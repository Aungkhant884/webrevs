{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-        modules\/jdk.crypto.ec\/sun\/security\/ec \\\n","filename":"make\/ZipSecurity.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-        COPY_DEBUG_SYMBOLS := false, \\\n+        COPY_DEBUG_SYMBOLS := $$(if $$($1_COPY_DEBUG_SYMBOLS_$$(name)),$$($1_COPY_DEBUG_SYMBOLS_$$(name)),false), \\\n","filename":"make\/common\/TestFilesCompilation.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-    jdk.crypto.ec \\\n","filename":"make\/conf\/docs-modules.conf","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,0 @@\n-    jdk.crypto.ec \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2007, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,1 +245,1 @@\n-                    value=\"-Xdebug -Xnoagent -Djava.compiler=none -Xrunjdwp:transport=dt_socket,address=${jpda.address}\"\n+                    value=\"-Xdebug -Xrunjdwp:transport=dt_socket,address=${jpda.address}\"\n","filename":"make\/ide\/netbeans\/langtools\/build.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -864,1 +864,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c libnativeStack.c exeGetCreatedJavaVMs.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c exeGetCreatedJavaVMs.c\n@@ -866,0 +866,2 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativeStack := jvm.lib\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_COPY_DEBUG_SYMBOLS_libnativeStack := true\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+const size_t pd_segfault_address = 1024;\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/jvmciCodeInstaller_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2973,0 +2973,17 @@\n+  \/\/ Big-endian 128-bit + 64-bit -> 128-bit addition.\n+  \/\/ Inputs: 128-bits. in is preserved.\n+  \/\/ The least-significant 64-bit word is in the upper dword of each vector.\n+  \/\/ inc (the 64-bit increment) is preserved. Its lower dword must be zero.\n+  \/\/ Output: result\n+  void be_add_128_64(FloatRegister result, FloatRegister in,\n+                     FloatRegister inc, FloatRegister tmp) {\n+    assert_different_registers(result, tmp, inc);\n+\n+    __ addv(result, __ T2D, in, inc);      \/\/ Add inc to the least-significant dword of\n+                                           \/\/ input\n+    __ cm(__ HI, tmp, __ T2D, inc, result);\/\/ Check for result overflowing\n+    __ ext(tmp, __ T16B, tmp, tmp, 0x08);  \/\/ Swap LSD of comparison result to MSD and\n+                                           \/\/ MSD == 0 (must be!) to LSD\n+    __ subv(result, __ T2D, result, tmp);  \/\/ Subtract -1 from MSD if there was an overflow\n+  }\n+\n@@ -3082,1 +3099,1 @@\n-      __ ins(v4, __ S, v5, 3, 3); \/\/ v4 contains { 0, 0, 0, 1 }\n+      __ ins(v4, __ S, v5, 2, 2); \/\/ v4 contains { 0, 1 }\n@@ -3084,5 +3101,8 @@\n-      __ ld1(v0, __ T16B, counter); \/\/ Load the counter into v0\n-      __ rev32(v16, __ T16B, v0);\n-      __ addv(v16, __ T4S, v16, v4);\n-      __ rev32(v16, __ T16B, v16);\n-      __ st1(v16, __ T16B, counter); \/\/ Save the incremented counter back\n+      \/\/ 128-bit big-endian increment\n+      __ ld1(v0, __ T16B, counter);\n+      __ rev64(v16, __ T16B, v0);\n+      be_add_128_64(v16, v16, v4, \/*tmp*\/v5);\n+      __ rev64(v16, __ T16B, v16);\n+      __ st1(v16, __ T16B, counter);\n+      \/\/ Previous counter value is in v0\n+      \/\/ v4 contains { 0, 1 }\n@@ -3120,3 +3140,3 @@\n-        __ rev32(v16, __ T16B, v16);\n-        __ addv(v16, __ T4S, v16, v4);\n-        __ rev32(v16, __ T16B, v16);\n+        __ rev64(v16, __ T16B, v16);\n+        be_add_128_64(v16, v16, v4, \/*tmp*\/v5);\n+        __ rev64(v16, __ T16B, v16);\n@@ -3170,1 +3190,1 @@\n-    __ rev32(v16, __ T16B, v0); \/\/ v16 contains byte-reversed counter\n+    __ rev64(v16, __ T16B, v0); \/\/ v16 contains byte-reversed counter\n@@ -3180,1 +3200,1 @@\n-      __ ins(v8, __ S, v9, 3, 3); \/\/ v8 contains { 0, 0, 0, 1 }\n+      __ ins(v8, __ S, v9, 2, 2); \/\/ v8 contains { 0, 1 }\n@@ -3184,2 +3204,2 @@\n-        __ rev32(v0_ofs, __ T16B, v16);\n-        __ addv(v16, __ T4S, v16, v8);\n+        __ rev64(v0_ofs, __ T16B, v16);\n+        be_add_128_64(v16, v16, v8, \/*tmp*\/v9);\n@@ -3215,1 +3235,1 @@\n-    __ rev32(v16, __ T16B, v16);\n+    __ rev64(v16, __ T16B, v16);\n@@ -7250,1 +7270,0 @@\n-    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n@@ -7279,0 +7298,1 @@\n+    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n@@ -7292,0 +7312,38 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  static RuntimeStub* generate_jfr_return_lease() {\n+    enum layout {\n+      rbp_off,\n+      rbpH_off,\n+      return_off,\n+      return_off2,\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    int insts_size = 1024;\n+    int locs_size = 64;\n+    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    MacroAssembler* _masm = masm;\n+\n+    address start = __ pc();\n+    __ enter();\n+    int frame_complete = __ pc() - start;\n+    address the_pc = __ pc();\n+    jfr_prologue(the_pc, _masm, rthread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+    jfr_epilogue(_masm);\n+\n+    __ leave();\n+    __ ret(lr);\n+\n+    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n@@ -8425,2 +8483,1 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n@@ -8429,0 +8486,9 @@\n+#if INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n+  }\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":83,"deletions":17,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+const size_t pd_segfault_address = 1024;\n","filename":"src\/hotspot\/cpu\/arm\/globalDefinitions_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3075,0 +3075,40 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  static RuntimeStub* generate_jfr_return_lease() {\n+    enum layout {\n+      r1_off,\n+      r2_off,\n+      return_off,\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+\n+    address start = __ pc();\n+    __ raw_push(R1, R2, LR);\n+    address the_pc = __ pc();\n+\n+    int frame_complete = the_pc - start;\n+\n+    __ set_last_Java_frame(SP, FP, true, Rtemp);\n+    __ mov(c_rarg0, Rthread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n+    __ reset_last_Java_frame(Rtemp);\n+\n+    __ raw_pop(R1, R2, LR);\n+    __ ret();\n+\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(framesize, 1);\n+    oop_maps->add_gc_map(frame_complete, map);\n+\n+    RuntimeStub* stub =\n+      RuntimeStub::new_runtime_stub(code.name(),\n+                                    &code,\n+                                    frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps,\n+                                    false);\n+    return stub;\n+  }\n+\n@@ -3119,2 +3159,1 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n@@ -3123,0 +3162,9 @@\n+#if INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n+  }\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+#ifdef AIX\n+const size_t pd_segfault_address = -1;\n+#else\n+const size_t pd_segfault_address = 1024;\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globalDefinitions_ppc.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4683,0 +4683,35 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  RuntimeStub* generate_jfr_return_lease() {\n+    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+    MacroAssembler* _masm = new MacroAssembler(&code);\n+\n+    Register tmp1 = R10_ARG8;\n+    Register tmp2 = R9_ARG7;\n+\n+    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+    address start = __ pc();\n+    __ mflr(tmp1);\n+    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+    __ push_frame_reg_args(0, tmp1);\n+    int frame_complete = __ pc() - start;\n+    __ set_last_Java_frame(R1_SP, noreg);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n+    address calls_return_pc = __ last_calls_return_pc();\n+    __ reset_last_Java_frame();\n+    __ pop_frame();\n+    __ ld(tmp1, _abi0(lr), R1_SP);\n+    __ mtlr(tmp1);\n+    __ blr();\n+\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(framesize, 0);\n+    oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(code.name(),\n+                                    &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n@@ -4731,2 +4766,1 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n@@ -4735,0 +4769,9 @@\n+#if INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n+  }\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2790,1 +2790,7 @@\n-    _slli(Rd, Rs1, shamt);                                                                   \\\n+    if (shamt != 0) {                                                                        \\\n+      _slli(Rd, Rs1, shamt);                                                                 \\\n+    } else {                                                                                 \\\n+      if (Rd != Rs1) {                                                                        \\\n+        addi(Rd, Rs1, 0);                                                                    \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n@@ -2805,1 +2811,7 @@\n-    NORMAL_NAME(Rd, Rs1, shamt);                                                             \\\n+    if (shamt != 0) {                                                                        \\\n+      NORMAL_NAME(Rd, Rs1, shamt);                                                           \\\n+    } else {                                                                                 \\\n+      if (Rd != Rs1) {                                                                        \\\n+        addi(Rd, Rs1, 0);                                                                    \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+const size_t pd_segfault_address = 1024;\n","filename":"src\/hotspot\/cpu\/riscv\/globalDefinitions_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2179,1 +2179,1 @@\n-  enc_class riscv_enc_li_imm(iRegIorL dst, immIorL src) %{\n+  enc_class riscv_enc_mov_imm(iRegIorL dst, immIorL src) %{\n@@ -4968,1 +4968,1 @@\n-  format %{ \"li $dst, $src\\t# int, #@loadConI\" %}\n+  format %{ \"mv $dst, $src\\t# int, #@loadConI\" %}\n@@ -4970,1 +4970,1 @@\n-  ins_encode(riscv_enc_li_imm(dst, src));\n+  ins_encode(riscv_enc_mov_imm(dst, src));\n@@ -4981,1 +4981,1 @@\n-  format %{ \"li $dst, $src\\t# long, #@loadConL\" %}\n+  format %{ \"mv $dst, $src\\t# long, #@loadConL\" %}\n@@ -4983,1 +4983,1 @@\n-  ins_encode(riscv_enc_li_imm(dst, src));\n+  ins_encode(riscv_enc_mov_imm(dst, src));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3926,1 +3926,0 @@\n-    __ resolve_global_jobject(x10, t0, t1);\n@@ -3955,0 +3954,1 @@\n+    __ resolve_global_jobject(x10, t0, t1);\n@@ -3968,0 +3968,38 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  static RuntimeStub* generate_jfr_return_lease() {\n+    enum layout {\n+      fp_off,\n+      fp_off2,\n+      return_off,\n+      return_off2,\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    int insts_size = 1024;\n+    int locs_size = 64;\n+    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    MacroAssembler* _masm = masm;\n+\n+    address start = __ pc();\n+    __ enter();\n+    int frame_complete = __ pc() - start;\n+    address the_pc = __ pc();\n+    jfr_prologue(the_pc, _masm, xthread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+\n+    jfr_epilogue(_masm);\n+    __ leave();\n+    __ ret();\n+\n+    OopMap* map = new OopMap(framesize, 1);\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n@@ -4011,2 +4049,1 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n@@ -4015,0 +4052,9 @@\n+#if INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n+  }\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -207,0 +207,7 @@\n+  \/\/ See JDK-8026049\n+  \/\/ This machine has fast unaligned memory accesses\n+  if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {\n+    FLAG_SET_DEFAULT(UseUnalignedAccesses,\n+      unaligned_access.value() == MISALIGNED_FAST);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+\/\/ All faults on s390x give the address only on page granularity.\n+\/\/ Set Pdsegfault_address to minimum one page address.\n+const size_t pd_segfault_address = 4096;\n+\n","filename":"src\/hotspot\/cpu\/s390\/globalDefinitions_s390.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3088,1 +3088,8 @@\n-  #endif \/\/ INCLUD_JFR\n+\n+  RuntimeStub* generate_jfr_return_lease() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  #endif \/\/ INCLUDE_JFR\n@@ -3136,2 +3143,9 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n+  }\n+\n+#if INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -3139,0 +3153,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -4434,0 +4434,8 @@\n+void Assembler::evpcmpuq(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n+  assert(VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x1E, (0xC0 | encode), vcc);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1809,0 +1809,2 @@\n+  void evpcmpuq(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+const size_t pd_segfault_address = 1024;\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -10032,0 +10033,11 @@\n+void MacroAssembler::evpaddq(XMMRegister dst, KRegister mask, XMMRegister nds, AddressLiteral src, bool merge, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::evpaddq(dst, mask, nds, as_Address(src), merge, vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::evpaddq(dst, mask, nds, Address(rscratch, 0), merge, vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1851,0 +1851,3 @@\n+  using Assembler::evpaddq;\n+  void evpaddq(XMMRegister dst, KRegister mask, XMMRegister nds, AddressLiteral src, bool merge, int vector_len, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/relocInfo_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4014,1 +4014,0 @@\n-    __ resolve_global_jobject(rax, java_thread, rdx);\n@@ -4047,0 +4046,1 @@\n+    __ resolve_global_jobject(rax, rdi, rdx);\n@@ -4060,0 +4060,41 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  static RuntimeStub* generate_jfr_return_lease() {\n+    enum layout {\n+      FPUState_off = 0,\n+      rbp_off = FPUStateSizeInWords,\n+      rdi_off,\n+      rsi_off,\n+      rcx_off,\n+      rbx_off,\n+      saved_argument_off,\n+      saved_argument_off2, \/\/ 2nd half of double\n+      framesize\n+    };\n+\n+    int insts_size = 1024;\n+    int locs_size = 64;\n+    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    MacroAssembler* _masm = masm;\n+\n+    address start = __ pc();\n+    __ enter();\n+    int frame_complete = __ pc() - start;\n+    address the_pc = __ pc();\n+    jfr_prologue(the_pc, _masm);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+    jfr_epilogue(_masm);\n+    __ leave();\n+    __ ret(0);\n+\n+    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n@@ -4151,2 +4192,1 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n@@ -4155,0 +4195,9 @@\n+#if INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n+  }\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":52,"deletions":3,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -3771,0 +3771,41 @@\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* StubGenerator::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n+  MacroAssembler* _masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n@@ -4124,2 +4165,1 @@\n-  JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-  JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+  JFR_ONLY(generate_jfr_stubs();)\n@@ -4128,0 +4168,9 @@\n+#if INCLUDE_JFR\n+void StubGenerator::generate_jfr_stubs() {\n+  StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+  StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+  StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+  StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -367,1 +367,2 @@\n-\n+  void ev_add128(XMMRegister xmmdst, XMMRegister xmmsrc1, XMMRegister xmmsrc2,\n+                 int vector_len, KRegister ktmp, Register rscratch = noreg);\n@@ -523,1 +524,1 @@\n-\n+  void generate_jfr_stubs();\n@@ -528,1 +529,2 @@\n-\n+  \/\/ For c2: call to runtime to return a buffer lease.\n+  RuntimeStub* generate_jfr_return_lease();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -124,0 +124,10 @@\n+ATTRIBUTE_ALIGNED(64) uint64_t COUNTER_MASK_ONES[] = {\n+    0x0000000000000000UL, 0x0000000000000001UL,\n+    0x0000000000000000UL, 0x0000000000000001UL,\n+    0x0000000000000000UL, 0x0000000000000001UL,\n+    0x0000000000000000UL, 0x0000000000000001UL,\n+};\n+static address counter_mask_ones_addr() {\n+  return (address)COUNTER_MASK_ONES;\n+}\n+\n@@ -1626,0 +1636,11 @@\n+\/\/ Add 128-bit integers in xmmsrc1 to xmmsrc2, then place the result in xmmdst.\n+\/\/ Clobber ktmp and rscratch.\n+\/\/ Used by aesctr_encrypt.\n+void StubGenerator::ev_add128(XMMRegister xmmdst, XMMRegister xmmsrc1, XMMRegister xmmsrc2,\n+                            int vector_len, KRegister ktmp, Register rscratch) {\n+  __ vpaddq(xmmdst, xmmsrc1, xmmsrc2, vector_len);\n+  __ evpcmpuq(ktmp, xmmdst, xmmsrc2, __ lt, vector_len);\n+  __ kshiftlbl(ktmp, ktmp, 1);\n+  __ evpaddq(xmmdst, ktmp, xmmdst, ExternalAddress(counter_mask_ones_addr()), \/*merge*\/true,\n+             vector_len, rscratch);\n+}\n@@ -2049,1 +2070,0 @@\n-\n@@ -2107,8 +2127,11 @@\n-  __ vpaddd(xmm8,  xmm8,  ExternalAddress(counter_mask_linc0_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n-  __ vpaddd(xmm9,  xmm8,  ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n-  __ vpaddd(xmm10, xmm9,  ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n-  __ vpaddd(xmm11, xmm10, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n-  __ vpaddd(xmm12, xmm11, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n-  __ vpaddd(xmm13, xmm12, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n-  __ vpaddd(xmm14, xmm13, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n-  __ vpaddd(xmm15, xmm14, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc0_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+  ev_add128(xmm8, xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+  __ evmovdquq(xmm19, ExternalAddress(counter_mask_linc4_addr()), Assembler::AVX_512bit, r15 \/*rscratch*\/);\n+  ev_add128(xmm9,  xmm8,  xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+  ev_add128(xmm10, xmm9,  xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+  ev_add128(xmm11, xmm10, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+  ev_add128(xmm12, xmm11, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+  ev_add128(xmm13, xmm12, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+  ev_add128(xmm14, xmm13, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+  ev_add128(xmm15, xmm14, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2162,1 +2185,1 @@\n-  __ vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm8,   xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2164,1 +2187,1 @@\n-  __ vpaddq(xmm9, xmm9, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm9,   xmm9, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2166,1 +2189,1 @@\n-  __ vpaddq(xmm10, xmm10, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm10, xmm10, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2168,1 +2191,1 @@\n-  __ vpaddq(xmm11, xmm11, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm11, xmm11, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2170,1 +2193,1 @@\n-  __ vpaddq(xmm12, xmm12, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm12, xmm12, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2172,1 +2195,1 @@\n-  __ vpaddq(xmm13, xmm13, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm13, xmm13, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2174,1 +2197,1 @@\n-  __ vpaddq(xmm14, xmm14, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm14, xmm14, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2176,1 +2199,1 @@\n-  __ vpaddq(xmm15, xmm15, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm15, xmm15, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2254,2 +2277,2 @@\n-  __ vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);\n-  __ vpaddq(xmm9, xmm9, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm8, xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n+  ev_add128(xmm9, xmm9, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2322,1 +2345,1 @@\n-  __ vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm8, xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2379,0 +2402,1 @@\n+\n@@ -2380,1 +2404,1 @@\n-  __ vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_512bit);\n+  ev_add128(xmm8, xmm8, xmm19, Assembler::AVX_512bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n@@ -2430,1 +2454,1 @@\n-  __ vpaddq(xmm8, xmm8, xmm19, Assembler::AVX_128bit);\n+  ev_add128(xmm8, xmm8, xmm19, Assembler::AVX_128bit, \/*ktmp*\/k1, r15 \/*rscratch*\/);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":46,"deletions":22,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -40,0 +40,7 @@\n+#if defined(AIX)\n+const size_t pd_segfault_address = -1;\n+#elif defined(S390)\n+const size_t pd_segfault_address = 4096;\n+#else\n+const size_t pd_segfault_address = 1024;\n+#endif\n","filename":"src\/hotspot\/cpu\/zero\/globalDefinitions_zero.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -831,1 +831,2 @@\n-    log_info(os, thread)(\"Number of threads approx. running in the VM: %d\", Threads::number_of_threads());\n+    log_warning(os, thread)(\"Number of threads approx. running in the VM: %d\", Threads::number_of_threads());\n+    log_warning(os, thread)(\"Checking JVM parameter MaxExpectedDataSegmentSize (currently \" SIZE_FORMAT \"k)  might be helpful\", MaxExpectedDataSegmentSize\/K);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"hugepages.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#include <dirent.h>\n+\n+StaticHugePageSupport::StaticHugePageSupport() :\n+  _initialized(false), _pagesizes(), _default_hugepage_size(SIZE_MAX) {}\n+\n+os::PageSizes StaticHugePageSupport::pagesizes() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _pagesizes;\n+}\n+\n+size_t StaticHugePageSupport::default_hugepage_size() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _default_hugepage_size;\n+}\n+\n+\/\/ Scan \/proc\/meminfo and return value of Hugepagesize\n+static size_t scan_default_hugepagesize() {\n+  size_t pagesize = 0;\n+\n+  \/\/ large_page_size on Linux is used to round up heap size. x86 uses either\n+  \/\/ 2M or 4M page, depending on whether PAE (Physical Address Extensions)\n+  \/\/ mode is enabled. AMD64\/EM64T uses 2M page in 64bit mode. IA64 can use\n+  \/\/ page as large as 1G.\n+  \/\/\n+  \/\/ Here we try to figure out page size by parsing \/proc\/meminfo and looking\n+  \/\/ for a line with the following format:\n+  \/\/    Hugepagesize:     2048 kB\n+  \/\/\n+  \/\/ If we can't determine the value (e.g. \/proc is not mounted, or the text\n+  \/\/ format has been changed), we'll set largest page size to 0\n+\n+  FILE *fp = os::fopen(\"\/proc\/meminfo\", \"r\");\n+  if (fp) {\n+    while (!feof(fp)) {\n+      int x = 0;\n+      char buf[16];\n+      if (fscanf(fp, \"Hugepagesize: %d\", &x) == 1) {\n+        if (x && fgets(buf, sizeof(buf), fp) && strcmp(buf, \" kB\\n\") == 0) {\n+          pagesize = x * K;\n+          break;\n+        }\n+      } else {\n+        \/\/ skip to next line\n+        for (;;) {\n+          int ch = fgetc(fp);\n+          if (ch == EOF || ch == (int)'\\n') break;\n+        }\n+      }\n+    }\n+    fclose(fp);\n+  }\n+\n+  return pagesize;\n+}\n+\n+\/\/ Given a file that contains a single (integral) number, return that number in (*out) and true;\n+\/\/ in case of an error, return false.\n+static bool read_number_file(const char* file, size_t* out) {\n+  FILE* f = ::fopen(file, \"r\");\n+  bool rc = false;\n+  if (f != nullptr) {\n+    uint64_t i = 0;\n+    if (::fscanf(f, SIZE_FORMAT, out) == 1) {\n+      rc = true;\n+    }\n+    ::fclose(f);\n+  }\n+  return rc;\n+}\n+\n+static const char* const sys_hugepages = \"\/sys\/kernel\/mm\/hugepages\";\n+\n+\/\/ Scan all directories in \/sys\/kernel\/mm\/hugepages\/hugepages-xxxx\n+\/\/ to discover the available page sizes\n+static os::PageSizes scan_hugepages() {\n+\n+  os::PageSizes pagesizes;\n+\n+  DIR *dir = opendir(sys_hugepages);\n+\n+  struct dirent *entry;\n+  size_t pagesize;\n+  while ((entry = readdir(dir)) != nullptr) {\n+    if (entry->d_type == DT_DIR &&\n+        sscanf(entry->d_name, \"hugepages-%zukB\", &pagesize) == 1) {\n+      \/\/ The kernel is using kB, hotspot uses bytes\n+      \/\/ Add each found Large Page Size to page_sizes\n+      pagesize *= K;\n+      pagesizes.add(pagesize);\n+    }\n+  }\n+  closedir(dir);\n+\n+  return pagesizes;\n+}\n+\n+void StaticHugePageSupport::print_on(outputStream* os) {\n+  if (_initialized) {\n+    os->print_cr(\"Static hugepage support:\");\n+    for (size_t s = _pagesizes.smallest(); s != 0; s = _pagesizes.next_larger(s)) {\n+      os->print_cr(\"  hugepage size: \" EXACTFMT, EXACTFMTARGS(s));\n+    }\n+    os->print_cr(\"  default hugepage size: \" EXACTFMT, EXACTFMTARGS(_default_hugepage_size));\n+  } else {\n+    os->print_cr(\"  unknown.\");\n+  }\n+}\n+\n+void StaticHugePageSupport::scan_os() {\n+  _pagesizes = scan_hugepages();\n+  _default_hugepage_size = scan_default_hugepagesize();\n+  assert(_pagesizes.contains(_default_hugepage_size),\n+         \"Unexpected configuration: default pagesize (\" SIZE_FORMAT \") \"\n+         \"has no associated directory in \/sys\/kernel\/mm\/hugepages..\", _default_hugepage_size);\n+  _initialized = true;\n+  LogTarget(Info, pagesize) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    print_on(&ls);\n+  }\n+}\n+\n+THPSupport::THPSupport() :\n+    _initialized(false), _mode(THPMode::never), _pagesize(SIZE_MAX) {}\n+\n+\n+THPMode THPSupport::mode() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _mode;\n+}\n+\n+size_t THPSupport::pagesize() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _pagesize;\n+}\n+\n+void THPSupport::scan_os() {\n+  \/\/ Scan \/sys\/kernel\/mm\/transparent_hugepage\/enabled\n+  \/\/ see mm\/huge_memory.c\n+  _mode = THPMode::never;\n+  const char* filename = \"\/sys\/kernel\/mm\/transparent_hugepage\/enabled\";\n+  FILE* f = ::fopen(filename, \"r\");\n+  if (f != nullptr) {\n+    char buf[64];\n+    char* s = fgets(buf, sizeof(buf), f);\n+    assert(s == buf, \"Should have worked\");\n+    if (::strstr(buf, \"[madvise]\") != nullptr) {\n+      _mode = THPMode::madvise;\n+    } else if (::strstr(buf, \"[always]\") != nullptr) {\n+      _mode = THPMode::always;\n+    } else {\n+      assert(::strstr(buf, \"[never]\") != nullptr, \"Weird content of %s: %s\", filename, buf);\n+    }\n+    fclose(f);\n+  }\n+\n+  \/\/ Scan large page size for THP from hpage_pmd_size\n+  _pagesize = 0;\n+  if (read_number_file(\"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pmd_size\", &_pagesize)) {\n+    assert(_pagesize > 0, \"Expected\");\n+  }\n+  _initialized = true;\n+\n+  LogTarget(Info, pagesize) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    print_on(&ls);\n+  }\n+}\n+\n+void THPSupport::print_on(outputStream* os) {\n+  if (_initialized) {\n+    os->print_cr(\"Transparent hugepage (THP) support:\");\n+    os->print_cr(\"  THP mode: %s\",\n+        (_mode == THPMode::always ? \"always\" : (_mode == THPMode::never ? \"never\" : \"madvise\")));\n+    os->print_cr(\"  THP pagesize: \" EXACTFMT, EXACTFMTARGS(_pagesize));\n+  } else {\n+    os->print_cr(\"  unknown.\");\n+  }\n+}\n+\n+StaticHugePageSupport HugePages::_static_hugepage_support;\n+THPSupport HugePages::_thp_support;\n+\n+void HugePages::initialize() {\n+  _static_hugepage_support.scan_os();\n+  _thp_support.scan_os();\n+}\n+\n+void HugePages::print_on(outputStream* os) {\n+  _static_hugepage_support.print_on(os);\n+  _thp_support.print_on(os);\n+}\n","filename":"src\/hotspot\/os\/linux\/hugepages.cpp","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_HUGEPAGES_HPP\n+#define OS_LINUX_HUGEPAGES_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/os.hpp\" \/\/ for os::PageSizes\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+\/\/ Header contains the interface that reads OS information about\n+\/\/ available hugepage support:\n+\/\/ - class StaticHugePageSupport - about static (non-THP) hugepages\n+\/\/ - class THPSupport - about transparent huge pages\n+\/\/ and:\n+\/\/ - class HugePages - a static umbrella wrapper\n+\n+\/\/ Information about static (non-thp) hugepages\n+class StaticHugePageSupport {\n+  bool _initialized;\n+\n+  \/\/ All supported hugepage sizes (sizes for which entries exist\n+  \/\/ in \/sys\/kernel\/mm\/hugepages\/hugepage-xxx)\n+  os::PageSizes _pagesizes;\n+\n+  \/\/ Contains the default hugepage. The \"default hugepage size\" is the one that\n+  \/\/ - is marked in \/proc\/meminfo as \"Hugepagesize\"\n+  \/\/ - is the size one gets when using mmap(MAP_HUGETLB) when omitting size specifiers like MAP_HUGE_SHIFT)\n+  size_t _default_hugepage_size;\n+\n+public:\n+  StaticHugePageSupport();\n+\n+  void scan_os();\n+\n+  os::PageSizes pagesizes() const;\n+  size_t default_hugepage_size() const;\n+  void print_on(outputStream* os);\n+};\n+\n+enum class THPMode { always, never, madvise };\n+\n+\/\/ 2) for transparent hugepages\n+class THPSupport {\n+  bool _initialized;\n+\n+  \/\/ See \/sys\/kernel\/mm\/transparent_hugepages\/enabled\n+  THPMode _mode;\n+\n+  \/\/ Contains the THP page size\n+  size_t _pagesize;\n+\n+public:\n+\n+  THPSupport();\n+\n+  \/\/ Queries the OS, fills in object\n+  void scan_os();\n+\n+  THPMode mode() const;\n+  size_t pagesize() const;\n+  void print_on(outputStream* os);\n+};\n+\n+\/\/ Umbrella static interface\n+class HugePages : public AllStatic {\n+\n+  static StaticHugePageSupport _static_hugepage_support;\n+  static THPSupport _thp_support;\n+\n+public:\n+\n+  static const StaticHugePageSupport& static_info() { return _static_hugepage_support; }\n+  static const THPSupport& thp_info() { return _thp_support; }\n+\n+  static size_t default_static_hugepage_size()  { return _static_hugepage_support.default_hugepage_size(); }\n+  static bool supports_static_hugepages()       { return default_static_hugepage_size() > 0; }\n+  static THPMode thp_mode()                     { return _thp_support.mode(); }\n+  static bool supports_thp()                    { return thp_mode() == THPMode::madvise || thp_mode() == THPMode::always; }\n+  static size_t thp_pagesize()                  { return _thp_support.pagesize(); }\n+\n+  static void initialize();\n+  static void print_on(outputStream* os);\n+};\n+\n+#endif \/\/ OS_LINUX_HUGEPAGES_HPP\n","filename":"src\/hotspot\/os\/linux\/hugepages.hpp","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"hugepages.hpp\"\n@@ -173,1 +174,0 @@\n-size_t os::Linux::_default_large_page_size = 0;\n@@ -936,1 +936,1 @@\n-  size_t default_large_page_size = os::Linux::default_large_page_size();\n+  size_t default_large_page_size = HugePages::default_static_hugepage_size();\n@@ -3559,1 +3559,1 @@\n-  if (page_size != default_large_page_size()) {\n+  if (page_size != HugePages::default_static_hugepage_size()) {\n@@ -3667,73 +3667,0 @@\n-static size_t scan_default_large_page_size() {\n-  size_t default_large_page_size = 0;\n-\n-  \/\/ large_page_size on Linux is used to round up heap size. x86 uses either\n-  \/\/ 2M or 4M page, depending on whether PAE (Physical Address Extensions)\n-  \/\/ mode is enabled. AMD64\/EM64T uses 2M page in 64bit mode. IA64 can use\n-  \/\/ page as large as 1G.\n-  \/\/\n-  \/\/ Here we try to figure out page size by parsing \/proc\/meminfo and looking\n-  \/\/ for a line with the following format:\n-  \/\/    Hugepagesize:     2048 kB\n-  \/\/\n-  \/\/ If we can't determine the value (e.g. \/proc is not mounted, or the text\n-  \/\/ format has been changed), we'll set largest page size to 0\n-\n-  FILE *fp = os::fopen(\"\/proc\/meminfo\", \"r\");\n-  if (fp) {\n-    while (!feof(fp)) {\n-      int x = 0;\n-      char buf[16];\n-      if (fscanf(fp, \"Hugepagesize: %d\", &x) == 1) {\n-        if (x && fgets(buf, sizeof(buf), fp) && strcmp(buf, \" kB\\n\") == 0) {\n-          default_large_page_size = x * K;\n-          break;\n-        }\n-      } else {\n-        \/\/ skip to next line\n-        for (;;) {\n-          int ch = fgetc(fp);\n-          if (ch == EOF || ch == (int)'\\n') break;\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n-\n-  return default_large_page_size;\n-}\n-\n-static os::PageSizes scan_multiple_page_support() {\n-  \/\/ Scan \/sys\/kernel\/mm\/hugepages\n-  \/\/ to discover the available page sizes\n-  const char* sys_hugepages = \"\/sys\/kernel\/mm\/hugepages\";\n-  os::PageSizes page_sizes;\n-\n-  DIR *dir = opendir(sys_hugepages);\n-\n-  struct dirent *entry;\n-  size_t page_size;\n-  while ((entry = readdir(dir)) != nullptr) {\n-    if (entry->d_type == DT_DIR &&\n-        sscanf(entry->d_name, \"hugepages-%zukB\", &page_size) == 1) {\n-      \/\/ The kernel is using kB, hotspot uses bytes\n-      \/\/ Add each found Large Page Size to page_sizes\n-      page_sizes.add(page_size * K);\n-    }\n-  }\n-  closedir(dir);\n-\n-  LogTarget(Debug, pagesize) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"Large Page sizes: \");\n-    page_sizes.print_on(&ls);\n-  }\n-\n-  return page_sizes;\n-}\n-\n-size_t os::Linux::default_large_page_size() {\n-  return _default_large_page_size;\n-}\n-\n@@ -3792,0 +3719,18 @@\n+struct LargePageInitializationLoggerMark {\n+  ~LargePageInitializationLoggerMark() {\n+    LogTarget(Info, pagesize) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      if (UseLargePages) {\n+        ls.print_cr(\"UseLargePages=1, UseTransparentHugePages=%d, UseHugeTLBFS=%d, UseSHM=%d\",\n+                    UseTransparentHugePages, UseHugeTLBFS, UseSHM);\n+        ls.print(\"Large page support enabled. Usable page sizes: \");\n+        os::page_sizes().print_on(&ls);\n+        ls.print_cr(\". Default large page size: \" EXACTFMT \".\", EXACTFMTARGS(os::large_page_size()));\n+      } else {\n+        ls.print(\"Large page support disabled.\");\n+      }\n+    }\n+  }\n+};\n+\n@@ -3793,3 +3738,4 @@\n-  \/\/ Always initialize the default large page size even if large pages are not being used.\n-  size_t default_large_page_size = scan_default_large_page_size();\n-  os::Linux::_default_large_page_size = default_large_page_size;\n+  LargePageInitializationLoggerMark logger;\n+\n+  \/\/ Query OS information first.\n+  HugePages::initialize();\n@@ -3816,1 +3762,2 @@\n-  if (default_large_page_size == 0) {\n+  if ( ( UseTransparentHugePages && HugePages::supports_thp() == false) ||\n+       (!UseTransparentHugePages && HugePages::supports_static_hugepages() == false) ) {\n@@ -3825,19 +3772,10 @@\n-  os::PageSizes all_large_pages = scan_multiple_page_support();\n-\n-  \/\/ 3) Consistency check and post-processing\n-\n-  \/\/ It is unclear if \/sys\/kernel\/mm\/hugepages\/ and \/proc\/meminfo could disagree. Manually\n-  \/\/ re-add the default page size to the list of page sizes to be sure.\n-  all_large_pages.add(default_large_page_size);\n-\n-  \/\/ Check LargePageSizeInBytes matches an available page size and if so set _large_page_size\n-  \/\/ using LargePageSizeInBytes as the maximum allowed large page size. If LargePageSizeInBytes\n-  \/\/ doesn't match an available page size set _large_page_size to default_large_page_size\n-  \/\/ and use it as the maximum.\n- if (FLAG_IS_DEFAULT(LargePageSizeInBytes) ||\n-      LargePageSizeInBytes == 0 ||\n-      LargePageSizeInBytes == default_large_page_size) {\n-    _large_page_size = default_large_page_size;\n-    log_info(pagesize)(\"Using the default large page size: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_exact_unit(_large_page_size),\n-                       exact_unit_for_byte_size(_large_page_size));\n+\n+  if (UseTransparentHugePages) {\n+    \/\/ In THP mode:\n+    \/\/ - os::large_page_size() is the *THP page size*\n+    \/\/ - os::pagesizes() has two members, the THP page size and the system page size\n+    assert(HugePages::supports_thp() && HugePages::thp_pagesize() > 0, \"Missing OS info\");\n+    _large_page_size = HugePages::thp_pagesize();\n+    _page_sizes.add(_large_page_size);\n+    _page_sizes.add(os::vm_page_size());\n+\n@@ -3845,9 +3783,17 @@\n-    if (all_large_pages.contains(LargePageSizeInBytes)) {\n-      _large_page_size = LargePageSizeInBytes;\n-      log_info(pagesize)(\"Overriding default large page size (\" SIZE_FORMAT \"%s) \"\n-                         \"using LargePageSizeInBytes: \" SIZE_FORMAT \"%s\",\n-                         byte_size_in_exact_unit(default_large_page_size),\n-                         exact_unit_for_byte_size(default_large_page_size),\n-                         byte_size_in_exact_unit(_large_page_size),\n-                         exact_unit_for_byte_size(_large_page_size));\n-    } else {\n+\n+    \/\/ In static hugepage mode:\n+    \/\/ - os::large_page_size() is the default static hugepage size (\/proc\/meminfo \"Hugepagesize\")\n+    \/\/ - os::pagesizes() contains all hugepage sizes the kernel supports, regardless whether there\n+    \/\/   are pages configured in the pool or not (from \/sys\/kernel\/hugepages\/hugepage-xxxx ...)\n+    os::PageSizes all_large_pages = HugePages::static_info().pagesizes();\n+    const size_t default_large_page_size = HugePages::default_static_hugepage_size();\n+\n+    \/\/ 3) Consistency check and post-processing\n+\n+    \/\/ Check LargePageSizeInBytes matches an available page size and if so set _large_page_size\n+    \/\/ using LargePageSizeInBytes as the maximum allowed large page size. If LargePageSizeInBytes\n+    \/\/ doesn't match an available page size set _large_page_size to default_large_page_size\n+    \/\/ and use it as the maximum.\n+   if (FLAG_IS_DEFAULT(LargePageSizeInBytes) ||\n+        LargePageSizeInBytes == 0 ||\n+        LargePageSizeInBytes == default_large_page_size) {\n@@ -3855,4 +3801,1 @@\n-      log_info(pagesize)(\"LargePageSizeInBytes is not a valid large page size (\" SIZE_FORMAT \"%s) \"\n-                         \"using the default large page size: \" SIZE_FORMAT \"%s\",\n-                         byte_size_in_exact_unit(LargePageSizeInBytes),\n-                         exact_unit_for_byte_size(LargePageSizeInBytes),\n+      log_info(pagesize)(\"Using the default large page size: \" SIZE_FORMAT \"%s\",\n@@ -3861,0 +3804,18 @@\n+    } else {\n+      if (all_large_pages.contains(LargePageSizeInBytes)) {\n+        _large_page_size = LargePageSizeInBytes;\n+        log_info(pagesize)(\"Overriding default large page size (\" SIZE_FORMAT \"%s) \"\n+                           \"using LargePageSizeInBytes: \" SIZE_FORMAT \"%s\",\n+                           byte_size_in_exact_unit(default_large_page_size),\n+                           exact_unit_for_byte_size(default_large_page_size),\n+                           byte_size_in_exact_unit(_large_page_size),\n+                           exact_unit_for_byte_size(_large_page_size));\n+      } else {\n+        _large_page_size = default_large_page_size;\n+        log_info(pagesize)(\"LargePageSizeInBytes is not a valid large page size (\" SIZE_FORMAT \"%s) \"\n+                           \"using the default large page size: \" SIZE_FORMAT \"%s\",\n+                           byte_size_in_exact_unit(LargePageSizeInBytes),\n+                           exact_unit_for_byte_size(LargePageSizeInBytes),\n+                           byte_size_in_exact_unit(_large_page_size),\n+                           exact_unit_for_byte_size(_large_page_size));\n+      }\n@@ -3862,1 +3823,0 @@\n-  }\n@@ -3864,12 +3824,6 @@\n-  \/\/ Populate _page_sizes with large page sizes less than or equal to\n-  \/\/ _large_page_size.\n-  for (size_t page_size = _large_page_size; page_size != 0;\n-         page_size = all_large_pages.next_smaller(page_size)) {\n-    _page_sizes.add(page_size);\n-  }\n-\n-  LogTarget(Info, pagesize) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"Usable page sizes: \");\n-    _page_sizes.print_on(&ls);\n+    \/\/ Populate _page_sizes with large page sizes less than or equal to\n+    \/\/ _large_page_size.\n+    for (size_t page_size = _large_page_size; page_size != 0;\n+           page_size = all_large_pages.next_smaller(page_size)) {\n+      _page_sizes.add(page_size);\n+    }\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":79,"deletions":125,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -52,2 +52,0 @@\n-  static size_t _default_large_page_size;\n-\n@@ -80,4 +78,0 @@\n-  static size_t default_large_page_size();\n-  static size_t scan_default_large_page_size();\n-  static os::PageSizes scan_multiple_page_support();\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -579,0 +579,5 @@\n+bool SymbolEngine::refreshModuleList() {\n+  SymbolEngineEntry entry_guard;\n+  return WindowsDbgHelp::symRefreshModuleList(::GetCurrentProcess());\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/symbolengine.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+  \/\/ Refresh the list of loaded modules e.g. pick up any newly loaded dll's\n+  \/\/ since VM initialization.\n+  \/\/ Returns true for success, false for error.\n+  bool refreshModuleList();\n+\n","filename":"src\/hotspot\/os\/windows\/symbolengine.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+typedef BOOL  (WINAPI *pfn_SymRefreshModuleList)(HANDLE);\n@@ -71,1 +72,2 @@\n- DO(SymGetLineFromAddr64)\n+ DO(SymGetLineFromAddr64) \\\n+ DO(SymRefreshModuleList)\n@@ -208,0 +210,8 @@\n+BOOL WindowsDbgHelp::symRefreshModuleList(HANDLE hProcess) {\n+  WindowsDbgHelpEntry entry_guard;\n+  if (g_pfn_SymRefreshModuleList != nullptr) {\n+    return g_pfn_SymRefreshModuleList(hProcess);\n+  }\n+  return FALSE;\n+}\n+\n@@ -304,1 +314,0 @@\n-\n","filename":"src\/hotspot\/os\/windows\/windbghelp.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+  BOOL symRefreshModuleList(HANDLE hProcess);\n","filename":"src\/hotspot\/os\/windows\/windbghelp.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -247,0 +247,3 @@\n+  \/\/ Ensure we consider dynamically loaded dll's\n+  SymbolEngine::refreshModuleList();\n+\n@@ -268,0 +271,2 @@\n+        } else {\n+          st->print(\"  (no source info available)\");\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+ , _loop(nullptr)\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -489,4 +489,0 @@\n-#ifdef JFR_HAVE_INTRINSICS\n-  void do_getEventWriter(Intrinsic* x);\n-#endif\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,1 +231,2 @@\n-    } else if (y->type()->as_IntConstant() && y->type()->as_IntConstant()->value() != 0) {\n+    } else if (x_bound->has_lower() && x_bound->lower() >= 0 && y->type()->as_IntConstant() &&\n+               y->type()->as_IntConstant()->value() != 0 && y->type()->as_IntConstant()->value() != min_jint) {\n@@ -235,1 +236,1 @@\n-      \/\/ % operator follows from this rule that the result of the remainder operation can be negative only\n+      \/\/ It follows from this rule that the result of the remainder operation can be negative only\n@@ -237,1 +238,1 @@\n-      \/\/ magnitude of the result is always less than the magnitude of the divisor(See JLS 15.17.3).\n+      \/\/ magnitude of the result is always less than the magnitude of the divisor (see JLS 15.17.3).\n@@ -244,5 +245,3 @@\n-      if (x_bound->has_lower() && x_bound->lower() >= 0) {\n-        _bound = new Bound(0, nullptr, y->type()->as_IntConstant()->value() - 1, nullptr);\n-      } else {\n-        _bound = new Bound();\n-      }\n+      \/\/\n+      \/\/ Use the absolute value of y as an upper bound. Skip min_jint because abs(min_jint) is undefined.\n+      _bound = new Bound(0, nullptr, abs(y->type()->as_IntConstant()->value()) - 1, nullptr);\n@@ -273,11 +272,7 @@\n-          \/\/ TODO: consider using __builtin_add_overflow\n-          jlong new_lowerl = ((jlong)bound->lower()) + const_value;\n-          jint new_lower = low(new_lowerl);\n-          jlong new_upperl = ((jlong)bound->upper()) + const_value;\n-          jint new_upper = low(new_upperl);\n-\n-          if (((jlong)new_lower) == new_lowerl && ((jlong)new_upper == new_upperl)) {\n-            Bound *newBound = new Bound(new_lower, bound->lower_instr(), new_upper, bound->upper_instr());\n-            _bound = newBound;\n-          } else {\n-            \/\/ overflow\n+          jint t_lo = bound->lower();\n+          jint t_hi = bound->upper();\n+          jint new_lower = java_add(t_lo, const_value);\n+          jint new_upper = java_add(t_hi, const_value);\n+          bool overflow = ((const_value < 0 && (new_lower > t_lo)) ||\n+                           (const_value > 0 && (new_upper < t_hi)));\n+          if (overflow) {\n@@ -285,0 +280,2 @@\n+          } else {\n+            _bound = new Bound(new_lower, bound->lower_instr(), new_upper, bound->upper_instr());\n@@ -1558,1 +1555,0 @@\n-      \/\/ TODO: Check that add operation does not overflow!\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  product(int, ArchiveRelocationMode, 0, DIAGNOSTIC,                        \\\n+  product(int, ArchiveRelocationMode, 1, DIAGNOSTIC,                        \\\n@@ -93,2 +93,2 @@\n-           \"unsuccessful, map at alternative address (default); \"           \\\n-           \"(1) always map at alternative address; \"                        \\\n+           \"unsuccessful, map at alternative address; \"                     \\\n+           \"(1) always map at alternative address (default); \"              \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n@@ -1257,0 +1257,1 @@\n+#ifdef _LP64\n@@ -1261,0 +1262,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-enum {\n+enum : uint {\n@@ -70,1 +70,1 @@\n-    enum {\n+    enum : uint {\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/stackValue.hpp\"\n@@ -83,0 +84,14 @@\n+ScopeValue* DebugInfoReadStream::read_object_merge_value() {\n+  int id = read_int();\n+#ifdef ASSERT\n+  assert(_obj_pool != nullptr, \"object pool does not exist\");\n+  for (int i = _obj_pool->length() - 1; i >= 0; i--) {\n+    assert(_obj_pool->at(i)->as_ObjectValue()->id() != id, \"should not be read twice\");\n+  }\n+#endif\n+  ObjectMergeValue* result = new ObjectMergeValue(id);\n+  _obj_pool->push(result);\n+  result->read_object(this);\n+  return result;\n+}\n+\n@@ -101,1 +116,2 @@\n-                          AUTO_BOX_OBJECT_CODE = 7, MARKER_CODE = 8 };\n+                          AUTO_BOX_OBJECT_CODE = 7, MARKER_CODE = 8,\n+                          OBJECT_MERGE_CODE = 9 };\n@@ -113,0 +129,1 @@\n+   case OBJECT_MERGE_CODE:    result = stream->read_object_merge_value();                break;\n@@ -152,0 +169,1 @@\n+  _is_root = stream->read_bool();\n@@ -170,0 +188,1 @@\n+    stream->write_bool(_is_root);\n@@ -185,1 +204,1 @@\n-  st->print(\"%s[%d]\", is_auto_box() ? \"box_obj\" : \"obj\", _id);\n+  st->print(\"%s[%d]\", is_auto_box() ? \"box_obj\" : is_object_merge() ? \"merge_obj\" : \"obj\", _id);\n@@ -190,6 +209,28 @@\n-  if (_field_values.length() > 0) {\n-    _field_values.at(0)->print_on(st);\n-  }\n-  for (int i = 1; i < _field_values.length(); i++) {\n-    st->print(\", \");\n-    _field_values.at(i)->print_on(st);\n+  if (is_object_merge()) {\n+    ObjectMergeValue* omv = (ObjectMergeValue*)this;\n+    st->print(\"selector=\\\"\");\n+    omv->selector()->print_on(st);\n+    st->print(\"\\\"\");\n+    ScopeValue* merge_pointer = omv->merge_pointer();\n+    if (!(merge_pointer->is_object() && merge_pointer->as_ObjectValue()->value()() == nullptr) &&\n+        !(merge_pointer->is_constant_oop() && merge_pointer->as_ConstantOopReadValue()->value()() == nullptr)) {\n+      st->print(\", merge_pointer=\\\"\");\n+      merge_pointer->print_on(st);\n+      st->print(\"\\\"\");\n+    }\n+    GrowableArray<ScopeValue*>* possible_objects = omv->possible_objects();\n+    st->print(\", candidate_objs=[%d\", possible_objects->at(0)->as_ObjectValue()->id());\n+    int ncandidates = possible_objects->length();\n+    for (int i = 1; i < ncandidates; i++) {\n+      st->print(\", %d\", possible_objects->at(i)->as_ObjectValue()->id());\n+    }\n+    st->print(\"]\");\n+  } else {\n+    st->print(\"\\n        Fields: \");\n+    if (_field_values.length() > 0) {\n+      _field_values.at(0)->print_on(st);\n+    }\n+    for (int i = 1; i < _field_values.length(); i++) {\n+      st->print(\", \");\n+      _field_values.at(i)->print_on(st);\n+    }\n@@ -200,0 +241,63 @@\n+\n+\/\/ ObjectMergeValue\n+\n+\/\/ Returns the ObjectValue that should be used for the local that this\n+\/\/ ObjectMergeValue represents. ObjectMergeValue represents allocation\n+\/\/ merges in C2. This method will select which path the allocation merge\n+\/\/ took during execution of the Trap that triggered the rematerialization\n+\/\/ of the object.\n+ObjectValue* ObjectMergeValue::select(frame& fr, RegisterMap& reg_map) {\n+  StackValue* sv_selector = StackValue::create_stack_value(&fr, &reg_map, _selector);\n+  jint selector = sv_selector->get_int();\n+\n+  \/\/ If the selector is '-1' it means that execution followed the path\n+  \/\/ where no scalar replacement happened.\n+  \/\/ Otherwise, it is the index in _possible_objects array that holds\n+  \/\/ the description of the scalar replaced object.\n+  if (selector == -1) {\n+    StackValue* sv_merge_pointer = StackValue::create_stack_value(&fr, &reg_map, _merge_pointer);\n+    _selected = new ObjectValue(id());\n+\n+    \/\/ Retrieve the pointer to the real object and use it as if we had\n+    \/\/ allocated it during the deoptimization\n+    _selected->set_value(sv_merge_pointer->get_obj()());\n+\n+    \/\/ No need to rematerialize\n+    return nullptr;\n+  } else {\n+    assert(selector < _possible_objects.length(), \"sanity\");\n+    _selected = (ObjectValue*) _possible_objects.at(selector);\n+    return _selected;\n+  }\n+}\n+\n+void ObjectMergeValue::read_object(DebugInfoReadStream* stream) {\n+  _selector = read_from(stream);\n+  _merge_pointer = read_from(stream);\n+  int ncandidates = stream->read_int();\n+  for (int i = 0; i < ncandidates; i++) {\n+    ScopeValue* result = read_from(stream);\n+    assert(result->is_object(), \"Candidate is not an object!\");\n+    ObjectValue* obj = result->as_ObjectValue();\n+    _possible_objects.append(obj);\n+  }\n+}\n+\n+void ObjectMergeValue::write_on(DebugInfoWriteStream* stream) {\n+  if (is_visited()) {\n+    stream->write_int(OBJECT_ID_CODE);\n+    stream->write_int(_id);\n+  } else {\n+    set_visited(true);\n+    stream->write_int(OBJECT_MERGE_CODE);\n+    stream->write_int(_id);\n+    _selector->write_on(stream);\n+    _merge_pointer->write_on(stream);\n+    int ncandidates = _possible_objects.length();\n+    stream->write_int(ncandidates);\n+    for (int i = 0; i < ncandidates; i++) {\n+      _possible_objects.at(i)->as_ObjectValue()->write_on(stream);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":112,"deletions":8,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class ObjectMergeValue;\n@@ -53,0 +54,1 @@\n+  virtual bool is_object_merge() const { return false; }\n@@ -76,0 +78,5 @@\n+  ObjectMergeValue* as_ObjectMergeValue() {\n+    assert(is_object_merge(), \"must be\");\n+    return (ObjectMergeValue*)this;\n+  }\n+\n@@ -130,0 +137,4 @@\n+  bool                       _is_root;   \/\/ Will be true if this object is referred to\n+                                         \/\/ as a local\/expression\/monitor in the JVMs.\n+                                         \/\/ Otherwise false, meaning it's just a candidate\n+                                         \/\/ in an object allocation merge.\n@@ -137,1 +148,2 @@\n-     , _visited(false) {\n+     , _visited(false)\n+     , _is_root(true) {\n@@ -144,1 +156,1 @@\n-     , _is_init(nullptr)\n+     , _is_init(new MarkerValue())\n@@ -147,1 +159,2 @@\n-     , _visited(false) {}\n+     , _visited(false)\n+     , _is_root(true) {}\n@@ -150,13 +163,16 @@\n-  bool                        is_object() const         { return true; }\n-  int                         id() const                { return _id; }\n-  ScopeValue*                 klass() const             { return _klass; }\n-  ScopeValue*                 is_init() const           { return _is_init; }\n-  GrowableArray<ScopeValue*>* field_values()            { return &_field_values; }\n-  ScopeValue*                 field_at(int i) const     { return _field_values.at(i); }\n-  int                         field_size()              { return _field_values.length(); }\n-  Handle                      value() const             { return _value; }\n-  bool                        is_visited() const        { return _visited; }\n-  bool                        maybe_null() const        { return !_is_init->is_marker(); }\n-\n-  void                        set_value(oop value);\n-  void                        set_visited(bool visited) { _visited = visited; }\n+  bool                        is_object() const           { return true; }\n+  int                         id() const                  { return _id; }\n+  virtual ScopeValue*         klass() const               { return _klass; }\n+  virtual ScopeValue*         is_init() const             { return _is_init; }\n+  virtual GrowableArray<ScopeValue*>* field_values()      { return &_field_values; }\n+  virtual ScopeValue*         field_at(int i) const       { return _field_values.at(i); }\n+  virtual int                 field_size()                { return _field_values.length(); }\n+  virtual Handle              value() const               { return _value; }\n+  bool                        is_visited() const          { return _visited; }\n+  bool                        is_root() const             { return _is_root; }\n+  bool                        maybe_null() const          { return !_is_init->is_marker(); }\n+\n+  void                        set_id(int id)              { _id = id; }\n+  virtual void                set_value(oop value);\n+  void                        set_visited(bool visited)   { _visited = visited; }\n+  void                        set_root(bool root)         { _is_root = root; }\n@@ -173,0 +189,59 @@\n+\/\/ An ObjectMergeValue describes objects that were inputs to a Phi in C2 and at\n+\/\/ least one of them was scalar replaced.\n+\/\/ '_selector' is an integer value that will be '-1' if during the execution of\n+\/\/ the C2 compiled code the path taken was that of the Phi input that was NOT\n+\/\/ scalar replaced. In that case '_merge_pointer' is a pointer to an already\n+\/\/ allocated object. If '_selector' is not '-1' then it should be the index of\n+\/\/ an object in '_possible_objects'. That object is an ObjectValue describing an\n+\/\/ object that was scalar replaced.\n+\n+class ObjectMergeValue: public ObjectValue {\n+protected:\n+  ScopeValue*                _selector;\n+  ScopeValue*                _merge_pointer;\n+  GrowableArray<ScopeValue*> _possible_objects;\n+\n+  \/\/ This holds the ObjectValue that should be used in place of this\n+  \/\/ ObjectMergeValue. I.e., it's the ScopeValue from _possible_objects that was\n+  \/\/ selected by 'select()' or is a on-the-fly created ScopeValue representing\n+  \/\/ the _merge_pointer if _selector is -1.\n+  \/\/\n+  \/\/ We need to keep this reference around because there will be entries in\n+  \/\/ ScopeDesc that reference this ObjectMergeValue directly. After\n+  \/\/ rematerialization ObjectMergeValue will be just a wrapper for the\n+  \/\/ Objectvalue pointed by _selected.\n+  ObjectValue*               _selected;\n+public:\n+  ObjectMergeValue(int id, ScopeValue* merge_pointer, ScopeValue* selector)\n+     : ObjectValue(id)\n+     , _selector(selector)\n+     , _merge_pointer(merge_pointer)\n+     , _possible_objects()\n+     , _selected(nullptr) {}\n+\n+  ObjectMergeValue(int id)\n+     : ObjectValue(id)\n+     , _selector(nullptr)\n+     , _merge_pointer(nullptr)\n+     , _possible_objects()\n+     , _selected(nullptr) {}\n+\n+  bool                        is_object_merge() const         { return true; }\n+  ScopeValue*                 selector() const                { return _selector; }\n+  ScopeValue*                 merge_pointer() const           { return _merge_pointer; }\n+  GrowableArray<ScopeValue*>* possible_objects()              { return &_possible_objects; }\n+  ObjectValue*                select(frame& fr, RegisterMap& reg_map) ;\n+\n+  ScopeValue*                 klass() const                   { ShouldNotReachHere(); return nullptr; }\n+  GrowableArray<ScopeValue*>* field_values()                  { ShouldNotReachHere(); return nullptr; }\n+  ScopeValue*                 field_at(int i) const           { ShouldNotReachHere(); return nullptr; }\n+  int                         field_size()                    { ShouldNotReachHere(); return -1; }\n+\n+  Handle                      value() const                   { assert(_selected != nullptr, \"Should call select() first.\"); return _selected->value(); }\n+  void                        set_value(oop value)            { assert(_selected != nullptr, \"Should call select() first.\"); _selected->set_value(value); }\n+\n+  \/\/ Serialization of debugging information\n+  void read_object(DebugInfoReadStream* stream);\n+  void write_on(DebugInfoWriteStream* stream);\n+};\n+\n@@ -324,0 +399,1 @@\n+  ScopeValue* read_object_merge_value();\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":92,"deletions":16,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-  assert(result->length() == length, \"inconsistent debug information\");\n@@ -135,0 +134,32 @@\n+GrowableArray<ScopeValue*>* ScopeDesc::objects_to_rematerialize(frame& frm, RegisterMap& map) {\n+  if (_objects == nullptr) {\n+    return nullptr;\n+  }\n+\n+  GrowableArray<ScopeValue*>* result = new GrowableArray<ScopeValue*>();\n+  for (int i = 0; i < _objects->length(); i++) {\n+    assert(_objects->at(i)->is_object(), \"invalid debug information\");\n+    ObjectValue* sv = _objects->at(i)->as_ObjectValue();\n+\n+    \/\/ If the object is not referenced in current JVM state, then it's only\n+    \/\/ a candidate in an ObjectMergeValue, we don't need to rematerialize it\n+    \/\/ unless when\/if it's returned by 'select()' below.\n+    if (!sv->is_root()) {\n+      continue;\n+    }\n+\n+    if (sv->is_object_merge()) {\n+      sv = sv->as_ObjectMergeValue()->select(frm, map);\n+      \/\/ If select() returns nullptr, then the object doesn't need to be\n+      \/\/ rematerialized.\n+      if (sv == nullptr) {\n+        continue;\n+      }\n+    }\n+\n+    result->append_if_missing(sv);\n+  }\n+\n+  return result;\n+}\n+\n@@ -243,2 +274,6 @@\n-      st->print(\"    - %d: \", sv->id());\n-      st->print(\"%s \", java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()())->external_name());\n+      st->print(\"    - %d: %c \", i, sv->is_root() ? 'R' : ' ');\n+      sv->print_on(st);\n+      st->print(\", \");\n+      if (!sv->is_object_merge()) {\n+        st->print(\"%s\", java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()())->external_name());\n+      }\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  GrowableArray<ScopeValue*>* objects_to_rematerialize(frame& frm, RegisterMap& map);\n","filename":"src\/hotspot\/share\/code\/scopeDesc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -515,9 +515,0 @@\n-#ifdef COMPILER2\n-  if (PostLoopMultiversioning && !RangeCheckElimination) {\n-    if (!FLAG_IS_DEFAULT(PostLoopMultiversioning)) {\n-      warning(\"PostLoopMultiversioning disabled because RangeCheckElimination is disabled.\");\n-    }\n-    FLAG_SET_CMDLINE(PostLoopMultiversioning, false);\n-  }\n-#endif \/\/ COMPILER2\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonMonitoringSupport.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AnalyticsSequences.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AnalyticsSequences.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -268,1 +268,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCCounters.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -639,1 +639,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -269,1 +269,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,1 +198,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -402,1 +402,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionSet.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -438,1 +438,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,1 +98,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupConfig.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-  uintx _claim_token;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -329,1 +329,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -604,1 +604,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        set $klass = (Klass*)(void*)((uintptr_t)CompressedKlassPointers::_narrow_klass._base +((uintptr_t)$obj->_metadata->_compressed_klass << CompressedKlassPointers::_narrow_klass._shift))\n+        set $klass = (Klass*)(void*)((uintptr_t)CompressedKlassPointers::_base +((uintptr_t)$obj->_metadata->_compressed_klass << CompressedKlassPointers::_shift))\n","filename":"src\/hotspot\/share\/gc\/x\/xDebug.gdb","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/x\/xMarkCache.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        set $klass = (Klass*)(void*)((uintptr_t)CompressedKlassPointers::_narrow_klass._base +((uintptr_t)$obj->_metadata->_compressed_klass << CompressedKlassPointers::_narrow_klass._shift))\n+        set $klass = (Klass*)(void*)((uintptr_t)CompressedKlassPointers::_base +((uintptr_t)$obj->_metadata->_compressed_klass << CompressedKlassPointers::_shift))\n","filename":"src\/hotspot\/share\/gc\/z\/zDebug.gdb","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -392,3 +392,4 @@\n-      int lo = Bytes::get_Java_u4(aligned_bcp + 1*jintSize);\n-      int hi = Bytes::get_Java_u4(aligned_bcp + 2*jintSize);\n-      int len = (int)(aligned_bcp - bcp) + (3 + hi - lo + 1)*jintSize;\n+      \/\/ Promote calculation to 64 bits to do range checks, used by the verifier.\n+      int64_t lo = (int)Bytes::get_Java_u4(aligned_bcp + 1*jintSize);\n+      int64_t hi = (int)Bytes::get_Java_u4(aligned_bcp + 2*jintSize);\n+      int64_t len = (aligned_bcp - bcp) + (3 + hi - lo + 1)*jintSize;\n@@ -397,1 +398,1 @@\n-      return (len > 0 && len == (int)len) ? len : -1;\n+      return (len > 0 && len == (int)len) ? (int)len : -1;\n@@ -407,2 +408,3 @@\n-      int npairs = Bytes::get_Java_u4(aligned_bcp + jintSize);\n-      int len = (int)(aligned_bcp - bcp) + (2 + 2*npairs)*jintSize;\n+      \/\/ Promote calculation to 64 bits to do range checks, used by the verifier.\n+      int64_t npairs = (int)Bytes::get_Java_u4(aligned_bcp + jintSize);\n+      int64_t len = (aligned_bcp - bcp) + (2 + 2*npairs)*jintSize;\n@@ -411,1 +413,1 @@\n-      return (len > 0 && len == (int)len) ? len : -1;\n+      return (len > 0 && len == (int)len) ? (int)len : -1;\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -290,3 +290,0 @@\n-    \/\/ We will reverse the bytecode rewriting _after_ adjusting them.\n-    \/\/ Adjust the cache index by offset to the invokedynamic entries in the\n-    \/\/ cpCache plus the delta if the invokedynamic bytecodes were adjusted.\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -293,3 +293,7 @@\n-JVM_ENTRY_NO_ENV(jboolean, jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size))\n-  return JfrJavaEventWriter::flush(writer, used_size, requested_size, thread);\n-JVM_END\n+NO_TRANSITION(void, jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size))\n+  JfrJavaEventWriter::flush(writer, used_size, requested_size, JavaThread::current());\n+NO_TRANSITION_END\n+\n+NO_TRANSITION(jlong, jfr_commit(JNIEnv* env, jclass jvm, jlong next_position))\n+  return JfrJavaEventWriter::commit(next_position);\n+NO_TRANSITION_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+jlong JNICALL jfr_commit(JNIEnv* env, jclass cls, jlong next_position);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,1 +74,2 @@\n-      (char*)\"flush\", (char*)\"(Ljdk\/jfr\/internal\/event\/EventWriter;II)Z\", (void*)jfr_event_writer_flush,\n+      (char*)\"flush\", (char*)\"(Ljdk\/jfr\/internal\/event\/EventWriter;II)V\", (void*)jfr_event_writer_flush,\n+      (char*)\"commit\", (char*)\"(J)J\", (void*)jfr_commit,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"jfr\/recorder\/stringpool\/jfrStringPool.hpp\"\n@@ -496,0 +497,1 @@\n+  JfrStringPool::on_epoch_shift();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-const char* get_java_thread_name(const JavaThread* jt, int& length, oop vthread) {\n+static const char* get_java_thread_name(const JavaThread* jt, int& length, oop vthread) {\n@@ -113,6 +113,3 @@\n-  const char* name_str = \"<no-name - thread name unresolved>\";\n-  oop thread_obj = vthread != nullptr ? vthread : jt->threadObj();\n-  if (thread_obj == nullptr) {\n-    if (jt->is_attaching_via_jni()) {\n-      name_str = \"<no-name - thread is attaching>\";\n-    }\n+  oop thread_obj;\n+  if (vthread != nullptr) {\n+    thread_obj = vthread;\n@@ -120,3 +117,3 @@\n-    const oop name = java_lang_Thread::name(thread_obj);\n-    if (name != nullptr) {\n-      name_str = java_lang_String::as_utf8_string(name, length);\n+    thread_obj = jt->threadObj();\n+    if (thread_obj == nullptr) {\n+      return nullptr;\n@@ -125,2 +122,3 @@\n-  assert(name_str != nullptr, \"unexpected null thread name\");\n-  return name_str;\n+  assert(thread_obj != nullptr, \"invariant\");\n+  const oop name = java_lang_Thread::name(thread_obj);\n+  return name != nullptr ? java_lang_String::as_utf8_string(name, length) : nullptr;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -272,2 +272,2 @@\n-void JfrThreadConstant::write_name(JfrCheckpointWriter& writer, const char* name, int length) {\n-  if (length == 0) {\n+void JfrThreadConstant::write_name(JfrCheckpointWriter& writer) {\n+  if (_length == 0) {\n@@ -277,1 +277,10 @@\n-  writer.write(name);\n+  writer.write(_name);\n+}\n+\n+void JfrThreadConstant::write_os_name(JfrCheckpointWriter& writer, bool is_vthread) {\n+  if (is_vthread) {\n+    \/\/ Write the null string categorically as the os name for virtual threads.\n+    writer.write((const char*)nullptr);\n+    return;\n+  }\n+  write_name(writer);\n@@ -282,1 +291,1 @@\n-  const bool vthread = _vthread != nullptr;\n+  const bool is_vthread = _vthread != nullptr;\n@@ -284,4 +293,3 @@\n-  int length = -1;\n-  const char* const name = JfrThreadName::name(_thread, length, _vthread);\n-  write_name(writer, name, length);\n-  writer.write(_vthread != nullptr ? static_cast<traceid>(0) : JfrThreadId::os_id(_thread));\n+  _name = JfrThreadName::name(_thread, _length, _vthread);\n+  write_os_name(writer, is_vthread);\n+  writer.write(is_vthread ? static_cast<traceid>(0) : JfrThreadId::os_id(_thread));\n@@ -289,1 +297,1 @@\n-    write_name(writer, nullptr, 0); \/\/ java name\n+    writer.write((const char*)nullptr); \/\/ java name\n@@ -293,12 +301,11 @@\n-  } else {\n-    write_name(writer, name, length);\n-    writer.write(JfrThreadId::jfr_id(_thread, _tid));\n-    \/\/ java thread group - VirtualThread threadgroup reserved id 1\n-    const traceid thread_group_id = vthread ? 1 :\n-      JfrThreadGroup::thread_group_id(JavaThread::cast(_thread), Thread::current());\n-    writer.write(thread_group_id);\n-    writer.write<bool>(vthread); \/\/ isVirtual\n-    if (!vthread) {\n-      JfrThreadGroup::serialize(&writer, thread_group_id);\n-    }\n-    \/\/ VirtualThread threadgroup already serialized invariant.\n+    return;\n+  }\n+  write_name(writer);\n+  writer.write(JfrThreadId::jfr_id(_thread, _tid));\n+  \/\/ java thread group - VirtualThread threadgroup reserved id 1\n+  const traceid thread_group_id = is_vthread ? 1 :\n+    JfrThreadGroup::thread_group_id(JavaThread::cast(_thread), Thread::current());\n+  writer.write(thread_group_id);\n+  writer.write<bool>(is_vthread); \/\/ isVirtual\n+  if (!is_vthread) {\n+    JfrThreadGroup::serialize(&writer, thread_group_id);\n@@ -306,0 +313,1 @@\n+  \/\/ VirtualThread threadgroup already serialized invariant.\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -110,1 +110,4 @@\n-  void write_name(JfrCheckpointWriter& writer, const char* name, int length);\n+  const char* _name;\n+  int _length;\n+  void write_name(JfrCheckpointWriter& writer);\n+  void write_os_name(JfrCheckpointWriter& writer, bool is_vthread);\n@@ -112,1 +115,2 @@\n-  JfrThreadConstant(Thread* t, traceid tid, oop vthread = nullptr) : _thread(t), _tid(tid), _vthread(vthread) {}\n+  JfrThreadConstant(Thread* t, traceid tid, oop vthread = nullptr) :\n+    _thread(t), _tid(tid), _vthread(vthread), _name(nullptr), _length(-1) {}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"oops\/compressedOops.hpp\"\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdKlassQueue.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  JfrMonitorTryLock try_msg_lock(JfrMsg_lock);\n+  JfrMutexTryLock try_msg_lock(JfrMsg_lock);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -262,0 +262,8 @@\n+\n+ByteSize JfrBuffer::pos_offset() {\n+  return byte_offset_of(JfrBuffer, _pos);\n+}\n+\n+ByteSize JfrBuffer::flags_offset() {\n+  return byte_offset_of(JfrBuffer, _flags);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/sizes.hpp\"\n@@ -177,0 +178,5 @@\n+\n+  \/\/ Code generation\n+  static ByteSize pos_offset();\n+  static ByteSize flags_offset();\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"jfr\/utilities\/jfrTryLock.hpp\"\n@@ -43,0 +44,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -175,1 +177,1 @@\n-static BufferPtr acquire_promotion_buffer(size_t size, JfrStorageMspace* mspace, JfrStorage& storage_instance, size_t retry_count, Thread* thread) {\n+BufferPtr JfrStorage::acquire_promotion_buffer(size_t size, JfrStorageMspace* mspace, JfrStorage& storage_instance, size_t retry_count, Thread* thread) {\n@@ -178,2 +180,5 @@\n-    BufferPtr buffer= mspace_acquire_live_with_retry(size, mspace, retry_count, thread);\n-    if (buffer == nullptr && storage_instance.control().should_discard()) {\n+    BufferPtr buffer = mspace_acquire_live_with_retry(size, mspace, retry_count, thread);\n+    if (buffer != nullptr) {\n+      return buffer;\n+    }\n+    if (storage_instance.control().should_discard()) {\n@@ -183,1 +188,1 @@\n-    return buffer;\n+    return storage_instance.control().to_disk() ? JfrStorage::acquire_transient(size, thread) : nullptr;\n@@ -253,0 +258,4 @@\n+  if (promotion_buffer->transient()) {\n+    promotion_buffer->set_retired();\n+    register_full(promotion_buffer, thread);\n+  }\n@@ -279,1 +288,0 @@\n-  assert(buffer->acquired_by(thread), \"invariant\");\n@@ -282,0 +290,9 @@\n+    if (thread->is_Java_thread()) {\n+      JavaThread* jt = JavaThread::cast(thread);\n+      if (jt->thread_state() == _thread_in_native) {\n+        \/\/ Transition java thread to vm so it can issue a notify.\n+        ThreadInVMfromNative transition(jt);\n+        _post_box.post(MSG_FULLBUFFER);\n+        return;\n+      }\n+    }\n@@ -319,1 +336,2 @@\n-  if (JfrBuffer_lock->try_lock()) {\n+  JfrMutexTryLock mutex(JfrBuffer_lock);\n+  if (mutex.acquired()) {\n@@ -329,1 +347,0 @@\n-      assert(oldest->identity() != nullptr, \"invariant\");\n@@ -338,0 +355,1 @@\n+      assert(oldest->identity() != nullptr, \"invariant\");\n@@ -341,1 +359,0 @@\n-    JfrBuffer_lock->unlock();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorage.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+  BufferPtr acquire_promotion_buffer(size_t size, JfrStorageMspace* mspace, JfrStorage& storage_instance, size_t retry_count, Thread* thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorage.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -42,0 +45,39 @@\n+static int generation_offset = invalid_offset;\n+static jobject string_pool = nullptr;\n+\n+static unsigned short generation = 0;\n+\n+static bool setup_string_pool_offsets(TRAPS) {\n+  const char class_name[] = \"jdk\/jfr\/internal\/StringPool\";\n+  Symbol* const k_sym = SymbolTable::new_symbol(class_name);\n+  assert(k_sym != nullptr, \"invariant\");\n+  Klass* klass = SystemDictionary::resolve_or_fail(k_sym, true, CHECK_false);\n+  assert(klass != nullptr, \"invariant\");\n+  klass->initialize(CHECK_false);\n+  assert(!klass->should_be_initialized(), \"invariant\");\n+  assert(string_pool == nullptr, \"invariant\");\n+  jobject pool = JfrJavaSupport::global_jni_handle(klass->java_mirror(), THREAD);\n+  if (pool == nullptr) {\n+    return false;\n+  }\n+  const char generation_name[] = \"generation\";\n+  Symbol* const generation_sym = SymbolTable::new_symbol(generation_name);\n+  assert(generation_sym != nullptr, \"invariant\");\n+  assert(invalid_offset == generation_offset, \"invariant\");\n+  if (!JfrJavaSupport::compute_field_offset(generation_offset, klass, generation_sym, vmSymbols::short_signature(), true)) {\n+    JfrJavaSupport::destroy_global_jni_handle(pool);\n+    return false;\n+  }\n+  assert(generation_offset != invalid_offset, \"invariant\");\n+  string_pool = pool;\n+  return true;\n+}\n+\n+static bool initialize_java_string_pool() {\n+  static bool initialized = false;\n+  if (!initialized) {\n+    initialized = setup_string_pool_offsets(JavaThread::current());\n+  }\n+  return initialized;\n+}\n+\n@@ -78,0 +120,4 @@\n+  if (!initialize_java_string_pool()) {\n+    return false;\n+  }\n+\n@@ -233,0 +279,9 @@\n+\n+void JfrStringPool::on_epoch_shift() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+  assert(!JfrTraceIdEpoch::is_synchronizing(), \"invariant\");\n+  assert(string_pool != nullptr, \"invariant\");\n+  oop mirror = JfrJavaSupport::resolve_non_null(string_pool);\n+  assert(mirror != nullptr, \"invariant\");\n+  mirror->short_field_put(generation_offset, generation++);\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  static void on_epoch_shift();\n@@ -76,0 +77,1 @@\n+  friend class JfrCheckpointManager;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+void JfrIntrinsicSupport::return_lease(JavaThread* jt) {\n+  DEBUG_ONLY(assert_precondition(jt);)\n+  ThreadStateTransition::transition_from_java(jt, _thread_in_native);\n+  assert(jt->jfr_thread_local()->has_java_event_writer(), \"invariant\");\n+  assert(jt->jfr_thread_local()->shelved_buffer() != nullptr, \"invariant\");\n+  JfrJavaEventWriter::flush(jt->jfr_thread_local()->java_event_writer(), 0, 0, jt);\n+  assert(jt->jfr_thread_local()->shelved_buffer() == nullptr, \"invariant\");\n+  ThreadStateTransition::transition_from_native(jt, _thread_in_Java);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+  static void return_lease(JavaThread* jt);\n@@ -64,1 +65,1 @@\n-\n+  do_intrinsic(_jvm_commit,   jdk_jfr_internal_JVM, commit_name, long_long_signature, F_SN)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jfr\/recorder\/storage\/jfrBuffer.hpp\"\n@@ -52,0 +53,12 @@\n+#define JAVA_BUFFER_OFFSET_JFR \\\n+  JfrThreadLocal::java_buffer_offset() + THREAD_LOCAL_OFFSET_JFR\n+\n+#define NOTIFY_OFFSET_JFR \\\n+  JfrThreadLocal::notified_offset() + THREAD_LOCAL_OFFSET_JFR\n+\n+#define JFR_BUFFER_POS_OFFSET \\\n+  JfrBuffer::pos_offset()\n+\n+#define JFR_BUFFER_FLAGS_OFFSET \\\n+  JfrBuffer::flags_offset()\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadExtension.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  _notified(false),\n@@ -250,0 +251,4 @@\n+ByteSize JfrThreadLocal::java_buffer_offset() {\n+  return byte_offset_of(JfrThreadLocal, _java_buffer);\n+}\n+\n@@ -266,0 +271,4 @@\n+ByteSize JfrThreadLocal::notified_offset() {\n+  return byte_offset_of(JfrThreadLocal, _notified);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+  bool _notified;\n@@ -253,0 +254,12 @@\n+  bool is_notified() {\n+    return _notified;\n+  }\n+\n+  void notify() {\n+    _notified = true;\n+  }\n+\n+  void clear_notification() {\n+    _notified = false;\n+  }\n+\n@@ -276,0 +289,1 @@\n+  static ByteSize java_buffer_offset();\n@@ -280,0 +294,1 @@\n+  static ByteSize notified_offset();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-class JfrMonitorTryLock : public StackObj {\n+class JfrMutexTryLock : public StackObj {\n@@ -55,1 +55,1 @@\n-  Monitor* _lock;\n+  Mutex* _mutex;\n@@ -59,3 +59,2 @@\n-  JfrMonitorTryLock(Monitor* lock) : _lock(lock), _acquired(lock->try_lock()) {}\n-\n-  ~JfrMonitorTryLock() {\n+  JfrMutexTryLock(Mutex* mutex) : _mutex(mutex), _acquired(mutex->try_lock()) {}\n+  ~JfrMutexTryLock() {\n@@ -63,2 +62,2 @@\n-      assert(_lock->owned_by_self(), \"invariant\");\n-      _lock->unlock();\n+      assert(_mutex->owned_by_self(), \"invariant\");\n+      _mutex->unlock();\n@@ -71,1 +70,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTryLock.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -48,1 +49,0 @@\n-static int notified_offset = invalid_offset;\n@@ -67,7 +67,0 @@\n-  const char start_pos_address_name[] = \"startPositionAddress\";\n-  Symbol* const start_pos_address_sym = SymbolTable::new_symbol(start_pos_address_name);\n-  assert(start_pos_address_sym != nullptr, \"invariant\");\n-  assert(invalid_offset == start_pos_address_offset, \"invariant\");\n-  JfrJavaSupport::compute_field_offset(start_pos_address_offset, klass, start_pos_address_sym, vmSymbols::long_signature());\n-  assert(start_pos_address_offset != invalid_offset, \"invariant\");\n-\n@@ -88,7 +81,0 @@\n-  const char notified_name[] = \"notified\";\n-  Symbol* const notified_sym = SymbolTable::new_symbol(notified_name);\n-  assert (notified_sym != nullptr, \"invariant\");\n-  assert(invalid_offset == notified_offset, \"invariant\");\n-  JfrJavaSupport::compute_field_offset(notified_offset, klass, notified_sym, vmSymbols::bool_signature());\n-  assert(notified_offset != invalid_offset, \"invariant\");\n-\n@@ -126,2 +112,2 @@\n-jboolean JfrJavaEventWriter::flush(jobject writer, jint used, jint requested, JavaThread* jt) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));\n+void JfrJavaEventWriter::flush(jobject writer, jint used, jint requested, JavaThread* jt) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n@@ -129,2 +115,0 @@\n-  oop const w = JNIHandles::resolve_non_null(writer);\n-  assert(w != nullptr, \"invariant\");\n@@ -141,0 +125,4 @@\n+  \/\/ can safepoint here\n+  ThreadInVMfromNative transition(jt);\n+  oop const w = JNIHandles::resolve_non_null(writer);\n+  assert(w != nullptr, \"invariant\");\n@@ -145,1 +133,0 @@\n-    w->long_field_put(start_pos_address_offset, (jlong)buffer->pos_address());\n@@ -151,1 +138,0 @@\n-    return JNI_FALSE;\n@@ -153,5 +139,28 @@\n-  \/\/ An exclusive use of a leased buffer is treated equivalent to\n-  \/\/ holding a system resource. As such, it should be released as soon as possible.\n-  \/\/ Returning true here signals that the thread will need to call flush again\n-  \/\/ on EventWriter.endEvent() and that flush will return the lease.\n-  return buffer->lease() ? JNI_TRUE : JNI_FALSE;\n+}\n+\n+jlong JfrJavaEventWriter::commit(jlong next_position) {\n+  assert(next_position != 0, \"invariant\");\n+  JavaThread* const jt = JavaThread::current();\n+  assert(jt != nullptr, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n+  JfrThreadLocal* const tl = jt->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n+  assert(tl->has_java_event_writer(), \"invariant\");\n+  assert(tl->has_java_buffer(), \"invariant\");\n+  JfrBuffer* const current = tl->java_buffer();\n+  assert(current != nullptr, \"invariant\");\n+  u1* const next = reinterpret_cast<u1*>(next_position);\n+  assert(next >= current->start(), \"invariant\");\n+  assert(next <= current->end(), \"invariant\");\n+  if (tl->is_notified()) {\n+    tl->clear_notification();\n+    return reinterpret_cast<jlong>(current->pos());\n+  }\n+  \/\/ set_pos() has release semantics\n+  current->set_pos(next);\n+  if (!current->lease()) {\n+    return next_position;\n+  }\n+  assert(current->lease(), \"invariant\");\n+  flush(tl->java_event_writer(), 0, 0, jt);\n+  return 0; \/\/ signals that the buffer lease was returned.\n@@ -201,3 +210,8 @@\n-    oop buffer_writer = JNIHandles::resolve_non_null(jt->jfr_thread_local()->java_event_writer());\n-    assert(buffer_writer != nullptr, \"invariant\");\n-    buffer_writer->release_bool_field_put(notified_offset, JNI_TRUE);\n+    JfrThreadLocal* const tl = jt->jfr_thread_local();\n+    assert(tl != nullptr, \"invariant\");\n+    oop event_writer = JNIHandles::resolve_non_null(tl->java_event_writer());\n+    assert(event_writer != nullptr, \"invariant\");\n+    const jlong start_pos = event_writer->long_field(start_pos_offset);\n+    if (event_writer->long_field(current_pos_offset) > start_pos) {\n+      tl->notify();\n+    }\n@@ -213,1 +227,1 @@\n-  static const char signature[] = \"(JJJJZZ)V\";\n+  static const char signature[] = \"(JJJZZ)V\";\n@@ -220,1 +234,0 @@\n-  args.push_long((jlong)buffer->pos_address());\n@@ -231,1 +244,0 @@\n-  assert(tl->shelved_buffer() == nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+class JfrBuffer;\n@@ -51,1 +52,2 @@\n-  static jboolean flush(jobject writer, jint used, jint requested, JavaThread* jt);\n+  static void flush(jobject writer, jint used, jint requested, JavaThread* jt);\n+  static jlong commit(jlong next_position);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,0 +70,27 @@\n+bool JVMCI::get_shared_library_path(char* pathbuf, size_t pathlen, bool fail_is_fatal) {\n+  if (JVMCILibPath != nullptr) {\n+    if (!os::dll_locate_lib(pathbuf, pathlen, JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {\n+      if (!fail_is_fatal) {\n+        return false;\n+      }\n+      fatal(\"Unable to create path to JVMCI shared library based on value of JVMCILibPath (%s)\", JVMCILibPath);\n+    }\n+  } else {\n+    if (!os::dll_locate_lib(pathbuf, pathlen, Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {\n+      if (!fail_is_fatal) {\n+        return false;\n+      }\n+      fatal(\"Unable to create path to JVMCI shared library\");\n+    }\n+  }\n+  return true;\n+}\n+\n+bool JVMCI::shared_library_exists() {\n+  if (_shared_library_handle != nullptr) {\n+    return true;\n+  }\n+  char path[JVM_MAXPATHLEN];\n+  return get_shared_library_path(path, sizeof(path), false);\n+}\n+\n@@ -81,9 +108,1 @@\n-    if (JVMCILibPath != nullptr) {\n-      if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {\n-        fatal(\"Unable to create path to JVMCI shared library based on value of JVMCILibPath (%s)\", JVMCILibPath);\n-      }\n-    } else {\n-      if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {\n-        fatal(\"Unable to create path to JVMCI shared library\");\n-      }\n-    }\n+    get_shared_library_path(path, sizeof(path), true);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -104,0 +104,6 @@\n+  \/\/ Writes into `pathbuf` the path to the existing JVMCI shared library file.\n+  \/\/ If the file cannot be found and `fail_is_fatal` is true, then\n+  \/\/ a fatal error occurs.\n+  \/\/ Returns whether the path to an existing file was written into `pathbuf`.\n+  static bool get_shared_library_path(char* pathbuf, size_t pathlen, bool fail_is_fatal);\n+\n@@ -125,0 +131,5 @@\n+  \/\/ Determines if the JVMCI shared library exists. This does not\n+  \/\/ take into account whether loading the library would succeed\n+  \/\/ if it's not already loaded.\n+  static bool shared_library_exists();\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1501,0 +1501,1 @@\n+              assert(!value->is_object_merge(), \"Should not be.\");\n@@ -1743,0 +1744,1 @@\n+        assert(!scopedValues->at(i2)->is_object_merge(), \"Should not be.\");\n@@ -1756,0 +1758,1 @@\n+        assert(!scopeExpressions->at(i2)->is_object_merge(), \"Should not be.\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -594,2 +595,2 @@\n-  \/\/ AArch64: Try to align metaspace so that we can decode a compressed\n-  \/\/ klass with a single MOVK instruction. We can do this iff the\n+  \/\/ AArch64: Try to align metaspace class space so that we can decode a\n+  \/\/ compressed klass with a single MOVK instruction. We can do this iff the\n@@ -618,0 +619,4 @@\n+  \/\/ Calculate a list of all possible values for the starting address for the\n+  \/\/ compressed class space.\n+  ResourceMark rm;\n+  GrowableArray<address> list(36);\n@@ -622,6 +627,1 @@\n-      ReservedSpace rs(size, Metaspace::reserve_alignment(),\n-                       os::vm_page_size(), (char*)a);\n-      if (rs.is_reserved()) {\n-        assert(a == (address)rs.base(), \"Sanity\");\n-        return rs;\n-      }\n+      list.append(a);\n@@ -631,0 +631,21 @@\n+\n+  int len = list.length();\n+  int r = 0;\n+  if (!DumpSharedSpaces) {\n+    \/\/ Starting from a random position in the list. If the address cannot be reserved\n+    \/\/ (the OS already assigned it for something else), go to the next position, wrapping\n+    \/\/ around if necessary, until we exhaust all the items.\n+    os::init_random((int)os::javaTimeNanos());\n+    r = os::random();\n+    log_info(metaspace)(\"Randomizing compressed class space: start from %d out of %d locations\",\n+                        r % len, len);\n+  }\n+  for (int i = 0; i < len; i++) {\n+    address a = list.at((i + r) % len);\n+    ReservedSpace rs(size, Metaspace::reserve_alignment(),\n+                     os::vm_page_size(), (char*)a);\n+    if (rs.is_reserved()) {\n+      assert(a == (address)rs.base(), \"Sanity\");\n+      return rs;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+ friend class VMStructs;\n","filename":"src\/hotspot\/share\/oops\/annotations.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+address CompressedKlassPointers::_base = nullptr;\n+int CompressedKlassPointers::_shift = 0;\n+size_t CompressedKlassPointers::_range = 0;\n+\n+#ifdef _LP64\n+\n+\/\/ Given a klass range [addr, addr+len) and a given encoding scheme, assert that this scheme covers the range, then\n+\/\/ set this encoding scheme. Used by CDS at runtime to re-instate the scheme used to pre-compute klass ids for\n+\/\/ archived heap objects.\n+void CompressedKlassPointers::initialize_for_given_encoding(address addr, size_t len, address requested_base, int requested_shift) {\n+  assert(is_valid_base(requested_base), \"Address must be a valid encoding base\");\n+  address const end = addr + len;\n+\n+  const int narrow_klasspointer_bits = sizeof(narrowKlass) * 8;\n+  const size_t encoding_range_size = nth_bit(narrow_klasspointer_bits + requested_shift);\n+  address encoding_range_end = requested_base + encoding_range_size;\n+\n+  \/\/ Note: it would be technically valid for the encoding base to precede the start of the Klass range. But we only call\n+  \/\/ this function from CDS, and therefore know this to be true.\n+  assert(requested_base == addr, \"Invalid requested base\");\n+  assert(encoding_range_end >= end, \"Encoding does not cover the full Klass range\");\n+\n+  set_base(requested_base);\n+  set_shift(requested_shift);\n+  set_range(encoding_range_size);\n+}\n+\n+\/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n+\/\/  cover, choose base, shift and range.\n+\/\/  The address range is the expected range of uncompressed Klass pointers we\n+\/\/  will encounter (and the implicit promise that there will be no Klass\n+\/\/  structures outside this range).\n+void CompressedKlassPointers::initialize(address addr, size_t len) {\n+  assert(is_valid_base(addr), \"Address must be a valid encoding base\");\n+  address const end = addr + len;\n+\n+  address base;\n+  int shift;\n+  size_t range;\n+\n+  \/\/ Attempt to run with encoding base == zero\n+  if (end <= (address)KlassEncodingMetaspaceMax) {\n+    base = 0;\n+  } else {\n+    base = addr;\n+  }\n+\n+  \/\/ Highest offset a Klass* can ever have in relation to base.\n+  range = end - base;\n+\n+  \/\/ We may not even need a shift if the range fits into 32bit:\n+  const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);\n+  if (range < UnscaledClassSpaceMax) {\n+    shift = 0;\n+  } else {\n+    shift = LogKlassAlignmentInBytes;\n+  }\n+\n+  set_base(base);\n+  set_shift(shift);\n+  set_range(range);\n+}\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+#ifdef AARCH64\n+  \/\/ Below 32G, base must be aligned to 4G.\n+  \/\/ Above that point, base must be aligned to 32G\n+  if (p < (address)(32 * G)) {\n+    return is_aligned(p, 4 * G);\n+  }\n+  return is_aligned(p, (4 << LogKlassAlignmentInBytes) * G);\n+#else\n+  return true;\n+#endif\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" SIZE_FORMAT_X, p2i(base()), shift(),\n+               range());\n+}\n+\n+void CompressedKlassPointers::set_base(address base) {\n+  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n+  _base   = base;\n+}\n+\n+void CompressedKlassPointers::set_shift(int shift)       {\n+  assert(shift == 0 || shift == LogKlassAlignmentInBytes, \"invalid shift for klass ptrs\");\n+  _shift   = shift;\n+}\n+\n+void CompressedKlassPointers::set_range(size_t range) {\n+  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n+  _range = range;\n+}\n+\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_COMPRESSEDKLASS_HPP\n+#define SHARE_OOPS_COMPRESSEDKLASS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+class Klass;\n+\n+\/\/ If compressed klass pointers then use narrowKlass.\n+typedef juint  narrowKlass;\n+\n+const int LogKlassAlignmentInBytes = 3;\n+const int KlassAlignmentInBytes    = 1 << LogKlassAlignmentInBytes;\n+\n+\/\/ Maximal size of compressed class space. Above this limit compression is not possible.\n+\/\/ Also upper bound for placement of zero based class space. (Class space is further limited\n+\/\/ to be < 3G, see arguments.cpp.)\n+const  uint64_t KlassEncodingMetaspaceMax = (uint64_t(max_juint) + 1) << LogKlassAlignmentInBytes;\n+\n+\/\/ For UseCompressedClassPointers.\n+class CompressedKlassPointers : public AllStatic {\n+  friend class VMStructs;\n+\n+  static address _base;\n+  static int _shift;\n+\n+  \/\/ Together with base, this defines the address range within which Klass\n+  \/\/  structures will be located: [base, base+range). While the maximal\n+  \/\/  possible encoding range is 4|32G for shift 0|3, if we know beforehand\n+  \/\/  the expected range of Klass* pointers will be smaller, a platform\n+  \/\/  could use this info to optimize encoding.\n+  static size_t _range;\n+\n+  static void set_base(address base);\n+  static void set_range(size_t range);\n+  static void set_shift(int shift);\n+\n+public:\n+\n+  \/\/ Given an address p, return true if p can be used as an encoding base.\n+  \/\/  (Some platforms have restrictions of what constitutes a valid base\n+  \/\/   address).\n+  static bool is_valid_base(address p);\n+\n+  \/\/ Given a klass range [addr, addr+len) and a given encoding scheme, assert that this scheme covers the range, then\n+  \/\/ set this encoding scheme. Used by CDS at runtime to re-instate the scheme used to pre-compute klass ids for\n+  \/\/ archived heap objects.\n+  static void initialize_for_given_encoding(address addr, size_t len, address requested_base, int requested_shift);\n+\n+  \/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n+  \/\/  cover, choose base, shift and range.\n+  \/\/  The address range is the expected range of uncompressed Klass pointers we\n+  \/\/  will encounter (and the implicit promise that there will be no Klass\n+  \/\/  structures outside this range).\n+  static void initialize(address addr, size_t len);\n+\n+  static void     print_mode(outputStream* st);\n+\n+  static address  base()               { return  _base; }\n+  static size_t   range()              { return  _range; }\n+  static int      shift()              { return  _shift; }\n+\n+  static bool is_null(Klass* v)      { return v == nullptr; }\n+  static bool is_null(narrowKlass v) { return v == 0; }\n+\n+  static inline Klass* decode_raw(narrowKlass v, address base, int shift);\n+  static inline Klass* decode_raw(narrowKlass v);\n+  static inline Klass* decode_not_null(narrowKlass v);\n+  static inline Klass* decode_not_null(narrowKlass v, address base, int shift);\n+  static inline Klass* decode(narrowKlass v);\n+  static inline narrowKlass encode_not_null(Klass* v);\n+  static inline narrowKlass encode_not_null(Klass* v, address base, int shift);\n+  static inline narrowKlass encode(Klass* v);\n+\n+};\n+\n+#endif \/\/ SHARE_OOPS_COMPRESSEDKLASS_HPP\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_COMPRESSEDKLASS_INLINE_HPP\n+#define SHARE_OOPS_COMPRESSEDKLASS_INLINE_HPP\n+\n+#include \"oops\/compressedKlass.hpp\"\n+\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+static inline bool check_alignment(Klass* v) {\n+  return (intptr_t)v % KlassAlignmentInBytes == 0;\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v) {\n+  return decode_raw(v, base(), shift());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base, int shift) {\n+  return (Klass*)((uintptr_t)narrow_base +((uintptr_t)v << shift));\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v) {\n+  return decode_not_null(v, base(), shift());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v, address narrow_base, int shift) {\n+  assert(!is_null(v), \"narrow klass value can never be zero\");\n+  Klass* result = decode_raw(v, narrow_base, shift);\n+  assert(check_alignment(result), \"address not aligned: \" PTR_FORMAT, p2i(result));\n+  return result;\n+}\n+\n+inline Klass* CompressedKlassPointers::decode(narrowKlass v) {\n+  return is_null(v) ? nullptr : decode_not_null(v);\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v) {\n+  return encode_not_null(v, base(), shift());\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v, address narrow_base, int shift) {\n+  assert(!is_null(v), \"klass value can never be zero\");\n+  assert(check_alignment(v), \"Address not aligned\");\n+  uint64_t pd = (uint64_t)(pointer_delta(v, narrow_base, 1));\n+  assert(KlassEncodingMetaspaceMax > pd, \"change encoding max if new encoding\");\n+  uint64_t result = pd >> shift;\n+  assert((result & CONST64(0xffffffff00000000)) == 0, \"narrow klass pointer overflow\");\n+  assert(decode_not_null((narrowKlass)result, narrow_base, shift) == v, \"reversibility\");\n+  return (narrowKlass)result;\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode(Klass* v) {\n+  return is_null(v) ? (narrowKlass)0 : encode_not_null(v);\n+}\n+\n+#endif \/\/ SHARE_OOPS_COMPRESSEDKLASS_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.inline.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -180,105 +180,0 @@\n-\n-\/\/ For UseCompressedClassPointers.\n-NarrowPtrStruct CompressedKlassPointers::_narrow_klass = { nullptr, 0, true };\n-\n-\/\/ CompressedClassSpaceSize set to 1GB, but appear 3GB away from _narrow_ptrs_base during CDS dump.\n-\/\/ (Todo: we should #ifdef out CompressedKlassPointers for 32bit completely and fix all call sites which\n-\/\/  are compiled for 32bit to LP64_ONLY).\n-size_t CompressedKlassPointers::_range = 0;\n-\n-#ifdef _LP64\n-\n-\/\/ Given a klass range [addr, addr+len) and a given encoding scheme, assert that this scheme covers the range, then\n-\/\/ set this encoding scheme. Used by CDS at runtime to re-instate the scheme used to pre-compute klass ids for\n-\/\/ archived heap objects.\n-void CompressedKlassPointers::initialize_for_given_encoding(address addr, size_t len, address requested_base, int requested_shift) {\n-  assert(is_valid_base(requested_base), \"Address must be a valid encoding base\");\n-  address const end = addr + len;\n-\n-  const int narrow_klasspointer_bits = sizeof(narrowKlass) * 8;\n-  const size_t encoding_range_size = nth_bit(narrow_klasspointer_bits + requested_shift);\n-  address encoding_range_end = requested_base + encoding_range_size;\n-\n-  \/\/ Note: it would be technically valid for the encoding base to precede the start of the Klass range. But we only call\n-  \/\/ this function from CDS, and therefore know this to be true.\n-  assert(requested_base == addr, \"Invalid requested base\");\n-  assert(encoding_range_end >= end, \"Encoding does not cover the full Klass range\");\n-\n-  set_base(requested_base);\n-  set_shift(requested_shift);\n-  set_range(encoding_range_size);\n-}\n-\n-\/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n-\/\/  cover, choose base, shift and range.\n-\/\/  The address range is the expected range of uncompressed Klass pointers we\n-\/\/  will encounter (and the implicit promise that there will be no Klass\n-\/\/  structures outside this range).\n-void CompressedKlassPointers::initialize(address addr, size_t len) {\n-  assert(is_valid_base(addr), \"Address must be a valid encoding base\");\n-  address const end = addr + len;\n-\n-  address base;\n-  int shift;\n-  size_t range;\n-\n-  \/\/ Attempt to run with encoding base == zero\n-  if (end <= (address)KlassEncodingMetaspaceMax) {\n-    base = 0;\n-  } else {\n-    base = addr;\n-  }\n-\n-  \/\/ Highest offset a Klass* can ever have in relation to base.\n-  range = end - base;\n-\n-  \/\/ We may not even need a shift if the range fits into 32bit:\n-  const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);\n-  if (range < UnscaledClassSpaceMax) {\n-    shift = 0;\n-  } else {\n-    shift = LogKlassAlignmentInBytes;\n-  }\n-\n-  set_base(base);\n-  set_shift(shift);\n-  set_range(range);\n-}\n-\n-\/\/ Given an address p, return true if p can be used as an encoding base.\n-\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n-bool CompressedKlassPointers::is_valid_base(address p) {\n-#ifdef AARCH64\n-  \/\/ Below 32G, base must be aligned to 4G.\n-  \/\/ Above that point, base must be aligned to 32G\n-  if (p < (address)(32 * G)) {\n-    return is_aligned(p, 4 * G);\n-  }\n-  return is_aligned(p, (4 << LogKlassAlignmentInBytes) * G);\n-#else\n-  return true;\n-#endif\n-}\n-\n-void CompressedKlassPointers::print_mode(outputStream* st) {\n-  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n-               \"Narrow klass range: \" SIZE_FORMAT_X, p2i(base()), shift(),\n-               range());\n-}\n-\n-void CompressedKlassPointers::set_base(address base) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _narrow_klass._base   = base;\n-}\n-\n-void CompressedKlassPointers::set_shift(int shift)       {\n-  assert(shift == 0 || shift == LogKlassAlignmentInBytes, \"invalid shift for klass ptrs\");\n-  _narrow_klass._shift   = shift;\n-}\n-\n-void CompressedKlassPointers::set_range(size_t range) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _range = range;\n-}\n-\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/oops\/compressedOops.cpp","additions":0,"deletions":105,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  \/\/ LogMinObjAlignmentInBytes\/LogKlassAlignmentInBytes otherwise.\n+  \/\/ LogMinObjAlignmentInBytes otherwise.\n@@ -143,56 +143,0 @@\n-\/\/ For UseCompressedClassPointers.\n-class CompressedKlassPointers : public AllStatic {\n-  friend class VMStructs;\n-\n-  static NarrowPtrStruct _narrow_klass;\n-\n-  \/\/ Together with base, this defines the address range within which Klass\n-  \/\/  structures will be located: [base, base+range). While the maximal\n-  \/\/  possible encoding range is 4|32G for shift 0|3, if we know beforehand\n-  \/\/  the expected range of Klass* pointers will be smaller, a platform\n-  \/\/  could use this info to optimize encoding.\n-  static size_t _range;\n-\n-  static void set_base(address base);\n-  static void set_range(size_t range);\n-  static void set_shift(int shift);\n-\n-public:\n-\n-  \/\/ Given an address p, return true if p can be used as an encoding base.\n-  \/\/  (Some platforms have restrictions of what constitutes a valid base\n-  \/\/   address).\n-  static bool is_valid_base(address p);\n-\n-  \/\/ Given a klass range [addr, addr+len) and a given encoding scheme, assert that this scheme covers the range, then\n-  \/\/ set this encoding scheme. Used by CDS at runtime to re-instate the scheme used to pre-compute klass ids for\n-  \/\/ archived heap objects.\n-  static void initialize_for_given_encoding(address addr, size_t len, address requested_base, int requested_shift);\n-\n-  \/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n-  \/\/  cover, choose base, shift and range.\n-  \/\/  The address range is the expected range of uncompressed Klass pointers we\n-  \/\/  will encounter (and the implicit promise that there will be no Klass\n-  \/\/  structures outside this range).\n-  static void initialize(address addr, size_t len);\n-\n-  static void     print_mode(outputStream* st);\n-\n-  static address  base()               { return  _narrow_klass._base; }\n-  static size_t   range()              { return  _range; }\n-  static int      shift()              { return  _narrow_klass._shift; }\n-\n-  static bool is_null(Klass* v)      { return v == nullptr; }\n-  static bool is_null(narrowKlass v) { return v == 0; }\n-\n-  static inline Klass* decode_raw(narrowKlass v, address base, int shift);\n-  static inline Klass* decode_raw(narrowKlass v);\n-  static inline Klass* decode_not_null(narrowKlass v);\n-  static inline Klass* decode_not_null(narrowKlass v, address base, int shift);\n-  static inline Klass* decode(narrowKlass v);\n-  static inline narrowKlass encode_not_null(Klass* v);\n-  static inline narrowKlass encode_not_null(Klass* v, address base, int shift);\n-  static inline narrowKlass encode(Klass* v);\n-\n-};\n-\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":1,"deletions":57,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -121,46 +121,0 @@\n-static inline bool check_alignment(Klass* v) {\n-  return (intptr_t)v % KlassAlignmentInBytes == 0;\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v) {\n-  return decode_raw(v, base(), shift());\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base, int shift) {\n-  return (Klass*)((uintptr_t)narrow_base +((uintptr_t)v << shift));\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v) {\n-  return decode_not_null(v, base(), shift());\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v, address narrow_base, int shift) {\n-  assert(!is_null(v), \"narrow klass value can never be zero\");\n-  Klass* result = decode_raw(v, narrow_base, shift);\n-  assert(check_alignment(result), \"address not aligned: \" PTR_FORMAT, p2i(result));\n-  return result;\n-}\n-\n-inline Klass* CompressedKlassPointers::decode(narrowKlass v) {\n-  return is_null(v) ? nullptr : decode_not_null(v);\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v) {\n-  return encode_not_null(v, base(), shift());\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v, address narrow_base, int shift) {\n-  assert(!is_null(v), \"klass value can never be zero\");\n-  assert(check_alignment(v), \"Address not aligned\");\n-  uint64_t pd = (uint64_t)(pointer_delta(v, narrow_base, 1));\n-  assert(KlassEncodingMetaspaceMax > pd, \"change encoding max if new encoding\");\n-  uint64_t result = pd >> shift;\n-  assert((result & CONST64(0xffffffff00000000)) == 0, \"narrow klass pointer overflow\");\n-  assert(decode_not_null((narrowKlass)result, narrow_base, shift) == v, \"reversibility\");\n-  return (narrowKlass)result;\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode(Klass* v) {\n-  return is_null(v) ? (narrowKlass)0 : encode_not_null(v);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/compressedOops.inline.hpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -4107,1 +4107,1 @@\n-                      p2i(this),  p2i(superklass()));\n+                       p2i(this),  p2i(superklass()));\n@@ -4115,1 +4115,1 @@\n-                          p2i(InstanceKlass::cast(local_interfaces()->at(i))));\n+                           p2i(InstanceKlass::cast(local_interfaces()->at(i))));\n@@ -4127,3 +4127,3 @@\n-                        cfs->length(),\n-                        ClassLoader::crc32(0, (const char*)cfs->buffer(),\n-                        cfs->length()));\n+                         cfs->length(),\n+                         ClassLoader::crc32(0, (const char*)cfs->buffer(),\n+                         cfs->length()));\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-\/\/ If compressed klass pointers then use narrowKlass.\n-typedef juint  narrowKlass;\n-\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -185,3 +185,0 @@\n-  product(bool, PostLoopMultiversioning, false, EXPERIMENTAL,               \\\n-           \"Multi versioned post loops to eliminate range checks\")          \\\n-                                                                            \\\n@@ -473,0 +470,6 @@\n+  product(bool, ReduceAllocationMerges, true, DIAGNOSTIC,                   \\\n+          \"Try to simplify allocation merges before Scalar Replacement\")    \\\n+                                                                            \\\n+  notproduct(bool, TraceReduceAllocationMerges, false,                      \\\n+          \"Trace decision for simplifying allocation merges.\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+const char* C2Compiler::retry_no_reduce_allocation_merges() {\n+  return \"retry without reducing allocation merges\";\n+}\n@@ -109,0 +112,1 @@\n+  bool do_reduce_allocation_merges = ReduceAllocationMerges;\n@@ -114,1 +118,1 @@\n-    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code);\n+    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, do_reduce_allocation_merges, eliminate_boxing, do_locks_coarsening, install_code);\n@@ -137,0 +141,6 @@\n+      if (C.failure_reason_is(retry_no_reduce_allocation_merges())) {\n+        assert(do_reduce_allocation_merges, \"must make progress\");\n+        do_reduce_allocation_merges = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n@@ -679,0 +689,1 @@\n+  case vmIntrinsics::_jvm_commit:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  static const char* retry_no_reduce_allocation_merges();\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1164,0 +1164,6 @@\n+\/\/----------------------------is_uncommon_trap----------------------------\n+\/\/ Returns true if this is an uncommon trap.\n+bool CallStaticJavaNode::is_uncommon_trap() const {\n+  return (_name != nullptr && !strcmp(_name, \"uncommon_trap\"));\n+}\n+\n@@ -1167,4 +1173,1 @@\n-  if (_name != nullptr && !strcmp(_name, \"uncommon_trap\")) {\n-    return extract_uncommon_trap_request(this);\n-  }\n-  return 0;\n+  return is_uncommon_trap() ? extract_uncommon_trap_request(this) : 0;\n@@ -1671,6 +1674,1 @@\n-SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp,\n-#ifdef ASSERT\n-                                                     Node* alloc,\n-#endif\n-                                                     uint first_index,\n-                                                     uint n_fields) :\n+SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint n_fields) :\n@@ -1679,4 +1677,2 @@\n-  _n_fields(n_fields)\n-#ifdef ASSERT\n-  , _alloc(alloc)\n-#endif\n+  _n_fields(n_fields),\n+  _alloc(alloc)\n@@ -1685,2 +1681,1 @@\n-  if (alloc != nullptr && !alloc->is_Allocate()\n-      && !(alloc->Opcode() == Op_VectorBox)) {\n+  if (alloc != nullptr && !alloc->is_Allocate() && !(alloc->Opcode() == Op_VectorBox)) {\n@@ -1732,2 +1727,21 @@\n-  st->print(\" # fields@[%d..%d]\", first_index(),\n-             first_index() + n_fields() - 1);\n+  st->print(\" # fields@[%d..%d]\", first_index(), first_index() + n_fields() - 1);\n+}\n+#endif\n+\n+\/\/==============  SafePointScalarMergeNode  ==============\n+\n+SafePointScalarMergeNode::SafePointScalarMergeNode(const TypeOopPtr* tp, int merge_pointer_idx) :\n+  TypeNode(tp, 1), \/\/ 1 control input -- seems required.  Get from root.\n+  _merge_pointer_idx(merge_pointer_idx)\n+{\n+  init_class_id(Class_SafePointScalarMerge);\n+}\n+\n+\/\/ Do not allow value-numbering for SafePointScalarMerge node.\n+uint SafePointScalarMergeNode::hash() const { return NO_HASH; }\n+bool SafePointScalarMergeNode::cmp( const Node &n ) const {\n+  return (&n == this); \/\/ Always fail except on self\n+}\n+\n+uint SafePointScalarMergeNode::ideal_reg() const {\n+  return 0; \/\/ No matching to machine instruction\n@@ -1736,0 +1750,29 @@\n+const RegMask &SafePointScalarMergeNode::in_RegMask(uint idx) const {\n+  return *(Compile::current()->matcher()->idealreg2debugmask[in(idx)->ideal_reg()]);\n+}\n+\n+const RegMask &SafePointScalarMergeNode::out_RegMask() const {\n+  return RegMask::Empty;\n+}\n+\n+uint SafePointScalarMergeNode::match_edge(uint idx) const {\n+  return 0;\n+}\n+\n+SafePointScalarMergeNode*\n+SafePointScalarMergeNode::clone(Dict* sosn_map, bool& new_node) const {\n+  void* cached = (*sosn_map)[(void*)this];\n+  if (cached != nullptr) {\n+    new_node = false;\n+    return (SafePointScalarMergeNode*)cached;\n+  }\n+  new_node = true;\n+  SafePointScalarMergeNode* res = (SafePointScalarMergeNode*)Node::clone();\n+  sosn_map->Insert((void*)this, (void*)res);\n+  return res;\n+}\n+\n+#ifndef PRODUCT\n+void SafePointScalarMergeNode::dump_spec(outputStream *st) const {\n+  st->print(\" # merge_pointer_idx=%d, scalarized_objects=%d\", _merge_pointer_idx, req()-1);\n+}\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":61,"deletions":18,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -507,1 +507,0 @@\n-\n@@ -509,5 +508,6 @@\n-  uint _first_index; \/\/ First input edge relative index of a SafePoint node where\n-                     \/\/ states of the scalarized object fields are collected.\n-                     \/\/ It is relative to the last (youngest) jvms->_scloff.\n-  uint _n_fields;    \/\/ Number of non-static fields of the scalarized object.\n-  DEBUG_ONLY(Node* _alloc;)\n+  uint _first_index;              \/\/ First input edge relative index of a SafePoint node where\n+                                  \/\/ states of the scalarized object fields are collected.\n+                                  \/\/ It is relative to the last (youngest) jvms->_scloff.\n+  uint _n_fields;                 \/\/ Number of non-static fields of the scalarized object.\n+\n+  Node* _alloc;                   \/\/ Just for debugging purposes.\n@@ -515,1 +515,1 @@\n-  virtual uint hash() const ; \/\/ { return NO_HASH; }\n+  virtual uint hash() const;\n@@ -521,5 +521,2 @@\n-  SafePointScalarObjectNode(const TypeOopPtr* tp,\n-#ifdef ASSERT\n-                            Node* alloc,\n-#endif\n-                            uint first_index, uint n_fields);\n+  SafePointScalarObjectNode(const TypeOopPtr* tp, Node* alloc, uint first_index, uint n_fields);\n+\n@@ -558,0 +555,86 @@\n+\/\/------------------------------SafePointScalarMergeNode----------------------\n+\/\/\n+\/\/ This class represents an allocation merge that is used as debug information\n+\/\/ and had at least one of its input scalar replaced.\n+\/\/\n+\/\/ The required inputs of this node, except the control, are pointers to\n+\/\/ SafePointScalarObjectNodes that describe scalarized inputs of the original\n+\/\/ allocation merge. The other(s) properties of the class are described below.\n+\/\/\n+\/\/ _merge_pointer_idx : index in the SafePointNode's input array where the\n+\/\/   description of the _allocation merge_ starts. The index is zero based and\n+\/\/   relative to the SafePoint's scloff. The two entries in the SafePointNode's\n+\/\/   input array starting at '_merge_pointer_idx` are Phi nodes representing:\n+\/\/\n+\/\/   1) The original merge Phi. During rematerialization this input will only be\n+\/\/   used if the \"selector Phi\" (see below) indicates that the execution of the\n+\/\/   Phi took the path of a non scalarized input.\n+\/\/\n+\/\/   2) A \"selector Phi\". The output of this Phi will be '-1' if the execution\n+\/\/   of the method exercised a non scalarized input of the original Phi.\n+\/\/   Otherwise, the output will be >=0, and it will indicate the index-1 in the\n+\/\/   SafePointScalarMergeNode input array where the description of the\n+\/\/   scalarized object that should be used is.\n+\/\/\n+\/\/ As an example, consider a Phi merging 3 inputs, of which the last 2 are\n+\/\/ scalar replaceable.\n+\/\/\n+\/\/    Phi(Region, NSR, SR, SR)\n+\/\/\n+\/\/ During scalar replacement the SR inputs will be changed to null:\n+\/\/\n+\/\/    Phi(Region, NSR, nullptr, nullptr)\n+\/\/\n+\/\/ A corresponding selector Phi will be created with a configuration like this:\n+\/\/\n+\/\/    Phi(Region, -1, 0, 1)\n+\/\/\n+\/\/ During execution of the compiled method, if the execution reaches a Trap, the\n+\/\/ output of the selector Phi will tell if we need to rematerialize one of the\n+\/\/ scalar replaced inputs or if we should just use the pointer returned by the\n+\/\/ original Phi.\n+\n+class SafePointScalarMergeNode: public TypeNode {\n+  int _merge_pointer_idx;         \/\/ This is the first input edge relative\n+                                  \/\/ index of a SafePoint node where metadata information relative\n+                                  \/\/ to restoring the merge is stored. The corresponding input\n+                                  \/\/ in the associated SafePoint will point to a Phi representing\n+                                  \/\/ potential non-scalar replaced objects.\n+\n+  virtual uint hash() const;\n+  virtual bool cmp( const Node &n ) const;\n+\n+public:\n+  SafePointScalarMergeNode(const TypeOopPtr* tp, int merge_pointer_idx);\n+\n+  virtual int            Opcode() const;\n+  virtual uint           ideal_reg() const;\n+  virtual const RegMask &in_RegMask(uint) const;\n+  virtual const RegMask &out_RegMask() const;\n+  virtual uint           match_edge(uint idx) const;\n+\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+  int merge_pointer_idx(JVMState* jvms) const {\n+    assert(jvms != nullptr, \"JVMS reference is null.\");\n+    return jvms->scloff() + _merge_pointer_idx;\n+  }\n+\n+  int selector_idx(JVMState* jvms) const {\n+    assert(jvms != nullptr, \"JVMS reference is null.\");\n+    return jvms->scloff() + _merge_pointer_idx + 1;\n+  }\n+\n+  \/\/ Assumes that \"this\" is an argument to a safepoint node \"s\", and that\n+  \/\/ \"new_call\" is being created to correspond to \"s\".  But the difference\n+  \/\/ between the start index of the jvmstates of \"new_call\" and \"s\" is\n+  \/\/ \"jvms_adj\".  Produce and return a SafePointScalarObjectNode that\n+  \/\/ corresponds appropriately to \"this\" in \"new_call\".  Assumes that\n+  \/\/ \"sosn_map\" is a map, specific to the translation of \"s\" to \"new_call\",\n+  \/\/ mapping old SafePointScalarObjectNodes to new, to avoid multiple copies.\n+  SafePointScalarMergeNode* clone(Dict* sosn_map, bool& new_node) const;\n+\n+#ifndef PRODUCT\n+  virtual void              dump_spec(outputStream *st) const;\n+#endif\n+};\n@@ -771,0 +854,1 @@\n+  bool is_uncommon_trap() const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":96,"deletions":12,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+macro(SafePointScalarMerge)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -535,0 +535,6 @@\n+  if (do_reduce_allocation_merges() != ReduceAllocationMerges && PrintOpto) {\n+    \/\/ Recompiling without reducing allocation merges\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without reduce allocation merges **\");\n+    tty->print_cr(\"*********************************************************\");\n+  }\n@@ -2801,1 +2807,0 @@\n-      if (major_progress()) print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);\n@@ -2805,0 +2810,1 @@\n+    print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);\n@@ -2826,2 +2832,0 @@\n-\n-        if (failing())  return;\n@@ -2829,0 +2833,4 @@\n+\n+      ConnectionGraph::verify_ram_nodes(this, root());\n+      if (failing())  return;\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  const bool _do_reduce_allocation_merges;  \/\/ Do try to reduce allocation merges.\n@@ -187,0 +188,1 @@\n+          bool do_reduce_allocation_merges,\n@@ -192,0 +194,1 @@\n+          _do_reduce_allocation_merges(do_reduce_allocation_merges),\n@@ -202,0 +205,1 @@\n+       \/* do_reduce_allocation_merges = *\/ false,\n@@ -575,0 +579,1 @@\n+  bool              do_reduce_allocation_merges() const  { return _options._do_reduce_allocation_merges; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -802,3 +802,4 @@\n-  GrowableArray<int>* bcis = new (C->node_arena()) GrowableArray<int>(C->node_arena(), 8, 0, -1);\n-  GrowableArray<const Type*>* extypes = new (C->node_arena()) GrowableArray<const Type*>(C->node_arena(), 8, 0, nullptr);\n-  GrowableArray<int>* saw_unloaded = new (C->node_arena()) GrowableArray<int>(C->node_arena(), 8, 0, 0);\n+  Arena tmp_mem{mtCompiler};\n+  GrowableArray<int> bcis(&tmp_mem, 8, 0, -1);\n+  GrowableArray<const Type*> extypes(&tmp_mem, 8, 0, nullptr);\n+  GrowableArray<int> saw_unloaded(&tmp_mem, 8, 0, -1);\n@@ -808,3 +809,3 @@\n-    ciExceptionHandler* h        = handlers.handler();\n-    int                 h_bci    = h->handler_bci();\n-    ciInstanceKlass*    h_klass  = h->is_catch_all() ? env()->Throwable_klass() : h->catch_klass();\n+    ciExceptionHandler* h       = handlers.handler();\n+    int                 h_bci   = h->handler_bci();\n+    ciInstanceKlass*    h_klass = h->is_catch_all() ? env()->Throwable_klass() : h->catch_klass();\n@@ -813,1 +814,1 @@\n-      if (saw_unloaded->contains(h_bci)) {\n+      if (saw_unloaded.contains(h_bci)) {\n@@ -819,1 +820,1 @@\n-        saw_unloaded->append(h_bci);\n+        saw_unloaded.append(h_bci);\n@@ -822,1 +823,1 @@\n-    const Type*         h_extype = TypeOopPtr::make_from_klass(h_klass);\n+    const Type* h_extype = TypeOopPtr::make_from_klass(h_klass);\n@@ -826,3 +827,3 @@\n-    \/\/ Note:  It's OK if the BCIs repeat themselves.\n-    bcis->append(h_bci);\n-    extypes->append(h_extype);\n+    \/\/ Note: It's OK if the BCIs repeat themselves.\n+    bcis.append(h_bci);\n+    extypes.append(h_extype);\n@@ -835,1 +836,1 @@\n-    bcis->append(-1);\n+    bcis.append(-1);\n@@ -838,1 +839,1 @@\n-    extypes->append(extype);\n+    extypes.append(extype);\n@@ -841,1 +842,1 @@\n-  int len = bcis->length();\n+  int len = bcis.length();\n@@ -852,1 +853,1 @@\n-    int handler_bci = bcis->at(i);\n+    int handler_bci = bcis.at(i);\n@@ -859,2 +860,2 @@\n-    const TypeInstPtr* extype = extypes->at(i)->is_instptr();\n-    Node *ex_oop = _gvn.transform(new CreateExNode(extypes->at(i), ctrl, i_o));\n+    const TypeInstPtr* extype = extypes.at(i)->is_instptr();\n+    Node* ex_oop = _gvn.transform(new CreateExNode(extypes.at(i), ctrl, i_o));\n@@ -863,1 +864,1 @@\n-    if (saw_unloaded->contains(handler_bci)) {\n+    if (saw_unloaded.contains(handler_bci)) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"opto\/macro.hpp\"\n@@ -46,1 +47,6 @@\n-  _nodes(C->comp_arena(), C->unique(), C->unique(), nullptr),\n+  \/\/ If ReduceAllocationMerges is enabled we might call split_through_phi during\n+  \/\/ split_unique_types and that will create additional nodes that need to be\n+  \/\/ pushed to the ConnectionGraph. The code below bumps the initial capacity of\n+  \/\/ _nodes by 10% to account for these additional nodes. If capacity is exceeded\n+  \/\/ the array will be reallocated.\n+  _nodes(C->comp_arena(), ReduceAllocationMerges ? C->unique()*1.10 : C->unique(), C->unique(), nullptr),\n@@ -60,0 +66,1 @@\n+  set_not_scalar_replaceable(phantom_obj NOT_PRODUCT(COMMA \"Phantom object\"));\n@@ -65,0 +72,1 @@\n+  set_not_scalar_replaceable(null_obj NOT_PRODUCT(COMMA \"Null object\"));\n@@ -128,0 +136,1 @@\n+  Unique_Node_List reducible_merges;\n@@ -306,1 +315,1 @@\n-      adjust_scalar_replaceable_state(ptn);\n+      adjust_scalar_replaceable_state(ptn, reducible_merges);\n@@ -320,0 +329,9 @@\n+  \/\/ alloc_worklist will be processed in reverse push order.\n+  \/\/ Therefore the reducible Phis will be processed for last and that's what we\n+  \/\/ want because by then the scalarizable inputs of the merge will already have\n+  \/\/ an unique instance type.\n+  for (uint i = 0; i < reducible_merges.size(); i++ ) {\n+    Node* n = reducible_merges.at(i);\n+    alloc_worklist.append(n);\n+  }\n+\n@@ -373,1 +391,1 @@\n-    split_unique_types(alloc_worklist, arraycopy_worklist, mergemem_worklist);\n+    split_unique_types(alloc_worklist, arraycopy_worklist, mergemem_worklist, reducible_merges);\n@@ -393,0 +411,15 @@\n+  \/\/ 6. Remove reducible allocation merges from ideal graph\n+  if (ReduceAllocationMerges && reducible_merges.size() > 0) {\n+    bool delay = _igvn->delay_transform();\n+    _igvn->set_delay_transform(true);\n+    for (uint i = 0; i < reducible_merges.size(); i++ ) {\n+      Node* n = reducible_merges.at(i);\n+      reduce_phi(n->as_Phi());\n+      if (C->failing()) {\n+        NOT_PRODUCT(escape_state_statistics(java_objects_worklist);)\n+        return false;\n+      }\n+    }\n+    _igvn->set_delay_transform(delay);\n+  }\n+\n@@ -415,0 +448,341 @@\n+\/\/ Check if it's profitable to reduce the Phi passed as parameter.  Returns true\n+\/\/ if at least one scalar replaceable allocation participates in the merge and\n+\/\/ no input to the Phi is nullable.\n+bool ConnectionGraph::can_reduce_phi_check_inputs(PhiNode* ophi) const {\n+  \/\/ Check if there is a scalar replaceable allocate in the Phi\n+  bool found_sr_allocate = false;\n+\n+  for (uint i = 1; i < ophi->req(); i++) {\n+    \/\/ Right now we can't restore a \"null\" pointer during deoptimization\n+    const Type* inp_t = _igvn->type(ophi->in(i));\n+    if (inp_t == nullptr || inp_t->make_oopptr() == nullptr || inp_t->make_oopptr()->maybe_null()) {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Input %d is nullable.\", ophi->_idx, _invocation, i);)\n+      return false;\n+    }\n+\n+    \/\/ We are looking for at least one SR object in the merge\n+    JavaObjectNode* ptn = unique_java_object(ophi->in(i));\n+    if (ptn != nullptr && ptn->scalar_replaceable()) {\n+      assert(ptn->ideal_node() != nullptr && ptn->ideal_node()->is_Allocate(), \"sanity\");\n+      AllocateNode* alloc = ptn->ideal_node()->as_Allocate();\n+\n+      if (PhaseMacroExpand::can_eliminate_allocation(_igvn, alloc, nullptr)) {\n+        found_sr_allocate = true;\n+      } else {\n+        ptn->set_scalar_replaceable(false);\n+      }\n+    }\n+  }\n+\n+  NOT_PRODUCT(if (TraceReduceAllocationMerges && !found_sr_allocate) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. No SR Allocate as input.\", ophi->_idx, _invocation);)\n+  return found_sr_allocate;\n+}\n+\n+\/\/ Check if we are able to untangle the merge. Right now we only reduce Phis\n+\/\/ which are only used as debug information.\n+bool ConnectionGraph::can_reduce_phi_check_users(PhiNode* ophi) const {\n+  for (DUIterator_Fast imax, i = ophi->fast_outs(imax); i < imax; i++) {\n+    Node* use = ophi->fast_out(i);\n+\n+    if (use->is_SafePoint()) {\n+      if (use->is_Call() && use->as_Call()->has_non_debug_use(ophi)) {\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Call has non_debug_use().\", ophi->_idx, _invocation);)\n+        return false;\n+      }\n+    } else if (use->is_AddP()) {\n+      Node* addp = use;\n+      for (DUIterator_Fast jmax, j = addp->fast_outs(jmax); j < jmax; j++) {\n+        Node* use_use = addp->fast_out(j);\n+        if (!use_use->is_Load() || !use_use->as_Load()->can_split_through_phi_base(_igvn)) {\n+          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. AddP user isn't a [splittable] Load(): %s\", ophi->_idx, _invocation, use_use->Name());)\n+          return false;\n+        }\n+      }\n+    } else {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. One of the uses is: %d %s\", ophi->_idx, _invocation, use->_idx, use->Name());)\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+\/\/ Returns true if: 1) It's profitable to reduce the merge, and 2) The Phi is\n+\/\/ only used in some certain code shapes. Check comments in\n+\/\/ 'can_reduce_phi_inputs' and 'can_reduce_phi_users' for more\n+\/\/ details.\n+bool ConnectionGraph::can_reduce_phi(PhiNode* ophi) const {\n+  \/\/ If there was an error attempting to reduce allocation merges for this\n+  \/\/ method we might have disabled the compilation and be retrying\n+  \/\/ with RAM disabled.\n+  if (!_compile->do_reduce_allocation_merges()) {\n+    return false;\n+  }\n+\n+  const Type* phi_t = _igvn->type(ophi);\n+  if (phi_t == nullptr || phi_t->make_ptr() == nullptr ||\n+                          phi_t->make_ptr()->isa_instptr() == nullptr ||\n+                          !phi_t->make_ptr()->isa_instptr()->klass_is_exact()) {\n+    NOT_PRODUCT(if (TraceReduceAllocationMerges) { tty->print_cr(\"Can NOT reduce Phi %d during invocation %d because it's nullable.\", ophi->_idx, _invocation); })\n+    return false;\n+  }\n+\n+  if (!can_reduce_phi_check_inputs(ophi) || !can_reduce_phi_check_users(ophi)) {\n+    return false;\n+  }\n+\n+  NOT_PRODUCT(if (TraceReduceAllocationMerges) { tty->print_cr(\"Can reduce Phi %d during invocation %d: \", ophi->_idx, _invocation); })\n+  return true;\n+}\n+\n+void ConnectionGraph::reduce_phi_on_field_access(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist) {\n+  \/\/ We'll pass this to 'split_through_phi' so that it'll do the split even\n+  \/\/ though the load doesn't have an unique instance type.\n+  bool ignore_missing_instance_id = true;\n+\n+  \/\/ Iterate over Phi outputs looking for an AddP\n+  for (int j = ophi->outcnt()-1; j >= 0;) {\n+    Node* previous_addp = ophi->raw_out(j);\n+    uint num_edges = 1;\n+    if (previous_addp->is_AddP()) {\n+      \/\/ All AddPs are present in the connection graph\n+      FieldNode* fn = ptnode_adr(previous_addp->_idx)->as_Field();\n+      num_edges = previous_addp->in(AddPNode::Address) == previous_addp->in(AddPNode::Base) ? 2 : 1;\n+\n+      \/\/ Iterate over AddP looking for a Load\n+      for (int k = previous_addp->outcnt()-1; k >= 0;) {\n+        Node* previous_load = previous_addp->raw_out(k);\n+        if (previous_load->is_Load()) {\n+          Node* data_phi = previous_load->as_Load()->split_through_phi(_igvn, ignore_missing_instance_id);\n+          _igvn->replace_node(previous_load, data_phi);\n+          assert(data_phi != nullptr, \"Output of split_through_phi is null.\");\n+          assert(data_phi != previous_load, \"Output of split_through_phi is same as input.\");\n+\n+          \/\/ Push the newly created AddP on alloc_worklist and patch\n+          \/\/ the connection graph. Note that the changes in the CG below\n+          \/\/ won't affect the ES of objects since the new nodes have the\n+          \/\/ same status as the old ones.\n+          if (data_phi != nullptr && data_phi->is_Phi()) {\n+            for (uint i = 1; i < data_phi->req(); i++) {\n+              Node* new_load = data_phi->in(i);\n+              if (new_load->is_Load()) {\n+                Node* new_addp = new_load->in(MemNode::Address);\n+                Node* base = get_addp_base(new_addp);\n+\n+                \/\/ The base might not be something that we can create an unique\n+                \/\/ type for. If that's the case we are done with that input.\n+                PointsToNode* jobj_ptn = unique_java_object(base);\n+                if (jobj_ptn == nullptr || !jobj_ptn->scalar_replaceable()) {\n+                  continue;\n+                }\n+\n+                \/\/ Push to alloc_worklist since the base has an unique_type\n+                alloc_worklist.append_if_missing(new_addp);\n+\n+                \/\/ Now let's add the node to the connection graph\n+                _nodes.at_grow(new_addp->_idx, nullptr);\n+                add_field(new_addp, fn->escape_state(), fn->offset());\n+                add_base(ptnode_adr(new_addp->_idx)->as_Field(), ptnode_adr(base->_idx));\n+\n+                \/\/ If the load doesn't load an object then it won't be\n+                \/\/ part of the connection graph\n+                PointsToNode* curr_load_ptn = ptnode_adr(previous_load->_idx);\n+                if (curr_load_ptn != nullptr) {\n+                  _nodes.at_grow(new_load->_idx, nullptr);\n+                  add_local_var(new_load, curr_load_ptn->escape_state());\n+                  add_edge(ptnode_adr(new_load->_idx), ptnode_adr(new_addp->_idx)->as_Field());\n+                }\n+              }\n+            }\n+          }\n+        }\n+        --k;\n+        k = MIN2(k, (int)previous_addp->outcnt()-1);\n+      }\n+\n+      \/\/ Remove the old AddP from the processing list because it's dead now\n+      alloc_worklist.remove_if_existing(previous_addp);\n+    }\n+    j -= num_edges;\n+    j = MIN2(j, (int)ophi->outcnt()-1);\n+  }\n+}\n+\n+\/\/ This method will create a SafePointScalarObjectNode for each combination of\n+\/\/ scalar replaceable allocation in 'ophi' and SafePoint node in 'safepoints'.\n+\/\/ The method will create a SafePointScalarMERGEnode for each combination of\n+\/\/ 'ophi' and SafePoint node in 'safepoints'.\n+\/\/ Each SafePointScalarMergeNode created here may describe multiple scalar\n+\/\/ replaced objects - check detailed description in SafePointScalarMergeNode\n+\/\/ class header.\n+\/\/\n+\/\/ This method will set entries in the Phi that are scalar replaceable to 'null'.\n+void ConnectionGraph::reduce_phi_on_safepoints(PhiNode* ophi, Unique_Node_List* safepoints) {\n+  Node* minus_one           = _igvn->register_new_node_with_optimizer(ConINode::make(-1));\n+  Node* selector            = _igvn->register_new_node_with_optimizer(PhiNode::make(ophi->region(), minus_one, TypeInt::INT));\n+  Node* null_ptr            = _igvn->makecon(TypePtr::NULL_PTR);\n+  const TypeOopPtr* merge_t = _igvn->type(ophi)->make_oopptr();\n+  uint number_of_sr_objects = 0;\n+  PhaseMacroExpand mexp(*_igvn);\n+\n+  _igvn->hash_delete(ophi);\n+\n+  \/\/ Fill in the 'selector' Phi. If index 'i' of the selector is:\n+  \/\/ -> a '-1' constant, the i'th input of the original Phi is NSR.\n+  \/\/ -> a 'x' constant >=0, the i'th input of of original Phi will be SR and the\n+  \/\/    info about the scalarized object will be at index x of\n+  \/\/    ObjectMergeValue::possible_objects\n+  for (uint i = 1; i < ophi->req(); i++) {\n+    Node* base          = ophi->in(i);\n+    JavaObjectNode* ptn = unique_java_object(base);\n+\n+    if (ptn != nullptr && ptn->scalar_replaceable()) {\n+      Node* sr_obj_idx = _igvn->register_new_node_with_optimizer(ConINode::make(number_of_sr_objects));\n+      selector->set_req(i, sr_obj_idx);\n+      number_of_sr_objects++;\n+    }\n+  }\n+\n+  \/\/ Update the debug information of all safepoints in turn\n+  for (uint spi = 0; spi < safepoints->size(); spi++) {\n+    SafePointNode* sfpt = safepoints->at(spi)->as_SafePoint();\n+    JVMState *jvms      = sfpt->jvms();\n+    uint merge_idx      = (sfpt->req() - jvms->scloff());\n+    int debug_start     = jvms->debug_start();\n+\n+    SafePointScalarMergeNode* smerge = new SafePointScalarMergeNode(merge_t, merge_idx);\n+    smerge->init_req(0, _compile->root());\n+    _igvn->register_new_node_with_optimizer(smerge);\n+\n+    \/\/ The next two inputs are:\n+    \/\/  (1) A copy of the original pointer to NSR objects.\n+    \/\/  (2) A selector, used to decide if we need to rematerialize an object\n+    \/\/      or use the pointer to a NSR object.\n+    \/\/ See more details of these fields in the declaration of SafePointScalarMergeNode\n+    sfpt->add_req(ophi);\n+    sfpt->add_req(selector);\n+\n+    for (uint i = 1; i < ophi->req(); i++) {\n+      Node* base          = ophi->in(i);\n+      JavaObjectNode* ptn = unique_java_object(base);\n+\n+      \/\/ If the base is not scalar replaceable we don't need to register information about\n+      \/\/ it at this time.\n+      if (ptn == nullptr || !ptn->scalar_replaceable()) {\n+        continue;\n+      }\n+\n+      AllocateNode* alloc = ptn->ideal_node()->as_Allocate();\n+      Unique_Node_List value_worklist;\n+      SafePointScalarObjectNode* sobj = mexp.create_scalarized_object_description(alloc, sfpt, &value_worklist);\n+      guarantee(value_worklist.size() == 0, \"Unimplemented: Valhalla support for 8287061\");\n+      if (sobj == nullptr) {\n+        _compile->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n+        return;\n+      }\n+\n+      \/\/ Now make a pass over the debug information replacing any references\n+      \/\/ to the allocated object with \"sobj\"\n+      Node* ccpp = alloc->result_cast();\n+      sfpt->replace_edges_in_range(ccpp, sobj, debug_start, jvms->debug_end(), _igvn);\n+\n+      \/\/ Register the scalarized object as a candidate for reallocation\n+      smerge->add_req(sobj);\n+    }\n+\n+    \/\/ Replaces debug information references to \"ophi\" in \"sfpt\" with references to \"smerge\"\n+    sfpt->replace_edges_in_range(ophi, smerge, debug_start, jvms->debug_end(), _igvn);\n+\n+    \/\/ The call to 'replace_edges_in_range' above might have removed the\n+    \/\/ reference to ophi that we need at _merge_pointer_idx. The line below make\n+    \/\/ sure the reference is maintained.\n+    sfpt->set_req(smerge->merge_pointer_idx(jvms), ophi);\n+    _igvn->_worklist.push(sfpt);\n+  }\n+\n+  \/\/ Now we can change ophi since we don't need to know the types\n+  \/\/ of the input allocations anymore.\n+  const Type* new_t = merge_t->meet(TypePtr::NULL_PTR);\n+  Node* new_phi = _igvn->register_new_node_with_optimizer(PhiNode::make(ophi->region(), null_ptr, new_t));\n+  for (uint i = 1; i < ophi->req(); i++) {\n+    Node* base          = ophi->in(i);\n+    JavaObjectNode* ptn = unique_java_object(base);\n+\n+    if (ptn != nullptr && ptn->scalar_replaceable()) {\n+      new_phi->set_req(i, null_ptr);\n+    } else {\n+      new_phi->set_req(i, ophi->in(i));\n+    }\n+  }\n+\n+  _igvn->replace_node(ophi, new_phi);\n+  _igvn->hash_insert(ophi);\n+  _igvn->_worklist.push(ophi);\n+}\n+\n+void ConnectionGraph::reduce_phi(PhiNode* ophi) {\n+  Unique_Node_List safepoints;\n+\n+  for (uint i = 0; i < ophi->outcnt(); i++) {\n+    Node* use = ophi->raw_out(i);\n+\n+    \/\/ All SafePoint nodes using the same Phi node use the same debug\n+    \/\/ information (regarding the Phi). Furthermore, reducing the Phi used by a\n+    \/\/ SafePoint requires changing the Phi. Therefore, I collect all safepoints\n+    \/\/ and patch them all at once later.\n+    if (use->is_SafePoint()) {\n+      safepoints.push(use->as_SafePoint());\n+    } else {\n+      assert(false, \"Unexpected use of reducible Phi.\");\n+    }\n+  }\n+\n+  if (safepoints.size() > 0) {\n+    reduce_phi_on_safepoints(ophi, &safepoints);\n+  }\n+}\n+\n+void ConnectionGraph::verify_ram_nodes(Compile* C, Node* root) {\n+  Unique_Node_List ideal_nodes;\n+\n+  ideal_nodes.map(C->live_nodes(), nullptr);  \/\/ preallocate space\n+  ideal_nodes.push(root);\n+\n+  for (uint next = 0; next < ideal_nodes.size(); ++next) {\n+    Node* n = ideal_nodes.at(next);\n+\n+    if (n->is_SafePointScalarMerge()) {\n+      SafePointScalarMergeNode* merge = n->as_SafePointScalarMerge();\n+\n+      \/\/ Validate inputs of merge\n+      for (uint i = 1; i < merge->req(); i++) {\n+        if (merge->in(i) != nullptr && !merge->in(i)->is_top() && !merge->in(i)->is_SafePointScalarObject()) {\n+          assert(false, \"SafePointScalarMerge inputs should be null\/top or SafePointScalarObject.\");\n+          C->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n+        }\n+      }\n+\n+      \/\/ Validate users of merge\n+      for (DUIterator_Fast imax, i = merge->fast_outs(imax); i < imax; i++) {\n+        Node* sfpt = merge->fast_out(i);\n+        if (sfpt->is_SafePoint()) {\n+          int merge_idx = merge->merge_pointer_idx(sfpt->as_SafePoint()->jvms());\n+\n+          if (sfpt->in(merge_idx) != nullptr && sfpt->in(merge_idx)->is_SafePointScalarMerge()) {\n+            assert(false, \"SafePointScalarMerge nodes can't be nested.\");\n+            C->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n+          }\n+        } else {\n+          assert(false, \"Only safepoints can use SafePointScalarMerge nodes.\");\n+          C->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n+        }\n+      }\n+    }\n+\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* m = n->fast_out(i);\n+      ideal_nodes.push(m);\n+    }\n+  }\n+}\n+\n@@ -606,1 +980,2 @@\n-      add_java_object(n, es);\n+      PointsToNode* ptn_con = add_java_object(n, es);\n+      set_not_scalar_replaceable(ptn_con NOT_PRODUCT(COMMA \"Constant pointer\"));\n@@ -698,1 +1073,2 @@\n-      add_java_object(n, PointsToNode::ArgEscape);\n+      PointsToNode* ptn_thr = add_java_object(n, PointsToNode::ArgEscape);\n+      set_not_scalar_replaceable(ptn_thr NOT_PRODUCT(COMMA \"Constant pointer\"));\n@@ -1078,0 +1454,3 @@\n+      if (es == PointsToNode::GlobalEscape) {\n+        set_not_scalar_replaceable(ptnode_adr(call->_idx) NOT_PRODUCT(COMMA \"object can be loaded from boxing cache\"));\n+      }\n@@ -1907,1 +2286,9 @@\n-void ConnectionGraph::adjust_scalar_replaceable_state(JavaObjectNode* jobj) {\n+void ConnectionGraph::adjust_scalar_replaceable_state(JavaObjectNode* jobj, Unique_Node_List &reducible_merges) {\n+  \/\/ A Phi 'x' is a _candidate_ to be reducible if 'can_reduce_phi(x)'\n+  \/\/ returns true. If one of the constraints in this method set 'jobj' to NSR\n+  \/\/ then the candidate Phi is discarded. If the Phi has another SR 'jobj' as\n+  \/\/ input, 'adjust_scalar_replaceable_state' will eventually be called with\n+  \/\/ that other object and the Phi will become a reducible Phi.\n+  \/\/ There could be multiple merges involving the same jobj.\n+  Unique_Node_List candidates;\n+\n@@ -1942,1 +2329,2 @@\n-    \/\/ 3. An object is not scalar replaceable if it is merged with other objects.\n+    \/\/ 3. An object is not scalar replaceable if it is merged with other objects\n+    \/\/ and we can't remove the merge\n@@ -1946,3 +2334,17 @@\n-        \/\/ Mark all objects.\n-        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA trace_merged_message(ptn)));\n-        set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA trace_merged_message(jobj)));\n+        Node* use_n = use->ideal_node();\n+\n+        \/\/ If it's already a candidate or confirmed reducible merge we can skip verification\n+        if (candidates.member(use_n)) {\n+          continue;\n+        } else if (reducible_merges.member(use_n)) {\n+          candidates.push(use_n);\n+          continue;\n+        }\n+\n+        if (ReduceAllocationMerges && use_n->is_Phi() && can_reduce_phi(use_n->as_Phi())) {\n+          candidates.push(use_n);\n+        } else {\n+          \/\/ Mark all objects as NSR if we can't remove the merge\n+          set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA trace_merged_message(ptn)));\n+          set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA trace_merged_message(jobj)));\n+        }\n@@ -2011,1 +2413,1 @@\n-    if (field->base_count() > 1) {\n+    if (field->base_count() > 1 && candidates.size() == 0) {\n@@ -2023,0 +2425,4 @@\n+\n+      if (!jobj->scalar_replaceable()) {\n+        return;\n+      }\n@@ -2025,0 +2431,9 @@\n+\n+  \/\/ The candidate is truly a reducible merge only if none of the other\n+  \/\/ constraints ruled it as NSR. There could be multiple merges involving the\n+  \/\/ same jobj.\n+  assert(jobj->scalar_replaceable(), \"sanity\");\n+  for (uint i = 0; i < candidates.size(); i++ ) {\n+    Node* candidate = candidates.at(i);\n+    reducible_merges.push(candidate);\n+  }\n@@ -2296,1 +2711,1 @@\n-void ConnectionGraph::add_java_object(Node *n, PointsToNode::EscapeState es) {\n+PointsToNode* ConnectionGraph::add_java_object(Node *n, PointsToNode::EscapeState es) {\n@@ -2300,1 +2715,1 @@\n-    return;\n+    return ptadr;\n@@ -2305,0 +2720,1 @@\n+  return ptadr;\n@@ -2402,2 +2818,1 @@\n-JavaObjectNode* ConnectionGraph::unique_java_object(Node *n) {\n-  assert(!_collecting, \"should not call when constructed graph\");\n+JavaObjectNode* ConnectionGraph::unique_java_object(Node *n) const {\n@@ -3258,1 +3673,2 @@\n-                                         GrowableArray<MergeMemNode*> &mergemem_worklist) {\n+                                         GrowableArray<MergeMemNode*> &mergemem_worklist,\n+                                         Unique_Node_List &reducible_merges) {\n@@ -3405,1 +3821,6 @@\n-      JavaObjectNode* jobj = unique_java_object(get_addp_base(n));\n+      Node* addp_base = get_addp_base(n);\n+      if (addp_base != nullptr && reducible_merges.member(addp_base)) {\n+        \/\/ This AddP will go away when we reduce the the Phi\n+        continue;\n+      }\n+      JavaObjectNode* jobj = unique_java_object(addp_base);\n@@ -3426,0 +3847,6 @@\n+      \/\/ Reducible Phi's will be removed from the graph after split_unique_types finishes\n+      if (reducible_merges.member(n)) {\n+        \/\/ Split loads through phi\n+        reduce_phi_on_field_access(n->as_Phi(), alloc_worklist);\n+        continue;\n+      }\n@@ -3578,1 +4005,0 @@\n-  assert(unique_old == _compile->unique(), \"there should be no new ideal nodes after Phase 1\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":444,"deletions":18,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-  void add_java_object(Node* n, PointsToNode::EscapeState es);\n+  PointsToNode* add_java_object(Node* n, PointsToNode::EscapeState es);\n@@ -445,0 +445,4 @@\n+\n+      if (esc != PointsToNode::NoEscape) {\n+        ptn->set_scalar_replaceable(false);\n+      }\n@@ -455,0 +459,4 @@\n+\n+      if (esc != PointsToNode::NoEscape) {\n+        ptn->set_scalar_replaceable(false);\n+      }\n@@ -464,1 +472,1 @@\n-  void adjust_scalar_replaceable_state(JavaObjectNode* jobj);\n+  void adjust_scalar_replaceable_state(JavaObjectNode* jobj, Unique_Node_List &reducible_merges);\n@@ -476,1 +484,1 @@\n-  JavaObjectNode* unique_java_object(Node *n);\n+  JavaObjectNode* unique_java_object(Node *n) const;\n@@ -536,1 +544,2 @@\n-                          GrowableArray<MergeMemNode*> &mergemem_worklist);\n+                          GrowableArray<MergeMemNode*> &mergemem_worklist,\n+                          Unique_Node_List &reducible_merges);\n@@ -581,0 +590,11 @@\n+  \/\/ -------------------------------------------\n+  \/\/ Methods related to Reduce Allocation Merges\n+\n+  bool can_reduce_phi(PhiNode* ophi) const;\n+  bool can_reduce_phi_check_users(PhiNode* ophi) const;\n+  bool can_reduce_phi_check_inputs(PhiNode* ophi) const;\n+\n+  void reduce_phi_on_field_access(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist);\n+  void reduce_phi_on_safepoints(PhiNode* ophi, Unique_Node_List* safepoints);\n+  void reduce_phi(PhiNode* ophi);\n+\n@@ -602,0 +622,3 @@\n+  \/\/ Verify that SafePointScalarMerge nodes are correctly connected\n+  static void verify_ram_nodes(Compile* C, Node* root);\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -263,1 +263,0 @@\n-#ifdef ASSERT\n@@ -265,1 +264,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -502,0 +502,1 @@\n+  case vmIntrinsics::_jvm_commit:               return inline_native_jvm_commit();\n@@ -3220,0 +3221,130 @@\n+\/\/------------------------inline_native_jvm_commit------------------\n+bool LibraryCallKit::inline_native_jvm_commit() {\n+  enum { _true_path = 1, _false_path = 2, PATH_LIMIT };\n+\n+  \/\/ Save input memory and i_o state.\n+  Node* input_memory_state = reset_memory();\n+  set_all_memory(input_memory_state);\n+  Node* input_io_state = i_o();\n+\n+  \/\/ TLS.\n+  Node* tls_ptr = _gvn.transform(new ThreadLocalNode());\n+  \/\/ Jfr java buffer.\n+  Node* java_buffer_offset = _gvn.transform(new AddPNode(top(), tls_ptr, _gvn.transform(MakeConX(in_bytes(JAVA_BUFFER_OFFSET_JFR)))));\n+  Node* java_buffer = _gvn.transform(new LoadPNode(control(), input_memory_state, java_buffer_offset, TypePtr::BOTTOM, TypeRawPtr::NOTNULL, MemNode::unordered));\n+  Node* java_buffer_pos_offset = _gvn.transform(new AddPNode(top(), java_buffer, _gvn.transform(MakeConX(in_bytes(JFR_BUFFER_POS_OFFSET)))));\n+\n+  \/\/ Load the current value of the notified field in the JfrThreadLocal.\n+  Node* notified_offset = basic_plus_adr(top(), tls_ptr, in_bytes(NOTIFY_OFFSET_JFR));\n+  Node* notified = make_load(control(), notified_offset, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n+\n+  \/\/ Test for notification.\n+  Node* notified_cmp = _gvn.transform(new CmpINode(notified, _gvn.intcon(1)));\n+  Node* test_notified = _gvn.transform(new BoolNode(notified_cmp, BoolTest::eq));\n+  IfNode* iff_notified = create_and_map_if(control(), test_notified, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ True branch, is notified.\n+  Node* is_notified = _gvn.transform(new IfTrueNode(iff_notified));\n+  set_control(is_notified);\n+\n+  \/\/ Reset notified state.\n+  Node* notified_reset_memory = store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  \/\/ Iff notified, the return address of the commit method is the current position of the backing java buffer. This is used to reset the event writer.\n+  Node* current_pos_X = _gvn.transform(new LoadXNode(control(), input_memory_state, java_buffer_pos_offset, TypeRawPtr::NOTNULL, TypeX_X, MemNode::unordered));\n+  \/\/ Convert the machine-word to a long.\n+  Node* current_pos = _gvn.transform(ConvX2L(current_pos_X));\n+\n+  \/\/ False branch, not notified.\n+  Node* not_notified = _gvn.transform(new IfFalseNode(iff_notified));\n+  set_control(not_notified);\n+  set_all_memory(input_memory_state);\n+\n+  \/\/ Arg is the next position as a long.\n+  Node* arg = argument(0);\n+  \/\/ Convert long to machine-word.\n+  Node* next_pos_X = _gvn.transform(ConvL2X(arg));\n+\n+  \/\/ Store the next_position to the underlying jfr java buffer.\n+  Node* commit_memory;\n+#ifdef _LP64\n+  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_LONG, Compile::AliasIdxRaw, MemNode::release);\n+#else\n+  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_INT, Compile::AliasIdxRaw, MemNode::release);\n+#endif\n+\n+  \/\/ Now load the flags from off the java buffer and decide if the buffer is a lease. If so, it needs to be returned post-commit.\n+  Node* java_buffer_flags_offset = _gvn.transform(new AddPNode(top(), java_buffer, _gvn.transform(MakeConX(in_bytes(JFR_BUFFER_FLAGS_OFFSET)))));\n+  Node* flags = make_load(control(), java_buffer_flags_offset, TypeInt::UBYTE, T_BYTE, MemNode::unordered);\n+  Node* lease_constant = _gvn.transform(_gvn.intcon(4));\n+\n+  \/\/ And flags with lease constant.\n+  Node* lease = _gvn.transform(new AndINode(flags, lease_constant));\n+\n+  \/\/ Branch on lease to conditionalize returning the leased java buffer.\n+  Node* lease_cmp = _gvn.transform(new CmpINode(lease, lease_constant));\n+  Node* test_lease = _gvn.transform(new BoolNode(lease_cmp, BoolTest::eq));\n+  IfNode* iff_lease = create_and_map_if(control(), test_lease, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ False branch, not a lease.\n+  Node* not_lease = _gvn.transform(new IfFalseNode(iff_lease));\n+\n+  \/\/ True branch, is lease.\n+  Node* is_lease = _gvn.transform(new IfTrueNode(iff_lease));\n+  set_control(is_lease);\n+\n+  \/\/ Make a runtime call, which can safepoint, to return the leased buffer. This updates both the JfrThreadLocal and the Java event writer oop.\n+  Node* call_return_lease = make_runtime_call(RC_NO_LEAF,\n+                                              OptoRuntime::void_void_Type(),\n+                                              StubRoutines::jfr_return_lease(),\n+                                              \"return_lease\", TypePtr::BOTTOM);\n+  Node* call_return_lease_control = _gvn.transform(new ProjNode(call_return_lease, TypeFunc::Control));\n+\n+  RegionNode* lease_compare_rgn = new RegionNode(PATH_LIMIT);\n+  record_for_igvn(lease_compare_rgn);\n+  PhiNode* lease_compare_mem = new PhiNode(lease_compare_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  record_for_igvn(lease_compare_mem);\n+  PhiNode* lease_compare_io = new PhiNode(lease_compare_rgn, Type::ABIO);\n+  record_for_igvn(lease_compare_io);\n+  PhiNode* lease_result_value = new PhiNode(lease_compare_rgn, TypeLong::LONG);\n+  record_for_igvn(lease_result_value);\n+\n+  \/\/ Update control and phi nodes.\n+  lease_compare_rgn->init_req(_true_path, call_return_lease_control);\n+  lease_compare_rgn->init_req(_false_path, not_lease);\n+\n+  lease_compare_mem->init_req(_true_path, _gvn.transform(reset_memory()));\n+  lease_compare_mem->init_req(_false_path, commit_memory);\n+\n+  lease_compare_io->init_req(_true_path, i_o());\n+  lease_compare_io->init_req(_false_path, input_io_state);\n+\n+  lease_result_value->init_req(_true_path, null()); \/\/ if the lease was returned, return 0.\n+  lease_result_value->init_req(_false_path, arg); \/\/ if not lease, return new updated position.\n+\n+  RegionNode* result_rgn = new RegionNode(PATH_LIMIT);\n+  PhiNode* result_mem = new PhiNode(result_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  PhiNode* result_io = new PhiNode(result_rgn, Type::ABIO);\n+  PhiNode* result_value = new PhiNode(result_rgn, TypeLong::LONG);\n+\n+  \/\/ Update control and phi nodes.\n+  result_rgn->init_req(_true_path, is_notified);\n+  result_rgn->init_req(_false_path, _gvn.transform(lease_compare_rgn));\n+\n+  result_mem->init_req(_true_path, notified_reset_memory);\n+  result_mem->init_req(_false_path, _gvn.transform(lease_compare_mem));\n+\n+  result_io->init_req(_true_path, input_io_state);\n+  result_io->init_req(_false_path, _gvn.transform(lease_compare_io));\n+\n+  result_value->init_req(_true_path, current_pos);\n+  result_value->init_req(_false_path, _gvn.transform(lease_result_value));\n+\n+  \/\/ Set output state.\n+  set_control(_gvn.transform(result_rgn));\n+  set_all_memory(_gvn.transform(result_mem));\n+  set_i_o(_gvn.transform(result_io));\n+  set_result(result_rgn, result_value);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+  bool inline_native_jvm_commit();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1891,49 +1891,0 @@\n-\n-\/\/-------------------------insert_scalar_rced_post_loop------------------------\n-\/\/ Insert a copy of the rce'd main loop as a post loop,\n-\/\/ We have not unrolled the main loop, so this is the right time to inject this.\n-\/\/ Later we will examine the partner of this post loop pair which still has range checks\n-\/\/ to see inject code which tests at runtime if the range checks are applicable.\n-void PhaseIdealLoop::insert_scalar_rced_post_loop(IdealLoopTree *loop, Node_List &old_new) {\n-  if (!loop->_head->is_CountedLoop()) return;\n-\n-  CountedLoopNode *cl = loop->_head->as_CountedLoop();\n-\n-  \/\/ only process RCE'd main loops\n-  if (!cl->is_main_loop() || loop->range_checks_present()) return;\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print(\"PostScalarRce  \");\n-    loop->dump_head();\n-  }\n-#endif\n-  C->set_major_progress();\n-\n-  \/\/ Find common pieces of the loop being guarded with pre & post loops\n-  CountedLoopNode *main_head = loop->_head->as_CountedLoop();\n-  CountedLoopEndNode *main_end = main_head->loopexit();\n-  \/\/ diagnostic to show loop end is not properly formed\n-  assert(main_end->outcnt() == 2, \"1 true, 1 false path only\");\n-\n-  Node *incr = main_end->incr();\n-  Node *limit = main_end->limit();\n-\n-  \/\/ In this case we throw away the result as we are not using it to connect anything else.\n-  CountedLoopNode *post_head = nullptr;\n-  insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);\n-  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n-\n-  \/\/ It's difficult to be precise about the trip-counts\n-  \/\/ for post loops.  They are usually very short,\n-  \/\/ so guess that unit vector trips is a reasonable value.\n-  post_head->set_profile_trip_cnt(4.0);\n-  post_head->set_is_rce_post_loop();\n-\n-  \/\/ Now force out all loop-invariant dominating tests.  The optimizer\n-  \/\/ finds some, but we _know_ they are all useless.\n-  peeled_dom_test_elim(loop, old_new);\n-  loop->record_for_igvn();\n-}\n-\n-\n@@ -3201,137 +3152,0 @@\n-\/\/-------------------------multi_version_post_loops----------------------------\n-\/\/ Check the range checks that remain, if simple, use the bounds to guard\n-\/\/ which version to a post loop we execute, one with range checks or one without\n-bool PhaseIdealLoop::multi_version_post_loops(IdealLoopTree *rce_loop, IdealLoopTree *legacy_loop) {\n-  bool multi_version_succeeded = false;\n-  assert(RangeCheckElimination, \"\");\n-  CountedLoopNode *legacy_cl = legacy_loop->_head->as_CountedLoop();\n-  assert(legacy_cl->is_post_loop(), \"\");\n-\n-  \/\/ Check for existence of range checks using the unique instance to make a guard with\n-  Unique_Node_List worklist;\n-  for (uint i = 0; i < legacy_loop->_body.size(); i++) {\n-    Node *iff = legacy_loop->_body[i];\n-    int iff_opc = iff->Opcode();\n-    if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {\n-      worklist.push(iff);\n-    }\n-  }\n-\n-  \/\/ Find RCE'd post loop so that we can stage its guard.\n-  if (legacy_cl->is_canonical_loop_entry() == nullptr) {\n-    return multi_version_succeeded;\n-  }\n-  Node* ctrl = legacy_cl->in(LoopNode::EntryControl);\n-  Node* iffm = ctrl->in(0);\n-\n-  \/\/ Now we test that both the post loops are connected\n-  Node* post_loop_region = iffm->in(0);\n-  if (post_loop_region == nullptr) return multi_version_succeeded;\n-  if (!post_loop_region->is_Region()) return multi_version_succeeded;\n-  Node* covering_region = post_loop_region->in(RegionNode::Control+1);\n-  if (covering_region == nullptr) return multi_version_succeeded;\n-  if (!covering_region->is_Region()) return multi_version_succeeded;\n-  Node* p_f = covering_region->in(RegionNode::Control);\n-  if (p_f == nullptr) return multi_version_succeeded;\n-  if (!p_f->is_IfFalse()) return multi_version_succeeded;\n-  if (!p_f->in(0)->is_CountedLoopEnd()) return multi_version_succeeded;\n-  CountedLoopEndNode* rce_loop_end = p_f->in(0)->as_CountedLoopEnd();\n-  if (rce_loop_end == nullptr) return multi_version_succeeded;\n-  CountedLoopNode* rce_cl = rce_loop_end->loopnode();\n-  if (rce_cl == nullptr || !rce_cl->is_post_loop()) return multi_version_succeeded;\n-  CountedLoopNode *known_rce_cl = rce_loop->_head->as_CountedLoop();\n-  if (rce_cl != known_rce_cl) return multi_version_succeeded;\n-\n-  \/\/ Then we fetch the cover entry test\n-  ctrl = rce_cl->in(LoopNode::EntryControl);\n-  if (!ctrl->is_IfTrue() && !ctrl->is_IfFalse()) return multi_version_succeeded;\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print(\"PostMultiVersion\\n\");\n-    rce_loop->dump_head();\n-    legacy_loop->dump_head();\n-  }\n-#endif\n-\n-  \/\/ Now fetch the limit we want to compare against\n-  Node *limit = rce_cl->limit();\n-  bool first_time = true;\n-\n-  \/\/ If we got this far, we identified the post loop which has been RCE'd and\n-  \/\/ we have a work list.  Now we will try to transform the if guard to cause\n-  \/\/ the loop pair to be multi version executed with the determination left to runtime\n-  \/\/ or the optimizer if full information is known about the given arrays at compile time.\n-  Node *last_min = nullptr;\n-  multi_version_succeeded = true;\n-  while (worklist.size()) {\n-    Node* rc_iffm = worklist.pop();\n-    if (rc_iffm->is_If()) {\n-      Node *rc_bolzm = rc_iffm->in(1);\n-      if (rc_bolzm->is_Bool()) {\n-        Node *rc_cmpzm = rc_bolzm->in(1);\n-        if (rc_cmpzm->is_Cmp()) {\n-          Node *rc_left = rc_cmpzm->in(2);\n-          if (rc_left->Opcode() != Op_LoadRange) {\n-            multi_version_succeeded = false;\n-            break;\n-          }\n-          if (first_time) {\n-            last_min = rc_left;\n-            first_time = false;\n-          } else {\n-            Node *cur_min = new MinINode(last_min, rc_left);\n-            last_min = cur_min;\n-            _igvn.register_new_node_with_optimizer(last_min);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ All we have to do is update the limit of the rce loop\n-  \/\/ with the min of our expression and the current limit.\n-  \/\/ We will use this expression to replace the current limit.\n-  if (last_min && multi_version_succeeded) {\n-    Node *cur_min = new MinINode(last_min, limit);\n-    _igvn.register_new_node_with_optimizer(cur_min);\n-    Node *cmp_node = rce_loop_end->cmp_node();\n-    _igvn.replace_input_of(cmp_node, 2, cur_min);\n-    set_ctrl(cur_min, ctrl);\n-    set_loop(cur_min, rce_loop->_parent);\n-\n-    legacy_cl->mark_is_multiversioned();\n-    rce_cl->mark_is_multiversioned();\n-    multi_version_succeeded = true;\n-\n-    C->set_major_progress();\n-  }\n-\n-  return multi_version_succeeded;\n-}\n-\n-\/\/-------------------------poison_rce_post_loop--------------------------------\n-\/\/ Causes the rce'd post loop to be optimized away if multiversioning fails\n-void PhaseIdealLoop::poison_rce_post_loop(IdealLoopTree *rce_loop) {\n-  CountedLoopNode *rce_cl = rce_loop->_head->as_CountedLoop();\n-  Node* ctrl = rce_cl->in(LoopNode::EntryControl);\n-  if (ctrl->is_IfTrue() || ctrl->is_IfFalse()) {\n-    Node* iffm = ctrl->in(0);\n-    if (iffm->is_If()) {\n-      Node* cur_bool = iffm->in(1);\n-      if (cur_bool->is_Bool()) {\n-        Node* cur_cmp = cur_bool->in(1);\n-        if (cur_cmp->is_Cmp()) {\n-          BoolTest::mask new_test = BoolTest::gt;\n-          BoolNode *new_bool = new BoolNode(cur_cmp, new_test);\n-          _igvn.replace_node(cur_bool, new_bool);\n-          _igvn._worklist.push(new_bool);\n-          Node* left_op = cur_cmp->in(1);\n-          _igvn.replace_input_of(cur_cmp, 2, left_op);\n-          C->set_major_progress();\n-        }\n-      }\n-    }\n-  }\n-}\n-\n@@ -3867,8 +3681,0 @@\n-    if (should_unroll && !should_peel && PostLoopMultiversioning &&\n-        Matcher::has_predicated_vectors()) {\n-      \/\/ Try to setup multiversioning on main loops before they are unrolled\n-      if (cl->is_main_loop() && (cl->unrolled_count() == 1)) {\n-        phase->insert_scalar_rced_post_loop(this, old_new);\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":0,"deletions":194,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -4016,1 +4016,0 @@\n-    if (cl->is_multiversioned()) tty->print(\" multi \");\n@@ -4656,23 +4655,1 @@\n-\n-        if (cl->is_rce_post_loop() && !cl->is_vectorized_loop()) {\n-          assert(PostLoopMultiversioning, \"multiversioning must be enabled\");\n-          \/\/ Check that the rce'd post loop is encountered first, multiversion after all\n-          \/\/ major main loop optimization are concluded\n-          if (!C->major_progress()) {\n-            IdealLoopTree *lpt_next = lpt->_next;\n-            if (lpt_next && lpt_next->is_counted()) {\n-              CountedLoopNode *cl = lpt_next->_head->as_CountedLoop();\n-              if (cl->is_post_loop() && lpt_next->range_checks_present()) {\n-                if (!cl->is_multiversioned()) {\n-                  if (multi_version_post_loops(lpt, lpt_next) == false) {\n-                    \/\/ Cause the rce loop to be optimized away if we fail\n-                    cl->mark_is_multiversioned();\n-                    cl->set_slp_max_unroll(0);\n-                    poison_rce_post_loop(lpt);\n-                  }\n-                }\n-              }\n-            }\n-            sw.transform_loop(lpt, true);\n-          }\n-        } else if (cl->is_main_loop()) {\n+        if (cl->is_main_loop()) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -75,7 +75,6 @@\n-         IsMultiversioned      = 1<<12,\n-         StripMined            = 1<<13,\n-         SubwordLoop           = 1<<14,\n-         ProfileTripFailed     = 1<<15,\n-         LoopNestInnerLoop     = 1<<16,\n-         LoopNestLongOuterLoop = 1<<17,\n-         FlattenedArrays       = 1<<18};\n+         StripMined            = 1<<12,\n+         SubwordLoop           = 1<<13,\n+         ProfileTripFailed     = 1<<14,\n+         LoopNestInnerLoop     = 1<<15,\n+         LoopNestLongOuterLoop = 1<<16,\n+         FlattenedArrays       = 1<<17};\n@@ -84,2 +83,0 @@\n-  char _postloop_flags;\n-  enum { RCEPostLoop = 1 };\n@@ -97,1 +94,0 @@\n-  bool is_multiversioned() const { return _loop_flags & IsMultiversioned; }\n@@ -115,1 +111,0 @@\n-  void mark_is_multiversioned() { _loop_flags |= IsMultiversioned; }\n@@ -127,3 +122,0 @@\n-  int is_rce_post_loop() const { return _postloop_flags & RCEPostLoop; }\n-  void set_is_rce_post_loop() { _postloop_flags |= RCEPostLoop; }\n-\n@@ -140,1 +132,1 @@\n-      _postloop_flags(0), _profile_trip_cnt(COUNT_UNKNOWN)  {\n+      _profile_trip_cnt(COUNT_UNKNOWN) {\n@@ -328,2 +320,0 @@\n-  void set_slp_pack_count(int pack_count)    { _slp_vector_pack_count = pack_count; }\n-  int  slp_pack_count() const                { return _slp_vector_pack_count; }\n@@ -1311,3 +1301,0 @@\n-  \/\/ Add an RCE'd post loop which we will multi-version adapt for run time test path usage\n-  void insert_scalar_rced_post_loop( IdealLoopTree *loop, Node_List &old_new );\n-\n@@ -1408,7 +1395,0 @@\n-  \/\/ Process post loops which have range checks and try to build a multi-version\n-  \/\/ guard to safely determine if we can execute the post loop which was RCE'd.\n-  bool multi_version_post_loops(IdealLoopTree *rce_loop, IdealLoopTree *legacy_loop);\n-\n-  \/\/ Cause the rce'd post loop to optimized away, this happens if we cannot complete multiverioning\n-  void poison_rce_post_loop(IdealLoopTree *rce_loop);\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":7,"deletions":27,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1872,1 +1872,7 @@\n-                register_new_node(cast, x_ctrl);\n+                Node* prev = _igvn.hash_find_insert(cast);\n+                if (prev != nullptr) {\n+                  cast->destruct(&_igvn);\n+                  cast = prev;\n+                } else {\n+                  register_new_node(cast, x_ctrl);\n+                }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-    Node* adr = _igvn.transform(new AddPNode(base, base, MakeConX(offset)));\n+    Node* adr = _igvn.transform(new AddPNode(base, base, _igvn.MakeConX(offset)));\n@@ -301,1 +301,1 @@\n-        adr = _igvn.transform(new AddPNode(base, base, MakeConX(off)));\n+        adr = _igvn.transform(new AddPNode(base, base, _igvn.MakeConX(off)));\n@@ -318,1 +318,1 @@\n-        diff = _igvn.transform(new LShiftXNode(diff, intcon(shift)));\n+        diff = _igvn.transform(new LShiftXNode(diff, _igvn.intcon(shift)));\n@@ -320,1 +320,1 @@\n-        Node* off = _igvn.transform(new AddXNode(MakeConX(offset), diff));\n+        Node* off = _igvn.transform(new AddXNode(_igvn.MakeConX(offset), diff));\n@@ -610,1 +610,1 @@\n-bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints) {\n+bool PhaseMacroExpand::can_eliminate_allocation(PhaseIterGVN* igvn, AllocateNode *alloc, GrowableArray <SafePointNode *>* safepoints) {\n@@ -615,1 +615,2 @@\n-  bool  can_eliminate = true;\n+  bool can_eliminate = true;\n+  bool reduce_merge_precheck = (safepoints == nullptr);\n@@ -627,1 +628,1 @@\n-    res_type = _igvn.type(res)->isa_oopptr();\n+    res_type = igvn->type(res)->isa_oopptr();\n@@ -647,1 +648,1 @@\n-        const TypePtr* addp_type = _igvn.type(use)->is_ptr();\n+        const TypePtr* addp_type = igvn->type(use)->is_ptr();\n@@ -688,2 +689,2 @@\n-        } else {\n-          safepoints.append_if_missing(sfpt);\n+        } else if (!reduce_merge_precheck) {\n+          safepoints->append_if_missing(sfpt);\n@@ -712,0 +713,2 @@\n+      } else if (reduce_merge_precheck && (use->is_Phi() || use->is_EncodeP() || use->Opcode() == Op_MemBarRelease)) {\n+        \/\/ Nothing to do\n@@ -737,1 +740,1 @@\n-  if (PrintEliminateAllocations) {\n+  if (PrintEliminateAllocations && safepoints != nullptr) {\n@@ -762,11 +765,1 @@\n-\/\/ Do scalar replacement.\n-bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints) {\n-  GrowableArray <SafePointNode *> safepoints_done;\n-\n-  ciInstanceKlass* iklass = nullptr;\n-  int nfields = 0;\n-  int array_base = 0;\n-  int element_size = 0;\n-  BasicType basic_elem_type = T_ILLEGAL;\n-  const Type* field_type = nullptr;\n-\n+void PhaseMacroExpand::undo_previous_scalarizations(GrowableArray <SafePointNode *> safepoints_done, AllocateNode* alloc) {\n@@ -774,0 +767,1 @@\n+  int nfields = 0;\n@@ -775,0 +769,51 @@\n+\n+  if (res != nullptr) {\n+    const TypeOopPtr* res_type = _igvn.type(res)->isa_oopptr();\n+\n+    if (res_type->isa_instptr()) {\n+      \/\/ find the fields of the class which will be needed for safepoint debug information\n+      ciInstanceKlass* iklass = res_type->is_instptr()->instance_klass();\n+      nfields = iklass->nof_nonstatic_fields();\n+    } else {\n+      \/\/ find the array's elements which will be needed for safepoint debug information\n+      nfields = alloc->in(AllocateNode::ALength)->find_int_con(-1);\n+      assert(nfields >= 0, \"must be an array klass.\");\n+    }\n+  }\n+\n+  \/\/ rollback processed safepoints\n+  while (safepoints_done.length() > 0) {\n+    SafePointNode* sfpt_done = safepoints_done.pop();\n+    \/\/ remove any extra entries we added to the safepoint\n+    uint last = sfpt_done->req() - 1;\n+    for (int k = 0;  k < nfields; k++) {\n+      sfpt_done->del_req(last--);\n+    }\n+    JVMState *jvms = sfpt_done->jvms();\n+    jvms->set_endoff(sfpt_done->req());\n+    \/\/ Now make a pass over the debug information replacing any references\n+    \/\/ to SafePointScalarObjectNode with the allocated object.\n+    int start = jvms->debug_start();\n+    int end   = jvms->debug_end();\n+    for (int i = start; i < end; i++) {\n+      if (sfpt_done->in(i)->is_SafePointScalarObject()) {\n+        SafePointScalarObjectNode* scobj = sfpt_done->in(i)->as_SafePointScalarObject();\n+        if (scobj->first_index(jvms) == sfpt_done->req() &&\n+            scobj->n_fields() == (uint)nfields) {\n+          assert(scobj->alloc() == alloc, \"sanity\");\n+          sfpt_done->set_req(i, res);\n+        }\n+      }\n+    }\n+    _igvn._worklist.push(sfpt_done);\n+  }\n+}\n+\n+SafePointScalarObjectNode* PhaseMacroExpand::create_scalarized_object_description(AllocateNode *alloc, SafePointNode* sfpt,\n+                                                                                  Unique_Node_List* value_worklist) {\n+  \/\/ Fields of scalar objs are referenced only at the end\n+  \/\/ of regular debuginfo at the last (youngest) JVMS.\n+  \/\/ Record relative start index.\n+  ciInstanceKlass* iklass    = nullptr;\n+  BasicType basic_elem_type  = T_ILLEGAL;\n+  const Type* field_type     = nullptr;\n@@ -776,0 +821,9 @@\n+  int nfields                = 0;\n+  int array_base             = 0;\n+  int element_size           = 0;\n+  uint first_ind             = (sfpt->req() - sfpt->jvms()->scloff());\n+  Node* res                  = alloc->result_cast();\n+\n+  assert(res == nullptr || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n+  assert(sfpt->jvms() != nullptr, \"missed JVMS\");\n+\n@@ -778,1 +832,0 @@\n-  }\n@@ -780,1 +833,0 @@\n-  if (res != nullptr) {\n@@ -799,50 +851,26 @@\n-  \/\/\n-  \/\/ Process the safepoint uses\n-  \/\/\n-  assert(safepoints.length() == 0 || !res_type->is_inlinetypeptr(), \"Inline type allocations should not have safepoint uses\");\n-  Unique_Node_List value_worklist;\n-  while (safepoints.length() > 0) {\n-    SafePointNode* sfpt = safepoints.pop();\n-    Node* mem = sfpt->memory();\n-    Node* ctl = sfpt->control();\n-    assert(sfpt->jvms() != nullptr, \"missed JVMS\");\n-    \/\/ Fields of scalar objs are referenced only at the end\n-    \/\/ of regular debuginfo at the last (youngest) JVMS.\n-    \/\/ Record relative start index.\n-    uint first_ind = (sfpt->req() - sfpt->jvms()->scloff());\n-    SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,\n-#ifdef ASSERT\n-                                                 alloc,\n-#endif\n-                                                 first_ind, nfields);\n-    sobj->init_req(0, C->root());\n-    transform_later(sobj);\n-\n-    \/\/ Scan object's fields adding an input to the safepoint for each field.\n-    for (int j = 0; j < nfields; j++) {\n-      intptr_t offset;\n-      ciField* field = nullptr;\n-      if (iklass != nullptr) {\n-        field = iklass->nonstatic_field_at(j);\n-        offset = field->offset_in_bytes();\n-        ciType* elem_type = field->type();\n-        basic_elem_type = field->layout_type();\n-        assert(!field->is_flattened(), \"flattened inline type fields should not have safepoint uses\");\n-\n-        \/\/ The next code is taken from Parse::do_get_xxx().\n-        if (is_reference_type(basic_elem_type)) {\n-          if (!elem_type->is_loaded()) {\n-            field_type = TypeInstPtr::BOTTOM;\n-          } else if (field != nullptr && field->is_static_constant()) {\n-            ciObject* con = field->constant_value().as_object();\n-            \/\/ Do not \"join\" in the previous type; it doesn't add value,\n-            \/\/ and may yield a vacuous result if the field is of interface type.\n-            field_type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n-            assert(field_type != nullptr, \"field singleton type must be consistent\");\n-          } else {\n-            field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n-          }\n-          if (UseCompressedOops) {\n-            field_type = field_type->make_narrowoop();\n-            basic_elem_type = T_NARROWOOP;\n-          }\n+\n+  SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type, alloc, first_ind, nfields);\n+  sobj->init_req(0, C->root());\n+  transform_later(sobj);\n+\n+  \/\/ Scan object's fields adding an input to the safepoint for each field.\n+  for (int j = 0; j < nfields; j++) {\n+    intptr_t offset;\n+    ciField* field = nullptr;\n+    if (iklass != nullptr) {\n+      field = iklass->nonstatic_field_at(j);\n+      offset = field->offset_in_bytes();\n+      ciType* elem_type = field->type();\n+      basic_elem_type = field->layout_type();\n+      assert(!field->is_flattened(), \"flattened inline type fields should not have safepoint uses\");\n+\n+      \/\/ The next code is taken from Parse::do_get_xxx().\n+      if (is_reference_type(basic_elem_type)) {\n+        if (!elem_type->is_loaded()) {\n+          field_type = TypeInstPtr::BOTTOM;\n+        } else if (field != nullptr && field->is_static_constant()) {\n+          ciObject* con = field->constant_value().as_object();\n+          \/\/ Do not \"join\" in the previous type; it doesn't add value,\n+          \/\/ and may yield a vacuous result if the field is of interface type.\n+          field_type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n+          assert(field_type != nullptr, \"field singleton type must be consistent\");\n@@ -850,1 +878,5 @@\n-          field_type = Type::get_const_basic_type(basic_elem_type);\n+          field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n+        }\n+        if (UseCompressedOops) {\n+          field_type = field_type->make_narrowoop();\n+          basic_elem_type = T_NARROWOOP;\n@@ -853,1 +885,1 @@\n-        offset = array_base + j * (intptr_t)element_size;\n+        field_type = Type::get_const_basic_type(basic_elem_type);\n@@ -855,0 +887,3 @@\n+    } else {\n+      offset = array_base + j * (intptr_t)element_size;\n+    }\n@@ -856,8 +891,16 @@\n-      Node* field_val = nullptr;\n-      const TypeOopPtr* field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n-      if (res_type->is_flat()) {\n-        ciInlineKlass* vk = res_type->is_aryptr()->elem()->inline_klass();\n-        assert(vk->flatten_array(), \"must be flattened\");\n-        field_val = inline_type_from_mem(mem, ctl, vk, field_addr_type->isa_aryptr(), 0, alloc);\n-      } else {\n-        field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);\n+    Node* field_val = nullptr;\n+    const TypeOopPtr* field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n+    if (res_type->is_flat()) {\n+      ciInlineKlass* vk = res_type->is_aryptr()->elem()->inline_klass();\n+      assert(vk->flatten_array(), \"must be flattened\");\n+      field_val = inline_type_from_mem(sfpt->memory(), sfpt->control(), vk, field_addr_type->isa_aryptr(), 0, alloc);\n+    } else {\n+      field_val = value_from_mem(sfpt->memory(), sfpt->control(), basic_elem_type, field_type, field_addr_type, alloc);\n+    }\n+\n+    \/\/ We weren't able to find a value for this field,\n+    \/\/ give up on eliminating this allocation.\n+    if (field_val == nullptr) {\n+      uint last = sfpt->req() - 1;\n+      for (int k = 0;  k < j; k++) {\n+        sfpt->del_req(last--);\n@@ -865,36 +908,2 @@\n-      if (field_val == nullptr) {\n-        \/\/ We weren't able to find a value for this field,\n-        \/\/ give up on eliminating this allocation.\n-\n-        \/\/ Remove any extra entries we added to the safepoint.\n-        uint last = sfpt->req() - 1;\n-        for (int k = 0;  k < j; k++) {\n-          sfpt->del_req(last--);\n-        }\n-        _igvn._worklist.push(sfpt);\n-        \/\/ rollback processed safepoints\n-        while (safepoints_done.length() > 0) {\n-          SafePointNode* sfpt_done = safepoints_done.pop();\n-          \/\/ remove any extra entries we added to the safepoint\n-          last = sfpt_done->req() - 1;\n-          for (int k = 0;  k < nfields; k++) {\n-            sfpt_done->del_req(last--);\n-          }\n-          JVMState *jvms = sfpt_done->jvms();\n-          jvms->set_endoff(sfpt_done->req());\n-          \/\/ Now make a pass over the debug information replacing any references\n-          \/\/ to SafePointScalarObjectNode with the allocated object.\n-          int start = jvms->debug_start();\n-          int end   = jvms->debug_end();\n-          for (int i = start; i < end; i++) {\n-            if (sfpt_done->in(i)->is_SafePointScalarObject()) {\n-              SafePointScalarObjectNode* scobj = sfpt_done->in(i)->as_SafePointScalarObject();\n-              if (scobj->first_index(jvms) == sfpt_done->req() &&\n-                  scobj->n_fields() == (uint)nfields) {\n-                assert(scobj->alloc() == alloc, \"sanity\");\n-                sfpt_done->set_req(i, res);\n-              }\n-            }\n-          }\n-          _igvn._worklist.push(sfpt_done);\n-        }\n+      _igvn._worklist.push(sfpt);\n+\n@@ -902,16 +911,8 @@\n-        if (PrintEliminateAllocations) {\n-          if (field != nullptr) {\n-            tty->print(\"=== At SafePoint node %d can't find value of Field: \",\n-                       sfpt->_idx);\n-            field->print();\n-            int field_idx = C->get_alias_index(field_addr_type);\n-            tty->print(\" (alias_idx=%d)\", field_idx);\n-          } else { \/\/ Array's element\n-            tty->print(\"=== At SafePoint node %d can't find value of array element [%d]\",\n-                       sfpt->_idx, j);\n-          }\n-          tty->print(\", which prevents elimination of: \");\n-          if (res == nullptr)\n-            alloc->dump();\n-          else\n-            res->dump();\n+      if (PrintEliminateAllocations) {\n+        if (field != nullptr) {\n+          tty->print(\"=== At SafePoint node %d can't find value of field: \", sfpt->_idx);\n+          field->print();\n+          int field_idx = C->get_alias_index(field_addr_type);\n+          tty->print(\" (alias_idx=%d)\", field_idx);\n+        } else { \/\/ Array's element\n+          tty->print(\"=== At SafePoint node %d can't find value of array element [%d]\", sfpt->_idx, j);\n@@ -919,2 +920,5 @@\n-#endif\n-        return false;\n+        tty->print(\", which prevents elimination of: \");\n+        if (res == nullptr)\n+          alloc->dump();\n+        else\n+          res->dump();\n@@ -922,12 +926,12 @@\n-      if (UseCompressedOops && field_type->isa_narrowoop()) {\n-        \/\/ Enable \"DecodeN(EncodeP(Allocate)) --> Allocate\" transformation\n-        \/\/ to be able scalar replace the allocation.\n-        if (field_val->is_EncodeP()) {\n-          field_val = field_val->in(1);\n-        } else if (!field_val->is_InlineType()) {\n-          field_val = transform_later(new DecodeNNode(field_val, field_val->get_ptr_type()));\n-        }\n-      }\n-      if (field_val->is_InlineType()) {\n-        \/\/ Keep track of inline types to scalarize them later\n-        value_worklist.push(field_val);\n+#endif\n+\n+      return nullptr;\n+    }\n+\n+    if (UseCompressedOops && field_type->isa_narrowoop()) {\n+      \/\/ Enable \"DecodeN(EncodeP(Allocate)) --> Allocate\" transformation\n+      \/\/ to be able scalar replace the allocation.\n+      if (field_val->is_EncodeP()) {\n+        field_val = field_val->in(1);\n+      } else if (!field_val->is_InlineType()) {\n+        field_val = transform_later(new DecodeNNode(field_val, field_val->get_ptr_type()));\n@@ -935,1 +939,0 @@\n-      sfpt->add_req(field_val);\n@@ -937,2 +940,34 @@\n-    JVMState *jvms = sfpt->jvms();\n-    jvms->set_endoff(sfpt->req());\n+    if (field_val->is_InlineType()) {\n+      \/\/ Keep track of inline types to scalarize them later\n+      value_worklist->push(field_val);\n+    }\n+    sfpt->add_req(field_val);\n+  }\n+\n+  sfpt->jvms()->set_endoff(sfpt->req());\n+\n+  return sobj;\n+}\n+\n+\/\/ Do scalar replacement.\n+bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints) {\n+  GrowableArray <SafePointNode *> safepoints_done;\n+  Node* res = alloc->result_cast();\n+  assert(res == nullptr || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n+  const TypeOopPtr* res_type = nullptr;\n+  if (res != nullptr) { \/\/ Could be null when there are no users\n+    res_type = _igvn.type(res)->isa_oopptr();\n+  }\n+\n+  \/\/ Process the safepoint uses\n+  assert(safepoints.length() == 0 || !res_type->is_inlinetypeptr(), \"Inline type allocations should not have safepoint uses\");\n+  Unique_Node_List value_worklist;\n+  while (safepoints.length() > 0) {\n+    SafePointNode* sfpt = safepoints.pop();\n+    SafePointScalarObjectNode* sobj = create_scalarized_object_description(alloc, sfpt, &value_worklist);\n+\n+    if (sobj == nullptr) {\n+      undo_previous_scalarizations(safepoints_done, alloc);\n+      return false;\n+    }\n+\n@@ -941,3 +976,2 @@\n-    int start = jvms->debug_start();\n-    int end   = jvms->debug_end();\n-    sfpt->replace_edges_in_range(res, sobj, start, end, &_igvn);\n+    JVMState *jvms = sfpt->jvms();\n+    sfpt->replace_edges_in_range(res, sobj, jvms->debug_start(), jvms->debug_end(), &_igvn);\n@@ -945,1 +979,3 @@\n-    safepoints_done.append_if_missing(sfpt); \/\/ keep it for rollback\n+\n+    \/\/ keep it for rollback\n+    safepoints_done.append_if_missing(sfpt);\n@@ -1172,1 +1208,1 @@\n-  if (!can_eliminate_allocation(alloc, safepoints)) {\n+  if (!can_eliminate_allocation(&_igvn, alloc, &safepoints)) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":194,"deletions":158,"binary":false,"changes":352,"status":"modified"},{"patch":"@@ -103,2 +103,2 @@\n-  bool can_eliminate_allocation(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints);\n-  bool scalar_replacement(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints_done);\n+  void undo_previous_scalarizations(GrowableArray <SafePointNode *> safepoints_done, AllocateNode* alloc);\n+  bool scalar_replacement(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints);\n@@ -223,0 +223,4 @@\n+  SafePointScalarObjectNode* create_scalarized_object_description(AllocateNode *alloc, SafePointNode* sfpt, Unique_Node_List* value_worklist);\n+  static bool can_eliminate_allocation(PhaseIterGVN *igvn, AllocateNode *alloc, GrowableArray <SafePointNode *> *safepoints);\n+\n+\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1549,0 +1549,29 @@\n+\n+\/\/------------------------------split_through_phi------------------------------\n+\/\/ Check whether a call to 'split_through_phi' would split this load through the\n+\/\/ Phi *base*. This method is essentially a copy of the validations performed\n+\/\/ by 'split_through_phi'. The first use of this method was in EA code as part\n+\/\/ of simplification of allocation merges.\n+bool LoadNode::can_split_through_phi_base(PhaseGVN* phase) {\n+  Node* mem        = in(Memory);\n+  Node* address    = in(Address);\n+  intptr_t ignore  = 0;\n+  Node*    base    = AddPNode::Ideal_base_and_offset(address, phase, ignore);\n+  bool base_is_phi = (base != nullptr) && base->is_Phi();\n+\n+  if (req() > 3 || !base_is_phi) {\n+    return false;\n+  }\n+\n+  if (!mem->is_Phi()) {\n+    if (!MemNode::all_controls_dominate(mem, base->in(0)))\n+      return false;\n+  } else if (base->in(0) != mem->in(0)) {\n+    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n@@ -1551,1 +1580,1 @@\n-Node* LoadNode::split_through_phi(PhaseGVN* phase) {\n+Node* LoadNode::split_through_phi(PhaseGVN* phase, bool ignore_missing_instance_id) {\n@@ -1562,1 +1591,2 @@\n-         (t_oop->is_known_instance_field() ||\n+         (ignore_missing_instance_id ||\n+          t_oop->is_known_instance_field() ||\n@@ -1574,2 +1604,2 @@\n-        (load_boxed_values || t_oop->is_known_instance_field()))) {\n-    return nullptr; \/\/ memory is not Phi\n+        (ignore_missing_instance_id || load_boxed_values || t_oop->is_known_instance_field()))) {\n+    return nullptr; \/\/ Neither memory or base are Phi\n@@ -1619,1 +1649,1 @@\n-  assert(C->have_alias_type(t_oop), \"instance should have alias type\");\n+  assert(ignore_missing_instance_id || C->have_alias_type(t_oop), \"instance should have alias type\");\n@@ -1655,0 +1685,1 @@\n+  Node* phi = nullptr;\n@@ -1656,7 +1687,0 @@\n-  int this_index  = C->get_alias_index(t_oop);\n-  int this_offset = t_oop->offset();\n-  int this_iid    = t_oop->instance_id();\n-  if (!t_oop->is_known_instance() && load_boxed_values) {\n-    \/\/ Use _idx of address base for boxed values.\n-    this_iid = base->_idx;\n-  }\n@@ -1664,1 +1688,11 @@\n-  Node* phi = new PhiNode(region, this_type, nullptr, mem->_idx, this_iid, this_index, this_offset);\n+  if (t_oop != nullptr && (t_oop->is_known_instance_field() || load_boxed_values)) {\n+    int this_index = C->get_alias_index(t_oop);\n+    int this_offset = t_oop->offset();\n+    int this_iid = t_oop->is_known_instance_field() ? t_oop->instance_id() : base->_idx;\n+    phi = new PhiNode(region, this_type, nullptr, mem->_idx, this_iid, this_index, this_offset);\n+  } else if (ignore_missing_instance_id) {\n+    phi = new PhiNode(region, this_type, nullptr, mem->_idx);\n+  } else {\n+    return nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":47,"deletions":13,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -251,0 +251,3 @@\n+  \/\/ Return true if it's possible to split the Load through a Phi merging the bases\n+  bool can_split_through_phi_base(PhaseGVN *phase);\n+\n@@ -252,1 +255,1 @@\n-  Node* split_through_phi(PhaseGVN *phase);\n+  Node* split_through_phi(PhaseGVN *phase, bool ignore_missing_instance_id = false);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+class SafePointScalarMergeNode;\n@@ -737,0 +738,1 @@\n+      DEFINE_CLASS_ID(SafePointScalarMerge, Type, 9)\n@@ -969,0 +971,1 @@\n+  DEFINE_CLASS_QUERY(SafePointScalarMerge)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -798,1 +798,1 @@\n-    ObjectValue* sv = sv_for_node_id(objs, spobj->_idx);\n+    ObjectValue* sv = (ObjectValue*) sv_for_node_id(objs, spobj->_idx);\n@@ -831,0 +831,25 @@\n+  } else if (local->is_SafePointScalarMerge()) {\n+    SafePointScalarMergeNode* smerge = local->as_SafePointScalarMerge();\n+    ObjectMergeValue* mv = (ObjectMergeValue*) sv_for_node_id(objs, smerge->_idx);\n+\n+    if (mv == NULL) {\n+      GrowableArray<ScopeValue*> deps;\n+\n+      int merge_pointer_idx = smerge->merge_pointer_idx(sfpt->jvms());\n+      (void)FillLocArray(0, sfpt, sfpt->in(merge_pointer_idx), &deps, objs);\n+      assert(deps.length() == 1, \"missing value\");\n+\n+      int selector_idx = smerge->selector_idx(sfpt->jvms());\n+      (void)FillLocArray(1, NULL, sfpt->in(selector_idx), &deps, NULL);\n+      assert(deps.length() == 2, \"missing value\");\n+\n+      mv = new ObjectMergeValue(smerge->_idx, deps.at(0), deps.at(1));\n+      set_sv_for_object_node(objs, mv);\n+\n+      for (uint i = 1; i < smerge->req(); i++) {\n+        Node* obj_node = smerge->in(i);\n+        (void)FillLocArray(mv->possible_objects()->length(), sfpt, obj_node, mv->possible_objects(), objs);\n+      }\n+    }\n+    array->append(mv);\n+    return;\n@@ -996,0 +1021,12 @@\n+\/\/ Determine if there is a monitor that has 'ov' as its owner.\n+bool PhaseOutput::contains_as_owner(GrowableArray<MonitorValue*> *monarray, ObjectValue *ov) const {\n+  for (int k = 0; k < monarray->length(); k++) {\n+    MonitorValue* mv = monarray->at(k);\n+    if (mv->owner() == ov) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n@@ -1130,0 +1167,15 @@\n+    \/\/ Mark ObjectValue nodes as root nodes if they are directly\n+    \/\/ referenced in the JVMS.\n+    for (int i = 0; i < objs->length(); i++) {\n+      ScopeValue* sv = objs->at(i);\n+      if (sv->is_object_merge()) {\n+        ObjectMergeValue* merge = sv->as_ObjectMergeValue();\n+\n+        for (int j = 0; j< merge->possible_objects()->length(); j++) {\n+          ObjectValue* ov = merge->possible_objects()->at(j)->as_ObjectValue();\n+          bool is_root = locarray->contains(ov) || exparray->contains(ov) || contains_as_owner(monarray, ov);\n+          ov->set_root(is_root);\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+  bool contains_as_owner(GrowableArray<MonitorValue*> *monarray, ObjectValue *ov) const;\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  _post_block(arena(), 8, 0, nullptr),                      \/\/ nodes common to current block which are marked as post loop vectorizable\n@@ -119,5 +118,0 @@\n-  if (cl->is_rce_post_loop() && is_marked_reduction_loop()) {\n-    \/\/ Post loop vectorization doesn't support reductions\n-    return false;\n-  }\n-\n@@ -179,18 +173,0 @@\n-    if (PostLoopMultiversioning) {\n-      if (cl->is_vectorized_loop() && cl->is_main_loop() && !is_marked_reduction_loop()) {\n-        IdealLoopTree *lpt_next = cl->is_strip_mined() ? lpt->_parent->_next : lpt->_next;\n-        CountedLoopNode *cl_next = lpt_next->_head->as_CountedLoop();\n-        \/\/ Main loop SLP works well for manually unrolled loops. But post loop\n-        \/\/ vectorization doesn't work for these. To bail out the optimization\n-        \/\/ earlier, we have range check and loop stride conditions below.\n-        if (cl_next->is_post_loop() && !lpt_next->range_checks_present() &&\n-            cl_next->stride_is_con() && abs(cl_next->stride_con()) == 1) {\n-          if (!cl_next->is_vectorized_loop()) {\n-            \/\/ Propagate some main loop attributes to its corresponding scalar\n-            \/\/ rce'd post loop for vectorization with vector masks\n-            cl_next->set_slp_max_unroll(cl->slp_max_unroll());\n-            cl_next->set_slp_pack_count(cl->slp_pack_count());\n-          }\n-        }\n-      }\n-    }\n@@ -209,3 +185,0 @@\n-  int rpo_idx = _post_block.length();\n-\n-  assert(rpo_idx == 0, \"post loop block is empty\");\n@@ -316,21 +289,0 @@\n-    \/\/ In the main loop, SLP works well if parts of the operations in the loop body\n-    \/\/ are not vectorizable and those non-vectorizable parts will be unrolled only.\n-    \/\/ But in post loops with vector masks, we create singleton packs directly from\n-    \/\/ scalars so all operations should be vectorized together. This compares the\n-    \/\/ number of packs in the post loop with the main loop and bail out if the post\n-    \/\/ loop potentially has more packs.\n-    if (cl->is_rce_post_loop()) {\n-      for (uint i = 0; i < lpt()->_body.size(); i++) {\n-        if (ignored_loop_nodes[i] == -1) {\n-          _post_block.at_put_grow(rpo_idx++, lpt()->_body.at(i));\n-        }\n-      }\n-      if (_post_block.length() > cl->slp_pack_count()) {\n-        \/\/ Clear local_loop_unroll_factor and bail out directly from here\n-        local_loop_unroll_factor = 0;\n-        cl->mark_was_slp();\n-        cl->set_slp_max_unroll(0);\n-        return;\n-      }\n-    }\n-\n@@ -407,1 +359,1 @@\n-    if (cl->is_main_loop() || cl->is_rce_post_loop()) {\n+    if (cl->is_main_loop()) {\n@@ -593,0 +545,4 @@\n+\n+  CountedLoopNode* cl = lpt()->_head->as_CountedLoop();\n+  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n+\n@@ -598,1 +554,1 @@\n-  \/\/ build    _dg, _disjoint_ptrs\n+  \/\/ build _dg, _disjoint_ptrs\n@@ -604,5 +560,2 @@\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  if (cl->is_main_loop()) {\n-    compute_vector_element_type();\n-\n-    \/\/ Attempt vectorization\n+  \/\/ Compute vector element types\n+  compute_vector_element_type();\n@@ -610,5 +563,2 @@\n-    find_adjacent_refs();\n-\n-    if (align_to_ref() == nullptr) {\n-      return false; \/\/ Did not find memory reference to align vectors\n-    }\n+  \/\/ Attempt vectorization\n+  find_adjacent_refs();\n@@ -616,3 +566,3 @@\n-    extend_packlist();\n-\n-    combine_packs();\n+  if (align_to_ref() == nullptr) {\n+    return false; \/\/ Did not find memory reference to align vectors\n+  }\n@@ -620,1 +570,1 @@\n-    construct_my_pack_map();\n+  extend_packlist();\n@@ -622,1 +572,1 @@\n-    filter_packs();\n+  combine_packs();\n@@ -624,1 +574,1 @@\n-    DEBUG_ONLY(verify_packs();)\n+  construct_my_pack_map();\n@@ -626,1 +576,1 @@\n-    schedule();\n+  filter_packs();\n@@ -628,27 +578,1 @@\n-    \/\/ Record eventual count of vector packs for checks in post loop vectorization\n-    if (PostLoopMultiversioning) {\n-      cl->set_slp_pack_count(_packset.length());\n-    }\n-  } else {\n-    assert(cl->is_rce_post_loop(), \"Must be an rce'd post loop\");\n-    int saved_mapped_unroll_factor = cl->slp_max_unroll();\n-    if (saved_mapped_unroll_factor) {\n-      int vector_mapped_unroll_factor = saved_mapped_unroll_factor;\n-\n-      \/\/ now reset the slp_unroll_factor so that we can check the analysis mapped\n-      \/\/ what the vector loop was mapped to\n-      cl->set_slp_max_unroll(0);\n-\n-      \/\/ do the analysis on the post loop\n-      unrolling_analysis(vector_mapped_unroll_factor);\n-\n-      \/\/ if our analyzed loop is a canonical fit, start processing it\n-      if (vector_mapped_unroll_factor == saved_mapped_unroll_factor) {\n-        \/\/ now add the vector nodes to packsets\n-        for (int i = 0; i < _post_block.length(); i++) {\n-          Node* n = _post_block.at(i);\n-          Node_List* singleton = new Node_List();\n-          singleton->push(n);\n-          _packset.append(singleton);\n-          set_my_pack(n, singleton);\n-        }\n+  DEBUG_ONLY(verify_packs();)\n@@ -656,10 +580,1 @@\n-        \/\/ map base types for vector usage\n-        compute_vector_element_type();\n-      } else {\n-        return false;\n-      }\n-    } else {\n-      \/\/ for some reason we could not map the slp analysis state of the vectorized loop\n-      return false;\n-    }\n-  }\n+  schedule();\n@@ -1146,0 +1061,2 @@\n+  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n+\n@@ -1160,3 +1077,1 @@\n-    if (cl->is_main_loop()) {\n-      mem_slice_preds(n_tail, n, _nlist);\n-    }\n+    mem_slice_preds(n_tail, n, _nlist);\n@@ -2594,0 +2509,1 @@\n+  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n@@ -2606,5 +2522,3 @@\n-  if (cl->is_main_loop()) {\n-    \/\/ MUST ENSURE main loop's initial value is properly aligned:\n-    \/\/  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0\n-\n-    align_initial_loop_index(align_to_ref());\n+  \/\/ Ensure main loop's initial value is properly aligned\n+  \/\/  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0\n+  align_initial_loop_index(align_to_ref());\n@@ -2612,4 +2526,3 @@\n-    \/\/ Insert extract (unpack) operations for scalar uses\n-    for (int i = 0; i < _packset.length(); i++) {\n-      insert_extracts(_packset.at(i));\n-    }\n+  \/\/ Insert extract (unpack) operations for scalar uses\n+  for (int i = 0; i < _packset.length(); i++) {\n+    insert_extracts(_packset.at(i));\n@@ -2632,10 +2545,0 @@\n-  Node* vmask = nullptr;\n-  if (cl->is_rce_post_loop() && do_reserve_copy()) {\n-    \/\/ Create a vector mask node for post loop, bail out if not created\n-    vmask = create_post_loop_vmask();\n-    if (vmask == nullptr) {\n-      \/\/ create_post_loop_vmask checks many conditions, any of them could fail\n-      return false; \/\/ and reverse to backup IG\n-    }\n-  }\n-\n@@ -2653,4 +2556,0 @@\n-      if (cl->is_rce_post_loop()) {\n-        \/\/ override vlen with the main loops vector length\n-        vlen = cl->slp_max_unroll();\n-      }\n@@ -2678,7 +2577,1 @@\n-        if (cl->is_rce_post_loop()) {\n-          assert(vmask != nullptr, \"vector mask should be generated\");\n-          const TypeVect* vt = TypeVect::make(velt_basic_type(n), vlen);\n-          vn = new LoadVectorMaskedNode(ctl, mem, adr, atyp, vt, vmask);\n-        } else {\n-          vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));\n-        }\n+        vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));\n@@ -2702,7 +2595,1 @@\n-        if (cl->is_rce_post_loop()) {\n-          assert(vmask != nullptr, \"vector mask should be generated\");\n-          const TypeVect* vt = TypeVect::make(velt_basic_type(n), vlen);\n-          vn = new StoreVectorMaskedNode(ctl, mem, adr, val, atyp, vmask);\n-        } else {\n-          vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);\n-        }\n+        vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);\n@@ -2964,1 +2851,0 @@\n-\n@@ -2967,11 +2853,4 @@\n-        if (cl->is_main_loop()) {\n-          \/\/ if vector resources are limited, do not allow additional unrolling, also\n-          \/\/ do not unroll more on pure vector loops which were not reduced so that we can\n-          \/\/ program the post loop to single iteration execution.\n-          if (Matcher::float_pressure_limit() > 8) {\n-            C->set_major_progress();\n-            cl->mark_do_unroll_only();\n-          }\n-        }\n-        if (cl->is_rce_post_loop() && do_reserve_copy()) {\n-          cl->mark_is_multiversioned();\n+        \/\/ if vector resources are limited, do not allow additional unrolling\n+        if (Matcher::float_pressure_limit() > 8) {\n+          C->set_major_progress();\n+          cl->mark_do_unroll_only();\n@@ -2991,101 +2870,0 @@\n-\/\/-------------------------create_post_loop_vmask-------------------------\n-\/\/ Check the post loop vectorizability and create a vector mask if yes.\n-\/\/ Return null to bail out if post loop is not vectorizable.\n-Node* SuperWord::create_post_loop_vmask() {\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_rce_post_loop(), \"Must be an rce post loop\");\n-  assert(!is_marked_reduction_loop(), \"no vector reduction in post loop\");\n-  assert(abs(cl->stride_con()) == 1, \"post loop stride can only be +\/-1\");\n-\n-  \/\/ Collect vector element types of all post loop packs. Also collect\n-  \/\/ superword pointers of each memory access operation if the address\n-  \/\/ expression is supported. (Note that vectorizable post loop should\n-  \/\/ only have positive scale in counting-up loop and negative scale in\n-  \/\/ counting-down loop.) Collected SWPointer(s) are also used for data\n-  \/\/ dependence check next.\n-  VectorElementSizeStats stats(_arena);\n-  GrowableArray<SWPointer*> swptrs(_arena, _packset.length(), 0, nullptr);\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    assert(p->size() == 1, \"all post loop packs should be singleton\");\n-    Node* n = p->at(0);\n-    BasicType bt = velt_basic_type(n);\n-    if (!is_java_primitive(bt)) {\n-      return nullptr;\n-    }\n-    if (n->is_Mem()) {\n-      SWPointer* mem_p = new (_arena) SWPointer(n->as_Mem(), this, nullptr, false);\n-      \/\/ For each memory access, we check if the scale (in bytes) in its\n-      \/\/ address expression is equal to the data size times loop stride.\n-      \/\/ With this, Only positive scales exist in counting-up loops and\n-      \/\/ negative scales exist in counting-down loops.\n-      if (mem_p->scale_in_bytes() != type2aelembytes(bt) * cl->stride_con()) {\n-        return nullptr;\n-      }\n-      swptrs.append(mem_p);\n-    }\n-    stats.record_size(type2aelembytes(bt));\n-  }\n-\n-  \/\/ Find the vector data type for generating vector masks. Currently we\n-  \/\/ don't support post loops with mixed vector data sizes\n-  int unique_size = stats.unique_size();\n-  BasicType vmask_bt;\n-  switch (unique_size) {\n-    case 1:  vmask_bt = T_BYTE; break;\n-    case 2:  vmask_bt = T_SHORT; break;\n-    case 4:  vmask_bt = T_INT; break;\n-    case 8:  vmask_bt = T_LONG; break;\n-    default: return nullptr;\n-  }\n-\n-  \/\/ Currently we can't remove this MaxVectorSize constraint. Without it,\n-  \/\/ it's not guaranteed that the RCE'd post loop runs at most \"vlen - 1\"\n-  \/\/ iterations, because the vector drain loop may not be cloned from the\n-  \/\/ vectorized main loop. We should re-engineer PostLoopMultiversioning\n-  \/\/ to fix this problem.\n-  int vlen = cl->slp_max_unroll();\n-  if (unique_size * vlen != MaxVectorSize) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Bail out if target doesn't support mask generator or masked load\/store\n-  if (!Matcher::match_rule_supported_vector(Op_LoadVectorMasked, vlen, vmask_bt)  ||\n-      !Matcher::match_rule_supported_vector(Op_StoreVectorMasked, vlen, vmask_bt) ||\n-      !Matcher::match_rule_supported_vector(Op_VectorMaskGen, vlen, vmask_bt)) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Bail out if potential data dependence exists between memory accesses\n-  if (SWPointer::has_potential_dependence(swptrs)) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Create vector mask with the post loop trip count. Note there's another\n-  \/\/ vector drain loop which is cloned from main loop before super-unrolling\n-  \/\/ so the scalar post loop runs at most vlen-1 trips. Hence, this version\n-  \/\/ only runs at most 1 iteration after vector mask transformation.\n-  Node* trip_cnt;\n-  Node* new_incr;\n-  if (cl->stride_con() > 0) {\n-    trip_cnt = new SubINode(cl->limit(), cl->init_trip());\n-    new_incr = new AddINode(cl->phi(), trip_cnt);\n-  } else {\n-    trip_cnt = new SubINode(cl->init_trip(), cl->limit());\n-    new_incr = new SubINode(cl->phi(), trip_cnt);\n-  }\n-  _igvn.register_new_node_with_optimizer(trip_cnt);\n-  _igvn.register_new_node_with_optimizer(new_incr);\n-  _igvn.replace_node(cl->incr(), new_incr);\n-  Node* length = new ConvI2LNode(trip_cnt);\n-  _igvn.register_new_node_with_optimizer(length);\n-  Node* vmask = VectorMaskGenNode::make(length, vmask_bt);\n-  _igvn.register_new_node_with_optimizer(vmask);\n-\n-  \/\/ Remove exit test to transform 1-iteration loop to straight-line code.\n-  \/\/ This results in redundant cmp+branch instructions been eliminated.\n-  Node *cl_exit = cl->loopexit();\n-  _igvn.replace_input_of(cl_exit, 1, _igvn.intcon(0));\n-  return vmask;\n-}\n-\n@@ -3101,6 +2879,0 @@\n-  if (cl->is_rce_post_loop()) {\n-    \/\/ override vlen with the main loops vector length\n-    assert(p->size() == 1, \"Packs in post loop should have only one node\");\n-    vlen = cl->slp_max_unroll();\n-  }\n-\n@@ -3110,4 +2882,2 @@\n-  \/\/ all inputs are the same iv, so we do a same inputs check here. But\n-  \/\/ in post loops, \"have_same_inputs\" is always true because all packs\n-  \/\/ are singleton. That's why a pack size check is also required.\n-  if (opd == iv() && (!have_same_inputs || p->size() == 1)) {\n+  \/\/ all inputs are the same iv, so we do a same inputs check here.\n+  if (opd == iv() && !have_same_inputs) {\n@@ -4029,1 +3799,0 @@\n-  _post_block.clear();\n@@ -4450,28 +4219,0 @@\n-\/\/-----------------has_potential_dependence-----------------\n-\/\/ Check potential data dependence among all memory accesses.\n-\/\/ We require every two accesses (with at least one store) of\n-\/\/ the same element type has the same address expression.\n-bool SWPointer::has_potential_dependence(GrowableArray<SWPointer*> swptrs) {\n-  for (int i1 = 0; i1 < swptrs.length(); i1++) {\n-    SWPointer* p1 = swptrs.at(i1);\n-    MemNode* n1 = p1->mem();\n-    BasicType bt1 = n1->memory_type();\n-\n-    \/\/ Iterate over remaining SWPointers\n-    for (int i2 = i1 + 1; i2 < swptrs.length(); i2++) {\n-      SWPointer* p2 = swptrs.at(i2);\n-      MemNode* n2 = p2->mem();\n-      BasicType bt2 = n2->memory_type();\n-\n-      \/\/ Data dependence exists between load-store, store-load\n-      \/\/ or store-store with the same element type or subword\n-      \/\/ size (subword load\/store may have inaccurate type)\n-      if ((n1->is_Store() || n2->is_Store()) &&\n-          same_type_or_subword_size(bt1, bt2) && !p1->equal(*p2)) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":37,"deletions":296,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -288,1 +288,0 @@\n-  GrowableArray<Node*> _post_block;      \/\/ Nodes in post loop block\n@@ -582,2 +581,0 @@\n-  \/\/ Create vector mask for post loop vectorization\n-  Node* create_post_loop_vmask();\n@@ -728,2 +725,0 @@\n-  static bool has_potential_dependence(GrowableArray<SWPointer*> swptrs);\n-\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -279,5 +279,1 @@\n-    Node* sobj = new SafePointScalarObjectNode(vec_box->box_type(),\n-#ifdef ASSERT\n-                                               vec_box,\n-#endif \/\/ ASSERT\n-                                               first_ind, n_fields);\n+    Node* sobj = new SafePointScalarObjectNode(vec_box->box_type(), vec_box, first_ind, n_fields);\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -802,6 +802,8 @@\n-  if (ext_suspended && ((state & JVMTI_THREAD_STATE_ALIVE) != 0)) {\n-    state &= ~java_lang_VirtualThread::RUNNING;\n-    state |= JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE | JVMTI_THREAD_STATE_SUSPENDED;\n-  }\n-  if (interrupted) {\n-    state |= JVMTI_THREAD_STATE_INTERRUPTED;\n+  \/\/ Ensure the thread has not exited after retrieving suspended\/interrupted values.\n+  if ((state & JVMTI_THREAD_STATE_ALIVE) != 0) {\n+    if (ext_suspended) {\n+      state |= JVMTI_THREAD_STATE_SUSPENDED;\n+    }\n+    if (interrupted) {\n+      state |= JVMTI_THREAD_STATE_INTERRUPTED;\n+    }\n@@ -1605,1 +1607,0 @@\n-  static bool _whitebox_used;\n@@ -1608,4 +1609,0 @@\n-  \/\/ This function is needed only for testing purposes to support multiple\n-  \/\/ enable&disable notifyJvmti events. Otherwise, there can be only one call\n-  \/\/ to enable_virtual_threads_notify_jvmti() for late binding agents. There\n-  \/\/ have to be no JvmtiThreadState's and need to correct them in such a case.\n@@ -1621,2 +1618,1 @@\n-    \/\/ It was not maintained while notifyJvmti was disabled but there can be\n-    \/\/ a leftover from previous cycle when notification were enabled.\n+    \/\/ It was not maintained while notifyJvmti was disabled.\n@@ -1643,3 +1639,1 @@\n-      if (_whitebox_used) {\n-        correct_jvmti_thread_state(jt); \/\/ needed in testing environment only\n-      }\n+      correct_jvmti_thread_state(jt);\n@@ -1654,3 +1648,0 @@\n-    if (!enable) {\n-      _whitebox_used = true; \/\/ disabling is available via WhiteBox only\n-    }\n@@ -1667,2 +1658,0 @@\n-bool VM_SetNotifyJvmtiEventsMode::_whitebox_used = false;\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -372,0 +372,7 @@\n+WB_ENTRY(jboolean, WB_HasLibgraal(JNIEnv* env, jobject o))\n+#if INCLUDE_JVMCI\n+  return JVMCI::shared_library_exists();\n+#endif\n+  return false;\n+WB_END\n+\n@@ -2902,0 +2909,1 @@\n+  {CC\"hasLibgraal\",                       CC\"()Z\",    (void*)&WB_HasLibgraal },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -2730,1 +2731,1 @@\n-      \/\/ For compatibility with classic. HotSpot refuses to load the old style agent.dll.\n+      warning(\"Option -Xnoagent was deprecated in JDK 22 and will likely be removed in a future release.\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-  GrowableArray<ScopeValue*>* objects = chunk->at(0)->scope()->objects();\n+  GrowableArray<ScopeValue*>* objects = chunk->at(0)->scope()->objects_to_rematerialize(deoptee, map);\n@@ -1661,0 +1661,1 @@\n+    assert(objects->at(i)->is_object(), \"invalid debug information\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -1714,3 +1715,9 @@\n-    frame f = os::current_frame();\n-    VMError::print_native_stack(tty, f, this, true \/*print_source_info *\/,\n-                                -1 \/* max stack *\/, buf, O_BUFLEN);\n+    address lastpc = nullptr;\n+    if (os::platform_print_native_stack(tty, nullptr, buf, O_BUFLEN, lastpc)) {\n+      \/\/ We have printed the native stack in platform-specific code,\n+      \/\/ so nothing else to do in this case.\n+    } else {\n+      frame f = os::current_frame();\n+      VMError::print_native_stack(tty, f, this, true \/*print_source_info *\/,\n+                                  -1 \/* max stack *\/, buf, O_BUFLEN);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-  JFR_ONLY(JfrConditionalFlushWithStacktrace<EventJavaMonitorEnter> flush(current);)\n+  JFR_ONLY(JfrConditionalFlush<EventJavaMonitorEnter> flush(current);)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,0 +188,2 @@\n+JFR_ONLY(RuntimeStub* StubRoutines::_jfr_return_lease_stub = nullptr;)\n+JFR_ONLY(address StubRoutines::_jfr_return_lease = nullptr;)\n@@ -282,37 +284,0 @@\n-#ifdef ASSERT\n-typedef void (*arraycopy_fn)(address src, address dst, int count);\n-\n-\/\/ simple tests of generated arraycopy functions\n-static void test_arraycopy_func(address func, int alignment) {\n-  int v = 0xcc;\n-  int v2 = 0x11;\n-  jlong lbuffer[8];\n-  jlong lbuffer2[8];\n-  address fbuffer  = (address) lbuffer;\n-  address fbuffer2 = (address) lbuffer2;\n-  unsigned int i;\n-  for (i = 0; i < sizeof(lbuffer); i++) {\n-    fbuffer[i] = v; fbuffer2[i] = v2;\n-  }\n-  \/\/ C++ does not guarantee jlong[] array alignment to 8 bytes.\n-  \/\/ Use middle of array to check that memory before it is not modified.\n-  address buffer  = align_up((address)&lbuffer[4], BytesPerLong);\n-  address buffer2 = align_up((address)&lbuffer2[4], BytesPerLong);\n-  \/\/ do an aligned copy\n-  ((arraycopy_fn)func)(buffer, buffer2, 0);\n-  for (i = 0; i < sizeof(lbuffer); i++) {\n-    assert(fbuffer[i] == v && fbuffer2[i] == v2, \"shouldn't have copied anything\");\n-  }\n-  \/\/ adjust destination alignment\n-  ((arraycopy_fn)func)(buffer, buffer2 + alignment, 0);\n-  for (i = 0; i < sizeof(lbuffer); i++) {\n-    assert(fbuffer[i] == v && fbuffer2[i] == v2, \"shouldn't have copied anything\");\n-  }\n-  \/\/ adjust source alignment\n-  ((arraycopy_fn)func)(buffer + alignment, buffer2, 0);\n-  for (i = 0; i < sizeof(lbuffer); i++) {\n-    assert(fbuffer[i] == v && fbuffer2[i] == v2, \"shouldn't have copied anything\");\n-  }\n-}\n-#endif \/\/ ASSERT\n-\n@@ -327,81 +292,0 @@\n-\n-#ifdef ASSERT\n-\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n-\n-#define TEST_ARRAYCOPY(type)                                                    \\\n-  test_arraycopy_func(          type##_arraycopy(),          sizeof(type));     \\\n-  test_arraycopy_func(          type##_disjoint_arraycopy(), sizeof(type));     \\\n-  test_arraycopy_func(arrayof_##type##_arraycopy(),          sizeof(HeapWord)); \\\n-  test_arraycopy_func(arrayof_##type##_disjoint_arraycopy(), sizeof(HeapWord))\n-\n-  \/\/ Make sure all the arraycopy stubs properly handle zero count\n-  TEST_ARRAYCOPY(jbyte);\n-  TEST_ARRAYCOPY(jshort);\n-  TEST_ARRAYCOPY(jint);\n-  TEST_ARRAYCOPY(jlong);\n-\n-#undef TEST_ARRAYCOPY\n-\n-#define TEST_FILL(type)                                                                      \\\n-  if (_##type##_fill != nullptr) {                                                              \\\n-    union {                                                                                  \\\n-      double d;                                                                              \\\n-      type body[96];                                                                         \\\n-    } s;                                                                                     \\\n-                                                                                             \\\n-    int v = 32;                                                                              \\\n-    for (int offset = -2; offset <= 2; offset++) {                                           \\\n-      for (int i = 0; i < 96; i++) {                                                         \\\n-        s.body[i] = 1;                                                                       \\\n-      }                                                                                      \\\n-      type* start = s.body + 8 + offset;                                                     \\\n-      for (int aligned = 0; aligned < 2; aligned++) {                                        \\\n-        if (aligned) {                                                                       \\\n-          if (((intptr_t)start) % HeapWordSize == 0) {                                       \\\n-            ((void (*)(type*, int, int))StubRoutines::_arrayof_##type##_fill)(start, v, 80); \\\n-          } else {                                                                           \\\n-            continue;                                                                        \\\n-          }                                                                                  \\\n-        } else {                                                                             \\\n-          ((void (*)(type*, int, int))StubRoutines::_##type##_fill)(start, v, 80);           \\\n-        }                                                                                    \\\n-        for (int i = 0; i < 96; i++) {                                                       \\\n-          if (i < (8 + offset) || i >= (88 + offset)) {                                      \\\n-            assert(s.body[i] == 1, \"what?\");                                                 \\\n-          } else {                                                                           \\\n-            assert(s.body[i] == 32, \"what?\");                                                \\\n-          }                                                                                  \\\n-        }                                                                                    \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-  }                                                                                          \\\n-\n-  TEST_FILL(jbyte);\n-  TEST_FILL(jshort);\n-  TEST_FILL(jint);\n-\n-#undef TEST_FILL\n-\n-#define TEST_COPYRTN(type) \\\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::conjoint_##type##s_atomic),  sizeof(type)); \\\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::arrayof_conjoint_##type##s), (int)MAX2(sizeof(HeapWord), sizeof(type)))\n-\n-  \/\/ Make sure all the copy runtime routines properly handle zero count\n-  TEST_COPYRTN(jbyte);\n-  TEST_COPYRTN(jshort);\n-  TEST_COPYRTN(jint);\n-  TEST_COPYRTN(jlong);\n-\n-#undef TEST_COPYRTN\n-\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::conjoint_words), sizeof(HeapWord));\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::disjoint_words), sizeof(HeapWord));\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::disjoint_words_atomic), sizeof(HeapWord));\n-  \/\/ Aligned to BytesPerLong\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_conjoint_words), sizeof(jlong));\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_disjoint_words), sizeof(jlong));\n-\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n-\n-#endif\n@@ -410,1 +294,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":119,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -263,0 +263,2 @@\n+  JFR_ONLY(static RuntimeStub* _jfr_return_lease_stub;)\n+  JFR_ONLY(static address _jfr_return_lease;)\n@@ -463,0 +465,1 @@\n+  JFR_ONLY(static address jfr_return_lease() { return _jfr_return_lease; })\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -330,0 +330,4 @@\n+  nonstatic_field(Annotations,                 _class_annotations,                            Array<u1>*)                            \\\n+  nonstatic_field(Annotations,                 _fields_annotations,                           Array<Array<u1>*>*)                    \\\n+  nonstatic_field(Annotations,                 _class_type_annotations,                       Array<u1>*)                            \\\n+  nonstatic_field(Annotations,                 _fields_type_annotations,                      Array<Array<u1>*>*)                    \\\n@@ -384,2 +388,2 @@\n-     static_field(CompressedKlassPointers,     _narrow_klass._base,                           address)                               \\\n-     static_field(CompressedKlassPointers,     _narrow_klass._shift,                          int)                                   \\\n+     static_field(CompressedKlassPointers,     _base,                                         address)                               \\\n+     static_field(CompressedKlassPointers,     _shift,                                        int)                                   \\\n@@ -970,0 +974,1 @@\n+  unchecked_nonstatic_field(Array<Array<u1>*>,        _data,                                  sizeof(Array<u1>*))                    \\\n@@ -1178,0 +1183,1 @@\n+    declare_type(Annotations, MetaspaceObj)                               \\\n@@ -1902,0 +1908,1 @@\n+            declare_type(Array<Array<u1>*>, MetaspaceObj)                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-enum VMErrorType {\n+enum VMErrorType : unsigned int {\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,0 +412,3 @@\n+#define EXACTFMT            SIZE_FORMAT \"%s\"\n+#define EXACTFMTARGS(s)     byte_size_in_exact_unit(s), exact_unit_for_byte_size(s)\n+\n@@ -587,5 +590,0 @@\n-const int LogKlassAlignmentInBytes = 3;\n-const int LogKlassAlignment        = LogKlassAlignmentInBytes - LogHeapWordSize;\n-const int KlassAlignmentInBytes    = 1 << LogKlassAlignmentInBytes;\n-const int KlassAlignment           = KlassAlignmentInBytes \/ HeapWordSize;\n-\n@@ -599,5 +597,0 @@\n-\/\/ Maximal size of compressed class space. Above this limit compression is not possible.\n-\/\/ Also upper bound for placement of zero based class space. (Class space is further limited\n-\/\/ to be < 3G, see arguments.cpp.)\n-const  uint64_t KlassEncodingMetaspaceMax = (uint64_t(max_juint) + 1) << LogKlassAlignmentInBytes;\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+const intptr_t    VMError::segfault_address = pd_segfault_address;\n@@ -477,0 +478,2 @@\n+  } else {\n+    st->print_cr(\"Native frames: <unavailable>\");\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-  static constexpr intptr_t segfault_address = AIX_ONLY(-1) NOT_AIX(1 * K);\n+  static const intptr_t segfault_address;\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.ref.Reference;\n@@ -208,1 +209,6 @@\n-        return key.clone();\n+        try {\n+            return key.clone();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -224,1 +230,6 @@\n-        return passwd.clone();\n+        try {\n+            return passwd.clone();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -240,3 +251,10 @@\n-        int retval = 0;\n-        for (int i = 1; i < this.key.length; i++) {\n-            retval += this.key[i] * i;\n+        try {\n+            int retval = 0;\n+            for (int i = 1; i < this.key.length; i++) {\n+                retval += this.key[i] * i;\n+            }\n+            return (retval ^= getAlgorithm().toLowerCase\n+                    (Locale.ENGLISH).hashCode());\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n@@ -244,1 +262,0 @@\n-        return(retval ^= getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode());\n@@ -248,2 +265,4 @@\n-        if (obj == this)\n-            return true;\n+        try {\n+            if (obj == this) {\n+                return true;\n+            }\n@@ -251,2 +270,3 @@\n-        if (!(obj instanceof SecretKey))\n-            return false;\n+            if (!(obj instanceof SecretKey)) {\n+                return false;\n+            }\n@@ -254,1 +274,1 @@\n-        SecretKey that = (SecretKey) obj;\n+            SecretKey that = (SecretKey) obj;\n@@ -256,8 +276,14 @@\n-        if (!(that.getAlgorithm().equalsIgnoreCase(getAlgorithm())))\n-            return false;\n-        if (!(that.getFormat().equalsIgnoreCase(\"RAW\")))\n-            return false;\n-        byte[] thatEncoded = that.getEncoded();\n-        boolean ret = MessageDigest.isEqual(key, thatEncoded);\n-        Arrays.fill(thatEncoded, (byte)0x00);\n-        return ret;\n+            if (!(that.getAlgorithm().equalsIgnoreCase(getAlgorithm()))) {\n+                return false;\n+            }\n+            if (!(that.getFormat().equalsIgnoreCase(\"RAW\"))) {\n+                return false;\n+            }\n+            byte[] thatEncoded = that.getEncoded();\n+            boolean ret = MessageDigest.isEqual(key, thatEncoded);\n+            Arrays.fill(thatEncoded, (byte)0x00);\n+            return ret;\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -276,2 +302,7 @@\n-        return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),\n-                getFormat(), key);\n+        try {\n+            return new KeyRep(KeyRep.Type.SECRET, getAlgorithm(),\n+                    getFormat(), key);\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":52,"deletions":21,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -33,1 +33,4 @@\n- * then use a data input stream to read the data back in.\n+ * then use a data input stream to read the data back in. A data output\n+ * stream wraps another output stream and delegates writing bytes to the\n+ * write methods of that output stream. Writing data consisting of more than\n+ * a single byte may cause several writes to the underlying output stream.\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataOutputStream.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.internal.misc.Blocker;\n@@ -208,1 +209,11 @@\n-    public native void sync() throws SyncFailedException;\n+    public void sync() throws SyncFailedException {\n+        long comp = Blocker.begin();\n+        try {\n+            sync0();\n+        } finally {\n+            Blocker.end(comp);\n+        }\n+    }\n+\n+    \/* fsync\/equivalent this file descriptor *\/\n+    private native void sync0() throws SyncFailedException;\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -271,15 +271,0 @@\n-    \/**\n-     * immutable table mapping primitive type names to corresponding\n-     * class objects\n-     *\/\n-    private static final Map<String, Class<?>> primClasses =\n-        Map.of(\"boolean\", boolean.class,\n-               \"byte\", byte.class,\n-               \"char\", char.class,\n-               \"short\", short.class,\n-               \"int\", int.class,\n-               \"long\", long.class,\n-               \"float\", float.class,\n-               \"double\", double.class,\n-               \"void\", void.class);\n-\n@@ -813,1 +798,1 @@\n-            Class<?> cl = primClasses.get(name);\n+            Class<?> cl = Class.forPrimitiveName(name);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -462,0 +462,3 @@\n+     * To obtain a {@code Class} object for a named primitive type\n+     * such as {@code int} or {@code long} use {@link\n+     * #forPrimitiveName(String)}.\n@@ -802,0 +805,35 @@\n+    \/**\n+     * {@return the {@code Class} object associated with the\n+     * {@linkplain #isPrimitive() primitive type} of the given name}\n+     * If the argument is not the name of a primitive type, {@code\n+     * null} is returned.\n+     *\n+     * @param primitiveName the name of the primitive type to find\n+     *\n+     * @throws NullPointerException if the argument is {@code null}\n+     *\n+     * @jls 4.2 Primitive Types and Values\n+     * @jls 15.8.2 Class Literals\n+     * @since 22\n+     *\/\n+    public static Class<?> forPrimitiveName(String primitiveName) {\n+        return switch(primitiveName) {\n+        \/\/ Integral types\n+        case \"int\"     -> int.class;\n+        case \"long\"    -> long.class;\n+        case \"short\"   -> short.class;\n+        case \"char\"    -> char.class;\n+        case \"byte\"    -> byte.class;\n+\n+        \/\/ Floating-point types\n+        case \"float\"   -> float.class;\n+        case \"double\"  -> double.class;\n+\n+        \/\/ Other types\n+        case \"boolean\" -> boolean.class;\n+        case \"void\"    -> void.class;\n+\n+        default        -> null;\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+    @ForceInline\n@@ -78,2 +79,2 @@\n-            ? this\n-            : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, true);\n+                ? this\n+                : new IndirectVarHandle(target, value, coordinates, handleFactory, vform, true);\n@@ -89,0 +90,1 @@\n+    @Override\n@@ -106,5 +108,0 @@\n-\n-    @Override\n-    public MethodHandle toMethodHandle(AccessMode accessMode) {\n-        return getMethodHandle(accessMode.ordinal()).bindTo(directTarget);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/IndirectVarHandle.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package java.lang.invoke;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Optional;\n+\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n+import static java.lang.invoke.MethodHandleStatics.uncaughtException;\n+\n+\/**\n+ * A lazy initializing var handle. It lazily initializes the referenced class before\n+ * any invocation of the target var handle to prevent reading uninitialized static\n+ * field values.\n+ *\/\n+final class LazyInitializingVarHandle extends VarHandle {\n+\n+    \/\/ Implementation notes:\n+    \/\/ We put a barrier on both target() (for VH form impl direct invocation)\n+    \/\/ and on getMethodHandle() (for indirect VH invocation, toMethodHandle)\n+    private final VarHandle target;\n+    private final Class<?> refc;\n+    private @Stable boolean initialized;\n+\n+    LazyInitializingVarHandle(VarHandle target, Class<?> refc) {\n+        super(target.vform, target.exact);\n+        this.target = target;\n+        this.refc = refc;\n+    }\n+\n+    @Override\n+    MethodType accessModeTypeUncached(AccessType at) {\n+        return target.accessModeType(at.ordinal());\n+    }\n+\n+    @Override\n+    @ForceInline\n+    VarHandle asDirect() {\n+        return target;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    VarHandle target() {\n+        ensureInitialized();\n+        return target;\n+    }\n+\n+    @Override\n+    public VarHandle withInvokeExactBehavior() {\n+        if (!initialized && hasInvokeExactBehavior())\n+            return this;\n+        var exactTarget = target.withInvokeExactBehavior();\n+        return initialized ? exactTarget : new LazyInitializingVarHandle(exactTarget, refc);\n+    }\n+\n+    @Override\n+    public VarHandle withInvokeBehavior() {\n+        if (!initialized && !hasInvokeExactBehavior())\n+            return this;\n+        var nonExactTarget = target.withInvokeBehavior();\n+        return initialized ? nonExactTarget : new LazyInitializingVarHandle(nonExactTarget, refc);\n+    }\n+\n+    @Override\n+    public Optional<VarHandleDesc> describeConstable() {\n+        return target.describeConstable();\n+    }\n+\n+    @Override\n+    public MethodHandle getMethodHandleUncached(int accessMode) {\n+        var mh = target.getMethodHandle(accessMode);\n+        if (this.initialized)\n+            return mh;\n+\n+        return MethodHandles.collectArguments(mh, 0, ensureInitializedMh()).bindTo(this);\n+    }\n+\n+    @ForceInline\n+    private void ensureInitialized() {\n+        if (this.initialized)\n+            return;\n+\n+        initialize();\n+    }\n+\n+    private void initialize() {\n+        UNSAFE.ensureClassInitialized(refc);\n+        this.initialized = true;\n+\n+        this.methodHandleTable = target.methodHandleTable;\n+    }\n+\n+    private static @Stable MethodHandle MH_ensureInitialized;\n+\n+    private static MethodHandle ensureInitializedMh() {\n+        var mh = MH_ensureInitialized;\n+        if (mh != null)\n+            return mh;\n+\n+        try {\n+            return MH_ensureInitialized = MethodHandles.lookup().findVirtual(\n+                    LazyInitializingVarHandle.class,\n+                    \"ensureInitialized\",\n+                    MethodType.methodType(void.class));\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LazyInitializingVarHandle.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -2854,0 +2854,5 @@\n+         * For a class or an interface, the name is the {@linkplain ClassLoader##binary-name binary name}.\n+         * For an array class of {@code n} dimensions, the name begins with {@code n} occurrences\n+         * of {@code '['} and followed by the element type as encoded in the\n+         * {@linkplain Class##nameFormat table} specified in {@link Class#getName}.\n+         * <p>\n@@ -2857,1 +2862,2 @@\n-         * @param targetName the fully qualified name of the class to be looked up.\n+         * @param targetName the {@linkplain ClassLoader##binary-name binary name} of the class\n+         *                   or the string representing an array class\n@@ -4233,1 +4239,1 @@\n-            return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),\n+            return VarHandles.makeFieldHandle(getField, refc,\n@@ -8228,13 +8234,12 @@\n-     * If {@code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of\n-     * type {@code R} as its coordinate in position {@code pos}, preceded and\/or followed by\n-     * any coordinate not passed to the filter.\n-     * No coordinates are reordered, and the result returned from the filter\n-     * replaces (in order) the whole subsequence of coordinates originally\n-     * passed to the adapter.\n-     * <p>\n-     * The argument types (if any) of the filter\n-     * replace zero or one coordinate types of the target var handle, at position {@code pos},\n-     * in the resulting adapted var handle.\n-     * The return type of the filter must be identical to the\n-     * coordinate type of the target var handle at position {@code pos}, and that target var handle\n-     * coordinate is supplied by the return value of the filter.\n+     * If {@code R} is the return type of the filter, then:\n+     * <ul>\n+     * <li>if {@code R} <em>is not<\/em> {@code void}, the target var handle must have a coordinate of type {@code R} in\n+     * position {@code pos}. The parameter types of the filter will replace the coordinate type at position {@code pos}\n+     * of the target var handle. When the returned var handle is invoked, it will be as if the filter is invoked first,\n+     * and its result is passed in place of the coordinate at position {@code pos} in a downstream invocation of the\n+     * target var handle.<\/li>\n+     * <li> if {@code R} <em>is<\/em> {@code void}, the parameter types (if any) of the filter will be inserted in the\n+     * coordinate type list of the target var handle at position {@code pos}. In this case, when the returned var handle\n+     * is invoked, the filter essentially acts as a side effect, consuming some of the coordinate values, before a\n+     * downstream invocation of the target var handle.<\/li>\n+     * <\/ul>\n@@ -8249,1 +8254,1 @@\n-     * @param pos the position of the coordinate to be filtered\n+     * @param pos the position in the coordinate list of the target var handle where the filter is to be inserted\n@@ -8254,1 +8259,1 @@\n-     * is void, or it is not the same as the {@code pos} coordinate of the target var handle,\n+     * is not void, and it is not the same as the {@code pos} coordinate of the target var handle,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -476,1 +476,2 @@\n-     permits IndirectVarHandle, VarHandleSegmentViewBase,\n+     permits IndirectVarHandle, LazyInitializingVarHandle,\n+             VarHandleSegmentViewBase,\n@@ -525,2 +526,7 @@\n-    RuntimeException unsupported() {\n-        return new UnsupportedOperationException();\n+    \/**\n+     * Returns the target VarHandle.   Subclasses may override this method to implement\n+     * additional logic for example lazily initializing the declaring class of a static field var handle.\n+     *\/\n+    @ForceInline\n+    VarHandle target() {\n+        return asDirect();\n@@ -529,0 +535,8 @@\n+    \/**\n+     * Returns the direct target VarHandle.   Indirect VarHandle subclasses should implement\n+     * this method.\n+     *\n+     * @see #getMethodHandle(int)\n+     * @see #checkAccessModeThenIsDirect(AccessDescriptor)\n+     *\/\n+    @ForceInline\n@@ -2075,2 +2089,2 @@\n-     * the access mode of this VarHandle, then returns if this is a direct\n-     * method handle. These operations were grouped together to slightly\n+     * the access mode of this VarHandle, then returns if this is direct.\n+     * These operations were grouped together to slightly\n@@ -2079,0 +2093,5 @@\n+     * A direct VarHandle's VarForm has implementation MemberNames that can\n+     * be linked directly. If a VarHandle is indirect, it must override\n+     * {@link #isAccessModeSupported} and {@link #getMethodHandleUncached}\n+     * which access MemberNames.\n+     *\n@@ -2082,0 +2101,1 @@\n+     * @see #asDirect()\n@@ -2157,1 +2177,1 @@\n-            return mh.bindTo(this);\n+            return mh.bindTo(asDirect());\n@@ -2199,0 +2219,8 @@\n+    \/**\n+     * Computes a method handle that can be passed the {@linkplain #asDirect() direct}\n+     * var handle of this var handle with the given access mode. Pre\/postprocessing\n+     * such as argument or return value filtering should be done by the returned\n+     * method handle.\n+     *\n+     * @throws UnsupportedOperationException if the access mode is not supported\n+     *\/\n@@ -2414,1 +2442,1 @@\n-                case FIELD        -> lookup.findVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                case FIELD        -> lookup.findVarHandle(declaringClass.resolveConstantDesc(lookup),\n@@ -2416,2 +2444,2 @@\n-                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n-                case STATIC_FIELD -> lookup.findStaticVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup),\n+                                                          varType.resolveConstantDesc(lookup));\n+                case STATIC_FIELD -> lookup.findStaticVarHandle(declaringClass.resolveConstantDesc(lookup),\n@@ -2419,2 +2447,2 @@\n-                                                          (Class<?>) varType.resolveConstantDesc(lookup));\n-                case ARRAY        -> MethodHandles.arrayElementVarHandle((Class<?>) declaringClass.resolveConstantDesc(lookup));\n+                                                          varType.resolveConstantDesc(lookup));\n+                case ARRAY        -> MethodHandles.arrayElementVarHandle(declaringClass.resolveConstantDesc(lookup));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    static VarHandle makeFieldHandle(MemberName f, Class<?> refc, Class<?> type, boolean isWriteAllowedOnFinalFields) {\n+    static VarHandle makeFieldHandle(MemberName f, Class<?> refc, boolean isWriteAllowedOnFinalFields) {\n@@ -60,0 +60,1 @@\n+            Class<?> type = f.getFieldType();\n@@ -116,9 +117,0 @@\n-            \/\/ TODO This is not lazy on first invocation\n-            \/\/ and might cause some circular initialization issues\n-\n-            \/\/ Replace with something similar to direct method handles\n-            \/\/ where a barrier is used then elided after use\n-\n-            if (UNSAFE.shouldBeInitialized(refc))\n-                UNSAFE.ensureClassInitialized(refc);\n-\n@@ -126,49 +118,13 @@\n-            Object base = MethodHandleNatives.staticFieldBase(f);\n-            long foffset = MethodHandleNatives.staticFieldOffset(f);\n-            if (!type.isPrimitive()) {\n-                if (f.isFlattened()) {\n-                    return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                            ? new VarHandleValues.FieldStaticReadOnly(decl, refc, foffset, type)\n-                            : new VarHandleValues.FieldStaticReadWrite(decl, refc, foffset, type));\n-                } else {\n-                    return f.isFinal() && !isWriteAllowedOnFinalFields\n-                            ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n-                            : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type);\n-                }\n-            }\n-            else if (type == boolean.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleBooleans.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleBooleans.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == byte.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleBytes.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleBytes.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == short.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleShorts.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleShorts.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == char.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleChars.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleChars.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == int.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleInts.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleInts.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == long.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleLongs.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleLongs.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == float.class) {\n-                return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                       ? new VarHandleFloats.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleFloats.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else if (type == double.class) {\n+            var vh = makeStaticFieldVarHandle(decl, f, isWriteAllowedOnFinalFields);\n+            return maybeAdapt(UNSAFE.shouldBeInitialized(decl)\n+                    ? new LazyInitializingVarHandle(vh, decl)\n+                    : vh);\n+        }\n+    }\n+\n+    static VarHandle makeStaticFieldVarHandle(Class<?> decl, MemberName f, boolean isWriteAllowedOnFinalFields) {\n+        Object base = MethodHandleNatives.staticFieldBase(f);\n+        long foffset = MethodHandleNatives.staticFieldOffset(f);\n+        Class<?> type = f.getFieldType();\n+        if (!type.isPrimitive()) {\n+            if (f.isFlattened()) {\n@@ -176,5 +132,6 @@\n-                       ? new VarHandleDoubles.FieldStaticReadOnly(decl, base, foffset)\n-                       : new VarHandleDoubles.FieldStaticReadWrite(decl, base, foffset));\n-            }\n-            else {\n-                throw new UnsupportedOperationException();\n+                        ? new VarHandleValues.FieldStaticReadOnly(decl, base, foffset, type)\n+                        : new VarHandleValues.FieldStaticReadWrite(decl, base, foffset, type));\n+            } else {\n+                return f.isFinal() && !isWriteAllowedOnFinalFields\n+                        ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type)\n+                        : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type);\n@@ -183,0 +140,43 @@\n+        else if (type == boolean.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleBooleans.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleBooleans.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == byte.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleBytes.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleBytes.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == short.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleShorts.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleShorts.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == char.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleChars.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleChars.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == int.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleInts.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleInts.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == long.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleLongs.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleLongs.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == float.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleFloats.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleFloats.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else if (type == double.class) {\n+            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                    ? new VarHandleDoubles.FieldStaticReadOnly(decl, base, foffset)\n+                    : new VarHandleDoubles.FieldStaticReadWrite(decl, base, foffset));\n+        }\n+        else {\n+            throw new UnsupportedOperationException();\n+        }\n@@ -584,3 +584,1 @@\n-        } else if (filter.type().returnType() == void.class) {\n-            throw newIllegalArgumentException(\"Invalid filter type \" + filter.type() + \" ; filter cannot be void\");\n-        } else if (filter.type().returnType() != targetCoordinates.get(pos)) {\n+        } else if (filter.type().returnType() != void.class && filter.type().returnType() != targetCoordinates.get(pos)) {\n@@ -591,1 +589,3 @@\n-        newCoordinates.remove(pos);\n+        if (filter.type().returnType() != void.class) {\n+            newCoordinates.remove(pos);\n+        }\n@@ -752,10 +752,1 @@\n-\/\/        static class HandleType {\n-\/\/            final Class<?> receiver;\n-\/\/            final Class<?>[] intermediates;\n-\/\/            final Class<?> value;\n-\/\/\n-\/\/            HandleType(Class<?> receiver, Class<?> value, Class<?>... intermediates) {\n-\/\/                this.receiver = receiver;\n-\/\/                this.intermediates = intermediates;\n-\/\/                this.value = value;\n-\/\/            }\n+\/\/        record HandleType(Class<?> receiver, Class<?> value, Class<?>... intermediates) {\n@@ -837,4 +828,2 @@\n-\/\/            for (int i = 0; i < intermediates.length; i++) {\n-\/\/                params.add(intermediates[i]);\n-\/\/            }\n-\/\/            for (Parameter p : m.getParameters()) {\n+\/\/            java.util.Collections.addAll(params, intermediates);\n+\/\/            for (var p : m.getParameters()) {\n@@ -849,1 +838,1 @@\n-\/\/            LinkedHashMap<String, Class<?>> params = new LinkedHashMap<>();\n+\/\/            var params = new java.util.LinkedHashMap<String, Class<?>>();\n@@ -862,1 +851,1 @@\n-\/\/                    collect(joining(\", \"));\n+\/\/                    collect(java.util.stream.Collectors.joining(\", \"));\n@@ -872,2 +861,1 @@\n-\/\/            List<String> LINK_TO_STATIC_ARGS = params.keySet().stream().\n-\/\/                    collect(toList());\n+\/\/            List<String> LINK_TO_STATIC_ARGS = new ArrayList<>(params.keySet());\n@@ -876,2 +864,1 @@\n-\/\/            List<String> LINK_TO_INVOKER_ARGS = params.keySet().stream().\n-\/\/                    collect(toList());\n+\/\/            List<String> LINK_TO_INVOKER_ARGS = new ArrayList<>(params.keySet());\n@@ -905,4 +892,2 @@\n-\/\/                    replaceAll(\"<LINK_TO_STATIC_ARGS>\", LINK_TO_STATIC_ARGS.stream().\n-\/\/                            collect(joining(\", \"))).\n-\/\/                    replace(\"<LINK_TO_INVOKER_ARGS>\", LINK_TO_INVOKER_ARGS.stream().\n-\/\/                            collect(joining(\", \")))\n+\/\/                    replaceAll(\"<LINK_TO_STATIC_ARGS>\", String.join(\", \", LINK_TO_STATIC_ARGS)).\n+\/\/                    replace(\"<LINK_TO_INVOKER_ARGS>\", String.join(\", \", LINK_TO_INVOKER_ARGS))\n@@ -937,24 +922,1 @@\n-\/\/            if (pt == void.class) {\n-\/\/                return 'V';\n-\/\/            }\n-\/\/            else if (!pt.isPrimitive()) {\n-\/\/                return 'L';\n-\/\/            }\n-\/\/            else if (pt == boolean.class) {\n-\/\/                return 'Z';\n-\/\/            }\n-\/\/            else if (pt == int.class) {\n-\/\/                return 'I';\n-\/\/            }\n-\/\/            else if (pt == long.class) {\n-\/\/                return 'J';\n-\/\/            }\n-\/\/            else if (pt == float.class) {\n-\/\/                return 'F';\n-\/\/            }\n-\/\/            else if (pt == double.class) {\n-\/\/                return 'D';\n-\/\/            }\n-\/\/            else {\n-\/\/                throw new IllegalStateException(pt.getName());\n-\/\/            }\n+\/\/            return Wrapper.forBasicType(pt).basicTypeChar();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":78,"deletions":116,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-            FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;\n+            FieldStaticReadOnly handle = (FieldStaticReadOnly) ob.target();\n@@ -456,1 +456,1 @@\n-            FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;\n+            FieldStaticReadOnly handle = (FieldStaticReadOnly) ob.target();\n@@ -463,1 +463,1 @@\n-            FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;\n+            FieldStaticReadOnly handle = (FieldStaticReadOnly) ob.target();\n@@ -470,1 +470,1 @@\n-            FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;\n+            FieldStaticReadOnly handle = (FieldStaticReadOnly) ob.target();\n@@ -511,1 +511,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -519,1 +519,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -527,1 +527,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -535,1 +535,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -544,1 +544,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -554,1 +554,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -563,1 +563,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -572,1 +572,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -581,1 +581,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -590,1 +590,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -599,1 +599,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -608,1 +608,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -617,1 +617,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -625,1 +625,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -633,1 +633,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -643,1 +643,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -651,1 +651,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -659,1 +659,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -669,1 +669,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -677,1 +677,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -685,1 +685,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -693,1 +693,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -701,1 +701,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -709,1 +709,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -717,1 +717,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -725,1 +725,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n@@ -733,1 +733,1 @@\n-            FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;\n+            FieldStaticReadWrite handle = (FieldStaticReadWrite) ob.target();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+     * @implSpec\n@@ -56,4 +57,1 @@\n-     * <pre>\n-     * int[] x = {length};\n-     * Array.newInstance(componentType, x);\n-     * <\/pre>\n+     * {@code Array.newInstance(componentType, new int[]{length});}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Array.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -957,0 +957,1 @@\n+    @Override\n@@ -962,3 +963,1 @@\n-     * Computes a hashcode for this charset.\n-     *\n-     * @return  An integer hashcode\n+     * {@return the hashcode for this charset}\n@@ -966,0 +965,1 @@\n+    @Override\n@@ -979,0 +979,1 @@\n+    @Override\n@@ -980,2 +981,0 @@\n-        if (!(ob instanceof Charset))\n-            return false;\n@@ -984,1 +983,1 @@\n-        return name.equals(((Charset)ob).name());\n+        return ob instanceof Charset other && name.equals(other.name());\n@@ -988,3 +987,1 @@\n-     * Returns a string describing this charset.\n-     *\n-     * @return  A string describing this charset\n+     * {@return a string describing this charset}\n@@ -992,0 +989,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/nio\/charset\/Charset.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -987,0 +987,1 @@\n+    @Override\n@@ -998,0 +999,1 @@\n+    @Override\n@@ -1001,1 +1003,1 @@\n-     * Returns the string representation of this path.\n+     * {@return the string representation of this path}\n@@ -1009,2 +1011,0 @@\n-     *\n-     * @return  the string representation of this path\n@@ -1012,0 +1012,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,4 +360,0 @@\n-    private static int hash(int h, Object o) {\n-        return h * 127 + o.hashCode();\n-    }\n-\n@@ -373,8 +369,6 @@\n-        if (hash != 0)\n-            return hash;\n-        int h = type.hashCode();\n-        h = hash(h, who);\n-        h = hash(h, perms);\n-        h = hash(h, flags);\n-        hash = h;\n-        return hash;\n+        int h = hash;\n+        if (h == 0) {\n+            h = Objects.hash(type, who, perms, flags);\n+            hash = h;\n+        }\n+        return h;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/attribute\/AclEntry.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,1 +294,1 @@\n-        return (obj instanceof FileTime) ? compareTo((FileTime)obj) == 0 : false;\n+        return obj instanceof FileTime other && compareTo(other) == 0;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/attribute\/FileTime.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -781,0 +781,7 @@\n+        \/\/ The 'getStackAccessControlContext' call inside 'isPrivileged'\n+        \/\/ requires that no Local was scalar replaced. However, in some\n+        \/\/ situations, after inlining, 'result' (or part of a possibly\n+        \/\/ allocation merge Phi leading to it) might become NonEscaping and get\n+        \/\/ scalar replaced. The call below enforces 'result' to always escape.\n+        ensureMaterializedForStackWalk(result);\n+\n@@ -812,0 +819,7 @@\n+        \/\/ The 'getStackAccessControlContext' call inside 'isPrivileged'\n+        \/\/ requires that no Local was scalar replaced. However, in some\n+        \/\/ situations, after inlining, 'result' (or part of a possibly\n+        \/\/ allocation merge Phi leading to it) might become NonEscaping and get\n+        \/\/ scalar replaced. The call below enforces 'result' to always escape.\n+        ensureMaterializedForStackWalk(result);\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/AccessController.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -621,1 +621,1 @@\n-                        valuesMatch(value, getAttribute(attribute, currIndex - 1))) {\n+                        Objects.equals(value, getAttribute(attribute, currIndex - 1))) {\n@@ -635,1 +635,1 @@\n-                        valuesMatch(value, getAttribute(attribute, currIndex + 1))) {\n+                        Objects.equals(value, getAttribute(attribute, currIndex + 1))) {\n@@ -653,1 +653,1 @@\n-            if (!valuesMatch(getAttribute(key, runIndex1), getAttribute(key, runIndex2))) {\n+            if (!Objects.equals(getAttribute(key, runIndex1), getAttribute(key, runIndex2))) {\n@@ -660,9 +660,0 @@\n-    \/\/ returns whether the two objects are either both null or equal\n-    private static final boolean valuesMatch(Object value1, Object value2) {\n-        if (value1 == null) {\n-            return value2 == null;\n-        } else {\n-            return value1.equals(value2);\n-        }\n-    }\n-\n@@ -763,0 +754,1 @@\n+        @Override\n@@ -778,0 +770,1 @@\n+        @Override\n@@ -864,1 +857,1 @@\n-                        valuesMatch(value, AttributedString.this.getAttribute(attribute, runIndex - 1))) {\n+                        Objects.equals(value, AttributedString.this.getAttribute(attribute, runIndex - 1))) {\n@@ -905,1 +898,1 @@\n-                        valuesMatch(value, AttributedString.this.getAttribute(attribute, runIndex + 1))) {\n+                        Objects.equals(value, AttributedString.this.getAttribute(attribute, runIndex + 1))) {\n@@ -1084,0 +1077,1 @@\n+    @Override\n@@ -1085,4 +1079,2 @@\n-        if (!(o instanceof AttributeEntry other)) {\n-            return false;\n-        }\n-        return other.key.equals(key) && Objects.equals(other.value, value);\n+        return o instanceof AttributeEntry other\n+                && other.key.equals(key) && Objects.equals(other.value, value);\n@@ -1103,0 +1095,1 @@\n+    @Override\n@@ -1104,1 +1097,1 @@\n-        return key.hashCode() ^ (value==null ? 0 : value.hashCode());\n+        return key.hashCode() ^ Objects.hashCode(value);\n","filename":"src\/java.base\/share\/classes\/java\/text\/AttributedString.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -500,0 +500,1 @@\n+    @Override\n@@ -512,0 +513,1 @@\n+    @Override\n@@ -513,1 +515,0 @@\n-        if (obj == null) return false;\n@@ -516,1 +517,1 @@\n-        if (getClass() != obj.getClass())\n+        if (obj == null || getClass() != obj.getClass())\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -533,4 +533,1 @@\n-        if (that == null) {\n-            return false;\n-        }\n-        if (getClass() != that.getClass()) {\n+        if (that == null || getClass() != that.getClass()) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/Collator.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2357,1 +2357,5 @@\n-        if (!super.equals(obj)) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (!super.equals(obj)) { \/\/ super does null and class checks\n@@ -2372,3 +2376,1 @@\n-     * Returns the hash code for this {@code CompactNumberFormat} instance.\n-     *\n-     * @return hash code for this {@code CompactNumberFormat}\n+     * {@return the hash code for this {@code CompactNumberFormat} instance}\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+    @Override\n@@ -698,4 +699,1 @@\n-                && ((localPatternChars != null\n-                  && localPatternChars.equals(that.localPatternChars))\n-                 || (localPatternChars == null\n-                  && that.localPatternChars == null)));\n+                && Objects.equals(localPatternChars, that.localPatternChars));\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormatSymbols.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2921,2 +2921,4 @@\n-        if (obj == null)\n-            return false;\n+        if (this == obj) {\n+            return true;\n+        }\n+\n@@ -2924,1 +2926,2 @@\n-            return false; \/\/ super does class check\n+            return false; \/\/ super does null and class checks\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -744,1 +744,0 @@\n-        if (obj == null) return false;\n@@ -746,1 +745,1 @@\n-        if (getClass() != obj.getClass()) return false;\n+        if (obj == null || getClass() != obj.getClass()) return false;\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+import java.util.Objects;\n+\n@@ -221,0 +223,1 @@\n+    @Override\n@@ -223,1 +226,0 @@\n-        if (obj == null) return false;\n@@ -226,6 +228,1 @@\n-        if (attribute == null) {\n-            if (other.attribute != null) {\n-                return false;\n-            }\n-        }\n-        else if (!attribute.equals(other.attribute)) {\n+        if (!Objects.equals(attribute, other.attribute))\n@@ -233,1 +230,0 @@\n-        }\n@@ -240,2 +236,1 @@\n-     * Returns a hash code for this FieldPosition.\n-     * @return a hash code value for this object\n+     * {@return a hash code for this FieldPosition}\n@@ -243,0 +238,1 @@\n+    @Override\n@@ -273,1 +269,1 @@\n-     * represents an inteter constant and {@code field} equals it.\n+     * represents an integer constant and {@code field} equals it.\n","filename":"src\/java.base\/share\/classes\/java\/text\/FieldPosition.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -1135,0 +1136,1 @@\n+    @Override\n@@ -1143,2 +1145,1 @@\n-                && ((locale != null && locale.equals(other.locale))\n-                 || (locale == null && other.locale == null))\n+                && Objects.equals(locale,other.locale)\n@@ -1153,0 +1154,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -714,3 +714,0 @@\n-        if (obj == null) {\n-            return false;\n-        }\n@@ -720,1 +717,1 @@\n-        if (getClass() != obj.getClass()) {\n+        if (obj == null || getClass() != obj.getClass()) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,0 +125,1 @@\n+    @Override\n@@ -127,4 +128,2 @@\n-        if (obj == null) return false;\n-        if (!(obj instanceof ParsePosition other))\n-            return false;\n-        return (index == other.index && errorIndex == other.errorIndex);\n+        return obj instanceof ParsePosition other\n+                && index == other.index && errorIndex == other.errorIndex;\n@@ -134,2 +133,1 @@\n-     * Returns a hash code for this ParsePosition.\n-     * @return a hash code value for this object\n+     * {@return a hash code for this ParsePosition}\n@@ -137,0 +135,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/text\/ParsePosition.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -732,0 +732,1 @@\n+    @Override\n@@ -733,2 +734,1 @@\n-        if (obj == null) return false;\n-        if (!super.equals(obj)) return false;  \/\/ super does class check\n+        if (!super.equals(obj)) return false;  \/\/ super does null and class checks\n@@ -743,0 +743,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/text\/RuleBasedCollator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2412,3 +2412,1 @@\n-     * Returns the hash code value for this {@code SimpleDateFormat} object.\n-     *\n-     * @return the hash code value for this {@code SimpleDateFormat} object.\n+     * {@return the hash code value for this {@code SimpleDateFormat} object}\n@@ -2434,1 +2432,1 @@\n-            return false; \/\/ super does class check\n+            return false; \/\/ super does null and class checks\n","filename":"src\/java.base\/share\/classes\/java\/text\/SimpleDateFormat.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1512,1 +1512,4 @@\n-            \/\/ ArrayListSpliterator not used here due to late-binding\n+            \/\/ This Spliterator needs to late-bind to the subList, not the outer\n+            \/\/ ArrayList. Note that it is legal for structural changes to be made\n+            \/\/ to a subList after spliterator() is called but before any spliterator\n+            \/\/ operations that would causing binding are performed.\n@@ -1631,3 +1634,1 @@\n-         * against; thus improving precision.  (This doesn't apply to\n-         * SubLists, that create spliterators with current non-lazy\n-         * values).  (2) We perform only a single\n+         * against; thus improving precision. (2) We perform only a single\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayList.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4336,2 +4336,1 @@\n-            int elementHash = (int)(element ^ (element >>> 32));\n-            result = 31 * result + elementHash;\n+            result = 31 * result + Long.hashCode(element);\n@@ -4472,1 +4471,1 @@\n-            result = 31 * result + (element ? 1231 : 1237);\n+            result = 31 * result + Boolean.hashCode(element);\n@@ -4499,1 +4498,1 @@\n-            result = 31 * result + Float.floatToIntBits(element);\n+            result = 31 * result + Float.hashCode(element);\n@@ -4526,2 +4525,1 @@\n-            long bits = Double.doubleToLongBits(element);\n-            result = 31 * result + (int)(bits ^ (bits >>> 32));\n+            result = 31 * result + Double.hashCode(element);\n@@ -4560,1 +4558,1 @@\n-            result = 31 * result + (element == null ? 0 : element.hashCode());\n+            result = 31 * result + Objects.hashCode(element);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -620,2 +620,8 @@\n-     * The implementation in this interface returns an instance of a reverse-ordered\n-     * Deque that delegates its operations to this Deque.\n+     * The implementation in this interface returns a reverse-ordered Deque\n+     * view. The {@code reversed()} method of the view returns a reference\n+     * to this Deque. Other operations on the view are implemented via calls to\n+     * public methods on this Deque. The exact relationship between calls on the\n+     * view and calls on this Deque is unspecified. However, order-sensitive\n+     * operations generally delegate to the appropriate method with the opposite\n+     * orientation. For example, calling {@code getFirst} on the view results in\n+     * a call to {@code getLast} on this Deque.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Deque.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -891,2 +891,8 @@\n-     * The implementation in this interface returns an instance of a reverse-ordered\n-     * List that delegates its operations to this List.\n+     * The implementation in this interface returns a reverse-ordered List\n+     * view. The {@code reversed()} method of the view returns a reference\n+     * to this List. Other operations on the view are implemented via calls to\n+     * public methods on this List. The exact relationship between calls on the\n+     * view and calls on this List is unspecified. However, order-sensitive\n+     * operations generally delegate to the appropriate method with the opposite\n+     * orientation. For example, calling {@code getFirst} on the view results in\n+     * a call to {@code getLast} on this List.\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        return Spliterators.spliteratorUnknownSize(base.descendingIterator(), 0);\n+        return Spliterators.spliterator(this, Spliterator.ORDERED);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderDequeView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,2 +154,1 @@\n-        \/\/ TODO can probably improve this\n-        return Spliterators.spliteratorUnknownSize(new DescendingIterator(), 0);\n+        return Spliterators.spliterator(this, Spliterator.ORDERED);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderListView.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        return Spliterators.spliteratorUnknownSize(descendingIterator(base), 0);\n+        return Spliterators.spliterator(this, Spliterator.ORDERED);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderSortedSetView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -319,2 +319,8 @@\n-     * The implementation in this interface returns an instance of a reverse-ordered\n-     * SortedMap that delegates its operations to this SortedMap.\n+     * The implementation in this interface returns a reverse-ordered SortedMap\n+     * view. The {@code reversed()} method of the view returns a reference\n+     * to this SortedMap. Other operations on the view are implemented via calls to\n+     * public methods on this SortedMap. The exact relationship between calls on the\n+     * view and calls on this SortedMap is unspecified. However, order-sensitive\n+     * operations generally delegate to the appropriate method with the opposite\n+     * orientation. For example, calling {@code firstEntry} on the view results in\n+     * a call to {@code lastEntry} on this SortedMap.\n","filename":"src\/java.base\/share\/classes\/java\/util\/SortedMap.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -363,2 +363,8 @@\n-     * The implementation in this interface returns an instance of a reverse-ordered\n-     * SortedSet that delegates its operations to this SortedSet.\n+     * The implementation in this interface returns a reverse-ordered SortedSet\n+     * view. The {@code reversed()} method of the view returns a reference\n+     * to this SortedSet. Other operations on the view are implemented via calls to\n+     * public methods on this SortedSet. The exact relationship between calls on the\n+     * view and calls on this SortedSet is unspecified. However, order-sensitive\n+     * operations generally delegate to the appropriate method with the opposite\n+     * orientation. For example, calling {@code getFirst} on the view results in\n+     * a call to {@code getLast} on this SortedSet.\n","filename":"src\/java.base\/share\/classes\/java\/util\/SortedSet.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -951,1 +951,2 @@\n-        private long estimatedSize; \/\/ estimated size, to help to split evenly\n+        private long estimatedSize; \/\/ if >= 0, the estimated size, to help to split evenly\n+                                    \/\/ if -1, exact size is known to be fence - index\n@@ -955,0 +956,1 @@\n+         * Its size is known exactly and it is SIZED and SUBSIZED.\n@@ -965,1 +967,2 @@\n-         * Creates a spliterator covering the given array and range\n+         * Creates a spliterator covering the given array and range.\n+         * Its size is known exactly and it is SIZED and SUBSIZED.\n@@ -981,0 +984,12 @@\n+        \/**\n+         * Creates a spliterator covering the given array and range but that is\n+         * not SIZED or SUBSIZED. This case occurs as a result of splitting another\n+         * spliterator that is not sized, so it's inappropriate for one of its\n+         * sub-spliterators to be sized.\n+         * @param array the array, assumed to be unmodified during use\n+         * @param origin the least index (inclusive) to cover\n+         * @param fence one past the greatest index to cover\n+         * @param characteristics characteristics of this spliterator's source; {@code SIZED} and\n+         *        {@code SUBSIZED} are removed if present\n+         * @param estimatedSize the size estimate; should always be nonnegative\n+         *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterators.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -133,2 +133,2 @@\n- * recognize one of them.\n- *\n+ * recognize one of them. The full list of deprecated three-letter time\n+ * zone IDs and their mappings can be viewed at {@link java.time.ZoneId#SHORT_IDS}.\n","filename":"src\/java.base\/share\/classes\/java\/util\/TimeZone.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1825,2 +1825,1 @@\n-            \/\/ TODO can probably improve this\n-            return Spliterators.spliteratorUnknownSize(new DescendingIterator(), 0);\n+            return Spliterators.spliterator(this, Spliterator.ORDERED);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArrayList.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n- *     Callable<Integer> task1 = ...\n+ *     Callable<Integer> task2 = ...\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import sun.security.util.SignatureFileVerifier;\n@@ -147,2 +148,0 @@\n-    \/\/ The maximum size of array to allocate. Some VMs reserve some header words in an array.\n-    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n@@ -802,2 +801,5 @@\n-            if (uncompressedSize > MAX_ARRAY_SIZE) {\n-                throw new IOException(\"Unsupported size: \" + uncompressedSize);\n+            if (uncompressedSize > SignatureFileVerifier.MAX_SIG_FILE_SIZE) {\n+                throw new IOException(\"Unsupported size: \" + uncompressedSize +\n+                        \" for JarEntry \" + ze.getName() +\n+                        \". Allowed max size: \" +\n+                        SignatureFileVerifier.MAX_SIG_FILE_SIZE + \" bytes\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.util.random.RandomSupport.*;\n@@ -40,0 +39,2 @@\n+import static java.lang.Math.*;\n+\n@@ -255,0 +256,168 @@\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code double} values, where each value is between the specified\n+     * {@code left} boundary and the specified {@code right} boundary.\n+     * The {@code left} boundary is included as indicated by\n+     * {@code isLeftIncluded}; similarly, the {@code right} boundary is included\n+     * as indicated by {@code isRightIncluded}.\n+     *\n+     * <p>The stream potentially produces all multiples <i>k<\/i> &delta;\n+     * (<i>k<\/i> integer) lying in the interval specified by the parameters,\n+     * where &delta; > 0 is the smallest number for which all these multiples\n+     * are exact {@code double}s.\n+     * They are therefore all equidistant.\n+     * The uniformity of the distribution of the {@code double}s produced by\n+     * the stream depends on the quality of the underlying {@link #nextLong(long)}.\n+     *\n+     * @implSpec The default implementation first determines the &delta; above.\n+     * It then computes both the smallest integer <i>k<\/i><sub><i>l<\/i><\/sub>\n+     * such that <i>k<\/i><sub><i>l<\/i><\/sub> &delta; lies <em>inside<\/em>\n+     * the given interval, and the smallest integer <i>n<\/i> > 0 such that\n+     * (<i>k<\/i><sub><i>l<\/i><\/sub> + <i>n<\/i>) &delta; lies\n+     * <em>outside<\/em> the interval.\n+     * Finally, it returns a stream which generates the {@code double}s\n+     * according to (<i>k<\/i><sub><i>l<\/i><\/sub> + {@code nextLong(}<i>n<\/i>{@code )})\n+     * &delta;.\n+     * The stream never produces {@code -0.0}, although it may produce\n+     * {@code 0.0} if the specified interval contains 0.\n+     *\n+     * @param left the left boundary\n+     * @param right the right boundary\n+     * @param isLeftIncluded whether the {@code left} boundary is included\n+     * @param isRightIncluded whether the {@code right} boundary is included\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values, each\n+     *         between {@code left} and {@code right}, as specified above.\n+     *\n+     * @throws IllegalArgumentException if {@code left} is not finite,\n+     *         or {@code right} is not finite, or if the specified interval\n+     *         is empty.\n+     *\n+     * @since 21\n+     *\/\n+    default DoubleStream equiDoubles(double left, double right,\n+        boolean isLeftIncluded, boolean isRightIncluded) {\n+        if (!(Double.NEGATIVE_INFINITY < left\n+                && right < Double.POSITIVE_INFINITY\n+                && (isLeftIncluded ? left : nextUp(left))\n+                    <= (isRightIncluded ? right : nextDown(right)))) {\n+            throw new IllegalArgumentException(\n+                    \"the boundaries must be finite and the interval must not be empty\");\n+        }\n+\n+        \/*\n+         * Inspired by\n+         *      Goualard, \"Drawing random floating-point numbers from an\n+         *      interval\", ACM TOMACS, 2022, 32 (3)\n+         *      (https:\/\/hal.science\/hal-03282794v4)\n+         * although implemented differently.\n+         *\n+         * It is assumed that left <= right.\n+         * Whether the boundaries of the interval I = <left, right> are included\n+         * is indicated by isLeftIncluded and isRightIncluded.\n+         *\n+         * delta > 0 is the smallest double such that every product k delta\n+         * (k integer) that lies in I is an exact double as well.\n+         * It turns out that delta is always a power of 2.\n+         *\n+         * kl is the smallest k such that k delta is inside I.\n+         * kr > kl is the smallest k such that k delta is outside I.\n+         * n is kr - kl\n+         *\/\n+        double delta;  \/\/ captured\n+        long kl;  \/\/ captured\n+        long kr;\n+        long n;  \/\/ captured\n+\n+        if (left <= -right) {\n+            \/*\n+             * Here,\n+             *      left <= 0,      left <= right <= -left\n+             *      P = Double.PRECISION\n+             *\n+             * delta is the distance from left to the next double in the\n+             * direction of positive infinity.\n+             * Most of the time, this is equivalent to the ulp of left, but not\n+             * always.\n+             * For example, for left == -1.0, Math.ulp(left) == 2.220446049250313E-16,\n+             * whereas delta as computed here is 1.1102230246251565E-16.\n+             *\n+             * Every product k delta lying in [left, -left] is an exact double.\n+             * Thus, every product k delta lying in I is an exact double, too.\n+             * Any other positive eps < delta does not meet this property:\n+             * some product k eps lying in I is not an exact double.\n+             * On the other hand, any other eps > delta would generate more\n+             * sparse products k eps, that is, fewer doubles in I.\n+             * delta is therefore the best value to ensure the largest number\n+             * of equidistant doubles in the interval I.\n+             *\n+             * left \/ delta is an exact double and an exact integer with\n+             *      -2^P <= left \/ delta <= 0\n+             * Thus, kl is computed exactly.\n+             *\n+             * Mathematically,\n+             *      kr = ceil(right \/ delta),           if !isRightIncluded\n+             *      kr = floor(right \/ delta) + 1,      if isRightIncluded\n+             * The double division rd = right \/ delta never overflows and is\n+             * exact, except in the presence of underflows. But even underflows\n+             * do not affect the outcomes of ceil() and floor(), except,\n+             * in turn, when the result drops to 0, that is, rd = 0.\n+             *\n+             * crd is a corrected version of rd when rd is zero. It is simply\n+             * right \/ delta, but rounded away from 0 to preserve information\n+             * ensuring correct outcomes in ceil() and floor().\n+             *\n+             * We know that -2^P <= kl, so\n+             *      -2^P <= kl + nextLong(n)\n+             * Also, since right <= -left, we know that\n+             *      kr <= -kl + 1\n+             * so that\n+             *      0 < n <= -2 kl + 1\n+             * This implies\n+             *      kl + nextLong(n) <= kl + (-2 kl) = -kl <= 2^P\n+             * and thus\n+             *      -2^P <= kl + nextLong(n) <= 2^P\n+             * which shows that kl + nextLong(n) can be cast exactly to double.\n+             *\n+             * Further, if isLeftIncluded then left = kl delta, so that we get\n+             *      left = kl * delta <= (kl + nextLong(n)) * delta\n+             * For any other k < kl, when nextLong(n) = 0 we would have\n+             *      (k + nextLong(n)) * delta < left\n+             * Otherwise, left = (kl - 1) delta, and therefore\n+             *      left = (kl - 1) * delta < (kl + nextLong(n)) * delta\n+             * For any other k < kl, when nextLong(n) = 0 we would get\n+             *      (k + nextLong(n)) * delta <= left\n+             * Either way, the lhs expression would not belong to I.\n+             * That is, kl is the smallest integer such that kl delta always\n+             * lies in I (it is an exact double).\n+             *\n+             * Similar considerations show that kr is the smallest integer such\n+             * that kr delta lies to the right of I (it is an exact double).\n+             *\n+             * All the above means that (kl + nextLong(n)) * delta is an exact\n+             * double lying in I and that kl and kr, thus n, are the best\n+             * possible choices to ensure the largest number of equidistant\n+             * doubles in I. Uniform distribution relies on the guarantee\n+             * afforded by nextLong().\n+             *\/\n+            delta = nextUp(left) - left;\n+            double rd = right \/ delta;\n+            double crd = rd != 0 || right == 0 ? rd : copySign(Double.MIN_VALUE, right);\n+            kr = isRightIncluded ? (long) floor(crd) + 1 : (long) ceil(crd);\n+            kl = (long) (left \/ delta) + (isLeftIncluded ? 0 : 1);\n+        } else {\n+            \/* Here,\n+             *      right > 0,      -right < left <= right\n+             *\n+             * Considerations similar to the ones above apply here as well.\n+             *\/\n+            delta = right - nextDown(right);\n+            double ld = left \/ delta;\n+            double cld = ld != 0 || left == 0 ? ld : copySign(Double.MIN_VALUE, left);\n+            kl = isLeftIncluded ? (long) ceil(cld) : (long) floor(cld) + 1;\n+            kr = (long) (right \/ delta) + (isRightIncluded ? 1 : 0);\n+        }\n+        n = kr - kl;\n+        return DoubleStream.generate(() -> (kl + nextLong(n)) * delta).sequential();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":171,"deletions":2,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import sun.security.action.GetBooleanAction;\n@@ -124,0 +125,6 @@\n+    \/**\n+     * Flag which specifies whether the validation of the Zip64 extra\n+     * fields should be disabled\n+     *\/\n+    private static final boolean disableZip64ExtraFieldValidation =\n+            GetBooleanAction.privilegedGetProperty(\"jdk.util.zip.disableZip64ExtraFieldValidation\");\n@@ -1202,0 +1209,10 @@\n+\n+            int elen = CENEXT(cen, pos);\n+            if (elen > 0 && !disableZip64ExtraFieldValidation) {\n+                long extraStartingOffset = pos + CENHDR + nlen;\n+                if ((int)extraStartingOffset != extraStartingOffset) {\n+                    zerror(\"invalid CEN header (bad extra offset)\");\n+                }\n+                checkExtraFields(pos, (int)extraStartingOffset, elen);\n+            }\n+\n@@ -1217,1 +1234,0 @@\n-                    int elen = CENEXT(cen, pos);\n@@ -1227,0 +1243,113 @@\n+        \/**\n+         * Validate the Zip64 Extra block fields\n+         * @param startingOffset Extra Field starting offset within the CEN\n+         * @param extraFieldLen Length of this Extra field\n+         * @throws ZipException  If an error occurs validating the Zip64 Extra\n+         * block\n+         *\/\n+        private void checkExtraFields(int cenPos, int startingOffset,\n+                                      int extraFieldLen) throws ZipException {\n+            \/\/ Extra field Length cannot exceed 65,535 bytes per the PKWare\n+            \/\/ APP.note 4.4.11\n+            if (extraFieldLen > 0xFFFF) {\n+                zerror(\"invalid extra field length\");\n+            }\n+            \/\/ CEN Offset where this Extra field ends\n+            int extraEndOffset = startingOffset + extraFieldLen;\n+            if (extraEndOffset > cen.length) {\n+                zerror(\"Invalid CEN header (extra data field size too long)\");\n+            }\n+            int currentOffset = startingOffset;\n+            while (currentOffset < extraEndOffset) {\n+                int tag = get16(cen, currentOffset);\n+                currentOffset += Short.BYTES;\n+\n+                int tagBlockSize = get16(cen, currentOffset);\n+                int tagBlockEndingOffset = currentOffset + tagBlockSize;\n+\n+                \/\/  The ending offset for this tag block should not go past the\n+                \/\/  offset for the end of the extra field\n+                if (tagBlockEndingOffset > extraEndOffset) {\n+                    zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+                }\n+                currentOffset += Short.BYTES;\n+\n+                if (tag == ZIP64_EXTID) {\n+                    \/\/ Get the compressed size;\n+                    long csize = CENSIZ(cen, cenPos);\n+                    \/\/ Get the uncompressed size;\n+                    long size = CENLEN(cen, cenPos);\n+                    checkZip64ExtraFieldValues(currentOffset, tagBlockSize,\n+                            csize, size);\n+                }\n+                currentOffset += tagBlockSize;\n+            }\n+        }\n+\n+        \/**\n+         * Validate the Zip64 Extended Information Extra Field (0x0001) block\n+         * size and that the uncompressed size and compressed size field\n+         * values are not negative.\n+         * Note:  As we do not use the LOC offset or Starting disk number\n+         * field value we will not validate them\n+         * @param off the starting offset for the Zip64 field value\n+         * @param blockSize the size of the Zip64 Extended Extra Field\n+         * @param csize CEN header compressed size value\n+         * @param size CEN header uncompressed size value\n+         * @throws ZipException if an error occurs\n+         *\/\n+        private void checkZip64ExtraFieldValues(int off, int blockSize, long csize,\n+                                                long size)\n+                throws ZipException {\n+            byte[] cen = this.cen;\n+            \/\/ Validate the Zip64 Extended Information Extra Field (0x0001)\n+            \/\/ length.\n+            if (!isZip64ExtBlockSizeValid(blockSize)) {\n+                zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+            }\n+            \/\/ Check the uncompressed size is not negative\n+            \/\/ Note we do not need to check blockSize is >= 8 as\n+            \/\/ we know its length is at least 8 from the call to\n+            \/\/ isZip64ExtBlockSizeValid()\n+            if ((size == ZIP64_MAGICVAL)) {\n+                if(get64(cen, off) < 0) {\n+                    zerror(\"Invalid zip64 extra block size value\");\n+                }\n+            }\n+            \/\/ Check the compressed size is not negative\n+            if ((csize == ZIP64_MAGICVAL) && (blockSize >= 16)) {\n+                if (get64(cen, off + 8) < 0) {\n+                    zerror(\"Invalid zip64 extra block compressed size value\");\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Validate the size and contents of a Zip64 extended information field\n+         * The order of the Zip64 fields is fixed, but the fields MUST\n+         * only appear if the corresponding LOC or CEN field is set to 0xFFFF:\n+         * or 0xFFFFFFFF:\n+         * Uncompressed Size - 8 bytes\n+         * Compressed Size   - 8 bytes\n+         * LOC Header offset - 8 bytes\n+         * Disk Start Number - 4 bytes\n+         * See PKWare APP.Note Section 4.5.3 for more details\n+         *\n+         * @param blockSize the Zip64 Extended Information Extra Field size\n+         * @return true if the extra block size is valid; false otherwise\n+         *\/\n+        private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n+            \/*\n+             * As the fields must appear in order, the block size indicates which\n+             * fields to expect:\n+             *  8 - uncompressed size\n+             * 16 - uncompressed size, compressed size\n+             * 24 - uncompressed size, compressed sise, LOC Header offset\n+             * 28 - uncompressed size, compressed sise, LOC Header offset,\n+             * and Disk start number\n+             *\/\n+            return switch(blockSize) {\n+                case 8, 16, 24, 28 -> true;\n+                default -> false;\n+            };\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":130,"deletions":1,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -693,1 +693,6 @@\n-    int PREVIEW_MINOR_VERSION = -1;\n+    \/**\n+     * A minor version number indicating a class uses preview features\n+     * of a Java SE version since 12, for major versions {@value\n+     * #JAVA_12_VERSION} and above.\n+     *\/\n+    int PREVIEW_MINOR_VERSION = 65535;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -454,1 +454,1 @@\n-     * {@return a stream of the live threads in this flock}\n+     * {@return a stream of the threads in this flock}\n@@ -462,1 +462,1 @@\n-        return threads.stream().filter(Thread::isAlive);\n+        return threads.stream();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1140,0 +1140,5 @@\n+    \/**\n+     * Largest value that {@link #computeNextExponential} can ever return.\n+     *\/\n+    private static final double MAX_EXPONENTIAL = 0x1.0p63 * DoubleZigguratTables.exponentialX0;\n+\n@@ -1144,0 +1149,18 @@\n+     * @param rng an instance of {@code RandomGenerator}, used to generate uniformly\n+     *            pseudorandomly chosen {@code long} values\n+     *\n+     * @return a nonnegative {@code double} value chosen pseudorandomly\n+     *         from an exponential distribution whose mean is 1\n+     *\/\n+    public static double computeNextExponential(RandomGenerator rng) {\n+        return computeNextExponentialSoftCapped(rng, MAX_EXPONENTIAL);\n+    }\n+\n+    \/**\n+     * Generates a pseudorandom value {@code x} such that {@code Math.min(x, maxValue)}\n+     * follows the same distribution as it would if {@code x} was exponentially distributed\n+     * with mean 1, but with a worst-case number of calls to {@link\n+     * RandomGenerator#nextLong()} that's linear with {@code maxValue}. {@code maxValue} is\n+     * a \"soft\" cap in that a value larger than {@code maxValue} may be returned in order\n+     * to save a calculation.\n+     *\n@@ -1160,1 +1183,1 @@\n-    public static double computeNextExponential(RandomGenerator rng) {\n+    public static double computeNextExponentialSoftCapped(RandomGenerator rng, double maxValue) {\n@@ -1189,3 +1212,12 @@\n-        \/\/ We didn't use the upper part of U1 after all.  We'll be able to use it later.\n-\n-        for (double extra = 0.0; ; ) {\n+        \/\/ We didn't use the upper part of U1 after all.  We'll probably be able to use it later.\n+        if (maxValue <= 0.0) {\n+            return 0.0;\n+        }\n+        final long maxExtraMinus1;\n+        if (maxValue >= MAX_EXPONENTIAL) {\n+            maxExtraMinus1 = Long.MAX_VALUE;\n+        } else {\n+            \/\/ Conversion to long rounds toward zero\n+            maxExtraMinus1 = (long) (maxValue \/ DoubleZigguratTables.exponentialX0);\n+        }\n+        for (long extra = 0; ; ) {\n@@ -1222,1 +1254,1 @@\n-                        return x + extra;   \/\/ The chosen point is way below the curve; accept it.\n+                        return Math.fma(extra, DoubleZigguratTables.exponentialX0, x);   \/\/ The chosen point is way below the curve; accept it.\n@@ -1228,1 +1260,1 @@\n-                        return x + extra;   \/\/ The chosen point is below the curve; accept it.\n+                        return Math.fma(extra, DoubleZigguratTables.exponentialX0, x);   \/\/ The chosen point is below the curve; accept it.\n@@ -1233,0 +1265,4 @@\n+            if (extra == maxExtraMinus1) {\n+                \/\/ We've reached the maximum, so don't waste any more time\n+                return maxValue;\n+            }\n@@ -1235,2 +1271,2 @@\n-            extra += DoubleZigguratTables.exponentialX0;\n-            \/\/ This is like the first five lines of this method, but if it returns, it first adds \"extra\".\n+            extra++;\n+            \/\/ This is like the first five lines of this method, but if it returns, it first adds \"extra\" times X0.\n@@ -1240,1 +1276,1 @@\n-                return DoubleZigguratTables.exponentialX[(int)i] * (U1 >>> 1) + extra;\n+                return Math.fma(extra, DoubleZigguratTables.exponentialX0, DoubleZigguratTables.exponentialX[(int)i] * (U1 >>> 1));\n@@ -1362,0 +1398,1 @@\n+            double limit;\n@@ -1364,1 +1401,2 @@\n-            } while (computeNextExponential(rng) < 0.5*x*x);\n+                limit = 0.5*x*x;\n+            } while (computeNextExponentialSoftCapped(rng, limit) < limit);\n@@ -1395,1 +1433,1 @@\n-                x = (X[j] * 0x1.0p63) + ((X[j-1] - X[j]) * (double)U1);\n+                x = Math.fma(X[j-1] - X[j], (double)U1, X[j] * 0x1.0p63);\n@@ -1405,1 +1443,1 @@\n-                double y = (Y[j] * 0x1.0p63) + ((Y[j-1] - Y[j]) * (double)U2);\n+                double y = Math.fma(Y[j-1] - Y[j], (double)U2, Y[j] * 0x1.0p63);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":50,"deletions":12,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -326,2 +326,1 @@\n-        java.security.jgss,\n-        jdk.crypto.ec;\n+        java.security.jgss;\n@@ -334,1 +333,0 @@\n-        jdk.crypto.ec,\n@@ -338,1 +336,0 @@\n-        jdk.crypto.ec,\n@@ -344,1 +341,0 @@\n-        jdk.crypto.ec,\n@@ -363,1 +359,0 @@\n-        jdk.crypto.ec,\n@@ -368,4 +363,0 @@\n-    exports sun.security.util.math to\n-        jdk.crypto.ec;\n-    exports sun.security.util.math.intpoly to\n-        jdk.crypto.ec;\n@@ -373,1 +364,0 @@\n-        jdk.crypto.ec,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -52,0 +51,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -81,1 +81,0 @@\n-import jdk.internal.util.OperatingSystem;\n@@ -89,0 +88,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -173,1 +173,5 @@\n-                printLocale();\n+                printLocale(false);\n+                break;\n+            case \"security\":\n+                var opt = opts.length > 2 ? opts[2].trim() : \"all\";\n+                SecuritySettings.printSecuritySettings(opt, ostream);\n@@ -183,1 +187,2 @@\n-                printLocale();\n+                printLocale(true);\n+                SecuritySettings.printSecuritySummarySettings(ostream);\n@@ -278,1 +283,1 @@\n-    private static void printLocale() {\n+    private static void printLocale(boolean summaryMode) {\n@@ -280,1 +285,7 @@\n-        ostream.println(LOCALE_SETTINGS);\n+        if (!summaryMode) {\n+            ostream.println(LOCALE_SETTINGS);\n+        } else {\n+            ostream.println(\"Locale settings summary:\");\n+            ostream.println(INDENT + \"Use \\\"-XshowSettings:locale\\\" \" +\n+                    \"option for verbose locale settings options\");\n+        }\n@@ -289,1 +300,3 @@\n-        printLocales();\n+        if (!summaryMode) {\n+            printLocales();\n+        }\n@@ -321,0 +334,1 @@\n+        ostream.println();\n@@ -323,1 +337,1 @@\n-    public static void printSystemMetrics() {\n+    private static void printSystemMetrics() {\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.launcher;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.access.SharedSecrets;\n+\n+\/**\n+ * A utility class for security libs functionality\n+ * in the -XshowSettings:security output\n+ *\/\n+public final class SecuritySettings {\n+\n+    private static final String INDENT = \"    \";\n+    private static final String TWOINDENT = INDENT + INDENT;\n+    private static final String THREEINDENT = TWOINDENT + INDENT;\n+    private static final String PROV_INFO_STRING = \"Provider information: \";\n+    private static PrintStream ostream = null;\n+\n+    static void printSecuritySettings(String arg, PrintStream stream) {\n+        ostream = stream;\n+        switch (arg) {\n+            case \"properties\" -> printSecurityProperties();\n+            case \"providers\"  -> printSecurityProviderConfig(true);\n+            case \"tls\"        -> printSecurityTLSConfig(true);\n+            case \"all\"        -> printAllSecurityConfig();\n+            default           -> ostream.println(\n+                    \"\\nUnrecognized security subcommand. Valid values are \" +\n+                    \"\\\"all\\\", \\\"properties\\\", \\\"providers\\\", \\\"tls\\\". See \\\"java -X\\\"\\n\");\n+        }\n+    }\n+\n+    \/\/ A non-verbose description of some core security configuration settings\n+    static void printSecuritySummarySettings(PrintStream stream) {\n+        ostream = stream;\n+        ostream.println(\"Security settings summary: \" + \"\\n\" +\n+                INDENT + \"See \\\"java -X\\\" for verbose security settings options\");\n+        printSecurityProviderConfig(false);\n+        printSecurityTLSConfig(false);\n+    }\n+\n+    static void printAllSecurityConfig() {\n+        ostream.println(\"Security settings:\");\n+        printSecurityProperties();\n+        printSecurityProviderConfig(true);\n+        printSecurityTLSConfig(true);\n+    }\n+\n+    private static void printSecurityProperties() {\n+        ostream.println(INDENT + \"Security properties:\");\n+        Properties p = SharedSecrets.getJavaSecurityPropertiesAccess().getInitialProperties();\n+        for (String key : p.stringPropertyNames().stream().sorted().toList()) {\n+            String val = p.getProperty(key);\n+            if (val.length() > 60) {\n+                splitLongPropertyLines(key, val);\n+            } else {\n+                ostream.println(TWOINDENT + key + \"=\" + val);\n+            }\n+        }\n+        ostream.println();\n+    }\n+\n+    private static void splitLongPropertyLines(String key, String val) {\n+        \/\/ split long property values which use well known separator\n+        if (val.contains(\",\") || val.contains(\";\")) {\n+            String separator = (val.contains(\",\")) ? \",\" : \";\";\n+            ostream.println(TWOINDENT + key + \"=\");\n+            String[] values = val.split(separator);\n+            String lastValue = values[values.length -1].trim();\n+            List.of(values).forEach(\n+                    s -> ostream.println(THREEINDENT + s.trim() +\n+                            (s.trim().equals(lastValue) ? \"\" : separator)));\n+        } else {\n+            ostream.println(TWOINDENT + key + \"=\" + val);\n+        }\n+    }\n+\n+    private static void printSecurityTLSConfig(boolean verbose) {\n+        SSLSocket ssls;\n+        SSLContext sslContext;\n+        try {\n+            sslContext = SSLContext.getDefault();\n+            ssls = (SSLSocket)sslContext.getSocketFactory().createSocket();\n+        } catch (IOException | NoSuchAlgorithmException e) {\n+            ostream.println(INDENT + \"Failed to create SSL socket\");\n+            ostream.println(INDENT + e + \"\\n\");\n+            return;\n+        }\n+\n+        ostream.println(INDENT + \"Security TLS configuration (\" +\n+                sslContext.getProvider().getName() + \" provider):\");\n+        ostream.println(TWOINDENT + \"Enabled Protocols:\");\n+        for (String s : ssls.getEnabledProtocols()) {\n+            ostream.println(THREEINDENT + s);\n+        }\n+\n+        if (verbose) {\n+            ostream.println(\"\\n\" + TWOINDENT + \"Enabled Cipher Suites:\");\n+            for (String s : ssls.getEnabledCipherSuites()) {\n+                ostream.println(THREEINDENT + s);\n+            }\n+        }\n+        ostream.println();\n+    }\n+\n+    private static void printSecurityProviderConfig(boolean verbose) {\n+        ostream.println(INDENT + \"Security provider static configuration: (in order of preference)\");\n+        for (Provider p : Security.getProviders()) {\n+            if (verbose) {\n+                \/\/ separate the views out\n+                ostream.println(TWOINDENT + \"-\".repeat(40));\n+            }\n+            ostream.println(TWOINDENT + \"Provider name: \" + p.getName());\n+            if (verbose) {\n+                ostream.println(wrappedString(PROV_INFO_STRING + p.getInfo(), 80,\n+                        TWOINDENT, THREEINDENT));\n+                ostream.println(TWOINDENT + \"Provider services: (type : algorithm)\");\n+                Set<Provider.Service> services = p.getServices();\n+                Set<String> keys = Collections.list(p.keys())\n+                        .stream()\n+                        .map(String.class::cast)\n+                        .filter(s -> s.startsWith(\"Alg.Alias.\"))\n+                        .collect(Collectors.toSet());\n+                if (!services.isEmpty()) {\n+                    services.stream()\n+                            .sorted(Comparator.comparing(Provider.Service::getType)\n+                                    .thenComparing(Provider.Service::getAlgorithm))\n+                            .forEach(ps -> {\n+                                ostream.println(THREEINDENT +\n+                                        ps.getType() + \".\" + ps.getAlgorithm());\n+                                List<String> aliases = keys\n+                                        .stream()\n+                                        .filter(s -> s.startsWith(\"Alg.Alias.\" + ps.getType()))\n+                                        .filter(s -> p.getProperty(s).equals(ps.getAlgorithm()))\n+                                        .map(s -> s.substring((\"Alg.Alias.\" + ps.getType() + \".\").length()))\n+                                        .toList();\n+\n+                                if (!aliases.isEmpty()) {\n+                                    ostream.println(wrappedString(\n+                                            aliases.stream()\n+                                                    .collect(Collectors.joining(\", \", INDENT + \" aliases: [\", \"]\")),\n+                                            80, \" \" + TWOINDENT, INDENT + THREEINDENT));\n+                                }\n+                            });\n+                } else {\n+                    ostream.println(THREEINDENT + \"<none>\");\n+                }\n+            }\n+        }\n+        if (verbose) {\n+            ostream.println();\n+        }\n+    }\n+\n+    \/\/ return a string split across multiple lines which aims to limit max length\n+    private static String wrappedString(String orig, int limit,\n+                                        String initIndent, String successiveIndent) {\n+        if (orig == null || orig.isEmpty() || limit <= 0) {\n+            \/\/ bad input\n+            return orig;\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        int widthCount = 0;\n+        for (String s : orig.split(\" \")) {\n+            if (widthCount == 0) {\n+                \/\/ first iteration only\n+                sb.append(initIndent + s);\n+                widthCount = s.length() + initIndent.length();\n+            } else {\n+                if (widthCount + s.length() > limit) {\n+                    sb.append(\"\\n\" + successiveIndent + s);\n+                    widthCount = s.length() + successiveIndent.length();\n+                } else {\n+                    sb.append(\" \" + s);\n+                    widthCount += s.length() + 1;\n+                }\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/SecuritySettings.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -173,0 +173,10 @@\n+\\    -XshowSettings:security\\n\\\n+\\                      show all security settings and continue\\n\\\n+\\    -XshowSettings:security:all\\n\\\n+\\                      show all security settings and continue\\n\\\n+\\    -XshowSettings:security:properties\\n\\\n+\\                      show security properties and continue\\n\\\n+\\    -XshowSettings:security:providers\\n\\\n+\\                      show static security provider settings and continue\\n\\\n+\\    -XshowSettings:security:tls\\n\\\n+\\                      show TLS related security settings and continue\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.net.DatagramPacket;\n@@ -653,1 +654,1 @@\n-     * Receives a datagram into the given buffer.\n+     * Receives a datagram.\n@@ -655,2 +656,1 @@\n-     * @apiNote This method is for use by the socket adaptor. The buffer is\n-     * assumed to be trusted, meaning it is not accessible to user code.\n+     * @apiNote This method is for use by the socket adaptor.\n@@ -661,1 +661,4 @@\n-    SocketAddress blockingReceive(ByteBuffer dst, long nanos) throws IOException {\n+    void blockingReceive(DatagramPacket p, long nanos) throws IOException {\n+        Objects.requireNonNull(p);\n+        assert nanos >= 0;\n+\n@@ -667,25 +670,0 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            boolean connected = isConnected();\n-            SocketAddress sender;\n-            do {\n-                if (nanos > 0) {\n-                    sender = trustedBlockingReceive(dst, nanos);\n-                } else {\n-                    sender = trustedBlockingReceive(dst);\n-                }\n-                \/\/ check sender when security manager set and not connected\n-                if (sm != null && !connected) {\n-                    InetSocketAddress isa = (InetSocketAddress) sender;\n-                    try {\n-                        sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n-                    } catch (SecurityException e) {\n-                        sender = null;\n-                    }\n-                }\n-            } while (sender == null);\n-            return sender;\n-        } finally {\n-            readLock.unlock();\n-        }\n-    }\n@@ -693,18 +671,6 @@\n-    \/**\n-     * Receives a datagram into given buffer. This method is used to support\n-     * the socket adaptor. The buffer is assumed to be trusted.\n-     * @throws SocketTimeoutException if the timeout elapses\n-     *\/\n-    private SocketAddress trustedBlockingReceive(ByteBuffer dst)\n-        throws IOException\n-    {\n-        assert readLock.isHeldByCurrentThread() && isBlocking();\n-        SocketAddress sender = null;\n-        try {\n-            SocketAddress remote = beginRead(true, false);\n-            configureSocketNonBlockingIfVirtualThread();\n-            boolean connected = (remote != null);\n-            int n = receive(dst, connected);\n-            while (IOStatus.okayToRetry(n) && isOpen()) {\n-                park(Net.POLLIN);\n-                n = receive(dst, connected);\n+            \/\/ underlying socket needs to be non-blocking if timed receive or virtual thread\n+            if (nanos > 0) {\n+                configureSocketNonBlocking();\n+            } else {\n+                configureSocketNonBlockingIfVirtualThread();\n+                nanos = Long.MAX_VALUE;\n@@ -712,3 +678,51 @@\n-            if (n > 0 || (n == 0 && isOpen())) {\n-                \/\/ sender address is in socket address buffer\n-                sender = sourceSocketAddress();\n+\n+            \/\/ p.bufLength is the maximum size of the datagram that can be received\n+            int bufLength;\n+            synchronized (p) {\n+                bufLength = DatagramPackets.getBufLength(p);\n+            }\n+\n+            long startNanos = System.nanoTime();\n+            SocketAddress sender = null;\n+            try {\n+                SocketAddress remote = beginRead(true, false);\n+                boolean connected = (remote != null);\n+                do {\n+                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                    ByteBuffer dst = tryBlockingReceive(connected, bufLength, remainingNanos);\n+\n+                    \/\/ if datagram received then get sender and copy to DatagramPacket\n+                    if (dst != null) {\n+                        try {\n+                            \/\/ sender address is in socket address buffer\n+                            sender = sourceSocketAddress();\n+\n+                            \/\/ check sender when security manager set and not connected\n+                            @SuppressWarnings(\"removal\")\n+                            SecurityManager sm = System.getSecurityManager();\n+                            if (sm != null && !connected) {\n+                                InetSocketAddress isa = (InetSocketAddress) sender;\n+                                try {\n+                                    sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n+                                } catch (SecurityException e) {\n+                                    sender = null;\n+                                }\n+                            }\n+\n+                            \/\/ copy bytes to the DatagramPacket, and set length and sender\n+                            if (sender != null) {\n+                                synchronized (p) {\n+                                    \/\/ re-read p.bufLength in case DatagramPacket changed\n+                                    int len = Math.min(dst.limit(), DatagramPackets.getBufLength(p));\n+                                    dst.get(p.getData(), p.getOffset(), len);\n+                                    DatagramPackets.setLength(p, len);\n+                                    p.setSocketAddress(sender);\n+                                }\n+                            }\n+                        } finally {\n+                            Util.offerFirstTemporaryDirectBuffer(dst);\n+                        }\n+                    }\n+                } while (sender == null && isOpen());\n+            } finally {\n+                endRead(true, (sender != null));\n@@ -716,1 +730,0 @@\n-            return sender;\n@@ -718,1 +731,1 @@\n-            endRead(true, (sender != null));\n+            readLock.unlock();\n@@ -723,2 +736,6 @@\n-     * Receives a datagram into given buffer with a timeout. This method is\n-     * used to support the socket adaptor. The buffer is assumed to be trusted.\n+     * Attempt to receive a datagram.\n+     *\n+     * @param connected if the channel's socket is connected\n+     * @param len the maximum size of the datagram to receive\n+     * @param nanos the timeout, should be Long.MAX_VALUE for untimed\n+     * @return a direct buffer containing the datagram or null if channel is closed\n@@ -727,1 +744,1 @@\n-    private SocketAddress trustedBlockingReceive(ByteBuffer dst, long nanos)\n+    private ByteBuffer tryBlockingReceive(boolean connected, int len, long nanos)\n@@ -730,2 +747,3 @@\n-        assert readLock.isHeldByCurrentThread() && isBlocking();\n-        SocketAddress sender = null;\n+        long startNanos = System.nanoTime();\n+        ByteBuffer dst = Util.getTemporaryDirectBuffer(len);\n+        int n = -1;\n@@ -733,15 +751,6 @@\n-            SocketAddress remote = beginRead(true, false);\n-            boolean connected = (remote != null);\n-\n-            \/\/ change socket to non-blocking\n-            lockedConfigureBlocking(false);\n-            try {\n-                long startNanos = System.nanoTime();\n-                int n = receive(dst, connected);\n-                while (n == IOStatus.UNAVAILABLE && isOpen()) {\n-                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n-                    if (remainingNanos <= 0) {\n-                        throw new SocketTimeoutException(\"Receive timed out\");\n-                    }\n-                    park(Net.POLLIN, remainingNanos);\n-                    n = receive(dst, connected);\n+            n = receive(dst, connected);\n+            while (n == IOStatus.UNAVAILABLE && isOpen()) {\n+                \/\/ virtual thread needs to release temporary direct buffer before parking\n+                if (Thread.currentThread().isVirtual()) {\n+                    Util.offerFirstTemporaryDirectBuffer(dst);\n+                    dst = null;\n@@ -749,3 +758,3 @@\n-                if (n > 0 || (n == 0 && isOpen())) {\n-                    \/\/ sender address is in socket address buffer\n-                    sender = sourceSocketAddress();\n+                long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                if (remainingNanos <= 0) {\n+                    throw new SocketTimeoutException(\"Receive timed out\");\n@@ -753,4 +762,6 @@\n-                return sender;\n-            } finally {\n-                \/\/ restore socket to blocking mode (if channel is open)\n-                tryLockedConfigureBlocking(true);\n+                park(Net.POLLIN, remainingNanos);\n+                \/\/ virtual thread needs to re-allocate temporary direct buffer after parking\n+                if (Thread.currentThread().isVirtual()) {\n+                    dst = Util.getTemporaryDirectBuffer(len);\n+                }\n+                n = receive(dst, connected);\n@@ -758,0 +769,1 @@\n+            dst.flip();\n@@ -759,1 +771,5 @@\n-            endRead(true, (sender != null));\n+            \/\/ release buffer if no datagram received\n+            if (dst != null && (n < 0 || (n == 0 && !isOpen()))) {\n+                Util.offerFirstTemporaryDirectBuffer(dst);\n+                dst = null;\n+            }\n@@ -761,0 +777,1 @@\n+        return dst;\n@@ -892,1 +909,1 @@\n-     * Sends a datagram from the bytes in given buffer.\n+     * Sends a datagram.\n@@ -896,0 +913,1 @@\n+     * @throws IllegalArgumentException if not connected and target address not set\n@@ -898,1 +916,3 @@\n-    void blockingSend(ByteBuffer src, SocketAddress target) throws IOException {\n+    void blockingSend(DatagramPacket p) throws IOException {\n+        Objects.requireNonNull(p);\n+\n@@ -904,1 +924,33 @@\n-            send(src, target);\n+\n+            ByteBuffer src = null;\n+            try {\n+                InetSocketAddress target;\n+                synchronized (p) {\n+                    int len = p.getLength();\n+                    src = Util.getTemporaryDirectBuffer(len);\n+\n+                    \/\/ copy bytes to temporary direct buffer\n+                    src.put(p.getData(), p.getOffset(), len);\n+                    src.flip();\n+\n+                    \/\/ target address\n+                    if (p.getAddress() == null) {\n+                        InetSocketAddress remote = remoteAddress();\n+                        if (remote == null) {\n+                            throw new IllegalArgumentException(\"Address not set\");\n+                        }\n+                        \/\/ set address\/port to be compatible with long standing behavior\n+                        p.setAddress(remote.getAddress());\n+                        p.setPort(remote.getPort());\n+                        target = remote;\n+                    } else {\n+                        target = (InetSocketAddress) p.getSocketAddress();\n+                    }\n+                }\n+\n+                \/\/ send the datagram (does not block)\n+                send(src, target);\n+\n+            } finally {\n+                if (src != null) Util.offerFirstTemporaryDirectBuffer(src);\n+            }\n@@ -1201,1 +1253,1 @@\n-     * Ensures that the socket is configured non-blocking when on a virtual thread.\n+     * Ensures that the socket is configured non-blocking.\n@@ -1204,1 +1256,1 @@\n-    private void configureSocketNonBlockingIfVirtualThread() throws IOException {\n+    private void configureSocketNonBlocking() throws IOException {\n@@ -1206,1 +1258,1 @@\n-        if (!forcedNonBlocking && Thread.currentThread().isVirtual()) {\n+        if (!forcedNonBlocking) {\n@@ -1215,0 +1267,10 @@\n+    \/**\n+     * Ensures that the socket is configured non-blocking when on a virtual thread.\n+     * @throws IOException if there is an I\/O error changing the blocking mode\n+     *\/\n+    private void configureSocketNonBlockingIfVirtualThread() throws IOException {\n+        if (Thread.currentThread().isVirtual()) {\n+            configureSocketNonBlocking();\n+        }\n+    }\n+\n@@ -1955,0 +2017,38 @@\n+    \/**\n+     * Defines static methods to get\/set DatagramPacket fields and workaround\n+     * DatagramPacket deficiencies.\n+     *\/\n+    private static class DatagramPackets {\n+        private static final VarHandle LENGTH;\n+        private static final VarHandle BUF_LENGTH;\n+        static {\n+            try {\n+                PrivilegedExceptionAction<MethodHandles.Lookup> pa = () ->\n+                    MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());\n+                @SuppressWarnings(\"removal\")\n+                MethodHandles.Lookup l = AccessController.doPrivileged(pa);\n+                LENGTH = l.findVarHandle(DatagramPacket.class, \"length\", int.class);\n+                BUF_LENGTH = l.findVarHandle(DatagramPacket.class, \"bufLength\", int.class);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+\n+        \/**\n+         * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be\n+         * used at this time because it sets both the length and bufLength fields.\n+         *\/\n+        static void setLength(DatagramPacket p, int value) {\n+            assert Thread.holdsLock(p);\n+            LENGTH.set(p, value);\n+        }\n+\n+        \/**\n+         * Returns the value of the DatagramPacket.bufLength field.\n+         *\/\n+        static int getBufLength(DatagramPacket p) {\n+            assert Thread.holdsLock(p);\n+            return (int) BUF_LENGTH.get(p);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":186,"deletions":86,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -47,1 +46,0 @@\n-import java.nio.ByteBuffer;\n@@ -59,1 +57,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -195,33 +192,6 @@\n-        synchronized (p) {\n-            int len = p.getLength();\n-            ByteBuffer bb = Util.getTemporaryDirectBuffer(len);\n-            try {\n-                \/\/ copy bytes to temporary direct buffer\n-                bb.put(p.getData(), p.getOffset(), len);\n-                bb.flip();\n-\n-                \/\/ target address\n-                InetSocketAddress target;\n-                if (p.getAddress() == null) {\n-                    InetSocketAddress remote = dc.remoteAddress();\n-                    if (remote == null) {\n-                        \/\/ not specified by DatagramSocket\n-                        throw new IllegalArgumentException(\"Address not set\");\n-                    }\n-                    \/\/ set address\/port to maintain compatibility with DatagramSocket\n-                    p.setAddress(remote.getAddress());\n-                    p.setPort(remote.getPort());\n-                    target = remote;\n-                } else {\n-                    target = (InetSocketAddress) p.getSocketAddress();\n-                }\n-\n-                \/\/ send datagram\n-                dc.blockingSend(bb, target);\n-            } catch (AlreadyConnectedException e) {\n-                throw new IllegalArgumentException(\"Connected and packet address differ\");\n-            } catch (ClosedChannelException e) {\n-                throw new SocketException(\"Socket closed\", e);\n-            } finally {\n-                Util.offerFirstTemporaryDirectBuffer(bb);\n-            }\n+        try {\n+            dc.blockingSend(p);\n+        } catch (AlreadyConnectedException e) {\n+            throw new IllegalArgumentException(\"Connected and packet address differ\");\n+        } catch (ClosedChannelException e) {\n+            throw new SocketException(\"Socket closed\", e);\n@@ -233,34 +203,9 @@\n-        synchronized (p) {\n-            \/\/ get temporary direct buffer with a capacity of p.bufLength\n-            int bufLength = DatagramPackets.getBufLength(p);\n-            ByteBuffer bb = Util.getTemporaryDirectBuffer(bufLength);\n-            try {\n-                SocketAddress sender;\n-                long comp = Blocker.begin();\n-                try {\n-                    sender = dc.blockingReceive(bb, MILLISECONDS.toNanos(timeout));\n-                } finally {\n-                    Blocker.end(comp);\n-                }\n-                bb.flip();\n-\n-                \/\/ copy bytes to the DatagramPacket and set length\n-                int len = Math.min(bb.limit(), DatagramPackets.getBufLength(p));\n-                bb.get(p.getData(), p.getOffset(), len);\n-                DatagramPackets.setLength(p, len);\n-\n-                \/\/ sender address\n-                p.setSocketAddress(sender);\n-            } catch (SocketTimeoutException | ClosedByInterruptException e) {\n-                throw e;\n-            } catch (InterruptedIOException e) {\n-                Thread thread = Thread.currentThread();\n-                if (thread.isVirtual() && thread.isInterrupted()) {\n-                    close();\n-                    throw new SocketException(\"Closed by interrupt\");\n-                }\n-                throw e;\n-            } catch (ClosedChannelException e) {\n-                throw new SocketException(\"Socket closed\", e);\n-            } finally {\n-                Util.offerFirstTemporaryDirectBuffer(bb);\n+        try {\n+            dc.blockingReceive(p, MILLISECONDS.toNanos(timeout));\n+        } catch (SocketTimeoutException | ClosedByInterruptException e) {\n+            throw e;\n+        } catch (InterruptedIOException e) {\n+            Thread thread = Thread.currentThread();\n+            if (thread.isVirtual() && thread.isInterrupted()) {\n+                close();\n+                throw new SocketException(\"Closed by interrupt\");\n@@ -268,0 +213,3 @@\n+            throw e;\n+        } catch (ClosedChannelException e) {\n+            throw new SocketException(\"Socket closed\", e);\n@@ -707,38 +655,0 @@\n-    \/**\n-     * Defines static methods to get\/set DatagramPacket fields and workaround\n-     * DatagramPacket deficiencies.\n-     *\/\n-    private static class DatagramPackets {\n-        private static final VarHandle LENGTH;\n-        private static final VarHandle BUF_LENGTH;\n-        static {\n-            try {\n-                PrivilegedExceptionAction<MethodHandles.Lookup> pa = () ->\n-                    MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());\n-                @SuppressWarnings(\"removal\")\n-                MethodHandles.Lookup l = AccessController.doPrivileged(pa);\n-                LENGTH = l.findVarHandle(DatagramPacket.class, \"length\", int.class);\n-                BUF_LENGTH = l.findVarHandle(DatagramPacket.class, \"bufLength\", int.class);\n-            } catch (Exception e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        }\n-\n-        \/**\n-         * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be\n-         * used at this time because it sets both the length and bufLength fields.\n-         *\/\n-        static void setLength(DatagramPacket p, int value) {\n-            assert Thread.holdsLock(p);\n-            LENGTH.set(p, value);\n-        }\n-\n-        \/**\n-         * Returns the value of the DatagramPacket.bufLength field.\n-         *\/\n-        static int getBufLength(DatagramPacket p) {\n-            assert Thread.holdsLock(p);\n-            return (int) BUF_LENGTH.get(p);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramSocketAdaptor.java","additions":19,"deletions":109,"binary":false,"changes":128,"status":"modified"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDSAOperations.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDSAOperations.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDSASignature.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDSASignature.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECKeyPairGenerator.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECKeyPairGenerator.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPublicKeyImpl.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECPublicKeyImpl.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ParametersMap.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ParametersMap.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/SunEC.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/SunEC.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHKeyAgreement.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XDHKeyAgreement.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHKeyFactory.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XDHKeyFactory.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHKeyPairGenerator.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XDHKeyPairGenerator.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPublicKeyImpl.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XDHPublicKeyImpl.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XECOperations.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XECOperations.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XECParameters.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/XECParameters.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/Ed25519Operations.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed25519Operations.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/Ed448Operations.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed448Operations.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAAlgorithmParameters.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAAlgorithmParameters.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyFactory.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyFactory.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyPairGenerator.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyPairGenerator.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAOperations.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAOperations.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAParameters.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAParameters.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPublicKeyImpl.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPublicKeyImpl.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSASignature.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSASignature.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdECOperations.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdECOperations.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/AffinePoint.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/point\/AffinePoint.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/ExtendedHomogeneousPoint.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/point\/ExtendedHomogeneousPoint.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/ImmutablePoint.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/point\/ImmutablePoint.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/MutablePoint.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/point\/MutablePoint.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/Point.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/point\/Point.java","status":"renamed"},{"patch":"","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/point\/ProjectivePoint.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/point\/ProjectivePoint.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,21 +179,30 @@\n-            \/\/ Create providers which are in java.base directly\n-            if (provName.equals(\"SUN\") || provName.equals(\"sun.security.provider.Sun\")) {\n-                p = new sun.security.provider.Sun();\n-            } else if (provName.equals(\"SunRsaSign\") || provName.equals(\"sun.security.rsa.SunRsaSign\")) {\n-                p = new sun.security.rsa.SunRsaSign();\n-            } else if (provName.equals(\"SunJCE\") || provName.equals(\"com.sun.crypto.provider.SunJCE\")) {\n-                p = new com.sun.crypto.provider.SunJCE();\n-            } else if (provName.equals(\"SunJSSE\")) {\n-                p = new sun.security.ssl.SunJSSE();\n-            } else if (provName.equals(\"Apple\") || provName.equals(\"apple.security.AppleProvider\")) {\n-                \/\/ need to use reflection since this class only exists on MacOsx\n-                @SuppressWarnings(\"removal\")\n-                var tmp = AccessController.doPrivileged(new PrivilegedAction<Provider>() {\n-                    public Provider run() {\n-                        try {\n-                            Class<?> c = Class.forName(\"apple.security.AppleProvider\");\n-                            if (Provider.class.isAssignableFrom(c)) {\n-                                @SuppressWarnings(\"deprecation\")\n-                                Object tmp = c.newInstance();\n-                                return (Provider) tmp;\n-                            } else {\n+            p = switch (provName) {\n+                case \"SUN\", \"sun.security.provider.Sun\" ->\n+                    new sun.security.provider.Sun();\n+                case \"SunRsaSign\", \"sun.security.rsa.SunRsaSign\" ->\n+                    new sun.security.rsa.SunRsaSign();\n+                case \"SunJCE\", \"com.sun.crypto.provider.SunJCE\" ->\n+                    new com.sun.crypto.provider.SunJCE();\n+                case \"SunJSSE\" -> new sun.security.ssl.SunJSSE();\n+                case \"SunEC\" -> new sun.security.ec.SunEC();\n+                case \"Apple\", \"apple.security.AppleProvider\" -> {\n+                    \/\/ Reflection is needed for compile time as the class\n+                    \/\/ is not available for non-macosx systems\n+                    @SuppressWarnings(\"removal\")\n+                    var tmp = AccessController.doPrivileged(\n+                        new PrivilegedAction<Provider>() {\n+                            public Provider run() {\n+                                try {\n+                                    Class<?> c = Class.forName(\n+                                        \"apple.security.AppleProvider\");\n+                                    if (Provider.class.isAssignableFrom(c)) {\n+                                        @SuppressWarnings(\"deprecation\")\n+                                        Object tmp = c.newInstance();\n+                                        return (Provider) tmp;\n+                                    }\n+                                } catch (Exception ex) {\n+                                    if (debug != null) {\n+                                        debug.println(\"Error loading provider Apple\");\n+                                        ex.printStackTrace();\n+                                    }\n+                                }\n@@ -202,6 +211,10 @@\n-                        } catch (Exception ex) {\n-                            if (debug != null) {\n-                                debug.println(\"Error loading provider Apple\");\n-                                ex.printStackTrace();\n-                            }\n-                            return null;\n+                        });\n+                    yield tmp;\n+                }\n+                default -> {\n+                    if (isLoading) {\n+                        \/\/ because this method is synchronized, this can only\n+                        \/\/ happen if there is recursion.\n+                        if (debug != null) {\n+                            debug.println(\"Recursion loading provider: \" + this);\n+                            new Exception(\"Call trace\").printStackTrace();\n@@ -209,0 +222,1 @@\n+                        yield null;\n@@ -210,9 +224,6 @@\n-                });\n-                p = tmp;\n-            } else {\n-                if (isLoading) {\n-                    \/\/ because this method is synchronized, this can only\n-                    \/\/ happen if there is recursion.\n-                    if (debug != null) {\n-                        debug.println(\"Recursion loading provider: \" + this);\n-                        new Exception(\"Call trace\").printStackTrace();\n+                    try {\n+                        isLoading = true;\n+                        tries++;\n+                        yield doLoadProvider();\n+                    } finally {\n+                        isLoading = false;\n@@ -220,1 +231,0 @@\n-                    return null;\n@@ -222,8 +232,1 @@\n-                try {\n-                    isLoading = true;\n-                    tries++;\n-                    p = doLoadProvider();\n-                } finally {\n-                    isLoading = false;\n-                }\n-            }\n+            };\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderConfig.java","additions":49,"deletions":46,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -653,2 +653,4 @@\n-            \/\/ The protocol version may have been negotiated.\n-            ProtocolVersion pv = conContext.handshakeContext.negotiatedProtocol;\n+            \/\/ The protocol version may have been negotiated.  The\n+            \/\/ conContext.handshakeContext.negotiatedProtocol is not used as there\n+            \/\/ may be a race to set it to null.\n+            ProtocolVersion pv = conContext.protocolVersion;\n@@ -1389,1 +1391,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import sun.security.action.GetIntegerAction;\n@@ -86,0 +87,6 @@\n+    \/\/ the maximum allowed size in bytes for the signature-related files\n+    public static final int MAX_SIG_FILE_SIZE = initializeMaxSigFileSize();\n+\n+    \/\/ The maximum size of array to allocate. Some VMs reserve some header words in an array.\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n+\n@@ -836,0 +843,20 @@\n+\n+    private static int initializeMaxSigFileSize() {\n+        \/*\n+         * System property \"jdk.jar.maxSignatureFileSize\" used to configure\n+         * the maximum allowed number of bytes for the signature-related files\n+         * in a JAR file.\n+         *\/\n+        Integer tmp = GetIntegerAction.privilegedGetProperty(\n+                \"jdk.jar.maxSignatureFileSize\", 8000000);\n+        if (tmp < 0 || tmp > MAX_ARRAY_SIZE) {\n+            if (debug != null) {\n+                debug.println(\"Default signature file size 8000000 bytes \" +\n+                        \"is used as the specified size for the \" +\n+                        \"jdk.jar.maxSignatureFileSize system property \" +\n+                        \"is out of range: \" + tmp);\n+            }\n+            tmp = 8000000;\n+        }\n+        return tmp;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -547,2 +547,2 @@\n-                    pn.equals(\"SunJCE\") || pn.equals(\"SunJSSE\"))) ||\n-                (mn.equals(\"jdk.crypto.ec\") && pn.equals(\"SunEC\")) ||\n+                    pn.equals(\"SunJCE\") || pn.equals(\"SunJSSE\") ||\n+                    pn.equals(\"SunEC\"))) ||\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,0 +94,1 @@\n+    @Override\n@@ -95,3 +96,3 @@\n-        if (that.getClass() != this.getClass()) return false;\n-\n-        IntHashtable other = (IntHashtable) that;\n+        if (!(that instanceof IntHashtable other)) {\n+            return false;\n+        }\n@@ -99,1 +100,1 @@\n-                return false;\n+            return false;\n@@ -109,0 +110,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/sun\/text\/IntHashtable.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+import java.util.Objects;\n+\n@@ -501,18 +503,3 @@\n-        try {\n-            if (that == null) {\n-                return false;\n-            }\n-\n-            RuleBasedBreakIterator other = (RuleBasedBreakIterator) that;\n-            if (checksum != other.checksum) {\n-                return false;\n-            }\n-            if (text == null) {\n-                return other.text == null;\n-            } else {\n-                return text.equals(other.text);\n-            }\n-        }\n-        catch(ClassCastException e) {\n-            return false;\n-        }\n+        return that instanceof RuleBasedBreakIterator other\n+                && checksum == other.checksum\n+                && Objects.equals(text, other.text);\n@@ -530,2 +517,1 @@\n-     * Compute a hashcode for this BreakIterator\n-     * @return A hash code\n+     * {@return hashcode for this BreakIterator}\n","filename":"src\/java.base\/share\/classes\/sun\/text\/RuleBasedBreakIterator.java","additions":7,"deletions":21,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -915,1 +915,2 @@\n-jdk.tls.keyLimits=AES\/GCM\/NoPadding KeyUpdate 2^37\n+jdk.tls.keyLimits=AES\/GCM\/NoPadding KeyUpdate 2^37, \\\n+                  ChaCha20-Poly1305 KeyUpdate 2^37\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,27 +0,0 @@\n-Owner: OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP\n-Issuer: OU=Security Communication RootCA1, O=SECOM Trust.net, C=JP\n-Serial number: 0\n-Valid from: Tue Sep 30 04:20:49 GMT 2003 until: Sat Sep 30 04:20:49 GMT 2023\n-Signature algorithm name: SHA1withRSA\n-Subject Public Key Algorithm: 2048-bit RSA key\n-Version: 3\n------BEGIN CERTIFICATE-----\n-MIIDWjCCAkKgAwIBAgIBADANBgkqhkiG9w0BAQUFADBQMQswCQYDVQQGEwJKUDEY\r\n-MBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYDVQQLEx5TZWN1cml0eSBDb21t\r\n-dW5pY2F0aW9uIFJvb3RDQTEwHhcNMDMwOTMwMDQyMDQ5WhcNMjMwOTMwMDQyMDQ5\r\n-WjBQMQswCQYDVQQGEwJKUDEYMBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYD\r\n-VQQLEx5TZWN1cml0eSBDb21tdW5pY2F0aW9uIFJvb3RDQTEwggEiMA0GCSqGSIb3\r\n-DQEBAQUAA4IBDwAwggEKAoIBAQCzs\/5\/022x7xZ8V6UMbXaKL0u\/ZPtM7orw8yl8\r\n-9f\/uKuDp6bpbZCKamm8sOiZpUQWZJtzVHGpxxpp9Hp3dfGzGjGdnSj74cbAZJ6kJ\r\n-DKaVv0uMDPpVmDvY6CKhS3E4eayXkmmziX7qIWgGmBSWh9JhNrxtJ1aeV+7AwFb9\r\n-Ms+k2Y7CI9eNqPPYJayX5HA49LY6tJ07lyZDo6G8SVlyTCMwhwFY9k6+HGhWZq\/N\r\n-QV3Is00qVUarH9oe4kA92819uZKAnDfdDJZkndwi92SL32HeFZRSFaB9UslLqCHJ\r\n-xrHty8OVYNEP8Ktw+N\/LTX7s1vqr2b1\/VPKl6Xn62dZ2JChzAgMBAAGjPzA9MB0G\r\n-A1UdDgQWBBSgc0mZaNyFW2XjmygvV5+9M7wHSDALBgNVHQ8EBAMCAQYwDwYDVR0T\r\n-AQH\/BAUwAwEB\/zANBgkqhkiG9w0BAQUFAAOCAQEAaECpqLvkT115swW1F7NgE+vG\r\n-kl3g0dNq\/vu+m22\/xwVtWSDEHPC32oRYAmP6SBbvT6UL90qY8j+eG61Ha2POCEfr\r\n-Uj94nK9NrvjVT8+amCoQQTlSxN3Zmw7vkwGusi7KaEIkQmywszo+zenaSMQVy+n5\r\n-Bw+SUEmK3TGXX8npN6o7WWWXlDLJs58+OmJYxUmtYg5xpTKqL8aJdkNAExNnPaJU\r\n-JRDL8Try2frbSVa7pv6nQTXD4IhhyYjH3zYQIphZ6rBK+1YWc26sTfcioU+tHXot\r\n-RSflMMFe8toTyyVCUZVHA4xsIcx0Qu1T\/zOLjw9XARYvz6buyXAiFL39vmwLAw==\n------END CERTIFICATE-----\n","filename":"src\/java.base\/share\/data\/cacerts\/secomscrootca1","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -130,9 +130,0 @@\n-grant codeBase \"jrt:\/jdk.crypto.ec\" {\n-    permission java.lang.RuntimePermission\n-                   \"accessClassInPackage.sun.security.*\";\n-    permission java.lang.RuntimePermission \"loadLibrary.sunec\";\n-    permission java.security.SecurityPermission \"putProviderProperty.SunEC\";\n-    permission java.security.SecurityPermission \"clearProviderProperties.SunEC\";\n-    permission java.security.SecurityPermission \"removeProviderProperty.SunEC\";\n-};\n-\n","filename":"src\/java.base\/share\/lib\/security\/default.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+    @Override\n@@ -52,0 +53,1 @@\n+    @Override\n@@ -55,8 +57,3 @@\n-        if (!(obj instanceof FileKey))\n-            return false;\n-        FileKey other = (FileKey)obj;\n-        if ((this.st_dev != other.st_dev) ||\n-            (this.st_ino != other.st_ino)) {\n-            return false;\n-        }\n-        return true;\n+        return obj instanceof FileKey other\n+                && (this.st_dev == other.st_dev)\n+                && (this.st_ino == other.st_ino);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileKey.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-#elif __linux__\n+#elif defined(__linux__)\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,4 +51,3 @@\n-        if (!(obj instanceof UnixFileKey))\n-            return false;\n-        UnixFileKey other = (UnixFileKey)obj;\n-        return (this.st_dev == other.st_dev) && (this.st_ino == other.st_ino);\n+        return obj instanceof UnixFileKey other\n+                && (this.st_dev == other.st_dev)\n+                && (this.st_ino == other.st_ino);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileKey.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,1 +237,1 @@\n-        if (!(ob instanceof UnixFileStore))\n+        if (!(ob instanceof UnixFileStore other))\n@@ -239,1 +239,0 @@\n-        UnixFileStore other = (UnixFileStore)ob;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileStore.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Arrays;\n@@ -44,0 +45,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -709,8 +711,1 @@\n-        if ((thatLen - thatPos) != (thisLen - thisPos))\n-            return false;\n-        while (thatPos < thatLen) {\n-            if (this.path[thisPos++] != that.path[thatPos++])\n-                return false;\n-        }\n-\n-        return true;\n+        return Arrays.equals(this.path, thisPos, thisLen, that.path, thatPos, thatLen);\n@@ -721,17 +716,1 @@\n-        int len1 = path.length;\n-        int len2 = ((UnixPath) other).path.length;\n-\n-        int n = Math.min(len1, len2);\n-        byte v1[] = path;\n-        byte v2[] = ((UnixPath) other).path;\n-\n-        int k = 0;\n-        while (k < n) {\n-            int c1 = v1[k] & 0xff;\n-            int c2 = v2[k] & 0xff;\n-            if (c1 != c2) {\n-                return c1 - c2;\n-            }\n-           k++;\n-        }\n-        return len1 - len2;\n+        return Arrays.compareUnsigned(path, ((UnixPath) other).path);\n@@ -742,4 +721,1 @@\n-        if (ob instanceof UnixPath path) {\n-            return compareTo(path) == 0;\n-        }\n-        return false;\n+        return ob instanceof UnixPath p && compareTo(p) == 0;\n@@ -753,3 +729,2 @@\n-            for (int i = 0; i< path.length; i++) {\n-                h = 31*h + (path[i] & 0xff);\n-            }\n+            h = ArraysSupport.vectorizedHashCode(path, 0, path.length, 0,\n+                    \/* unsigned bytes *\/ ArraysSupport.T_BOOLEAN);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":7,"deletions":32,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -78,4 +78,0 @@\n-            if ((c == '\/') && (pos < len) && (p.charAt(pos) == '\/')) {\n-                \/\/ skip redundant slashes\n-                continue;\n-            }\n@@ -95,0 +91,4 @@\n+            if (b == '\/' && rlen > 0 && result[rlen-1] == '\/') {\n+                \/\/ skip redundant slashes\n+                continue;\n+            }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUriUtils.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-            if (!(obj instanceof User))\n+            if (!(obj instanceof User other))\n@@ -86,1 +86,0 @@\n-            User other = (User)obj;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserPrincipals.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-Java_java_io_FileDescriptor_sync(JNIEnv *env, jobject this) {\n+Java_java_io_FileDescriptor_sync0(JNIEnv *env, jobject this) {\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+    @Override\n@@ -51,1 +52,1 @@\n-               (int)(nFileIndexLow ^ (nFileIndexHigh >>> 32));\n+               (int)(nFileIndexLow ^ (nFileIndexLow >>> 32));\n@@ -54,0 +55,1 @@\n+    @Override\n@@ -57,9 +59,4 @@\n-        if (!(obj instanceof FileKey))\n-            return false;\n-        FileKey other = (FileKey)obj;\n-        if ((this.dwVolumeSerialNumber != other.dwVolumeSerialNumber) ||\n-            (this.nFileIndexHigh != other.nFileIndexHigh) ||\n-            (this.nFileIndexLow != other.nFileIndexLow)) {\n-            return false;\n-        }\n-        return true;\n+        return obj instanceof FileKey other\n+                && this.dwVolumeSerialNumber == other.dwVolumeSerialNumber\n+                && this.nFileIndexHigh == other.nFileIndexHigh\n+                && this.nFileIndexLow == other.nFileIndexLow;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileKey.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -815,4 +815,1 @@\n-        if (obj instanceof WindowsPath path) {\n-            return compareTo(path) == 0;\n-        }\n-        return false;\n+        return obj instanceof WindowsPath other && compareTo(other) == 0;\n@@ -826,1 +823,1 @@\n-            for (int i = 0; i< path.length(); i++) {\n+            for (int i = 0; i < path.length(); i++) {\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsPath.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,4 +83,2 @@\n-            if (!(obj instanceof WindowsUserPrincipals.User))\n-                return false;\n-            WindowsUserPrincipals.User other = (WindowsUserPrincipals.User)obj;\n-            return this.sidString.equals(other.sidString);\n+            return obj instanceof WindowsUserPrincipals.User other\n+                    && this.sidString.equals(other.sidString);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsUserPrincipals.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,6 +234,4 @@\n-            if (!(obj instanceof FileKey))\n-                return false;\n-            FileKey other = (FileKey)obj;\n-            if (this.volSerialNumber != other.volSerialNumber) return false;\n-            if (this.fileIndexHigh != other.fileIndexHigh) return false;\n-            return this.fileIndexLow == other.fileIndexLow;\n+            return obj instanceof FileKey other\n+                    && this.volSerialNumber == other.volSerialNumber\n+                    && this.fileIndexHigh == other.fileIndexHigh\n+                    && this.fileIndexLow == other.fileIndexLow;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsWatchService.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-Java_java_io_FileDescriptor_sync(JNIEnv *env, jobject this) {\n+Java_java_io_FileDescriptor_sync0(JNIEnv *env, jobject this) {\n","filename":"src\/java.base\/windows\/native\/libjava\/FileDescriptor_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,8 +58,9 @@\n-        buffer.bufPtr += ID_SIZE; \/\/ Skip the id\n-        version = (buffer.buf[buffer.bufPtr++] & 0xff) << 8;\n-        version |= buffer.buf[buffer.bufPtr++] & 0xff;\n-        flags0 = (buffer.buf[buffer.bufPtr++] & 0xff) << 8;\n-        flags0 |= buffer.buf[buffer.bufPtr++] & 0xff;\n-        flags1 = (buffer.buf[buffer.bufPtr++] & 0xff) << 8;\n-        flags1 |= buffer.buf[buffer.bufPtr++] & 0xff;\n-        transform = buffer.buf[buffer.bufPtr++] & 0xff;\n+        int markPtr = buffer.bufPtr;\n+        markPtr += ID_SIZE; \/\/ Skip the id\n+        version = (buffer.buf[markPtr++] & 0xff) << 8;\n+        version |= buffer.buf[markPtr++] & 0xff;\n+        flags0 = (buffer.buf[markPtr++] & 0xff) << 8;\n+        flags0 |= buffer.buf[markPtr++] & 0xff;\n+        flags1 = (buffer.buf[markPtr++] & 0xff) << 8;\n+        flags1 |= buffer.buf[markPtr++] & 0xff;\n+        transform = buffer.buf[markPtr++] & 0xff;\n@@ -67,0 +68,1 @@\n+        buffer.bufPtr += length;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/AdobeMarkerSegment.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-     * @param  s the specified detail message\n+     * @param  message the specified detail message, or {@code null}\n@@ -56,2 +56,2 @@\n-    public CMMException(String s) {\n-        super(s);\n+    public CMMException(String message) {\n+        super(message);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/CMMException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -308,0 +308,2 @@\n+     * @throws IllegalArgumentException if {@code cspace} is not one of the\n+     *         predefined color space types\n@@ -353,0 +355,1 @@\n+     * @throws NullPointerException if {@code colorvalue} is {@code null}\n@@ -374,0 +377,1 @@\n+     * @throws NullPointerException if {@code rgbvalue} is {@code null}\n@@ -398,1 +402,2 @@\n-     *         the number of components in this {@code ColorSpace}.\n+     *         the number of components in this {@code ColorSpace}\n+     * @throws NullPointerException if {@code colorvalue} is {@code null}\n@@ -424,0 +429,1 @@\n+     * @throws NullPointerException if {@code colorvalue} is {@code null}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ColorSpace.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,1 @@\n+     * @throws NullPointerException if {@code profile} is {@code null}\n@@ -160,0 +161,1 @@\n+     * @throws NullPointerException if {@code s} is {@code null}\n@@ -198,0 +200,1 @@\n+     * @throws NullPointerException if {@code colorvalue} is {@code null}\n@@ -246,0 +249,1 @@\n+     * @throws NullPointerException if {@code rgbvalue} is {@code null}\n@@ -374,0 +378,1 @@\n+     * @throws NullPointerException if {@code colorvalue} is {@code null}\n@@ -505,0 +510,1 @@\n+     * @throws NullPointerException if {@code colorvalue} is {@code null}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ColorSpace.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -821,2 +821,1 @@\n-     * {@code CS_sRGB}). Throws an {@code IllegalArgumentException} if cspace is\n-     * not one of the defined color spaces.\n+     * {@code CS_sRGB}).\n@@ -1415,0 +1414,1 @@\n+     * @throws NullPointerException if {@code s} is {@code null}\n@@ -1470,2 +1470,2 @@\n-     * @throws ClassNotFoundException thrown by {@code\n-     *         ObjectInputStream}\n+     * @throws ClassNotFoundException thrown by {@code ObjectInputStream}\n+     * @throws NullPointerException if {@code s} is {@code null}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-     * @param  s the specified detail message\n+     * @param  message the specified detail message, or {@code null}\n@@ -48,2 +48,2 @@\n-    public ProfileDataException(String s) {\n-        super(s);\n+    public ProfileDataException(String message) {\n+        super(message);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ProfileDataException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n-#if defined(__linux__) && !defined(MAP_FAILED)\n-#define MAP_FAILED ((caddr_t)-1)\n-#endif\n-\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/fontpath.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.awt.Dimension;\n@@ -178,1 +177,1 @@\n-        private Part part;\n+        private final Part part;\n@@ -289,7 +288,2 @@\n-                \/\/ Assume for now that height is correct and derive width using the\n-                \/\/ ratio from the uxtheme part\n-                width = UIManager.getInt(\"InternalFrame.titleButtonHeight\") -2;\n-                Dimension d = XPStyle.getPartSize(Part.WP_CLOSEBUTTON, State.NORMAL);\n-                if (d != null && d.width != 0 && d.height != 0) {\n-                    width = (int) ((float) width * d.width \/ d.height);\n-                }\n+                \/\/ Assume for now that height is correct and derive width from height\n+                width = UIManager.getInt(\"InternalFrame.titleButtonHeight\") + 10;\n@@ -297,4 +291,1 @@\n-                width = UIManager.getInt(\"InternalFrame.titleButtonWidth\") -2;\n-            }\n-            if (XPStyle.getXP() != null) {\n-                width -= 2;\n+                width = UIManager.getInt(\"InternalFrame.titleButtonHeight\") - 2;\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsIconFactory.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,9 +28,16 @@\n-import sun.swing.SwingUtilities2;\n-\n-import javax.swing.*;\n-import javax.swing.border.*;\n-import javax.swing.UIManager;\n-import javax.swing.plaf.*;\n-import javax.swing.plaf.basic.BasicInternalFrameTitlePane;\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.Paint;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n@@ -41,1 +48,20 @@\n-import static com.sun.java.swing.plaf.windows.TMSchema.*;\n+import javax.swing.BorderFactory;\n+import javax.swing.Icon;\n+import javax.swing.JComponent;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+import javax.swing.JSeparator;\n+import javax.swing.LookAndFeel;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.border.Border;\n+import javax.swing.plaf.UIResource;\n+import javax.swing.plaf.basic.BasicInternalFrameTitlePane;\n+\n+import sun.swing.SwingUtilities2;\n+\n+import static com.sun.java.swing.plaf.windows.TMSchema.Part;\n+import static com.sun.java.swing.plaf.windows.TMSchema.Prop;\n+import static com.sun.java.swing.plaf.windows.TMSchema.State;\n@@ -71,1 +97,0 @@\n-        buttonWidth     = UIManager.getInt(\"InternalFrame.titleButtonWidth\")  - 4;\n@@ -80,7 +105,2 @@\n-            \/\/ Assume for now that height is correct and derive width using the\n-            \/\/ ratio from the uxtheme part\n-            buttonWidth = buttonHeight;\n-            Dimension d = XPStyle.getPartSize(Part.WP_CLOSEBUTTON, State.NORMAL);\n-            if (d != null && d.width != 0 && d.height != 0) {\n-                buttonWidth = (int) ((float) buttonWidth * d.width \/ d.height);\n-            }\n+            \/\/ Assume for now that height is correct and derive width from height\n+            buttonWidth = buttonHeight + 14;\n@@ -88,1 +108,1 @@\n-            buttonWidth += 2;\n+            buttonWidth = buttonHeight + 2;\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsInternalFrameTitlePane.java","additions":40,"deletions":20,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include <cmath>\n@@ -27,1 +28,0 @@\n-#include <math.h>\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DTextRenderer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <cmath>\n+\n@@ -30,2 +32,0 @@\n-#include \"math.h\"\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DVertexCacher.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <cmath>                \/* for cos(), sin(), etc *\/\n+\n@@ -38,2 +40,0 @@\n-#include <math.h>                \/* for cos(), sin(), etc *\/\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/windows\/GDIRenderer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <cmath>\n+\n@@ -31,2 +33,0 @@\n-#include \"math.h\"\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/ThemeReader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,6 +43,0 @@\n-\/\/ Disable \"C++ Exception Specification ignored\" warnings.\n-\/\/ These warnings are generated because VC++ 5.0 allows, but does not enforce,\n-\/\/ exception specifications. This #pragma can be safely removed when VC++\n-\/\/ is updated to enforce exception specifications.\n-#pragma warning(disable : 4290)\n-\n@@ -91,3 +85,3 @@\n-void *safe_Malloc(size_t size) throw (std::bad_alloc);\n-void *safe_Calloc(size_t num, size_t size) throw (std::bad_alloc);\n-void *safe_Realloc(void *memblock, size_t size) throw (std::bad_alloc);\n+void *safe_Malloc(size_t size);\n+void *safe_Calloc(size_t num, size_t size);\n+void *safe_Realloc(void *memblock, size_t size);\n@@ -98,1 +92,1 @@\n-jthrowable safe_ExceptionOccurred(JNIEnv *env) throw (std::bad_alloc);\n+jthrowable safe_ExceptionOccurred(JNIEnv *env);\n@@ -114,1 +108,1 @@\n-void throw_if_shutdown(void) throw (awt_toolkit_shutdown);\n+void throw_if_shutdown(void);\n@@ -123,8 +117,4 @@\n-    void *safe_Malloc_outofmem(size_t size, const char *, int)\n-        throw (std::bad_alloc);\n-    void *safe_Calloc_outofmem(size_t num, size_t size, const char *, int)\n-        throw (std::bad_alloc);\n-    void *safe_Realloc_outofmem(void *memblock, size_t size, const char *, int)\n-        throw (std::bad_alloc);\n-    void * CDECL operator new(size_t size, const char *, int)\n-        throw (std::bad_alloc);\n+    void *safe_Malloc_outofmem(size_t size, const char *, int);\n+    void *safe_Calloc_outofmem(size_t num, size_t size, const char *, int);\n+    void *safe_Realloc_outofmem(void *memblock, size_t size, const char *, int);\n+    void * CDECL operator new(size_t size, const char *, int);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/alloc.h","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <cmath>\n+\n@@ -50,1 +52,0 @@\n-#include \"math.h\"\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <cmath>\n+\n@@ -38,2 +40,0 @@\n-#include \"math.h\"\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DesktopProperties.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include <cmath>\n@@ -27,1 +28,0 @@\n-#include <math.h>\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Font.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include <cmath>\n+#include <cfloat>\n@@ -31,2 +33,0 @@\n-#include <float.h>\n-#include <math.h>\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintControl.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include <cmath>\n@@ -28,1 +29,0 @@\n-#include <math.h>\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1991,1 +1991,1 @@\n-void throw_if_shutdown(void) throw (awt_toolkit_shutdown)\n+void throw_if_shutdown(void)\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-    INLINE void VerifyActive() throw (awt_toolkit_shutdown) {\n+    INLINE void VerifyActive() {\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include <cmath> \/\/ ceil()\n@@ -41,1 +42,0 @@\n-#include <sun_awt_Win32GraphicsDevice.h>\n@@ -49,1 +49,0 @@\n-#include \"dither.h\"\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include <cmath>\n@@ -48,1 +49,0 @@\n-#include <math.h>\n@@ -50,1 +50,1 @@\n-typedef __int32 LONG_PTR;\n+typedef int32_t LONG_PTR;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,3 +84,3 @@\n-void *safe_Malloc(size_t size) throw (std::bad_alloc) {\n-    register void *ret_val = malloc(size);\n-    if (ret_val == NULL) {\n+void *safe_Malloc(size_t size) {\n+    void *ptr = malloc(size);\n+    if (ptr == nullptr) {\n@@ -90,1 +90,1 @@\n-    return ret_val;\n+    return ptr;\n@@ -93,3 +93,3 @@\n-void *safe_Calloc(size_t num, size_t size) throw (std::bad_alloc) {\n-    register void *ret_val = calloc(num, size);\n-    if (ret_val == NULL) {\n+void *safe_Calloc(size_t num, size_t size) {\n+    void *ptr = calloc(num, size);\n+    if (ptr == nullptr) {\n@@ -99,1 +99,1 @@\n-    return ret_val;\n+    return ptr;\n@@ -102,2 +102,2 @@\n-void *safe_Realloc(void *memblock, size_t size) throw (std::bad_alloc) {\n-    register void *ret_val = realloc(memblock, size);\n+void *safe_Realloc(void *memblock, size_t size) {\n+    void *ptr = realloc(memblock, size);\n@@ -106,2 +106,2 @@\n-    if (memblock != NULL && size == 0) {\n-        return ret_val; \/\/ even if it's NULL\n+    if (memblock != nullptr && size == 0) {\n+        return ptr; \/\/ even if it's NULL\n@@ -110,1 +110,1 @@\n-    if (ret_val == NULL) {\n+    if (ptr == nullptr) {\n@@ -114,1 +114,1 @@\n-    return ret_val;\n+    return ptr;\n@@ -123,1 +123,1 @@\n-void * CDECL operator new(size_t size) throw (std::bad_alloc) {\n+void * CDECL operator new(size_t size) {\n@@ -163,1 +163,1 @@\n-safe_ExceptionOccurred(JNIEnv *env) throw (std::bad_alloc) {\n+safe_ExceptionOccurred(JNIEnv *env) {\n@@ -191,2 +191,1 @@\n-rand_alloc_fail(const char *file, int line) throw (std::bad_alloc)\n-{\n+rand_alloc_fail(const char *file, int line) {\n@@ -216,3 +215,1 @@\n-void *safe_Malloc_outofmem(size_t size, const char *file, int line)\n-    throw (std::bad_alloc)\n-{\n+void *safe_Malloc_outofmem(size_t size, const char *file, int line) {\n@@ -223,3 +220,1 @@\n-void *safe_Calloc_outofmem(size_t num, size_t size, const char *file, int line)\n-    throw (std::bad_alloc)\n-{\n+void *safe_Calloc_outofmem(size_t num, size_t size, const char *file, int line) {\n@@ -231,3 +226,1 @@\n-                            int line)\n-    throw (std::bad_alloc)\n-{\n+                            int line) {\n@@ -238,3 +231,1 @@\n-void * CDECL operator new(size_t size, const char *file, int line)\n-    throw (std::bad_alloc)\n-{\n+void * CDECL operator new(size_t size, const char *file, int line) {\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_new.cpp","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.Set;\n@@ -232,1 +233,1 @@\n-        static final Pattern FILENAME = Pattern.compile(\"filename\\\\s*=\", CASE_INSENSITIVE);\n+        static final Pattern FILENAME = Pattern.compile(\"filename\\\\s*=\\\\s*\", CASE_INSENSITIVE);\n@@ -236,0 +237,15 @@\n+        \/\/ Characters disallowed in token values\n+\n+        static final Set<Character> NOT_ALLOWED_IN_TOKEN = Set.of(\n+            '(', ')', '<', '>', '@',\n+            ',', ';', ':', '\\\\', '\"',\n+            '\/', '[', ']', '?', '=',\n+            '{', '}', ' ', '\\t');\n+\n+        static boolean allowedInToken(char c) {\n+            if (NOT_ALLOWED_IN_TOKEN.contains(c))\n+                return false;\n+            \/\/ exclude CTL chars <= 31, == 127, or anything >= 128\n+            return isTokenText(c);\n+        }\n+\n@@ -242,0 +258,89 @@\n+        static final UncheckedIOException unchecked(String msg) {\n+            return new UncheckedIOException(new IOException(msg));\n+        }\n+\n+        \/\/ Process a \"filename=\" parameter, which is either a \"token\"\n+        \/\/ or a \"quoted string\". If a token, it is terminated by a\n+        \/\/ semicolon or the end of the string.\n+        \/\/ If a quoted string (surrounded by \"\" chars then the closing \"\n+        \/\/ terminates the name.\n+        \/\/ quoted strings may contain quoted-pairs (eg embedded \" chars)\n+\n+        static String processFilename(String src) throws UncheckedIOException {\n+            if (\"\".equals(src))\n+                return src;\n+            if (src.charAt(0) == '\\\"') {\n+                return processQuotedString(src.substring(1));\n+            } else {\n+                return processToken(src);\n+            }\n+        }\n+\n+        static boolean isTokenText(char c) throws UncheckedIOException {\n+            return c > 31 && c < 127;\n+        }\n+\n+        static boolean isQuotedStringText(char c) throws UncheckedIOException {\n+            return c > 31;\n+        }\n+\n+        static String processQuotedString(String src) throws UncheckedIOException {\n+            boolean inqpair = false;\n+            int len = src.length();\n+            StringBuilder sb = new StringBuilder();\n+\n+            for (int i=0; i<len; i++) {\n+                char c = src.charAt(i);\n+                if (!isQuotedStringText(c)) {\n+                    throw unchecked(\"Illegal character\");\n+                }\n+                if (c == '\\\"') {\n+                    if (!inqpair) {\n+                        return sb.toString();\n+                    } else {\n+                        sb.append(c);\n+                    }\n+                } else if (c == '\\\\') {\n+                    if (!inqpair) {\n+                        inqpair = true;\n+                        continue;\n+                    } else {\n+                        \/\/ the quoted char is '\\'\n+                        sb.append(c);\n+                    }\n+                } else {\n+                    sb.append(c);\n+                }\n+                if (inqpair) {\n+                    inqpair = false;\n+                }\n+            }\n+            \/\/ not terminated by \"\n+            throw unchecked(\"Invalid quoted string\");\n+        }\n+\n+        static String processToken(String src) throws UncheckedIOException {\n+            int end = 0;\n+            int len = src.length();\n+            boolean whitespace = false;\n+\n+            for (int i=0; i<len; i++) {\n+                char c = src.charAt(i);\n+                if (c == ';') {\n+                    break;\n+                }\n+                if (c == ' ' || c == '\\t') {\n+                    \/\/ WS only until ; or end of string\n+                    whitespace = true;\n+                    continue;\n+                }\n+                end++;\n+                if (whitespace || !allowedInToken(c)) {\n+                    String msg = whitespace ? \"whitespace must be followed by a semicolon\"\n+                                            : c + \" is not allowed in a token\";\n+                    throw unchecked(msg);\n+                }\n+            }\n+            return src.substring(0, end);\n+        }\n+\n@@ -259,7 +364,1 @@\n-            int semi = dispoHeader.substring(n).indexOf(\";\");\n-            String filenameParam;\n-            if (semi < 0) {\n-                filenameParam = dispoHeader.substring(n);\n-            } else {\n-                filenameParam = dispoHeader.substring(n, n + semi);\n-            }\n+            String filenameParam = processFilename(dispoHeader.substring(n));\n@@ -279,13 +378,0 @@\n-            if (filenameParam.startsWith(\"\\\"\")) {  \/\/ quoted-string\n-                if (!filenameParam.endsWith(\"\\\"\") || filenameParam.length() == 1) {\n-                    throw unchecked(responseInfo,\n-                            \"Badly quoted Content-Disposition filename parameter\");\n-                }\n-                filenameParam = filenameParam.substring(1, filenameParam.length() -1 );\n-            } else {  \/\/ token,\n-                if (filenameParam.contains(\" \")) {  \/\/ space disallowed\n-                    throw unchecked(responseInfo,\n-                            \"unquoted space in Content-Disposition filename parameter\");\n-                }\n-            }\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseBodyHandlers.java","additions":107,"deletions":21,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Type.WildcardType;\n@@ -69,1 +68,0 @@\n-import com.sun.tools.javac.util.Options;\n@@ -249,1 +247,1 @@\n-    public final Type nonAtomicType;\n+    public final Type looselyConsistentValueType;\n@@ -648,1 +646,1 @@\n-        nonAtomicType = enterClass(\"java.lang.NonAtomic\");\n+        looselyConsistentValueType = enterClass(\"java.lang.LooselyConsistentValue\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1776,0 +1776,2 @@\n+                                    } else if (!constants.add(enumSym)) {\n+                                        log.error(label.pos(), Errors.DuplicateCaseLabel);\n@@ -1807,0 +1809,2 @@\n+                                    } else if (!constants.add(s)) {\n+                                        log.error(label.pos(), Errors.DuplicateCaseLabel);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2803,1 +2803,1 @@\n-        boolean implementsNonAtomic = false;\n+        boolean implementsLooselyConsistentValue = false;\n@@ -2805,1 +2805,1 @@\n-            implementsNonAtomic = allowValueClasses ? types.asSuper(c, syms.nonAtomicType.tsym) != null : false;\n+            implementsLooselyConsistentValue = allowValueClasses ? types.asSuper(c, syms.looselyConsistentValueType.tsym) != null : false;\n@@ -2811,1 +2811,1 @@\n-        if (c.getKind() == TypeKind.DECLARED && implementsNonAtomic && !c.tsym.isAbstract()) {\n+        if (c.getKind() == TypeKind.DECLARED && implementsLooselyConsistentValue && !c.tsym.isAbstract()) {\n@@ -2813,1 +2813,1 @@\n-                log.error(pos, Errors.CantImplementNonAtomic(c.tsym));\n+                log.error(pos, Errors.CantImplementInterface(c.tsym));\n@@ -5027,2 +5027,4 @@\n-            if (currentPattern instanceof JCBindingPattern) {\n-                return existingPattern instanceof JCBindingPattern;\n+            if (currentPattern instanceof JCBindingPattern ||\n+                currentPattern instanceof JCAnyPattern) {\n+                return existingPattern instanceof JCBindingPattern ||\n+                       existingPattern instanceof JCAnyPattern;\n@@ -5030,1 +5032,2 @@\n-                if (existingPattern instanceof JCBindingPattern) {\n+                if (existingPattern instanceof JCBindingPattern ||\n+                    existingPattern instanceof JCAnyPattern) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -778,1 +778,1 @@\n-            List<PatternDescription> patterns = List.from(patternSet);\n+            Set<PatternDescription> patterns = patternSet;\n@@ -782,1 +782,1 @@\n-                    List<PatternDescription> updatedPatterns;\n+                    Set<PatternDescription> updatedPatterns;\n@@ -786,1 +786,2 @@\n-                    repeat = updatedPatterns != patterns;\n+                    updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                    repeat = !updatedPatterns.equals(patterns);\n@@ -799,1 +800,1 @@\n-        private boolean checkCovered(Type seltype, List<PatternDescription> patterns) {\n+        private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n@@ -835,1 +836,1 @@\n-        private List<PatternDescription> reduceBindingPatterns(Type selectorType, List<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n@@ -843,1 +844,0 @@\n-                    Set<PatternDescription> toRemove = new HashSet<>();\n@@ -849,0 +849,2 @@\n+                        clazz.complete();\n+\n@@ -874,1 +876,0 @@\n-                                    boolean reduces = false;\n@@ -891,1 +892,0 @@\n-                                            reduces = true;\n@@ -894,4 +894,0 @@\n-\n-                                    if (reduces) {\n-                                        bindings.append(pdOther);\n-                                    }\n@@ -902,1 +898,0 @@\n-                                toRemove.addAll(bindings);\n@@ -908,8 +903,4 @@\n-                    if (!toAdd.isEmpty() || !toRemove.isEmpty()) {\n-                        for (PatternDescription pd : toRemove) {\n-                            patterns = List.filter(patterns, pd);\n-                        }\n-                        for (PatternDescription pd : toAdd) {\n-                            patterns = patterns.prepend(pd);\n-                        }\n-                        return patterns;\n+                    if (!toAdd.isEmpty()) {\n+                        Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n+                        newPatterns.addAll(toAdd);\n+                        return newPatterns;\n@@ -931,0 +922,2 @@\n+                current.complete();\n+\n@@ -957,1 +950,1 @@\n-        private List<PatternDescription> reduceNestedPatterns(List<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns) {\n@@ -976,0 +969,1 @@\n+                Set<RecordPattern> current = new HashSet<>(e.getValue());\n@@ -982,1 +976,1 @@\n-                            e.getValue()\n+                            current\n@@ -1017,1 +1011,1 @@\n-                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(List.collector());\n+                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n@@ -1021,0 +1015,1 @@\n+                            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n@@ -1023,11 +1018,2 @@\n-                            if (nestedPatterns != updatedPatterns) {\n-                                ListBuffer<PatternDescription> result = new ListBuffer<>();\n-                                Set<PatternDescription> toRemove = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-                                toRemove.addAll(join);\n-\n-                                for (PatternDescription p : patterns) {\n-                                    if (!toRemove.contains(p)) {\n-                                        result.append(p);\n-                                    }\n-                                }\n+                            if (!nestedPatterns.equals(updatedPatterns)) {\n+                                current.removeAll(join);\n@@ -1039,1 +1025,1 @@\n-                                    result.append(new RecordPattern(rpOne.recordType(),\n+                                    current.add(new RecordPattern(rpOne.recordType(),\n@@ -1043,1 +1029,0 @@\n-                                return result.toList();\n@@ -1048,0 +1033,7 @@\n+\n+                if (!current.equals(new HashSet<>(e.getValue()))) {\n+                    Set<PatternDescription> result = new HashSet<>(patterns);\n+                    result.removeAll(e.getValue());\n+                    result.addAll(current);\n+                    return result;\n+                }\n@@ -1057,2 +1049,2 @@\n-        private List<PatternDescription> reduceRecordPatterns(List<PatternDescription> patterns) {\n-            var newPatterns = new ListBuffer<PatternDescription>();\n+        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n+            var newPatterns = new HashSet<PatternDescription>();\n@@ -1064,1 +1056,1 @@\n-                        newPatterns.append(reducedPattern);\n+                        newPatterns.add(reducedPattern);\n@@ -1069,1 +1061,1 @@\n-                newPatterns.append(pd);\n+                newPatterns.add(pd);\n@@ -1071,2 +1063,2 @@\n-            return modified ? newPatterns.toList() : patterns;\n-                }\n+            return modified ? newPatterns : patterns;\n+        }\n@@ -1104,0 +1096,17 @@\n+        private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n+            Set<Symbol> existingBindings = patterns.stream()\n+                                                   .filter(pd -> pd instanceof BindingPattern)\n+                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                                   .collect(Collectors.toSet());\n+            Set<PatternDescription> result = new HashSet<>(patterns);\n+\n+            for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n+                PatternDescription pd = it.next();\n+                if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n+                    it.remove();\n+                }\n+            }\n+\n+            return result;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":52,"deletions":43,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-import com.sun.tools.javac.code.Scope.WriteableScope;\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -965,1 +963,1 @@\n-            int flags = ACC_DEFAULT | (csym.isSubClass(syms.nonAtomicType.tsym, types) ? ACC_NON_ATOMIC : 0);\n+            int flags = ACC_DEFAULT | (csym.isSubClass(syms.looselyConsistentValueType.tsym, types) ? ACC_NON_ATOMIC : 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1549,1 +1549,4 @@\n-                skip('*');\n+                if (skip('*') != 0 && is('\/')) {\n+                    return ;\n+                }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -915,0 +915,1 @@\n+            checkSourceLevel(Feature.UNNAMED_VARIABLES);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4138,2 +4138,2 @@\n-compiler.err.cant.implement.non.atomic=\\\n-    class {0} cannot implement NonAtomic interface. Concrete classes implementing this interface must:\\n\\\n+compiler.err.cant.implement.interface=\\\n+    class {0} cannot implement LooselyConsistentValue interface. Concrete classes implementing this interface must:\\n\\\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,0 @@\n-    \/\/ Depends on SunEC provider for EC related functionality\n-    requires jdk.crypto.ec;\n-\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+@Deprecated(since=\"22\", forRemoval = true)\n@@ -35,1 +36,0 @@\n-    provides java.security.Provider with sun.security.ec.SunEC;\n","filename":"src\/jdk.crypto.ec\/share\/classes\/module-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.oops;\n+\n+import java.io.*;\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.interpreter.Bytecodes;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.*;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+\/\/ An Annotation is an oop containing annotations as described in the class file\n+\n+public class Annotations extends Metadata {\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private ArrayOfU1Array fieldAnnotationsArray;\n+  private ArrayOfU1Array fieldTypeAnnotationsArray;\n+\n+  public Annotations(Address addr) {\n+    super(addr);\n+  }\n+\n+  public boolean isAnnotations()            { return true; }\n+\n+  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+    Type type = db.lookupType(\"Annotations\");\n+    classAnnotations = type.getAddressField(\"_class_annotations\");\n+    fieldsAnnotations = type.getAddressField(\"_fields_annotations\");\n+    classTypeAnnotations = type.getAddressField(\"_class_type_annotations\");\n+    fieldsTypeAnnotations = type.getAddressField(\"_fields_type_annotations\");\n+  }\n+\n+  private static AddressField classAnnotations;\n+  private static AddressField fieldsAnnotations;\n+  private static AddressField classTypeAnnotations;\n+  private static AddressField fieldsTypeAnnotations;\n+\n+  public U1Array getClassAnnotations() {\n+    Address addr = classAnnotations.getValue(getAddress());\n+    return VMObjectFactory.newObject(U1Array.class, addr);\n+  }\n+\n+  public U1Array getFieldAnnotations(int fieldIndex) {\n+    if (fieldAnnotationsArray == null) {\n+      Address addr = fieldsAnnotations.getValue(getAddress());\n+      fieldAnnotationsArray = VMObjectFactory.newObject(ArrayOfU1Array.class, addr);\n+    }\n+    if (fieldAnnotationsArray != null) {\n+      Address addr = fieldAnnotationsArray.at(fieldIndex);\n+      return VMObjectFactory.newObject(U1Array.class, addr);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public U1Array getClassTypeAnnotations() {\n+    Address addr = classTypeAnnotations.getValue(getAddress());\n+    return VMObjectFactory.newObject(U1Array.class, addr);\n+  }\n+\n+  public U1Array getFieldTypeAnnotations(int fieldIndex) {\n+    if (fieldTypeAnnotationsArray == null) {\n+      Address addr = fieldsTypeAnnotations.getValue(getAddress());\n+      fieldTypeAnnotationsArray = VMObjectFactory.newObject(ArrayOfU1Array.class, addr);\n+    }\n+    if (fieldTypeAnnotationsArray != null) {\n+      Address addr = fieldTypeAnnotationsArray.at(fieldIndex);\n+      return VMObjectFactory.newObject(U1Array.class, addr);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public void printValueOn(PrintStream tty) {\n+      tty.print(\"Annotations\" + \"@\" + getAddress());\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Annotations.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -61,2 +61,2 @@\n-    baseField = type.getAddressField(\"_narrow_klass._base\");\n-    shiftField = type.getCIntegerField(\"_narrow_klass._shift\");\n+    baseField = type.getAddressField(\"_base\");\n+    shiftField = type.getCIntegerField(\"_shift\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/CompressedKlassPointers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -420,10 +420,7 @@\n-  private boolean hasMethodParameters() {\n-    return (getFlags() & HAS_METHOD_PARAMETERS) != 0;\n-  }\n-\n-  private boolean hasGenericSignature() {\n-    return (getFlags() & HAS_GENERIC_SIGNATURE) != 0;\n-  }\n-\n-  private boolean hasMethodAnnotations() {\n-    return (getFlags() & HAS_METHOD_ANNOTATIONS) != 0;\n+  public U1Array getMethodAnnotations() {\n+    if (hasMethodAnnotations()) {\n+      Address addr = getAddressAtOffset(getSize() - getMethodAnnotationsOffset());\n+      return VMObjectFactory.newObject(U1Array.class, addr);\n+    } else {\n+      return null;\n+    }\n@@ -432,2 +429,7 @@\n-  private boolean hasParameterAnnotations() {\n-    return (getFlags() & HAS_PARAMETER_ANNOTATIONS) != 0;\n+  public U1Array getParameterAnnotations() {\n+    if (hasParameterAnnotations()) {\n+      Address addr = getAddressAtOffset(getSize() - getParameterAnnotationsOffset());\n+      return VMObjectFactory.newObject(U1Array.class, addr);\n+    } else {\n+      return null;\n+    }\n@@ -436,2 +438,7 @@\n-  private boolean hasDefaultAnnotations() {\n-    return (getFlags() & HAS_DEFAULT_ANNOTATIONS) != 0;\n+  public U1Array getTypeAnnotations() {\n+    if (hasTypeAnnotations()) {\n+      Address addr = getAddressAtOffset(getSize() - getTypeAnnotationsOffset());\n+      return VMObjectFactory.newObject(U1Array.class, addr);\n+    } else {\n+      return null;\n+    }\n@@ -440,2 +447,7 @@\n-  private boolean hasTypeAnnotations() {\n-    return (getFlags() & HAS_TYPE_ANNOTATIONS) != 0;\n+  public U1Array getDefaultAnnotations() {\n+    if (hasDefaultAnnotations()) {\n+      Address addr = getAddressAtOffset(getSize() - getDefaultAnnotationsOffset());\n+      return VMObjectFactory.newObject(U1Array.class, addr);\n+    } else {\n+      return null;\n+    }\n@@ -444,1 +456,0 @@\n-\n@@ -613,0 +624,66 @@\n+  private boolean hasMethodParameters() {\n+    return (getFlags() & HAS_METHOD_PARAMETERS) != 0;\n+  }\n+\n+  private boolean hasGenericSignature() {\n+    return (getFlags() & HAS_GENERIC_SIGNATURE) != 0;\n+  }\n+\n+  private Address getAddressAtOffset(long offsetInWords) {\n+    return getAddress().getAddressAt(offsetInWords * VM.getVM().getAddressSize());\n+  }\n+\n+  \/\/ Pointers to annotations are stored towards the end of the ConstMethod in following format.\n+  \/\/ Each of the pointer may or may not be present.\n+  \/\/\n+  \/\/            |<-------------- getSize() -----------------|\n+  \/\/   start of ConstMethod                          end of ConstMethod\n+  \/\/            |                                           |\n+  \/\/            V                                           V\n+  \/\/            | ... | default | type | parameter | method |\n+  \/\/\n+  \/\/ These methods return the offset of the pointer to the requested annotation from the end of ConstMethod.\n+  private int getMethodAnnotationsOffset() {\n+    return 1;\n+  }\n+\n+  private int getParameterAnnotationsOffset() {\n+    int offset = 1;\n+    if (hasMethodAnnotations()) {\n+      offset += getMethodAnnotationsOffset();\n+    }\n+    return offset;\n+  }\n+\n+  private int getTypeAnnotationsOffset() {\n+    int offset = 1;\n+    if (hasParameterAnnotations()) {\n+      offset += getParameterAnnotationsOffset();\n+    }\n+    return offset;\n+  }\n+\n+  private int getDefaultAnnotationsOffset() {\n+    int offset = 1;\n+    if (hasTypeAnnotations()) {\n+      offset += getTypeAnnotationsOffset();\n+    }\n+    return offset;\n+  }\n+\n+  private boolean hasMethodAnnotations() {\n+    return (getFlags() & HAS_METHOD_ANNOTATIONS) != 0;\n+  }\n+\n+  private boolean hasParameterAnnotations() {\n+    return (getFlags() & HAS_PARAMETER_ANNOTATIONS) != 0;\n+  }\n+\n+  private boolean hasTypeAnnotations() {\n+    return (getFlags() & HAS_TYPE_ANNOTATIONS) != 0;\n+  }\n+\n+  private boolean hasDefaultAnnotations() {\n+    return (getFlags() & HAS_DEFAULT_ANNOTATIONS) != 0;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstMethod.java","additions":94,"deletions":17,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -223,5 +223,1 @@\n-    int oneHalf = getAddress().getJIntAt(indexOffset(index + 1));\n-    int otherHalf   = getAddress().getJIntAt(indexOffset(index));\n-    \/\/ buildLongFromIntsPD accepts higher address value, lower address value\n-    \/\/ in that order.\n-    return VM.getVM().buildLongFromIntsPD(oneHalf, otherHalf);\n+    return getAddress().getJLongAt(indexOffset(index));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPool.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    annotations          = type.getAddressField(\"_annotations\");\n@@ -133,0 +134,1 @@\n+  private static AddressField  annotations;\n@@ -378,1 +380,0 @@\n-\n@@ -387,0 +388,4 @@\n+  public Annotations  getAnnotations() {\n+    Address addr = annotations.getValue(getAddress());\n+    return VMObjectFactory.newObject(Annotations.class, addr);\n+  }\n@@ -862,0 +867,36 @@\n+  public U1Array getClassAnnotations() {\n+    Annotations annotations = getAnnotations();\n+    if (annotations != null) {\n+      return annotations.getClassAnnotations();\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public U1Array getClassTypeAnnotations() {\n+    Annotations annotations = getAnnotations();\n+    if (annotations != null) {\n+      return annotations.getClassTypeAnnotations();\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public U1Array getFieldAnnotations(int fieldIndex) {\n+    Annotations annotations = getAnnotations();\n+    if (annotations != null) {\n+      return annotations.getFieldAnnotations(fieldIndex);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public U1Array getFieldTypeAnnotations(int fieldIndex) {\n+    Annotations annotations = getAnnotations();\n+    if (annotations != null) {\n+      return annotations.getFieldTypeAnnotations(fieldIndex);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+    metadataConstructor.addMapping(\"Annotations\", Annotations.class);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Metadata.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import sun.jvm.hotspot.utilities.U1Array;\n@@ -387,0 +388,16 @@\n+\n+  public U1Array getAnnotations() {\n+    return getConstMethod().getMethodAnnotations();\n+  }\n+\n+  public U1Array getParameterAnnotations() {\n+    return getConstMethod().getParameterAnnotations();\n+  }\n+\n+  public U1Array getTypeAnnotations() {\n+    return getConstMethod().getTypeAnnotations();\n+  }\n+\n+  public U1Array getAnnotationDefault() {\n+    return getConstMethod().getDefaultAnnotations();\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,3 @@\n-          return (short) cpCache.getEntryAt(cpCacheIndex).getConstantPoolIndex();\n+          short cpIndex = (short) cpCache.getIndyEntryAt(cpCacheIndex).getConstantPoolIndex();\n+          Assert.that(cpool.getTagAt(cpIndex).isInvokeDynamic(), \"CP Entry should be InvokeDynamic\");\n+          return cpIndex;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ByteCodeRewriter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -410,0 +410,10 @@\n+            U1Array fieldAnnotations = klass.getFieldAnnotations(index);\n+            if (fieldAnnotations != null) {\n+                fieldAttributeCount++;\n+            }\n+\n+            U1Array fieldTypeAnnotations = klass.getFieldTypeAnnotations(index);\n+            if (fieldTypeAnnotations != null) {\n+                fieldAttributeCount++;\n+            }\n+\n@@ -429,0 +439,8 @@\n+\n+            if (fieldAnnotations != null) {\n+                writeAnnotationAttribute(\"RuntimeVisibleAnnotations\", fieldAnnotations);\n+            }\n+\n+            if (fieldTypeAnnotations != null) {\n+                writeAnnotationAttribute(\"RuntimeVisibleTypeAnnotations\", fieldTypeAnnotations);\n+            }\n@@ -496,0 +514,20 @@\n+        final U1Array annotations = m.getAnnotations();\n+        if (annotations != null) {\n+            methodAttributeCount++;\n+        }\n+\n+        final U1Array parameterAnnotations = m.getParameterAnnotations();\n+        if (parameterAnnotations != null) {\n+            methodAttributeCount++;\n+        }\n+\n+        final U1Array typeAnnotations = m.getTypeAnnotations();\n+        if (typeAnnotations != null) {\n+            methodAttributeCount++;\n+        }\n+\n+        final U1Array annotationDefault = m.getAnnotationDefault();\n+        if (annotationDefault != null) {\n+            methodAttributeCount++;\n+        }\n+\n@@ -691,0 +729,16 @@\n+\n+        if (annotationDefault != null) {\n+           writeAnnotationAttribute(\"AnnotationDefault\", annotationDefault);\n+        }\n+\n+        if (annotations != null) {\n+           writeAnnotationAttribute(\"RuntimeVisibleAnnotations\", annotations);\n+        }\n+\n+        if (parameterAnnotations != null) {\n+           writeAnnotationAttribute(\"RuntimeVisibleParameterAnnotations\", parameterAnnotations);\n+        }\n+\n+        if (typeAnnotations != null) {\n+           writeAnnotationAttribute(\"RuntimeVisibleTypeAnnotations\", typeAnnotations);\n+        }\n@@ -735,0 +789,10 @@\n+        U1Array classAnnotations = klass.getClassAnnotations();\n+        if (classAnnotations != null) {\n+            classAttributeCount++;\n+        }\n+\n+        U1Array classTypeAnnotations = klass.getClassTypeAnnotations();\n+        if (classTypeAnnotations != null) {\n+            classAttributeCount++;\n+        }\n+\n@@ -796,0 +860,21 @@\n+\n+        if (classAnnotations != null) {\n+           writeAnnotationAttribute(\"RuntimeVisibleAnnotations\", classAnnotations);\n+        }\n+\n+        if (classTypeAnnotations != null) {\n+           writeAnnotationAttribute(\"RuntimeVisibleTypeAnnotations\", classTypeAnnotations);\n+        }\n+    }\n+\n+    protected void writeAnnotationAttribute(String annotationName, U1Array annotation) throws IOException {\n+      int length = annotation.length();\n+      Short annotationNameIndex = utf8ToIndex.get(annotationName);\n+      if (Assert.ASSERTS_ENABLED) {\n+        Assert.that(annotationNameIndex != null, \"should not be null\");\n+      }\n+      writeIndex(annotationNameIndex.shortValue());\n+      dos.writeInt(length);\n+      for (int index = 0; index < length; index++) {\n+        dos.writeByte(annotation.at(index));\n+      }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.utilities;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+import sun.jvm.hotspot.types.WrongTypeException;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+public class ArrayOfU1Array extends GenericArray {\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+      public void update(Observable o, Object data) {\n+        initialize(VM.getVM().getTypeDataBase());\n+      }\n+    });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+    elemType = db.lookupType(\"Array<u1>*\");\n+\n+    Type type = db.lookupType(\"Array<Array<u1>*>\");\n+    dataFieldOffset = type.getAddressField(\"_data\").getOffset();\n+  }\n+\n+  private static long dataFieldOffset;\n+  protected static Type elemType;\n+\n+  public ArrayOfU1Array(Address addr) {\n+    super(addr, dataFieldOffset);\n+  }\n+\n+  public Address at(int i) {\n+    return getAddressAt(i);\n+  }\n+\n+  public Type getElemType() {\n+    return elemType;\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/ArrayOfU1Array.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -190,0 +190,1 @@\n+        delete[] data;\n","filename":"src\/jdk.internal.le\/linux\/native\/lible\/CLibrary.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+        delete[] data;\n","filename":"src\/jdk.internal.le\/macosx\/native\/lible\/CLibrary.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -756,0 +756,7 @@\n+                        long uncompressedSize = je.getSize();\n+                        if (uncompressedSize > SignatureFileVerifier.MAX_SIG_FILE_SIZE) {\n+                            unparsableSignatures.putIfAbsent(alias, String.format(\n+                                    rb.getString(\"history.unparsable\"), name));\n+                            continue;\n+                        }\n+\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.DeprecatedTaglet;\n@@ -260,2 +259,2 @@\n-        Content output = (new DeprecatedTaglet()).getAllBlockTagOutput(member,\n-            writer.getTagletWriterInstance(false));\n+        var t = configuration.tagletManager.getTaglet(DocTree.Kind.DEPRECATED);\n+        Content output = t.getAllBlockTagOutput(member, writer.getTagletWriterInstance(false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+\n@@ -44,0 +45,1 @@\n+\n@@ -54,1 +56,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;\n@@ -95,0 +96,5 @@\n+    @Override\n+    public Content getOutputInstance() {\n+        return new ContentBuilder();\n+    }\n+\n@@ -176,1 +182,1 @@\n-    protected TypeElement getCurrentPageElement() {\n+    public TypeElement getCurrentPageElement() {\n@@ -271,2 +277,2 @@\n-            Content paramInfo = (new ParamTaglet()).getAllBlockTagOutput(typeElement,\n-                    getTagletWriterInstance(false));\n+            var t = configuration.tagletManager.getTaglet(DocTree.Kind.PARAM);\n+            Content paramInfo = t.getAllBlockTagOutput(typeElement, getTagletWriterInstance(false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n@@ -30,0 +34,1 @@\n+import java.util.Arrays;\n@@ -42,0 +47,1 @@\n+import javax.tools.DocumentationTool;\n@@ -52,0 +58,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n@@ -64,0 +71,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.SimpleDocletException;\n@@ -107,1 +115,1 @@\n-    protected HtmlIndexBuilder mainIndex;\n+    public HtmlIndexBuilder mainIndex;\n@@ -136,1 +144,1 @@\n-    protected final Messages messages;\n+    public final Messages messages;\n@@ -146,0 +154,5 @@\n+    \/**\n+     * The taglet manager.\n+     *\/\n+    public TagletManager tagletManager;\n+\n@@ -427,0 +440,24 @@\n+\n+        String snippetPath = options.snippetPath();\n+        if (snippetPath != null) {\n+            Messages messages = getMessages();\n+            JavaFileManager fm = getFileManager();\n+            if (fm instanceof StandardJavaFileManager) {\n+                try {\n+                    List<Path> sp = Arrays.stream(snippetPath.split(File.pathSeparator))\n+                            .map(Path::of)\n+                            .toList();\n+                    StandardJavaFileManager sfm = (StandardJavaFileManager) fm;\n+                    sfm.setLocationFromPaths(DocumentationTool.Location.SNIPPET_PATH, sp);\n+                } catch (IOException | InvalidPathException e) {\n+                    throw new SimpleDocletException(messages.getResources().getText(\n+                            \"doclet.error_setting_snippet_path\", snippetPath, e), e);\n+                }\n+            } else {\n+                throw new SimpleDocletException(messages.getResources().getText(\n+                        \"doclet.cannot_use_snippet_path\", snippetPath));\n+            }\n+        }\n+\n+        initTagletManager(options.customTagStrs());\n+\n@@ -429,0 +466,95 @@\n+\n+    \/**\n+     * Initialize the taglet manager.  The strings to initialize the simple custom tags should\n+     * be in the following format:  \"[tag name]:[location str]:[heading]\".\n+     *\n+     * @param customTagStrs the set two-dimensional arrays of strings.  These arrays contain\n+     *                      either -tag or -taglet arguments.\n+     *\/\n+    private void initTagletManager(Set<List<String>> customTagStrs) {\n+        tagletManager = tagletManager != null ? tagletManager : new TagletManager(this);\n+        JavaFileManager fileManager = getFileManager();\n+        Messages messages = getMessages();\n+        try {\n+            tagletManager.initTagletPath(fileManager);\n+            tagletManager.loadTaglets(fileManager);\n+\n+            for (List<String> args : customTagStrs) {\n+                if (args.get(0).equals(\"-taglet\")) {\n+                    tagletManager.addCustomTag(args.get(1), fileManager);\n+                    continue;\n+                }\n+                \/* Since there are few constraints on the characters in a tag name,\n+                 * and real world examples with ':' in the tag name, we cannot simply use\n+                 * String.split(regex);  instead, we tokenize the string, allowing\n+                 * special characters to be escaped with '\\'. *\/\n+                List<String> tokens = tokenize(args.get(1), 3);\n+                switch (tokens.size()) {\n+                    case 1 -> {\n+                        String tagName = args.get(1);\n+                        if (tagletManager.isKnownCustomTag(tagName)) {\n+                            \/\/reorder a standard tag\n+                            tagletManager.addNewSimpleCustomTag(tagName, null, \"\");\n+                        } else {\n+                            \/\/Create a simple tag with the heading that has the same name as the tag.\n+                            StringBuilder heading = new StringBuilder(tagName + \":\");\n+                            heading.setCharAt(0, Character.toUpperCase(tagName.charAt(0)));\n+                            tagletManager.addNewSimpleCustomTag(tagName, heading.toString(), \"a\");\n+                        }\n+                    }\n+\n+                    case 2 ->\n+                        \/\/Add simple taglet without heading, probably to excluding it in the output.\n+                            tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(1), \"\");\n+\n+                    case 3 ->\n+                            tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(2), tokens.get(1));\n+\n+                    default ->\n+                            messages.error(\"doclet.Error_invalid_custom_tag_argument\", args.get(1));\n+                }\n+            }\n+        } catch (IOException e) {\n+            messages.error(\"doclet.taglet_could_not_set_location\", e.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Given a string, return an array of tokens, separated by ':'.\n+     * The separator character can be escaped with the '\\' character.\n+     * The '\\' character may also be escaped with the '\\' character.\n+     *\n+     * @param s         the string to tokenize\n+     * @param maxTokens the maximum number of tokens returned.  If the\n+     *                  max is reached, the remaining part of s is appended\n+     *                  to the end of the last token.\n+     * @return an array of tokens\n+     *\/\n+    private List<String> tokenize(String s, int maxTokens) {\n+        List<String> tokens = new ArrayList<>();\n+        StringBuilder token = new StringBuilder();\n+        boolean prevIsEscapeChar = false;\n+        for (int i = 0; i < s.length(); i += Character.charCount(i)) {\n+            int currentChar = s.codePointAt(i);\n+            if (prevIsEscapeChar) {\n+                \/\/ Case 1:  escaped character\n+                token.appendCodePoint(currentChar);\n+                prevIsEscapeChar = false;\n+            } else if (currentChar == ':' && tokens.size() < maxTokens - 1) {\n+                \/\/ Case 2:  separator\n+                tokens.add(token.toString());\n+                token = new StringBuilder();\n+            } else if (currentChar == '\\\\') {\n+                \/\/ Case 3:  escape character\n+                prevIsEscapeChar = true;\n+            } else {\n+                \/\/ Case 4:  regular character\n+                token.appendCodePoint(currentChar);\n+            }\n+        }\n+        if (token.length() > 0) {\n+            tokens.add(token.toString());\n+        }\n+        return tokens;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":134,"deletions":2,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -322,0 +322,10 @@\n+    @Override\n+    protected void generateFiles() throws DocletException {\n+        super.generateFiles();\n+\n+        if (configuration.tagletManager != null) { \/\/ may be null, if no files generated, perhaps because of errros\n+            configuration.tagletManager.printReport();\n+        }\n+\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+\n@@ -71,1 +72,0 @@\n-import com.sun.source.doctree.IndexTree;\n@@ -73,0 +73,1 @@\n+import com.sun.source.doctree.InlineTagTree;\n@@ -76,2 +77,0 @@\n-import com.sun.source.doctree.SummaryTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n@@ -94,0 +93,2 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n@@ -97,3 +98,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n@@ -112,1 +110,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n@@ -115,1 +112,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.CODE;\n@@ -117,3 +113,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.LINK;\n-import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n-import static com.sun.source.doctree.DocTree.Kind.SEE;\n@@ -163,1 +156,1 @@\n-    protected final Messages messages;\n+    public final Messages messages;\n@@ -167,1 +160,1 @@\n-    protected final Links links;\n+    public final Links links;\n@@ -200,1 +193,1 @@\n-    Map<String, Integer> indexAnchorTable = new HashMap<>();\n+    public final Map<String, Integer> indexAnchorTable = new HashMap<>();\n@@ -281,1 +274,1 @@\n-        \/\/ Note: {@docRoot} is not case sensitive when passed in with a command-line option:\n+        \/\/ Note: {@docRoot} is not case-sensitive when passed in with a command-line option:\n@@ -377,3 +370,2 @@\n-    private Content getInlineTagOutput(Element element, DocTree tree, TagletWriterImpl.Context context) {\n-        return getTagletWriterInstance(context)\n-                .getInlineTagOutput(element, configuration.tagletManager, tree);\n+    private Content getInlineTagOutput(Element element, InlineTagTree tree, TagletWriter.Context context) {\n+        return getTagletWriterInstance(context).getInlineTagOutput(element, tree);\n@@ -389,1 +381,1 @@\n-        return new TagletWriterImpl(this, isFirstSentence);\n+        return new TagletWriter(this, isFirstSentence);\n@@ -398,2 +390,2 @@\n-    public TagletWriterImpl getTagletWriterInstance(TagletWriterImpl.Context context) {\n-        return new TagletWriterImpl(this, context);\n+    public TagletWriter getTagletWriterInstance(TagletWriter.Context context) {\n+        return new TagletWriter(this, context);\n@@ -759,1 +751,1 @@\n-     * Return a class cross link to external class documentation.\n+     * Return a class cross-link to external class documentation.\n@@ -889,1 +881,1 @@\n-    protected TypeElement getCurrentPageElement() {\n+    public TypeElement getCurrentPageElement() {\n@@ -1180,1 +1172,1 @@\n-                new TagletWriterImpl.Context(isFirstSentence, inSummary));\n+                new TagletWriter.Context(isFirstSentence, inSummary));\n@@ -1197,1 +1189,1 @@\n-                                        TagletWriterImpl.Context context)\n+                                        TagletWriter.Context context)\n@@ -1310,6 +1302,0 @@\n-                @Override\n-                public Boolean visitDocRoot(DocRootTree node, Content content) {\n-                    content.add(getInlineTagOutput(element, node, context));\n-                    return false;\n-                }\n-\n@@ -1364,37 +1350,0 @@\n-                @Override\n-                public Boolean visitIndex(IndexTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    if (output != null) {\n-                        content.add(output);\n-                    }\n-                    return false;\n-                }\n-\n-                @Override\n-                public Boolean visitLink(LinkTree node, Content content) {\n-                    var inTags = context.inTags;\n-                    if (inTags.contains(LINK) || inTags.contains(LINK_PLAIN) || inTags.contains(SEE)) {\n-                        DocTreePath dtp = ch.getDocTreePath(node);\n-                        if (dtp != null) {\n-                            messages.warning(dtp, \"doclet.see.nested_link\", \"{@\" + node.getTagName() + \"}\");\n-                        }\n-                        Content label = commentTagsToContent(element, node.getLabel(), context);\n-                        if (label.isEmpty()) {\n-                            label = Text.of(node.getReference().getSignature());\n-                        }\n-                        content.add(label);\n-                    } else {\n-                        TagletWriterImpl t = getTagletWriterInstance(context.within(node));\n-                        content.add(t.linkTagOutput(element, node));\n-                    }\n-                    return false;\n-                }\n-\n-                @Override\n-                public Boolean visitLiteral(LiteralTree node, Content content) {\n-                    String s = node.getBody().getBody();\n-                    Content t = Text.of(Text.normalizeNewlines(s));\n-                    content.add(node.getKind() == CODE ? HtmlTree.CODE(t) : t);\n-                    return false;\n-                }\n-\n@@ -1414,16 +1363,0 @@\n-                @Override\n-                public Boolean visitSummary(SummaryTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    content.add(output);\n-                    return false;\n-                }\n-\n-                @Override\n-                public Boolean visitSystemProperty(SystemPropertyTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    if (output != null) {\n-                        content.add(output);\n-                    }\n-                    return false;\n-                }\n-\n@@ -1458,3 +1391,5 @@\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    if (output != null) {\n-                        content.add(output);\n+                    if (node instanceof InlineTagTree itt) {\n+                        var output = getInlineTagOutput(element, itt, context);\n+                        if (output != null) {\n+                            content.add(output);\n+                        }\n@@ -1488,1 +1423,1 @@\n-                                         Element element, TagletWriterImpl.Context context) {\n+                                         Element element, TagletWriter.Context context) {\n@@ -1565,1 +1500,1 @@\n-    protected Content invalidTagOutput(String summary, Optional<Content> detail) {\n+    public Content invalidTagOutput(String summary, Optional<Content> detail) {\n@@ -1668,1 +1603,1 @@\n-                text = \"{@\" + (new DocRootTaglet()).getName() + \"}\/\"\n+                text = \"{@\" + Kind.DOC_ROOT.tagName + \"}\/\"\n@@ -2052,1 +1987,1 @@\n-     * @throws DocFileIOException\n+     * @throws DocFileIOException if an issue arises while accessing any stylesheets\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":26,"deletions":91,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -397,1 +397,1 @@\n-    static HtmlId forParam(String paramName) {\n+    public static HtmlId forParam(String paramName) {\n@@ -410,1 +410,1 @@\n-    static HtmlId forText(String text, Map<String, Integer> counts) {\n+    public static HtmlId forText(String text, Map<String, Integer> counts) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.LinkedHashSet;\n@@ -103,0 +104,5 @@\n+    \/**\n+     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n+     *\/\n+    private final LinkedHashSet<List<String>> customTagStrs = new LinkedHashSet<>();\n+\n@@ -178,0 +184,6 @@\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path for external snippets.\n+     *\/\n+    private String snippetPath = null;\n+\n@@ -185,0 +197,6 @@\n+    \/**\n+     * Argument for command-line option {@code --show-taglets}.\n+     * Show taglets (internal debug switch)\n+     *\/\n+    private boolean showTaglets = false;\n+\n@@ -190,0 +208,6 @@\n+    \/**\n+     * Argument for command-line option {@code -tagletpath}.\n+     * The path to Taglets\n+     *\/\n+    private String tagletPath = null;\n+\n@@ -409,0 +433,38 @@\n+                new Option(resources, \"--snippet-path\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        snippetPath = args.get(0);\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"-tag\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        ArrayList<String> list = new ArrayList<>();\n+                        list.add(opt);\n+                        list.add(args.get(0));\n+                        customTagStrs.add(list);\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"-taglet\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        ArrayList<String> list = new ArrayList<>();\n+                        list.add(opt);\n+                        list.add(args.get(0));\n+                        customTagStrs.add(list);\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"-tagletpath\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        tagletPath = args.get(0);\n+                        return true;\n+                    }\n+                },\n+\n@@ -492,0 +554,8 @@\n+                },\n+\n+                new Hidden(resources, \"--show-taglets\") {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        showTaglets = true;\n+                        return true;\n+                    }\n@@ -623,0 +693,7 @@\n+    \/**\n+     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n+     *\/\n+    LinkedHashSet<List<String>> customTagStrs() {\n+        return customTagStrs;\n+    }\n+\n@@ -724,0 +801,16 @@\n+    \/**\n+     * Argument for command-line option {@code --show-taglets}.\n+     * Show taglets (internal debug switch)\n+     *\/\n+    public boolean showTaglets() {\n+        return showTaglets;\n+    }\n+\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path for external snippets.\n+     *\/\n+    public String snippetPath() {\n+        return snippetPath;\n+    }\n+\n@@ -740,0 +833,8 @@\n+    \/**\n+     * Argument for command-line option {@code -tagletpath}.\n+     * The path to Taglets\n+     *\/\n+    public String tagletPath() {\n+        return tagletPath;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlOptions.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import java.util.*;\n+import java.util.List;\n+import java.util.SortedSet;\n@@ -35,1 +36,0 @@\n-\n@@ -38,0 +38,1 @@\n+\n@@ -39,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n@@ -41,0 +41,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n@@ -42,0 +43,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n@@ -137,1 +139,1 @@\n-                    new TagletWriterImpl.Context(false, false));\n+                    new TagletWriter.Context(false, false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialFieldWriter.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialMethodWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,985 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.util.ArrayList;\n-import java.util.EnumSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.SimpleElementVisitor14;\n-\n-import com.sun.source.doctree.DeprecatedTree;\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.IndexTree;\n-import com.sun.source.doctree.LinkTree;\n-import com.sun.source.doctree.LiteralTree;\n-import com.sun.source.doctree.ParamTree;\n-import com.sun.source.doctree.ReturnTree;\n-import com.sun.source.doctree.SeeTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.doctree.SpecTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n-import com.sun.source.doctree.TextTree;\n-import com.sun.source.doctree.ThrowsTree;\n-import com.sun.source.util.DocTreePath;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Style;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils.PreviewFlagProvider;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n-\n-\/**\n- * The taglet writer that writes HTML.\n- *\/\n-public class TagletWriterImpl extends TagletWriter {\n-    \/**\n-     * A class that provides the information about the enclosing context for\n-     * a series of {@code DocTree} nodes.\n-     * This context may be used to determine the content that should be generated from the tree nodes.\n-     *\/\n-    static class Context {\n-        \/**\n-         * Whether or not the trees are appearing in a context of just the first sentence,\n-         * such as in the summary table of the enclosing element.\n-         *\/\n-        final boolean isFirstSentence;\n-        \/**\n-         * Whether or not the trees are appearing in the \"summary\" section of the\n-         * page for a declaration.\n-         *\/\n-        final boolean inSummary;\n-        \/**\n-         * The set of enclosing kinds of tags.\n-         *\/\n-        final Set<DocTree.Kind> inTags;\n-\n-        \/**\n-         * Creates an outermost context, with no enclosing tags.\n-         *\n-         * @param isFirstSentence {@code true} if the trees are appearing in a context of just the\n-         *                        first sentence and {@code false} otherwise\n-         * @param inSummary       {@code true} if the trees are appearing in the \"summary\" section\n-         *                        of the page for a declaration and {@code false} otherwise\n-         *\/\n-        Context(boolean isFirstSentence, boolean inSummary) {\n-            this(isFirstSentence, inSummary, EnumSet.noneOf(DocTree.Kind.class));\n-        }\n-\n-        private Context(boolean isFirstSentence, boolean inSummary, Set<DocTree.Kind> inTags) {\n-            this.isFirstSentence = isFirstSentence;\n-            this.inSummary = inSummary;\n-            this.inTags = inTags;\n-        }\n-\n-        \/**\n-         * Creates a new {@code Context} that includes an extra tag kind in the set of enclosing\n-         * kinds of tags.\n-         *\n-         * @param tree the enclosing tree\n-         *\n-         * @return the new {@code Context}\n-         *\/\n-        Context within(DocTree tree) {\n-            var newInTags = EnumSet.copyOf(inTags);\n-            newInTags.add(tree.getKind());\n-            return new Context(isFirstSentence, inSummary, newInTags);\n-        }\n-    }\n-\n-    private final HtmlDocletWriter htmlWriter;\n-    private final HtmlConfiguration configuration;\n-    private final HtmlOptions options;\n-    private final Utils utils;\n-    private final Resources resources;\n-\n-    private final Messages messages;\n-\n-    private final Contents contents;\n-    private final Context context;\n-\n-    \/\/ Threshold for length of @see tag label for switching from inline to block layout.\n-    private static final int TAG_LIST_ITEM_MAX_INLINE_LENGTH = 30;\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n-     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n-     *                        \"first sentence\" summary\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence) {\n-        this(htmlWriter, isFirstSentence, false);\n-    }\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n-     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n-     *                        \"first sentence\" summary, and {@code false} otherwise\n-     * @param inSummary       {@code true} if this taglet writer is being used for the content\n-     *                        of a {@code {@summary ...}} tag, and {@code false} otherwise\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence, boolean inSummary) {\n-        this(htmlWriter, new Context(isFirstSentence, inSummary));\n-    }\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter the {@code HtmlDocletWriter} for the page\n-     * @param context    the enclosing context for any tags\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, Context context) {\n-        super(context.isFirstSentence);\n-        this.htmlWriter = htmlWriter;\n-        this.context = context;\n-        configuration = htmlWriter.configuration;\n-        options = configuration.getOptions();\n-        utils = configuration.utils;\n-        messages = configuration.messages;\n-        resources = configuration.getDocResources();\n-        contents = configuration.getContents();\n-    }\n-\n-    @Override\n-    public Content getOutputInstance() {\n-        return new ContentBuilder();\n-    }\n-\n-    @Override\n-    protected Content codeTagOutput(Element element, LiteralTree tag) {\n-        return HtmlTree.CODE(Text.of(Text.normalizeNewlines(tag.getBody().getBody())));\n-    }\n-\n-    @Override\n-    protected Content indexTagOutput(Element element, IndexTree tag) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-\n-        DocTree searchTerm = tag.getSearchTerm();\n-        String tagText = (searchTerm instanceof TextTree tt) ? tt.getBody() : \"\";\n-        if (tagText.charAt(0) == '\"' && tagText.charAt(tagText.length() - 1) == '\"') {\n-            tagText = tagText.substring(1, tagText.length() - 1);\n-        }\n-        tagText = tagText.replaceAll(\"\\\\s+\", \" \");\n-\n-        Content desc = htmlWriter.commentTagsToContent(element, tag.getDescription(), context.within(tag));\n-        String descText = extractText(desc);\n-\n-        return createAnchorAndSearchIndex(element, tagText, descText, tag);\n-    }\n-\n-    \/\/ ugly but simple;\n-    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n-    private String extractText(Content c) {\n-        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n-    }\n-\n-    @Override\n-    public Content getDocRootOutput() {\n-        String path;\n-        if (htmlWriter.pathToRoot.isEmpty())\n-            path = \".\";\n-        else\n-            path = htmlWriter.pathToRoot.getPath();\n-        return Text.of(path);\n-    }\n-\n-    @Override\n-    public Content deprecatedTagOutput(Element element) {\n-        ContentBuilder result = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(element);\n-        if (utils.isTypeElement(element)) {\n-            if (utils.isDeprecated(element)) {\n-                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(element)));\n-                if (!deprs.isEmpty()) {\n-                    List<? extends DocTree> commentTrees = ch.getDescription(deprs.get(0));\n-                    if (!commentTrees.isEmpty()) {\n-                        result.add(commentTagsToOutput(element, null, commentTrees, false));\n-                    }\n-                }\n-            }\n-        } else {\n-            if (utils.isDeprecated(element)) {\n-                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(element)));\n-                if (!deprs.isEmpty()) {\n-                    List<? extends DocTree> bodyTrees = ch.getBody(deprs.get(0));\n-                    Content body = commentTagsToOutput(element, null, bodyTrees, false);\n-                    if (!body.isEmpty())\n-                        result.add(HtmlTree.DIV(HtmlStyle.deprecationComment, body));\n-                }\n-            } else {\n-                Element ee = utils.getEnclosingTypeElement(element);\n-                if (utils.isDeprecated(ee)) {\n-                    result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(ee)));\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public Content linkTagOutput(Element element, LinkTree tag) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-\n-        var linkRef = tag.getReference();\n-        if (linkRef == null) {\n-            messages.warning(ch.getDocTreePath(tag), \"doclet.link.no_reference\");\n-            return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", tag.toString()),\n-                    Optional.empty());\n-        }\n-\n-        DocTree.Kind kind = tag.getKind();\n-        String refSignature = ch.getReferencedSignature(linkRef);\n-\n-        return linkSeeReferenceOutput(element,\n-                tag,\n-                refSignature,\n-                ch.getReferencedElement(tag),\n-                (kind == LINK_PLAIN),\n-                htmlWriter.commentTagsToContent(element, tag.getLabel(), context),\n-                (key, args) -> messages.warning(ch.getDocTreePath(tag), key, args)\n-        );\n-    }\n-\n-    @Override\n-    protected Content literalTagOutput(Element element, LiteralTree tag) {\n-        return Text.of(Text.normalizeNewlines(tag.getBody().getBody()));\n-    }\n-\n-    @Override\n-    public Content getParamHeader(ParamTaglet.ParamKind kind) {\n-        Content header = switch (kind) {\n-            case PARAMETER -> contents.parameters;\n-            case TYPE_PARAMETER -> contents.typeParameters;\n-            case RECORD_COMPONENT -> contents.recordComponents;\n-            default -> throw new IllegalArgumentException(kind.toString());\n-        };\n-        return HtmlTree.DT(header);\n-    }\n-\n-    @Override\n-    public Content paramTagOutput(Element element, ParamTree paramTag, String paramName) {\n-        ContentBuilder body = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        \/\/ define id attributes for state components so that generated descriptions may refer to them\n-        boolean defineID = (element.getKind() == ElementKind.RECORD)\n-                && !paramTag.isTypeParameter();\n-        Content nameContent = Text.of(paramName);\n-        body.add(HtmlTree.CODE(defineID ? HtmlTree.SPAN_ID(HtmlIds.forParam(paramName), nameContent) : nameContent));\n-        body.add(\" - \");\n-        List<? extends DocTree> description = ch.getDescription(paramTag);\n-        body.add(htmlWriter.commentTagsToContent(element, description, context.within(paramTag)));\n-        return HtmlTree.DD(body);\n-    }\n-\n-    @Override\n-    public Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        List<? extends DocTree> desc = ch.getDescription(returnTag);\n-        Content content = htmlWriter.commentTagsToContent(element, desc, context.within(returnTag));\n-        return inline\n-                ? new ContentBuilder(contents.getContent(\"doclet.Returns_0\", content))\n-                : new ContentBuilder(HtmlTree.DT(contents.returns), HtmlTree.DD(content));\n-    }\n-\n-    @Override\n-    public Content seeTagOutput(Element holder, List<? extends SeeTree> seeTags) {\n-        List<Content> links = new ArrayList<>();\n-        for (SeeTree dt : seeTags) {\n-            TagletWriterImpl t = new TagletWriterImpl(htmlWriter, context.within(dt));\n-            links.add(t.seeTagOutput(holder, dt));\n-        }\n-        if (utils.isVariableElement(holder) && ((VariableElement)holder).getConstantValue() != null &&\n-                htmlWriter instanceof ClassWriterImpl writer) {\n-            \/\/Automatically add link to constant values page for constant fields.\n-            DocPath constantsPath =\n-                    htmlWriter.pathToRoot.resolve(DocPaths.CONSTANT_VALUES);\n-            String whichConstant =\n-                    writer.getTypeElement().getQualifiedName() + \".\" +\n-                    utils.getSimpleName(holder);\n-            DocLink link = constantsPath.fragment(whichConstant);\n-            links.add(htmlWriter.links.createLink(link,\n-                    contents.getContent(\"doclet.Constants_Summary\")));\n-        }\n-        if (utils.isClass(holder) && utils.isSerializable((TypeElement)holder)) {\n-            \/\/Automatically add link to serialized form page for serializable classes.\n-            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n-                      SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n-                DocPath serialPath = htmlWriter.pathToRoot.resolve(DocPaths.SERIALIZED_FORM);\n-                DocLink link = serialPath.fragment(utils.getFullyQualifiedName(holder));\n-                links.add(htmlWriter.links.createLink(link,\n-                        contents.getContent(\"doclet.Serialized_Form\")));\n-            }\n-        }\n-        if (links.isEmpty()) {\n-            return Text.EMPTY;\n-        }\n-        \/\/ Use a different style if any link label is longer than 30 chars or contains commas.\n-        boolean hasLongLabels = links.stream().anyMatch(this::isLongOrHasComma);\n-        var seeList = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n-        links.stream()\n-                .filter(Predicate.not(Content::isEmpty))\n-                .forEach(item -> seeList.add(HtmlTree.LI(item)));\n-\n-        return new ContentBuilder(\n-                HtmlTree.DT(contents.seeAlso),\n-                HtmlTree.DD(seeList));\n-    }\n-\n-    private boolean isLongOrHasComma(Content c) {\n-        String s = c.toString()\n-                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n-                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n-                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n-        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n-    }\n-\n-    String textOf(List<? extends DocTree> trees) {\n-        return trees.stream()\n-                .filter(dt -> dt instanceof TextTree)\n-                .map(dt -> ((TextTree) dt).getBody().trim())\n-                .collect(Collectors.joining(\" \"));\n-    }\n-\n-    \/**\n-     * {@return the output for a single {@code @see} tag}\n-     *\n-     * @param element the element that has the documentation comment containing this tag\n-     * @param seeTag  the tag\n-     *\/\n-    private Content seeTagOutput(Element element, SeeTree seeTag) {\n-        List<? extends DocTree> ref = seeTag.getReference();\n-        assert !ref.isEmpty();\n-        DocTree ref0 = ref.get(0);\n-        switch (ref0.getKind()) {\n-            case TEXT, START_ELEMENT -> {\n-                \/\/ @see \"Reference\"\n-                \/\/ @see <a href=\"...\">...<\/a>\n-                return htmlWriter.commentTagsToContent(element, ref, false, false);\n-            }\n-\n-            case REFERENCE -> {\n-                \/\/ @see reference label...\n-                CommentHelper ch = utils.getCommentHelper(element);\n-                String refSignature = ch.getReferencedSignature(ref0);\n-                List<? extends DocTree> label = ref.subList(1, ref.size());\n-\n-                return linkSeeReferenceOutput(element,\n-                        seeTag,\n-                        refSignature,\n-                        ch.getReferencedElement(seeTag),\n-                        false,\n-                        htmlWriter.commentTagsToContent(element, label, context),\n-                        (key, args) -> messages.warning(ch.getDocTreePath(seeTag), key, args)\n-                );\n-            }\n-\n-            case ERRONEOUS -> {\n-                return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n-                                ref0.toString()),\n-                        Optional.empty());\n-            }\n-\n-            default -> throw new IllegalStateException(ref0.getKind().toString());\n-        }\n-\n-    }\n-\n-    \/**\n-     * Worker method to generate a link from the information in different kinds of tags,\n-     * such as {@code {@link ...}} tags, {@code @see ...} tags and the {@code link} markup tag\n-     * in a {@code {@snippet ...}} tag.\n-     *\n-     * @param holder        the element that has the documentation comment containing the information\n-     * @param refTree       the tree node containing the information, or {@code null} if not available\n-     * @param refSignature  the normalized signature of the target of the reference\n-     * @param ref           the target of the reference\n-     * @param isLinkPlain   {@code true} if the link should be presented in \"plain\" font,\n-     *                      or {@code false} for \"code\" font\n-     * @param label         the label for the link,\n-     *                      or an empty item to use a default label derived from the signature\n-     * @param reportWarning a function to report warnings about issues found in the reference\n-     *\n-     * @return the output containing the generated link, or content indicating an error\n-     *\/\n-    private Content linkSeeReferenceOutput(Element holder,\n-                                           DocTree refTree,\n-                                           String refSignature,\n-                                           Element ref,\n-                                           boolean isLinkPlain,\n-                                           Content label,\n-                                           BiConsumer<String, Object[]> reportWarning) {\n-        Content labelContent = plainOrCode(isLinkPlain, label);\n-\n-        \/\/ The signature from the @see tag. We will output this text when a label is not specified.\n-        Content text = plainOrCode(isLinkPlain,\n-                Text.of(Objects.requireNonNullElse(refSignature, \"\")));\n-\n-        CommentHelper ch = utils.getCommentHelper(holder);\n-        TypeElement refClass = ch.getReferencedClass(ref);\n-        Element refMem =       ch.getReferencedMember(ref);\n-        String refFragment =   ch.getReferencedFragment(refSignature);\n-\n-        if (refFragment == null && refMem != null) {\n-            refFragment = refMem.toString();\n-        } else if (refFragment != null && refFragment.startsWith(\"#\")) {\n-            if (labelContent.isEmpty()) {\n-                \/\/ A non-empty label is required for fragment links as the\n-                \/\/ reference target does not provide a useful default label.\n-                htmlWriter.messages.error(ch.getDocTreePath(refTree), \"doclet.link.see.no_label\");\n-                return invalidTagOutput(resources.getText(\"doclet.link.see.no_label\"),\n-                        Optional.of(refSignature));\n-            }\n-            refFragment = refFragment.substring(1);\n-        }\n-        if (refClass == null) {\n-            ModuleElement refModule = ch.getReferencedModule(ref);\n-            if (refModule != null && utils.isIncluded(refModule)) {\n-                return htmlWriter.getModuleLink(refModule, labelContent.isEmpty() ? text : labelContent, refFragment);\n-            }\n-            \/\/@see is not referencing an included class\n-            PackageElement refPackage = ch.getReferencedPackage(ref);\n-            if (refPackage != null && utils.isIncluded(refPackage)) {\n-                \/\/@see is referencing an included package\n-                if (labelContent.isEmpty()) {\n-                    labelContent = plainOrCode(isLinkPlain,\n-                            Text.of(refPackage.getQualifiedName()));\n-                }\n-                return htmlWriter.getPackageLink(refPackage, labelContent, refFragment);\n-            } else {\n-                \/\/ @see is not referencing an included class, module or package. Check for cross links.\n-                String refModuleName =  ch.getReferencedModuleName(refSignature);\n-                DocLink elementCrossLink = (refPackage != null) ? htmlWriter.getCrossPackageLink(refPackage) :\n-                        (configuration.extern.isModule(refModuleName))\n-                                ? htmlWriter.getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n-                                : null;\n-                if (elementCrossLink != null) {\n-                    \/\/ Element cross link found\n-                    return htmlWriter.links.createExternalLink(elementCrossLink,\n-                            (labelContent.isEmpty() ? text : labelContent));\n-                } else {\n-                    \/\/ No cross link found so print warning\n-                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n-                        reportWarning.accept(\n-                                \"doclet.link.see.reference_not_found\",\n-                                new Object[] { refSignature});\n-                    }\n-                    return htmlWriter.invalidTagOutput(resources.getText(\"doclet.link.see.reference_invalid\"),\n-                            Optional.of(labelContent.isEmpty() ? text: labelContent));\n-                }\n-            }\n-        } else if (refFragment == null) {\n-            \/\/ Must be a class reference since refClass is not null and refFragment is null.\n-            if (labelContent.isEmpty() && refTree != null) {\n-                TypeMirror referencedType = ch.getReferencedType(refTree);\n-                if (utils.isGenericType(referencedType)) {\n-                    \/\/ This is a generic type link, use the TypeMirror representation.\n-                    return plainOrCode(isLinkPlain, htmlWriter.getLink(\n-                            new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, referencedType)));\n-                }\n-                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n-            }\n-            return htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, refClass)\n-                    .label(labelContent));\n-        } else if (refMem == null) {\n-            \/\/ This is a fragment reference since refClass and refFragment are not null but refMem is null.\n-            return htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, refClass)\n-                    .label(labelContent)\n-                    .fragment(refFragment)\n-                    .style(null));\n-        } else {\n-            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n-            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n-            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n-\n-            \/\/ Find the enclosing type where the method is actually visible\n-            \/\/ in the inheritance hierarchy.\n-            ExecutableElement overriddenMethod = null;\n-            if (refMem.getKind() == ElementKind.METHOD) {\n-                VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);\n-                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n-\n-                if (overriddenMethod != null) {\n-                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n-                }\n-            }\n-            if (refSignature.trim().startsWith(\"#\") &&\n-                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n-                \/\/ Since the link is relative and the holder is not even being\n-                \/\/ documented, this must be an inherited link.  Redirect it.\n-                \/\/ The current class either overrides the referenced member or\n-                \/\/ inherits it automatically.\n-                if (htmlWriter instanceof ClassWriterImpl writer) {\n-                    containing = writer.getTypeElement();\n-                } else if (!utils.isPublic(containing)) {\n-                    reportWarning.accept(\"doclet.link.see.reference_not_accessible\",\n-                            new Object[] { utils.getFullyQualifiedName(containing)});\n-                } else {\n-                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n-                        reportWarning.accept(\"doclet.link.see.reference_not_found\",\n-                                new Object[] { refSignature });\n-                    }\n-                }\n-            }\n-            String refMemName = refFragment;\n-            if (configuration.currentTypeElement != containing) {\n-                refMemName = (utils.isConstructor(refMem))\n-                        ? refMemName\n-                        : utils.getSimpleName(containing) + \".\" + refMemName;\n-            }\n-            if (utils.isExecutableElement(refMem)) {\n-                if (refMemName.indexOf('(') < 0) {\n-                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n-                }\n-                if (overriddenMethod != null) {\n-                    \/\/ The method to actually link.\n-                    refMem = overriddenMethod;\n-                }\n-            }\n-\n-            return htmlWriter.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, containing,\n-                    refMem, (labelContent.isEmpty()\n-                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n-                            : labelContent), null, false);\n-        }\n-    }\n-\n-    private Content plainOrCode(boolean plain, Content body) {\n-        return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);\n-    }\n-\n-    @Override\n-    public Content simpleBlockTagOutput(Element element, List<? extends DocTree> simpleTags, String header) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        ContentBuilder body = new ContentBuilder();\n-        boolean many = false;\n-        for (DocTree simpleTag : simpleTags) {\n-            if (many) {\n-                body.add(\", \");\n-            }\n-            List<? extends DocTree> bodyTags = ch.getBody(simpleTag);\n-            body.add(htmlWriter.commentTagsToContent(element, bodyTags, context.within(simpleTag)));\n-            many = true;\n-        }\n-        return new ContentBuilder(\n-                HtmlTree.DT(RawHtml.of(header)),\n-                HtmlTree.DD(body));\n-    }\n-\n-    @Override\n-    protected Content snippetTagOutput(Element element, SnippetTree tag, StyledText content,\n-                                       String id, String lang) {\n-        var pre = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n-        if (id != null && !id.isBlank()) {\n-            pre.put(HtmlAttr.ID, id);\n-        }\n-        var code = new HtmlTree(TagName.CODE)\n-                .addUnchecked(Text.EMPTY); \/\/ Make sure the element is always rendered\n-        if (lang != null && !lang.isBlank()) {\n-            code.addStyle(\"language-\" + lang);\n-        }\n-\n-        content.consumeBy((styles, sequence) -> {\n-            CharSequence text = Text.normalizeNewlines(sequence);\n-            if (styles.isEmpty()) {\n-                code.add(text);\n-            } else {\n-                Element e = null;\n-                String t = null;\n-                boolean linkEncountered = false;\n-                boolean markupEncountered = false;\n-                Set<String> classes = new HashSet<>();\n-                for (Style s : styles) {\n-                    if (s instanceof Style.Name n) {\n-                        classes.add(n.name());\n-                    } else if (s instanceof Style.Link l) {\n-                        assert !linkEncountered; \/\/ TODO: do not assert; pick the first link report on subsequent\n-                        linkEncountered = true;\n-                        t = l.target();\n-                        e = getLinkedElement(element, t);\n-                        if (e == null) {\n-                            \/\/ TODO: diagnostic output\n-                        }\n-                    } else if (s instanceof Style.Markup) {\n-                        markupEncountered = true;\n-                        break;\n-                    } else {\n-                        \/\/ TODO: transform this if...else into an exhaustive\n-                        \/\/ switch over the sealed Style hierarchy when \"Pattern\n-                        \/\/ Matching for switch\" has been implemented (JEP 406\n-                        \/\/ and friends)\n-                        throw new AssertionError(styles);\n-                    }\n-                }\n-                Content c;\n-                if (markupEncountered) {\n-                    return;\n-                } else if (linkEncountered) {\n-                    assert e != null;\n-                    \/\/disable preview tagging inside the snippets:\n-                    PreviewFlagProvider prevPreviewProvider = utils.setPreviewFlagProvider(el -> false);\n-                    try {\n-                        c = linkSeeReferenceOutput(element,\n-                                null,\n-                                t,\n-                                e,\n-                                false, \/\/ TODO: for now\n-                                Text.of(sequence.toString()),\n-                                (key, args) -> { \/* TODO: report diagnostic *\/ });\n-                    } finally {\n-                        utils.setPreviewFlagProvider(prevPreviewProvider);\n-                    }\n-                } else {\n-                    c = HtmlTree.SPAN(Text.of(text));\n-                    classes.forEach(((HtmlTree) c)::addStyle);\n-                }\n-                code.add(c);\n-            }\n-        });\n-        String copyText = resources.getText(\"doclet.Copy_to_clipboard\");\n-        String copiedText = resources.getText(\"doclet.Copied_to_clipboard\");\n-        String copySnippetText = resources.getText(\"doclet.Copy_snippet_to_clipboard\");\n-        var snippetContainer = HtmlTree.DIV(HtmlStyle.snippetContainer,\n-                new HtmlTree(TagName.BUTTON)\n-                        .add(HtmlTree.SPAN(Text.of(copyText))\n-                                .put(HtmlAttr.DATA_COPIED, copiedText))\n-                        .add(new HtmlTree(TagName.IMG)\n-                                .put(HtmlAttr.SRC, htmlWriter.pathToRoot.resolve(DocPaths.CLIPBOARD_SVG).getPath())\n-                                .put(HtmlAttr.ALT, copySnippetText))\n-                        .addStyle(HtmlStyle.copy)\n-                        .addStyle(HtmlStyle.snippetCopy)\n-                        .put(HtmlAttr.ARIA_LABEL, copySnippetText)\n-                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\"));\n-        return snippetContainer.add(pre.add(code));\n-    }\n-\n-    \/*\n-     * Returns the element that is linked from the context of the referrer using\n-     * the provided signature; returns null if such element could not be found.\n-     *\n-     * This method is to be used when it is the target of the link that is\n-     * important, not the container of the link (e.g. was it an @see,\n-     * @link\/@linkplain or @snippet tags, etc.)\n-     *\/\n-    public Element getLinkedElement(Element referer, String signature) {\n-        var factory = utils.docTrees.getDocTreeFactory();\n-        var docCommentTree = utils.getDocCommentTree(referer);\n-        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n-        var reference = factory.newReferenceTree(signature);\n-        var fabricatedPath = new DocTreePath(rootPath, reference);\n-        return utils.docTrees.getElement(fabricatedPath);\n-    }\n-\n-    @Override\n-    public Content specTagOutput(Element holder, List<? extends SpecTree> specTags) {\n-        if (specTags.isEmpty()) {\n-            return Text.EMPTY;\n-        }\n-\n-        List<Content> links = specTags.stream()\n-                .map(st -> specTagToContent(holder, st))\n-                .collect(Collectors.toList());\n-\n-        \/\/ Use a different style if any link label is longer than 30 chars or contains commas.\n-        boolean hasLongLabels = links.stream().anyMatch(this::isLongOrHasComma);\n-        var specList = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n-        links.stream()\n-                .filter(Predicate.not(Content::isEmpty))\n-                .forEach(item -> specList.add(HtmlTree.LI(item)));\n-\n-        return new ContentBuilder(\n-                HtmlTree.DT(contents.externalSpecifications),\n-                HtmlTree.DD(specList));\n-    }\n-\n-    private Content specTagToContent(Element holder, SpecTree specTree) {\n-        String specTreeURL = specTree.getURL().getBody();\n-        List<? extends DocTree> specTreeLabel = specTree.getTitle();\n-        Content label = htmlWriter.commentTagsToContent(holder, specTreeLabel, isFirstSentence);\n-        return getExternalSpecContent(holder, specTree, specTreeURL,\n-                textOf(specTreeLabel).replaceAll(\"\\\\s+\", \" \"), label);\n-    }\n-\n-    Content getExternalSpecContent(Element holder, DocTree docTree, String url, String searchText, Content title) {\n-        URI specURI;\n-        try {\n-            \/\/ Use the canonical title of the spec if one is available\n-            specURI = new URI(url);\n-        } catch (URISyntaxException e) {\n-            CommentHelper ch = utils.getCommentHelper(holder);\n-            DocTreePath dtp = ch.getDocTreePath(docTree);\n-            htmlWriter.messages.error(dtp, \"doclet.Invalid_URL\", e.getMessage());\n-            specURI = null;\n-        }\n-\n-        Content titleWithAnchor = createAnchorAndSearchIndex(holder,\n-                searchText,\n-                title,\n-                resources.getText(\"doclet.External_Specification\"),\n-                docTree);\n-\n-        if (specURI == null) {\n-            return titleWithAnchor;\n-        } else {\n-            return HtmlTree.A(htmlWriter.resolveExternalSpecURI(specURI), titleWithAnchor);\n-        }\n-\n-    }\n-\n-    @Override\n-    protected Content systemPropertyTagOutput(Element element, SystemPropertyTree tag) {\n-        String tagText = tag.getPropertyName().toString();\n-        return HtmlTree.CODE(createAnchorAndSearchIndex(element, tagText,\n-                resources.getText(\"doclet.System_Property\"), tag));\n-    }\n-\n-    @Override\n-    public Content getThrowsHeader() {\n-        return HtmlTree.DT(contents.throws_);\n-    }\n-\n-    @Deprecated(forRemoval = true)\n-    private Content throwsTagOutput(Element element, ThrowsTree throwsTag, TypeMirror substituteType) {\n-        ContentBuilder body = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        Element exception = ch.getException(throwsTag);\n-        Content excName;\n-        if (substituteType != null) {\n-            excName = htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN,\n-                   substituteType));\n-        } else if (exception == null) {\n-            excName = Text.of(throwsTag.getExceptionName().toString());\n-        } else if (exception.asType() == null) {\n-            excName = Text.of(utils.getFullyQualifiedName(exception));\n-        } else {\n-            HtmlLinkInfo link = new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN,\n-                                                 exception.asType());\n-            excName = htmlWriter.getLink(link);\n-        }\n-        body.add(HtmlTree.CODE(excName));\n-        List<? extends DocTree> description = ch.getDescription(throwsTag);\n-        Content desc = htmlWriter.commentTagsToContent(element, description, context.within(throwsTag));\n-        if (desc != null && !desc.isEmpty()) {\n-            body.add(\" - \");\n-            body.add(desc);\n-        }\n-        return HtmlTree.DD(body);\n-    }\n-\n-    @Override\n-    public Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n-        var linkInfo = new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, throwsType);\n-        var link = htmlWriter.getLink(linkInfo);\n-        var concat = new ContentBuilder(HtmlTree.CODE(link));\n-        if (content.isPresent()) {\n-            concat.add(\" - \");\n-            concat.add(content.get());\n-        }\n-        return HtmlTree.DD(concat);\n-    }\n-\n-    @Override\n-    public Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink) {\n-        return includeLink\n-                ? htmlWriter.getDocLink(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, field, constantVal)\n-                : Text.of(constantVal);\n-    }\n-\n-    @Override\n-    protected Content invalidTagOutput(String summary, Optional<String> detail) {\n-        return htmlWriter.invalidTagOutput(summary,\n-                detail.isEmpty() || detail.get().isEmpty()\n-                        ? Optional.empty()\n-                        : Optional.of(Text.of(Text.normalizeNewlines(detail.get()))));\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(DocTree holder, List<? extends DocTree> tags) {\n-        return commentTagsToOutput(null, holder, tags, false);\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(Element element, List<? extends DocTree> tags) {\n-        return commentTagsToOutput(element, null, tags, false);\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(Element holder,\n-                                       DocTree holderTag,\n-                                       List<? extends DocTree> tags,\n-                                       boolean isFirstSentence)\n-    {\n-        return htmlWriter.commentTagsToContent(holder,\n-                tags, holderTag == null ? context : context.within(holderTag));\n-    }\n-\n-    @Override\n-    public BaseConfiguration configuration() {\n-        return configuration;\n-    }\n-\n-    @Override\n-    protected TypeElement getCurrentPageElement() {\n-        return htmlWriter.getCurrentPageElement();\n-    }\n-\n-    public HtmlDocletWriter getHtmlWriter() {\n-        return htmlWriter;\n-    }\n-\n-    private Content createAnchorAndSearchIndex(Element element, String tagText, String desc, DocTree tree) {\n-        return createAnchorAndSearchIndex(element, tagText, Text.of(tagText), desc, tree);\n-    }\n-\n-    @SuppressWarnings(\"preview\")\n-    private Content createAnchorAndSearchIndex(Element element, String tagText, Content tagContent, String desc, DocTree tree) {\n-        Content result = null;\n-        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n-            result = tagContent;\n-        } else {\n-            HtmlId id = HtmlIds.forText(tagText, htmlWriter.indexAnchorTable);\n-            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, tagContent);\n-            if (options.createIndex() && !tagText.isEmpty()) {\n-                String holder = getHolderName(element);\n-                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n-                        new DocLink(htmlWriter.path, id.name()));\n-                configuration.mainIndex.add(item);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    String getHolderName(Element element) {\n-        return new SimpleElementVisitor14<String, Void>() {\n-\n-            @Override\n-            public String visitModule(ModuleElement e, Void p) {\n-                return resources.getText(\"doclet.module\")\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitPackage(PackageElement e, Void p) {\n-                return resources.getText(\"doclet.package\")\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitType(TypeElement e, Void p) {\n-                return utils.getTypeElementKindName(e, true)\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitExecutable(ExecutableElement e, Void p) {\n-                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                        + \".\" + utils.getSimpleName(e)\n-                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n-            }\n-\n-            @Override\n-            public String visitVariable(VariableElement e, Void p) {\n-                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                        + \".\" + utils.getSimpleName(e);\n-            }\n-\n-            @Override\n-            public String visitUnknown(Element e, Void p) {\n-                if (e instanceof DocletElement de) {\n-                    return switch (de.getSubKind()) {\n-                        case OVERVIEW -> resources.getText(\"doclet.Overview\");\n-                        case DOCFILE -> getHolderName(de);\n-                    };\n-                } else {\n-                    return super.visitUnknown(e, p);\n-                }\n-            }\n-\n-            @Override\n-            protected String defaultAction(Element e, Void p) {\n-                return utils.getFullyQualifiedName(e);\n-            }\n-        }.visit(element);\n-    }\n-\n-    private String getHolderName(DocletElement de) {\n-        PackageElement pe = de.getPackageElement();\n-        if (pe.isUnnamed()) {\n-            \/\/ if package is unnamed use enclosing module only if it is named\n-            Element ee = pe.getEnclosingElement();\n-            if (ee instanceof ModuleElement && !((ModuleElement)ee).isUnnamed()) {\n-                return resources.getText(\"doclet.module\") + \" \" + utils.getFullyQualifiedName(ee);\n-            }\n-            return pe.toString(); \/\/ \"Unnamed package\" or similar\n-        }\n-        return resources.getText(\"doclet.package\") + \" \" + utils.getFullyQualifiedName(pe);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":0,"deletions":985,"binary":false,"changes":985,"status":"deleted"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.Messages;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A base class that implements the {@link Taglet} interface.\n+ *\/\n+public class BaseTaglet implements Taglet {\n+    \/\/ The following members are global to the lifetime of the doclet\n+    protected final HtmlConfiguration config;\n+    protected final Messages messages;\n+    protected final Resources resources;\n+    protected final Utils utils;\n+\n+    \/\/ The following members are specific to the instance of the taglet\n+    protected final DocTree.Kind tagKind;\n+    protected final String name;\n+    private final boolean inline;\n+    private final Set<Location> sites;\n+\n+    \/\/ The following is dynamically set for the duration of the methods\n+    \/\/      getInlineTagOutput and getAllBlockTagOutput\n+    \/\/ by those taglets that need to refer to it\n+    protected TagletWriter tagletWriter;\n+\n+    public BaseTaglet(HtmlConfiguration config, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n+        this(config, tagKind.tagName, tagKind, inline, sites);\n+    }\n+\n+    protected BaseTaglet(HtmlConfiguration config, String name, boolean inline, Set<Location> sites) {\n+        this(config, name, inline ? DocTree.Kind.UNKNOWN_INLINE_TAG : DocTree.Kind.UNKNOWN_BLOCK_TAG, inline, sites);\n+    }\n+\n+    private BaseTaglet(HtmlConfiguration config, String name, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n+        this.config = config;\n+        this.messages = config.getMessages();\n+        this.resources = config.getDocResources();\n+        this.utils = config.utils;\n+\n+        this.name = name;\n+        this.tagKind = tagKind;\n+        this.inline = inline;\n+        this.sites = sites;\n+    }\n+\n+    @Override\n+    public Set<Location> getAllowedLocations() {\n+        return sites;\n+    }\n+\n+    @Override\n+    public final boolean isInlineTag() {\n+        return inline;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    \/**\n+     * Returns the kind of trees recognized by this taglet.\n+     *\n+     * @return the kind of trees recognized by this taglet\n+     *\/\n+    public DocTree.Kind getTagKind() {\n+        return tagKind;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation throws {@link UnsupportedTagletOperationException}.\n+     *\/\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        throw new UnsupportedTagletOperationException(\"Method not supported in taglet \" + getName() + \".\");\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation throws {@link UnsupportedTagletOperationException}\n+     *\/\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        throw new UnsupportedTagletOperationException(\"Method not supported in taglet \" + getName() + \".\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/BaseTaglet.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+\n+\/**\n+ * A taglet that represents the {@code @deprecated} tag.\n+ *\/\n+public class DeprecatedTaglet extends BaseTaglet {\n+\n+    DeprecatedTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.DEPRECATED, false,\n+                EnumSet.of(Taglet.Location.MODULE, Taglet.Location.TYPE, Taglet.Location.CONSTRUCTOR, Taglet.Location.METHOD, Taglet.Location.FIELD));\n+\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element element, TagletWriter tagletWriter) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        ContentBuilder result = new ContentBuilder();\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(element);\n+        if (utils.isTypeElement(element)) {\n+            if (utils.isDeprecated(element)) {\n+                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                        htmlWriter.getDeprecatedPhrase(element)));\n+                if (!deprs.isEmpty()) {\n+                    List<? extends DocTree> commentTrees = ch.getDescription(deprs.get(0));\n+                    if (!commentTrees.isEmpty()) {\n+                        result.add(tagletWriter.commentTagsToOutput(element, null, commentTrees, false));\n+                    }\n+                }\n+            }\n+        } else {\n+            if (utils.isDeprecated(element)) {\n+                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                        htmlWriter.getDeprecatedPhrase(element)));\n+                if (!deprs.isEmpty()) {\n+                    List<? extends DocTree> bodyTrees = ch.getBody(deprs.get(0));\n+                    Content body = tagletWriter.commentTagsToOutput(element, null, bodyTrees, false);\n+                    if (!body.isEmpty())\n+                        result.add(HtmlTree.DIV(HtmlStyle.deprecationComment, body));\n+                }\n+            } else {\n+                Element ee = utils.getEnclosingTypeElement(element);\n+                if (utils.isDeprecated(ee)) {\n+                    result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                            htmlWriter.getDeprecatedPhrase(ee)));\n+                }\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DeprecatedTaglet.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * An inline taglet representing {@code {@docRoot}}.  This taglet is\n+ * used to get the relative path to the document's root output\n+ * directory.\n+ *\/\n+public class DocRootTaglet extends BaseTaglet {\n+    DocRootTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.DOC_ROOT, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var pathToRoot = htmlWriter.pathToRoot;\n+        return Text.of(pathToRoot.isEmpty() ? \".\" : pathToRoot.getPath());\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DocRootTaglet.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.IndexTree;\n+import com.sun.source.doctree.TextTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * An inline taglet used to index a word or a phrase.\n+ * The enclosed text is interpreted as not containing HTML markup or\n+ * nested javadoc tags.\n+ *\/\n+public class IndexTaglet extends BaseTaglet {\n+\n+    IndexTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.INDEX, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        var context = tagletWriter.context;\n+        var indexTree = (IndexTree) tag;\n+\n+        DocTree searchTerm = indexTree.getSearchTerm();\n+        String tagText = (searchTerm instanceof TextTree tt) ? tt.getBody() : \"\";\n+        if (tagText.charAt(0) == '\"' && tagText.charAt(tagText.length() - 1) == '\"') {\n+            tagText = tagText.substring(1, tagText.length() - 1);\n+        }\n+        tagText = tagText.replaceAll(\"\\\\s+\", \" \");\n+\n+        Content desc = tagletWriter.htmlWriter.commentTagsToContent(element, indexTree.getDescription(), context.within(indexTree));\n+        String descText = extractText(desc);\n+\n+        return tagletWriter.createAnchorAndSearchIndex(element, tagText, descText, tag);\n+    }\n+\n+    \/\/ ugly but simple;\n+    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n+    private String extractText(Content c) {\n+        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/IndexTaglet.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -39,0 +39,1 @@\n+\n@@ -40,1 +41,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n@@ -42,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n@@ -57,2 +57,2 @@\n-    public InheritDocTaglet() {\n-        super(DocTree.Kind.INHERIT_DOC, true, EnumSet.of(Location.METHOD));\n+    InheritDocTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.INHERIT_DOC, true, EnumSet.of(Location.METHOD));\n@@ -79,3 +79,0 @@\n-        BaseConfiguration configuration = writer.configuration();\n-        Messages messages = configuration.getMessages();\n-        Utils utils = configuration.utils;\n@@ -106,1 +103,1 @@\n-            VisibleMemberTable visibleMemberTable = configuration.getVisibleMemberTable(supertype);\n+            VisibleMemberTable visibleMemberTable = config.getVisibleMemberTable(supertype);\n@@ -145,1 +142,1 @@\n-        Taglet taglet = configuration.tagletManager.getTaglet(ch.getTagName(holderTag));\n+        Taglet taglet = config.tagletManager.getTaglet(ch.getTagName(holderTag));\n@@ -154,1 +151,1 @@\n-        InheritableTaglet.Output inheritedDoc = inheritableTaglet.inherit(method, src, holderTag, isFirstSentence, configuration);\n+        InheritableTaglet.Output inheritedDoc = inheritableTaglet.inherit(method, src, holderTag, isFirstSentence);\n@@ -185,1 +182,4 @@\n-        return retrieveInheritedDocumentation(tagletWriter, (ExecutableElement) e, (InheritDocTree) inheritDoc, tagletWriter.isFirstSentence);\n+        return retrieveInheritedDocumentation(tagletWriter,\n+                (ExecutableElement) e,\n+                (InheritDocTree) inheritDoc,\n+                tagletWriter.context.isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/InheritDocTaglet.java","additions":12,"deletions":12,"binary":false,"changes":24,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritDocTaglet.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -34,1 +34,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -40,1 +39,1 @@\n-public interface InheritableTaglet extends Taglet {\n+public interface InheritableTaglet {\n@@ -55,1 +54,1 @@\n-    Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration);\n+    Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/InheritableTaglet.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritableTaglet.java","status":"renamed"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.LinkTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+import static com.sun.source.doctree.DocTree.Kind.LINK;\n+import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n+import static com.sun.source.doctree.DocTree.Kind.SEE;\n+\n+\/**\n+ * A taglet that represents the {@code {@link ...}} and {@linkplain ...} tags,\n+ * with support for links to program elements in {@code @see} and\n+ * {@code {@snippet ...}} tags.\n+ *\/\n+public class LinkTaglet extends BaseTaglet {\n+    LinkTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        var linkTree = (LinkTree) tag;\n+        var ch = utils.getCommentHelper(element);\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        var inTags = context.inTags;\n+        if (inTags.contains(LINK) || inTags.contains(LINK_PLAIN) || inTags.contains(SEE)) {\n+            DocTreePath dtp = ch.getDocTreePath(linkTree);\n+            if (dtp != null) {\n+                messages.warning(dtp, \"doclet.see.nested_link\", \"{@\" + linkTree.getTagName() + \"}\");\n+            }\n+            Content label = htmlWriter.commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree));\n+            if (label.isEmpty()) {\n+                label = Text.of(linkTree.getReference().getSignature());\n+            }\n+            return label;\n+        }\n+\n+        var linkRef = linkTree.getReference();\n+        if (linkRef == null) {\n+            messages.warning(ch.getDocTreePath(tag), \"doclet.link.no_reference\");\n+            return tagletWriter.invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", tag.toString()),\n+                    Optional.empty());\n+        }\n+\n+        DocTree.Kind kind = tag.getKind();\n+        String refSignature = ch.getReferencedSignature(linkRef);\n+\n+        return linkSeeReferenceOutput(element,\n+                tag,\n+                refSignature,\n+                ch.getReferencedElement(tag),\n+                (kind == LINK_PLAIN),\n+                htmlWriter.commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree)),\n+                (key, args) -> messages.warning(ch.getDocTreePath(tag), key, args),\n+                tagletWriter);\n+    }\n+\n+    \/**\n+     * Worker method to generate a link from the information in different kinds of tags,\n+     * such as {@code {@link ...}} tags, {@code @see ...} tags and the {@code link} markup tag\n+     * in a {@code {@snippet ...}} tag.\n+     *\n+     * @param holder        the element that has the documentation comment containing the information\n+     * @param refTree       the tree node containing the information, or {@code null} if not available\n+     * @param refSignature  the normalized signature of the target of the reference\n+     * @param ref           the target of the reference\n+     * @param isLinkPlain   {@code true} if the link should be presented in \"plain\" font,\n+     *                      or {@code false} for \"code\" font\n+     * @param label         the label for the link,\n+     *                      or an empty item to use a default label derived from the signature\n+     * @param reportWarning a function to report warnings about issues found in the reference\n+     * @param tagletWriter  the writer providing the context for this call\n+     *\n+     * @return the output containing the generated link, or content indicating an error\n+     *\/\n+    Content linkSeeReferenceOutput(Element holder,\n+                                   DocTree refTree,\n+                                   String refSignature,\n+                                   Element ref,\n+                                   boolean isLinkPlain,\n+                                   Content label,\n+                                   BiConsumer<String, Object[]> reportWarning,\n+                                   TagletWriter tagletWriter) {\n+        var config = tagletWriter.configuration;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        Content labelContent = plainOrCode(isLinkPlain, label);\n+\n+        \/\/ The signature from the @see tag. We will output this text when a label is not specified.\n+        Content text = plainOrCode(isLinkPlain,\n+                Text.of(Objects.requireNonNullElse(refSignature, \"\")));\n+\n+        CommentHelper ch = utils.getCommentHelper(holder);\n+        TypeElement refClass = ch.getReferencedClass(ref);\n+        Element refMem =       ch.getReferencedMember(ref);\n+        String refFragment =   ch.getReferencedFragment(refSignature);\n+\n+        if (refFragment == null && refMem != null) {\n+            refFragment = refMem.toString();\n+        } else if (refFragment != null && refFragment.startsWith(\"#\")) {\n+            if (labelContent.isEmpty()) {\n+                \/\/ A non-empty label is required for fragment links as the\n+                \/\/ reference target does not provide a useful default label.\n+                htmlWriter.messages.error(ch.getDocTreePath(refTree), \"doclet.link.see.no_label\");\n+                return tagletWriter.invalidTagOutput(resources.getText(\"doclet.link.see.no_label\"),\n+                        Optional.of(refSignature));\n+            }\n+            refFragment = refFragment.substring(1);\n+        }\n+        if (refClass == null) {\n+            ModuleElement refModule = ch.getReferencedModule(ref);\n+            if (refModule != null && utils.isIncluded(refModule)) {\n+                return htmlWriter.getModuleLink(refModule, labelContent.isEmpty() ? text : labelContent, refFragment);\n+            }\n+            \/\/@see is not referencing an included class\n+            PackageElement refPackage = ch.getReferencedPackage(ref);\n+            if (refPackage != null && utils.isIncluded(refPackage)) {\n+                \/\/@see is referencing an included package\n+                if (labelContent.isEmpty()) {\n+                    labelContent = plainOrCode(isLinkPlain,\n+                            Text.of(refPackage.getQualifiedName()));\n+                }\n+                return htmlWriter.getPackageLink(refPackage, labelContent, refFragment);\n+            } else {\n+                \/\/ @see is not referencing an included class, module or package. Check for cross-links.\n+                String refModuleName =  ch.getReferencedModuleName(refSignature);\n+                DocLink elementCrossLink = (refPackage != null) ? htmlWriter.getCrossPackageLink(refPackage) :\n+                        (config.extern.isModule(refModuleName))\n+                                ? htmlWriter.getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n+                                : null;\n+                if (elementCrossLink != null) {\n+                    \/\/ Element cross-link found\n+                    return htmlWriter.links.createExternalLink(elementCrossLink,\n+                            (labelContent.isEmpty() ? text : labelContent));\n+                } else {\n+                    \/\/ No cross-link found so print warning\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n+                        reportWarning.accept(\n+                                \"doclet.link.see.reference_not_found\",\n+                                new Object[] { refSignature});\n+                    }\n+                    return htmlWriter.invalidTagOutput(resources.getText(\"doclet.link.see.reference_invalid\"),\n+                            Optional.of(labelContent.isEmpty() ? text: labelContent));\n+                }\n+            }\n+        } else if (refFragment == null) {\n+            \/\/ Must be a class reference since refClass is not null and refFragment is null.\n+            if (labelContent.isEmpty() && refTree != null) {\n+                TypeMirror referencedType = ch.getReferencedType(refTree);\n+                if (utils.isGenericType(referencedType)) {\n+                    \/\/ This is a generic type link, use the TypeMirror representation.\n+                    return plainOrCode(isLinkPlain, htmlWriter.getLink(\n+                            new HtmlLinkInfo(config, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, referencedType)));\n+                }\n+                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n+            }\n+            return htmlWriter.getLink(new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, refClass)\n+                    .label(labelContent));\n+        } else if (refMem == null) {\n+            \/\/ This is a fragment reference since refClass and refFragment are not null but refMem is null.\n+            return htmlWriter.getLink(new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, refClass)\n+                    .label(labelContent)\n+                    .fragment(refFragment)\n+                    .style(null));\n+        } else {\n+            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n+            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n+            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n+\n+            \/\/ Find the enclosing type where the method is actually visible\n+            \/\/ in the inheritance hierarchy.\n+            ExecutableElement overriddenMethod = null;\n+            if (refMem.getKind() == ElementKind.METHOD) {\n+                VisibleMemberTable vmt = config.getVisibleMemberTable(containing);\n+                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n+\n+                if (overriddenMethod != null) {\n+                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n+                }\n+            }\n+            if (refSignature.trim().startsWith(\"#\") &&\n+                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n+                \/\/ Since the link is relative and the holder is not even being\n+                \/\/ documented, this must be an inherited link.  Redirect it.\n+                \/\/ The current class either overrides the referenced member or\n+                \/\/ inherits it automatically.\n+                if (htmlWriter instanceof ClassWriterImpl cw) {\n+                    containing = cw.getTypeElement();\n+                } else if (!utils.isPublic(containing)) {\n+                    reportWarning.accept(\"doclet.link.see.reference_not_accessible\",\n+                            new Object[] { utils.getFullyQualifiedName(containing)});\n+                } else {\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n+                        reportWarning.accept(\"doclet.link.see.reference_not_found\",\n+                                new Object[] { refSignature });\n+                    }\n+                }\n+            }\n+            String refMemName = refFragment;\n+            if (config.currentTypeElement != containing) {\n+                refMemName = (utils.isConstructor(refMem))\n+                        ? refMemName\n+                        : utils.getSimpleName(containing) + \".\" + refMemName;\n+            }\n+            if (utils.isExecutableElement(refMem)) {\n+                if (refMemName.indexOf('(') < 0) {\n+                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n+                }\n+                if (overriddenMethod != null) {\n+                    \/\/ The method to actually link.\n+                    refMem = overriddenMethod;\n+                }\n+            }\n+\n+            return htmlWriter.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, containing,\n+                    refMem, (labelContent.isEmpty()\n+                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n+                            : labelContent), null, false);\n+        }\n+    }\n+\n+    private Content plainOrCode(boolean plain, Content body) {\n+        return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.LiteralTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * An inline taglet used to denote literal text, possibly in monospace font.\n+ *\n+ * For example, the text:\n+ * <blockquote>  {@code {@literal a<B>c}}  <\/blockquote>\n+ * displays as:\n+ * <blockquote>  {@literal a<B>c}  <\/blockquote>\n+ *\n+ * <p> The tag {@code {@code ...}} is equivalent to\n+ * {@code <code>{@literal ...}<\/code>}.\n+ *\n+ * For example, the text:\n+ * <blockquote>  The type {@code {@code List<P>}}  <\/blockquote>\n+ * displays as:\n+ * <blockquote>  The type {@code List<P>}  <\/blockquote>\n+ *\/\n+public class LiteralTaglet extends BaseTaglet {\n+    LiteralTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        var literalTree = (LiteralTree) tag;\n+        var body = Text.of(Text.normalizeNewlines(literalTree.getBody().getBody()));\n+        return tag.getKind() == DocTree.Kind.CODE ? HtmlTree.CODE(body) : body;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LiteralTaglet.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.ParamTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @param} tag.\n+ *\/\n+public class ParamTaglet extends BaseTaglet implements InheritableTaglet {\n+\n+    public enum ParamKind {\n+        \/** Parameter of an executable element. *\/\n+        PARAMETER,\n+        \/** State components of a record. *\/\n+        RECORD_COMPONENT,\n+        \/** Type parameters of an executable element or type element. *\/\n+        TYPE_PARAMETER\n+    }\n+\n+    private final Contents contents;\n+\n+    ParamTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.PARAM, false, EnumSet.of(Taglet.Location.TYPE, Taglet.Location.CONSTRUCTOR, Taglet.Location.METHOD));\n+        contents = config.contents;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        assert dst.getKind() == ElementKind.METHOD;\n+        assert tag.getKind() == DocTree.Kind.PARAM;\n+        var method = (ExecutableElement) dst;\n+        var param = (ParamTree) tag;\n+        \/\/ find the position of an owner parameter described by the given tag\n+        List<? extends Element> parameterElements;\n+        if (param.isTypeParameter()) {\n+            parameterElements = method.getTypeParameters();\n+        } else {\n+            parameterElements = method.getParameters();\n+        }\n+        Map<String, Integer> stringIntegerMap = mapNameToPosition(utils, parameterElements);\n+        CommentHelper ch = utils.getCommentHelper(dst);\n+        Integer position = stringIntegerMap.get(ch.getParameterName(param));\n+        if (position == null) {\n+            return new Output(null, null, List.of(), true);\n+        }\n+        \/\/ try to inherit description of the respective parameter in an overridden method\n+        try {\n+            var docFinder = utils.docFinder();\n+\n+            Optional<Documentation> r;\n+            if (src != null){\n+                r = docFinder.search((ExecutableElement) src,\n+                                m -> DocFinder.Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n+                        .toOptional();\n+            } else {\n+                r = docFinder.find((ExecutableElement) dst,\n+                                m -> DocFinder.Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n+                        .toOptional();\n+            }\n+            return r.map(result -> new Output(result.paramTree, result.method, result.paramTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n+            return new Output(null, null, List.of(), false);\n+        }\n+    }\n+\n+    \/**\n+     * Given a list of parameter elements, returns a name-position map.\n+     * @param params the list of parameters from a type or an executable member\n+     * @return a name-position map\n+     *\/\n+    private static Map<String, Integer> mapNameToPosition(Utils utils, List<? extends Element> params) {\n+        Map<String, Integer> result = new HashMap<>();\n+        int position = 0;\n+        for (Element e : params) {\n+            String name = utils.isTypeParameterElement(e)\n+                    ? utils.getTypeName(e.asType(), false)\n+                    : utils.getSimpleName(e);\n+            result.put(name, position);\n+            position++;\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        if (utils.isExecutableElement(holder)) {\n+            ExecutableElement member = (ExecutableElement) holder;\n+            Content output = convertParams(member, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(member), member.getTypeParameters(), tagletWriter);\n+            output.add(convertParams(member, ParamKind.PARAMETER,\n+                    utils.getParamTrees(member), member.getParameters(), tagletWriter));\n+            return output;\n+        } else {\n+            TypeElement typeElement = (TypeElement) holder;\n+            Content output = convertParams(typeElement, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), tagletWriter);\n+            output.add(convertParams(typeElement, ParamKind.RECORD_COMPONENT,\n+                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), tagletWriter));\n+            return output;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code Content} representation of a list of {@code ParamTree}\n+     * of the specified kind.\n+     *\n+     * <p> This method correlates a {@code ParamTree} with a parameter\n+     * {@code Element} by name. Once it's done, a particular {@code ParamTree}\n+     * is addressed by the position (index) of the correlated {@code Element}\n+     * in the list of parameter elements. This is needed for documentation\n+     * inheritance because the corresponding parameters in the inheritance\n+     * hierarchy may be named differently.\n+     *\n+     * <p> This method warns about {@code @param} tags that do not map to\n+     * parameter elements and param tags that are duplicated. <\/p>\n+     *\n+     * @param kind the kind of <em>all<\/em> parameters in the lists\n+     *\/\n+    private Content convertParams(Element e,\n+                                  ParamKind kind,\n+                                  List<ParamTree> tags,\n+                                  List<? extends Element> parameters,\n+                                  TagletWriter writer) {\n+        Map<Integer, ParamTree> tagOfPosition = new HashMap<>();\n+        CommentHelper ch = utils.getCommentHelper(e);\n+        if (!tags.isEmpty()) {\n+            Map<String, Integer> positionOfName = mapNameToPosition(utils, parameters);\n+            for (ParamTree tag : tags) {\n+                String name = ch.getParameterName(tag);\n+                String paramName = kind == ParamKind.TYPE_PARAMETER ? \"<\" + name + \">\" : name;\n+                if (!positionOfName.containsKey(name)) {\n+                    String key = switch (kind) {\n+                        case PARAMETER -> \"doclet.Parameters_warn\";\n+                        case TYPE_PARAMETER -> \"doclet.TypeParameters_warn\";\n+                        case RECORD_COMPONENT -> \"doclet.RecordComponents_warn\";\n+                    };\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n+                        messages.warning(ch.getDocTreePath(tag), key, paramName);\n+                    }\n+                }\n+                Integer position = positionOfName.get(name);\n+                if (position != null) {\n+                    if (tagOfPosition.containsKey(position)) {\n+                        String key = switch (kind) {\n+                            case PARAMETER -> \"doclet.Parameters_dup_warn\";\n+                            case TYPE_PARAMETER -> \"doclet.TypeParameters_dup_warn\";\n+                            case RECORD_COMPONENT -> \"doclet.RecordComponents_dup_warn\";\n+                        };\n+                        if (!config.isDocLintReferenceGroupEnabled()) {\n+                            messages.warning(ch.getDocTreePath(tag), key, paramName);\n+                        }\n+                    } else {\n+                        tagOfPosition.put(position, tag);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Document declared parameters for which tag documentation is available\n+        \/\/ (either directly or inherited) in order of their declaration.\n+        Content result = writer.getOutputInstance();\n+        for (int i = 0; i < parameters.size(); i++) {\n+            ParamTree tag = tagOfPosition.get(i);\n+            if (tag != null) {\n+                result.add(convertParam(e, kind, writer, tag,\n+                        ch.getParameterName(tag), result.isEmpty()));\n+            } else if (utils.isMethod(e)) {\n+                result.add(getInheritedTagletOutput(kind, e, writer,\n+                        parameters.get(i), i, result.isEmpty()));\n+            }\n+        }\n+        if (tags.size() > tagOfPosition.size()) {\n+            \/\/ Generate documentation for remaining tags that do not match a declared parameter.\n+            \/\/ These are erroneous but we generate them anyway.\n+            for (ParamTree tag : tags) {\n+                if (!tagOfPosition.containsValue(tag)) {\n+                    result.add(convertParam(e, kind, writer, tag,\n+                            ch.getParameterName(tag), result.isEmpty()));\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Tries to inherit documentation for a specific parameter (element).\n+     * If unsuccessful, the returned content is empty.\n+     *\/\n+    private Content getInheritedTagletOutput(ParamKind kind,\n+                                             Element holder,\n+                                             TagletWriter writer,\n+                                             Element param,\n+                                             int position,\n+                                             boolean isFirst) {\n+        Content result = writer.getOutputInstance();\n+        var r = utils.docFinder().search((ExecutableElement) holder,\n+                        m -> DocFinder.Result.fromOptional(extract(utils, m, position, kind == ParamTaglet.ParamKind.TYPE_PARAMETER)))\n+                .toOptional();\n+        if (r.isPresent()) {\n+            String name = kind != ParamKind.TYPE_PARAMETER\n+                    ? utils.getSimpleName(param)\n+                    : utils.getTypeName(param.asType(), false);\n+            Content content = convertParam(r.get().method, kind, writer,\n+                    r.get().paramTree, name, isFirst);\n+            result.add(content);\n+        }\n+        return result;\n+    }\n+\n+    private Content getParamHeader(ParamKind kind) {\n+        var header = switch (kind) {\n+            case PARAMETER -> contents.parameters;\n+            case TYPE_PARAMETER -> contents.typeParameters;\n+            case RECORD_COMPONENT -> contents.recordComponents;\n+        };\n+        return HtmlTree.DT(header);\n+    }\n+\n+    private Content paramTagOutput(Element element, ParamTree paramTag, String paramName) {\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var body = new ContentBuilder();\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        \/\/ define id attributes for state components so that generated descriptions may refer to them\n+        boolean defineID = (element.getKind() == ElementKind.RECORD)\n+                && !paramTag.isTypeParameter();\n+        Content nameContent = Text.of(paramName);\n+        body.add(HtmlTree.CODE(defineID ? HtmlTree.SPAN_ID(HtmlIds.forParam(paramName), nameContent) : nameContent));\n+        body.add(\" - \");\n+        List<? extends DocTree> description = ch.getDescription(paramTag);\n+        body.add(htmlWriter.commentTagsToContent(element, description, context.within(paramTag)));\n+        return HtmlTree.DD(body);\n+    }\n+\n+    private record Documentation(ParamTree paramTree, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method, Integer position, boolean typeParam) {\n+        var ch = utils.getCommentHelper(method);\n+        List<ParamTree> tags = typeParam\n+                ? utils.getTypeParamTrees(method)\n+                : utils.getParamTrees(method);\n+        List<? extends Element> parameters = typeParam\n+                ? method.getTypeParameters()\n+                : method.getParameters();\n+        var positionOfName = mapNameToPosition(utils, parameters);\n+        return tags.stream().filter(t -> position.equals(positionOfName.get(ch.getParameterName(t))))\n+                .map(t -> new Documentation(t, method)).findAny();\n+    }\n+\n+    \/**\n+     * Converts an individual {@code ParamTree} to {@code Content}, which is\n+     * prepended with the header if the parameter is first in the list.\n+     *\/\n+    private Content convertParam(Element e,\n+                                 ParamKind kind,\n+                                 TagletWriter writer,\n+                                 ParamTree paramTag,\n+                                 String name,\n+                                 boolean isFirstParam) {\n+        Content result = writer.getOutputInstance();\n+        if (isFirstParam) {\n+            result.add(getParamHeader(kind));\n+        }\n+        result.add(paramTagOutput(e, paramTag, name));\n+        return result;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ParamTaglet.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.ReturnTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @return} and {@code {@return }} tags.\n+ *\/\n+public class ReturnTaglet extends BaseTaglet implements InheritableTaglet {\n+    private final Contents contents;\n+\n+    ReturnTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.RETURN, true, EnumSet.of(Taglet.Location.METHOD));\n+        contents = config.contents;\n+    }\n+\n+    @Override\n+    public boolean isBlockTag() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        try {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> r;\n+            if (src == null) {\n+                r = docFinder.find((ExecutableElement) dst, m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            } else {\n+                r = docFinder.search((ExecutableElement) src, m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            }\n+            return r.map(result -> new Output(result.returnTree, result.method, result.returnTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n+            return new Output(null, null, List.of(), false);\n+        }\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        return returnTagOutput(element, (ReturnTree) tag, true);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        assert holder.getKind() == ElementKind.METHOD : holder.getKind();\n+        var method = (ExecutableElement) holder;\n+        this.tagletWriter = tagletWriter;\n+        List<? extends ReturnTree> tags = utils.getReturnTrees(holder);\n+\n+        \/\/ make sure we are not using @return on a method with the void return type\n+        TypeMirror returnType = utils.getReturnType(tagletWriter.getCurrentPageElement(), method);\n+        if (returnType != null && utils.isVoid(returnType)) {\n+            if (!tags.isEmpty() && !config.isDocLintReferenceGroupEnabled()) {\n+                messages.warning(holder, \"doclet.Return_tag_on_void_method\");\n+            }\n+            return null;\n+        }\n+\n+        \/\/ it would also be good to check if there are more than one @return\n+        \/\/ tags and produce a warning or error similarly to how it's done\n+        \/\/ above for a case where @return is used for void\n+\n+        var docFinder = utils.docFinder();\n+        return docFinder.search(method, m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional()\n+                .map(r -> returnTagOutput(r.method, r.returnTree, false))\n+                .orElse(null);\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code @return} tag.\n+     *\n+     * @param element   the element that owns the doc comment\n+     * @param returnTag the return tag to document\n+     * @param inline    whether this should be written as an inline instance or block instance\n+     *\n+     * @return the output\n+     *\/\n+    public Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline) {\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var ch = utils.getCommentHelper(element);\n+        List<? extends DocTree> desc = ch.getDescription(returnTag);\n+        Content content = htmlWriter.commentTagsToContent(element, desc, context.within(returnTag));\n+        return inline\n+                ? new ContentBuilder(contents.getContent(\"doclet.Returns_0\", content))\n+                : new ContentBuilder(HtmlTree.DT(contents.returns), HtmlTree.DD(content));\n+    }\n+\n+    private record Documentation(ReturnTree returnTree, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        \/\/ TODO\n+        \/\/  Using getBlockTags(..., Kind.RETURN) for clarity. Since @return has become a bimodal tag,\n+        \/\/  Utils.getReturnTrees is now a misnomer: it returns only block returns, not all returns.\n+        \/\/  We could revisit this later.\n+        Stream<? extends ReturnTree> blockTags = utils.getBlockTags(method, DocTree.Kind.RETURN, ReturnTree.class).stream();\n+        Stream<? extends ReturnTree> mainDescriptionTags = utils.getFirstSentenceTrees(method).stream()\n+                .mapMulti((t, c) -> {\n+                    if (t.getKind() == DocTree.Kind.RETURN) c.accept((ReturnTree) t);\n+                });\n+        \/\/ this method should not check validity of @return tags, hence findAny and not findFirst or what have you\n+        return Stream.concat(blockTags, mainDescriptionTags)\n+                .map(t -> new Documentation(t, method)).findAny();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ReturnTaglet.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SeeTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+public class SeeTaglet extends BaseTaglet implements InheritableTaglet {\n+    SeeTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SEE, false, EnumSet.allOf(Taglet.Location.class));\n+        contents = config.contents;\n+    }\n+\n+    private final Contents contents;\n+    private HtmlDocletWriter htmlWriter;\n+\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        CommentHelper ch = utils.getCommentHelper(dst);\n+        var path = ch.getDocTreePath(tag);\n+        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        List<? extends SeeTree> tags = utils.getSeeTrees(holder);\n+        Element e = holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+                    m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            if (result.isPresent()) {\n+                ExecutableElement m = result.get().method();\n+                tags = utils.getSeeTrees(m);\n+                e = m;\n+            }\n+        }\n+        return seeTagOutput(e, tags);\n+    }\n+\n+    \/**\n+     * Returns the output for {@code @see} tags.\n+     *\n+     * @param holder The element that owns the doc comment\n+     * @param seeTags the list of tags\n+     *\n+     * @return the output\n+     *\/\n+    public Content seeTagOutput(Element holder, List<? extends SeeTree> seeTags) {\n+        htmlWriter = tagletWriter.htmlWriter;\n+\n+        List<Content> links = new ArrayList<>();\n+        for (SeeTree dt : seeTags) {\n+            links.add(seeTagOutput(holder, dt));\n+        }\n+        if (utils.isVariableElement(holder) && ((VariableElement)holder).getConstantValue() != null &&\n+                htmlWriter instanceof ClassWriterImpl classWriter) {\n+            \/\/Automatically add link to constant values page for constant fields.\n+            DocPath constantsPath =\n+                    htmlWriter.pathToRoot.resolve(DocPaths.CONSTANT_VALUES);\n+            String whichConstant =\n+                    classWriter.getTypeElement().getQualifiedName() + \".\" +\n+                            utils.getSimpleName(holder);\n+            DocLink link = constantsPath.fragment(whichConstant);\n+            links.add(htmlWriter.links.createLink(link,\n+                    contents.getContent(\"doclet.Constants_Summary\")));\n+        }\n+        if (utils.isClass(holder) && utils.isSerializable((TypeElement)holder)) {\n+            \/\/Automatically add link to serialized form page for serializable classes.\n+            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n+                    SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n+                DocPath serialPath = htmlWriter.pathToRoot.resolve(DocPaths.SERIALIZED_FORM);\n+                DocLink link = serialPath.fragment(utils.getFullyQualifiedName(holder));\n+                links.add(htmlWriter.links.createLink(link,\n+                        contents.getContent(\"doclet.Serialized_Form\")));\n+            }\n+        }\n+        if (links.isEmpty()) {\n+            return Text.EMPTY;\n+        }\n+\n+        var seeList = tagletWriter.tagList(links);\n+        return new ContentBuilder(\n+                HtmlTree.DT(contents.seeAlso),\n+                HtmlTree.DD(seeList));\n+    }\n+\n+    private record Documentation(List<? extends SeeTree> seeTrees, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SeeTree> tags = utils.getSeeTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n+    }\n+\n+    \/**\n+     * {@return the output for a single {@code @see} tag}\n+     *\n+     * @param element the element that has the documentation comment containing this tag\n+     * @param seeTag  the tag\n+     *\/\n+    private Content seeTagOutput(Element element, SeeTree seeTag) {\n+\n+        List<? extends DocTree> ref = seeTag.getReference();\n+        assert !ref.isEmpty();\n+        DocTree ref0 = ref.get(0);\n+        switch (ref0.getKind()) {\n+            case TEXT, START_ELEMENT -> {\n+                \/\/ @see \"Reference\"\n+                \/\/ @see <a href=\"...\">...<\/a>\n+                return htmlWriter.commentTagsToContent(element, ref, false, false);\n+            }\n+\n+            case REFERENCE -> {\n+                \/\/ @see reference label...\n+                CommentHelper ch = utils.getCommentHelper(element);\n+                String refSignature = ch.getReferencedSignature(ref0);\n+                List<? extends DocTree> label = ref.subList(1, ref.size());\n+\n+                var lt = (LinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n+                return lt.linkSeeReferenceOutput(element,\n+                        seeTag,\n+                        refSignature,\n+                        ch.getReferencedElement(seeTag),\n+                        false,\n+                        htmlWriter.commentTagsToContent(element, label, tagletWriter.getContext().within(seeTag)),\n+                        (key, args) -> messages.warning(ch.getDocTreePath(seeTag), key, args),\n+                        tagletWriter\n+                );\n+            }\n+\n+            case ERRONEOUS -> {\n+                return tagletWriter.invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n+                                ref0.toString()),\n+                        Optional.empty());\n+            }\n+\n+            default -> throw new IllegalStateException(ref0.getKind().toString());\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SeeTaglet.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+\n+import com.sun.source.doctree.BlockTagTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.UnknownBlockTagTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+\n+\/**\n+ * A custom single-argument block tag.\n+ *\/\n+public class SimpleTaglet extends BaseTaglet implements InheritableTaglet {\n+\n+    \/**\n+     * The header to output.\n+     *\/\n+    private final String header;\n+\n+    private final boolean enabled;\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *                  The string can contain 'p' for package, 't' for type,\n+     *                  'm' for method, 'c' for constructor and 'f' for field.\n+     *                  See {@link #getLocations(String) getLocations} for the\n+     *                  complete list.\n+     *\/\n+    SimpleTaglet(HtmlConfiguration config, String tagName, String header, String locations) {\n+        this(config, tagName, header, getLocations(locations), isEnabled(locations));\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagKind   the kind of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    SimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations) {\n+        this(config, tagKind, header, locations, true);\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    SimpleTaglet(HtmlConfiguration config, String tagName, String header, Set<Taglet.Location> locations) {\n+        this(config, tagName, header, locations, true);\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    private SimpleTaglet(HtmlConfiguration config, String tagName, String header, Set<Taglet.Location> locations, boolean enabled) {\n+        super(config, tagName, false, locations);\n+        this.header = header;\n+        this.enabled = enabled;\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagKind   the kind of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    protected SimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations, boolean enabled) {\n+        super(config, tagKind, false, locations);\n+        this.header = header;\n+        this.enabled = enabled;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        assert dst.getKind() == ElementKind.METHOD;\n+        assert !isFirstSentence;\n+        try {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> r;\n+            if (src == null) {\n+                r = docFinder.find((ExecutableElement) dst,\n+                        m -> DocFinder.Result.fromOptional(extractFirst(m))).toOptional();\n+            } else {\n+                r = docFinder.search((ExecutableElement) src,\n+                        m -> DocFinder.Result.fromOptional(extractFirst(m))).toOptional();\n+            }\n+            return r.map(result -> new Output(result.tag, result.method, result.description, true))\n+                    .orElseGet(()->new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n+            return new Output(null, null, List.of(), false);\n+        }\n+    }\n+\n+    \/**\n+     * Whether the taglet should generate output.\n+     * Standard tags like {@code @author}, {@code @since}, {@code @version} can\n+     * be disabled by command-line options; custom tags created with -tag can be\n+     * disabled with an X in the defining string.\n+     *\/\n+    boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    \/**\n+     * Returns whether this taglet accepts a {@code BlockTagTree} node.\n+     * The taglet accepts a tree node if it has the same kind, and\n+     * if the kind is {@code UNKNOWN_BLOCK_TAG} the same tag name.\n+     *\n+     * @param tree the tree node\n+     * @return {@code true} if this taglet accepts this tree node\n+     *\/\n+    private boolean accepts(BlockTagTree tree) {\n+        return (tree.getKind() == DocTree.Kind.UNKNOWN_BLOCK_TAG && tagKind == DocTree.Kind.UNKNOWN_BLOCK_TAG)\n+                ? tree.getTagName().equals(name)\n+                : tree.getKind() == tagKind;\n+    }\n+\n+    record Documentation(DocTree tag, List<? extends DocTree> description, ExecutableElement method) { }\n+\n+    private Optional<Documentation> extractFirst(ExecutableElement m) {\n+        List<? extends DocTree> tags = utils.getBlockTags(m, this::accepts);\n+        if (tags.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        DocTree t = tags.get(0);\n+        return Optional.of(new Documentation(t, utils.getCommentHelper(m).getDescription(t), m));\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        List<? extends DocTree> tags = utils.getBlockTags(holder, this::accepts);\n+        if (header == null || tags.isEmpty()) {\n+            return null;\n+        }\n+        return simpleBlockTagOutput(holder, tags, header, tagletWriter);\n+    }\n+\n+    \/**\n+     * Returns the output for a series of simple tags.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param simpleTags the list of simple tags\n+     * @param header     the header for the series of tags\n+     *\n+     * @return the output\n+     *\/\n+    private Content simpleBlockTagOutput(Element element,\n+                                        List<? extends DocTree> simpleTags,\n+                                        String header,\n+                                        TagletWriter writer) {\n+        var ch = utils.getCommentHelper(element);\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        ContentBuilder body = new ContentBuilder();\n+        boolean many = false;\n+        for (DocTree simpleTag : simpleTags) {\n+            if (many) {\n+                body.add(\", \");\n+            }\n+            List<? extends DocTree> bodyTags = ch.getBody(simpleTag);\n+            body.add(htmlWriter.commentTagsToContent(element, bodyTags, context.within(simpleTag)));\n+            many = true;\n+        }\n+        return new ContentBuilder(\n+                HtmlTree.DT(RawHtml.of(header)),\n+                HtmlTree.DD(body));\n+    }\n+\n+    private static Set<Taglet.Location> getLocations(String locations) {\n+        Set<Taglet.Location> set = EnumSet.noneOf(Taglet.Location.class);\n+        for (int i = 0; i < locations.length(); i++) {\n+            switch (locations.charAt(i)) {\n+                case 'a':  case 'A':\n+                    return EnumSet.allOf(Taglet.Location.class);\n+                case 'c':  case 'C':\n+                    set.add(Taglet.Location.CONSTRUCTOR);\n+                    break;\n+                case 'f':  case 'F':\n+                    set.add(Taglet.Location.FIELD);\n+                    break;\n+                case 'm':  case 'M':\n+                    set.add(Taglet.Location.METHOD);\n+                    break;\n+                case 'o':  case 'O':\n+                    set.add(Taglet.Location.OVERVIEW);\n+                    break;\n+                case 'p':  case 'P':\n+                    set.add(Taglet.Location.PACKAGE);\n+                    break;\n+                case 's':  case 'S':        \/\/ super-packages, anyone?\n+                    set.add(Taglet.Location.MODULE);\n+                    break;\n+                case 't':  case 'T':\n+                    set.add(Taglet.Location.TYPE);\n+                    break;\n+                case 'x':  case 'X':\n+                    break;\n+            }\n+        }\n+        return set;\n+    }\n+\n+    private static boolean isEnabled(String locations) {\n+        return locations.matches(\"[^Xx]*\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SimpleTaglet.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -0,0 +1,590 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.io.IOException;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.PackageElement;\n+import javax.tools.Diagnostic;\n+import javax.tools.DocumentationTool;\n+import javax.tools.FileObject;\n+\n+import com.sun.source.doctree.AttributeTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.Action;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.ParseException;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.Parser;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.Style;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.StyledText;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @snippet} tag.\n+ *\/\n+public class SnippetTaglet extends BaseTaglet {\n+\n+    public enum Language {\n+\n+        JAVA(\"java\"),\n+        PROPERTIES(\"properties\");\n+\n+        private static final Map<String, Language> languages;\n+\n+        static {\n+            Map<String, Language> tmp = new HashMap<>();\n+            for (var language : values()) {\n+                String id = Objects.requireNonNull(language.identifier);\n+                if (tmp.put(id, language) != null)\n+                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n+            }\n+            languages = Map.copyOf(tmp);\n+        }\n+\n+        Language(String id) {\n+            identifier = id;\n+        }\n+\n+        private final String identifier;\n+\n+        public static Optional<Language> of(String identifier) {\n+            if (identifier == null)\n+                return Optional.empty();\n+            return Optional.ofNullable(languages.get(identifier));\n+        }\n+\n+        public String getIdentifier() {return identifier;}\n+    }\n+\n+    SnippetTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    \/*\n+     * A snippet can specify content by value (inline), by reference (external)\n+     * or both (hybrid).\n+     *\n+     * To specify content by value, a snippet uses its body; the body of\n+     * a snippet is the content.\n+     *\n+     * To specify content by reference, a snippet uses either the \"class\"\n+     * or \"file\" attribute; the value of that attribute refers to the content.\n+     *\n+     * A snippet can specify the \"region\" attribute. That attribute refines\n+     * the location of the content. The value of that attribute must match\n+     * one of the named regions in the snippets content.\n+     *\/\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        try {\n+            return generateContent(holder, tag);\n+        } catch (BadSnippetException e) {\n+            error(tagletWriter, holder, e.tag(), e.key(), e.args());\n+            String details = config.getDocResources().getText(e.key(), e.args());\n+            return badSnippet(tagletWriter, Optional.of(details));\n+        }\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code {@snippet ...}} tag.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param tag        the snippet tag\n+     * @param id         the value of the id attribute, or null if not defined\n+     * @param lang       the value of the lang attribute, or null if not defined\n+     *\n+     * @return the output\n+     *\/\n+    private Content snippetTagOutput(Element element, SnippetTree tag, StyledText content,\n+                                       String id, String lang) {\n+        var pathToRoot = tagletWriter.htmlWriter.pathToRoot;\n+        var pre = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n+        if (id != null && !id.isBlank()) {\n+            pre.put(HtmlAttr.ID, id);\n+        }\n+        var code = new HtmlTree(TagName.CODE)\n+                .addUnchecked(Text.EMPTY); \/\/ Make sure the element is always rendered\n+        if (lang != null && !lang.isBlank()) {\n+            code.addStyle(\"language-\" + lang);\n+        }\n+\n+        content.consumeBy((styles, sequence) -> {\n+            CharSequence text = Text.normalizeNewlines(sequence);\n+            if (styles.isEmpty()) {\n+                code.add(text);\n+            } else {\n+                Element e = null;\n+                String t = null;\n+                boolean linkEncountered = false;\n+                boolean markupEncountered = false;\n+                Set<String> classes = new HashSet<>();\n+                for (Style s : styles) {\n+                    if (s instanceof Style.Name n) {\n+                        classes.add(n.name());\n+                    } else if (s instanceof Style.Link l) {\n+                        assert !linkEncountered; \/\/ TODO: do not assert; pick the first link report on subsequent\n+                        linkEncountered = true;\n+                        t = l.target();\n+                        e = getLinkedElement(element, t);\n+                        if (e == null) {\n+                            \/\/ TODO: diagnostic output\n+                        }\n+                    } else if (s instanceof Style.Markup) {\n+                        markupEncountered = true;\n+                        break;\n+                    } else {\n+                        \/\/ TODO: transform this if...else into an exhaustive\n+                        \/\/ switch over the sealed Style hierarchy when \"Pattern\n+                        \/\/ Matching for switch\" has been implemented (JEP 406\n+                        \/\/ and friends)\n+                        throw new AssertionError(styles);\n+                    }\n+                }\n+                Content c;\n+                if (markupEncountered) {\n+                    return;\n+                } else if (linkEncountered) {\n+                    assert e != null;\n+                    \/\/disable preview tagging inside the snippets:\n+                    Utils.PreviewFlagProvider prevPreviewProvider = utils.setPreviewFlagProvider(el -> false);\n+                    try {\n+                        var lt = (LinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n+                        c = lt.linkSeeReferenceOutput(element,\n+                                null,\n+                                t,\n+                                e,\n+                                false, \/\/ TODO: for now\n+                                Text.of(sequence.toString()),\n+                                (key, args) -> { \/* TODO: report diagnostic *\/ },\n+                                tagletWriter);\n+                    } finally {\n+                        utils.setPreviewFlagProvider(prevPreviewProvider);\n+                    }\n+                } else {\n+                    c = HtmlTree.SPAN(Text.of(text));\n+                    classes.forEach(((HtmlTree) c)::addStyle);\n+                }\n+                code.add(c);\n+            }\n+        });\n+        String copyText = resources.getText(\"doclet.Copy_to_clipboard\");\n+        String copiedText = resources.getText(\"doclet.Copied_to_clipboard\");\n+        String copySnippetText = resources.getText(\"doclet.Copy_snippet_to_clipboard\");\n+        var snippetContainer = HtmlTree.DIV(HtmlStyle.snippetContainer,\n+                new HtmlTree(TagName.BUTTON)\n+                        .add(HtmlTree.SPAN(Text.of(copyText))\n+                                .put(HtmlAttr.DATA_COPIED, copiedText))\n+                        .add(new HtmlTree(TagName.IMG)\n+                                .put(HtmlAttr.SRC, pathToRoot.resolve(DocPaths.CLIPBOARD_SVG).getPath())\n+                                .put(HtmlAttr.ALT, copySnippetText))\n+                        .addStyle(HtmlStyle.copy)\n+                        .addStyle(HtmlStyle.snippetCopy)\n+                        .put(HtmlAttr.ARIA_LABEL, copySnippetText)\n+                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\"));\n+        return snippetContainer.add(pre.add(code));\n+    }\n+\n+    private static final class BadSnippetException extends Exception {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 1;\n+\n+        private final transient DocTree tag;\n+        private final String key;\n+        private final transient Object[] args;\n+\n+        BadSnippetException(DocTree tag, String key, Object... args) {\n+            this.tag = tag;\n+            this.key = key;\n+            this.args = args;\n+        }\n+\n+        DocTree tag() {\n+            return tag;\n+        }\n+\n+        String key() {\n+            return key;\n+        }\n+\n+        Object[] args() {\n+            return args;\n+        }\n+    }\n+\n+    private Content generateContent(Element holder, DocTree tag)\n+            throws BadSnippetException\n+    {\n+        SnippetTree snippetTag = (SnippetTree) tag;\n+\n+        \/\/ organize snippet attributes in a map, performing basic checks along the way\n+        Map<String, AttributeTree> attributes = new HashMap<>();\n+        for (DocTree d : snippetTag.getAttributes()) {\n+            if (!(d instanceof AttributeTree a)) {\n+                continue; \/\/ this might be an ErroneousTree\n+            }\n+            if (attributes.putIfAbsent(a.getName().toString(), a) == null) {\n+                continue;\n+            }\n+            \/\/ two like-named attributes found; although we report on the most\n+            \/\/ recently encountered of the two, the iteration order might differ\n+            \/\/ from the source order (see JDK-8266826)\n+            throw new BadSnippetException(a, \"doclet.tag.attribute.repeated\",\n+                    a.getName().toString());\n+        }\n+\n+        final String CLASS = \"class\";\n+        final String FILE = \"file\";\n+\n+        final boolean containsClass = attributes.containsKey(CLASS);\n+        final boolean containsFile = attributes.containsKey(FILE);\n+        final boolean containsBody = snippetTag.getBody() != null;\n+\n+        if (containsClass && containsFile) {\n+            throw new BadSnippetException(attributes.get(CLASS),\n+                    \"doclet.snippet.contents.ambiguity.external\");\n+        } else if (!containsClass && !containsFile && !containsBody) {\n+            throw new BadSnippetException(tag, \"doclet.snippet.contents.none\");\n+        }\n+\n+        String regionName = null;\n+        AttributeTree region = attributes.get(\"region\");\n+        if (region != null) {\n+            regionName = stringValueOf(region);\n+            if (regionName.isBlank()) {\n+                throw new BadSnippetException(region, \"doclet.tag.attribute.value.illegal\",\n+                        \"region\", region.getValue());\n+            }\n+        }\n+\n+        String inlineContent = null, externalContent = null;\n+\n+        if (containsBody) {\n+            inlineContent = snippetTag.getBody().getBody();\n+        }\n+\n+        FileObject fileObject = null;\n+\n+        if (containsFile || containsClass) {\n+            AttributeTree a;\n+            String v = containsFile\n+                    ? stringValueOf((a = attributes.get(FILE)))\n+                    : stringValueOf((a = attributes.get(CLASS))).replace(\".\", \"\/\") + \".java\";\n+\n+            if (v.isBlank()) {\n+                throw new BadSnippetException(a, \"doclet.tag.attribute.value.illegal\",\n+                        containsFile ? FILE : CLASS, v);\n+            }\n+\n+            \/\/ we didn't create JavaFileManager, so we won't close it; even if an error occurs\n+            var fileManager = config.getFileManager();\n+\n+            try {\n+                \/\/ first, look in local snippet-files subdirectory\n+                var pkg = getPackageElement(holder, utils);\n+                var pkgLocation = utils.getLocationForPackage(pkg);\n+                var pkgName = pkg.getQualifiedName().toString(); \/\/ note: empty string for unnamed package\n+                var relativeName = \"snippet-files\/\" + v;\n+                fileObject = fileManager.getFileForInput(pkgLocation, pkgName, relativeName);\n+\n+                \/\/ if not found in local snippet-files directory, look on snippet path\n+                if (fileObject == null && fileManager.hasLocation(DocumentationTool.Location.SNIPPET_PATH)) {\n+                    fileObject = fileManager.getFileForInput(DocumentationTool.Location.SNIPPET_PATH, \"\", v);\n+                }\n+            } catch (IOException | IllegalArgumentException e) { \/\/ TODO: test this when JDK-8276892 is integrated\n+                \/\/ JavaFileManager.getFileForInput can throw IllegalArgumentException in certain cases\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e);\n+            }\n+\n+            if (fileObject == null) {\n+                \/\/ i.e. the file does not exist\n+                throw new BadSnippetException(a, \"doclet.snippet_file_not_found\", v);\n+            }\n+\n+            try {\n+                externalContent = fileObject.getCharContent(true).toString();\n+            } catch (IOException e) {  \/\/ TODO: test this when JDK-8276892 is integrated\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\",\n+                        fileObject.getName(), e);\n+            }\n+        }\n+\n+        String lang = null;\n+        AttributeTree langAttr = attributes.get(\"lang\");\n+        if (langAttr != null) {\n+            lang = stringValueOf(langAttr);\n+        } else if (containsClass) {\n+            lang = \"java\";\n+        } else if (containsFile) {\n+            lang = languageFromFileName(fileObject.getName());\n+        }\n+\n+        Optional<Language> language = Language.of(lang);\n+\n+\n+        \/\/ TODO cache parsed external snippet (WeakHashMap)\n+\n+        StyledText inlineSnippet = null;\n+        StyledText externalSnippet = null;\n+\n+        try {\n+            Diags d = (text, pos) -> {\n+                var path = utils.getCommentHelper(holder)\n+                        .getDocTreePath(snippetTag.getBody());\n+                config.getReporter().print(Diagnostic.Kind.WARNING,\n+                        path, pos, pos, pos, text);\n+            };\n+            if (inlineContent != null) {\n+                inlineSnippet = parse(resources, d, language, inlineContent);\n+            }\n+        } catch (ParseException e) {\n+            var path = utils.getCommentHelper(holder)\n+                    .getDocTreePath(snippetTag.getBody());\n+            \/\/ TODO: there should be a method in Messages; that method should mirror Reporter's; use that method instead accessing Reporter.\n+            String msg = resources.getText(\"doclet.snippet.markup\", e.getMessage());\n+            config.getReporter().print(Diagnostic.Kind.ERROR,\n+                    path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n+            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n+        }\n+\n+        try {\n+            var finalFileObject = fileObject;\n+            Diags d = (text, pos) -> messages.warning(finalFileObject, pos, pos, pos, text);\n+            if (externalContent != null) {\n+                externalSnippet = parse(resources, d, language, externalContent);\n+            }\n+        } catch (ParseException e) {\n+            assert fileObject != null;\n+            messages.error(fileObject, e.getPosition(),\n+                    e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n+            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n+        }\n+\n+        \/\/ the region must be matched at least in one content: it can be matched\n+        \/\/ in both, but never in none\n+        if (regionName != null) {\n+            StyledText r1 = null;\n+            StyledText r2 = null;\n+            if (inlineSnippet != null) {\n+                r1 = inlineSnippet.getBookmarkedText(regionName);\n+                if (r1 != null) {\n+                    inlineSnippet = r1;\n+                }\n+            }\n+            if (externalSnippet != null) {\n+                r2 = externalSnippet.getBookmarkedText(regionName);\n+                if (r2 != null) {\n+                    externalSnippet = r2;\n+                }\n+            }\n+            if (r1 == null && r2 == null) {\n+                throw new BadSnippetException(tag, \"doclet.snippet.region.not_found\", regionName);\n+            }\n+        }\n+\n+        if (inlineSnippet != null) {\n+            inlineSnippet = toDisplayForm(inlineSnippet);\n+        }\n+\n+        if (externalSnippet != null) {\n+            externalSnippet = toDisplayForm(externalSnippet);\n+        }\n+\n+        if (inlineSnippet != null && externalSnippet != null) {\n+            String inlineStr = inlineSnippet.asCharSequence().toString();\n+            String externalStr = externalSnippet.asCharSequence().toString();\n+            if (!Objects.equals(inlineStr, externalStr)) {\n+                throw new BadSnippetException(tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n+            }\n+        }\n+\n+        assert inlineSnippet != null || externalSnippet != null;\n+        StyledText text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n+\n+        AttributeTree idAttr = attributes.get(\"id\");\n+        String id = idAttr == null\n+                ? null\n+                : stringValueOf(idAttr);\n+\n+        return snippetTagOutput(holder, snippetTag, text, id, lang);\n+    }\n+\n+    \/*\n+     * Maybe there's a case for implementing a proper (or at least more helpful)\n+     * diff view, but for now simply outputting both sides of a hybrid snippet\n+     * would do. A user could then use a diff tool of their choice to compare\n+     * those sides.\n+     *\n+     * There's a separate issue of mapping discrepancies back to their\n+     * originating source in the doc comment and the external file. Maybe there\n+     * is a value in it, or maybe there isn't. In any case, accurate mapping\n+     * would not be trivial to code.\n+     *\/\n+    private static String diff(String inline, String external) {\n+        return \"\"\"\n+               ----------------- inline -------------------\n+               %s\n+               ----------------- external -----------------\n+               %s\n+               \"\"\".formatted(inline, external);\n+    }\n+\n+    private StyledText parse(Resources resources, Diags diags, Optional<Language> language, String content) throws ParseException {\n+        Parser.Result result = new Parser(resources).parse(diags, language, content);\n+        result.actions().forEach(Action::perform);\n+        return result.text();\n+    }\n+\n+    public interface Diags {\n+        void warn(String text, int pos);\n+    }\n+\n+    private static String stringValueOf(AttributeTree at) throws BadSnippetException {\n+        if (at.getValueKind() == AttributeTree.ValueKind.EMPTY) {\n+            throw new BadSnippetException(at, \"doclet.tag.attribute.value.missing\",\n+                    at.getName().toString());\n+        }\n+        return at.getValue().stream()\n+                \/\/ value consists of TextTree or ErroneousTree nodes;\n+                \/\/ ErroneousTree is a subtype of TextTree\n+                .map(t -> ((TextTree) t).getBody())\n+                .collect(Collectors.joining());\n+    }\n+\n+    private String languageFromFileName(String fileName) {\n+        \/\/ TODO: find a way to extend\/customize the list of recognized file name extensions\n+        if (fileName.endsWith(\".java\")) {\n+            return \"java\";\n+        } else if (fileName.endsWith(\".properties\")) {\n+            return \"properties\";\n+        }\n+        return null;\n+    }\n+\n+    private void error(TagletWriter writer, Element holder, DocTree tag, String key, Object... args) {\n+        messages.error(utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n+    }\n+\n+    private Content badSnippet(TagletWriter writer, Optional<String> details) {\n+        var resources = config.getDocResources();\n+        return writer.invalidTagOutput(resources.getText(\"doclet.tag.invalid\", \"snippet\"), details);\n+    }\n+\n+    private static PackageElement getPackageElement(Element e, Utils utils) {\n+        if (e instanceof DocletElement de) {\n+            return de.getPackageElement();\n+        } else {\n+            return utils.elementUtils.getPackageOf(e);\n+        }\n+    }\n+\n+    \/*\n+     * Returns a version of styled text that can be rendered into HTML or\n+     * compared to another such version. The latter is used to decide if inline\n+     * and external parts of a hybrid snippet match.\n+     *\n+     * Use this method to obtain a final version of text. After all\n+     * transformations on text have been performed, call this method with that\n+     * text and then use the returned result as described above.\n+     *\/\n+    private static StyledText toDisplayForm(StyledText source) {\n+        var sourceString = source.asCharSequence().toString();\n+        var result = new StyledText();\n+        var originalLines = sourceString.lines().iterator();\n+        var unindentedLines = sourceString.stripIndent().lines().iterator();\n+        \/\/ done; the rest of the method translates the stripIndent\n+        \/\/ transformation performed on a character sequence to the styled\n+        \/\/ text that this sequence originates from, line by line\n+        int pos = 0;\n+        \/\/ overcome a \"quirk\" of String.lines\n+        boolean endsWithLineFeed = !sourceString.isEmpty() && sourceString.charAt(source.length() - 1) == '\\n';\n+        while (originalLines.hasNext() && unindentedLines.hasNext()) { \/\/ [^1]\n+            String originalLine = originalLines.next();\n+            String unindentedLine = unindentedLines.next();\n+            \/\/ the search MUST succeed\n+            int idx = originalLine.indexOf(unindentedLine);\n+            \/\/ assume newlines are always of the \\n form\n+            \/\/ append the found fragment\n+            result.append(source.subText(pos + idx, pos + idx + unindentedLine.length()));\n+            \/\/ append the possibly styled newline, but not if it's the last line\n+            int eol = pos + originalLine.length();\n+            if (originalLines.hasNext() || endsWithLineFeed) {\n+                result.append(source.subText(eol, eol + 1));\n+            }\n+            pos = eol + 1;\n+        }\n+        return result;\n+        \/\/ [^1]: Checking hasNext() on both iterators might look unnecessary.\n+        \/\/ However, there are strings for which those iterators return different\n+        \/\/ number of lines. That is, there exists a string s, such that\n+        \/\/\n+        \/\/     s.lines().count() != s.stripIndent().lines().count()\n+        \/\/\n+        \/\/ The most trivial example of such a string is \" \". In fact, any string\n+        \/\/ with a trailing non-empty blank line would do.\n+    }\n+\n+    \/*\n+     * Returns the element that is linked from the context of the referrer using\n+     * the provided signature; returns null if such element could not be found.\n+     *\n+     * This method is to be used when it is the target of the link that is\n+     * important, not the container of the link (e.g. was it an @see,\n+     * @link\/@linkplain or @snippet tags, etc.)\n+     *\/\n+    private Element getLinkedElement(Element referer, String signature) {\n+        var factory = utils.docTrees.getDocTreeFactory();\n+        var docCommentTree = utils.getDocCommentTree(referer);\n+        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n+        var reference = factory.newReferenceTree(signature);\n+        var fabricatedPath = new DocTreePath(rootPath, reference);\n+        return utils.docTrees.getElement(fabricatedPath);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SnippetTaglet.java","additions":590,"deletions":0,"binary":false,"changes":590,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SpecTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @spec} tag.\n+ *\/\n+public class SpecTaglet extends BaseTaglet implements InheritableTaglet {\n+    private final Contents contents;\n+\n+    SpecTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SPEC, false, EnumSet.allOf(Taglet.Location.class));\n+        this.contents = config.contents;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        CommentHelper ch = utils.getCommentHelper(dst);\n+        var path = ch.getDocTreePath(tag);\n+        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        List<? extends SpecTree> tags = utils.getSpecTrees(holder);\n+        Element e = holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+                    m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            if (result.isPresent()) {\n+                e = result.get().method();\n+                tags = result.get().specTrees();\n+            }\n+        }\n+        return specTagOutput(e, tags);\n+    }\n+\n+    \/**\n+     * Returns the output for one or more {@code @spec} tags.\n+     *\n+     * @param holder  the element that owns the doc comment\n+     * @param specTags the array of @spec tags.\n+     *\n+     * @return the output\n+     *\/\n+    public Content specTagOutput(Element holder, List<? extends SpecTree> specTags) {\n+        if (specTags.isEmpty()) {\n+            return Text.EMPTY;\n+        }\n+\n+        var links = specTags.stream()\n+                .map(st -> specTagToContent(holder, st)).toList();\n+\n+        var specList = tagletWriter.tagList(links);\n+        return new ContentBuilder(\n+                HtmlTree.DT(contents.externalSpecifications),\n+                HtmlTree.DD(specList));\n+    }\n+\n+    private record Documentation(List<? extends SpecTree> specTrees, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SpecTree> tags = utils.getSpecTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n+    }\n+\n+    private Content specTagToContent(Element holder, SpecTree specTree) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        String specTreeURL = specTree.getURL().getBody();\n+        List<? extends DocTree> specTreeLabel = specTree.getTitle();\n+        Content label = htmlWriter.commentTagsToContent(holder, specTreeLabel, tagletWriter.context.isFirstSentence);\n+        return getExternalSpecContent(holder, specTree, specTreeURL,\n+                textOf(specTreeLabel).replaceAll(\"\\\\s+\", \" \"), label);\n+    }\n+\n+    private String textOf(List<? extends DocTree> trees) {\n+        return trees.stream()\n+                .filter(dt -> dt instanceof TextTree)\n+                .map(dt -> ((TextTree) dt).getBody().trim())\n+                .collect(Collectors.joining(\" \"));\n+    }\n+\n+    Content getExternalSpecContent(Element holder,\n+                                   DocTree docTree,\n+                                   String url,\n+                                   String searchText,\n+                                   Content title) {\n+        URI specURI;\n+        try {\n+            \/\/ Use the canonical title of the spec if one is available\n+            specURI = new URI(url);\n+        } catch (URISyntaxException e) {\n+            CommentHelper ch = utils.getCommentHelper(holder);\n+            DocTreePath dtp = ch.getDocTreePath(docTree);\n+            tagletWriter.htmlWriter.messages.error(dtp, \"doclet.Invalid_URL\", e.getMessage());\n+            specURI = null;\n+        }\n+\n+        Content titleWithAnchor = tagletWriter.createAnchorAndSearchIndex(holder,\n+                searchText,\n+                title,\n+                resources.getText(\"doclet.External_Specification\"),\n+                docTree);\n+\n+        if (specURI == null) {\n+            return titleWithAnchor;\n+        } else {\n+            var htmlWriter = tagletWriter.htmlWriter;\n+            return HtmlTree.A(htmlWriter.resolveExternalSpecURI(specURI), titleWithAnchor);\n+        }\n+\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SpecTaglet.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SummaryTree;\n+\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * A taglet that represents the {@code {@summary}} tag.\n+ *\/\n+public class SummaryTaglet extends BaseTaglet {\n+\n+    SummaryTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SUMMARY, true, EnumSet.allOf(Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        return tagletWriter.commentTagsToOutput(holder, tag, ((SummaryTree)tag).getSummary(),\n+                tagletWriter.context.isFirstSentence);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SummaryTaglet.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SystemPropertyTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * A taglet that represents the {@code @systemProperty} tag.\n+ *\/\n+public class SystemPropertyTaglet extends BaseTaglet {\n+\n+    SystemPropertyTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SYSTEM_PROPERTY, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        return systemPropertyTagOutput(element, (SystemPropertyTree) tag);\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code {@systemProperty...}} tag.\n+     *\n+     * @param element the element that owns the doc comment\n+     * @param tag     the system property tag\n+     *\n+     * @return the output\n+     *\/\n+    private Content systemPropertyTagOutput(Element element, SystemPropertyTree tag) {\n+        String tagText = tag.getPropertyName().toString();\n+        return HtmlTree.CODE(tagletWriter.createAnchorAndSearchIndex(element, tagText,\n+                resources.getText(\"doclet.System_Property\"), tag));\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SystemPropertyTaglet.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.Set;\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * This is the taglet interface used internally within the doclet.\n+ *\n+ * The public {@link jdk.javadoc.doclet.Taglet} interface only supports\n+ * output to strings.   This interface supports structured output,\n+ * to {@link Content} objects, such as {@link HtmlTree}.\n+ *\n+ * User-provided taglets are supported using the {@link UserTaglet}\n+ * wrapper class.\n+ *\/\n+public interface Taglet {\n+    \/**\n+     * Returns the set of allowed locations for a block tag handled by this taglet.\n+     *\n+     * @return the set of allowable locations\n+     *\/\n+    Set<Location> getAllowedLocations();\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in field documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in field documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inField() {\n+        return getAllowedLocations().contains(Location.FIELD);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in constructor documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in constructor documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inConstructor() {\n+        return getAllowedLocations().contains(Location.CONSTRUCTOR);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in method documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in method documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inMethod() {\n+        return getAllowedLocations().contains(Location.METHOD);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in overview documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in overview documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inOverview() {\n+        return getAllowedLocations().contains(Location.OVERVIEW);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in module documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in module documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inModule()  {\n+        return getAllowedLocations().contains(Location.MODULE);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in package documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in package documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inPackage() {\n+        return getAllowedLocations().contains(Location.PACKAGE);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in type documentation (classes or interfaces).\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in type documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inType()  {\n+        return getAllowedLocations().contains(Location.TYPE);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} represents an inline tag.\n+     *\n+     * @return {@code true} if this {@code Taglet} represents an inline tag\n+     *         and {@code false} otherwise\n+     *\/\n+    boolean isInlineTag();\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} represents a block tag.\n+     *\n+     * @return {@code true} if this {@code Taglet} represents a block tag\n+     * @implSpec This implementation returns the inverse\n+     * result to {@code isInlineTag}.\n+     *\/\n+    default boolean isBlockTag() {\n+        return !isInlineTag();\n+    }\n+\n+    \/**\n+     * Returns the name of this tag.\n+     * @return the name of this tag\n+     *\/\n+    String getName();\n+\n+    \/**\n+     * Returns the content to be included in the generated output for an\n+     * instance of an inline tag handled by this taglet.\n+     *\n+     * @param owner  the element for the enclosing doc comment\n+     * @param tag    the tag\n+     * @param tagletWriter the taglet-writer used in this doclet\n+     *\n+     * @return the output for this tag\n+     * @throws UnsupportedTagletOperationException if the method is not supported by the taglet\n+     *\/\n+    Content getInlineTagOutput(Element owner, DocTree tag, TagletWriter tagletWriter) throws\n+            UnsupportedTagletOperationException;\n+\n+    \/**\n+     * Returns the content to be included in the generated output for\n+     * all instances of block tags handled by this taglet.\n+     *\n+     * @param owner  the element for the enclosing doc comment\n+     * @param tagletWriter the taglet-writer used in this doclet\n+     *\n+     * @return the output for this tag\n+     * @throws UnsupportedTagletOperationException if the method is not supported by the taglet\n+     *\/\n+    Content getAllBlockTagOutput(Element owner, TagletWriter tagletWriter) throws\n+            UnsupportedTagletOperationException;\n+\n+    class UnsupportedTagletOperationException extends UnsupportedOperationException {\n+        private static final long serialVersionUID = -3530273193380250271L;\n+        public UnsupportedTagletOperationException(String message) {\n+            super(message);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/Taglet.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,749 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+import javax.tools.JavaFileManager;\n+import javax.tools.StandardJavaFileManager;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Messages;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+import static com.sun.source.doctree.DocTree.Kind.AUTHOR;\n+import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;\n+import static com.sun.source.doctree.DocTree.Kind.HIDDEN;\n+import static com.sun.source.doctree.DocTree.Kind.PARAM;\n+import static com.sun.source.doctree.DocTree.Kind.PROVIDES;\n+import static com.sun.source.doctree.DocTree.Kind.SEE;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n+import static com.sun.source.doctree.DocTree.Kind.SINCE;\n+import static com.sun.source.doctree.DocTree.Kind.THROWS;\n+import static com.sun.source.doctree.DocTree.Kind.USES;\n+import static com.sun.source.doctree.DocTree.Kind.VERSION;\n+\n+import static javax.tools.DocumentationTool.Location.TAGLET_PATH;\n+\n+\/**\n+ * Manages the {@code Taglet}s used by the standard doclet.\n+ *\/\n+public class TagletManager {\n+\n+    \/**\n+     * All taglets, keyed either by their {@link Taglet#getName() name},\n+     * or by an alias.\n+     *\n+     * In general, taglets do <i>not<\/i> provide aliases;\n+     * the one instance that does is {@code ThrowsTaglet}, which handles\n+     * both {@code @throws} tags and {@code @exception} tags.\n+     *\/\n+    private final LinkedHashMap<String, Taglet> allTaglets;\n+\n+    \/**\n+     * Block (non-inline) taglets, grouped by {@link Location location}.\n+     *\/\n+    private Map<Location, List<Taglet>> blockTagletsByLocation;\n+\n+    \/**\n+     * The taglets that can appear inline in descriptive text.\n+     *\/\n+    private Map<String, Taglet> inlineTags;\n+\n+    \/**\n+     * The taglets that can appear in the serialized form.\n+     *\/\n+    private List<Taglet> serializedFormTags;\n+\n+    private final DocletEnvironment docEnv;\n+    private final Doclet doclet;\n+\n+    private final Utils utils;\n+    private final Messages messages;\n+    private final Resources resources;\n+\n+    \/**\n+     * Keep track of standard tags.\n+     *\/\n+    private final Set<String> standardTags;\n+\n+    \/**\n+     * Keep track of standard tags in lowercase to compare for better\n+     * error messages when a tag like {@code @docRoot} is mistakenly spelled\n+     * lowercase {@code @docroot}.\n+     *\/\n+    private final Set<String> standardTagsLowercase;\n+\n+    \/**\n+     * Keep track of overridden standard tags.\n+     *\/\n+    private final Set<String> overriddenStandardTags;\n+\n+    \/**\n+     * Keep track of the tags that may conflict\n+     * with standard tags in the future (any custom tag without\n+     * a period in its name).\n+     *\/\n+    private final Set<String> potentiallyConflictingTags;\n+\n+    \/**\n+     * The set of unseen custom tags.\n+     *\/\n+    private final Set<String> unseenCustomTags;\n+\n+    \/**\n+     * True if we do not want to use {@code @since} tags.\n+     *\/\n+    private final boolean nosince;\n+\n+    \/**\n+     * True if we want to use {@code @version} tags.\n+     *\/\n+    private final boolean showversion;\n+\n+    \/**\n+     * True if we want to use {@code @author} tags.\n+     *\/\n+    private final boolean showauthor;\n+\n+    \/**\n+     * True if we want to use JavaFX-related tags ({@code @defaultValue}, {@code @treatAsPrivate}).\n+     *\/\n+    private final boolean javafx;\n+\n+    \/**\n+     * Show the taglets table when it has been initialized.\n+     *\/\n+    private final boolean showTaglets;\n+\n+    private final String tagletPath;\n+\n+    private final HtmlConfiguration config;\n+\n+    \/**\n+     * Constructs a new {@code TagletManager}.\n+     *\n+     * @param config the configuration for this taglet manager\n+     *\/\n+    public TagletManager(HtmlConfiguration config) {\n+        overriddenStandardTags = new HashSet<>();\n+        potentiallyConflictingTags = new HashSet<>();\n+        standardTags = new HashSet<>();\n+        standardTagsLowercase = new HashSet<>();\n+        unseenCustomTags = new HashSet<>();\n+        allTaglets = new LinkedHashMap<>();\n+        this.config = config;\n+        HtmlOptions options = config.getOptions();\n+        this.nosince = options.noSince();\n+        this.showversion = options.showVersion();\n+        this.showauthor = options.showAuthor();\n+        this.javafx = options.javafx();\n+        this.docEnv = config.docEnv;\n+        this.doclet = config.doclet;\n+        this.messages = config.getMessages();\n+        this.resources = config.getDocResources();\n+        this.showTaglets = options.showTaglets();\n+        this.utils = config.utils;\n+        this.tagletPath = options.tagletPath();\n+        initStandardTaglets();\n+    }\n+\n+    public Set<String> getAllTagletNames() {\n+        return allTaglets.keySet();\n+    }\n+\n+    \/**\n+     * Initializes the location TAGLET_PATH which is used to locate the custom taglets.\n+     *\n+     * @param fileManager the file manager to load classes and resources\n+     * @throws IOException if an error occurs while setting the location\n+     *\/\n+    public void initTagletPath(JavaFileManager fileManager) throws IOException {\n+        if (fileManager instanceof StandardJavaFileManager sfm) {\n+            if (tagletPath != null) {\n+                List<File> paths = new ArrayList<>();\n+                for (String pathname : tagletPath.split(File.pathSeparator)) {\n+                    paths.add(new File(pathname));\n+                }\n+                sfm.setLocation(TAGLET_PATH, paths);\n+            } else if (!sfm.hasLocation(TAGLET_PATH)) {\n+                sfm.setLocation(TAGLET_PATH, List.of());\n+            }\n+        } else if (tagletPath != null) {\n+            messages.error(\"doclet.not_standard_file_manager\");\n+        }\n+    }\n+\n+    \/**\n+     * Adds a new {@code Taglet}.\n+     *\n+     * Prints a message to indicate whether or not the Taglet was registered properly.\n+     *\n+     * @param classname  the name of the class representing the custom tag\n+     * @param fileManager the file manager to load classes and resources\n+     *\/\n+    public void addCustomTag(String classname, JavaFileManager fileManager) {\n+        ClassLoader tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);\n+        if (config.workArounds.accessInternalAPI()) {\n+            Module thisModule = getClass().getModule();\n+            Module tagletLoaderUnnamedModule = tagClassLoader.getUnnamedModule();\n+            List<String> pkgs = List.of(\n+                    \"jdk.javadoc.doclet\",\n+                    \"jdk.javadoc.internal.doclets.toolkit\",\n+                    \"jdk.javadoc.internal.doclets.formats.html\");\n+            pkgs.forEach(p -> thisModule.addOpens(p, tagletLoaderUnnamedModule));\n+        }\n+        try {\n+            Class<? extends jdk.javadoc.doclet.Taglet> customTagClass =\n+                    tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);\n+            jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();\n+            registerTaglet(instance);\n+        } catch (ReflectiveOperationException | ExceptionInInitializerError | ClassCastException exc) {\n+            messages.error(\"doclet.Error_taglet_not_registered\", exc.getClass().getName(),\n+                    classname);\n+        }\n+    }\n+\n+    \/**\n+     * Loads taglets from a taglet path using the service loader.\n+     *\n+     * @param fileManager the file manager to load the taglets\n+     * @throws IOException if an error occurs while getting the service loader\n+     *\/\n+    public void loadTaglets(JavaFileManager fileManager) throws IOException {\n+        Iterable<? extends File> location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);\n+        if (location != null && location.iterator().hasNext()) {\n+            ServiceLoader<jdk.javadoc.doclet.Taglet> serviceLoader =\n+                    fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);\n+            for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {\n+                registerTaglet(taglet);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Registers the {@code Taglet}.\n+     *\n+     * Prints a message if the {@code Taglet} got registered properly.\n+     *\n+     * @param instance the {@code Taglet} instance\n+     *\/\n+    private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {\n+        instance.init(docEnv, doclet);\n+        Taglet newLegacy = new UserTaglet(instance);\n+        allTaglets.put(newLegacy.getName(), newLegacy);\n+        messages.notice(\"doclet.Notice_taglet_registered\", instance.getClass().getName());\n+    }\n+\n+    \/**\n+     * Adds a new {@code SimpleTaglet}.\n+     *\n+     * If this tag already exists and the header passed as an argument is {@code null},\n+     * move tag to the back of the list. If this tag already exists and the\n+     * header passed as an argument is not {@code null}, overwrite previous tag\n+     * with the new one. Otherwise, add a new SimpleTaglet to the list.\n+     *\n+     * @param tagName the name of this tag\n+     * @param header the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    public void addNewSimpleCustomTag(String tagName, String header, String locations) {\n+        if (tagName == null || locations == null) {\n+            return;\n+        }\n+        \/\/ remove + put in both branches below move the tag to the back of the map's ordering\n+        Taglet tag = allTaglets.remove(tagName);\n+        if (tag == null || header != null) {\n+            allTaglets.put(tagName, new SimpleTaglet(config, tagName, header, locations));\n+            if (Utils.toLowerCase(locations).indexOf('x') == -1) {\n+                checkTagName(tagName);\n+            }\n+        } else {\n+            \/\/ Move existing tag to the back\n+            allTaglets.put(tagName, tag);\n+        }\n+    }\n+\n+    \/**\n+     * Given a tag name, add it to the set of tags it belongs to.\n+     *\/\n+    private void checkTagName(String name) {\n+        if (standardTags.contains(name)) {\n+            overriddenStandardTags.add(name);\n+        } else {\n+            if (name.indexOf('.') == -1) {\n+                potentiallyConflictingTags.add(name);\n+            }\n+            unseenCustomTags.add(name);\n+        }\n+    }\n+\n+    \/**\n+     * Reports that a tag was seen in a doc comment.\n+     * It is removed from the list of custom tags that have not yet been seen.\n+     *\n+     * @param name the name of the tag\n+     *\/\n+    void seenTag(String name) {\n+        unseenCustomTags.remove(name);\n+    }\n+\n+    \/**\n+     * Given a series of {@code DocTree}s, check for misuse and spelling mistakes.\n+     *\n+     * @param element the tags holder\n+     * @param trees the trees containing the comments\n+     *\/\n+    public void checkTags(Element element, Iterable<? extends DocTree> trees) {\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        for (DocTree tag : trees) {\n+            String name = tag.getKind().tagName;\n+            if (name == null) {\n+                continue;\n+            }\n+            if (!name.isEmpty() && name.charAt(0) == '@') {\n+                name = name.substring(1);\n+            }\n+            if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {\n+                if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {\n+                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTagLowercase\", ch.getTagName(tag));\n+                    continue;\n+                } else {\n+                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTag\", ch.getTagName(tag));\n+                    continue;\n+                }\n+            }\n+            final Taglet taglet = allTaglets.get(name);\n+            \/\/ Check and verify tag usage\n+            if (taglet != null) {\n+                if (taglet instanceof SimpleTaglet st && !st.isEnabled()) {\n+                    \/\/ taglet has been disabled\n+                    return;\n+                }\n+\n+                new SimpleElementVisitor14<Void, Void>() {\n+                    @Override\n+                    public Void visitModule(ModuleElement e, Void p) {\n+                        if (!taglet.inModule()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"module\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitPackage(PackageElement e, Void p) {\n+                        if (!taglet.inPackage()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"package\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitType(TypeElement e, Void p) {\n+                        if (!taglet.inType()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"class\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitExecutable(ExecutableElement e, Void p) {\n+                        if (utils.isConstructor(e) && !taglet.inConstructor()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"constructor\");\n+                        } else if (!taglet.inMethod()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"method\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitVariable(VariableElement e, Void p) {\n+                        if (utils.isField(e) && !taglet.inField()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"field\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitUnknown(Element e, Void p) {\n+                        if (utils.isOverviewElement(e) && !taglet.inOverview()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"overview\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    protected Void defaultAction(Element e, Void p) {\n+                        return null;\n+                    }\n+                }.visit(element);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Given the taglet, the tag and the type of documentation that the tag\n+     * was found in, print a tag misuse warning.\n+     *\n+     * @param taglet the taglet representing the misused tag\n+     * @param tag the misused tag\n+     * @param holderType the type of documentation that the misused tag was found in\n+     *\/\n+    private void printTagMisuseWarn(CommentHelper ch, Taglet taglet, DocTree tag, String holderType) {\n+        Set<String> locationsSet = new LinkedHashSet<>();\n+        \/\/ The following names should be localized\n+        if (taglet.inOverview()) {\n+            locationsSet.add(\"overview\");\n+        }\n+        if (taglet.inModule()) {\n+            locationsSet.add(\"module\");\n+        }\n+        if (taglet.inPackage()) {\n+            locationsSet.add(\"package\");\n+        }\n+        if (taglet.inType()) {\n+            locationsSet.add(\"class\/interface\");\n+        }\n+        if (taglet.inConstructor())  {\n+            locationsSet.add(\"constructor\");\n+        }\n+        if (taglet.inField()) {\n+            locationsSet.add(\"field\");\n+        }\n+        if (taglet.inMethod()) {\n+            locationsSet.add(\"method\");\n+        }\n+        if (locationsSet.isEmpty()) {\n+            \/\/This known tag is excluded.\n+            return;\n+        }\n+        var combined_locations = String.join(\", \", locationsSet);\n+        messages.warning(ch.getDocTreePath(tag), \"doclet.tag_misuse\",\n+            \"@\" + taglet.getName(), holderType, combined_locations);\n+    }\n+\n+    \/**\n+     * Returns the taglets that can appear inline, in descriptive text.\n+     * @return the taglets that can appear inline\n+     *\/\n+    Map<String, Taglet> getInlineTaglets() {\n+        if (inlineTags == null) {\n+            initTaglets();\n+        }\n+        return inlineTags;\n+    }\n+\n+    \/**\n+     * Returns the taglets that can appear in the serialized form.\n+     * @return the taglet that can appear in the serialized form\n+     *\/\n+    public List<Taglet> getSerializedFormTaglets() {\n+        if (serializedFormTags == null) {\n+            initTaglets();\n+        }\n+        return serializedFormTags;\n+    }\n+\n+    \/**\n+     * Returns the custom tags for a given element.\n+     *\n+     * @param e the element to get custom tags for\n+     * @return the array of {@code Taglet}s that can\n+     * appear in the given element\n+     *\/\n+    @SuppressWarnings(\"fallthrough\")\n+    public List<Taglet> getBlockTaglets(Element e) {\n+        if (blockTagletsByLocation == null) {\n+            initTaglets();\n+        }\n+\n+        switch (e.getKind()) {\n+            case CONSTRUCTOR:\n+                return blockTagletsByLocation.get(Location.CONSTRUCTOR);\n+            case METHOD:\n+                return blockTagletsByLocation.get(Location.METHOD);\n+            case ENUM_CONSTANT:\n+            case FIELD:\n+                return blockTagletsByLocation.get(Location.FIELD);\n+            case ANNOTATION_TYPE:\n+            case INTERFACE:\n+            case CLASS:\n+            case ENUM:\n+            case RECORD:\n+                return blockTagletsByLocation.get(Location.TYPE);\n+            case MODULE:\n+                return blockTagletsByLocation.get(Location.MODULE);\n+            case PACKAGE:\n+                return blockTagletsByLocation.get(Location.PACKAGE);\n+            case OTHER:\n+                if (e instanceof DocletElement de) {\n+                    switch (de.getSubKind()) {\n+                        case DOCFILE:\n+                            return blockTagletsByLocation.get(Location.PACKAGE);\n+                        case OVERVIEW:\n+                            return blockTagletsByLocation.get(Location.OVERVIEW);\n+                        default:\n+                            \/\/ fall through\n+                    }\n+                }\n+                \/\/ fall through\n+            default:\n+                throw new AssertionError(\"unknown element: \" + e + \" ,kind: \" + e.getKind());\n+        }\n+    }\n+\n+    \/**\n+     * Initialize the tag collections.\n+     *\/\n+    private void initTaglets() {\n+\n+        blockTagletsByLocation = new EnumMap<>(Location.class);\n+        for (Location site : Location.values()) {\n+            blockTagletsByLocation.put(site, new ArrayList<>());\n+        }\n+\n+        inlineTags = new LinkedHashMap<>();\n+\n+        allTaglets.forEach((name, t) -> {\n+            if (t.isInlineTag()) {\n+                inlineTags.put(t.getName(), t);\n+            }\n+\n+            if (t.isBlockTag() && t.getName().equals(name)) {\n+                t.getAllowedLocations().forEach(l -> blockTagletsByLocation.get(l).add(t));\n+            }\n+        });\n+\n+        \/\/ init the serialized form tags for the serialized form page\n+        serializedFormTags = new ArrayList<>();\n+        serializedFormTags.add(allTaglets.get(SERIAL_DATA.tagName));\n+        serializedFormTags.add(allTaglets.get(PARAM.tagName));\n+        serializedFormTags.add(allTaglets.get(THROWS.tagName));\n+        if (!nosince)\n+            serializedFormTags.add(allTaglets.get(SINCE.tagName));\n+        serializedFormTags.add(allTaglets.get(SEE.tagName));\n+\n+        if (showTaglets) {\n+            showTaglets(System.out);\n+        }\n+    }\n+\n+    \/**\n+     * Initialize standard Javadoc tags for ordering purposes.\n+     *\/\n+    private void initStandardTaglets() {\n+        if (javafx) {\n+            initJavaFXTaglets();\n+        }\n+\n+        addStandardTaglet(new ParamTaglet(config));\n+        addStandardTaglet(new ReturnTaglet(config));\n+        addStandardTaglet(new ThrowsTaglet(config), EXCEPTION);\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SINCE, resources.getText(\"doclet.Since\"),\n+                    EnumSet.allOf(Location.class), !nosince));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, VERSION, resources.getText(\"doclet.Version\"),\n+                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, AUTHOR, resources.getText(\"doclet.Author\"),\n+                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SERIAL_DATA, resources.getText(\"doclet.SerialData\"),\n+                    EnumSet.noneOf(Location.class)));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, HIDDEN, null,\n+                    EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));\n+\n+        \/\/ This appears to be a default custom (non-standard) taglet\n+        Taglet factoryTaglet = new SimpleTaglet(config, \"factory\", resources.getText(\"doclet.Factory\"),\n+                EnumSet.of(Location.METHOD));\n+        allTaglets.put(factoryTaglet.getName(), factoryTaglet);\n+\n+        addStandardTaglet(new SeeTaglet(config));\n+        addStandardTaglet(new SpecTaglet(config));\n+\n+        \/\/ Standard inline tags\n+        addStandardTaglet(new DocRootTaglet(config));\n+        addStandardTaglet(new InheritDocTaglet(config));\n+        addStandardTaglet(new ValueTaglet(config));\n+        addStandardTaglet(new LinkTaglet(config, DocTree.Kind.LINK));\n+        addStandardTaglet(new LinkTaglet(config, DocTree.Kind.LINK_PLAIN));\n+        addStandardTaglet(new LiteralTaglet(config, DocTree.Kind.CODE));\n+        addStandardTaglet(new LiteralTaglet(config, DocTree.Kind.LITERAL));\n+        addStandardTaglet(new SnippetTaglet(config));\n+        addStandardTaglet(new IndexTaglet(config));\n+        addStandardTaglet(new SummaryTaglet(config));\n+        addStandardTaglet(new SystemPropertyTaglet(config));\n+\n+        \/\/ Keep track of the names of standard tags for error checking purposes.\n+        \/\/ The following are not handled above.\n+        addStandardTaglet(new DeprecatedTaglet(config));\n+        addStandardTaglet(new BaseTaglet(config, USES, false, EnumSet.of(jdk.javadoc.doclet.Taglet.Location.MODULE)));\n+        addStandardTaglet(new BaseTaglet(config, PROVIDES, false, EnumSet.of(jdk.javadoc.doclet.Taglet.Location.MODULE)));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SERIAL, null,\n+                        EnumSet.of(jdk.javadoc.doclet.Taglet.Location.PACKAGE, jdk.javadoc.doclet.Taglet.Location.TYPE, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SERIAL_FIELD, null, EnumSet.of(jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+    }\n+\n+    \/**\n+     * Initialize JavaFX-related tags.\n+     *\/\n+    private void initJavaFXTaglets() {\n+        addStandardTaglet(new SimpleTaglet(config, \"propertyDescription\",\n+                resources.getText(\"doclet.PropertyDescription\"),\n+                EnumSet.of(jdk.javadoc.doclet.Taglet.Location.METHOD, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+        addStandardTaglet(new SimpleTaglet(config, \"defaultValue\", resources.getText(\"doclet.DefaultValue\"),\n+                EnumSet.of(jdk.javadoc.doclet.Taglet.Location.METHOD, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+        addStandardTaglet(new SimpleTaglet(config, \"treatAsPrivate\", null,\n+                EnumSet.of(jdk.javadoc.doclet.Taglet.Location.TYPE, jdk.javadoc.doclet.Taglet.Location.METHOD, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+    }\n+\n+    private void addStandardTaglet(Taglet taglet) {\n+        String name = taglet.getName();\n+        allTaglets.put(name, taglet);\n+        standardTags.add(name);\n+        standardTagsLowercase.add(Utils.toLowerCase(name));\n+    }\n+\n+    private void addStandardTaglet(Taglet taglet, DocTree.Kind alias) {\n+        addStandardTaglet(taglet);\n+        String name = alias.tagName;\n+        allTaglets.put(name, taglet);\n+        standardTags.add(name);\n+        standardTagsLowercase.add(Utils.toLowerCase(name));\n+    }\n+\n+    public boolean isKnownCustomTag(String tagName) {\n+        return allTaglets.containsKey(tagName);\n+    }\n+\n+    \/**\n+     * Print a list of {@link Taglet}s that might conflict with\n+     * standard tags in the future and a list of standard tags\n+     * that have been overridden.\n+     *\/\n+    public void printReport() {\n+        printReportHelper(\"doclet.Notice_taglet_conflict_warn\", potentiallyConflictingTags);\n+        printReportHelper(\"doclet.Notice_taglet_overridden\", overriddenStandardTags);\n+        printReportHelper(\"doclet.Notice_taglet_unseen\", unseenCustomTags);\n+    }\n+\n+    private void printReportHelper(String noticeKey, Set<String> names) {\n+        if (!names.isEmpty()) {\n+            StringBuilder result = new StringBuilder();\n+            for (String name : names) {\n+                result.append(result.length() == 0 ? \" \" : \", \");\n+                result.append(\"@\").append(name);\n+            }\n+            messages.notice(noticeKey, result);\n+        }\n+    }\n+\n+    \/**\n+     * Given the name of a tag, return the corresponding taglet.\n+     *\n+     * @param name the name of the taglet to retrieve\n+     * @return the corresponding taglet or {@code null} if the tag is unknown\n+     *\/\n+    Taglet getTaglet(String name) {\n+        if (name.indexOf(\"@\") == 0) {\n+            return allTaglets.get(name.substring(1));\n+        } else {\n+            return allTaglets.get(name);\n+        }\n+    }\n+\n+    public Taglet getTaglet(DocTree.Kind kind) {\n+        return switch (kind) {\n+            case DEPRECATED, LINK, LINK_PLAIN, PARAM, RETURN, THROWS -> getTaglet(kind.tagName);\n+            default ->\n+                throw new IllegalArgumentException(kind.toString());\n+        };\n+    }\n+\n+    \/*\n+     * The output of this method is the basis for a table at the end of the\n+     * doc comment specification, so any changes in the output may indicate\n+     * a need for a corresponding update to the spec.\n+     *\/\n+    private void showTaglets(PrintStream out) {\n+        Map<String, Taglet> taglets = new TreeMap<>(allTaglets);\n+\n+        taglets.forEach((n, t) -> {\n+            \/\/ give preference to simpler block form if a tag can be either\n+            String name = t.isBlockTag() ? \"@\" + n : \"{@\" + n + \"}\";\n+            out.println(String.format(\"%20s\", name) + \": \"\n+                    + format(t.isBlockTag(), \"block\")+ \" \"\n+                    + format(t.inOverview(), \"overview\") + \" \"\n+                    + format(t.inModule(), \"module\") + \" \"\n+                    + format(t.inPackage(), \"package\") + \" \"\n+                    + format(t.inType(), \"type\") + \" \"\n+                    + format(t.inConstructor(),\"constructor\") + \" \"\n+                    + format(t.inMethod(), \"method\") + \" \"\n+                    + format(t.inField(), \"field\") + \" \"\n+                    + format(t.isInlineTag(), \"inline\")+ \" \"\n+                    + format((t instanceof SimpleTaglet st) && !st.isEnabled(), \"disabled\"));\n+        });\n+    }\n+\n+    private String format(boolean b, String s) {\n+        return b ? s : \".\".repeat(s.length()); \/\/ \"replace\" all with \".\"\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletManager.java","additions":749,"deletions":0,"binary":false,"changes":749,"status":"added"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import com.sun.source.doctree.InlineTagTree;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlOptions;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.Taglet.UnsupportedTagletOperationException;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * Context and utility methods for taglet classes.\n+ *\/\n+public class TagletWriter {\n+\n+    \/**\n+     * A class that provides the information about the enclosing context for\n+     * a series of {@code DocTree} nodes.\n+     * This context may be used to determine the content that should be generated from the tree nodes.\n+     *\/\n+    public static class Context {\n+        \/**\n+         * Whether the trees are appearing in a context of just the first sentence,\n+         * such as in the summary table of the enclosing element.\n+         *\/\n+        public final boolean isFirstSentence;\n+        \/**\n+         * Whether the trees are appearing in the \"summary\" section of the\n+         * page for a declaration.\n+         *\/\n+        public final boolean inSummary;\n+        \/**\n+         * The set of enclosing kinds of tags.\n+         *\/\n+        public final Set<DocTree.Kind> inTags;\n+\n+        \/**\n+         * Creates an outermost context, with no enclosing tags.\n+         *\n+         * @param isFirstSentence {@code true} if the trees are appearing in a context of just the\n+         *                        first sentence and {@code false} otherwise\n+         * @param inSummary       {@code true} if the trees are appearing in the \"summary\" section\n+         *                        of the page for a declaration and {@code false} otherwise\n+         *\/\n+        public Context(boolean isFirstSentence, boolean inSummary) {\n+            this(isFirstSentence, inSummary, EnumSet.noneOf(DocTree.Kind.class));\n+        }\n+\n+        private Context(boolean isFirstSentence, boolean inSummary, Set<DocTree.Kind> inTags) {\n+            this.isFirstSentence = isFirstSentence;\n+            this.inSummary = inSummary;\n+            this.inTags = inTags;\n+        }\n+\n+        \/**\n+         * Creates a new {@code Context} that includes an extra tag kind in the set of enclosing\n+         * kinds of tags.\n+         *\n+         * @param tree the enclosing tree\n+         *\n+         * @return the new {@code Context}\n+         *\/\n+        public Context within(DocTree tree) {\n+            var newInTags = EnumSet.copyOf(inTags);\n+            newInTags.add(tree.getKind());\n+            return new Context(isFirstSentence, inSummary, newInTags);\n+        }\n+    }\n+\n+    public final HtmlDocletWriter htmlWriter;\n+    public final HtmlConfiguration configuration;\n+    public final HtmlOptions options;\n+    public final Utils utils;\n+    public final Resources resources;\n+\n+    \/**\n+     * The context in which to generate the output for a series of {@code DocTree} nodes.\n+     *\/\n+    public final Context context;\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n+     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n+     *                        \"first sentence\" summary\n+     *\/\n+    public TagletWriter(HtmlDocletWriter htmlWriter, boolean isFirstSentence) {\n+        this(htmlWriter, isFirstSentence, false);\n+    }\n+\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n+     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n+     *                        \"first sentence\" summary, and {@code false} otherwise\n+     * @param inSummary       {@code true} if this taglet writer is being used for the content\n+     *                        of a {@code {@summary ...}} tag, and {@code false} otherwise\n+     *\/\n+    public TagletWriter(HtmlDocletWriter htmlWriter, boolean isFirstSentence, boolean inSummary) {\n+        this(htmlWriter, new Context(isFirstSentence, inSummary));\n+    }\n+\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter the {@code HtmlDocletWriter} for the page\n+     * @param context    the enclosing context for any tags\n+     *\/\n+    public TagletWriter(HtmlDocletWriter htmlWriter, Context context) {\n+        this.htmlWriter = Objects.requireNonNull(htmlWriter);\n+        this.context = Objects.requireNonNull(context);\n+        configuration = htmlWriter.configuration;\n+        options = configuration.getOptions();\n+        utils = configuration.utils;\n+        resources = configuration.getDocResources();\n+    }\n+\n+    public Context getContext() {\n+        return context;\n+    }\n+\n+    \/**\n+     * Returns an instance of an output object.\n+     *\n+     * @return an instance of an output object\n+     *\/\n+    public Content getOutputInstance() {\n+        return new ContentBuilder();\n+    }\n+\n+    \/**\n+     * Returns the output for an invalid tag. The returned content uses special styling to\n+     * highlight the problem. Depending on the presence of the {@code detail} string the method\n+     * returns a plain text span or an expandable component.\n+     *\n+     * @param summary the single-line summary message\n+     * @param detail the optional detail message which may contain preformatted text\n+     * @return the output\n+     *\/\n+    public Content invalidTagOutput(String summary, Optional<String> detail) {\n+        return htmlWriter.invalidTagOutput(summary,\n+                detail.isEmpty() || detail.get().isEmpty()\n+                        ? Optional.empty()\n+                        : Optional.of(Text.of(Text.normalizeNewlines(detail.get()))));\n+    }\n+\n+    \/**\n+     * Returns the main type element of the current page or null for pages that don't have one.\n+     *\n+     * @return the type element of the current page or null.\n+     *\/\n+    public TypeElement getCurrentPageElement() {\n+        return htmlWriter.getCurrentPageElement();\n+    }\n+\n+    \/**\n+     * Returns the content generated from the block tags for a given element.\n+     * The content is generated according to the order of the list of taglets.\n+     * The result is a possibly-empty list of the output generated by each\n+     * of the given taglets for all of the tags they individually support.\n+     *\n+     * @param tagletManager the manager that manages the taglets\n+     * @param element       the element that we are to write tags for\n+     * @param taglets       the taglets for the tags to write\n+     *\n+     * @return the content\n+     *\/\n+    public Content getBlockTagOutput(TagletManager tagletManager,\n+                                    Element element,\n+                                    List<Taglet> taglets) {\n+        for (Taglet t : taglets) {\n+            if (!t.isBlockTag()) {\n+                throw new IllegalArgumentException(t.getName());\n+            }\n+        }\n+\n+        Content output = getOutputInstance();\n+        tagletManager.checkTags(element, utils.getBlockTags(element));\n+        tagletManager.checkTags(element, utils.getFullBody(element));\n+        for (Taglet taglet : taglets) {\n+            if (utils.isTypeElement(element) && taglet instanceof ParamTaglet) {\n+                \/\/ The type parameters and state components are documented in a special\n+                \/\/ section away from the tag info, so skip here.\n+                continue;\n+            }\n+\n+            if (element.getKind() == ElementKind.MODULE && taglet instanceof BaseTaglet t) {\n+                switch (t.getTagKind()) {\n+                    \/\/ @uses and @provides are handled separately, so skip here.\n+                    \/\/ See ModuleWriterImpl.computeModulesData\n+                    case USES:\n+                    case PROVIDES:\n+                        continue;\n+                }\n+            }\n+\n+            if (taglet instanceof DeprecatedTaglet) {\n+                \/\/Deprecated information is documented \"inline\", not in tag info\n+                \/\/section.\n+                continue;\n+            }\n+\n+            if (taglet instanceof SimpleTaglet st && !st.isEnabled()) {\n+                \/\/ taglet has been disabled\n+                continue;\n+            }\n+\n+            try {\n+                Content tagletOutput = taglet.getAllBlockTagOutput(element, this);\n+                if (tagletOutput != null) {\n+                    tagletManager.seenTag(taglet.getName());\n+                    output.add(tagletOutput);\n+                }\n+            } catch (UnsupportedTagletOperationException e) {\n+                \/\/ malformed taglet:\n+                \/\/ claims to support block tags (see Taglet.isBlockTag) but does not provide the\n+                \/\/ appropriate method, Taglet.getAllBlockTagOutput.\n+            }\n+        }\n+        return output;\n+    }\n+\n+    \/**\n+     * Returns the content generated from an inline tag in the doc comment for a given element,\n+     * or {@code null} if the tag is not supported or does not return any output.\n+     *\n+     * @param holder        the element associated with the doc comment\n+     * @param inlineTag     the inline tag to be documented\n+     *\n+     * @return the content, or {@code null}\n+     *\/\n+    public Content getInlineTagOutput(Element holder,\n+                                      InlineTagTree inlineTag) {\n+        var tagletManager = configuration.tagletManager;\n+        Map<String, Taglet> inlineTags = tagletManager.getInlineTaglets();\n+        CommentHelper ch = configuration.utils.getCommentHelper(holder);\n+        final String inlineTagName = ch.getTagName(inlineTag);\n+        Taglet t = inlineTags.get(inlineTagName);\n+        if (t == null) {\n+            return null;\n+        }\n+\n+        try {\n+            Content tagletOutput = t.getInlineTagOutput(holder, inlineTag, this);\n+            tagletManager.seenTag(t.getName());\n+            return tagletOutput;\n+        } catch (UnsupportedTagletOperationException e) {\n+            \/\/ malformed taglet:\n+            \/\/ claims to support inline tags (see Taglet.isInlineTag) but does not provide the\n+            \/\/ appropriate method, Taglet.getInlineTagOutput.\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to content, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to block tags.\n+     *\n+     * @param holderTree the tree that holds the documentation\n+     * @param trees      list of {@code DocTree} nodes containing text and inline tags (often alternating)\n+     *                   present in the text of interest for this doc\n+     *\n+     * @return the generated content\n+     *\/\n+    public Content commentTagsToOutput(DocTree holderTree, List<? extends DocTree> trees) {\n+        return commentTagsToOutput(null, holderTree, trees, false);\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to content, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to block tags.\n+     *\n+     * @param element The element that owns the documentation\n+     * @param trees  list of {@code DocTree} nodes containing text and inline tags (often alternating)\n+     *               present in the text of interest for this doc\n+     *\n+     * @return the generated content\n+     *\/\n+    public Content commentTagsToOutput(Element element, List<? extends DocTree> trees) {\n+        return commentTagsToOutput(element, null, trees, false);\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to content, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to non-inline tags.\n+     *\n+     * @param element          the element where comment resides\n+     * @param holder       the tag that holds the documentation\n+     * @param trees           array of text tags and inline tags (often alternating)\n+     *                        present in the text of interest for this doc\n+     * @param isFirstSentence true if this is the first sentence\n+     *\n+     * @return the generated content\n+     *\/\n+    public Content commentTagsToOutput(Element element,\n+                                       DocTree holder,\n+                                       List<? extends DocTree> trees,\n+                                       boolean isFirstSentence)\n+    {\n+        return htmlWriter.commentTagsToContent(element,\n+                trees, holder == null ? context : context.within(holder));\n+    }\n+\n+    public Content createAnchorAndSearchIndex(Element element, String tagText, String desc, DocTree tree) {\n+        return createAnchorAndSearchIndex(element, tagText, Text.of(tagText), desc, tree);\n+    }\n+\n+    @SuppressWarnings(\"preview\")\n+    Content createAnchorAndSearchIndex(Element element, String tagText, Content tagContent, String desc, DocTree tree) {\n+        Content result;\n+        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n+            result = tagContent;\n+        } else {\n+            HtmlId id = HtmlIds.forText(tagText, htmlWriter.indexAnchorTable);\n+            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, tagContent);\n+            if (options.createIndex() && !tagText.isEmpty()) {\n+                String holder = getHolderName(element);\n+                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n+                        new DocLink(htmlWriter.path, id.name()));\n+                configuration.mainIndex.add(item);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public String getHolderName(Element element) {\n+        return new SimpleElementVisitor14<String, Void>() {\n+\n+            @Override\n+            public String visitModule(ModuleElement e, Void p) {\n+                return resources.getText(\"doclet.module\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitPackage(PackageElement e, Void p) {\n+                return resources.getText(\"doclet.package\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitType(TypeElement e, Void p) {\n+                return utils.getTypeElementKindName(e, true)\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitExecutable(ExecutableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e)\n+                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n+            }\n+\n+            @Override\n+            public String visitVariable(VariableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e);\n+            }\n+\n+            @Override\n+            public String visitUnknown(Element e, Void p) {\n+                if (e instanceof DocletElement de) {\n+                    return switch (de.getSubKind()) {\n+                        case OVERVIEW -> resources.getText(\"doclet.Overview\");\n+                        case DOCFILE -> getHolderName(de);\n+                    };\n+                } else {\n+                    return super.visitUnknown(e, p);\n+                }\n+            }\n+\n+            @Override\n+            protected String defaultAction(Element e, Void p) {\n+                return utils.getFullyQualifiedName(e);\n+            }\n+        }.visit(element);\n+    }\n+\n+    private String getHolderName(DocletElement de) {\n+        PackageElement pe = de.getPackageElement();\n+        if (pe.isUnnamed()) {\n+            \/\/ if package is unnamed use enclosing module only if it is named\n+            Element ee = pe.getEnclosingElement();\n+            if (ee instanceof ModuleElement && !((ModuleElement)ee).isUnnamed()) {\n+                return resources.getText(\"doclet.module\") + \" \" + utils.getFullyQualifiedName(ee);\n+            }\n+            return pe.toString(); \/\/ \"Unnamed package\" or similar\n+        }\n+        return resources.getText(\"doclet.package\") + \" \" + utils.getFullyQualifiedName(pe);\n+    }\n+\n+    Content tagList(List<Content> items) {\n+        \/\/ Use a different style if any list item is longer than 30 chars or contains commas.\n+        boolean hasLongLabels = items.stream().anyMatch(this::isLongOrHasComma);\n+        var list = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n+        items.stream()\n+                .filter(Predicate.not(Content::isEmpty))\n+                .forEach(item -> list.add(HtmlTree.LI(item)));\n+        return list;\n+    }\n+\n+    \/\/ Threshold for length of list item for switching from inline to block layout.\n+    private static final int TAG_LIST_ITEM_MAX_INLINE_LENGTH = 30;\n+\n+    private boolean isLongOrHasComma(Content c) {\n+        String s = c.toString()\n+                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n+                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n+                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n+        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletWriter.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -56,2 +56,4 @@\n-import com.sun.source.util.DocTreePath;\n-import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n@@ -59,1 +61,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n@@ -62,1 +64,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -159,1 +160,4 @@\n-    public ThrowsTaglet(BaseConfiguration configuration) {\n+    private final HtmlConfiguration config;\n+    private final Contents contents;\n+\n+    ThrowsTaglet(HtmlConfiguration config) {\n@@ -162,3 +166,3 @@\n-        super(DocTree.Kind.THROWS, false, EnumSet.of(Location.CONSTRUCTOR, Location.METHOD));\n-        this.configuration = configuration;\n-        this.utils = this.configuration.utils;\n+        super(config, DocTree.Kind.THROWS, false, EnumSet.of(Taglet.Location.CONSTRUCTOR, Taglet.Location.METHOD));\n+        this.config = config;\n+        contents = config.contents;\n@@ -167,3 +171,0 @@\n-    private final BaseConfiguration configuration;\n-    private final Utils utils;\n-\n@@ -171,1 +172,1 @@\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n@@ -180,1 +181,2 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n@@ -182,1 +184,1 @@\n-            return getAllBlockTagOutput0(holder, writer);\n+            return getAllBlockTagOutput0(holder);\n@@ -186,1 +188,0 @@\n-            var messages = configuration.getMessages();\n@@ -213,2 +214,2 @@\n-                    + utils.flatSignature((ExecutableElement) holder, writer.getCurrentPageElement());\n-            configuration.getMessages().warning(holder, \"doclet.noInheritedDoc\", signature);\n+                    + utils.flatSignature((ExecutableElement) holder, tagletWriter.getCurrentPageElement());\n+            messages.warning(holder, \"doclet.noInheritedDoc\", signature);\n@@ -216,1 +217,1 @@\n-        return writer.getOutputInstance(); \/\/ TODO: consider invalid rather than empty output\n+        return tagletWriter.getOutputInstance(); \/\/ TODO: consider invalid rather than empty output\n@@ -219,2 +220,1 @@\n-    private Content getAllBlockTagOutput0(Element holder,\n-                                          TagletWriter writer)\n+    private Content getAllBlockTagOutput0(Element holder)\n@@ -238,1 +238,1 @@\n-                writer.getCurrentPageElement(), executable);\n+                tagletWriter.getCurrentPageElement(), executable);\n@@ -245,1 +245,1 @@\n-        var exceptionSection = new ExceptionSectionBuilder(writer);\n+        var exceptionSection = new ExceptionSectionBuilder(tagletWriter, this);\n@@ -251,1 +251,1 @@\n-            outputAnExceptionTagDeeply(exceptionSection, exceptionElement, t, executable, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+            outputAnExceptionTagDeeply(exceptionSection, exceptionElement, t, executable, alreadyDocumentedExceptions, typeSubstitutions);\n@@ -280,1 +280,1 @@\n-                    outputAnExceptionTagDeeply(exceptionSection, exceptionElement, e.getKey(), e.getValue(), alreadyDocumentedExceptions, typeSubstitutions, writer);\n+                    outputAnExceptionTagDeeply(exceptionSection, exceptionElement, e.getKey(), e.getValue(), alreadyDocumentedExceptions, typeSubstitutions);\n@@ -302,0 +302,29 @@\n+    \/**\n+     * Returns the header for the {@code @throws} tag.\n+     *\n+     * @return the header for the throws tag\n+     *\/\n+    private Content getThrowsHeader() {\n+        return HtmlTree.DT(contents.throws_);\n+    }\n+\n+    \/**\n+     * Returns the output for a default {@code @throws} tag.\n+     *\n+     * @param throwsType the type that is thrown\n+     * @param content    the optional content to add as a description\n+     *\n+     * @return the output\n+     *\/\n+    private Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var linkInfo = new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, throwsType);\n+        var link = htmlWriter.getLink(linkInfo);\n+        var concat = new ContentBuilder(HtmlTree.CODE(link));\n+        if (content.isPresent()) {\n+            concat.add(\" - \");\n+            concat.add(content.get());\n+        }\n+        return HtmlTree.DD(concat);\n+    }\n+\n@@ -307,2 +336,1 @@\n-                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n-                                            TagletWriter writer)\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions)\n@@ -317,1 +345,1 @@\n-        outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, tag, holder, true, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+        outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, tag, holder, true, alreadyDocumentedExceptions, typeSubstitutions);\n@@ -326,2 +354,1 @@\n-                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n-                                            TagletWriter writer)\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions)\n@@ -358,1 +385,1 @@\n-            exceptionSection.continueEntry(writer.commentTagsToOutput(holder, description));\n+            exceptionSection.continueEntry(tagletWriter.commentTagsToOutput(holder, description));\n@@ -376,1 +403,1 @@\n-                Content beforeInheritDoc = writer.commentTagsToOutput(holder, description.subList(0, i));\n+                Content beforeInheritDoc = tagletWriter.commentTagsToOutput(holder, description.subList(0, i));\n@@ -389,1 +416,1 @@\n-                VisibleMemberTable visibleMemberTable = configuration.getVisibleMemberTable(supertype);\n+                VisibleMemberTable visibleMemberTable = config.getVisibleMemberTable(supertype);\n@@ -425,1 +452,1 @@\n-                outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, e.getKey(), e.getValue(), addNewEntryRecursively, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+                outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, e.getKey(), e.getValue(), addNewEntryRecursively, alreadyDocumentedExceptions, typeSubstitutions);\n@@ -429,1 +456,1 @@\n-                Content afterInheritDoc = writer.commentTagsToOutput(holder, description.subList(i + 1, description.size()));\n+                Content afterInheritDoc = tagletWriter.commentTagsToOutput(holder, description.subList(i + 1, description.size()));\n@@ -607,1 +634,1 @@\n-        Result<Map<ThrowsTree, ExecutableElement>> result;\n+        DocFinder.Result<Map<ThrowsTree, ExecutableElement>> result;\n@@ -626,1 +653,1 @@\n-        if (result instanceof Result.Conclude<Map<ThrowsTree, ExecutableElement>> c) {\n+        if (result instanceof DocFinder.Result.Conclude<Map<ThrowsTree, ExecutableElement>> c) {\n@@ -632,3 +659,3 @@\n-    private static Result<Map<ThrowsTree, ExecutableElement>> toResult(Element target,\n-                                                                       ExecutableElement holder,\n-                                                                       List<ThrowsTree> tags) {\n+    private static DocFinder.Result<Map<ThrowsTree, ExecutableElement>> toResult(Element target,\n+                                                                                 ExecutableElement holder,\n+                                                                                 List<ThrowsTree> tags) {\n@@ -637,1 +664,1 @@\n-            return Result.CONCLUDE(toExceptionTags(holder, tags));\n+            return DocFinder.Result.CONCLUDE(toExceptionTags(holder, tags));\n@@ -639,1 +666,1 @@\n-        return Result.CONTINUE();\n+        return DocFinder.Result.CONTINUE();\n@@ -697,0 +724,1 @@\n+        private final ThrowsTaglet taglet;\n@@ -698,1 +726,1 @@\n-        private ContentBuilder current;\n+        private Content current;\n@@ -703,1 +731,1 @@\n-        ExceptionSectionBuilder(TagletWriter writer) {\n+        ExceptionSectionBuilder(TagletWriter writer, ThrowsTaglet taglet) {\n@@ -705,0 +733,1 @@\n+            this.taglet = taglet;\n@@ -713,1 +742,1 @@\n-            current = new ContentBuilder();\n+            current = writer.getOutputInstance();\n@@ -731,1 +760,1 @@\n-                result.add(writer.getThrowsHeader());\n+                result.add(taglet.getThrowsHeader());\n@@ -733,1 +762,2 @@\n-            result.add(writer.throwsTagOutput(exceptionType, current.isEmpty() ? Optional.empty() : Optional.of(current)));\n+            result.add(taglet.throwsTagOutput(exceptionType,\n+                    current.isEmpty() ? Optional.empty() : Optional.of(current)));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ThrowsTaglet.java","additions":77,"deletions":47,"binary":false,"changes":124,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","status":"renamed"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * A taglet wrapper, allows the public taglet {@link jdk.javadoc.doclet.Taglet}\n+ * wrapped into an internal {@code Taglet} representation.\n+ *\/\n+public final class UserTaglet implements Taglet {\n+\n+    private final jdk.javadoc.doclet.Taglet userTaglet;\n+\n+    UserTaglet(jdk.javadoc.doclet.Taglet t) {\n+        userTaglet = t;\n+    }\n+\n+    @Override\n+    public Set<jdk.javadoc.doclet.Taglet.Location> getAllowedLocations() {\n+        return userTaglet.getAllowedLocations();\n+    }\n+\n+    @Override\n+    public boolean isInlineTag() {\n+        return userTaglet.isInlineTag();\n+    }\n+\n+    @Override\n+    public boolean isBlockTag() {\n+        return userTaglet.isBlockTag();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return userTaglet.getName();\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        Content output = tagletWriter.getOutputInstance();\n+        output.add(RawHtml.of(userTaglet.toString(List.of(tag), element)));\n+        return output;\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        Content output = tagletWriter.getOutputInstance();\n+        var utils = tagletWriter.utils;\n+        List<? extends DocTree> tags = utils.getBlockTags(holder, getName());\n+        if (!tags.isEmpty()) {\n+            String tagString = userTaglet.toString(tags, holder);\n+            if (tagString != null) {\n+                output.add(RawHtml.of(tagString));\n+            }\n+        }\n+        return output;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/UserTaglet.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.VariableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.doctree.ValueTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+\n+\/**\n+ * An inline taglet representing the value tag. This tag should only be used with\n+ * constant fields that have a value.  It is used to access the value of constant\n+ * fields.  This inline tag has an optional field name parameter.  If the name is\n+ * specified, the constant value is retrieved from the specified field.  A link\n+ * is also created to the specified field.  If a name is not specified, the value\n+ * is retrieved for the field that the inline tag appears on.  The name is specified\n+ * in the following format:  [fully qualified class name]#[constant field name].\n+ *\/\n+public class ValueTaglet extends BaseTaglet {\n+\n+    ValueTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.VALUE, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    \/**\n+     * Returns the referenced field or a null if the value tag\n+     * is empty or the reference is invalid.\n+     *\n+     * @param holder the tag holder.\n+     * @param config the  configuration of the doclet.\n+     * @param tag the value tag.\n+     *\n+     * @return the referenced field or null.\n+     *\/\n+    private VariableElement getVariableElement(Element holder, BaseConfiguration config, DocTree tag) {\n+        CommentHelper ch = config.utils.getCommentHelper(holder);\n+        String signature = ch.getReferencedSignature(tag);\n+\n+        Element e = signature == null\n+                ? holder\n+                : ch.getReferencedMember(tag);\n+\n+        return (e != null && config.utils.isVariableElement(e))\n+                ? (VariableElement) e\n+                : null;\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        VariableElement field = getVariableElement(holder, config, tag);\n+        if (field == null) {\n+            if (tag.toString().isEmpty()) {\n+                \/\/Invalid use of @value\n+                messages.warning(holder,\n+                        \"doclet.value_tag_invalid_use\");\n+            } else {\n+                \/\/Reference is unknown.\n+                messages.warning(holder,\n+                        \"doclet.value_tag_invalid_reference\", tag.toString());\n+            }\n+        } else if (field.getConstantValue() != null) {\n+            TextTree format = ((ValueTree) tag).getFormat();\n+            String text;\n+            if (format != null) {\n+                String f = format.getBody();\n+                if (f.startsWith(\"\\\"\")) {\n+                    f = f.substring(1, f.length() - 1);\n+                }\n+                try {\n+                    text = String.format(config.getLocale(), f, field.getConstantValue());\n+                } catch (IllegalFormatException e) {\n+                    messages.error(holder,\n+                            \"doclet.value_tag_invalid_format\", format);\n+                    return tagletWriter.invalidTagOutput(\n+                            messages.getResources().getText(\"doclet.value_tag_invalid_format\", format),\n+                            Optional.empty());\n+                }\n+            } else {\n+                text = utils.constantValueExpression(field);\n+            }\n+            return valueTagOutput(field, text, !field.equals(holder));\n+        } else {\n+            \/\/Referenced field is not a constant.\n+            messages.warning(holder,\n+                    \"doclet.value_tag_invalid_constant\", utils.getSimpleName(field));\n+        }\n+        return tagletWriter.getOutputInstance();\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code {@value}} tag.\n+     *\n+     * @param field       the constant field that holds the value tag\n+     * @param constantVal the constant value to document\n+     * @param includeLink true if we should link the constant text to the\n+     *                    constant field itself\n+     *\n+     * @return the output\n+     *\/\n+    private Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        return includeLink\n+                ? htmlWriter.getDocLink(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, field, constantVal)\n+                : Text.of(constantVal);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ValueTaglet.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Classes used to build the output for documentation comment tags.\n+ *\n+ * Tags are either inline tags, meaning they can be used within a\n+ * sentence or phrase, or are block tags, meaning that they provide\n+ * additional details that follow the main description in a comment.\n+ * Taglets model that distinction.\n+ *\n+ * Inline tags are always processed individually, within the surrounding\n+ * context. In general, inline tags always generate some (non-empty) output,\n+ * even if the output is some form indicating an error. It is almost never\n+ * correct to not generate any output to place between the parts of the\n+ * comment that come before and after the tag in the underlying comment.\n+ *\n+ * Conversely, block tags of any given kind are always processed as a\n+ * group, even if they do not appear contiguously in the underlying comment.\n+ *\/\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/package-info.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Action.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Action.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/AddStyle.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/AddStyle.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Attribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attribute.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Attributes.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attributes.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Bookmark.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Bookmark.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/MarkupParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/MarkupParser.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/ParseException.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/ParseException.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n@@ -41,0 +41,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.SnippetTaglet;\n@@ -42,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.SnippetTaglet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Parser.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Replace.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Replace.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Style.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Style.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/StyledText.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/StyledText.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Map;\n@@ -39,2 +38,0 @@\n-import jdk.javadoc.doclet.StandardDoclet;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlDoclet;\n@@ -71,19 +68,0 @@\n-    \/**\n-     * The only doclet that may use this toolkit is {@value}\n-     *\/\n-    private static final String TOOLKIT_DOCLET_NAME =\n-        jdk.javadoc.internal.doclets.formats.html.HtmlDoclet.class.getName();\n-\n-    \/**\n-     * Verify that the only doclet that is using this toolkit is\n-     * #TOOLKIT_DOCLET_NAME.\n-     *\/\n-    private boolean isValidDoclet() {\n-        if (!getClass().getName().equals(TOOLKIT_DOCLET_NAME)) {\n-            messages.error(\"doclet.Toolkit_Usage_Violation\",\n-                TOOLKIT_DOCLET_NAME);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n@@ -104,4 +82,0 @@\n-        if (!isValidDoclet()) {\n-            return false;\n-        }\n-\n@@ -110,1 +84,1 @@\n-                startGeneration();\n+                generateFiles();\n@@ -154,1 +128,1 @@\n-        if (getClass().equals(StandardDoclet.class) || getClass().equals(HtmlDoclet.class)) {\n+        if (getClass().getModule() == AbstractDoclet.class.getModule()) {\n@@ -191,1 +165,1 @@\n-    private void startGeneration() throws DocletException {\n+    protected void generateFiles() throws DocletException {\n@@ -214,1 +188,0 @@\n-        configuration.tagletManager.printReport();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AbstractDoclet.java","additions":4,"deletions":31,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,0 @@\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n@@ -34,1 +30,0 @@\n-import java.util.Arrays;\n@@ -56,1 +51,0 @@\n-import javax.tools.DocumentationTool;\n@@ -59,1 +53,0 @@\n-import javax.tools.StandardJavaFileManager;\n@@ -71,1 +64,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n@@ -103,5 +95,0 @@\n-    \/**\n-     * The taglet manager.\n-     *\/\n-    public TagletManager tagletManager;\n-\n@@ -377,22 +364,0 @@\n-        String snippetPath = options.snippetPath();\n-        if (snippetPath != null) {\n-            Messages messages = getMessages();\n-            JavaFileManager fm = getFileManager();\n-            if (fm instanceof StandardJavaFileManager) {\n-                try {\n-                    List<Path> sp = Arrays.stream(snippetPath.split(File.pathSeparator))\n-                            .map(Path::of)\n-                            .toList();\n-                    StandardJavaFileManager sfm = (StandardJavaFileManager) fm;\n-                    sfm.setLocationFromPaths(DocumentationTool.Location.SNIPPET_PATH, sp);\n-                } catch (IOException | InvalidPathException e) {\n-                    throw new SimpleDocletException(messages.getResources().getText(\n-                            \"doclet.error_setting_snippet_path\", snippetPath, e), e);\n-                }\n-            } else {\n-                throw new SimpleDocletException(messages.getResources().getText(\n-                        \"doclet.cannot_use_snippet_path\", snippetPath));\n-            }\n-        }\n-\n-        initTagletManager(options.customTagStrs());\n@@ -454,94 +419,0 @@\n-    \/**\n-     * Initialize the taglet manager.  The strings to initialize the simple custom tags should\n-     * be in the following format:  \"[tag name]:[location str]:[heading]\".\n-     *\n-     * @param customTagStrs the set two dimensional arrays of strings.  These arrays contain\n-     *                      either -tag or -taglet arguments.\n-     *\/\n-    private void initTagletManager(Set<List<String>> customTagStrs) {\n-        tagletManager = tagletManager != null ? tagletManager : new TagletManager(this);\n-        JavaFileManager fileManager = getFileManager();\n-        Messages messages = getMessages();\n-        try {\n-            tagletManager.initTagletPath(fileManager);\n-            tagletManager.loadTaglets(fileManager);\n-\n-            for (List<String> args : customTagStrs) {\n-                if (args.get(0).equals(\"-taglet\")) {\n-                    tagletManager.addCustomTag(args.get(1), fileManager);\n-                    continue;\n-                }\n-                \/* Since there are few constraints on the characters in a tag name,\n-                 * and real world examples with ':' in the tag name, we cannot simply use\n-                 * String.split(regex);  instead, we tokenize the string, allowing\n-                 * special characters to be escaped with '\\'. *\/\n-                List<String> tokens = tokenize(args.get(1), 3);\n-                switch (tokens.size()) {\n-                    case 1 -> {\n-                        String tagName = args.get(1);\n-                        if (tagletManager.isKnownCustomTag(tagName)) {\n-                            \/\/reorder a standard tag\n-                            tagletManager.addNewSimpleCustomTag(tagName, null, \"\");\n-                        } else {\n-                            \/\/Create a simple tag with the heading that has the same name as the tag.\n-                            StringBuilder heading = new StringBuilder(tagName + \":\");\n-                            heading.setCharAt(0, Character.toUpperCase(tagName.charAt(0)));\n-                            tagletManager.addNewSimpleCustomTag(tagName, heading.toString(), \"a\");\n-                        }\n-                    }\n-\n-                    case 2 ->\n-                        \/\/Add simple taglet without heading, probably to excluding it in the output.\n-                        tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(1), \"\");\n-\n-                    case 3 ->\n-                        tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(2), tokens.get(1));\n-\n-                    default ->\n-                        messages.error(\"doclet.Error_invalid_custom_tag_argument\", args.get(1));\n-                }\n-            }\n-        } catch (IOException e) {\n-            messages.error(\"doclet.taglet_could_not_set_location\", e.toString());\n-        }\n-    }\n-\n-    \/**\n-     * Given a string, return an array of tokens, separated by ':'.\n-     * The separator character can be escaped with the '\\' character.\n-     * The '\\' character may also be escaped with the '\\' character.\n-     *\n-     * @param s         the string to tokenize\n-     * @param maxTokens the maximum number of tokens returned.  If the\n-     *                  max is reached, the remaining part of s is appended\n-     *                  to the end of the last token.\n-     * @return an array of tokens\n-     *\/\n-    private List<String> tokenize(String s, int maxTokens) {\n-        List<String> tokens = new ArrayList<>();\n-        StringBuilder token = new StringBuilder();\n-        boolean prevIsEscapeChar = false;\n-        for (int i = 0; i < s.length(); i += Character.charCount(i)) {\n-            int currentChar = s.codePointAt(i);\n-            if (prevIsEscapeChar) {\n-                \/\/ Case 1:  escaped character\n-                token.appendCodePoint(currentChar);\n-                prevIsEscapeChar = false;\n-            } else if (currentChar == ':' && tokens.size() < maxTokens - 1) {\n-                \/\/ Case 2:  separator\n-                tokens.add(token.toString());\n-                token = new StringBuilder();\n-            } else if (currentChar == '\\\\') {\n-                \/\/ Case 3:  escape character\n-                prevIsEscapeChar = true;\n-            } else {\n-                \/\/ Case 4:  regular character\n-                token.appendCodePoint(currentChar);\n-            }\n-        }\n-        if (token.length() > 0) {\n-            tokens.add(token.toString());\n-        }\n-        return tokens;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":1,"deletions":130,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,0 @@\n-import java.nio.file.Path;\n-import java.time.Instant;\n-import java.time.ZoneOffset;\n@@ -41,2 +38,0 @@\n-import java.time.temporal.ChronoUnit;\n-import java.time.temporal.TemporalUnit;\n@@ -45,1 +40,0 @@\n-import java.util.Calendar;\n@@ -47,1 +41,0 @@\n-import java.util.LinkedHashSet;\n@@ -52,1 +45,0 @@\n-import java.util.StringTokenizer;\n@@ -57,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -90,5 +81,0 @@\n-    \/**\n-     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n-     *\/\n-    private final LinkedHashSet<List<String>> customTagStrs = new LinkedHashSet<>();\n-\n@@ -268,6 +254,0 @@\n-    \/**\n-     * Argument for command-line option {@code --show-taglets}.\n-     * Show taglets (internal debug switch)\n-     *\/\n-    private boolean showTaglets = false;\n-\n@@ -316,12 +296,0 @@\n-    \/**\n-     * Argument for command-line option {@code -tagletpath}.\n-     * The path to Taglets\n-     *\/\n-    private String tagletPath = null;\n-\n-    \/**\n-     * Argument for command-line option {@code --snippet-path}.\n-     * The path for external snippets.\n-     *\/\n-    private String snippetPath = null;\n-\n@@ -620,38 +588,0 @@\n-                new Option(resources, \"-tag\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        ArrayList<String> list = new ArrayList<>();\n-                        list.add(opt);\n-                        list.add(args.get(0));\n-                        customTagStrs.add(list);\n-                        return true;\n-                    }\n-                },\n-\n-                new Option(resources, \"-taglet\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        ArrayList<String> list = new ArrayList<>();\n-                        list.add(opt);\n-                        list.add(args.get(0));\n-                        customTagStrs.add(list);\n-                        return true;\n-                    }\n-                },\n-\n-                new Option(resources, \"-tagletpath\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        tagletPath = args.get(0);\n-                        return true;\n-                    }\n-                },\n-\n-                new Option(resources, \"--snippet-path\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        snippetPath = args.get(0);\n-                        return true;\n-                    }\n-                },\n-\n@@ -708,8 +638,0 @@\n-                },\n-\n-                new Hidden(resources, \"--show-taglets\") {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        showTaglets = true;\n-                        return true;\n-                    }\n@@ -804,7 +726,0 @@\n-    \/**\n-     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n-     *\/\n-    LinkedHashSet<List<String>> customTagStrs() {\n-        return customTagStrs;\n-    }\n-\n@@ -1026,1 +941,1 @@\n-     * Default is don't show author information.\n+     * Default is to not show author information.\n@@ -1032,8 +947,0 @@\n-    \/**\n-     * Argument for command-line option {@code --show-taglets}.\n-     * Show taglets (internal debug switch)\n-     *\/\n-    public boolean showTaglets() {\n-        return showTaglets;\n-    }\n-\n@@ -1092,16 +999,0 @@\n-    \/**\n-     * Argument for command-line option {@code -tagletpath}.\n-     * The path to Taglets\n-     *\/\n-    public String tagletPath() {\n-        return tagletPath;\n-    }\n-\n-    \/**\n-     * Argument for command-line option {@code --snippet-path}.\n-     * The path for external snippets.\n-     *\/\n-    public String snippetPath() {\n-        return snippetPath;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":2,"deletions":111,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,6 @@\n+    \/**\n+     * Returns an instance of an output object.\n+     *\n+     * @return an instance of an output object\n+     *\/\n+    Content getOutputInstance();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ClassWriter.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n@@ -146,1 +145,1 @@\n-        Content c = new ContentBuilder();\n+        Content c = writer.getOutputInstance();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-doclet.Toolkit_Usage_Violation=The Doclet Toolkit can only be used by {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.Set;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.UnknownBlockTagTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * A base class that implements the {@link Taglet} interface.\n- *\/\n-public class BaseTaglet implements Taglet {\n-\n-    protected final DocTree.Kind tagKind;\n-    protected final String name;\n-    private final boolean inline;\n-    private final Set<Location> sites;\n-\n-    BaseTaglet(DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n-        this(tagKind.tagName, tagKind, inline, sites);\n-    }\n-\n-    BaseTaglet(String name, boolean inline, Set<Location> sites) {\n-        this(name, inline ? DocTree.Kind.UNKNOWN_INLINE_TAG : DocTree.Kind.UNKNOWN_BLOCK_TAG, inline, sites);\n-    }\n-\n-    private BaseTaglet(String name, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n-        this.name = name;\n-        this.tagKind = tagKind;\n-        this.inline = inline;\n-        this.sites = sites;\n-    }\n-\n-    @Override\n-    public Set<Location> getAllowedLocations() {\n-        return sites;\n-    }\n-\n-    @Override\n-    public final boolean inField() {\n-        return sites.contains(Location.FIELD);\n-    }\n-\n-    @Override\n-    public final boolean inConstructor() {\n-        return sites.contains(Location.CONSTRUCTOR);\n-    }\n-\n-    @Override\n-    public final boolean inMethod() {\n-        return sites.contains(Location.METHOD);\n-    }\n-\n-    @Override\n-    public final boolean inOverview() {\n-        return sites.contains(Location.OVERVIEW);\n-    }\n-\n-    @Override\n-    public final boolean inModule() {\n-        return sites.contains(Location.MODULE);\n-    }\n-\n-    @Override\n-    public final boolean inPackage() {\n-        return sites.contains(Location.PACKAGE);\n-    }\n-\n-    @Override\n-    public final boolean inType() {\n-        return sites.contains(Location.TYPE);\n-    }\n-\n-    @Override\n-    public final boolean isInlineTag() {\n-        return inline;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Returns the kind of trees recognized by this taglet.\n-     *\n-     * @return the kind of trees recognized by this taglet\n-     *\/\n-    public DocTree.Kind getTagKind() {\n-        return tagKind;\n-    }\n-\n-    \/**\n-     * Returns whether or not this taglet accepts a {@code DocTree} node.\n-     * The taglet accepts a tree node if it has the same kind, and\n-     * if the kind is {@code UNKNOWN_BLOCK_TAG} the same tag name.\n-     *\n-     * @param tree the tree node\n-     * @return {@code true} if this taglet accepts this tree node\n-     *\/\n-    public boolean accepts(DocTree tree) {\n-        return (tree.getKind() == DocTree.Kind.UNKNOWN_BLOCK_TAG\n-                    && tagKind == DocTree.Kind.UNKNOWN_BLOCK_TAG)\n-                ? ((UnknownBlockTagTree) tree).getTagName().equals(name)\n-                : tree.getKind() == tagKind;\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation throws {@link UnsupportedTagletOperationException}.\n-     *\/\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        throw new UnsupportedTagletOperationException(\"Method not supported in taglet \" + getName() + \".\");\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation throws {@link UnsupportedTagletOperationException}\n-     *\/\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        throw new UnsupportedTagletOperationException(\"Method not supported in taglet \" + getName() + \".\");\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/BaseTaglet.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.LiteralTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet used to denote literal code fragments.\n- * The enclosed text is interpreted as not containing HTML markup or\n- * nested javadoc tags, and is rendered in a font suitable for code.\n- *\n- * <p> The tag {@code {@code ...}} is equivalent to\n- * {@code <code>{@literal ...}<\/code>}.\n- * For example, the text:\n- * <blockquote>  The type {@code {@code List<P>}}  <\/blockquote>\n- * displays as:\n- * <blockquote>  The type {@code List<P>}  <\/blockquote>\n- *\/\n-public class CodeTaglet extends BaseTaglet {\n-\n-    CodeTaglet() {\n-        super(DocTree.Kind.CODE, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.codeTagOutput(element, (LiteralTree) tag);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/CodeTaglet.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * A taglet that represents the {@code @deprecated} tag.\n- *\/\n-public class DeprecatedTaglet extends BaseTaglet {\n-\n-    public DeprecatedTaglet() {\n-        super(DocTree.Kind.DEPRECATED, false,\n-                EnumSet.of(Location.MODULE, Location.TYPE, Location.CONSTRUCTOR, Location.METHOD, Location.FIELD));\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        return writer.deprecatedTagOutput(holder);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/DeprecatedTaglet.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet representing {@code {@docRoot}}.  This taglet is\n- * used to get the relative path to the document's root output\n- * directory.\n- *\/\n-public class DocRootTaglet extends BaseTaglet {\n-\n-    \/**\n-     * Construct a new DocRootTaglet.\n-     *\/\n-    public DocRootTaglet() {\n-        super(DocTree.Kind.DOC_ROOT, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        return writer.getDocRootOutput();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/DocRootTaglet.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.IndexTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet used to index a word or a phrase.\n- * The enclosed text is interpreted as not containing HTML markup or\n- * nested javadoc tags.\n- *\/\n-public class IndexTaglet extends BaseTaglet {\n-\n-    IndexTaglet() {\n-        super(DocTree.Kind.INDEX, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.indexTagOutput(element, (IndexTree) tag);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/IndexTaglet.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.LiteralTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet used to denote literal text.\n- * For example, the text:\n- * <blockquote>  {@code {@literal a<B>c}}  <\/blockquote>\n- * displays as:\n- * <blockquote>  {@literal a<B>c}  <\/blockquote>\n- *\/\n-public class LiteralTaglet extends BaseTaglet {\n-\n-    LiteralTaglet() {\n-        super(DocTree.Kind.LITERAL, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element e, DocTree tag, TagletWriter writer) {\n-        return writer.literalTagOutput(e, (LiteralTree) tag);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/LiteralTaglet.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,284 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.ParamTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @param} tag.\n- *\/\n-public class ParamTaglet extends BaseTaglet implements InheritableTaglet {\n-    public enum ParamKind {\n-        \/** Parameter of an executable element. *\/\n-        PARAMETER,\n-        \/** State components of a record. *\/\n-        RECORD_COMPONENT,\n-        \/** Type parameters of an executable element or type element. *\/\n-        TYPE_PARAMETER\n-    }\n-\n-    \/**\n-     * Construct a ParamTaglet.\n-     *\/\n-    public ParamTaglet() {\n-        super(DocTree.Kind.PARAM, false, EnumSet.of(Location.TYPE, Location.CONSTRUCTOR, Location.METHOD));\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        assert dst.getKind() == ElementKind.METHOD;\n-        assert tag.getKind() == DocTree.Kind.PARAM;\n-        var method = (ExecutableElement) dst;\n-        var param = (ParamTree) tag;\n-        \/\/ find the position of an owner parameter described by the given tag\n-        List<? extends Element> parameterElements;\n-        if (param.isTypeParameter()) {\n-            parameterElements = method.getTypeParameters();\n-        } else {\n-            parameterElements = method.getParameters();\n-        }\n-        Map<String, Integer> stringIntegerMap = mapNameToPosition(configuration.utils, parameterElements);\n-        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n-        Integer position = stringIntegerMap.get(ch.getParameterName(param));\n-        if (position == null) {\n-            return new Output(null, null, List.of(), true);\n-        }\n-        \/\/ try to inherit description of the respective parameter in an overridden method\n-        try {\n-            var docFinder = configuration.utils.docFinder();\n-\n-            Optional<Documentation> r;\n-            if (src != null){\n-                r = docFinder.search((ExecutableElement) src,\n-                                m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n-                        .toOptional();\n-            } else {\n-                r = docFinder.find((ExecutableElement) dst,\n-                                m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n-                        .toOptional();\n-            }\n-            return r.map(result -> new Output(result.paramTree, result.method, result.paramTree.getDescription(), true))\n-                    .orElseGet(() -> new Output(null, null, List.of(), true));\n-        } catch (DocFinder.NoOverriddenMethodFound e) {\n-            return new Output(null, null, List.of(), false);\n-        }\n-    }\n-\n-    \/**\n-     * Given a list of parameter elements, returns a name-position map.\n-     * @param params the list of parameters from a type or an executable member\n-     * @return a name-position map\n-     *\/\n-    private static Map<String, Integer> mapNameToPosition(Utils utils, List<? extends Element> params) {\n-        Map<String, Integer> result = new HashMap<>();\n-        int position = 0;\n-        for (Element e : params) {\n-            String name = utils.isTypeParameterElement(e)\n-                    ? utils.getTypeName(e.asType(), false)\n-                    : utils.getSimpleName(e);\n-            result.put(name, position);\n-            position++;\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        if (utils.isExecutableElement(holder)) {\n-            ExecutableElement member = (ExecutableElement) holder;\n-            Content output = convertParams(member, ParamKind.TYPE_PARAMETER,\n-                    utils.getTypeParamTrees(member), member.getTypeParameters(), writer);\n-            output.add(convertParams(member, ParamKind.PARAMETER,\n-                    utils.getParamTrees(member), member.getParameters(), writer));\n-            return output;\n-        } else {\n-            TypeElement typeElement = (TypeElement) holder;\n-            Content output = convertParams(typeElement, ParamKind.TYPE_PARAMETER,\n-                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), writer);\n-            output.add(convertParams(typeElement, ParamKind.RECORD_COMPONENT,\n-                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), writer));\n-            return output;\n-        }\n-    }\n-\n-    \/**\n-     * Returns a {@code Content} representation of a list of {@code ParamTree}\n-     * of the specified kind.\n-     *\n-     * <p> This method correlates a {@code ParamTree} with a parameter\n-     * {@code Element} by name. Once it's done, a particular {@code ParamTree}\n-     * is addressed by the position (index) of the correlated {@code Element}\n-     * in the list of parameter elements. This is needed for documentation\n-     * inheritance because the corresponding parameters in the inheritance\n-     * hierarchy may be named differently.\n-     *\n-     * <p> This method warns about {@code @param} tags that do not map to\n-     * parameter elements and param tags that are duplicated. <\/p>\n-     *\n-     * @param kind the kind of <em>all<\/em> parameters in the lists\n-     *\/\n-    private Content convertParams(Element e,\n-                                  ParamKind kind,\n-                                  List<ParamTree> tags,\n-                                  List<? extends Element> parameters,\n-                                  TagletWriter writer) {\n-        Map<Integer, ParamTree> tagOfPosition = new HashMap<>();\n-        Messages messages = writer.configuration().getMessages();\n-        CommentHelper ch = writer.configuration().utils.getCommentHelper(e);\n-        if (!tags.isEmpty()) {\n-            Map<String, Integer> positionOfName = mapNameToPosition(writer.configuration().utils, parameters);\n-            for (ParamTree tag : tags) {\n-                String name = ch.getParameterName(tag);\n-                String paramName = kind == ParamKind.TYPE_PARAMETER ? \"<\" + name + \">\" : name;\n-                if (!positionOfName.containsKey(name)) {\n-                    String key = switch (kind) {\n-                        case PARAMETER -> \"doclet.Parameters_warn\";\n-                        case TYPE_PARAMETER -> \"doclet.TypeParameters_warn\";\n-                        case RECORD_COMPONENT -> \"doclet.RecordComponents_warn\";\n-                    };\n-                    if (!writer.configuration().isDocLintReferenceGroupEnabled()) {\n-                        messages.warning(ch.getDocTreePath(tag), key, paramName);\n-                    }\n-                }\n-                Integer position = positionOfName.get(name);\n-                if (position != null) {\n-                    if (tagOfPosition.containsKey(position)) {\n-                        String key = switch (kind) {\n-                            case PARAMETER -> \"doclet.Parameters_dup_warn\";\n-                            case TYPE_PARAMETER -> \"doclet.TypeParameters_dup_warn\";\n-                            case RECORD_COMPONENT -> \"doclet.RecordComponents_dup_warn\";\n-                        };\n-                        if (!writer.configuration().isDocLintReferenceGroupEnabled()) {\n-                            messages.warning(ch.getDocTreePath(tag), key, paramName);\n-                        }\n-                    } else {\n-                        tagOfPosition.put(position, tag);\n-                    }\n-                }\n-            }\n-        }\n-        \/\/ Document declared parameters for which tag documentation is available\n-        \/\/ (either directly or inherited) in order of their declaration.\n-        Content result = writer.getOutputInstance();\n-        for (int i = 0; i < parameters.size(); i++) {\n-            ParamTree tag = tagOfPosition.get(i);\n-            if (tag != null) {\n-                result.add(convertParam(e, kind, writer, tag,\n-                        ch.getParameterName(tag), result.isEmpty()));\n-            } else if (writer.configuration().utils.isMethod(e)) {\n-                result.add(getInheritedTagletOutput(kind, e, writer,\n-                        parameters.get(i), i, result.isEmpty()));\n-            }\n-        }\n-        if (tags.size() > tagOfPosition.size()) {\n-            \/\/ Generate documentation for remaining tags that do not match a declared parameter.\n-            \/\/ These are erroneous but we generate them anyway.\n-            for (ParamTree tag : tags) {\n-                if (!tagOfPosition.containsValue(tag)) {\n-                    result.add(convertParam(e, kind, writer, tag,\n-                            ch.getParameterName(tag), result.isEmpty()));\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    \/**\n-     * Tries to inherit documentation for a specific parameter (element).\n-     * If unsuccessful, the returned content is empty.\n-     *\/\n-    private Content getInheritedTagletOutput(ParamKind kind,\n-                                             Element holder,\n-                                             TagletWriter writer,\n-                                             Element param,\n-                                             int position,\n-                                             boolean isFirst) {\n-        Utils utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        var r = utils.docFinder().search((ExecutableElement) holder,\n-                        m -> Result.fromOptional(extract(utils, m, position, kind == ParamKind.TYPE_PARAMETER)))\n-                .toOptional();\n-        if (r.isPresent()) {\n-            String name = kind != ParamKind.TYPE_PARAMETER\n-                    ? utils.getSimpleName(param)\n-                    : utils.getTypeName(param.asType(), false);\n-            Content content = convertParam(r.get().method, kind, writer,\n-                    r.get().paramTree, name, isFirst);\n-            result.add(content);\n-        }\n-        return result;\n-    }\n-\n-    private record Documentation(ParamTree paramTree, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method, Integer position, boolean typeParam) {\n-        var ch = utils.getCommentHelper(method);\n-        List<ParamTree> tags = typeParam\n-                ? utils.getTypeParamTrees(method)\n-                : utils.getParamTrees(method);\n-        List<? extends Element> parameters = typeParam\n-                ? method.getTypeParameters()\n-                : method.getParameters();\n-        var positionOfName = mapNameToPosition(utils, parameters);\n-        return tags.stream().filter(t -> position.equals(positionOfName.get(ch.getParameterName(t))))\n-                .map(t -> new Documentation(t, method)).findAny();\n-    }\n-\n-    \/**\n-     * Converts an individual {@code ParamTree} to {@code Content}, which is\n-     * prepended with the header if the parameter is first in the list.\n-     *\/\n-    private Content convertParam(Element e,\n-                                 ParamKind kind,\n-                                 TagletWriter writer,\n-                                 ParamTree paramTag,\n-                                 String name,\n-                                 boolean isFirstParam) {\n-        Content result = writer.getOutputInstance();\n-        if (isFirstParam) {\n-            result.add(writer.getParamHeader(kind));\n-        }\n-        result.add(writer.paramTagOutput(e, paramTag, name));\n-        return result;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":0,"deletions":284,"binary":false,"changes":284,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.ReturnTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @return} and {@code {@return }} tags.\n- *\/\n-public class ReturnTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    public ReturnTaglet() {\n-        super(DocTree.Kind.RETURN, true, EnumSet.of(Location.METHOD));\n-    }\n-\n-    @Override\n-    public boolean isBlockTag() {\n-        return true;\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        try {\n-            var docFinder = configuration.utils.docFinder();\n-            Optional<Documentation> r;\n-            if (src == null) {\n-                r = docFinder.find((ExecutableElement) dst, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n-            } else {\n-                r = docFinder.search((ExecutableElement) src, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n-            }\n-            return r.map(result -> new Output(result.returnTree, result.method, result.returnTree.getDescription(), true))\n-                    .orElseGet(() -> new Output(null, null, List.of(), true));\n-        } catch (DocFinder.NoOverriddenMethodFound e) {\n-            return new Output(null, null, List.of(), false);\n-        }\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.returnTagOutput(element, (ReturnTree) tag, true);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        assert holder.getKind() == ElementKind.METHOD : holder.getKind();\n-        var method = (ExecutableElement) holder;\n-        Messages messages = writer.configuration().getMessages();\n-        Utils utils = writer.configuration().utils;\n-        List<? extends ReturnTree> tags = utils.getReturnTrees(holder);\n-\n-        \/\/ make sure we are not using @return on a method with the void return type\n-        TypeMirror returnType = utils.getReturnType(writer.getCurrentPageElement(), method);\n-        if (returnType != null && utils.isVoid(returnType)) {\n-            if (!tags.isEmpty() && !writer.configuration().isDocLintReferenceGroupEnabled()) {\n-                messages.warning(holder, \"doclet.Return_tag_on_void_method\");\n-            }\n-            return null;\n-        }\n-\n-        \/\/ it would also be good to check if there are more than one @return\n-        \/\/ tags and produce a warning or error similarly to how it's done\n-        \/\/ above for a case where @return is used for void\n-\n-        var docFinder = utils.docFinder();\n-        return docFinder.search(method, m -> Result.fromOptional(extract(utils, m))).toOptional()\n-                .map(r -> writer.returnTagOutput(r.method, r.returnTree, false))\n-                .orElse(null);\n-    }\n-\n-    private record Documentation(ReturnTree returnTree, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n-        \/\/ TODO\n-        \/\/  Using getBlockTags(..., Kind.RETURN) for clarity. Since @return has become a bimodal tag,\n-        \/\/  Utils.getReturnTrees is now a misnomer: it returns only block returns, not all returns.\n-        \/\/  We could revisit this later.\n-        Stream<? extends ReturnTree> blockTags = utils.getBlockTags(method, DocTree.Kind.RETURN, ReturnTree.class).stream();\n-        Stream<? extends ReturnTree> mainDescriptionTags = utils.getFirstSentenceTrees(method).stream()\n-                .mapMulti((t, c) -> {\n-                    if (t.getKind() == DocTree.Kind.RETURN) c.accept((ReturnTree) t);\n-                });\n-        \/\/ this method should not check validity of @return tags, hence findAny and not findFirst or what have you\n-        return Stream.concat(blockTags, mainDescriptionTags)\n-                .map(t -> new Documentation(t, method)).findAny();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ReturnTaglet.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SeeTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @see} tag.\n- *\/\n-public class SeeTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    public SeeTaglet() {\n-        super(DocTree.Kind.SEE, false, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n-        var path = ch.getDocTreePath(tag);\n-        configuration.getMessages().warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n-        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        List<? extends SeeTree> tags = utils.getSeeTrees(holder);\n-        Element e = holder;\n-        if (utils.isMethod(holder)) {\n-            var docFinder = utils.docFinder();\n-            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n-                    m -> Result.fromOptional(extract(utils, m))).toOptional();\n-            if (result.isPresent()) {\n-                ExecutableElement m = result.get().method();\n-                tags = utils.getSeeTrees(m);\n-                e = m;\n-            }\n-        }\n-        return writer.seeTagOutput(e, tags);\n-    }\n-\n-    private record Documentation(List<? extends SeeTree> seeTrees, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n-        List<? extends SeeTree> tags = utils.getSeeTrees(method);\n-        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SeeTaglet.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,206 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A custom single-argument block tag.\n- *\/\n-public class SimpleTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    \/**\n-     * The header to output.\n-     *\/\n-    protected String header;\n-\n-    \/**\n-     * Whether or not the taglet should generate output.\n-     * Standard tags like {@code @author}, {@code @since}, {@code @version} can\n-     * be disabled by command-line options; custom tags created with -tag can be\n-     * disabled with an X in the defining string.\n-     *\/\n-    protected final boolean enabled;\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *                  The string can contain 'p' for package, 't' for type,\n-     *                  'm' for method, 'c' for constructor and 'f' for field.\n-     *                  See {@link #getLocations(String) getLocations} for the\n-     *                  complete list.\n-     *\/\n-    public SimpleTaglet(String tagName, String header, String locations) {\n-        this(tagName, header, getLocations(locations), isEnabled(locations));\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagKind   the kind of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(DocTree.Kind tagKind, String header, Set<Location> locations) {\n-        this(tagKind, header, locations, true);\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(String tagName, String header, Set<Location> locations) {\n-        this(tagName, header, locations, true);\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(String tagName, String header, Set<Location> locations, boolean enabled) {\n-        super(tagName, false, locations);\n-        this.header = header;\n-        this.enabled = enabled;\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagKind   the kind of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(DocTree.Kind tagKind, String header, Set<Location> locations, boolean enabled) {\n-        super(tagKind, false, locations);\n-        this.header = header;\n-        this.enabled = enabled;\n-    }\n-\n-    private static Set<Location> getLocations(String locations) {\n-        Set<Location> set = EnumSet.noneOf(Location.class);\n-        for (int i = 0; i < locations.length(); i++) {\n-            switch (locations.charAt(i)) {\n-                case 'a':  case 'A':\n-                    return EnumSet.allOf(Location.class);\n-                case 'c':  case 'C':\n-                    set.add(Location.CONSTRUCTOR);\n-                    break;\n-                case 'f':  case 'F':\n-                    set.add(Location.FIELD);\n-                    break;\n-                case 'm':  case 'M':\n-                    set.add(Location.METHOD);\n-                    break;\n-                case 'o':  case 'O':\n-                    set.add(Location.OVERVIEW);\n-                    break;\n-                case 'p':  case 'P':\n-                    set.add(Location.PACKAGE);\n-                    break;\n-                case 's':  case 'S':        \/\/ super-packages, anyone?\n-                    set.add(Location.MODULE);\n-                    break;\n-                case 't':  case 'T':\n-                    set.add(Location.TYPE);\n-                    break;\n-                case 'x':  case 'X':\n-                    break;\n-            }\n-        }\n-        return set;\n-    }\n-\n-    private static boolean isEnabled(String locations) {\n-        return locations.matches(\"[^Xx]*\");\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        assert dst.getKind() == ElementKind.METHOD;\n-        assert !isFirstSentence;\n-        try {\n-            var docFinder = configuration.utils.docFinder();\n-            Optional<Documentation> r;\n-            if (src == null) {\n-                r = docFinder.find((ExecutableElement) dst,\n-                        m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n-            } else {\n-                r = docFinder.search((ExecutableElement) src,\n-                        m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n-            }\n-            return r.map(result -> new Output(result.tag, result.method, result.description, true))\n-                    .orElseGet(()->new Output(null, null, List.of(), true));\n-        } catch (DocFinder.NoOverriddenMethodFound e) {\n-            return new Output(null, null, List.of(), false);\n-        }\n-    }\n-\n-    record Documentation(DocTree tag, List<? extends DocTree> description, ExecutableElement method) { }\n-\n-    private Optional<Documentation> extractFirst(ExecutableElement m, Utils utils) {\n-        List<? extends DocTree> tags = utils.getBlockTags(m, this);\n-        if (tags.isEmpty()) {\n-            return Optional.empty();\n-        }\n-        DocTree t = tags.get(0);\n-        return Optional.of(new Documentation(t, utils.getCommentHelper(m).getDescription(t), m));\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        List<? extends DocTree> tags = utils.getBlockTags(holder, this);\n-        if (header == null || tags.isEmpty()) {\n-            return null;\n-        }\n-        return writer.simpleBlockTagOutput(holder, tags, header);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SimpleTaglet.java","additions":0,"deletions":206,"binary":false,"changes":206,"status":"deleted"},{"patch":"@@ -1,464 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.io.IOException;\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.PackageElement;\n-import javax.tools.Diagnostic;\n-import javax.tools.DocumentationTool.Location;\n-import javax.tools.FileObject;\n-\n-import com.sun.source.doctree.AttributeTree;\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.doctree.TextTree;\n-import jdk.javadoc.doclet.Taglet;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Action;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.ParseException;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Parser;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @snippet} tag.\n- *\/\n-public class SnippetTaglet extends BaseTaglet {\n-\n-    public enum Language {\n-\n-        JAVA(\"java\"),\n-        PROPERTIES(\"properties\");\n-\n-        private static final Map<String, Language> languages;\n-\n-        static {\n-            Map<String, Language> tmp = new HashMap<>();\n-            for (var language : values()) {\n-                String id = Objects.requireNonNull(language.identifier);\n-                if (tmp.put(id, language) != null)\n-                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n-            }\n-            languages = Map.copyOf(tmp);\n-        }\n-\n-        Language(String id) {\n-            identifier = id;\n-        }\n-\n-        private final String identifier;\n-\n-        public static Optional<Language> of(String identifier) {\n-            if (identifier == null)\n-                return Optional.empty();\n-            return Optional.ofNullable(languages.get(identifier));\n-        }\n-\n-        public String getIdentifier() {return identifier;}\n-    }\n-\n-    public SnippetTaglet() {\n-        super(DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n-    }\n-\n-    \/*\n-     * A snippet can specify content by value (inline), by reference (external)\n-     * or both (hybrid).\n-     *\n-     * To specify content by value, a snippet uses its body; the body of\n-     * a snippet is the content.\n-     *\n-     * To specify content by reference, a snippet uses either the \"class\"\n-     * or \"file\" attribute; the value of that attribute refers to the content.\n-     *\n-     * A snippet can specify the \"region\" attribute. That attribute refines\n-     * the location of the content. The value of that attribute must match\n-     * one of the named regions in the snippets content.\n-     *\/\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        try {\n-            return generateContent(holder, tag, writer);\n-        } catch (BadSnippetException e) {\n-            error(writer, holder, e.tag(), e.key(), e.args());\n-            String details = writer.configuration().getDocResources().getText(e.key(), e.args());\n-            return badSnippet(writer, Optional.of(details));\n-        }\n-    }\n-\n-    private static final class BadSnippetException extends Exception {\n-\n-        @java.io.Serial\n-        private static final long serialVersionUID = 1;\n-\n-        private final transient DocTree tag;\n-        private final String key;\n-        private final transient Object[] args;\n-\n-        BadSnippetException(DocTree tag, String key, Object... args) {\n-            this.tag = tag;\n-            this.key = key;\n-            this.args = args;\n-        }\n-\n-        DocTree tag() {\n-            return tag;\n-        }\n-\n-        String key() {\n-            return key;\n-        }\n-\n-        Object[] args() {\n-            return args;\n-        }\n-    }\n-\n-    private Content generateContent(Element holder, DocTree tag, TagletWriter writer)\n-            throws BadSnippetException\n-    {\n-        SnippetTree snippetTag = (SnippetTree) tag;\n-\n-        \/\/ organize snippet attributes in a map, performing basic checks along the way\n-        Map<String, AttributeTree> attributes = new HashMap<>();\n-        for (DocTree d : snippetTag.getAttributes()) {\n-            if (!(d instanceof AttributeTree a)) {\n-                continue; \/\/ this might be an ErroneousTree\n-            }\n-            if (attributes.putIfAbsent(a.getName().toString(), a) == null) {\n-                continue;\n-            }\n-            \/\/ two like-named attributes found; although we report on the most\n-            \/\/ recently encountered of the two, the iteration order might differ\n-            \/\/ from the source order (see JDK-8266826)\n-            throw new BadSnippetException(a, \"doclet.tag.attribute.repeated\",\n-                    a.getName().toString());\n-        }\n-\n-        final String CLASS = \"class\";\n-        final String FILE = \"file\";\n-\n-        final boolean containsClass = attributes.containsKey(CLASS);\n-        final boolean containsFile = attributes.containsKey(FILE);\n-        final boolean containsBody = snippetTag.getBody() != null;\n-\n-        if (containsClass && containsFile) {\n-            throw new BadSnippetException(attributes.get(CLASS),\n-                    \"doclet.snippet.contents.ambiguity.external\");\n-        } else if (!containsClass && !containsFile && !containsBody) {\n-            throw new BadSnippetException(tag, \"doclet.snippet.contents.none\");\n-        }\n-\n-        String regionName = null;\n-        AttributeTree region = attributes.get(\"region\");\n-        if (region != null) {\n-            regionName = stringValueOf(region);\n-            if (regionName.isBlank()) {\n-                throw new BadSnippetException(region, \"doclet.tag.attribute.value.illegal\",\n-                        \"region\", region.getValue());\n-            }\n-        }\n-\n-        String inlineContent = null, externalContent = null;\n-\n-        if (containsBody) {\n-            inlineContent = snippetTag.getBody().getBody();\n-        }\n-\n-        FileObject fileObject = null;\n-\n-        if (containsFile || containsClass) {\n-            AttributeTree a;\n-            String v = containsFile\n-                    ? stringValueOf((a = attributes.get(FILE)))\n-                    : stringValueOf((a = attributes.get(CLASS))).replace(\".\", \"\/\") + \".java\";\n-\n-            if (v.isBlank()) {\n-                throw new BadSnippetException(a, \"doclet.tag.attribute.value.illegal\",\n-                        containsFile ? FILE : CLASS, v);\n-            }\n-\n-            \/\/ we didn't create JavaFileManager, so we won't close it; even if an error occurs\n-            var fileManager = writer.configuration().getFileManager();\n-\n-            try {\n-                \/\/ first, look in local snippet-files subdirectory\n-                var utils = writer.configuration().utils;\n-                var pkg = getPackageElement(holder, utils);\n-                var pkgLocation = utils.getLocationForPackage(pkg);\n-                var pkgName = pkg.getQualifiedName().toString(); \/\/ note: empty string for unnamed package\n-                var relativeName = \"snippet-files\/\" + v;\n-                fileObject = fileManager.getFileForInput(pkgLocation, pkgName, relativeName);\n-\n-                \/\/ if not found in local snippet-files directory, look on snippet path\n-                if (fileObject == null && fileManager.hasLocation(Location.SNIPPET_PATH)) {\n-                    fileObject = fileManager.getFileForInput(Location.SNIPPET_PATH, \"\", v);\n-                }\n-            } catch (IOException | IllegalArgumentException e) { \/\/ TODO: test this when JDK-8276892 is integrated\n-                \/\/ JavaFileManager.getFileForInput can throw IllegalArgumentException in certain cases\n-                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e);\n-            }\n-\n-            if (fileObject == null) {\n-                \/\/ i.e. the file does not exist\n-                throw new BadSnippetException(a, \"doclet.snippet_file_not_found\", v);\n-            }\n-\n-            try {\n-                externalContent = fileObject.getCharContent(true).toString();\n-            } catch (IOException e) {  \/\/ TODO: test this when JDK-8276892 is integrated\n-                throw new BadSnippetException(a, \"doclet.exception.read.file\",\n-                        fileObject.getName(), e);\n-            }\n-        }\n-\n-        String lang = null;\n-        AttributeTree langAttr = attributes.get(\"lang\");\n-        if (langAttr != null) {\n-            lang = stringValueOf(langAttr);\n-        } else if (containsClass) {\n-            lang = \"java\";\n-        } else if (containsFile) {\n-            lang = languageFromFileName(fileObject.getName());\n-        }\n-\n-        Optional<Language> language = Language.of(lang);\n-\n-\n-        \/\/ TODO cache parsed external snippet (WeakHashMap)\n-\n-        StyledText inlineSnippet = null;\n-        StyledText externalSnippet = null;\n-\n-        try {\n-            Diags d = (text, pos) -> {\n-                var path = writer.configuration().utils.getCommentHelper(holder)\n-                        .getDocTreePath(snippetTag.getBody());\n-                writer.configuration().getReporter().print(Diagnostic.Kind.WARNING,\n-                        path, pos, pos, pos, text);\n-            };\n-            if (inlineContent != null) {\n-                inlineSnippet = parse(writer.configuration().getDocResources(), d, language, inlineContent);\n-            }\n-        } catch (ParseException e) {\n-            var path = writer.configuration().utils.getCommentHelper(holder)\n-                    .getDocTreePath(snippetTag.getBody());\n-            \/\/ TODO: there should be a method in Messages; that method should mirror Reporter's; use that method instead accessing Reporter.\n-            String msg = writer.configuration().getDocResources()\n-                    .getText(\"doclet.snippet.markup\", e.getMessage());\n-            writer.configuration().getReporter().print(Diagnostic.Kind.ERROR,\n-                    path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n-            return badSnippet(writer, Optional.of(e.getMessage()));\n-        }\n-\n-        try {\n-            var finalFileObject = fileObject;\n-            Diags d = (text, pos) -> writer.configuration().getMessages().warning(finalFileObject, pos, pos, pos, text);\n-            if (externalContent != null) {\n-                externalSnippet = parse(writer.configuration().getDocResources(), d, language, externalContent);\n-            }\n-        } catch (ParseException e) {\n-            assert fileObject != null;\n-            writer.configuration().getMessages().error(fileObject, e.getPosition(),\n-                    e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n-            return badSnippet(writer, Optional.of(e.getMessage()));\n-        }\n-\n-        \/\/ the region must be matched at least in one content: it can be matched\n-        \/\/ in both, but never in none\n-        if (regionName != null) {\n-            StyledText r1 = null;\n-            StyledText r2 = null;\n-            if (inlineSnippet != null) {\n-                r1 = inlineSnippet.getBookmarkedText(regionName);\n-                if (r1 != null) {\n-                    inlineSnippet = r1;\n-                }\n-            }\n-            if (externalSnippet != null) {\n-                r2 = externalSnippet.getBookmarkedText(regionName);\n-                if (r2 != null) {\n-                    externalSnippet = r2;\n-                }\n-            }\n-            if (r1 == null && r2 == null) {\n-                throw new BadSnippetException(tag, \"doclet.snippet.region.not_found\", regionName);\n-            }\n-        }\n-\n-        if (inlineSnippet != null) {\n-            inlineSnippet = toDisplayForm(inlineSnippet);\n-        }\n-\n-        if (externalSnippet != null) {\n-            externalSnippet = toDisplayForm(externalSnippet);\n-        }\n-\n-        if (inlineSnippet != null && externalSnippet != null) {\n-            String inlineStr = inlineSnippet.asCharSequence().toString();\n-            String externalStr = externalSnippet.asCharSequence().toString();\n-            if (!Objects.equals(inlineStr, externalStr)) {\n-                throw new BadSnippetException(tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n-            }\n-        }\n-\n-        assert inlineSnippet != null || externalSnippet != null;\n-        StyledText text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n-\n-        AttributeTree idAttr = attributes.get(\"id\");\n-        String id = idAttr == null\n-                ? null\n-                : stringValueOf(idAttr);\n-\n-        return writer.snippetTagOutput(holder, snippetTag, text, id, lang);\n-    }\n-\n-    \/*\n-     * Maybe there's a case for implementing a proper (or at least more helpful)\n-     * diff view, but for now simply outputting both sides of a hybrid snippet\n-     * would do. A user could then use a diff tool of their choice to compare\n-     * those sides.\n-     *\n-     * There's a separate issue of mapping discrepancies back to their\n-     * originating source in the doc comment and the external file. Maybe there\n-     * is a value in it, or maybe there isn't. In any case, accurate mapping\n-     * would not be trivial to code.\n-     *\/\n-    private static String diff(String inline, String external) {\n-        return \"\"\"\n-               ----------------- inline -------------------\n-               %s\n-               ----------------- external -----------------\n-               %s\n-               \"\"\".formatted(inline, external);\n-    }\n-\n-    private StyledText parse(Resources resources, Diags diags, Optional<Language> language, String content) throws ParseException {\n-        Parser.Result result = new Parser(resources).parse(diags, language, content);\n-        result.actions().forEach(Action::perform);\n-        return result.text();\n-    }\n-\n-    public interface Diags {\n-        void warn(String text, int pos);\n-    }\n-\n-    private static String stringValueOf(AttributeTree at) throws BadSnippetException {\n-        if (at.getValueKind() == AttributeTree.ValueKind.EMPTY) {\n-            throw new BadSnippetException(at, \"doclet.tag.attribute.value.missing\",\n-                    at.getName().toString());\n-        }\n-        return at.getValue().stream()\n-            \/\/ value consists of TextTree or ErroneousTree nodes;\n-            \/\/ ErroneousTree is a subtype of TextTree\n-            .map(t -> ((TextTree) t).getBody())\n-            .collect(Collectors.joining());\n-    }\n-\n-    private String languageFromFileName(String fileName) {\n-        \/\/ TODO: find a way to extend\/customize the list of recognized file name extensions\n-        if (fileName.endsWith(\".java\")) {\n-            return \"java\";\n-        } else if (fileName.endsWith(\".properties\")) {\n-            return \"properties\";\n-        }\n-        return null;\n-    }\n-\n-    private void error(TagletWriter writer, Element holder, DocTree tag, String key, Object... args) {\n-        writer.configuration().getMessages().error(\n-            writer.configuration().utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n-    }\n-\n-    private Content badSnippet(TagletWriter writer, Optional<String> details) {\n-        Resources resources = writer.configuration().getDocResources();\n-        return writer.invalidTagOutput(resources.getText(\"doclet.tag.invalid\", \"snippet\"), details);\n-    }\n-\n-    private static PackageElement getPackageElement(Element e, Utils utils) {\n-        if (e instanceof DocletElement de) {\n-            return de.getPackageElement();\n-        } else {\n-            return utils.elementUtils.getPackageOf(e);\n-        }\n-    }\n-\n-    \/*\n-     * Returns a version of styled text that can be rendered into HTML or\n-     * compared to another such version. The latter is used to decide if inline\n-     * and external parts of a hybrid snippet match.\n-     *\n-     * Use this method to obtain a final version of text. After all\n-     * transformations on text have been performed, call this method with that\n-     * text and then use the returned result as described above.\n-     *\/\n-    private static StyledText toDisplayForm(StyledText source) {\n-        var sourceString = source.asCharSequence().toString();\n-        var result = new StyledText();\n-        var originalLines = sourceString.lines().iterator();\n-        var unindentedLines = sourceString.stripIndent().lines().iterator();\n-        \/\/ done; the rest of the method translates the stripIndent\n-        \/\/ transformation performed on a character sequence to the styled\n-        \/\/ text that this sequence originates from, line by line\n-        int pos = 0;\n-        \/\/ overcome a \"quirk\" of String.lines\n-        boolean endsWithLineFeed = !sourceString.isEmpty() && sourceString.charAt(source.length() - 1) == '\\n';\n-        while (originalLines.hasNext() && unindentedLines.hasNext()) { \/\/ [^1]\n-            String originalLine = originalLines.next();\n-            String unindentedLine = unindentedLines.next();\n-            \/\/ the search MUST succeed\n-            int idx = originalLine.indexOf(unindentedLine);\n-            \/\/ assume newlines are always of the \\n form\n-            \/\/ append the found fragment\n-            result.append(source.subText(pos + idx, pos + idx + unindentedLine.length()));\n-            \/\/ append the possibly styled newline, but not if it's the last line\n-            int eol = pos + originalLine.length();\n-            if (originalLines.hasNext() || endsWithLineFeed) {\n-                result.append(source.subText(eol, eol + 1));\n-            }\n-            pos = eol + 1;\n-        }\n-        return result;\n-        \/\/ [^1]: Checking hasNext() on both iterators might look unnecessary.\n-        \/\/ However, there are strings for which those iterators return different\n-        \/\/ number of lines. That is, there exists a string s, such that\n-        \/\/\n-        \/\/     s.lines().count() != s.stripIndent().lines().count()\n-        \/\/\n-        \/\/ The most trivial example of such a string is \" \". In fact, any string\n-        \/\/ with a trailing non-empty blank line would do.\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":0,"deletions":464,"binary":false,"changes":464,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SpecTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @spec} tag.\n- *\/\n-public class SpecTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    public SpecTaglet() {\n-        super(DocTree.Kind.SPEC, false, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n-        var path = ch.getDocTreePath(tag);\n-        configuration.getMessages().warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n-        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        List<? extends SpecTree> tags = utils.getSpecTrees(holder);\n-        Element e = holder;\n-        if (utils.isMethod(holder)) {\n-            var docFinder = utils.docFinder();\n-            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n-                    m -> Result.fromOptional(extract(utils, m))).toOptional();\n-            if (result.isPresent()) {\n-                e = result.get().method();\n-                tags = result.get().specTrees();\n-            }\n-        }\n-        return writer.specTagOutput(e, tags);\n-    }\n-\n-    private record Documentation(List<? extends SpecTree> specTrees, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n-        List<? extends SpecTree> tags = utils.getSpecTrees(method);\n-        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import com.sun.source.doctree.SummaryTree;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * A taglet that represents the {@code {@summary}} tag.\n- *\/\n-public class SummaryTaglet extends BaseTaglet {\n-\n-    public SummaryTaglet() {\n-        super(DocTree.Kind.SUMMARY, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        return writer.commentTagsToOutput(holder, tag, ((SummaryTree)tag).getSummary(),\n-                writer.isFirstSentence);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SummaryTaglet.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-import javax.lang.model.element.Element;\n-import java.util.EnumSet;\n-\n-\/**\n- * A taglet that represents the {@code @systemProperty} tag.\n- *\/\n-public class SystemPropertyTaglet extends BaseTaglet {\n-\n-    SystemPropertyTaglet() {\n-        super(DocTree.Kind.SYSTEM_PROPERTY, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.systemPropertyTagOutput(element, (SystemPropertyTree) tag);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SystemPropertyTaglet.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,160 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.Set;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * This is the taglet interface used internally within the doclet.\n- *\/\n-public interface Taglet {\n-    \/**\n-     * Returns the set of allowed locations for a block tag handled by this taglet.\n-     *\n-     * @return the set of allowable locations\n-     *\/\n-    Set<Location> getAllowedLocations();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in field documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in field documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inField();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in constructor documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in constructor documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inConstructor();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in method documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in method documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inMethod();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in overview documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in overview documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inOverview();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in module documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in module documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inModule();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in package documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in package documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inPackage();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in type documentation (classes or interfaces).\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in type documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inType();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} represents an inline tag.\n-     *\n-     * @return {@code true} if this {@code Taglet} represents an inline tag\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean isInlineTag();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} represents a block tag.\n-     *\n-     * @return {@code true} if this {@code Taglet} represents a block tag\n-     * @implSpec This implementation returns the inverse\n-     * result to {@code isInlineTag}.\n-     *\/\n-    default boolean isBlockTag() {\n-        return !isInlineTag();\n-    }\n-\n-    \/**\n-     * Returns the name of this tag.\n-     * @return the name of this tag\n-     *\/\n-    String getName();\n-\n-    \/**\n-     * Returns the content to be included in the generated output for an\n-     * instance of an inline tag handled by this taglet.\n-     *\n-     * @param owner  the element for the enclosing doc comment\n-     * @param tag    the tag\n-     * @param writer the taglet-writer used in this doclet\n-     *\n-     * @return the output for this tag\n-     * @throws UnsupportedTagletOperationException if the method is not supported by the taglet\n-     *\/\n-    Content getInlineTagOutput(Element owner, DocTree tag, TagletWriter writer) throws\n-            UnsupportedTagletOperationException;\n-\n-    \/**\n-     * Returns the content to be included in the generated output for\n-     * all instances of block tags handled by this taglet.\n-     *\n-     * @param owner  the element for the enclosing doc comment\n-     * @param writer the taglet-writer used in this doclet\n-     *\n-     * @return the output for this tag\n-     * @throws UnsupportedTagletOperationException if the method is not supported by the taglet\n-     *\/\n-    Content getAllBlockTagOutput(Element owner, TagletWriter writer) throws\n-            UnsupportedTagletOperationException;\n-\n-    class UnsupportedTagletOperationException extends UnsupportedOperationException {\n-        private static final long serialVersionUID = -3530273193380250271L;\n-        public UnsupportedTagletOperationException(String message) {\n-            super(message);\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/Taglet.java","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"},{"patch":"@@ -1,742 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.util.ArrayList;\n-import java.util.EnumMap;\n-import java.util.EnumSet;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.ServiceLoader;\n-import java.util.Set;\n-import java.util.TreeMap;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.util.SimpleElementVisitor14;\n-import javax.tools.JavaFileManager;\n-import javax.tools.StandardJavaFileManager;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Doclet;\n-import jdk.javadoc.doclet.DocletEnvironment;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-import static com.sun.source.doctree.DocTree.Kind.AUTHOR;\n-import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;\n-import static com.sun.source.doctree.DocTree.Kind.HIDDEN;\n-import static com.sun.source.doctree.DocTree.Kind.LINK;\n-import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n-import static com.sun.source.doctree.DocTree.Kind.PARAM;\n-import static com.sun.source.doctree.DocTree.Kind.PROVIDES;\n-import static com.sun.source.doctree.DocTree.Kind.SEE;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n-import static com.sun.source.doctree.DocTree.Kind.SINCE;\n-import static com.sun.source.doctree.DocTree.Kind.THROWS;\n-import static com.sun.source.doctree.DocTree.Kind.USES;\n-import static com.sun.source.doctree.DocTree.Kind.VERSION;\n-import static javax.tools.DocumentationTool.Location.TAGLET_PATH;\n-\n-\/**\n- * Manages the {@code Taglet}s used by doclets.\n- *\/\n-public class TagletManager {\n-\n-    \/**\n-     * All taglets, keyed either by their {@link Taglet#getName() name},\n-     * or by an alias.\n-     *\n-     * In general, taglets do <i>not<\/i> provide aliases;\n-     * the one instance that does is {@code ThrowsTaglet}, which handles\n-     * both {@code @throws} tags and {@code @exception} tags.\n-     *\/\n-    private final LinkedHashMap<String, Taglet> allTaglets;\n-\n-    \/**\n-     * Block (non-inline) taglets, grouped by {@link Location location}.\n-     *\/\n-    private Map<Location, List<Taglet>> blockTagletsByLocation;\n-\n-    \/**\n-     * The taglets that can appear inline in descriptive text.\n-     *\/\n-    private Map<String, Taglet> inlineTags;\n-\n-    \/**\n-     * The taglets that can appear in the serialized form.\n-     *\/\n-    private List<Taglet> serializedFormTags;\n-\n-    private final DocletEnvironment docEnv;\n-    private final Doclet doclet;\n-\n-    private final Utils utils;\n-    private final Messages messages;\n-    private final Resources resources;\n-\n-    \/**\n-     * Keep track of standard tags.\n-     *\/\n-    private final Set<String> standardTags;\n-\n-    \/**\n-     * Keep track of standard tags in lowercase to compare for better\n-     * error messages when a tag like {@code @docRoot} is mistakenly spelled\n-     * lowercase {@code @docroot}.\n-     *\/\n-    private final Set<String> standardTagsLowercase;\n-\n-    \/**\n-     * Keep track of overridden standard tags.\n-     *\/\n-    private final Set<String> overriddenStandardTags;\n-\n-    \/**\n-     * Keep track of the tags that may conflict\n-     * with standard tags in the future (any custom tag without\n-     * a period in its name).\n-     *\/\n-    private final Set<String> potentiallyConflictingTags;\n-\n-    \/**\n-     * The set of unseen custom tags.\n-     *\/\n-    private final Set<String> unseenCustomTags;\n-\n-    \/**\n-     * True if we do not want to use {@code @since} tags.\n-     *\/\n-    private final boolean nosince;\n-\n-    \/**\n-     * True if we want to use {@code @version} tags.\n-     *\/\n-    private final boolean showversion;\n-\n-    \/**\n-     * True if we want to use {@code @author} tags.\n-     *\/\n-    private final boolean showauthor;\n-\n-    \/**\n-     * True if we want to use JavaFX-related tags ({@code @defaultValue}, {@code @treatAsPrivate}).\n-     *\/\n-    private final boolean javafx;\n-\n-    \/**\n-     * Show the taglets table when it has been initialized.\n-     *\/\n-    private final boolean showTaglets;\n-\n-    private final String tagletPath;\n-\n-    private final BaseConfiguration configuration;\n-\n-    \/**\n-     * Constructs a new {@code TagletManager}.\n-     *\n-     * @param configuration the configuration for this taglet manager\n-     *\/\n-    public TagletManager(BaseConfiguration configuration) {\n-        overriddenStandardTags = new HashSet<>();\n-        potentiallyConflictingTags = new HashSet<>();\n-        standardTags = new HashSet<>();\n-        standardTagsLowercase = new HashSet<>();\n-        unseenCustomTags = new HashSet<>();\n-        allTaglets = new LinkedHashMap<>();\n-        this.configuration = configuration;\n-        BaseOptions options = configuration.getOptions();\n-        this.nosince = options.noSince();\n-        this.showversion = options.showVersion();\n-        this.showauthor = options.showAuthor();\n-        this.javafx = options.javafx();\n-        this.docEnv = configuration.docEnv;\n-        this.doclet = configuration.doclet;\n-        this.messages = configuration.getMessages();\n-        this.resources = configuration.getDocResources();\n-        this.showTaglets = options.showTaglets();\n-        this.utils = configuration.utils;\n-        this.tagletPath = options.tagletPath();\n-        initStandardTaglets();\n-    }\n-\n-    public Set<String> getAllTagletNames() {\n-        return allTaglets.keySet();\n-    }\n-\n-    \/**\n-     * Initializes the location TAGLET_PATH which is used to locate the custom taglets.\n-     *\n-     * @param fileManager the file manager to load classes and resources\n-     * @throws IOException if an error occurs while setting the location\n-     *\/\n-    public void initTagletPath(JavaFileManager fileManager) throws IOException {\n-        if (fileManager instanceof StandardJavaFileManager sfm) {\n-            if (tagletPath != null) {\n-                List<File> paths = new ArrayList<>();\n-                for (String pathname : tagletPath.split(File.pathSeparator)) {\n-                    paths.add(new File(pathname));\n-                }\n-                sfm.setLocation(TAGLET_PATH, paths);\n-            } else if (!sfm.hasLocation(TAGLET_PATH)) {\n-                sfm.setLocation(TAGLET_PATH, List.of());\n-            }\n-        } else if (tagletPath != null) {\n-            messages.error(\"doclet.not_standard_file_manager\");\n-        }\n-    }\n-\n-    \/**\n-     * Adds a new {@code Taglet}.\n-     *\n-     * Prints a message to indicate whether or not the Taglet was registered properly.\n-     *\n-     * @param classname  the name of the class representing the custom tag\n-     * @param fileManager the file manager to load classes and resources\n-     *\/\n-    public void addCustomTag(String classname, JavaFileManager fileManager) {\n-        ClassLoader tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);\n-        if (configuration.workArounds.accessInternalAPI()) {\n-            Module thisModule = getClass().getModule();\n-            Module tagletLoaderUnnamedModule = tagClassLoader.getUnnamedModule();\n-            List<String> pkgs = List.of(\n-                    \"jdk.javadoc.doclet\",\n-                    \"jdk.javadoc.internal.doclets.toolkit\",\n-                    \"jdk.javadoc.internal.doclets.formats.html\");\n-            pkgs.forEach(p -> thisModule.addOpens(p, tagletLoaderUnnamedModule));\n-        }\n-        try {\n-            Class<? extends jdk.javadoc.doclet.Taglet> customTagClass =\n-                    tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);\n-            jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();\n-            registerTaglet(instance);\n-        } catch (ReflectiveOperationException | ExceptionInInitializerError | ClassCastException exc) {\n-            messages.error(\"doclet.Error_taglet_not_registered\", exc.getClass().getName(),\n-                    classname);\n-        }\n-    }\n-\n-    \/**\n-     * Loads taglets from a taglet path using the service loader.\n-     *\n-     * @param fileManager the file manager to load the taglets\n-     * @throws IOException if an error occurs while getting the service loader\n-     *\/\n-    public void loadTaglets(JavaFileManager fileManager) throws IOException {\n-        Iterable<? extends File> location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);\n-        if (location != null && location.iterator().hasNext()) {\n-            ServiceLoader<jdk.javadoc.doclet.Taglet> serviceLoader =\n-                    fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);\n-            for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {\n-                registerTaglet(taglet);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Registers the {@code Taglet}.\n-     *\n-     * Prints a message if the {@code Taglet} got registered properly.\n-     *\n-     * @param instance the {@code Taglet} instance\n-     *\/\n-    private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {\n-        instance.init(docEnv, doclet);\n-        Taglet newLegacy = new UserTaglet(instance);\n-        allTaglets.put(newLegacy.getName(), newLegacy);\n-        messages.notice(\"doclet.Notice_taglet_registered\", instance.getClass().getName());\n-    }\n-\n-    \/**\n-     * Adds a new {@code SimpleTaglet}.\n-     *\n-     * If this tag already exists and the header passed as an argument is {@code null},\n-     * move tag to the back of the list. If this tag already exists and the\n-     * header passed as an argument is not {@code null}, overwrite previous tag\n-     * with the new one. Otherwise, add a new SimpleTaglet to the list.\n-     *\n-     * @param tagName the name of this tag\n-     * @param header the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public void addNewSimpleCustomTag(String tagName, String header, String locations) {\n-        if (tagName == null || locations == null) {\n-            return;\n-        }\n-        \/\/ remove + put in both branches below move the tag to the back of the map's ordering\n-        Taglet tag = allTaglets.remove(tagName);\n-        if (tag == null || header != null) {\n-            allTaglets.put(tagName, new SimpleTaglet(tagName, header, locations));\n-            if (Utils.toLowerCase(locations).indexOf('x') == -1) {\n-                checkTagName(tagName);\n-            }\n-        } else {\n-            \/\/ Move existing tag to the back\n-            allTaglets.put(tagName, tag);\n-        }\n-    }\n-\n-    \/**\n-     * Given a tag name, add it to the set of tags it belongs to.\n-     *\/\n-    private void checkTagName(String name) {\n-        if (standardTags.contains(name)) {\n-            overriddenStandardTags.add(name);\n-        } else {\n-            if (name.indexOf('.') == -1) {\n-                potentiallyConflictingTags.add(name);\n-            }\n-            unseenCustomTags.add(name);\n-        }\n-    }\n-\n-    \/**\n-     * Reports that a tag was seen in a doc comment.\n-     * It is removed from the list of custom tags that have not yet been seen.\n-     *\n-     * @param name the name of the tag\n-     *\/\n-    void seenTag(String name) {\n-        unseenCustomTags.remove(name);\n-    }\n-\n-    \/**\n-     * Given a series of {@code DocTree}s, check for misuse and spelling mistakes.\n-     *\n-     * @param element the tags holder\n-     * @param trees the trees containing the comments\n-     *\/\n-    public void checkTags(Element element, Iterable<? extends DocTree> trees) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        for (DocTree tag : trees) {\n-            String name = tag.getKind().tagName;\n-            if (name == null) {\n-                continue;\n-            }\n-            if (!name.isEmpty() && name.charAt(0) == '@') {\n-                name = name.substring(1);\n-            }\n-            if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {\n-                if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {\n-                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTagLowercase\", ch.getTagName(tag));\n-                    continue;\n-                } else {\n-                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTag\", ch.getTagName(tag));\n-                    continue;\n-                }\n-            }\n-            final Taglet taglet = allTaglets.get(name);\n-            \/\/ Check and verify tag usage\n-            if (taglet != null) {\n-                if (taglet instanceof SimpleTaglet st && !st.enabled) {\n-                    \/\/ taglet has been disabled\n-                    return;\n-                }\n-\n-                new SimpleElementVisitor14<Void, Void>() {\n-                    @Override\n-                    public Void visitModule(ModuleElement e, Void p) {\n-                        if (!taglet.inModule()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"module\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitPackage(PackageElement e, Void p) {\n-                        if (!taglet.inPackage()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"package\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitType(TypeElement e, Void p) {\n-                        if (!taglet.inType()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"class\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitExecutable(ExecutableElement e, Void p) {\n-                        if (utils.isConstructor(e) && !taglet.inConstructor()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"constructor\");\n-                        } else if (!taglet.inMethod()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"method\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitVariable(VariableElement e, Void p) {\n-                        if (utils.isField(e) && !taglet.inField()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"field\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitUnknown(Element e, Void p) {\n-                        if (utils.isOverviewElement(e) && !taglet.inOverview()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"overview\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    protected Void defaultAction(Element e, Void p) {\n-                        return null;\n-                    }\n-                }.visit(element);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Given the taglet, the tag and the type of documentation that the tag\n-     * was found in, print a tag misuse warning.\n-     *\n-     * @param taglet the taglet representing the misused tag\n-     * @param tag the misused tag\n-     * @param holderType the type of documentation that the misused tag was found in\n-     *\/\n-    private void printTagMisuseWarn(CommentHelper ch, Taglet taglet, DocTree tag, String holderType) {\n-        Set<String> locationsSet = new LinkedHashSet<>();\n-        \/\/ The following names should be localized\n-        if (taglet.inOverview()) {\n-            locationsSet.add(\"overview\");\n-        }\n-        if (taglet.inModule()) {\n-            locationsSet.add(\"module\");\n-        }\n-        if (taglet.inPackage()) {\n-            locationsSet.add(\"package\");\n-        }\n-        if (taglet.inType()) {\n-            locationsSet.add(\"class\/interface\");\n-        }\n-        if (taglet.inConstructor())  {\n-            locationsSet.add(\"constructor\");\n-        }\n-        if (taglet.inField()) {\n-            locationsSet.add(\"field\");\n-        }\n-        if (taglet.inMethod()) {\n-            locationsSet.add(\"method\");\n-        }\n-        if (locationsSet.isEmpty()) {\n-            \/\/This known tag is excluded.\n-            return;\n-        }\n-        var combined_locations = String.join(\", \", locationsSet);\n-        messages.warning(ch.getDocTreePath(tag), \"doclet.tag_misuse\",\n-            \"@\" + taglet.getName(), holderType, combined_locations);\n-    }\n-\n-    \/**\n-     * Returns the taglets that can appear inline, in descriptive text.\n-     * @return the taglets that can appear inline\n-     *\/\n-    Map<String, Taglet> getInlineTaglets() {\n-        if (inlineTags == null) {\n-            initTaglets();\n-        }\n-        return inlineTags;\n-    }\n-\n-    \/**\n-     * Returns the taglets that can appear in the serialized form.\n-     * @return the taglet that can appear in the serialized form\n-     *\/\n-    public List<Taglet> getSerializedFormTaglets() {\n-        if (serializedFormTags == null) {\n-            initTaglets();\n-        }\n-        return serializedFormTags;\n-    }\n-\n-    \/**\n-     * Returns the custom tags for a given element.\n-     *\n-     * @param e the element to get custom tags for\n-     * @return the array of {@code Taglet}s that can\n-     * appear in the given element\n-     *\/\n-    @SuppressWarnings(\"fallthrough\")\n-    public List<Taglet> getBlockTaglets(Element e) {\n-        if (blockTagletsByLocation == null) {\n-            initTaglets();\n-        }\n-\n-        switch (e.getKind()) {\n-            case CONSTRUCTOR:\n-                return blockTagletsByLocation.get(Location.CONSTRUCTOR);\n-            case METHOD:\n-                return blockTagletsByLocation.get(Location.METHOD);\n-            case ENUM_CONSTANT:\n-            case FIELD:\n-                return blockTagletsByLocation.get(Location.FIELD);\n-            case ANNOTATION_TYPE:\n-            case INTERFACE:\n-            case CLASS:\n-            case ENUM:\n-            case RECORD:\n-                return blockTagletsByLocation.get(Location.TYPE);\n-            case MODULE:\n-                return blockTagletsByLocation.get(Location.MODULE);\n-            case PACKAGE:\n-                return blockTagletsByLocation.get(Location.PACKAGE);\n-            case OTHER:\n-                if (e instanceof DocletElement de) {\n-                    switch (de.getSubKind()) {\n-                        case DOCFILE:\n-                            return blockTagletsByLocation.get(Location.PACKAGE);\n-                        case OVERVIEW:\n-                            return blockTagletsByLocation.get(Location.OVERVIEW);\n-                        default:\n-                            \/\/ fall through\n-                    }\n-                }\n-                \/\/ fall through\n-            default:\n-                throw new AssertionError(\"unknown element: \" + e + \" ,kind: \" + e.getKind());\n-        }\n-    }\n-\n-    \/**\n-     * Initialize the tag collections.\n-     *\/\n-    private void initTaglets() {\n-\n-        blockTagletsByLocation = new EnumMap<>(Location.class);\n-        for (Location site : Location.values()) {\n-            blockTagletsByLocation.put(site, new ArrayList<>());\n-        }\n-\n-        inlineTags = new LinkedHashMap<>();\n-\n-        allTaglets.forEach((name, t) -> {\n-            if (t.isInlineTag()) {\n-                inlineTags.put(t.getName(), t);\n-            }\n-\n-            if (t.isBlockTag() && t.getName().equals(name)) {\n-                t.getAllowedLocations().forEach(l -> blockTagletsByLocation.get(l).add(t));\n-            }\n-        });\n-\n-        \/\/ init the serialized form tags for the serialized form page\n-        serializedFormTags = new ArrayList<>();\n-        serializedFormTags.add(allTaglets.get(SERIAL_DATA.tagName));\n-        serializedFormTags.add(allTaglets.get(PARAM.tagName));\n-        serializedFormTags.add(allTaglets.get(THROWS.tagName));\n-        if (!nosince)\n-            serializedFormTags.add(allTaglets.get(SINCE.tagName));\n-        serializedFormTags.add(allTaglets.get(SEE.tagName));\n-\n-        if (showTaglets) {\n-            showTaglets(System.out);\n-        }\n-    }\n-\n-    \/**\n-     * Initialize standard Javadoc tags for ordering purposes.\n-     *\/\n-    private void initStandardTaglets() {\n-        if (javafx) {\n-            initJavaFXTaglets();\n-        }\n-\n-        addStandardTaglet(new ParamTaglet());\n-        addStandardTaglet(new ReturnTaglet());\n-        addStandardTaglet(new ThrowsTaglet(configuration), EXCEPTION);\n-        addStandardTaglet(\n-                new SimpleTaglet(SINCE, resources.getText(\"doclet.Since\"),\n-                    EnumSet.allOf(Location.class), !nosince));\n-        addStandardTaglet(\n-                new SimpleTaglet(VERSION, resources.getText(\"doclet.Version\"),\n-                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));\n-        addStandardTaglet(\n-                new SimpleTaglet(AUTHOR, resources.getText(\"doclet.Author\"),\n-                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));\n-        addStandardTaglet(\n-                new SimpleTaglet(SERIAL_DATA, resources.getText(\"doclet.SerialData\"),\n-                    EnumSet.noneOf(Location.class)));\n-        addStandardTaglet(\n-                new SimpleTaglet(HIDDEN, null,\n-                    EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));\n-\n-        \/\/ This appears to be a default custom (non-standard) taglet\n-        Taglet factoryTaglet = new SimpleTaglet(\"factory\", resources.getText(\"doclet.Factory\"),\n-                EnumSet.of(Location.METHOD));\n-        allTaglets.put(factoryTaglet.getName(), factoryTaglet);\n-\n-        addStandardTaglet(new SeeTaglet());\n-        addStandardTaglet(new SpecTaglet());\n-\n-        \/\/ Standard inline tags\n-        addStandardTaglet(new DocRootTaglet());\n-        addStandardTaglet(new InheritDocTaglet());\n-        addStandardTaglet(new ValueTaglet());\n-        addStandardTaglet(new LiteralTaglet());\n-        addStandardTaglet(new CodeTaglet());\n-        addStandardTaglet(new SnippetTaglet());\n-        addStandardTaglet(new IndexTaglet());\n-        addStandardTaglet(new SummaryTaglet());\n-        addStandardTaglet(new SystemPropertyTaglet());\n-\n-        \/\/ Keep track of the names of standard tags for error checking purposes.\n-        \/\/ The following are not handled above.\n-        addStandardTaglet(new DeprecatedTaglet());\n-        addStandardTaglet(new BaseTaglet(LINK, true, EnumSet.allOf(Location.class)));\n-        addStandardTaglet(new BaseTaglet(LINK_PLAIN, true, EnumSet.allOf(Location.class)));\n-        addStandardTaglet(new BaseTaglet(USES, false, EnumSet.of(Location.MODULE)));\n-        addStandardTaglet(new BaseTaglet(PROVIDES, false, EnumSet.of(Location.MODULE)));\n-        addStandardTaglet(\n-                new SimpleTaglet(SERIAL, null,\n-                    EnumSet.of(Location.PACKAGE, Location.TYPE, Location.FIELD)));\n-        addStandardTaglet(\n-                new SimpleTaglet(SERIAL_FIELD, null, EnumSet.of(Location.FIELD)));\n-    }\n-\n-    \/**\n-     * Initialize JavaFX-related tags.\n-     *\/\n-    private void initJavaFXTaglets() {\n-        addStandardTaglet(new SimpleTaglet(\"propertyDescription\",\n-                resources.getText(\"doclet.PropertyDescription\"),\n-                EnumSet.of(Location.METHOD, Location.FIELD)));\n-        addStandardTaglet(new SimpleTaglet(\"defaultValue\", resources.getText(\"doclet.DefaultValue\"),\n-                EnumSet.of(Location.METHOD, Location.FIELD)));\n-        addStandardTaglet(new SimpleTaglet(\"treatAsPrivate\", null,\n-                EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));\n-    }\n-\n-    private void addStandardTaglet(Taglet taglet) {\n-        String name = taglet.getName();\n-        allTaglets.put(name, taglet);\n-        standardTags.add(name);\n-        standardTagsLowercase.add(Utils.toLowerCase(name));\n-    }\n-\n-    private void addStandardTaglet(Taglet taglet, DocTree.Kind alias) {\n-        addStandardTaglet(taglet);\n-        String name = alias.tagName;\n-        allTaglets.put(name, taglet);\n-        standardTags.add(name);\n-        standardTagsLowercase.add(Utils.toLowerCase(name));\n-    }\n-\n-    public boolean isKnownCustomTag(String tagName) {\n-        return allTaglets.containsKey(tagName);\n-    }\n-\n-    \/**\n-     * Print a list of {@link Taglet}s that might conflict with\n-     * standard tags in the future and a list of standard tags\n-     * that have been overridden.\n-     *\/\n-    public void printReport() {\n-        printReportHelper(\"doclet.Notice_taglet_conflict_warn\", potentiallyConflictingTags);\n-        printReportHelper(\"doclet.Notice_taglet_overridden\", overriddenStandardTags);\n-        printReportHelper(\"doclet.Notice_taglet_unseen\", unseenCustomTags);\n-    }\n-\n-    private void printReportHelper(String noticeKey, Set<String> names) {\n-        if (!names.isEmpty()) {\n-            StringBuilder result = new StringBuilder();\n-            for (String name : names) {\n-                result.append(result.length() == 0 ? \" \" : \", \");\n-                result.append(\"@\").append(name);\n-            }\n-            messages.notice(noticeKey, result);\n-        }\n-    }\n-\n-    \/**\n-     * Given the name of a tag, return the corresponding taglet.\n-     *\n-     * @param name the name of the taglet to retrieve\n-     * @return the corresponding taglet or {@code null} if the tag is unknown\n-     *\/\n-    Taglet getTaglet(String name) {\n-        if (name.indexOf(\"@\") == 0) {\n-            return allTaglets.get(name.substring(1));\n-        } else {\n-            return allTaglets.get(name);\n-        }\n-    }\n-\n-    \/*\n-     * The output of this method is the basis for a table at the end of the\n-     * doc comment specification, so any changes in the output may indicate\n-     * a need for a corresponding update to the spec.\n-     *\/\n-    private void showTaglets(PrintStream out) {\n-        Map<String, Taglet> taglets = new TreeMap<>(allTaglets);\n-\n-        taglets.forEach((n, t) -> {\n-            \/\/ give preference to simpler block form if a tag can be either\n-            String name = t.isBlockTag() ? \"@\" + n : \"{@\" + n + \"}\";\n-            out.println(String.format(\"%20s\", name) + \": \"\n-                    + format(t.isBlockTag(), \"block\")+ \" \"\n-                    + format(t.inOverview(), \"overview\") + \" \"\n-                    + format(t.inModule(), \"module\") + \" \"\n-                    + format(t.inPackage(), \"package\") + \" \"\n-                    + format(t.inType(), \"type\") + \" \"\n-                    + format(t.inConstructor(),\"constructor\") + \" \"\n-                    + format(t.inMethod(), \"method\") + \" \"\n-                    + format(t.inField(), \"field\") + \" \"\n-                    + format(t.isInlineTag(), \"inline\")+ \" \"\n-                    + format((t instanceof SimpleTaglet st) && !st.enabled, \"disabled\"));\n-        });\n-    }\n-\n-    private String format(boolean b, String s) {\n-        return b ? s : \".\".repeat(s.length()); \/\/ \"replace\" all with \".\"\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":0,"deletions":742,"binary":false,"changes":742,"status":"deleted"},{"patch":"@@ -1,420 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SpecTree;\n-import com.sun.source.doctree.IndexTree;\n-import com.sun.source.doctree.LinkTree;\n-import com.sun.source.doctree.LiteralTree;\n-import com.sun.source.doctree.ParamTree;\n-import com.sun.source.doctree.ReturnTree;\n-import com.sun.source.doctree.SeeTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n-import com.sun.source.doctree.ThrowsTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet.UnsupportedTagletOperationException;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * The interface for the taglet writer.\n- *\/\n-public abstract class TagletWriter {\n-\n-    \/**\n-     * True if we only want to write the first sentence.\n-     *\/\n-    protected final boolean isFirstSentence;\n-\n-    protected TagletWriter(boolean isFirstSentence) {\n-        this.isFirstSentence = isFirstSentence;\n-    }\n-\n-    \/**\n-     * Returns an instance of an output object.\n-     *\n-     * @return an instance of an output object\n-     *\/\n-    public abstract Content getOutputInstance();\n-\n-    \/**\n-     * Returns the output for a {@code {@code ...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content codeTagOutput(Element element, LiteralTree tag);\n-\n-    \/**\n-     * Returns the output for a {@code {@index...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content indexTagOutput(Element element, IndexTree tag);\n-\n-    \/**\n-     * Returns the output for a {@code {@docRoot}} tag.\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content getDocRootOutput();\n-\n-    \/**\n-     * Returns the output for a {@code @deprecated} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content deprecatedTagOutput(Element element);\n-\n-    \/**\n-     * Returns the output for a {@code {@link ...}} or {@code {@linkplain ...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content linkTagOutput(Element element, LinkTree tag);\n-\n-    \/**\n-     * Returns the output for a {@code {@literal ...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content literalTagOutput(Element element, LiteralTree tag);\n-\n-    \/**\n-     * Returns the header for the {@code @param} tags.\n-     *\n-     * @param kind the kind of header that is required\n-     *\n-     * @return the header\n-     *\/\n-    protected abstract Content getParamHeader(ParamTaglet.ParamKind kind);\n-\n-    \/**\n-     * Returns the output for a {@code @param} tag.\n-     * Note we cannot rely on the name in the tag, because we might be\n-     * inheriting the tag.\n-     *\n-     * @param element   The element that owns the doc comment\n-     * @param paramTag  the parameter to document\n-     * @param paramName the name of the parameter\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content paramTagOutput(Element element, ParamTree paramTag, String paramName);\n-\n-    \/**\n-     * Returns the output for a {@code @return} tag.\n-     *\n-     * @param element   the element that owns the doc comment\n-     * @param returnTag the return tag to document\n-     * @param inline    whether this should be written as an inline instance or block instance\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline);\n-\n-    \/**\n-     * Returns the output for {@code @see} tags.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param seeTags the list of tags\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content seeTagOutput(Element element, List<? extends SeeTree> seeTags);\n-\n-    \/**\n-     * Returns the output for a series of simple tags.\n-     *\n-     * @param element    The element that owns the doc comment\n-     * @param simpleTags the list of simple tags\n-     * @param header     the header for the series of tags\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content simpleBlockTagOutput(Element element, List<? extends DocTree> simpleTags, String header);\n-\n-    \/**\n-     * Returns the output for a {@code {@snippet ...}} tag.\n-     *\n-     * @param element    The element that owns the doc comment\n-     * @param snippetTag the snippet tag\n-     * @param id         the value of the id attribute, or null if not defined\n-     * @param lang       the value of the lang attribute, or null if not defined\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content snippetTagOutput(Element element, SnippetTree snippetTag, StyledText text,\n-                                                String id, String lang);\n-\n-    \/**\n-     * Returns the output for one or more {@code @spec} tags.\n-     *\n-     * @param element  the element that owns the doc comment\n-     * @param specTags the array of @spec tags.\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content specTagOutput(Element element, List<? extends SpecTree> specTags);\n-\n-    \/**\n-     * Returns the output for a {@code {@systemProperty...}} tag.\n-     *\n-     * @param element           the element that owns the doc comment\n-     * @param systemPropertyTag the system property tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content systemPropertyTagOutput(Element element, SystemPropertyTree systemPropertyTag);\n-\n-    \/**\n-     * Returns the header for the {@code @throws} tag.\n-     *\n-     * @return the header for the throws tag\n-     *\/\n-    protected abstract Content getThrowsHeader();\n-\n-    \/**\n-     * Returns the output for a default {@code @throws} tag.\n-     *\n-     * @param throwsType the type that is thrown\n-     * @param content    the optional content to add as a description\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content);\n-\n-    \/**\n-     * Returns the output for a {@code {@value}} tag.\n-     *\n-     * @param field       the constant field that holds the value tag\n-     * @param constantVal the constant value to document\n-     * @param includeLink true if we should link the constant text to the\n-     *                    constant field itself\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content valueTagOutput(VariableElement field,\n-        String constantVal, boolean includeLink);\n-\n-    \/**\n-     * Returns the output for an invalid tag. The returned content uses special styling to\n-     * highlight the problem. Depending on the presence of the {@code detail} string the method\n-     * returns a plain text span or an expandable component.\n-     *\n-     * @param summary the single-line summary message\n-     * @param detail the optional detail message which may contain preformatted text\n-     * @return the output\n-     *\/\n-    protected abstract Content invalidTagOutput(String summary, Optional<String> detail);\n-\n-    \/**\n-     * Returns the main type element of the current page or null for pages that don't have one.\n-     *\n-     * @return the type element of the current page or null.\n-     *\/\n-    protected abstract TypeElement getCurrentPageElement();\n-\n-    \/**\n-     * Returns the content generated from the block tags for a given element.\n-     * The content is generated according to the order of the list of taglets.\n-     * The result is a possibly-empty list of the output generated by each\n-     * of the given taglets for all of the tags they individually support.\n-     *\n-     * @param tagletManager the manager that manages the taglets\n-     * @param element       the element that we are to write tags for\n-     * @param taglets       the taglets for the tags to write\n-     *\n-     * @return the content\n-     *\/\n-    public Content getBlockTagOutput(TagletManager tagletManager,\n-                                    Element element,\n-                                    List<Taglet> taglets) {\n-        for (Taglet t : taglets) {\n-            if (!t.isBlockTag()) {\n-                throw new IllegalArgumentException(t.getName());\n-            }\n-        }\n-\n-        Content output = getOutputInstance();\n-        Utils utils = configuration().utils;\n-        tagletManager.checkTags(element, utils.getBlockTags(element));\n-        tagletManager.checkTags(element, utils.getFullBody(element));\n-        for (Taglet taglet : taglets) {\n-            if (utils.isTypeElement(element) && taglet instanceof ParamTaglet) {\n-                \/\/ The type parameters and state components are documented in a special\n-                \/\/ section away from the tag info, so skip here.\n-                continue;\n-            }\n-\n-            if (element.getKind() == ElementKind.MODULE && taglet instanceof BaseTaglet t) {\n-                switch (t.getTagKind()) {\n-                    \/\/ @uses and @provides are handled separately, so skip here.\n-                    \/\/ See ModuleWriterImpl.computeModulesData\n-                    case USES:\n-                    case PROVIDES:\n-                        continue;\n-                }\n-            }\n-\n-            if (taglet instanceof DeprecatedTaglet) {\n-                \/\/Deprecated information is documented \"inline\", not in tag info\n-                \/\/section.\n-                continue;\n-            }\n-\n-            if (taglet instanceof SimpleTaglet st && !st.enabled) {\n-                \/\/ taglet has been disabled\n-                continue;\n-            }\n-\n-            try {\n-                Content tagletOutput = taglet.getAllBlockTagOutput(element, this);\n-                if (tagletOutput != null) {\n-                    tagletManager.seenTag(taglet.getName());\n-                    output.add(tagletOutput);\n-                }\n-            } catch (UnsupportedTagletOperationException e) {\n-                \/\/ malformed taglet:\n-                \/\/ claims to support block tags (see Taglet.isBlockTag) but does not provide the\n-                \/\/ appropriate method, Taglet.getAllBlockTagOutput.\n-            }\n-        }\n-        return output;\n-    }\n-\n-    \/**\n-     * Returns the content generated from an inline tag in the doc comment for a given element,\n-     * or {@code null} if the tag is not supported or does not return any output.\n-     *\n-     * @param holder        the element associated with the doc comment\n-     * @param tagletManager the taglet manager for the current doclet\n-     * @param inlineTag     the inline tag to be documented\n-     *\n-     * @return the content, or {@code null}\n-     *\/\n-    public Content getInlineTagOutput(Element holder,\n-                                      TagletManager tagletManager,\n-                                      DocTree inlineTag) {\n-\n-        Map<String, Taglet> inlineTags = tagletManager.getInlineTaglets();\n-        CommentHelper ch = configuration().utils.getCommentHelper(holder);\n-        final String inlineTagName = ch.getTagName(inlineTag);\n-        Taglet t = inlineTags.get(inlineTagName);\n-        if (t == null) {\n-            return null;\n-        }\n-\n-        try {\n-            Content tagletOutput = t.getInlineTagOutput(holder, inlineTag, this);\n-            tagletManager.seenTag(t.getName());\n-            return tagletOutput;\n-        } catch (UnsupportedTagletOperationException e) {\n-            \/\/ malformed taglet:\n-            \/\/ claims to support inline tags (see Taglet.isInlineTag) but does not provide the\n-            \/\/ appropriate method, Taglet.getInlineTagOutput.\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Converts inline tags and text to content, expanding the\n-     * inline tags along the way.  Called wherever text can contain\n-     * an inline tag, such as in comments or in free-form text arguments\n-     * to block tags.\n-     *\n-     * @param holderTree the tree that holds the documentation\n-     * @param trees      list of {@code DocTree} nodes containing text and inline tags (often alternating)\n-     *                   present in the text of interest for this doc\n-     *\n-     * @return the generated content\n-     *\/\n-    public abstract Content commentTagsToOutput(DocTree holderTree, List<? extends DocTree> trees);\n-\n-    \/**\n-     * Converts inline tags and text to content, expanding the\n-     * inline tags along the way.  Called wherever text can contain\n-     * an inline tag, such as in comments or in free-form text arguments\n-     * to block tags.\n-     *\n-     * @param element The element that owns the documentation\n-     * @param trees  list of {@code DocTree} nodes containing text and inline tags (often alternating)\n-     *               present in the text of interest for this doc\n-     *\n-     * @return the generated content\n-     *\/\n-    public abstract Content commentTagsToOutput(Element element, List<? extends DocTree> trees);\n-\n-    \/**\n-     * Converts inline tags and text to content, expanding the\n-     * inline tags along the way.  Called wherever text can contain\n-     * an inline tag, such as in comments or in free-form text arguments\n-     * to non-inline tags.\n-     *\n-     * @param element         the element where comment resides\n-     * @param holder          the tag that holds the documentation\n-     * @param trees           array of text tags and inline tags (often alternating)\n-     *                        present in the text of interest for this doc\n-     * @param isFirstSentence true if this is the first sentence\n-     *\n-     * @return the generated content\n-     *\/\n-    public abstract Content commentTagsToOutput(Element element, DocTree holder,\n-                                                List<? extends DocTree> trees, boolean isFirstSentence);\n-\n-    \/**\n-     * Returns an instance of the configuration used for this doclet.\n-     *\n-     * @return an instance of the configuration used for this doclet\n-     *\/\n-    public abstract BaseConfiguration configuration();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":0,"deletions":420,"binary":false,"changes":420,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.List;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-import static jdk.javadoc.doclet.Taglet.Location.*;\n-\n-\/**\n- * A taglet wrapper, allows the public taglet {@link jdk.javadoc.doclet.Taglet}\n- * wrapped into an internal {@code Taglet} representation.\n- *\/\n-public final class UserTaglet implements Taglet {\n-\n-    private final jdk.javadoc.doclet.Taglet userTaglet;\n-\n-    public UserTaglet(jdk.javadoc.doclet.Taglet t) {\n-        userTaglet = t;\n-    }\n-\n-    @Override\n-    public Set<jdk.javadoc.doclet.Taglet.Location> getAllowedLocations() {\n-        return userTaglet.getAllowedLocations();\n-    }\n-\n-    @Override\n-    public boolean inField() {\n-        return userTaglet.getAllowedLocations().contains(FIELD);\n-    }\n-\n-    @Override\n-    public boolean inConstructor() {\n-        return userTaglet.getAllowedLocations().contains(CONSTRUCTOR);\n-    }\n-\n-    @Override\n-    public boolean inMethod() {\n-        return userTaglet.getAllowedLocations().contains(METHOD);\n-    }\n-\n-    @Override\n-    public boolean inOverview() {\n-        return userTaglet.getAllowedLocations().contains(OVERVIEW);\n-    }\n-\n-    @Override\n-    public boolean inModule() {\n-        return userTaglet.getAllowedLocations().contains(MODULE);\n-    }\n-\n-    @Override\n-    public boolean inPackage() {\n-        return userTaglet.getAllowedLocations().contains(PACKAGE);\n-    }\n-\n-    @Override\n-    public boolean inType() {\n-        return userTaglet.getAllowedLocations().contains(TYPE);\n-    }\n-\n-    @Override\n-    public boolean isInlineTag() {\n-        return userTaglet.isInlineTag();\n-    }\n-\n-    @Override\n-    public boolean isBlockTag() {\n-        return userTaglet.isBlockTag();\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return userTaglet.getName();\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        Content output = writer.getOutputInstance();\n-        output.add(RawHtml.of(userTaglet.toString(List.of(tag), element)));\n-        return output;\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Content output = writer.getOutputInstance();\n-        Utils utils = writer.configuration().utils;\n-        List<? extends DocTree> tags = utils.getBlockTags(holder, this);\n-        if (!tags.isEmpty()) {\n-            String tagString = userTaglet.toString(tags, holder);\n-            if (tagString != null) {\n-                output.add(RawHtml.of(tagString));\n-            }\n-        }\n-        return output;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/UserTaglet.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.IllegalFormatException;\n-import java.util.Optional;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.VariableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.TextTree;\n-import com.sun.source.doctree.ValueTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * An inline taglet representing the value tag. This tag should only be used with\n- * constant fields that have a value.  It is used to access the value of constant\n- * fields.  This inline tag has an optional field name parameter.  If the name is\n- * specified, the constant value is retrieved from the specified field.  A link\n- * is also created to the specified field.  If a name is not specified, the value\n- * is retrieved for the field that the inline tag appears on.  The name is specified\n- * in the following format:  [fully qualified class name]#[constant field name].\n- *\/\n-public class ValueTaglet extends BaseTaglet {\n-\n-    \/**\n-     * Construct a new ValueTaglet.\n-     *\/\n-    public ValueTaglet() {\n-        super(DocTree.Kind.VALUE, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    \/**\n-     * Returns the referenced field or a null if the value tag\n-     * is empty or the reference is invalid.\n-     *\n-     * @param holder the tag holder.\n-     * @param config the  configuration of the doclet.\n-     * @param tag the value tag.\n-     *\n-     * @return the referenced field or null.\n-     *\/\n-    private VariableElement getVariableElement(Element holder, BaseConfiguration config, DocTree tag) {\n-        CommentHelper ch = config.utils.getCommentHelper(holder);\n-        String signature = ch.getReferencedSignature(tag);\n-\n-        Element e = signature == null\n-                ? holder\n-                : ch.getReferencedMember(tag);\n-\n-        return (e != null && config.utils.isVariableElement(e))\n-                ? (VariableElement) e\n-                : null;\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        BaseConfiguration configuration = writer.configuration();\n-        Utils utils = configuration.utils;\n-        Messages messages = configuration.getMessages();\n-        VariableElement field = getVariableElement(holder, configuration, tag);\n-        if (field == null) {\n-            if (tag.toString().isEmpty()) {\n-                \/\/Invalid use of @value\n-                messages.warning(holder,\n-                        \"doclet.value_tag_invalid_use\");\n-            } else {\n-                \/\/Reference is unknown.\n-                messages.warning(holder,\n-                        \"doclet.value_tag_invalid_reference\", tag.toString());\n-            }\n-        } else if (field.getConstantValue() != null) {\n-            TextTree format = ((ValueTree) tag).getFormat();\n-            String text;\n-            if (format != null) {\n-                String f = format.getBody();\n-                if (f.startsWith(\"\\\"\")) {\n-                    f = f.substring(1, f.length() - 1);\n-                }\n-                try {\n-                    text = String.format(configuration.getLocale(), f, field.getConstantValue());\n-                } catch (IllegalFormatException e) {\n-                    messages.error(holder,\n-                            \"doclet.value_tag_invalid_format\", format);\n-                    return writer.invalidTagOutput(\n-                            messages.getResources().getText(\"doclet.value_tag_invalid_format\", format),\n-                            Optional.empty());\n-                }\n-            } else {\n-                text = utils.constantValueExpression(field);\n-            }\n-            return writer.valueTagOutput(field,\n-                text,\n-                !field.equals(holder));\n-        } else {\n-            \/\/Referenced field is not a constant.\n-            messages.warning(holder,\n-                \"doclet.value_tag_invalid_constant\", utils.getSimpleName(field));\n-        }\n-        return writer.getOutputInstance();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ValueTaglet.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This package has classes used to generate output for Javadoc tags.\n- *\n- * <p>Doclets no longer have to implement their own version of standard tags\n- * such as &#64;param and &#64;throws.  Individual taglets provide\n- * common processing, independent of the output format.\n- * Each doclet must have a taglet writer that takes a taglet\n- * as input and writes doclet-dependent output. The taglet itself will\n- * do the tag processing. For example, suppose we are outputting\n- * &#64;throws tags. The taglet would:\n- * <ul>\n- *     <li> Retrieve the list of throws tags to be documented.\n- *     <li> Replace {&#64;inheritDoc} with the appropriate documentation.\n- *     <li> Add throws documentation for exceptions that are declared in\n- *          the signature of the method but not documented with the throws tags.\n- * <\/ul>\n- * After doing the steps above, the taglet would pass the information to\n- * the taglet writer for writing. The taglets are essentially builders for\n- * tags.\n- *\/\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/package-info.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Arrays;\n@@ -119,0 +118,1 @@\n+\n@@ -124,2 +124,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;\n@@ -994,1 +992,1 @@\n-     * For example, a two dimensional array of String returns \"{@code [][]}\".\n+     * For example, a two-dimensional array of String returns \"{@code [][]}\".\n@@ -2090,0 +2088,9 @@\n+    \/**\n+     * Returns the \"raw\" list of block tags from the doc-comment tree for an element,\n+     * or an empty list if there is no such comment.\n+     *\n+     * Note: The list may include {@code ErroneousTree} nodes.\n+     *\n+     * @param element the element\n+     * @return the list\n+     *\/\n@@ -2094,0 +2101,9 @@\n+    \/**\n+     * Returns the \"raw\" list of block tags from a {@code DocCommentTree}, or an empty list\n+     * if the doc-comment tree is {@code null}.\n+     *\n+     * Note: The list may include {@code ErroneousTree} nodes.\n+     *\n+     * @param dcTree the doc-comment tree\n+     * @return the list\n+     *\/\n@@ -2098,1 +2114,9 @@\n-    public List<? extends DocTree> getBlockTags(Element element, Predicate<DocTree> filter) {\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element that match\n+     * a given filter, or an empty list if there is no such doc-comment.\n+     *\n+     * @param element the element\n+     * @param filter  the filter\n+     * @return the list\n+     *\/\n+    public List<? extends BlockTagTree> getBlockTags(Element element, Predicate<? super BlockTagTree> filter) {\n@@ -2101,0 +2125,1 @@\n+                .map(t -> (BlockTagTree) t)\n@@ -2105,1 +2130,12 @@\n-    public <T extends DocTree> List<T> getBlockTags(Element element, Predicate<DocTree> filter, Class<T> tClass) {\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element that match\n+     * a given filter, or an empty list if there is no such doc-comment.\n+     *\n+     * @param <T> the type of the required block tags\n+     * @param element the element\n+     * @param filter  the filter\n+     * @return the list\n+     *\/\n+    public <T extends BlockTagTree> List<T> getBlockTags(Element element,\n+                                                         Predicate<? super BlockTagTree> filter,\n+                                                         Class<T> tClass) {\n@@ -2108,0 +2144,1 @@\n+                .map(t -> (BlockTagTree) t)\n@@ -2113,1 +2150,8 @@\n-    public List<? extends DocTree> getBlockTags(Element element, DocTree.Kind kind) {\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element,\n+     * or an empty list if there is no such doc-comment.\n+     *\n+     * @param element the element\n+     * @return the list\n+     *\/\n+    public List<? extends BlockTagTree> getBlockTags(Element element, DocTree.Kind kind) {\n@@ -2117,1 +2161,10 @@\n-    public <T extends DocTree> List<? extends T> getBlockTags(Element element, DocTree.Kind kind, Class<T> tClass) {\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element that match a given kind,\n+     * or an empty list if there is no such doc-comment.\n+     *\n+     * @param <T> the type of the required block tags\n+     * @param element the element\n+     * @param kind the kind for the required block tags\n+     * @return the list\n+     *\/\n+    public <T extends BlockTagTree> List<? extends T> getBlockTags(Element element, DocTree.Kind kind, Class<T> tClass) {\n@@ -2121,10 +2174,10 @@\n-    public List<? extends DocTree> getBlockTags(Element element, Taglet taglet) {\n-        return getBlockTags(element, t -> {\n-            if (taglet instanceof BaseTaglet baseTaglet) {\n-                return baseTaglet.accepts(t);\n-            } else if (t instanceof BlockTagTree blockTagTree) {\n-                return blockTagTree.getTagName().equals(taglet.getName());\n-            } else {\n-                return false;\n-            }\n-        });\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element that match a given name,\n+     * or an empty list if there is no such doc-comment.\n+     *\n+     * @param element the element\n+     * @param tagName the name of the required block tags\n+     * @return the list\n+     *\/\n+    public List<? extends BlockTagTree> getBlockTags(Element element, String tagName) {\n+        return getBlockTags(element, t -> t.getTagName().equals(tagName));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":71,"deletions":18,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+        if (isVirtual()) {\n+            return -1L;\n+        }\n@@ -93,1 +96,2 @@\n-        return l.longValue();\n+        long id = l.longValue();\n+        return id == 0 ? -1L : id;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedThread.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -430,1 +430,11 @@\n-    public static native boolean flush(EventWriter writer, int uncommittedSize, int requestedSize);\n+    public static native void flush(EventWriter writer, int uncommittedSize, int requestedSize);\n+\n+    \/**\n+     * Commits an event to the underlying buffer by setting the nextPosition.\n+     *\n+     * @param nextPosition\n+     *\n+     * @return the next startPosition\n+     *\/\n+    @IntrinsicCandidate\n+    public static native long commit(long nextPosition);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+    \/* mask for constructing generation relative string id. *\/\n+    private static final long SID_MASK = -65536;\n@@ -51,0 +53,2 @@\n+    \/* string pool generation (0-65535) set by the JVM on epoch shift. Not private to avoid being optimized away. *\/\n+    static short generation = 0;\n@@ -52,4 +56,33 @@\n-    public static void reset() {\n-        cache.clear();\n-        synchronized (StringPool.class) {\n-            currentSizeUTF16 = 0;\n+    \/* internalSid is a composite id [48-bit externalSid][16-bit generation]. *\/\n+    private static boolean isCurrentGeneration(long internalSid) {\n+        return generation == (short)internalSid;\n+    }\n+\n+    private static long updateInternalSid(long internalSid) {\n+        return (internalSid & SID_MASK) | generation;\n+    }\n+\n+    private static long nextInternalSid() {\n+        return sidIdx.getAndIncrement() << 16  | generation;\n+    }\n+\n+    \/* externalSid is the most significant 48-bits of the internalSid. *\/\n+    private static long externalSid(long internalSid) {\n+        return internalSid >> 16;\n+    }\n+\n+    \/* synchronized because of writing the string to the JVM. *\/\n+    private static synchronized long storeString(String s) {\n+        Long lsid = cache.get(s);\n+        long internalSid;\n+        if (lsid != null) {\n+            internalSid = lsid.longValue();\n+            if (isCurrentGeneration(internalSid)) {\n+                \/\/ Someone already updated the cache.\n+                return externalSid(internalSid);\n+            }\n+            internalSid = updateInternalSid(internalSid);\n+        } else {\n+            \/\/ Not yet added or the cache was cleared.\n+            internalSid = nextInternalSid();\n+            currentSizeUTF16 += s.length();\n@@ -57,0 +90,11 @@\n+        long extSid = externalSid(internalSid);\n+        \/\/ Write the string to the JVM before publishing to the cache.\n+        JVM.addStringConstant(extSid, s);\n+        cache.put(s, internalSid);\n+        return extSid;\n+    }\n+\n+    \/* a string fetched from the string pool must be of the current generation *\/\n+    private static long ensureCurrentGeneration(String s, Long lsid) {\n+        long internalSid = lsid.longValue();\n+        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s);\n@@ -59,0 +103,9 @@\n+    \/*\n+     * The string pool uses a generational id scheme to sync the JVM and Java sides.\n+     * The string pool relies on the EventWriter and its implementation, especially\n+     * its ability to restart event write attempts on interleaving epoch shifts.\n+     * Even though a string id is generationally valid during StringPool lookup,\n+     * the JVM can evolve the generation before the event is committed,\n+     * effectively invalidating the fetched string id. The event restart mechanism\n+     * of the EventWriter ensures that committed strings are in the correct generation.\n+     *\/\n@@ -62,1 +115,1 @@\n-            return lsid.longValue();\n+            return ensureCurrentGeneration(s, lsid);\n@@ -75,11 +128,0 @@\n-    private static long storeString(String s) {\n-        long sid = sidIdx.getAndIncrement();\n-        \/* we can race but it is ok *\/\n-        cache.put(s, sid);\n-        synchronized (StringPool.class) {\n-            JVM.addStringConstant(sid, s);\n-            currentSizeUTF16 += s.length();\n-        }\n-        return sid;\n-    }\n-\n@@ -103,0 +145,5 @@\n+\n+    private static synchronized void reset() {\n+        cache.clear();\n+        currentSizeUTF16 = 0;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":64,"deletions":17,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-    private long startPositionAddress;\n@@ -69,1 +68,0 @@\n-    boolean notified; \/\/ Not private to avoid being optimized away\n@@ -73,1 +71,0 @@\n-    private boolean flushOnEnd;\n@@ -215,4 +212,0 @@\n-        if (flushOnEnd) {\n-            flushOnEnd = flush();\n-        }\n-        valid = true;\n@@ -226,1 +219,1 @@\n-            flushOnEnd = flush(usedSize(), requestedSize);\n+            flush(usedSize(), requestedSize);\n@@ -235,12 +228,0 @@\n-    private boolean isNotified() {\n-        return notified;\n-    }\n-\n-    private void resetNotified() {\n-        notified = false;\n-    }\n-\n-    private void resetStringPool() {\n-        StringPool.reset();\n-    }\n-\n@@ -251,2 +232,2 @@\n-    private boolean flush() {\n-        return flush(usedSize(), 0);\n+    private void flush() {\n+        flush(usedSize(), 0);\n@@ -255,2 +236,2 @@\n-    private boolean flush(int usedSize, int requestedSize) {\n-        return JVM.flush(this, usedSize, requestedSize);\n+    private void flush(int usedSize, int requestedSize) {\n+        JVM.flush(this, usedSize, requestedSize);\n@@ -259,1 +240,0 @@\n-\n@@ -280,0 +260,1 @@\n+            valid = true;\n@@ -287,1 +268,0 @@\n-\n@@ -301,7 +281,5 @@\n-\n-        if (isNotified()) {\n-            resetNotified();\n-            resetStringPool();\n-            reset();\n-            \/\/ returning false will trigger restart of the event write attempt\n-            return false;\n+        long nextPosition = JVM.commit(currentPosition);\n+        if (nextPosition == currentPosition) {\n+            \/\/ Successful commit. Update the writer start position.\n+            startPosition = nextPosition;\n+            return true;\n@@ -309,6 +287,4 @@\n-        startPosition = currentPosition;\n-        unsafe.storeStoreFence();\n-        unsafe.putAddress(startPositionAddress, currentPosition);\n-        \/\/ the event is now committed\n-        if (flushOnEnd) {\n-            flushOnEnd = flush();\n+        \/\/ If nextPosition == 0, the event was committed, the underlying buffer lease\n+        \/\/ returned and new writer positions updated. Nothing to do.\n+        if (nextPosition == 0) {\n+            return true;\n@@ -316,1 +292,5 @@\n-        return true;\n+        \/\/ The commit was aborted because of an interleaving epoch shift.\n+        \/\/ The nextPosition returned is the current start position.\n+        \/\/ Reset the writer and return false to restart the write attempt.\n+        currentPosition = nextPosition;\n+        return false;\n@@ -319,1 +299,1 @@\n-    private EventWriter(long startPos, long maxPos, long startPosAddress, long threadID, boolean valid, boolean excluded) {\n+    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean excluded) {\n@@ -322,1 +302,0 @@\n-        startPositionAddress = startPosAddress;\n@@ -324,1 +303,0 @@\n-        flushOnEnd = false;\n@@ -326,1 +304,0 @@\n-        notified = false;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":21,"deletions":44,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-jfr - parse and print Flight Recorder files\n+jfr - print and manipulate Flight Recorder files\n@@ -49,0 +49,8 @@\n+To display aggregated event data on standard out:\n+.PP\n+\\f[V]jfr\\f[R] \\f[V]view\\f[R] [\\f[I]options\\f[R]] \\f[I]file\\f[R]\n+.PP\n+To configure a .jfc settings file:\n+.PP\n+\\f[V]jfr\\f[R] \\f[V]configure\\f[R] [\\f[I]options\\f[R]]\n+.PP\n@@ -51,1 +59,9 @@\n-\\f[V]jfr\\f[R] \\f[V]metadata\\f[R] \\f[I]file\\f[R]\n+\\f[V]jfr\\f[R] \\f[V]metadata\\f[R] [\\f[I]file\\f[R]]\n+.PP\n+To view the summary statistics for a flight recording file:\n+.PP\n+\\f[V]jfr\\f[R] \\f[V]summary\\f[R] \\f[I]file\\f[R]\n+.PP\n+To remove events from a flight recording file:\n+.PP\n+\\f[V]jfr\\f[R] \\f[V]scrub\\f[R] [\\f[I]options\\f[R]] \\f[I]file\\f[R]\n@@ -60,4 +76,0 @@\n-.PP\n-To view the summary statistics for a flight recording file:\n-.PP\n-\\f[V]jfr\\f[R] \\f[V]summary\\f[R] \\f[I]file\\f[R]\n@@ -82,1 +94,2 @@\n-There is also support for merging and splitting recording files.\n+There is also support for scrubbing, merging and splitting recording\n+files.\n@@ -94,0 +107,6 @@\n+\\f[V]view\\f[R]\n+.IP \\[bu] 2\n+\\f[V]configure\\f[R]\n+.IP \\[bu] 2\n+\\f[V]metadata\\f[R]\n+.IP \\[bu] 2\n@@ -96,0 +115,2 @@\n+\\f[V]scrub\\f[R]\n+.IP \\[bu] 2\n@@ -99,2 +120,0 @@\n-.IP \\[bu] 2\n-\\f[V]metadata\\f[R]\n@@ -105,0 +124,1 @@\n+.PP\n@@ -115,1 +135,1 @@\n-Print the recording in XML format\n+Print the recording in XML format.\n@@ -118,1 +138,1 @@\n-Print the recording in JSON format\n+Print the recording in JSON format.\n@@ -123,1 +143,1 @@\n-and\/or quoted glob patterns\n+and\/or quoted glob patterns.\n@@ -128,1 +148,1 @@\n-and\/or quoted glob patterns\n+and\/or quoted glob patterns.\n@@ -131,1 +151,1 @@\n-Number of frames in stack traces, by default 5\n+Number of frames in stack traces, by default 5.\n@@ -167,0 +187,105 @@\n+.SS \\f[V]jfr view\\f[R] subcommand\n+.PP\n+Use \\f[V]jfr view\\f[R] to aggregate and display event data on standard\n+out.\n+.PP\n+The syntax is:\n+.PP\n+\\f[V]jfr view\\f[R] [\\f[V]--verbose\\f[R]] [\\f[V]--width\\f[R]\n+<\\f[I]integer\\f[R]>] [\\f[V]--truncate\\f[R] <\\f[I]mode\\f[R]>]\n+[\\f[V]--cell-height\\f[R] <\\f[I]integer\\f[R]>] <\\f[I]view\\f[R]>\n+<\\f[I]file\\f[R]>\n+.PP\n+where:\n+.TP\n+\\f[V]--verbose\\f[R]\n+Displays the query that makes up the view.\n+.TP\n+\\f[V]--width\\f[R] <\\f[I]integer\\f[R]>\n+The width of the view in characters.\n+Default value depends on the view.\n+.TP\n+\\f[V]--truncate\\f[R] <\\f[I]mode\\f[R]>\n+How to truncate content that exceeds space in a table cell.\n+Mode can be \\[aq]beginning\\[aq] or \\[aq]end\\[aq].\n+Default value is \\[aq]end\\[aq].\n+.TP\n+\\f[V]--cell-height\\f[R] <\\f[I]integer\\f[R]>\n+Maximum number of rows in a table cell.\n+Default value depends on the view.\n+.TP\n+<\\f[I]view\\f[R]>\n+Name of the view or event type to display.\n+Use \\f[V]jfr --help view\\f[R] to see a list of available views.\n+.TP\n+<\\f[I]file\\f[R]>\n+Location of the recording file (.jfr)\n+.PP\n+The parameter can be an event type name.\n+Use the \\f[V]jfr view types <file>\\f[R] to see a list.\n+To display all views, use \\f[V]jfr view all-views <file>\\f[R].\n+To display all events, use \\f[V]jfr view all-events <file>\\f[R].\n+.SS \\f[V]jfr configure\\f[R] subcommand\n+.PP\n+Use \\f[V]jfr configure\\f[R] to configure a .jfc settings file.\n+.PP\n+The syntax is:\n+.PP\n+\\f[V]jfr configure\\f[R] [--interactive] [--verbose] [--input ] [--output\n+] [option=value]* [event-setting=value]*\n+.TP\n+\\f[V]--interactive\\f[R]\n+Interactive mode where the configuration is determined by a set of\n+questions.\n+.TP\n+\\f[V]--verbose\\f[R]\n+Displays the modified settings.\n+.TP\n+\\f[V]--input\\f[R] <\\f[I]files\\f[R]>\n+A comma-separated list of .jfc files from which the new configuration is\n+based.\n+If no file is specified, the default file in the JDK is used\n+(default.jfc).\n+If \\[aq]none\\[aq] is specified, the new configuration starts empty.\n+.TP\n+\\f[V]--output\\f[R] <\\f[I]file\\f[R]>\n+The filename of the generated output file.\n+If not specified, the filename custom.jfc will be used.\n+.TP\n+\\f[I]option=value\\f[R]\n+The option value to modify.\n+To see available options, use \\f[V]jfr help configure\\f[R]\n+.TP\n+\\f[I]event-setting=value\\f[R]\n+The event setting value to modify.\n+Use the form: <\\f[I]event-name>#=<value\\f[R]> To add a new event\n+setting, prefix the event name with \\[aq]+\\[aq].\n+.PP\n+The whitespace delimiter can be omitted for timespan values, i.e.\n+20ms.\n+For more information about the settings syntax, see Javadoc of the\n+jdk.jfr package.\n+.SS \\f[V]jfr metadata\\f[R] subcommand\n+.PP\n+Use \\f[V]jfr metadata\\f[R] to display information about events, such as\n+event names, categories and field layout within a flight recording file.\n+.PP\n+The syntax is:\n+.PP\n+\\f[V]jfr metadata\\f[R] [--categories ] [--events ] []\n+.TP\n+\\f[V]--categories\\f[R] <\\f[I]filter\\f[R]>\n+Select events matching a category name.\n+The filter is a comma-separated list of names, simple and\/or qualified,\n+and\/or quoted glob patterns.\n+.TP\n+\\f[V]--events\\f[R] <\\f[I]filter\\f[R]>\n+Select events matching an event name.\n+The filter is a comma-separated list of names, simple and\/or qualified,\n+and\/or quoted glob patterns.\n+.TP\n+<\\f[I]file\\f[R]>\n+Location of the recording file (.jfr)\n+.PP\n+If the parameter is omitted, metadata from the JDK where the\n+\\[aq]jfr\\[aq] tool is located will be used.\n@@ -183,1 +308,4 @@\n-.SS \\f[V]jfr metadata\\f[R] subcommand\n+.SS \\f[V]jfr scrub\\f[R] subcommand\n+.PP\n+Use \\f[V]jfr scrub\\f[R] to remove sensitive contents from a file or to\n+reduce its size.\n@@ -185,2 +313,0 @@\n-Use \\f[V]jfr metadata\\f[R] to view information about events, such as\n-event names, categories and field layout within a flight recording file.\n@@ -189,1 +315,23 @@\n-\\f[V]jfr metadata\\f[R] <\\f[I]file\\f[R]>\n+\\f[V]jfr scrub\\f[R] [--include-events <\\f[I]filter\\f[R]>]\n+[--exclude-events <\\f[I]filter\\f[R]>] [--include-categories\n+<\\f[I]filter\\f[R]>] [--exclude-categories <\\f[I]filter\\f[R]>]\n+[--include-threads <\\f[I]filter\\f[R]>] [--exclude-threads\n+<\\f[I]filter\\f[R]>] <\\f[I]input-file\\f[R]> []\n+.TP\n+\\f[V]--include-events\\f[R] <\\f[I]filter\\f[R]>\n+Select events matching an event name.\n+.TP\n+\\f[V]--exclude-events\\f[R] <\\f[I]filter\\f[R]>\n+Exclude events matching an event name.\n+.TP\n+\\f[V]--include-categories\\f[R] <\\f[I]filter\\f[R]>\n+Select events matching a category name.\n+.TP\n+\\f[V]--exclude-categories\\f[R] <\\f[I]filter\\f[R]>\n+Exclude events matching a category name.\n+.TP\n+\\f[V]--include-threads\\f[R] <\\f[I]filter\\f[R]>\n+Select events matching a thread name.\n+.TP\n+\\f[V]--exclude-threads\\f[R] <\\f[I]filter\\f[R]>\n+Exclude events matching a thread name.\n@@ -191,1 +339,1 @@\n-where:\n+<\\f[I]input-file\\f[R]> :The input file to read events from.\n@@ -193,2 +341,8 @@\n-<\\f[I]file\\f[R]>\n-Location of the flight recording file (\\f[V].jfr\\f[R])\n+<\\f[I]output-file\\f[R]>\n+The output file to write filter events to.\n+If no file is specified, it will be written to the same path as the\n+input file, but with \\[dq]-scrubbed\\[dq] appended to the filename.\n+.PP\n+The filter is a comma-separated list of names, simple and\/or qualified,\n+and\/or quoted glob patterns.\n+If multiple filters are used, they are applied in the specified order.\n@@ -207,1 +361,1 @@\n-Directory where the repository containing chunk files is located\n+Directory where the repository containing chunk files is located.\n@@ -210,1 +364,1 @@\n-Location of the flight recording file (\\f[V].jfr\\f[R])\n+Location of the flight recording file (\\f[V].jfr\\f[R]).\n@@ -223,0 +377,1 @@\n+.PP\n@@ -269,0 +424,4 @@\n+\\f[V]view\\f[R]\n+.IP \\[bu] 2\n+\\f[V]configure\\f[R]\n+.IP \\[bu] 2\n@@ -273,0 +432,2 @@\n+\\f[V]scrub\\f[R]\n+.IP \\[bu] 2\n","filename":"src\/jdk.jfr\/share\/man\/jfr.1","additions":185,"deletions":24,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-import jdk.tools.jlink.plugin.ResourcePoolModule;\n@@ -148,1 +147,1 @@\n-    private Platform platform;\n+    private final Platform platform;\n@@ -154,0 +153,2 @@\n+     * @param launchers mapping of launcher command name to their module\/main class\n+     * @param targetPlatform target platform of the image\n@@ -155,0 +156,1 @@\n+     * @throws NullPointerException If any of the params is null\n@@ -156,1 +158,2 @@\n-    public DefaultImageBuilder(Path root, Map<String, String> launchers) throws IOException {\n+    public DefaultImageBuilder(Path root, Map<String, String> launchers, Platform targetPlatform)\n+            throws IOException {\n@@ -158,0 +161,1 @@\n+        this.platform = Objects.requireNonNull(targetPlatform);\n@@ -171,13 +175,0 @@\n-            String value = files.moduleView()\n-                                .findModule(\"java.base\")\n-                                .map(ResourcePoolModule::targetPlatform)\n-                                .orElse(null);\n-            if (value == null) {\n-                throw new PluginException(\"ModuleTarget attribute is missing for java.base module\");\n-            }\n-            try {\n-                this.platform = Platform.parsePlatform(value);\n-            } catch (IllegalArgumentException iae) {\n-                throw new PluginException(\"ModuleTarget is malformed: \" + iae.getMessage());\n-            }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-        private final ByteOrder endian;\n@@ -158,1 +157,0 @@\n-         * @param endian Jimage byte order. Native order by default\n@@ -163,1 +161,0 @@\n-                                  ByteOrder endian,\n@@ -167,1 +164,0 @@\n-            this.endian = Objects.requireNonNull(endian);\n@@ -171,7 +167,0 @@\n-        \/**\n-         * @return the byte ordering\n-         *\/\n-        public ByteOrder getByteOrder() {\n-            return endian;\n-        }\n-\n@@ -232,1 +221,0 @@\n-            builder.append(\"endian=\").append(endian).append(\"\\n\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Jlink.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.internal.module.ModuleReferenceImpl;\n@@ -71,2 +72,0 @@\n-import jdk.tools.jlink.builder.DefaultImageBuilder;\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -222,1 +221,1 @@\n-        ByteOrder endian = ByteOrder.nativeOrder();\n+        ByteOrder endian;\n@@ -358,0 +357,1 @@\n+                                    null,\n@@ -397,1 +397,0 @@\n-                                      options.endian,\n@@ -411,6 +410,7 @@\n-        ImageProvider imageProvider = createImageProvider(config,\n-                                                          options.packagedModulesPath,\n-                                                          options.ignoreSigning,\n-                                                          options.bindServices,\n-                                                          options.verbose,\n-                                                          log);\n+        ImageHelper imageProvider = createImageProvider(config,\n+                                                        options.packagedModulesPath,\n+                                                        options.ignoreSigning,\n+                                                        options.bindServices,\n+                                                        options.endian,\n+                                                        options.verbose,\n+                                                        log);\n@@ -420,1 +420,2 @@\n-            taskHelper.getPluginsConfig(options.output, options.launchers));\n+            taskHelper.getPluginsConfig(options.output, options.launchers,\n+                    imageProvider.targetPlatform));\n@@ -514,6 +515,7 @@\n-    private static ImageProvider createImageProvider(JlinkConfiguration config,\n-                                                     Path retainModulesPath,\n-                                                     boolean ignoreSigning,\n-                                                     boolean bindService,\n-                                                     boolean verbose,\n-                                                     PrintWriter log)\n+    private static ImageHelper createImageProvider(JlinkConfiguration config,\n+                                                   Path retainModulesPath,\n+                                                   boolean ignoreSigning,\n+                                                   boolean bindService,\n+                                                   ByteOrder endian,\n+                                                   boolean verbose,\n+                                                   PrintWriter log)\n@@ -566,1 +568,16 @@\n-        return new ImageHelper(cf, mods, config.getByteOrder(), retainModulesPath, ignoreSigning);\n+        \/\/ determine the target platform of the image being created\n+        Platform targetPlatform = targetPlatform(cf, mods);\n+        \/\/ if the user specified any --endian, then it must match the target platform's native\n+        \/\/ endianness\n+        if (endian != null && endian != targetPlatform.arch().byteOrder()) {\n+            throw new IOException(\n+                    taskHelper.getMessage(\"err.target.endianness.mismatch\", endian, targetPlatform));\n+        }\n+        if (verbose && log != null) {\n+            Platform runtime = Platform.runtime();\n+            if (runtime.os() != targetPlatform.os() || runtime.arch() != targetPlatform.arch()) {\n+                log.format(\"Cross-platform image generation, using %s for target platform %s%n\",\n+                        targetPlatform.arch().byteOrder(), targetPlatform);\n+            }\n+        }\n+        return new ImageHelper(cf, mods, targetPlatform, retainModulesPath, ignoreSigning);\n@@ -612,0 +629,57 @@\n+    private static Platform targetPlatform(Configuration cf, Map<String, Path> modsPaths) throws IOException {\n+        Path javaBasePath = modsPaths.get(\"java.base\");\n+        assert javaBasePath != null : \"java.base module path is missing\";\n+        if (isJavaBaseFromDefaultModulePath(javaBasePath)) {\n+            \/\/ this implies that the java.base module used for the target image\n+            \/\/ will correspond to the current platform. So this isn't an attempt to\n+            \/\/ build a cross-platform image. We use the current platform's endianness\n+            \/\/ in this case\n+            return Platform.runtime();\n+        } else {\n+            \/\/ this is an attempt to build a cross-platform image. We now attempt to\n+            \/\/ find the target platform's arch and thus its endianness from the java.base\n+            \/\/ module's ModuleTarget attribute\n+            String targetPlatformVal = readJavaBaseTargetPlatform(cf);\n+            try {\n+                return Platform.parsePlatform(targetPlatformVal);\n+            } catch (IllegalArgumentException iae) {\n+                throw new IOException(\n+                        taskHelper.getMessage(\"err.unknown.target.platform\", targetPlatformVal));\n+            }\n+        }\n+    }\n+\n+    \/\/ returns true if the default module-path is the parent of the passed javaBasePath\n+    private static boolean isJavaBaseFromDefaultModulePath(Path javaBasePath) throws IOException {\n+        Path defaultModulePath = getDefaultModulePath();\n+        if (defaultModulePath == null) {\n+            return false;\n+        }\n+        \/\/ resolve, against the default module-path dir, the java.base module file used\n+        \/\/ for image creation\n+        Path javaBaseInDefaultPath = defaultModulePath.resolve(javaBasePath.getFileName());\n+        if (Files.notExists(javaBaseInDefaultPath)) {\n+            \/\/ the java.base module used for image creation doesn't exist in the default\n+            \/\/ module path\n+            return false;\n+        }\n+        return Files.isSameFile(javaBasePath, javaBaseInDefaultPath);\n+    }\n+\n+    \/\/ returns the targetPlatform value from the ModuleTarget attribute of the java.base module.\n+    \/\/ throws IOException if the targetPlatform cannot be determined.\n+    private static String readJavaBaseTargetPlatform(Configuration cf) throws IOException {\n+        Optional<ResolvedModule> javaBase = cf.findModule(\"java.base\");\n+        assert javaBase.isPresent() : \"java.base module is missing\";\n+        ModuleReference ref = javaBase.get().reference();\n+        if (ref instanceof ModuleReferenceImpl modRefImpl\n+                && modRefImpl.moduleTarget() != null) {\n+            return modRefImpl.moduleTarget().targetPlatform();\n+        }\n+        \/\/ could not determine target platform\n+        throw new IOException(\n+                taskHelper.getMessage(\"err.cannot.determine.target.platform\",\n+                        ref.location().map(URI::toString)\n+                                .orElse(\"java.base module\")));\n+    }\n+\n@@ -775,1 +849,1 @@\n-        final ByteOrder order;\n+        final Platform targetPlatform;\n@@ -783,1 +857,1 @@\n-                    ByteOrder order,\n+                    Platform targetPlatform,\n@@ -786,1 +860,2 @@\n-            this.order = order;\n+            Objects.requireNonNull(targetPlatform);\n+            this.targetPlatform = targetPlatform;\n@@ -860,1 +935,2 @@\n-            ExecutableImage image = ImageFileCreator.create(archives, order, stack);\n+            ExecutableImage image = ImageFileCreator.create(archives,\n+                    targetPlatform.arch().byteOrder(), stack);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":98,"deletions":22,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -53,4 +53,1 @@\n-        \/\/ Alias architecture names, if needed\n-        archName = archName.replace(\"amd64\", \"X64\");\n-        archName = archName.replace(\"s390x\", \"S390\");\n-        Architecture arch = Architecture.valueOf(archName.toUpperCase(Locale.ROOT));\n+        Architecture arch = Architecture.lookupByName(archName);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Platform.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -412,2 +412,3 @@\n-        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers\n-                    ) throws IOException, BadArgs {\n+        private PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                      Platform targetPlatform)\n+                throws IOException, BadArgs {\n@@ -460,1 +461,1 @@\n-                builder = new DefaultImageBuilder(output, launchers);\n+                builder = new DefaultImageBuilder(output, launchers, targetPlatform);\n@@ -711,1 +712,2 @@\n-    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers)\n+    public PluginsConfiguration getPluginsConfig(Path output, Map<String, String> launchers,\n+                                                 Platform targetPlatform)\n@@ -713,1 +715,1 @@\n-        return pluginOptions.getPluginsConfig(output, launchers);\n+        return pluginOptions.getPluginsConfig(output, launchers, targetPlatform);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/TaskHelper.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -149,0 +149,4 @@\n+err.cannot.determine.target.platform=cannot determine target platform from {0}\n+err.unknown.target.platform=unknown target platform {0}\n+err.target.endianness.mismatch=specified --endian {0} does not match endianness of target \\\n+platform {1}\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,2 @@\n-     * These are JDI com.sun.jdi.connect.Connector arguments.\n+     * These are JDI com.sun.jdi.connect.Connector arguments. The {@code vmexec}\n+     * argument is not supported.\n@@ -108,1 +109,4 @@\n-        argumentName2Value.putAll(customConnectorArgs);\n+        customConnectorArgs.entrySet()\n+                           .stream()\n+                           .filter(e -> !\"vmexec\".equals(e.getKey()))\n+                           .forEach(e -> argumentName2Value.put(e.getKey(), e.getValue()));\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiInitiator.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3073,0 +3073,5 @@\n+            \/\/ Extra field Length cannot exceed 65,535 bytes per the PKWare\n+            \/\/ APP.note 4.4.11\n+            if (elen > 0xFFFF) {\n+                throw new ZipException(\"invalid extra field length\");\n+            }\n@@ -3082,2 +3087,3 @@\n-                if (pos + sz > elen)         \/\/ invalid data\n-                    break;\n+                if (pos + sz > elen) {        \/\/ invalid data\n+                    throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+                }\n@@ -3086,0 +3092,4 @@\n+                    \/\/ Check to see if we have a valid block size\n+                    if (!isZip64ExtBlockSizeValid(sz)) {\n+                        throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+                    }\n@@ -3090,0 +3100,3 @@\n+                        if (size < 0) {\n+                            throw new ZipException(\"Invalid zip64 extra block size value\");\n+                        }\n@@ -3096,0 +3109,3 @@\n+                        if (csize < 0) {\n+                            throw new ZipException(\"Invalid zip64 extra block compressed size value\");\n+                        }\n@@ -3102,0 +3118,3 @@\n+                        if (locoff < 0) {\n+                            throw new ZipException(\"Invalid zip64 extra block LOC offset value\");\n+                        }\n@@ -3159,0 +3178,30 @@\n+        \/**\n+         * Validate the size and contents of a Zip64 extended information field\n+         * The order of the Zip64 fields is fixed, but the fields MUST\n+         * only appear if the corresponding LOC or CEN field is set to 0xFFFF:\n+         * or 0xFFFFFFFF:\n+         * Uncompressed Size - 8 bytes\n+         * Compressed Size   - 8 bytes\n+         * LOC Header offset - 8 bytes\n+         * Disk Start Number - 4 bytes\n+         * See PKWare APP.Note Section 4.5.3 for more details\n+         *\n+         * @param blockSize the Zip64 Extended Information Extra Field size\n+         * @return true if the extra block size is valid; false otherwise\n+         *\/\n+        private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n+            \/*\n+             * As the fields must appear in order, the block size indicates which\n+             * fields to expect:\n+             *  8 - uncompressed size\n+             * 16 - uncompressed size, compressed size\n+             * 24 - uncompressed size, compressed sise, LOC Header offset\n+             * 28 - uncompressed size, compressed sise, LOC Header offset,\n+             * and Disk start number\n+             *\/\n+            return switch(blockSize) {\n+                case 8, 16, 24, 28 -> true;\n+                default -> false;\n+            };\n+        }\n+\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -639,14 +639,1 @@\n-        int len1 = this.path.length;\n-        int len2 = o.path.length;\n-\n-        int n = Math.min(len1, len2);\n-\n-        int k = 0;\n-        while (k < n) {\n-            int c1 = this.path[k] & 0xff;\n-            int c2 = o.path[k] & 0xff;\n-            if (c1 != c2)\n-                return c1 - c2;\n-            k++;\n-        }\n-        return len1 - len2;\n+        return Arrays.compareUnsigned(this.path, o.path);\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"unittest.hpp\"\n+\n+typedef void (*arraycopy_fn)(address src, address dst, int count);\n+\n+\/\/ simple tests of generated arraycopy functions\n+static void test_arraycopy_func(address func, int alignment) {\n+  int v = 0xcc;\n+  int v2 = 0x11;\n+  jlong lbuffer[8];\n+  jlong lbuffer2[8];\n+  address fbuffer  = (address) lbuffer;\n+  address fbuffer2 = (address) lbuffer2;\n+  unsigned int i;\n+  for (i = 0; i < sizeof(lbuffer); i++) {\n+    fbuffer[i] = v; fbuffer2[i] = v2;\n+  }\n+  \/\/ C++ does not guarantee jlong[] array alignment to 8 bytes.\n+  \/\/ Use middle of array to check that memory before it is not modified.\n+  address buffer  = align_up((address)&lbuffer[4], BytesPerLong);\n+  address buffer2 = align_up((address)&lbuffer2[4], BytesPerLong);\n+  \/\/ do an aligned copy\n+  ((arraycopy_fn)func)(buffer, buffer2, 0);\n+  for (i = 0; i < sizeof(lbuffer); i++) {\n+    ASSERT_TRUE(fbuffer[i] == v && fbuffer2[i] == v2) << \"shouldn't have copied anything\";\n+  }\n+  \/\/ adjust destination alignment\n+  ((arraycopy_fn)func)(buffer, buffer2 + alignment, 0);\n+  for (i = 0; i < sizeof(lbuffer); i++) {\n+    ASSERT_TRUE(fbuffer[i] == v && fbuffer2[i] == v2) << \"shouldn't have copied anything\";\n+  }\n+  \/\/ adjust source alignment\n+  ((arraycopy_fn)func)(buffer + alignment, buffer2, 0);\n+  for (i = 0; i < sizeof(lbuffer); i++) {\n+    ASSERT_TRUE(fbuffer[i] == v && fbuffer2[i] == v2) << \"shouldn't have copied anything\";\n+  }\n+}\n+\n+TEST_VM(StubRoutines, array_copy_routine) {\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n+#define TEST_ARRAYCOPY(type)                                                                  \\\n+  test_arraycopy_func(          StubRoutines::type##_arraycopy(),          sizeof(type));     \\\n+  test_arraycopy_func(          StubRoutines::type##_disjoint_arraycopy(), sizeof(type));     \\\n+  test_arraycopy_func(StubRoutines::arrayof_##type##_arraycopy(),          sizeof(HeapWord)); \\\n+  test_arraycopy_func(StubRoutines::arrayof_##type##_disjoint_arraycopy(), sizeof(HeapWord))\n+\n+  \/\/ Make sure all the arraycopy stubs properly handle zero count\n+  TEST_ARRAYCOPY(jbyte);\n+  TEST_ARRAYCOPY(jshort);\n+  TEST_ARRAYCOPY(jint);\n+  TEST_ARRAYCOPY(jlong);\n+\n+#undef TEST_ARRAYCOPY\n+\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+}\n+\n+TEST_VM(StubRoutines, copy_routine) {\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n+#define TEST_COPYRTN(type) \\\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::conjoint_##type##s_atomic),  sizeof(type)); \\\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::arrayof_conjoint_##type##s), (int)MAX2(sizeof(HeapWord), sizeof(type)))\n+\n+  \/\/ Make sure all the copy runtime routines properly handle zero count\n+  TEST_COPYRTN(jbyte);\n+  TEST_COPYRTN(jshort);\n+  TEST_COPYRTN(jint);\n+  TEST_COPYRTN(jlong);\n+\n+#undef TEST_COPYRTN\n+\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::conjoint_words), sizeof(HeapWord));\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::disjoint_words), sizeof(HeapWord));\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::disjoint_words_atomic), sizeof(HeapWord));\n+  \/\/ Aligned to BytesPerLong\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_conjoint_words), sizeof(jlong));\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_disjoint_words), sizeof(jlong));\n+\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+}\n+\n+TEST_VM(StubRoutines, array_fill_routine) {\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n+#define TEST_FILL(type)                                                                      \\\n+  if (StubRoutines::_##type##_fill != nullptr) {                                             \\\n+    union {                                                                                  \\\n+      double d;                                                                              \\\n+      type body[96];                                                                         \\\n+    } s;                                                                                     \\\n+                                                                                             \\\n+    int v = 32;                                                                              \\\n+    for (int offset = -2; offset <= 2; offset++) {                                           \\\n+      for (int i = 0; i < 96; i++) {                                                         \\\n+        s.body[i] = 1;                                                                       \\\n+      }                                                                                      \\\n+      type* start = s.body + 8 + offset;                                                     \\\n+      for (int aligned = 0; aligned < 2; aligned++) {                                        \\\n+        if (aligned) {                                                                       \\\n+          if (((intptr_t)start) % HeapWordSize == 0) {                                       \\\n+            ((void (*)(type*, int, int))StubRoutines::_arrayof_##type##_fill)(start, v, 80); \\\n+          } else {                                                                           \\\n+            continue;                                                                        \\\n+          }                                                                                  \\\n+        } else {                                                                             \\\n+          ((void (*)(type*, int, int))StubRoutines::_##type##_fill)(start, v, 80);           \\\n+        }                                                                                    \\\n+        for (int i = 0; i < 96; i++) {                                                       \\\n+          if (i < (8 + offset) || i >= (88 + offset)) {                                      \\\n+            ASSERT_TRUE(s.body[i] == 1) << \"what?\";                                          \\\n+          } else {                                                                           \\\n+            ASSERT_TRUE(s.body[i] == 32) << \"what?\";                                         \\\n+          }                                                                                  \\\n+        }                                                                                    \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+  }                                                                                          \\\n+\n+  TEST_FILL(jbyte);\n+  TEST_FILL(jshort);\n+  TEST_FILL(jint);\n+\n+#undef TEST_FILL\n+\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_stubRoutines.cpp","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -76,0 +76,1 @@\n+compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java 8314923 generic-all\n@@ -111,0 +112,1 @@\n+applications\/ctw\/modules\/jdk_crypto_ec.java 8312194 generic-all\n@@ -128,0 +130,1 @@\n+serviceability\/jvmti\/vthread\/VThreadTLSTest\/VThreadTLSTest.java#id1 8300051 generic-all\n@@ -209,2 +212,0 @@\n-\n-vmTestbase\/nsk\/jdb\/interrupt\/interrupt001\/interrupt001.java 8310551 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    vm.jvmci.enabled \\\n@@ -80,0 +81,2 @@\n+    jdk.hasLibgraal \\\n+    vm.libgraal.enabled \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,1413 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8281429\n+ * @summary Tests that C2 can correctly scalar replace some object allocation merges.\n+ * @library \/test\/lib \/\n+ * @requires vm.debug == true & vm.bits == 64 & vm.compiler2.enabled & vm.opt.final.UseCompressedOops & vm.opt.final.EliminateAllocations\n+ * @run driver compiler.c2.irTests.scalarReplacement.AllocationMergesTests\n+ *\/\n+public class AllocationMergesTests {\n+    private int invocations = 0;\n+    private static Point global_escape = new Point(2022, 2023);\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UnlockDiagnosticVMOptions\",\n+                                   \"-XX:+ReduceAllocationMerges\",\n+                                   \"-XX:+TraceReduceAllocationMerges\",\n+                                   \"-XX:+DeoptimizeALot\",\n+                                   \"-XX:CompileCommand=exclude,*::dummy*\");\n+    }\n+\n+    \/\/ ------------------ No Scalar Replacement Should Happen in The Tests Below ------------------- \/\/\n+\n+    @Run(test = {\"testGlobalEscape_C2\",\n+                 \"testArgEscape_C2\",\n+                 \"testEscapeInCallAfterMerge_C2\",\n+                 \"testNoEscapeWithWriteInLoop_C2\",\n+                 \"testPollutedWithWrite_C2\",\n+                 \"testPollutedPolymorphic_C2\",\n+                 \"testMergedLoadAfterDirectStore_C2\",\n+                 \"testMergedAccessAfterCallWithWrite_C2\",\n+                 \"testLoadAfterTrap_C2\",\n+                 \"testCondAfterMergeWithNull_C2\",\n+                 \"testLoadAfterLoopAlias_C2\",\n+                 \"testCallTwoSide_C2\",\n+                 \"testMergedAccessAfterCallNoWrite_C2\",\n+                 \"testCmpMergeWithNull_Second_C2\",\n+                 \"testObjectIdentity_C2\",\n+                 \"testSubclassesTrapping_C2\",\n+                 \"testCmpMergeWithNull_C2\",\n+                 \"testSubclasses_C2\",\n+                 \"testPartialPhis_C2\",\n+                 \"testPollutedNoWrite_C2\",\n+                 \"testThreeWayAliasedAlloc_C2\",\n+                 \"TestTrapAfterMerge_C2\",\n+                 \"testNestedObjectsObject_C2\",\n+                 \"testNestedObjectsNoEscapeObject_C2\",\n+                 \"testNestedObjectsArray_C2\",\n+                 \"testTrappingAfterMerge_C2\",\n+                 \"testSimpleAliasedAlloc_C2\",\n+                 \"testSimpleDoubleMerge_C2\",\n+                 \"testConsecutiveSimpleMerge_C2\",\n+                 \"testDoubleIfElseMerge_C2\",\n+                 \"testNoEscapeWithLoadInLoop_C2\",\n+                 \"testCmpAfterMerge_C2\",\n+                 \"testCondAfterMergeWithAllocate_C2\",\n+                 \"testCondLoadAfterMerge_C2\",\n+                 \"testIfElseInLoop_C2\",\n+                 \"testLoadInCondAfterMerge_C2\",\n+                 \"testLoadInLoop_C2\",\n+                 \"testMergesAndMixedEscape_C2\",\n+                 \"testSRAndNSR_NoTrap_C2\",\n+                 \"testSRAndNSR_Trap_C2\",\n+                 \"testString_one_C2\",\n+                 \"testString_two_C2\"\n+                })\n+    public void runner(RunInfo info) {\n+        Random random = info.getRandom();\n+        boolean cond1 = random.nextBoolean();\n+        boolean cond2 = random.nextBoolean();\n+\n+        int l = random.nextInt();\n+        int w = random.nextInt();\n+        int x = random.nextInt();\n+        int y = random.nextInt();\n+        int z = random.nextInt();\n+\n+        Asserts.assertEQ(testGlobalEscape_Interp(x, y),                             testGlobalEscape_C2(x, y));\n+        Asserts.assertEQ(testArgEscape_Interp(x, y),                                testArgEscape_C2(x, y));\n+        Asserts.assertEQ(testEscapeInCallAfterMerge_Interp(cond1, cond2, x, y),     testEscapeInCallAfterMerge_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testNoEscapeWithWriteInLoop_Interp(cond1, cond2, x, y),    testNoEscapeWithWriteInLoop_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testPollutedWithWrite_Interp(cond1, x),                    testPollutedWithWrite_C2(cond1, x));\n+        Asserts.assertEQ(testPollutedPolymorphic_Interp(cond1, x),                  testPollutedPolymorphic_C2(cond1, x));\n+        Asserts.assertEQ(testMergedLoadAfterDirectStore_Interp(cond1, x, y),        testMergedLoadAfterDirectStore_C2(cond1, x, y));\n+        Asserts.assertEQ(testMergedAccessAfterCallWithWrite_Interp(cond1, x, y),    testMergedAccessAfterCallWithWrite_C2(cond1, x, y));\n+        Asserts.assertEQ(testLoadAfterTrap_Interp(cond1, x, y),                     testLoadAfterTrap_C2(cond1, x, y));\n+        Asserts.assertEQ(testCondAfterMergeWithNull_Interp(cond1, cond2, x, y),     testCondAfterMergeWithNull_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testLoadAfterLoopAlias_Interp(cond1, x, y),                testLoadAfterLoopAlias_C2(cond1, x, y));\n+        Asserts.assertEQ(testCallTwoSide_Interp(cond1, x, y),                       testCallTwoSide_C2(cond1, x, y));\n+        Asserts.assertEQ(testMergedAccessAfterCallNoWrite_Interp(cond1, x, y),      testMergedAccessAfterCallNoWrite_C2(cond1, x, y));\n+        Asserts.assertEQ(testCmpMergeWithNull_Second_Interp(cond1, x, y),           testCmpMergeWithNull_Second_C2(cond1, x, y));\n+        Asserts.assertEQ(testObjectIdentity_Interp(cond1, 42, y),                   testObjectIdentity_C2(cond1, 42, y));\n+        Asserts.assertEQ(testSubclassesTrapping_Interp(cond1, cond2, x, y, w, z),   testSubclassesTrapping_C2(cond1, cond2, x, y, w, z));\n+        Asserts.assertEQ(testCmpMergeWithNull_Interp(cond1, x, y),                  testCmpMergeWithNull_C2(cond1, x, y));\n+        Asserts.assertEQ(testSubclasses_Interp(cond1, cond2, x, y, w, z),           testSubclasses_C2(cond1, cond2, x, y, w, z));\n+        Asserts.assertEQ(testPartialPhis_Interp(cond1, l, x, y),                    testPartialPhis_C2(cond1, l, x, y));\n+        Asserts.assertEQ(testPollutedNoWrite_Interp(cond1, l),                      testPollutedNoWrite_C2(cond1, l));\n+        Asserts.assertEQ(testThreeWayAliasedAlloc_Interp(cond1, x, y),              testThreeWayAliasedAlloc_C2(cond1, x, y));\n+        Asserts.assertEQ(TestTrapAfterMerge_Interp(cond1, x, y),                    TestTrapAfterMerge_C2(cond1, x, y));\n+        Asserts.assertEQ(testNestedObjectsObject_Interp(cond1, x, y),               testNestedObjectsObject_C2(cond1, x, y));\n+        Asserts.assertEQ(testNestedObjectsNoEscapeObject_Interp(cond1, x, y),       testNestedObjectsNoEscapeObject_C2(cond1, x, y));\n+        Asserts.assertEQ(testTrappingAfterMerge_Interp(cond1, x, y),                testTrappingAfterMerge_C2(cond1, x, y));\n+        Asserts.assertEQ(testSimpleAliasedAlloc_Interp(cond1, x, y),                testSimpleAliasedAlloc_C2(cond1, x, y));\n+        Asserts.assertEQ(testSimpleDoubleMerge_Interp(cond1, x, y),                 testSimpleDoubleMerge_C2(cond1, x, y));\n+        Asserts.assertEQ(testConsecutiveSimpleMerge_Interp(cond1, cond2, x, y),     testConsecutiveSimpleMerge_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testDoubleIfElseMerge_Interp(cond1, x, y),                 testDoubleIfElseMerge_C2(cond1, x, y));\n+        Asserts.assertEQ(testNoEscapeWithLoadInLoop_Interp(cond1, x, y),            testNoEscapeWithLoadInLoop_C2(cond1, x, y));\n+        Asserts.assertEQ(testCmpAfterMerge_Interp(cond1, cond2, x, y),              testCmpAfterMerge_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testCondAfterMergeWithAllocate_Interp(cond1, cond2, x, y), testCondAfterMergeWithAllocate_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testCondLoadAfterMerge_Interp(cond1, cond2, x, y),         testCondLoadAfterMerge_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testIfElseInLoop_Interp(),                                 testIfElseInLoop_C2());\n+        Asserts.assertEQ(testLoadInCondAfterMerge_Interp(cond1, x, y),              testLoadInCondAfterMerge_C2(cond1, x, y));\n+        Asserts.assertEQ(testLoadInLoop_Interp(cond1, x, y),                        testLoadInLoop_C2(cond1, x, y));\n+        Asserts.assertEQ(testMergesAndMixedEscape_Interp(cond1, x, y),              testMergesAndMixedEscape_C2(cond1, x, y));\n+        Asserts.assertEQ(testSRAndNSR_NoTrap_Interp(cond1, x, y),                   testSRAndNSR_NoTrap_C2(cond1, x, y));\n+        Asserts.assertEQ(testString_one_Interp(cond1),                              testString_one_C2(cond1));\n+        Asserts.assertEQ(testString_two_Interp(cond1),                              testString_two_C2(cond1));\n+\n+        Asserts.assertEQ(testSRAndNSR_Trap_Interp(false, cond1, cond2, x, y),\n+                         testSRAndNSR_Trap_C2(info.isTestC2Compiled(\"testSRAndNSR_Trap_C2\"), cond1, cond2, x, y));\n+\n+        var arr1 = testNestedObjectsArray_Interp(cond1, x, y);\n+        var arr2 = testNestedObjectsArray_C2(cond1, x, y);\n+\n+        if (arr1.length != arr2.length) Asserts.fail(\"testNestedObjectsArray result size mismatch.\");\n+        for (int i=0; i<arr1.length; i++) {\n+            if (!arr1[i].equals(arr2[i])) {\n+                Asserts.fail(\"testNestedObjectsArray objects mismatch.\");\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testGlobalEscape(int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        AllocationMergesTests.global_escape = p;\n+\n+        return p.x * p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    int testGlobalEscape_C2(int x, int y) { return testGlobalEscape(x, y); }\n+\n+    @DontCompile\n+    int testGlobalEscape_Interp(int x, int y) { return testGlobalEscape(x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testArgEscape(int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        int val = dummy(p);\n+\n+        return val + p.x + p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    int testArgEscape_C2(int x, int y) { return testArgEscape(x, y); }\n+\n+    @DontCompile\n+    int testArgEscape_Interp(int x, int y) { return testArgEscape(x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testEscapeInCallAfterMerge(boolean cond, boolean cond2, int x, int y) {\n+        Point p = new Point(x, x);\n+\n+        if (cond) {\n+            p = new Point(y, y);\n+        }\n+\n+        if (cond2) {\n+            dummy(p);\n+        }\n+\n+        return p.x * p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testEscapeInCallAfterMerge_C2(boolean cond, boolean cond2, int x, int y) { return testEscapeInCallAfterMerge(cond, cond2, x, y); }\n+\n+    @DontCompile\n+    int testEscapeInCallAfterMerge_Interp(boolean cond, boolean cond2, int x, int y) { return testEscapeInCallAfterMerge(cond, cond2, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testNoEscapeWithWriteInLoop(boolean cond, boolean cond2, int x, int y) {\n+        Point p = new Point(x, y);\n+        int res = 0;\n+\n+        if (cond) {\n+            p = new Point(y, x);\n+        }\n+\n+        for (int i=0; i<100; i++) {\n+            p.x += p.y + i;\n+            p.y += p.x + i;\n+        }\n+\n+        return res + p.x + p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Merge won't be reduced because of the write to the fields\n+    int testNoEscapeWithWriteInLoop_C2(boolean cond, boolean cond2, int x, int y) { return testNoEscapeWithWriteInLoop(cond, cond2, x, y); }\n+\n+    @DontCompile\n+    int testNoEscapeWithWriteInLoop_Interp(boolean cond, boolean cond2, int x, int y) { return testNoEscapeWithWriteInLoop(cond, cond2, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testPollutedWithWrite(boolean cond, int l) {\n+        Shape obj1 = new Square(l);\n+        Shape obj2 = new Square(l);\n+        Shape obj = null;\n+\n+        if (cond) {\n+            obj = obj1;\n+        } else {\n+            obj = obj2;\n+        }\n+\n+        for (int i=1; i<132; i++) {\n+            obj.x++;\n+        }\n+\n+        return obj1.x + obj2.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Merge won't be reduced because of the write to the field\n+    int testPollutedWithWrite_C2(boolean cond, int l) { return testPollutedWithWrite(cond, l); }\n+\n+    @DontCompile\n+    int testPollutedWithWrite_Interp(boolean cond, int l) { return testPollutedWithWrite(cond, l); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+    @ForceInline\n+    int testPollutedPolymorphic(boolean cond, int l) {\n+        Shape obj1 = new Square(l);\n+        Shape obj2 = new Circle(l);\n+        Shape obj = (cond ? obj1 : obj2);\n+        int res = 0;\n+\n+        for (int i=1; i<232; i++) {\n+            res += obj.x;\n+        }\n+\n+        return res + obj1.x + obj2.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Merge won't be reduced because the inputs to the Phi have different Klasses\n+    int testPollutedPolymorphic_C2(boolean cond, int l) { return testPollutedPolymorphic(cond, l); }\n+\n+    @DontCompile\n+    int testPollutedPolymorphic_Interp(boolean cond, int l) { return testPollutedPolymorphic(cond, l); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testMergedLoadAfterDirectStore(boolean cond, int x, int y) {\n+        Point p0 = new Point(x, x);\n+        Point p1 = new Point(y, y);\n+        Point p = null;\n+\n+        if (cond) {\n+            p = p0;\n+        } else {\n+            p = p1;\n+        }\n+\n+        p0.x = x * y;\n+\n+        return p.x;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Merge won't be reduced because write to one of the inputs *after* the merge\n+    int testMergedLoadAfterDirectStore_C2(boolean cond, int x, int y) { return testMergedLoadAfterDirectStore(cond, x, y); }\n+\n+    @DontCompile\n+    int testMergedLoadAfterDirectStore_Interp(boolean cond, int x, int y) { return testMergedLoadAfterDirectStore(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testMergedAccessAfterCallWithWrite(boolean cond, int x, int y) {\n+        Point p2 = new Point(x, x);\n+        Point p = new Point(y, y);\n+\n+        p.x = p.x * y;\n+\n+        if (cond) {\n+            p = new Point(x, x);\n+        }\n+\n+        dummy(p2);\n+\n+        for (int i=3; i<324; i++) {\n+            p.x += i * x;\n+        }\n+\n+        return p.x;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"3\" })\n+    \/\/ Objects won't be scalar replaced because:\n+    \/\/  - p is written inside the loop.\n+    \/\/  - p2 is ArgEscape\n+    int testMergedAccessAfterCallWithWrite_C2(boolean cond, int x, int y) { return testMergedAccessAfterCallWithWrite(cond, x, y); }\n+\n+    @DontCompile\n+    int testMergedAccessAfterCallWithWrite_Interp(boolean cond, int x, int y) { return testMergedAccessAfterCallWithWrite(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testLoadAfterTrap(boolean cond, int x, int y) {\n+        Point p = null;\n+\n+        if (cond) {\n+            p = new Point(x, x);\n+        } else {\n+            p = new Point(y, y);\n+        }\n+\n+        dummy(x+y);\n+\n+        return p.x + p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The allocations won't be removed because 'split_through_phi' won't split the load through the bases.\n+    int testLoadAfterTrap_C2(boolean cond, int x, int y) { return testLoadAfterTrap(cond, x, y); }\n+\n+    @DontCompile\n+    int testLoadAfterTrap_Interp(boolean cond, int x, int y) { return testLoadAfterTrap(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testCondAfterMergeWithNull(boolean cond1, boolean cond2, int x, int y) {\n+        Point p = null;\n+\n+        if (cond1) {\n+            p = new Point(y, x);\n+        }\n+\n+        if (cond2 && cond1) {\n+            return p.x;\n+        } else {\n+            return 321;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ The merge won't be simplified because the merge with NULL\n+    int testCondAfterMergeWithNull_C2(boolean cond1, boolean cond2, int x, int y) { return testCondAfterMergeWithNull(cond1, cond2, x, y); }\n+\n+    @DontCompile\n+    int testCondAfterMergeWithNull_Interp(boolean cond1, boolean cond2, int x, int y) { return testCondAfterMergeWithNull(cond1, cond2, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testLoadAfterLoopAlias(boolean cond, int x, int y) {\n+        Point a = new Point(x, y);\n+        Point b = new Point(y, x);\n+        Point c = a;\n+\n+        for (int i=10; i<232; i++) {\n+            if (i == x) {\n+                c = b;\n+            }\n+        }\n+\n+        return cond ? c.x : c.y;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both allocations should be removed\n+    int testLoadAfterLoopAlias_C2(boolean cond, int x, int y) { return testLoadAfterLoopAlias(cond, x, y); }\n+\n+    @DontCompile\n+    int testLoadAfterLoopAlias_Interp(boolean cond, int x, int y) { return testLoadAfterLoopAlias(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testCallTwoSide(boolean cond1, int x, int y) {\n+        Point p = dummy(x, y);\n+\n+        if (cond1) {\n+            p = dummy(y, x);\n+        }\n+\n+        return (p != null) ? p.x : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.CALL, \"<=3\" })\n+    \/\/ Merge won't be reduced because both of the inputs are NSR.\n+    \/\/ There could be 3 call nodes because one if can became an unstable trap.\n+    int testCallTwoSide_C2(boolean cond1, int x, int y) { return testCallTwoSide(cond1, x, y); }\n+\n+    @DontCompile\n+    int testCallTwoSide_Interp(boolean cond1, int x, int y) { return testCallTwoSide(cond1, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testMergedAccessAfterCallNoWrite(boolean cond, int x, int y) {\n+        Point p2 = new Point(x, x);\n+        Point p = new Point(y, y);\n+        int res = 0;\n+\n+        p.x = p.x * y;\n+\n+        if (cond) {\n+            p = new Point(y, y);\n+        }\n+\n+        dummy(p2);\n+\n+        for (int i=3; i<324; i++) {\n+            res += p.x + i * x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"3\" })\n+    \/\/ p2 escapes and therefore won't be removed.\n+    \/\/ The allocations won't be removed because 'split_through_phi' won't split the load through the bases.\n+    int testMergedAccessAfterCallNoWrite_C2(boolean cond, int x, int y) { return testMergedAccessAfterCallNoWrite(cond, x, y); }\n+\n+    @DontCompile\n+    int testMergedAccessAfterCallNoWrite_Interp(boolean cond, int x, int y) { return testMergedAccessAfterCallNoWrite(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testCmpMergeWithNull_Second(boolean cond, int x, int y) {\n+        Point p = null;\n+\n+        if (cond) {\n+            p = new Point(x*x, y*y);\n+        }\n+\n+        dummy(x);\n+\n+        if (p != null) {\n+            return p.x * p.y;\n+        } else {\n+            return 1984;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ Merge won't be reduced because, among other things, one of the inputs is null.\n+    int testCmpMergeWithNull_Second_C2(boolean cond, int x, int y) { return testCmpMergeWithNull_Second(cond, x, y); }\n+\n+    @DontCompile\n+    int testCmpMergeWithNull_Second_Interp(boolean cond, int x, int y) { return testCmpMergeWithNull_Second(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testObjectIdentity(boolean cond, int x, int y) {\n+        Point o = new Point(x, y);\n+\n+        if (cond && x == 42) {\n+            o = global_escape;\n+        }\n+\n+        return o.x + o.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ The allocation won't be removed because the merge doesn't have exact type\n+    int testObjectIdentity_C2(boolean cond, int x, int y) { return testObjectIdentity(cond, x, y); }\n+\n+    @DontCompile\n+    int testObjectIdentity_Interp(boolean cond, int x, int y) { return testObjectIdentity(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testSubclassesTrapping(boolean c1, boolean c2, int x, int y, int w, int z) {\n+        new A();\n+        Root s = new Home(x, y);\n+        new B();\n+\n+        if (c1) {\n+            new C();\n+            s = new Etc(\"Hello\");\n+            new D();\n+        } else {\n+            new E();\n+            s = new Usr(y, x, z);\n+            new F();\n+        }\n+\n+        dummy();\n+\n+        return s.a;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The initial allocation assigned to 's' will always be dead.\n+    \/\/ The other two allocations assigned to 's' won't be removed because they have different type.\n+    int testSubclassesTrapping_C2(boolean c1, boolean c2, int x, int y, int w, int z) { return testSubclassesTrapping(c1, c2, x, y, w, z); }\n+\n+    @DontCompile\n+    int testSubclassesTrapping_Interp(boolean c1, boolean c2, int x, int y, int w, int z) { return testSubclassesTrapping(c1, c2, x, y, w, z); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testCmpMergeWithNull(boolean cond, int x, int y) {\n+        Point p = null;\n+\n+        if (cond) {\n+            p = new Point(x*x, y*y);\n+        } else if (x > y) {\n+            p = new Point(x+y, x*y);\n+        }\n+\n+        if (p != null) {\n+            return p.x * p.y;\n+        } else {\n+            return 1984;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testCmpMergeWithNull_C2(boolean cond, int x, int y) { return testCmpMergeWithNull(cond, x, y); }\n+\n+    @DontCompile\n+    int testCmpMergeWithNull_Interp(boolean cond, int x, int y) { return testCmpMergeWithNull(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testSubclasses(boolean c1, boolean c2, int x, int y, int w, int z) {\n+        new A();\n+        Root s = new Home(x, y);\n+        new B();\n+\n+        if (c1) {\n+            new C();\n+            s = new Etc(\"Hello\");\n+            new D();\n+        } else {\n+            new E();\n+            s = new Usr(y, x, z);\n+            new F();\n+        }\n+\n+        new G();\n+\n+        return s.a;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The unused allocation will be removed.\n+    \/\/ The other two allocations assigned to 's' won't be removed because they have different type.\n+    int testSubclasses_C2(boolean c1, boolean c2, int x, int y, int w, int z) { return testSubclasses(c1, c2, x, y, w, z); }\n+\n+    @DontCompile\n+    int testSubclasses_Interp(boolean c1, boolean c2, int x, int y, int w, int z) { return testSubclasses(c1, c2, x, y, w, z); }\n+\n+\n+    \/\/ ------------------ Some Scalar Replacement Should Happen in The Tests Below ------------------- \/\/\n+\n+    @ForceInline\n+    int testPartialPhis(boolean cond, int l, int x, int y) {\n+        int k = l;\n+\n+        if (l == 0) {\n+            k = l + 1;\n+        } else if (l == 2) {\n+            k = l + 2;\n+        } else if (l == 3) {\n+            new Point(x, y);\n+        } else if (l == 4) {\n+            new Point(y, x);\n+        }\n+\n+        return k;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ all allocations will be dead\n+    int testPartialPhis_C2(boolean cond, int l, int x, int y) { return testPartialPhis(cond, l, x, y); }\n+\n+    @DontCompile\n+    int testPartialPhis_Interp(boolean cond, int l, int x, int y) { return testPartialPhis(cond, l, x, y); }\n+\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testPollutedNoWrite(boolean cond, int l) {\n+        Shape obj1 = new Square(l);\n+        Shape obj2 = new Square(l);\n+        Shape obj = null;\n+        int res = 0;\n+\n+        if (cond) {\n+            obj = obj1;\n+        } else {\n+            obj = obj2;\n+        }\n+\n+        for (int i=1; i<132; i++) {\n+            res += obj.x;\n+        }\n+\n+        return res + obj1.x + obj2.y;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both allocations will be removed. After initialization they are read-only objects.\n+    \/\/ Access to the input of the merge, after the merge, is fine.\n+    int testPollutedNoWrite_C2(boolean cond, int l) { return testPollutedNoWrite(cond, l); }\n+\n+    @DontCompile\n+    int testPollutedNoWrite_Interp(boolean cond, int l) { return testPollutedNoWrite(cond, l); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testThreeWayAliasedAlloc(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x+1, y+1);\n+        Point p3 = new Point(x+2, y+2);\n+\n+        if (cond) {\n+            p3 = p1;\n+        } else {\n+            p3 = p2;\n+        }\n+\n+        return p3.x + p3.y;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Initial p3 will always be dead.\n+    \/\/ The other two allocations will be reduced and scaled\n+    int testThreeWayAliasedAlloc_C2(boolean cond, int x, int y) { return testThreeWayAliasedAlloc(cond, x, y); }\n+\n+    @DontCompile\n+    int testThreeWayAliasedAlloc_Interp(boolean cond, int x, int y) { return testThreeWayAliasedAlloc(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int TestTrapAfterMerge(boolean cond, int x, int y) {\n+        Point p = new Point(x, x);\n+\n+        if (cond) {\n+            p = new Point(y, y);\n+        }\n+\n+        for (int i=402; i<432; i+=x) {\n+            x++;\n+        }\n+\n+        return p.x + x;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both allocations will be eliminated.\n+    int TestTrapAfterMerge_C2(boolean cond, int x, int y) { return TestTrapAfterMerge(cond, x, y); }\n+\n+    @DontCompile\n+    int TestTrapAfterMerge_Interp(boolean cond, int x, int y) { return TestTrapAfterMerge(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    Point testNestedObjectsObject(boolean cond, int x, int y) {\n+        Picture p = new Picture(x, x, y);\n+\n+        if (cond) {\n+            p = new Picture(y, y, x);\n+        }\n+\n+        return p.position;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The allocation of \"Picture\" will be removed and only allocations of \"Position\" will be kept\n+    Point testNestedObjectsObject_C2(boolean cond, int x, int y) { return testNestedObjectsObject(cond, x, y); }\n+\n+    @DontCompile\n+    Point testNestedObjectsObject_Interp(boolean cond, int x, int y) { return testNestedObjectsObject(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testNestedObjectsNoEscapeObject(boolean cond, int x, int y) {\n+        Picture p = new Picture(x, x, y);\n+\n+        if (cond) {\n+            p = new Picture(y, y, x);\n+        }\n+\n+        return p.position.x;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" } )\n+    \/\/ The two Picture objects will be removed. The nested Point objects won't\n+    \/\/ be removed because the Phi merging them will have a DecodeN user - which\n+    \/\/ currently isn't supported.\n+    int testNestedObjectsNoEscapeObject_C2(boolean cond, int x, int y) { return testNestedObjectsNoEscapeObject(cond, x, y); }\n+\n+    @DontCompile\n+    int testNestedObjectsNoEscapeObject_Interp(boolean cond, int x, int y) { return testNestedObjectsNoEscapeObject(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    Point[] testNestedObjectsArray(boolean cond, int x, int y) {\n+        PicturePositions p = new PicturePositions(x, y, x+y);\n+\n+        if (cond) {\n+            p = new PicturePositions(x+1, y+1, x+y+1);\n+        }\n+\n+        return p.positions;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"4\" })\n+    \/\/ The two PicturePositions objects will be reduced and scaled.\n+    Point[] testNestedObjectsArray_C2(boolean cond, int x, int y) { return testNestedObjectsArray(cond, x, y); }\n+\n+    @DontCompile\n+    Point[] testNestedObjectsArray_Interp(boolean cond, int x, int y) { return testNestedObjectsArray(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testTrappingAfterMerge(boolean cond, int x, int y) {\n+        Point p = new Point(x, y);\n+        int res = 0;\n+\n+        if (cond) {\n+            p = new Point(y, y);\n+        }\n+\n+        for (int i=832; i<932; i++) {\n+            res += p.x;\n+        }\n+\n+        if (x > y) {\n+            res += new Point(p.x, p.y).x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ The allocation inside the last if will be removed because it's not part of a merge\n+    \/\/ The other two allocations will be reduced and removed\n+    int testTrappingAfterMerge_C2(boolean cond, int x, int y) { return testTrappingAfterMerge(cond, x, y); }\n+\n+    @DontCompile\n+    int testTrappingAfterMerge_Interp(boolean cond, int x, int y) { return testTrappingAfterMerge(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testSimpleAliasedAlloc(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(y, x);\n+        Point p = p1;\n+\n+        if (cond) {\n+            p = p2;\n+        }\n+\n+        return p.x * p.y;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both merges will be reduced and removed\n+    int testSimpleAliasedAlloc_C2(boolean cond, int x, int y) { return testSimpleAliasedAlloc(cond, x, y); }\n+\n+    @DontCompile\n+    int testSimpleAliasedAlloc_Interp(boolean cond, int x, int y) { return testSimpleAliasedAlloc(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testSimpleDoubleMerge(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x+1, y+1);\n+\n+        if (cond) {\n+            p1 = new Point(y, x);\n+            p2 = new Point(y+1, x+1);\n+        }\n+\n+        return p1.x + p2.y;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both merges will be reduced and removed\n+    int testSimpleDoubleMerge_C2(boolean cond, int x, int y) { return testSimpleDoubleMerge(cond, x, y); }\n+\n+    @DontCompile\n+    int testSimpleDoubleMerge_Interp(boolean cond, int x, int y) { return testSimpleDoubleMerge(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testConsecutiveSimpleMerge(boolean cond1, boolean cond2, int x, int y) {\n+        Point p0 = new Point(x, x);\n+        Point p1 = new Point(x, y);\n+        Point pA = null;\n+\n+        Point p2 = new Point(y, x);\n+        Point p3 = new Point(y, y);\n+        Point pB = null;\n+\n+        if (cond1) {\n+            pA = p0;\n+        } else {\n+            pA = p1;\n+        }\n+\n+        if (cond2) {\n+            pB = p2;\n+        } else {\n+            pB = p3;\n+        }\n+\n+        return pA.x * pA.y + pB.x * pB.y;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ All allocations will be removed.\n+    int testConsecutiveSimpleMerge_C2(boolean cond1, boolean cond2, int x, int y) { return testConsecutiveSimpleMerge(cond1, cond2, x, y); }\n+\n+    @DontCompile\n+    int testConsecutiveSimpleMerge_Interp(boolean cond1, boolean cond2, int x, int y) { return testConsecutiveSimpleMerge(cond1, cond2, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testDoubleIfElseMerge(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x+1, y+1);\n+\n+        if (cond) {\n+            p1 = new Point(y, x);\n+            p2 = new Point(y, x);\n+        } else {\n+            p1 = new Point(x, y);\n+            p2 = new Point(x+1, y+1);\n+        }\n+\n+        return p1.x * p2.y;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ The initial allocation is always dead. The other\n+    \/\/ two will be reduced and scaled.\n+    int testDoubleIfElseMerge_C2(boolean cond, int x, int y) { return testDoubleIfElseMerge(cond, x, y); }\n+\n+    @DontCompile\n+    int testDoubleIfElseMerge_Interp(boolean cond, int x, int y) { return testDoubleIfElseMerge(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testNoEscapeWithLoadInLoop(boolean cond, int x, int y) {\n+        Point p = new Point(x, y);\n+        int res = 0;\n+\n+        if (cond) {\n+            p = new Point(y, x);\n+        }\n+\n+        for (int i=3342; i<4234; i++) {\n+            res += p.x + p.y + i;\n+        }\n+\n+        return res + p.x + p.y;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both allocations will be reduced and scaled.\n+    int testNoEscapeWithLoadInLoop_C2(boolean cond, int x, int y) { return testNoEscapeWithLoadInLoop(cond, x, y); }\n+\n+    @DontCompile\n+    int testNoEscapeWithLoadInLoop_Interp(boolean cond, int x, int y) { return testNoEscapeWithLoadInLoop(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testCmpAfterMerge(boolean cond, boolean cond2, int x, int y) {\n+        Point a = new Point(x, y);\n+        Point b = new Point(y, x);\n+        Point c = null;\n+\n+        if (x+2 >= y-5) {\n+            c = a;\n+        } else {\n+            c = b;\n+        }\n+\n+        return cond2 ? c.x : c.y;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both allocations will be reduced and scaled\n+    int testCmpAfterMerge_C2(boolean cond, boolean cond2, int x, int y) { return testCmpAfterMerge(cond, cond2, x, y); }\n+\n+    @DontCompile\n+    int testCmpAfterMerge_Interp(boolean cond, boolean cond2, int x, int y) { return testCmpAfterMerge(cond, cond2, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testCondAfterMergeWithAllocate(boolean cond1, boolean cond2, int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        if (cond1) {\n+            p = new Point(y, x);\n+        }\n+\n+        if (cond2 && cond1) {\n+            return p.x;\n+        } else {\n+            return 321;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both allocations will be eliminated.\n+    int testCondAfterMergeWithAllocate_C2(boolean cond1, boolean cond2, int x, int y) { return testCondAfterMergeWithAllocate(cond1, cond2, x, y); }\n+\n+    @DontCompile\n+    int testCondAfterMergeWithAllocate_Interp(boolean cond1, boolean cond2, int x, int y) { return testCondAfterMergeWithAllocate(cond1, cond2, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testCondLoadAfterMerge(boolean cond1, boolean cond2, int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        if (cond1) {\n+            p = new Point(y, x);\n+        }\n+\n+        if (cond1 == false && cond2 == false) {\n+            return p.x + 1;\n+        } else if (cond1 == false && cond2 == true) {\n+            return p.x + 30;\n+        } else if (cond1 == true && cond2 == false) {\n+            return p.x + 40;\n+        } else if (cond1 == true && cond2 == true) {\n+            return p.x + 50;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both allocations will be eliminated.\n+    int testCondLoadAfterMerge_C2(boolean cond1, boolean cond2, int x, int y) { return testCondLoadAfterMerge(cond1, cond2, x, y); }\n+\n+    @DontCompile\n+    int testCondLoadAfterMerge_Interp(boolean cond1, boolean cond2, int x, int y) { return testCondLoadAfterMerge(cond1, cond2, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testIfElseInLoop() {\n+        int res = 0;\n+\n+        for (int i=1; i<1000; i++) {\n+            Point obj = new Point(i, i);\n+\n+            if (i % 2 == 1) {\n+                obj = new Point(i, i+1);\n+            } else {\n+                obj = new Point(i-1, i);\n+            }\n+\n+            res += obj.x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ The initial allocation is always dead. The other\n+    \/\/ two will be reduced and scaled.\n+    int testIfElseInLoop_C2() { return testIfElseInLoop(); }\n+\n+    @DontCompile\n+    int testIfElseInLoop_Interp() { return testIfElseInLoop(); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testLoadInCondAfterMerge(boolean cond, int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        if (cond) {\n+            p = new Point(y, x);\n+        }\n+\n+        if (p.x == 10) {\n+            if (p.y == 10) {\n+                return dummy(10);\n+            } else {\n+                return dummy(20);\n+            }\n+        } else if (p.x == 20) {\n+            if (p.y == 20) {\n+                return dummy(30);\n+            } else {\n+                return dummy(40);\n+            }\n+        }\n+\n+        return 1984;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both allocations will be reduced and removed.\n+    int testLoadInCondAfterMerge_C2(boolean cond, int x, int y) { return testLoadInCondAfterMerge(cond, x, y); }\n+\n+    @DontCompile\n+    int testLoadInCondAfterMerge_Interp(boolean cond, int x, int y) { return testLoadInCondAfterMerge(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testLoadInLoop(boolean cond, int x, int y) {\n+        Point obj1 = new Point(x, y);\n+        Point obj2 = new Point(y, x);\n+        Point obj = null;\n+        int res = 0;\n+\n+        if (cond) {\n+            obj = obj1;\n+        } else {\n+            obj = obj2;\n+        }\n+\n+        for (int i = 0; i < 532; i++) {\n+            res += obj.x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Both allocations will be reduced and removed.\n+    int testLoadInLoop_C2(boolean cond, int x, int y) { return testLoadInLoop(cond, x, y); }\n+\n+    @DontCompile\n+    int testLoadInLoop_Interp(boolean cond, int x, int y) { return testLoadInLoop(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testMergesAndMixedEscape(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x, y);\n+        int val  = 0;\n+\n+        if (cond) {\n+            p1 = new Point(x+1, y+1);\n+            val = dummy(p2);\n+        }\n+\n+        return val + p1.x + p2.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ p2 escapes and will remain. The other two allocations will be reduced and scaled.\n+    int testMergesAndMixedEscape_C2(boolean cond, int x, int y) { return testMergesAndMixedEscape(cond, x, y); }\n+\n+    @DontCompile\n+    int testMergesAndMixedEscape_Interp(boolean cond, int x, int y) { return testMergesAndMixedEscape(cond, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testSRAndNSR_NoTrap(boolean cond1, int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        if (cond1) {\n+            p = new Point(x+1, y+1);\n+            global_escape = p;\n+        }\n+\n+        return p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"<=1\" })\n+    int testSRAndNSR_NoTrap_C2(boolean cond1, int x, int y) { return testSRAndNSR_NoTrap(cond1, x, y); }\n+\n+    @DontCompile\n+    int testSRAndNSR_NoTrap_Interp(boolean cond1, int x, int y) { return testSRAndNSR_NoTrap(cond1, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testSRAndNSR_Trap(boolean is_c2, boolean cond1, boolean cond2, int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        if (cond1) {\n+            p = new Point(x+1, y+1);\n+            global_escape = p;\n+        }\n+\n+        if (is_c2) {\n+            \/\/ This will show up to C2 as a trap.\n+            dummy_defaults();\n+        }\n+\n+        return p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"<=1\" })\n+    int testSRAndNSR_Trap_C2(boolean is_c2, boolean cond1, boolean cond2, int x, int y) { return testSRAndNSR_Trap(is_c2, cond1, cond2, x, y); }\n+\n+    @DontCompile\n+    int testSRAndNSR_Trap_Interp(boolean is_c2, boolean cond1, boolean cond2, int x, int y) { return testSRAndNSR_Trap(is_c2, cond1, cond2, x, y); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    char testString_one(boolean cond1) {\n+        String p = new String(\"Java\");\n+\n+        if (cond1) {\n+            p = new String(\"HotSpot\");\n+        }\n+\n+        return p.charAt(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"0\" })\n+    char testString_one_C2(boolean cond1) { return testString_one(cond1); }\n+\n+    @DontCompile\n+    char testString_one_Interp(boolean cond1) { return testString_one(cond1); }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    char testString_two(boolean cond1) {\n+        String p = new String(\"HotSpot\");\n+\n+        if (cond1) {\n+            p = dummy(\"String\");\n+            if (p == null) return 'J';\n+        }\n+\n+        return p.charAt(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"0\" })\n+    char testString_two_C2(boolean cond1) { return testString_two(cond1); }\n+\n+    @DontCompile\n+    char testString_two_Interp(boolean cond1) { return testString_two(cond1); }\n+\n+    \/\/ ------------------ Utility for Testing ------------------- \/\/\n+\n+    @DontCompile\n+    static void dummy() {\n+    }\n+\n+    @DontCompile\n+    static int dummy(Point p) {\n+        return p.x * p.y;\n+    }\n+\n+    @DontCompile\n+    static int dummy(int x) {\n+        return x;\n+    }\n+\n+    @DontCompile\n+    static Point dummy(int x, int y) {\n+        return new Point(x, y);\n+    }\n+\n+    @DontCompile\n+    static String dummy(String str) {\n+        return str;\n+    }\n+\n+    @DontCompile\n+    static ADefaults dummy_defaults() {\n+        return new ADefaults();\n+    }\n+\n+    static class Point {\n+        int x, y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (!(o instanceof Point)) return false;\n+            Point p = (Point) o;\n+            return (p.x == x) && (p.y == y);\n+        }\n+    }\n+\n+    class Shape {\n+        int x, y, l;\n+        Shape(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    class Square extends Shape {\n+        Square(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+    class Circle extends Shape {\n+        Circle(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+    static class ADefaults {\n+        static int ble;\n+        int i;\n+        @DontCompile\n+        ADefaults(int i) { this.i = i; }\n+        @DontCompile\n+        ADefaults() { }\n+    }\n+\n+    static class Picture {\n+        public int id;\n+        public Point position;\n+\n+        public Picture(int id, int x, int y) {\n+            this.id = id;\n+            this.position = new Point(x, y);\n+        }\n+    }\n+\n+    static class PicturePositions {\n+        public int id;\n+        public Point[] positions;\n+\n+        public PicturePositions(int id, int x, int y) {\n+            this.id = id;\n+            this.positions = new Point[] { new Point(x, y), new Point(y, x) };\n+        }\n+    }\n+\n+    class Root {\n+        public int a;\n+        public int b;\n+        public int c;\n+        public int d;\n+        public int e;\n+\n+        public Root(int a, int b, int c, int d, int e) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+            this.d = d;\n+            this.e = e;\n+        }\n+    }\n+\n+    class Usr extends Root {\n+        public float flt;\n+\n+        public Usr(float a, float b, float c) {\n+            super((int)a, (int)b, (int)c, 0, 0);\n+            this.flt = a;\n+        }\n+    }\n+\n+    class Home extends Root {\n+        public double[] arr;\n+\n+        public Home(double a, double b) {\n+            super((int)a, (int)b, 0, 0, 0);\n+            this.arr = new double[] {a, b};\n+        }\n+\n+    }\n+\n+    class Tmp extends Root {\n+        public String s;\n+\n+        public Tmp(String s) {\n+            super((int)s.length(), 0, 0, 0, 0);\n+            this.s = s;\n+        }\n+    }\n+\n+    class Etc extends Root {\n+        public String a;\n+\n+        public Etc(String s) {\n+            super((int)s.length(), 0, 0, 0, 0);\n+            this.a = s;\n+        }\n+    }\n+\n+    class A { }\n+    class B { }\n+    class C { }\n+    class D { }\n+    class E { }\n+    class F { }\n+    class G { }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":1413,"deletions":0,"binary":false,"changes":1413,"status":"added"},{"patch":"@@ -201,1 +201,1 @@\n-        String optoRegex = \"(.*precise .*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+        String optoRegex = \"(.*precise .*\\\\R((.*(?i:mov|mv|xorl|nop|spill).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n@@ -207,1 +207,1 @@\n-        String regex = \"(.*precise .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+        String regex = \"(.*precise .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|mv|xorl|nop|spill).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n@@ -213,1 +213,1 @@\n-        String optoRegex = \"(.*precise \\\\[.*\\\\R((.*(?i:mov|xor|nop|spill).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+        String optoRegex = \"(.*precise \\\\[.*\\\\R((.*(?i:mov|mv|xor|nop|spill).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n@@ -219,1 +219,1 @@\n-        String regex = \"(.*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|xorl|nop|spill).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+        String regex = \"(.*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|mv|xorl|nop|spill).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n@@ -280,1 +280,1 @@\n-        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*:|.*(?i:mov|or).*precise \\\\[.*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*:|.*(?i:mov|mv|or).*precise \\\\[.*:.*\\\\R.*(cmp|CMP|CLR))\" + END;\n@@ -286,1 +286,1 @@\n-        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*\" + IS_REPLACED + \":|.*(?i:mov|or).*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R.*(cmp|CMP|CLR))\" + END;\n+        String regex = \"(((?i:cmp|CLFI|CLR).*precise \\\\[.*\" + IS_REPLACED + \":|.*(?i:mov|mv|or).*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R.*(cmp|CMP|CLR))\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308103\n+ * @summary Massive (up to ~30x) increase in C2 compilation time since JDK 17\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestSinkingNodesCausesLongCompilation::mainTest -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:RepeatCompilation=30 TestSinkingNodesCausesLongCompilation\n+ *\/\n+\n+public class TestSinkingNodesCausesLongCompilation {\n+    public static final int N = 400;\n+    public static int iFld=41489;\n+\n+    public void mainTest(String[] strArr1) {\n+        int i9=-13, i10=-248, i11=-4, i13=33, i15=-171, i18=-58, iArr2[]=new int[N];\n+\n+        for (i9 = 7; i9 < 256; i9++) {\n+            i11 = 1;\n+            do {\n+            } while (++i11 < 101);\n+        }\n+        for (int i14 : iArr2) {\n+            for (i15 = 63; 0 < i15; i15 -= 2) {\n+                i10 *= i13;\n+                i10 >>= i14;\n+            }\n+            for (i18 = 2; 63 > i18; i18++) {\n+                i10 = iFld;\n+                iArr2[i18] |= i11;\n+            }\n+        }\n+        System.out.println(\"i9 = \" + i9);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestSinkingNodesCausesLongCompilation _instance = new TestSinkingNodesCausesLongCompilation();\n+        for (int i = 0; i < 10; i++) {\n+            _instance.mainTest(strArr);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSinkingNodesCausesLongCompilation.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test TestRangeCheckEliminationDisabled\n- * @bug 8154763\n- * @summary Tests PostLoopMultiversioning with RangeCheckElimination disabled.\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+UnlockExperimentalVMOptions -XX:+PostLoopMultiversioning -XX:-RangeCheckElimination\n- *                   compiler.rangechecks.TestRangeCheckEliminationDisabled\n- *\/\n-\n-package compiler.rangechecks;\n-\n-public class TestRangeCheckEliminationDisabled {\n-\n-    public static void main(String[] args) {\n-      System.out.println(\"Passed\");\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckEliminationDisabled.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -64,3 +64,0 @@\n-        \/\/ Add extra VM options to verify experimental auto-vectorization\n-        WB.setBooleanVMFlag(\"UnlockExperimentalVMOptions\", true);\n-        WB.setBooleanVMFlag(\"PostLoopMultiversioning\", true);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/TestAgeOutput.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/TestFullGCALot.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/TestNumWorkerOutput.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/TestStackOverflow.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,1 +98,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestAggressiveHeap.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapSizeFlags.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMinInitialErgonomics.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelHeapSizeFlags.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSerialHeapSizeFlags.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUnrecognizedVMOptionsHandling.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsErgo.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/class_unloading\/TestG1ClassUnloadingHWM.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegionsClearMarkBits.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -131,1 +131,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegionsLog.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegionsWithRefs.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEdenSurvivorLessThanMax.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEvacuationFailure.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestFromCardCacheIndex.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1SkipCompaction.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -371,1 +371,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousAllocConcurrentStart.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousAllocNearlyFullRegion.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousCodeCacheRoots.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -144,1 +144,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousConcurrentStartUndo.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousRemsetsMatch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestOneEdenRegionAfterGC.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestPLABOutput.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestPLABSizeBounds.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestParallelAlwaysPreTouch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestPeriodicLogMessages.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestPrintRegionRememberedSetInfo.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestRemsetLogging.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/mixedgc\/TestLogging.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -146,1 +146,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/mixedgc\/TestOldGenCollectionUsage.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/parallel\/TestPrintGCDetailsVerbose.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestWrongArrayMember.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestJNIBlockFullGC\/libTestJNIBlockFullGC.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -331,1 +331,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestMultiThreadStressRSet.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestReclaimStringsLeaksMemory.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,1 +71,8 @@\n-    String crashAddress = Platform.isAix() ? \"0xffffffffffffffff\" : \"0x0*400\";\n+    String crashAddress = \"0x0*400\";\n+    if (Platform.isAix()) {\n+        crashAddress = \"0xffffffffffffffff\";\n+    } else if (Platform.isS390x()) {\n+        \/\/ All faults on s390x give the address only on page granularity.\n+        \/\/ Hence fault address is first page address.\n+        crashAddress = \"0x0*1000\";\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestSigInfoInHsErrFile.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires !vm.jvmci.enabled\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/serviceability\/ReplaceCriticalClassesForSubgraphs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires os.family != \"windows\" & os.arch != \"arm\"\n+ * @requires os.arch != \"arm\"\n@@ -31,1 +31,0 @@\n- * @comment The native code only supports POSIX so no windows testing\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/nativeStack\/TestNativeStack.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,5 @@\n+#ifdef _WIN32\n+#include <windows.h>\n+#include <process.h>\n+typedef  unsigned int THREAD_ID;\n+#else\n@@ -28,0 +33,3 @@\n+typedef  pthread_t THREAD_ID;\n+#endif\n+\n@@ -66,1 +74,6 @@\n-static void * thread_start(void* unused) {\n+#ifdef _WIN32\n+unsigned __stdcall\n+#else\n+void *\n+#endif\n+thread_start(void* unused) {\n@@ -97,0 +110,1 @@\n+#ifndef _WIN32\n@@ -98,0 +112,3 @@\n+#else\n+  return 0;\n+#endif\n@@ -103,1 +120,1 @@\n-  pthread_t thread;\n+  THREAD_ID thread;\n@@ -112,0 +129,15 @@\n+#ifdef _WIN32\n+  HANDLE hThread = (HANDLE) _beginthreadex(NULL, 0, thread_start,\n+                                           NULL, 0, &thread);\n+  if (hThread == 0) {\n+    fprintf(stderr, \"TEST ERROR: _beginthreadex failed: %s\\n\", strerror(errno));\n+    exit(1);\n+  }\n+  if (WaitForSingleObject(hThread, INFINITE) != WAIT_OBJECT_0) {\n+    fprintf(stderr, \"TEST ERROR: WaitForSingleObject failed: %d\\n\", GetLastError());\n+    exit(1);\n+  }\n+  CloseHandle(hThread);\n+\n+#else\n+\n@@ -128,0 +160,1 @@\n+#endif\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/nativeStack\/libnativeStack.c","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-    private static OutputAnalyzer out;\n-    private static ProcessBuilder pb;\n@@ -61,2 +59,1 @@\n-    static void checkFor(String... outputStrings) throws Exception {\n-        out = new OutputAnalyzer(pb.start());\n+    static void checkFor(OutputAnalyzer output, String... outputStrings) throws Exception {\n@@ -64,1 +61,1 @@\n-            out.shouldContain(s);\n+            output.shouldContain(s);\n@@ -66,1 +63,0 @@\n-        out.shouldHaveExitValue(0);\n@@ -69,2 +65,1 @@\n-    static void checkAbsent(String... outputStrings) throws Exception {\n-        out = new OutputAnalyzer(pb.start());\n+    static void checkAbsent(OutputAnalyzer output, String... outputStrings) throws Exception {\n@@ -72,1 +67,1 @@\n-            out.shouldNotContain(s);\n+            output.shouldNotContain(s);\n@@ -74,1 +69,0 @@\n-        out.shouldHaveExitValue(0);\n@@ -78,1 +72,1 @@\n-    static ProcessBuilder exec(String... args) throws Exception {\n+    static OutputAnalyzer exec(String... args) throws Exception {\n@@ -81,7 +75,6 @@\n-        Collections.addAll(argsList, \"-Xmn8m\");\n-        Collections.addAll(argsList, \"-Xbootclasspath\/a:.\");\n-        Collections.addAll(argsList, \"-XX:+UnlockDiagnosticVMOptions\");\n-        Collections.addAll(argsList, \"-XX:+WhiteBoxAPI\");\n-        Collections.addAll(argsList, \"-XX:+ClassUnloading\");\n-        Collections.addAll(argsList, ClassUnloadTestMain.class.getName());\n-        return ProcessTools.createJavaProcessBuilder(argsList);\n+        Collections.addAll(argsList, \"-Xmn8m\", \"-Xbootclasspath\/a:.\", \"-XX:+UnlockDiagnosticVMOptions\",\n+                           \"-XX:+WhiteBoxAPI\", \"-XX:+ClassUnloading\", ClassUnloadTestMain.class.getName());\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(argsList);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n@@ -92,0 +85,2 @@\n+        OutputAnalyzer output;\n+\n@@ -93,2 +88,2 @@\n-        pb = exec(\"-Xlog:class+unload=info\");\n-        checkFor(\"[class,unload]\", \"unloading class\");\n+        output = exec(\"-Xlog:class+unload=info\");\n+        checkFor(output, \"[class,unload]\", \"unloading class\");\n@@ -97,2 +92,2 @@\n-        pb = exec(\"-Xlog:class+unload=off\");\n-        checkAbsent(\"[class,unload]\");\n+        output = exec(\"-Xlog:class+unload=off\");\n+        checkAbsent(output,\"[class,unload]\");\n@@ -101,2 +96,2 @@\n-        pb = exec(\"-Xlog:class+load=info\");\n-        checkFor(\"[class,load]\", \"java.lang.Object\", \"source:\");\n+        output = exec(\"-Xlog:class+load=info\");\n+        checkFor(output,\"[class,load]\", \"java.lang.Object\", \"source:\");\n@@ -105,2 +100,2 @@\n-        pb = exec(\"-Xlog:class+load=debug\");\n-        checkFor(\"[class,load]\", \"java.lang.Object\", \"source:\", \"klass:\", \"super:\", \"loader:\", \"bytes:\");\n+        output = exec(\"-Xlog:class+load=debug\");\n+        checkFor(output,\"[class,load]\", \"java.lang.Object\", \"source:\", \"klass:\", \"super:\", \"loader:\", \"bytes:\");\n@@ -109,2 +104,2 @@\n-        pb = exec(\"-Xlog:class+load=off\");\n-        checkAbsent(\"[class,load]\");\n+        output = exec(\"-Xlog:class+load=off\");\n+        checkAbsent(output,\"[class,load]\");\n@@ -113,3 +108,3 @@\n-        pb = exec(\"-verbose:class\");\n-        checkFor(\"[class,load]\", \"java.lang.Object\", \"source:\");\n-        checkFor(\"[class,unload]\", \"unloading class\");\n+        output = exec(\"-verbose:class\");\n+        checkFor(output,\"[class,load]\", \"java.lang.Object\", \"source:\");\n+        checkFor(output,\"[class,unload]\", \"unloading class\");\n@@ -118,2 +113,2 @@\n-        pb = exec(\"-Xlog:class+loader+data=trace\");\n-        checkFor(\"[class,loader,data]\", \"create loader data\");\n+        output = exec(\"-Xlog:class+loader+data=trace\");\n+        checkFor(output, \"[class,loader,data]\", \"create loader data\");\n@@ -122,16 +117,15 @@\n-        pb = exec(\"-Xlog:class+load+cause\");\n-        checkAbsent(\"[class,load,cause]\");\n-        checkFor(\"class load cause logging will not produce output without LogClassLoadingCauseFor\");\n-\n-        \/\/  -Xlog:class+load+cause -XX:LogClassLoadingCauseFor=java.lang.StringCoding\n-        pb = exec(\"-Xlog:class+load+cause\", \"-XX:LogClassLoadingCauseFor=java.lang.StringCoding\");\n-        checkFor(\"[class,load,cause]\", \"Java stack when loading java.lang.StringCoding:\");\n-\n-        \/\/  -Xlog:class+load+cause -XX:LogClassLoadingCauseFor=java.lang.StringCoding\n-        pb = exec(\"-Xlog:class+load+cause+native\", \"-XX:LogClassLoadingCauseFor=java.lang.StringCoding\");\n-        checkFor(\"[class,load,cause,native]\", \"Native stack when loading java.lang.StringCoding:\");\n-\n-        \/\/  -Xlog:class+load+cause* -XX:LogClassLoadingCauseFor=java.lang.StringCoding\n-        pb = exec(\"-Xlog:class+load+cause*\", \"-XX:LogClassLoadingCauseFor=java.lang.StringCoding\");\n-        checkFor(\"[class,load,cause] Java stack when loading java.lang.StringCoding:\");\n-        checkFor(\"[class,load,cause,native] Native stack when loading java.lang.StringCoding:\");\n+        output = exec(\"-Xlog:class+load+cause\");\n+        checkAbsent(output,\"[class,load,cause]\");\n+        checkFor(output,\"class load cause logging will not produce output without LogClassLoadingCauseFor\");\n+\n+        String x = ClassUnloadTestMain.class.getName();\n+\n+        output = exec(\"-Xlog:class+load+cause\", \"-XX:LogClassLoadingCauseFor=\" + x);\n+        checkFor(output,\"[class,load,cause]\", \"Java stack when loading \" + x + \":\");\n+\n+        output = exec(\"-Xlog:class+load+cause+native\", \"-XX:LogClassLoadingCauseFor=\" + x);\n+        checkFor(output,\"[class,load,cause,native]\", \"Native stack when loading \" + x + \":\");\n+\n+        output = exec(\"-Xlog:class+load+cause*\", \"-XX:LogClassLoadingCauseFor=\" + x);\n+        checkFor(output,\"[class,load,cause] Java stack when loading \" + x + \":\");\n+        checkFor(output,\"[class,load,cause,native] Native stack when loading \" + x + \":\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ClassLoadUnloadTest.java","additions":43,"deletions":49,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.*;\n+import java.util.Set;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+class HugePageConfiguration {\n+\n+    Set<Long> _staticHugePageSizes;\n+    long _staticDefaultHugePageSize;\n+\n+    enum THPMode {always, never, madvise, unknown}\n+    THPMode _thpMode;\n+    long _thpPageSize;\n+\n+    public Set<Long> getStaticHugePageSizes() {\n+        return _staticHugePageSizes;\n+    }\n+\n+    public long getStaticDefaultHugePageSize() {\n+        return _staticDefaultHugePageSize;\n+    }\n+\n+    public THPMode getThpMode() {\n+        return _thpMode;\n+    }\n+\n+    public long getThpPageSize() {\n+        return _thpPageSize;\n+    }\n+\n+    public HugePageConfiguration(Set<Long> _staticHugePageSizes, long _staticDefaultHugePageSize, THPMode _thpMode, long _thpPageSize) {\n+        this._staticHugePageSizes = _staticHugePageSizes;\n+        this._staticDefaultHugePageSize = _staticDefaultHugePageSize;\n+        this._thpMode = _thpMode;\n+        this._thpPageSize = _thpPageSize;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Configuration{\" +\n+                \"_staticHugePageSizes=\" + _staticHugePageSizes +\n+                \", _staticDefaultHugePageSize=\" + _staticDefaultHugePageSize +\n+                \", _thpMode=\" + _thpMode +\n+                \", _thpPageSize=\" + _thpPageSize +\n+                '}';\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        HugePageConfiguration that = (HugePageConfiguration) o;\n+        return _staticDefaultHugePageSize == that._staticDefaultHugePageSize && _thpPageSize == that._thpPageSize && Objects.equals(_staticHugePageSizes, that._staticHugePageSizes) && _thpMode == that._thpMode;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(_staticHugePageSizes, _staticDefaultHugePageSize, _thpMode, _thpPageSize);\n+    }\n+\n+    private static long readDefaultHugePageSizeFromOS() {\n+        Pattern pat = Pattern.compile(\"Hugepagesize: *(\\\\d+) +kB\");\n+        long result = 0;\n+        try (Scanner scanner = new Scanner(new File(\"\/proc\/meminfo\"))) {\n+            while (scanner.hasNextLine()) {\n+                Matcher mat = pat.matcher(scanner.nextLine());\n+                if (mat.matches()) {\n+                    scanner.close();\n+                    return Long.parseLong(mat.group(1)) * 1024;\n+                }\n+            }\n+        } catch (FileNotFoundException e) {\n+            System.out.println(\"Could not open \/proc\/meminfo\");\n+        }\n+        return 0;\n+    }\n+\n+    private static Set<Long> readSupportedHugePagesFromOS() {\n+        TreeSet<Long> pagesizes = new TreeSet<>();\n+        Pattern pat = Pattern.compile(\"hugepages-(\\\\d+)kB\");\n+        File[] subdirs = new File(\"\/sys\/kernel\/mm\/hugepages\").listFiles();\n+        if (subdirs != null) {\n+            for (File f : subdirs) {\n+                String name = f.getName();\n+                Matcher mat = pat.matcher(name);\n+                if (mat.matches()) {\n+                    long pagesize = Long.parseLong(mat.group(1)) * 1024;\n+                    pagesizes.add(pagesize);\n+                }\n+            }\n+        }\n+        return pagesizes;\n+    }\n+\n+    private static THPMode readTHPModeFromOS() {\n+        THPMode mode = THPMode.unknown;\n+        String file = \"\/sys\/kernel\/mm\/transparent_hugepage\/enabled\";\n+        try (FileReader fr = new FileReader(file);\n+             BufferedReader reader = new BufferedReader(fr)) {\n+            String s = reader.readLine();\n+            if (s.contains(\"[never]\")) {\n+                mode = THPMode.never;\n+            } else if (s.contains(\"[always]\")) {\n+                mode = THPMode.always;\n+            } else if (s.contains(\"[madvise]\")) {\n+                mode = THPMode.madvise;\n+            } else {\n+                throw new RuntimeException(\"Unexpected content of \" + file + \": \" + s);\n+            }\n+        } catch (IOException e) {\n+            System.out.println(\"Failed to read \" + file);\n+            mode = THPMode.unknown;\n+        }\n+        return mode;\n+    }\n+\n+    private static long readTHPPageSizeFromOS() {\n+        long pagesize = 0;\n+        String file = \"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pmd_size\";\n+        try (FileReader fr = new FileReader(file);\n+             BufferedReader reader = new BufferedReader(fr)) {\n+            String s = reader.readLine();\n+            pagesize = Long.parseLong(s);\n+        } catch (IOException | NumberFormatException e) { \/* ignored *\/ }\n+        return pagesize;\n+    }\n+\n+    \/\/ Fill object with info read from proc file system\n+    public static HugePageConfiguration readFromOS() {\n+        return new HugePageConfiguration(readSupportedHugePagesFromOS(),\n+                readDefaultHugePageSizeFromOS(),\n+                readTHPModeFromOS(),\n+                readTHPPageSizeFromOS());\n+    }\n+\n+    private static long parseSIUnit(String num, String unit) {\n+        long n = Long.parseLong(num);\n+        return switch (unit) {\n+            case \"K\" -> n * 1024;\n+            case \"M\" -> n * 1024 * 1024;\n+            case \"G\" -> n * 1024 * 1024 * 1024;\n+            default -> throw new RuntimeException(\"Invalid unit \" + unit);\n+        };\n+    }\n+\n+    public static HugePageConfiguration readFromJVMLog(OutputAnalyzer output) {\n+        \/\/ Expects output from -Xlog:pagesize\n+        \/\/ Example:\n+        \/\/ [0.001s][info][pagesize] Static hugepage support:\n+        \/\/ [0.001s][info][pagesize]   hugepage size: 2M\n+        \/\/ [0.001s][info][pagesize]   hugepage size: 1G\n+        \/\/ [0.001s][info][pagesize]   default hugepage size: 2M\n+        \/\/ [0.001s][info][pagesize] Transparent hugepage (THP) support:\n+        \/\/ [0.001s][info][pagesize]   THP mode: madvise\n+        \/\/ [0.001s][info][pagesize]   THP pagesize: 2M\n+        TreeSet<Long> hugepages = new TreeSet<>();\n+        long defaultHugepageSize = 0;\n+        THPMode thpMode = THPMode.never;\n+        long thpPageSize = 0;\n+        Pattern patternHugepageSize = Pattern.compile(\".*\\\\[pagesize] *hugepage size: (\\\\d+)([KMG])\");\n+        Pattern patternDefaultHugepageSize = Pattern.compile(\".*\\\\[pagesize] *default hugepage size: (\\\\d+)([KMG]) *\");\n+        Pattern patternTHPPageSize = Pattern.compile(\".*\\\\[pagesize] *THP pagesize: (\\\\d+)([KMG])\");\n+        Pattern patternTHPMode = Pattern.compile(\".*\\\\[pagesize] *THP mode: (\\\\S+)\");\n+        List<String> lines = output.asLines();\n+        for (String s : lines) {\n+            Matcher mat = patternHugepageSize.matcher(s);\n+            if (mat.matches()) {\n+                hugepages.add(parseSIUnit(mat.group(1), mat.group(2)));\n+                continue;\n+            }\n+            if (defaultHugepageSize == 0) {\n+                mat = patternDefaultHugepageSize.matcher(s);\n+                if (mat.matches()) {\n+                    defaultHugepageSize = parseSIUnit(mat.group(1), mat.group(2));\n+                    continue;\n+                }\n+            }\n+            if (thpPageSize == 0) {\n+                mat = patternTHPPageSize.matcher(s);\n+                if (mat.matches()) {\n+                    thpPageSize = parseSIUnit(mat.group(1), mat.group(2));\n+                    continue;\n+                }\n+            }\n+            mat = patternTHPMode.matcher(s);\n+            if (mat.matches()) {\n+                thpMode = THPMode.valueOf(mat.group(1));\n+            }\n+        }\n+\n+        return new HugePageConfiguration(hugepages, defaultHugepageSize, thpMode, thpPageSize);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/HugePageConfiguration.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test that the JVM detects the OS hugepage\/THP settings correctly.\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver HugePageDetection\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class HugePageDetection {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        ArrayList<String> finalargs = new ArrayList<String>();\n+        String[] defaultArgs = {\n+            \"-Xlog:pagesize\", \"-Xmx64M\", \"-XX:-CreateCoredumpOnCrash\"\n+        };\n+        finalargs.addAll(Arrays.asList(defaultArgs));\n+        finalargs.add(\"-version\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                new String[] {\"-Xlog:pagesize\", \"-Xmx64M\", \"-version\"});\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0);\n+\n+        \/\/ The configuration detected by the JVM should match the OS settings\n+\n+        HugePageConfiguration configurationFromOS = HugePageConfiguration.readFromOS();\n+        System.out.println(\"Configuration read from OS: \" + configurationFromOS);\n+\n+        HugePageConfiguration configurationFromLog = HugePageConfiguration.readFromJVMLog(output);\n+        System.out.println(\"Configuration read from JVM log: \" + configurationFromLog);\n+\n+        if (configurationFromOS.equals(configurationFromLog)) {\n+            System.out.println(\"Okay\");\n+        } else {\n+            throw new RuntimeException(\"Configurations differ\");\n+        }\n+\n+        \/\/ If we want to run\n+\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/HugePageDetection.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @requires vm.gc != \"Z\"\n+ * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ This test generates a npairs that overflows int so lookupswitch is an invalid bytecode\n+\n+public class LookupSwitchp1 version 50:0 {\n+\n+public static Method runLookup:\"()V\"\n+\tstack 4 locals 3\n+{\n+    iconst_0;\n+    bytecode 171; \/\/ lookupswitch\n+    bytecode 0,0; \/\/ padding\n+    bytecode 0,0,0,16; \/\/ default target == L17\n+    bytecode 0x80,0,0,0; \/\/ 0x80000000 npairs\n+    bytecode 0,0,0,0;    \/\/ one match-offset pair\n+    bytecode 0,0,0,16;   \/\/ also goes to target\n+    \/\/ incomplete npair table\n+  L17:\n+    iconst_0;\n+    ireturn;\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/LookupSwitchp1.jasm","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ This test generates (high - lo) that overflows int so tableswitch is an invalid bytecode\n+\/\/ If treated as unsigned lo > high but the tableswitch operands are signed int.\n+\n+public class TableSwitchp1 version 50:0 {\n+\n+public static Method runTable:\"()V\"\n+\tstack 4 locals 3\n+{\n+    iconst_0;\n+    bytecode 170; \/\/ tableswitch\n+    bytecode 0,0; \/\/ padding\n+    bytecode 0,0,0,15; \/\/ default target == L16\n+    bytecode 0x80,0,0,0; \/\/ 0x80000000 low\n+    bytecode 0x7F,0xFF,0xFF,0xFF; \/\/ 0x7fffffff high\n+    \/\/ illegal empty table\n+  L16:\n+    iconst_0;\n+    ireturn;\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TableSwitchp1.jasm","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/*\n+ * @test TestTableSwitch\n+ * @bug 8311583\n+ * @library \/test\/lib\n+ * @compile TableSwitchp1.jasm LookupSwitchp1.jasm\n+ * @run driver TestTableSwitch\n+ *\/\n+\n+public class TestTableSwitch {\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 1) {\n+            if (args[0].equals(\"runTable\")) {\n+                TableSwitchp1.runTable();\n+            } else {  \/\/ if (args[0].equals(\"runLookup\"))\n+                LookupSwitchp1.runLookup();\n+            }\n+        } else {\n+           ProcessBuilder pb = ProcessTools.createTestJvm(\"TestTableSwitch\", \"runTable\");\n+           OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+           output.shouldContain(\"java.lang.VerifyError: Bad instruction\");\n+           output.shouldHaveExitValue(1);\n+\n+           pb = ProcessTools.createTestJvm(\"TestTableSwitch\", \"runLookup\");\n+           output = new OutputAnalyzer(pb.start());\n+           output.shouldContain(\"java.lang.VerifyError: Bad instruction\");\n+           output.shouldHaveExitValue(1);\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TestTableSwitch.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -241,1 +241,0 @@\n-        \/* \"waiting\" test cases fail due JDK-8310584\n@@ -247,1 +246,0 @@\n-        *\/\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadStateMountedTest\/GetThreadStateMountedTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Verifies JVMTI GetLocalStorage\/SetLocalStorage\n+ * @requires vm.continuations\n+ * @requires vm.jvmti\n+ * @run main\/othervm\/native -agentlib:VThreadTLSTest VThreadTLSTest\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8311556\n+ * @summary Verifies JVMTI GetLocalStorage\/SetLocalStorage\n+ * @requires vm.continuations\n+ * @requires vm.jvmti\n+ * @run main\/othervm\/native -Djdk.attach.allowAttachSelf=true -XX:+EnableDynamicAgentLoading VThreadTLSTest attach\n+ *\/\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class VThreadTLSTest {\n+    static final String AGENT_LIB = \"VThreadTLSTest\";\n+    static volatile boolean attached;\n+    static volatile boolean failed;\n+\n+    static void log(String msg) { System.out.println(msg); }\n+    static native long getTLS();\n+    static native void setTLS(long value);\n+\n+    static void test() {\n+        try {\n+            while (!attached) {\n+                \/\/ keep mounted\n+            }\n+            long threadId = Thread.currentThread().threadId();\n+            setTLS(threadId);\n+            long mountedValue = getTLS();\n+\n+            if (mountedValue != threadId) {\n+                log(\"Error: wrong TLS value while mounted: \" + threadId + \", \" + mountedValue);\n+                failed = true;\n+                return;\n+            }\n+            for (int count = 0; count < 10; count++) {\n+                Thread.sleep(1);\n+                long tlsValue = getTLS();\n+                if (tlsValue != threadId) {\n+                    log(\"Error: wrong TLS value after yield: expected: \" + threadId + \" got: \" + tlsValue);\n+                    failed = true;\n+                    return;\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (ExecutorService execService = Executors.newVirtualThreadPerTaskExecutor()) {\n+            for (int threadCount = 0; threadCount < 20; threadCount++) {\n+                execService.execute(() -> test());\n+            }\n+            if (args.length == 1 && args[0].equals(\"attach\")) {\n+                log(\"loading \" + AGENT_LIB + \" lib\");\n+                VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));\n+                vm.loadAgentLibrary(AGENT_LIB);\n+            }\n+            Thread.sleep(10);\n+            attached = true;\n+        }\n+        if (failed) {\n+            throw new RuntimeException(\"Test FAILED: errors encountered\");\n+        } else {\n+            log(\"Test passed\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadTLSTest\/VThreadTLSTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <cstdlib>\n+#include <cstring>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti;\n+\n+JNIEXPORT jlong JNICALL\n+Java_VThreadTLSTest_getTLS(JNIEnv* jni, jclass clazz) {\n+  void* data;\n+  jvmtiError err = jvmti->GetThreadLocalStorage(nullptr, &data);\n+  check_jvmti_status(jni, err, \"getTLS: Failed in JVMTI GetThreadLocalStorage\");\n+  return (jlong)data;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_VThreadTLSTest_setTLS(JNIEnv* jni, jclass clazz, jlong value) {\n+  jvmtiError err = jvmti->SetThreadLocalStorage(nullptr, (void*)value);\n+  check_jvmti_status(jni, err, \"setTLS: Failed in JVMTI SetThreadLocalStorage\");\n+}\n+\n+jint agent_init(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    LOG(\"agent_init: could not initialize JVMTI\\n\");\n+    return JNI_ERR;\n+  }\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_support_virtual_threads = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"agent_init: error in JVMTI AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad\\n\");\n+  return agent_init(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnAttach\\n\");\n+  return agent_init(jvm, options, reserved);\n+}\n+\n+} \/\/ extern \"C\"\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadTLSTest\/libVThreadTLSTest.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -57,2 +57,0 @@\n-\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/GenClassesBuilder.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/README","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/bytecode\/GenClassesBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_keep_cl\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_keep_class\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_keep_obj\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/FinalizeTest02\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large002\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large003\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large004\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large005\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/MemoryEater\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/StringInternSync2\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/StringInternSyncWithGC2\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/StringInternSyncWithGC3\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/StringInternSyncWithGC4\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/WeakReferenceEvilTest\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/WeakReferenceTest\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/lock\/jni\/jnilock001\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/lock\/jniref\/jniglobalreflock01\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/lock\/jniref\/jnilocalreflock01\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/lock\/jniref\/jnireflock01\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/lock\/jniref\/jniweakglobalreflock01\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Churn\/Churn2\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/memory\/Churn\/Churn3a\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/CircularListHigh\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/CircularListLow\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/DoubleArrayHigh\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/DoubleArrayLow\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/FloatArrayHigh\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/FloatArrayLow\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/LinearListHigh\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/LinearListLow\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/NonbranchyTreeHigh\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/NonbranchyTreeLow\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/ObjectArrayHigh\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/ObjectArrayLow\/TestDescription.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    static final String DEBUGGEE_RESULT = DEBUGGEE_CLASS + \".notInterrupted.get()\";\n+    static final String DEBUGGEE_RESULT = DEBUGGEE_CLASS + \".notInterrupted\";\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/interrupt\/interrupt001\/interrupt001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,0 @@\n-                    notInterrupted.decrementAndGet();\n@@ -61,0 +60,1 @@\n+                        notInterrupted--;\n@@ -86,1 +86,1 @@\n-    public static final AtomicInteger notInterrupted = new AtomicInteger(numThreads);\n+    public static volatile int notInterrupted = numThreads;\n@@ -125,2 +125,2 @@\n-        while (notInterrupted.get() > 0 && System.currentTimeMillis() - startTime <= waitTime) {\n-            synchronized (waitnotify) {\n+        synchronized (waitnotify) {\n+            while (notInterrupted > 0 && System.currentTimeMillis() - startTime <= waitTime) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/interrupt\/interrupt001\/interrupt001a.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-                + \" -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,address=0\"\n+                + \" -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=0\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-            \" -Xdebug -Xnoagent -Xrunjdwp:transport=dt_shmem,server=y,address=\" +\n+            \" -Xdebug -Xrunjdwp:transport=dt_shmem,server=y,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-                + \" -Xdebug -Xnoagent -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0\"\n+                + \" -Xdebug -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attachnosuspend\/attachnosuspend001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-                \" -Xdebug -Xnoagent -Xrunjdwp:suspend=y,transport=\" +\n+                \" -Xdebug -Xrunjdwp:suspend=y,transport=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/LaunchingConnector\/launch\/launch003.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-                \" -Xdebug -Xnoagent -Xrunjdwp:suspend=y,transport=\" +\n+                \" -Xdebug -Xrunjdwp:suspend=y,transport=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/LaunchingConnector\/launch\/launch004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-            \" -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=n,address=\" +\n+            \" -Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/accept\/accept001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-            \" -Xdebug -Xnoagent -Xrunjdwp:transport=dt_shmem,server=n,address=\" +\n+            \" -Xdebug -Xrunjdwp:transport=dt_shmem,server=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/accept\/accept002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-            \" -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=n,suspend=n,address=\" +\n+            \" -Xdebug -Xrunjdwp:transport=dt_socket,server=n,suspend=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/listennosuspend\/listennosuspend001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-            \" -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=n,address=\" +\n+            \" -Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/startListening\/startlis001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-            \" -Xdebug -Xnoagent -Xrunjdwp:transport=dt_shmem,server=n,address=\" +\n+            \" -Xdebug -Xrunjdwp:transport=dt_shmem,server=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/startListening\/startlis002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,3 @@\n-java\/lang\/ScopedValue\/StressStackOverflow.java#default 8309646 linux-all\n+java\/lang\/ScopedValue\/StressStackOverflow.java#default 8309646 generic-all\n+java\/lang\/ScopedValue\/StressStackOverflow.java#no-TieredCompilation 8309646 generic-all\n+java\/lang\/ScopedValue\/StressStackOverflow.java#TieredStopAtLevel1 8309646 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-java\/util\/concurrent\/ScheduledThreadPoolExecutor\/BasicCancelTest.java 8308047 windows-x64\n","filename":"test\/jdk\/ProblemList-generational-zgc.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -579,2 +579,0 @@\n-sun\/security\/tools\/keytool\/ListKeychainStore.sh                 8156889 macosx-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+    vm.jvmci.enabled \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.CMMException;\n+import java.util.Objects;\n+\n+\/**\n+ * @test\n+ * @bug 6211126\n+ * @summary Checks basic functionality of java.awt.color.CMMException\n+ *\/\n+public final class CMMExceptionMessage {\n+\n+    public static void main(String[] args) {\n+        test(null);\n+        test(\"\");\n+        test(\"CMMExceptionMessage\");\n+    }\n+\n+    private static void test(String expected) {\n+        CMMException e = new CMMException(expected);\n+        if (!Objects.equals(e.getMessage(), expected)) {\n+            System.err.println(\"Expected message: \" + expected);\n+            System.err.println(\"Actual message: \" + e.getMessage());\n+            throw new RuntimeException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/CMMExceptionMessage.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.awt.color.ColorSpace;\n@@ -28,1 +29,1 @@\n- * @bug 6211198\n+ * @bug 6211198 6211202\n@@ -41,0 +42,12 @@\n+        try {\n+            ICC_Profile.getInstance(-5);\n+            throw new RuntimeException(\"IllegalArgumentException is expected\");\n+        } catch (IllegalArgumentException ignored) {\n+            \/\/ expected\n+        }\n+        try {\n+            ColorSpace.getInstance(-5);\n+            throw new RuntimeException(\"IllegalArgumentException is expected\");\n+        } catch (IllegalArgumentException ignored) {\n+            \/\/ expected\n+        }\n","filename":"test\/jdk\/java\/awt\/color\/GetInstanceBrokenData.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_ColorSpace;\n+\n+\/**\n+ * @test\n+ * @bug 6211126 6211139\n+ *\/\n+public final class ExpectedNPEOnNull {\n+\n+    public static void main(String[] args) {\n+        try {\n+            new ICC_ColorSpace(null);\n+            throw new RuntimeException(\"NPE is expected\");\n+        } catch (NullPointerException ignored) {\n+            \/\/ expected\n+        }\n+        test(ICC_ColorSpace.getInstance(ColorSpace.CS_sRGB));\n+        test(ICC_ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB));\n+        test(ICC_ColorSpace.getInstance(ColorSpace.CS_CIEXYZ));\n+        test(ICC_ColorSpace.getInstance(ColorSpace.CS_PYCC));\n+        test(ICC_ColorSpace.getInstance(ColorSpace.CS_GRAY));\n+    }\n+\n+    private static void test(ColorSpace cs) {\n+        try {\n+            cs.toRGB(null);\n+            throw new RuntimeException(\"NPE is expected\");\n+        } catch (NullPointerException ignored) {\n+            \/\/ expected\n+        }\n+        try {\n+            cs.fromRGB(null);\n+            throw new RuntimeException(\"NPE is expected\");\n+        } catch (NullPointerException ignored) {\n+            \/\/ expected\n+        }\n+        try {\n+            cs.toCIEXYZ(null);\n+            throw new RuntimeException(\"NPE is expected\");\n+        } catch (NullPointerException ignored) {\n+            \/\/ expected\n+        }\n+        try {\n+            cs.fromCIEXYZ(null);\n+            throw new RuntimeException(\"NPE is expected\");\n+        } catch (NullPointerException ignored) {\n+            \/\/ expected\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_ColorSpace\/ExpectedNPEOnNull.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ProfileDataException;\n+import java.util.Objects;\n+\n+\/**\n+ * @test\n+ * @bug 6211126\n+ * @summary Checks basic functionality of java.awt.color.ProfileDataException\n+ *\/\n+public final class ProfileDataExceptionMessage {\n+\n+    public static void main(String[] args) {\n+        test(null);\n+        test(\"\");\n+        test(\"ProfileDataExceptionMessage\");\n+    }\n+\n+    private static void test(String expected) {\n+        ProfileDataException e = new ProfileDataException(expected);\n+        if (!Objects.equals(e.getMessage(), expected)) {\n+            System.err.println(\"Expected message: \" + expected);\n+            System.err.println(\"Actual message: \" + e.getMessage());\n+            throw new RuntimeException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ProfileDataExceptionMessage.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -354,0 +354,6 @@\n+    @Test\n+    public void testCollectCoordinatesVoidFilterType() {\n+        VarHandle handle = MethodHandles.collectCoordinates(intHandle, 0, VOID_FILTER);\n+        assertEquals(handle.coordinateTypes(), List.of(String.class, MemorySegment.class));\n+    }\n+\n@@ -369,5 +375,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCollectCoordinatesWrongVoidFilterType() {\n-        MethodHandles.collectCoordinates(intHandle, 0, VOID_FILTER);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test Class.forPrimitiveName\n+ * @bug 6361826\n+ *\/\n+\n+import java.util.*;\n+\n+public class ForPrimitiveName {\n+    public static void main(String... args) {\n+        positiveTests();\n+        negativeTests();\n+    }\n+\n+    private static final void positiveTests() {\n+\n+        \/**\n+         * immutable table mapping primitive type names to corresponding\n+         * class objects\n+         *\/\n+        final Map<String, Class<?>> primClasses =\n+            Map.of(\"boolean\", boolean.class,\n+                   \"byte\",    byte.class,\n+                   \"char\",    char.class,\n+                   \"short\",   short.class,\n+                   \"int\",     int.class,\n+                   \"long\",    long.class,\n+                   \"float\",   float.class,\n+                   \"double\",  double.class,\n+                   \"void\",    void.class);\n+\n+        for (var entry : primClasses.entrySet()) {\n+            String key = entry.getKey();\n+            Class<?> expected = entry.getValue();\n+            Class<?> result = Class.forPrimitiveName(key);\n+\n+            \/\/ For java.lang.Class, equality is identity.\n+            if (result != expected) {\n+                throw new RuntimeException(\"Unexpected mapping for \" + key);\n+            }\n+        }\n+    }\n+\n+    private static final void negativeTests() {\n+        final List<String> expectedNull =\n+            List.of(\"java.lang.Object\",\n+                    \"java.lang.String\",\n+\n+                    \/\/ descriptor string names for primitive types\n+                    \"Z\", \/\/ boolean\n+                    \"B\", \/\/ byte\n+                    \"C\", \/\/ char\n+                    \"D\", \/\/ double\n+                    \"F\", \/\/ float\n+                    \"I\", \/\/ int\n+                    \"L\", \/\/ long\n+                    \"S\", \/\/ short\n+                    \"V\", \/\/ void\n+\n+                    \/\/ Wrapper classes\n+                    \"java.lang.Byte\",\n+                    \"java.lang.Boolean\",\n+                    \"java.lang.Character\",\n+                    \"java.lang.Short\",\n+                    \"java.lang.Integer\",\n+                    \"java.lang.Long\",\n+                    \"java.lang.Float\",\n+                    \"java.lang.Double\",\n+                    \"java.lang.Void\");\n+        for (var entry : expectedNull) {\n+            Class<?> result = Class.forPrimitiveName(entry);\n+            if (result != null ) {\n+                throw new RuntimeException(\"Unexpected nonnull result for \" +\n+                                           entry);\n+            }\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/java\/lang\/Class\/ForPrimitiveName.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -26,1 +26,7 @@\n- * @summary StressStackOverflow the recovery path for ScopedValue\n+ * @summary Stress ScopedValue stack overflow recovery path\n+ * @enablePreview\n+ * @run main\/othervm\/timeout=300 StressStackOverflow\n+ *\/\n+\n+\/*\n+ * @test id=no-TieredCompilation\n@@ -29,0 +35,5 @@\n+ *\/\n+\n+\/*\n+ * @test id=TieredStopAtLevel1\n+ * @enablePreview\n@@ -30,1 +41,0 @@\n- * @run main\/othervm\/timeout=300 StressStackOverflow\n@@ -40,0 +50,1 @@\n+import java.time.Duration;\n@@ -58,1 +69,1 @@\n-    static final long MINUTES = 60 * 1_000_000_000L; \/\/ 60 * 10**9 ns\n+    static final long DURATION_IN_NANOS = Duration.ofMinutes(2).toNanos();\n@@ -81,1 +92,1 @@\n-                if (System.nanoTime() - startTime > 3 * MINUTES) { \/\/ 3 minutes is long enough\n+                if (System.nanoTime() - startTime > DURATION_IN_NANOS) {\n@@ -235,1 +246,1 @@\n-                && System.nanoTime() - startTime <= 3 * MINUTES) { \/\/ 3 minutes is long enough\n+                && System.nanoTime() - startTime <= DURATION_IN_NANOS) {\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/StressStackOverflow.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -63,2 +63,1 @@\n-        layer.findModule(\"jdk.crypto.ec\")\n-            .ifPresent(m -> expected.add(\"sun.security.ec.SunEC\"));\n+        expected.add(\"sun.security.ec.SunEC\");\n","filename":"test\/jdk\/java\/lang\/SecurityManager\/CheckSecurityProvider.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -78,1 +79,1 @@\n-            System.out.println(events);\n+            System.err.println(events);\n@@ -82,2 +83,2 @@\n-            assertTrue(startCount == 100);\n-            assertTrue(endCount == 100);\n+            assertEquals(100, startCount);\n+            assertEquals(100, endCount);\n@@ -92,0 +93,5 @@\n+        Runnable[] parkers = new Runnable[] {\n+            () -> LockSupport.park(),\n+            () -> LockSupport.parkNanos(Duration.ofDays(1).toNanos())\n+        };\n+\n@@ -93,2 +99,1 @@\n-            recording.enable(\"jdk.VirtualThreadPinned\")\n-                     .withThreshold(Duration.ofMillis(500));\n+            recording.enable(\"jdk.VirtualThreadPinned\");\n@@ -96,1 +101,0 @@\n-            \/\/ execute task in a virtual thread, carrier thread is pinned 3 times.\n@@ -98,10 +102,15 @@\n-            ThreadFactory factory = Thread.ofVirtual().factory();\n-            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n-                executor.submit(() -> {\n-                    synchronized (lock) {\n-                        \/\/ pinned, duration < 500ms\n-                        Thread.sleep(1);\n-\n-                        \/\/ pinned, duration > 500ms\n-                        Thread.sleep(Duration.ofSeconds(3));\n-                        Thread.sleep(Duration.ofSeconds(3));\n+            try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+                for (Runnable parker : parkers) {\n+                    \/\/ execute parking task in virtual thread\n+                    var threadRef = new AtomicReference<Thread>();\n+                    executor.submit(() -> {\n+                        threadRef.set(Thread.currentThread());\n+                        synchronized (lock) {\n+                            parker.run();   \/\/ should pin carrier\n+                        }\n+                    });\n+\n+                    \/\/ wait for the task to start and the virtual thread to park\n+                    Thread thread;\n+                    while ((thread = threadRef.get()) == null) {\n+                        Thread.sleep(10);\n@@ -109,2 +118,10 @@\n-                    return null;\n-                });\n+                    try {\n+                        Thread.State state = thread.getState();\n+                        while (state != Thread.State.WAITING && state != Thread.State.TIMED_WAITING) {\n+                            Thread.sleep(10);\n+                            state = thread.getState();\n+                        }\n+                    } finally {\n+                        LockSupport.unpark(thread);\n+                    }\n+                }\n@@ -116,1 +133,1 @@\n-            System.out.println(events);\n+            System.err.println(events);\n@@ -118,1 +135,1 @@\n-            \/\/ should have two pinned events recorded\n+            \/\/ should have a pinned event for each park\n@@ -120,1 +137,1 @@\n-            assertTrue(pinnedCount == 2);\n+            assertEquals(parkers.length, pinnedCount);\n@@ -167,1 +184,1 @@\n-            System.out.println(events);\n+            System.err.println(events);\n@@ -170,1 +187,1 @@\n-            assertTrue(count == 2);\n+            assertEquals(2, count);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8291065\n+ * @summary Checks interaction of static field VarHandle with class\n+ *          initialization mechanism..\n+ * @run junit LazyInitializingTest\n+ * @run junit\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true LazyInitializingTest\n+ * @run junit\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false LazyInitializingTest\n+ * @run junit\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true\n+ *                    -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false LazyInitializingTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.Objects;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class LazyInitializingTest {\n+\n+    record SampleData(Runnable callback, int initialValue) {\n+        private static final Runnable FAIL_ON_CLINIT_CALLBACK = () -> {\n+            throw new AssertionError(\"Class shouldn't be initialized\");\n+        };\n+        static final SampleData FAIL_ON_CLINIT = new SampleData();\n+\n+        SampleData() {\n+            this(FAIL_ON_CLINIT_CALLBACK, 0);\n+        }\n+    }\n+    record ClassInfo(MethodHandles.Lookup definingLookup, VarHandle vh) {}\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    \/**\n+     * Meta test to ensure the testing mechanism to check initialization is correct.\n+     *\/\n+    @Test\n+    public void testMeta() throws IllegalAccessException {\n+        boolean[] val = new boolean[1];\n+        var v0 = createSampleClass(new SampleData(() -> val[0] = true, 0));\n+        assertFalse(val[0], \"callback run before class init\");\n+        v0.definingLookup.ensureInitialized(v0.definingLookup.lookupClass());\n+        assertTrue(val[0], \"callback not run at class init\");\n+    }\n+\n+    @Test\n+    public void testUninitializedOperations() {\n+        var ci = createSampleClass(SampleData.FAIL_ON_CLINIT);\n+        var vh = ci.vh;\n+        vh.describeConstable();\n+        vh.isAccessModeSupported(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE);\n+        vh.withInvokeExactBehavior();\n+        vh.withInvokeBehavior();\n+        vh.toMethodHandle(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE);\n+        vh.hasInvokeExactBehavior();\n+        vh.accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE);\n+    }\n+\n+    @Test\n+    public void testInitializationOnVarHandleUse() {\n+        var initialized = new boolean[1];\n+        var ci = createSampleClass(new SampleData(() -> initialized[0] = true, 42));\n+        var vh = ci.vh;\n+\n+        assertEquals(42, (int) vh.get(), \"VH does not read value set in class initializer\");\n+        assertTrue(initialized[0], \"class initialization not captured\");\n+    }\n+\n+    @Test\n+    public void testInitializationOnToMethodHandleUse() throws Throwable {\n+        var initialized = new boolean[1];\n+        var ci = createSampleClass(new SampleData(() -> initialized[0] = true, 42));\n+        var mh = ci.vh.toMethodHandle(VarHandle.AccessMode.GET);\n+\n+        assertEquals(42, (int) mh.invokeExact(), \"VH does not read value set in class initializer\");\n+        assertTrue(initialized[0], \"class initialization not captured\");\n+    }\n+\n+    @Test\n+    public void testParentChildLoading() throws Throwable {\n+        \/\/ ChildSample: ensure only ParentSample (field declarer) is initialized\n+        var l = new ParentChildLoader();\n+        var childSampleClass = l.childClass();\n+        var lookup = MethodHandles.privateLookupIn(childSampleClass, LOOKUP);\n+        var childVh = lookup.findStaticVarHandle(childSampleClass, \"f\", int.class);\n+\n+        assertEquals(3, (int) childVh.get(), \"Child class initialized unnecessarily\");\n+\n+        lookup.ensureInitialized(childSampleClass);\n+\n+        assertEquals(6, (int) childVh.get(), \"Child class was not initialized\");\n+    }\n+\n+    static ClassInfo createSampleClass(SampleData sampleData) {\n+        try {\n+            var lookup = LOOKUP.defineHiddenClassWithClassData(sampleClassBytes(), sampleData, false);\n+            var vh = lookup.findStaticVarHandle(lookup.lookupClass(), \"f\", int.class);\n+            return new ClassInfo(lookup, vh);\n+        } catch (IllegalAccessException | NoSuchFieldException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    private static byte[] sampleClassBytes;\n+\n+    private static byte[] sampleClassBytes() {\n+        var bytes = sampleClassBytes;\n+        if (bytes != null)\n+            return bytes;\n+\n+        try (var in = LazyInitializingTest.class.getResourceAsStream(\"LazyInitializingSample.class\")) {\n+            if (in == null)\n+                throw new AssertionError(\"class file not found\");\n+            return sampleClassBytes = in.readAllBytes();\n+        } catch (IOException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+}\n+\n+\/\/ This is used as a template class, whose bytes are used to define\n+\/\/ hidden classes instead\n+class LazyInitializingSample {\n+    static int f;\n+\n+    static {\n+        try {\n+            var data = MethodHandles.classData(MethodHandles.lookup(), ConstantDescs.DEFAULT_NAME,\n+                    LazyInitializingTest.SampleData.class);\n+            Objects.requireNonNull(data);\n+\n+            data.callback().run();\n+            f = data.initialValue();\n+        } catch (IllegalAccessException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+}\n+\n+class ParentChildLoader extends ClassLoader {\n+    ParentChildLoader() {\n+        super(LazyInitializingTest.class.getClassLoader().getParent());\n+    }\n+\n+    Class<?> parentClass() {\n+        try {\n+            return loadClass(\"ParentSample\");\n+        } catch (ClassNotFoundException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    Class<?> childClass() {\n+        try {\n+            return loadClass(\"ChildSample\");\n+        } catch (ClassNotFoundException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+        try (var stream = switch (name) {\n+            case \"ParentSample\", \"ChildSample\" -> LazyInitializingTest.class.getResourceAsStream(name + \".class\");\n+            default -> throw new ClassNotFoundException(name);\n+        }) {\n+            if (stream == null)\n+                throw new AssertionError();\n+            var b = stream.readAllBytes();\n+            return defineClass(name, b, 0, b.length);\n+        } catch (IOException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+}\n+\n+class ParentSample {\n+    static int f;\n+\n+    static {\n+        f = 3;\n+    }\n+}\n+\n+class ChildSample extends ParentSample {\n+    static {\n+        f = 6;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/LazyInitializingTest.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,3 @@\n-        assertTrue(re.isInstance(_e), String.format(\"%sIncorrect throwable thrown, %s. Expected %s\", message, _e, re));\n+        if (!re.isInstance(_e)) {\n+            fail(String.format(\"%sIncorrect throwable thrown, %s. Expected %s\", message, _e, re), _e);\n+        }\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleBaseTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test a timed DatagramSocket.receive with a SecurityManager set\n+ * @run main\/othervm -Djava.security.manager=allow TimeoutWithSM\n+ *\/\n+\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.SocketTimeoutException;\n+import java.security.Permission;\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class TimeoutWithSM {\n+\n+    private static final int TIMEOUT = 10_000;\n+\n+    public static void main(String[] args) throws Exception {\n+        try (var socket = new DatagramSocket(null)) {\n+            InetAddress lb = InetAddress.getLoopbackAddress();\n+            socket.bind(new InetSocketAddress(lb, 0));\n+\n+            \/\/ start sender to send datagrams to us\n+            var done = new AtomicBoolean();\n+            startSender(socket.getLocalSocketAddress(), done);\n+\n+            \/\/ set a SecurityManager that blocks datagrams from sender\n+            System.setSecurityManager(new SecurityManager() {\n+                @Override\n+                public void checkPermission(Permission p) {\n+                }\n+                @Override\n+                public void checkAccept(String host, int port) {\n+                    var isa = new InetSocketAddress(host, port);\n+                    System.out.println(\"checkAccept \" + isa);\n+                    throw new SecurityException();\n+                }\n+            });\n+\n+            \/\/ timed receive, should throw SocketTimeoutException\n+            try {\n+                socket.setSoTimeout(TIMEOUT);\n+                try {\n+                    byte[] bytes = new byte[1024];\n+                    DatagramPacket p = new DatagramPacket(bytes, bytes.length);\n+                    socket.receive(p);\n+                    throw new RuntimeException(\"Packet received, unexpected!!! \"\n+                            + \" sender=\" + p.getSocketAddress() + \", len=\" + p.getLength());\n+                } catch (SocketTimeoutException expected) {\n+                    System.out.println(expected + \", expected!!!\");\n+                }\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Start a thread to send datagrams to the given target address at intervals of\n+     * one second. The sender stops when done is set to true.\n+     *\/\n+    static void startSender(SocketAddress target, AtomicBoolean done) throws Exception {\n+        assert target instanceof InetSocketAddress isa && isa.getAddress().isLoopbackAddress();\n+        var sender = new DatagramSocket(null);\n+        boolean started = false;\n+        try {\n+            InetAddress lb = InetAddress.getLoopbackAddress();\n+            sender.bind(new InetSocketAddress(lb, 0));\n+            Thread.ofPlatform().start(() -> {\n+                try {\n+                    try (sender) {\n+                        byte[] bytes = \"hello\".getBytes(\"UTF-8\");\n+                        DatagramPacket p = new DatagramPacket(bytes, bytes.length);\n+                        p.setSocketAddress(target);\n+                        while (!done.get()) {\n+                            System.out.println(\"Send datagram to \" + target + \" ...\");\n+                            sender.send(p);\n+                            Thread.sleep(Duration.ofSeconds(1));\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            started = true;\n+        } finally {\n+            if (!started) {\n+                sender.close();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/TimeoutWithSM.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -74,1 +74,1 @@\n- * @bug 8196965\n+ * @bug 8196965 8302475\n@@ -129,12 +129,12 @@\n-            { \"030\", \"attachment; filename=foo\/file1.txt\",        \"file1.txt\" },\n-            { \"031\", \"attachment; filename=foo\/bar\/file2.txt\",    \"file2.txt\" },\n-            { \"032\", \"attachment; filename=baz\\\\file3.txt\",       \"file3.txt\" },\n-            { \"033\", \"attachment; filename=baz\\\\bar\\\\file4.txt\",  \"file4.txt\" },\n-            { \"034\", \"attachment; filename=x\/y\\\\file5.txt\",       \"file5.txt\" },\n-            { \"035\", \"attachment; filename=x\/y\\\\file6.txt\",       \"file6.txt\" },\n-            { \"036\", \"attachment; filename=x\/y\\\\z\/file7.txt\",     \"file7.txt\" },\n-            { \"037\", \"attachment; filename=x\/y\\\\z\/\\\\x\/file8.txt\", \"file8.txt\" },\n-            { \"038\", \"attachment; filename=\/root\/file9.txt\",      \"file9.txt\" },\n-            { \"039\", \"attachment; filename=..\/file10.txt\",        \"file10.txt\" },\n-            { \"040\", \"attachment; filename=..\\\\file11.txt\",       \"file11.txt\" },\n-            { \"041\", \"attachment; filename=foo\/..\/..\/file12.txt\", \"file12.txt\" },\n+            { \"030\", \"attachment; filename=\\\"foo\/file1.txt\\\"\",        \"file1.txt\" },\n+            { \"031\", \"attachment; filename=\\\"foo\/bar\/file2.txt\\\"\",    \"file2.txt\" },\n+            { \"032\", \"attachment; filename=\\\"baz\\\\\\\\file3.txt\\\"\",       \"file3.txt\" },\n+            { \"033\", \"attachment; filename=\\\"baz\\\\\\\\bar\\\\\\\\file4.txt\\\"\",  \"file4.txt\" },\n+            { \"034\", \"attachment; filename=\\\"x\/y\\\\\\\\file5.txt\\\"\",       \"file5.txt\" },\n+            { \"035\", \"attachment; filename=\\\"x\/y\\\\\\\\file6.txt\\\"\",       \"file6.txt\" },\n+            { \"036\", \"attachment; filename=\\\"x\/y\\\\\\\\z\/file7.txt\\\"\",     \"file7.txt\" },\n+            { \"037\", \"attachment; filename=\\\"x\/y\\\\\\\\z\/\\\\\\\\x\/file8.txt\\\"\", \"file8.txt\" },\n+            { \"038\", \"attachment; filename=\\\"\/root\/file9.txt\\\"\",      \"file9.txt\" },\n+            { \"039\", \"attachment; filename=\\\"..\/file10.txt\\\"\",        \"file10.txt\" },\n+            { \"040\", \"attachment; filename=\\\"..\\\\\\\\file11.txt\\\"\",       \"file11.txt\" },\n+            { \"041\", \"attachment; filename=\\\"foo\/..\/..\/file12.txt\\\"\", \"file12.txt\" },\n@@ -181,1 +181,1 @@\n-\n+            Path body = response.body();\n@@ -183,1 +183,1 @@\n-            out.println(\"Got body Path: \" + response.body());\n+            out.println(\"Got body Path: \" + body);\n@@ -188,1 +188,1 @@\n-            assertEquals(response.body().getFileName().toString(), expectedFilename);\n+            assertEquals(body.getFileName().toString(), expectedFilename);\n@@ -194,0 +194,5 @@\n+            if (!body.toAbsolutePath().startsWith(tempDir.toAbsolutePath())) {\n+                System.out.println(\"Tempdir = \" + tempDir.toAbsolutePath());\n+                System.out.println(\"body = \" + body.toAbsolutePath());\n+                throw new AssertionError(\"body in wrong location\");\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/AsFileDownloadTest.java","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Test standard charset name constants.\n+ * @summary Test standard charset name constants and class qualities.\n@@ -29,1 +29,1 @@\n- * @run main Standard\n+ * @run junit Standard\n@@ -34,2 +34,2 @@\n-import java.io.*;\n-import java.nio.charset.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n@@ -37,2 +37,10 @@\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -42,4 +50,5 @@\n-    private final static String standardCharsets[] = {\n-        \"US-ASCII\", \"ISO-8859-1\", \"UTF-8\",\n-        \"UTF-16BE\", \"UTF-16LE\", \"UTF-16\",\n-        \"UTF-32BE\", \"UTF-32LE\", \"UTF-32\",\n+    \/\/ These are the charsets StandardCharsets.java is expected to contain.\n+    private static final String[] expectedCharsets = {\n+            \"US-ASCII\", \"ISO-8859-1\", \"UTF-8\",\n+            \"UTF-16BE\", \"UTF-16LE\", \"UTF-16\",\n+            \"UTF-32BE\", \"UTF-32LE\", \"UTF-32\"\n@@ -48,10 +57,2 @@\n-    public static void realMain(String[] args) {\n-        check(StandardCharsets.US_ASCII instanceof Charset);\n-        check(StandardCharsets.ISO_8859_1 instanceof Charset);\n-        check(StandardCharsets.UTF_8 instanceof Charset);\n-        check(StandardCharsets.UTF_16BE instanceof Charset);\n-        check(StandardCharsets.UTF_16LE instanceof Charset);\n-        check(StandardCharsets.UTF_16 instanceof Charset);\n-        check(StandardCharsets.UTF_32BE instanceof Charset);\n-        check(StandardCharsets.UTF_32LE instanceof Charset);\n-        check(StandardCharsets.UTF_32 instanceof Charset);\n+    private static final Field[] standardCharsetFields =\n+            StandardCharsets.class.getFields();\n@@ -59,9 +60,20 @@\n-        check(\"US-ASCII\".equals(StandardCharsets.US_ASCII.name()));\n-        check(\"ISO-8859-1\".equals(StandardCharsets.ISO_8859_1.name()));\n-        check(\"UTF-8\".equals(StandardCharsets.UTF_8.name()));\n-        check(\"UTF-16BE\".equals(StandardCharsets.UTF_16BE.name()));\n-        check(\"UTF-16LE\".equals(StandardCharsets.UTF_16LE.name()));\n-        check(\"UTF-16\".equals(StandardCharsets.UTF_16.name()));\n-        check(\"UTF-32BE\".equals(StandardCharsets.UTF_32BE.name()));\n-        check(\"UTF-32LE\".equals(StandardCharsets.UTF_32LE.name()));\n-        check(\"UTF-32\".equals(StandardCharsets.UTF_32.name()));\n+    \/**\n+     * Validates that the Charset constants from the data provider\n+     * are of type Charset.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetProvider\")\n+    public void typeTest(Charset charset) {\n+        \/\/ Doubly checked, as it is validated when passed as a param\n+        assertTrue(charset instanceof Charset);\n+    }\n+\n+    \/**\n+     * Validates that calling .name() on a Charset constant is equal\n+     * to the matching String value from the data provider.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetProvider\")\n+    public void nameMethodTest(Charset charset, String charString) {\n+        assertEquals(charset.name(), charString);\n+    }\n@@ -69,9 +81,9 @@\n-        check(Charset.forName(\"US-ASCII\") == StandardCharsets.US_ASCII);\n-        check(Charset.forName(\"ISO-8859-1\") == StandardCharsets.ISO_8859_1);\n-        check(Charset.forName(\"UTF-8\") == StandardCharsets.UTF_8);\n-        check(Charset.forName(\"UTF-16BE\") == StandardCharsets.UTF_16BE);\n-        check(Charset.forName(\"UTF-16LE\") == StandardCharsets.UTF_16LE);\n-        check(Charset.forName(\"UTF-16\") == StandardCharsets.UTF_16);\n-        check(Charset.forName(\"UTF-32BE\") == StandardCharsets.UTF_32BE);\n-        check(Charset.forName(\"UTF-32LE\") == StandardCharsets.UTF_32LE);\n-        check(Charset.forName(\"UTF-32\") == StandardCharsets.UTF_32);\n+    \/**\n+     * Validates that calling Charset.forName() on a String is equal\n+     * to the matching Charset constant from the data provider.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetProvider\")\n+    public void forNameMethodTest(Charset charset, String charString) {\n+        assertEquals(Charset.forName(charString), charset);\n+    }\n@@ -79,2 +91,17 @@\n-        Set<String> charsets = new HashSet<>();\n-        Field standardCharsetFields[] = StandardCharsets.class.getFields();\n+    \/**\n+     * Validates the qualities of a StandardCharsets field are as expected:\n+     * The field is final, static, public, and one can access\n+     * the underlying value of the field.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetFields\")\n+    public void charsetModifiersTest(Field charsetField) throws IllegalAccessException {\n+        \/\/ Check modifiers\n+        assertEquals(StandardCharsets.class, charsetField.getDeclaringClass());\n+        assertTrue(Modifier.isFinal(charsetField.getModifiers()));\n+        assertTrue(Modifier.isStatic(charsetField.getModifiers()));\n+        assertTrue(Modifier.isPublic(charsetField.getModifiers()));\n+        \/\/ Check that the value can be accessed, and it is a Charset\n+        Object valueOfField = charsetField.get(null);\n+        assertTrue(valueOfField instanceof Charset);\n+    }\n@@ -82,6 +109,10 @@\n-        for(Field charsetField : standardCharsetFields) {\n-            check(StandardCharsets.class == charsetField.getDeclaringClass());\n-            check(Modifier.isFinal(charsetField.getModifiers()));\n-            check(Modifier.isStatic(charsetField.getModifiers()));\n-            check(Modifier.isPublic(charsetField.getModifiers()));\n-            Object value;\n+    \/**\n+     * Validates that the Charsets contained in StandardCharsets are equal\n+     * to the expected Charsets list defined in the test. This test should fail if\n+     * either the actual or expected (standard) Charsets are modified, and\n+     * the others are not.\n+     *\/\n+    @Test\n+    public void correctCharsetsTest() {\n+        \/\/ Grab the value from each Standard Charset field\n+        List<String> actualCharsets = charsetFields().map(field -> {\n@@ -89,4 +120,3 @@\n-                value = charsetField.get(null);\n-            } catch(IllegalAccessException failure) {\n-                unexpected(failure);\n-                continue;\n+                return ((Charset) field.get(null)).name();\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Can not test correctCharsetsTest() due to %s\", e);\n@@ -94,7 +124,2 @@\n-            check(value instanceof Charset);\n-            charsets.add(((Charset)value).name());\n-        }\n-\n-        check(charsets.containsAll(Arrays.asList(standardCharsets)));\n-        charsets.removeAll(Arrays.asList(standardCharsets));\n-        check(charsets.isEmpty());\n+        }).toList();\n+        assertEquals(actualCharsets, Arrays.asList(expectedCharsets));\n@@ -103,16 +128,16 @@\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() { passed++; }\n-    static void fail() { failed++; Thread.dumpStack(); }\n-    static void fail(String msg) { System.out.println(msg); fail(); }\n-    static void unexpected(Throwable t) { failed++; t.printStackTrace(); }\n-    static void check(boolean cond) { if (cond) pass(); else fail(); }\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else {System.out.println(x + \" not equal to \" + y); fail();}}\n-    static void equal2(Object x, Object y) {equal(x, y); equal(y, x);}\n-    public static void main(String[] args) throws Throwable {\n-        try { realMain(args); } catch (Throwable t) { unexpected(t); }\n-\n-        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n-        if (failed > 0) throw new Exception(\"Some tests failed\");\n+    \/**\n+     * Provides the constant Charset and associated String value of\n+     * the standard charsets.\n+     *\/\n+    private static Stream<Arguments> charsetProvider() {\n+        return Stream.of(\n+                Arguments.of(StandardCharsets.US_ASCII, \"US-ASCII\"),\n+                Arguments.of(StandardCharsets.ISO_8859_1, \"ISO-8859-1\"),\n+                Arguments.of(StandardCharsets.UTF_8, \"UTF-8\"),\n+                Arguments.of(StandardCharsets.UTF_16BE, \"UTF-16BE\"),\n+                Arguments.of(StandardCharsets.UTF_16LE, \"UTF-16LE\"),\n+                Arguments.of(StandardCharsets.UTF_16, \"UTF-16\"),\n+                Arguments.of(StandardCharsets.UTF_32BE, \"UTF-32BE\"),\n+                Arguments.of(StandardCharsets.UTF_32LE, \"UTF-32LE\"),\n+                Arguments.of(StandardCharsets.UTF_32, \"UTF-32\")\n+        );\n@@ -120,14 +145,0 @@\n-    static byte[] serializedForm(Object obj) {\n-        try {\n-            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            new ObjectOutputStream(baos).writeObject(obj);\n-            return baos.toByteArray();\n-        } catch (IOException e) { throw new Error(e); }}\n-    static Object readObject(byte[] bytes)\n-        throws IOException, ClassNotFoundException {\n-        InputStream is = new ByteArrayInputStream(bytes);\n-        return new ObjectInputStream(is).readObject();}\n-    @SuppressWarnings(\"unchecked\")\n-    static <T> T serialClone(T obj) {\n-        try { return (T) readObject(serializedForm(obj)); }\n-        catch (Exception e) { throw new Error(e); }}\n@@ -135,0 +146,3 @@\n+    private static Stream<Field> charsetFields() {\n+        return Arrays.stream(standardCharsetFields);\n+    }\n","filename":"test\/jdk\/java\/nio\/charset\/StandardCharsets\/Standard.java","additions":101,"deletions":87,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @bug 8155246 8292297 8292177\n+ * @bug 8155246 8292297 8292177 8281658\n@@ -74,0 +74,4 @@\n+            \/\/ sanity test -XshowSettings:security option\n+            exerciseShowSettingsSecurity(copiedJava.toString(), \"-cp\", System.getProperty(\"test.classes\"),\n+                    \"-Djava.security.debug=all\", \"-XshowSettings:security\", \"ConfigFileTest\", \"runner\");\n+\n@@ -139,0 +143,10 @@\n+    \/\/ exercise the -XshowSettings:security launcher\n+    private static void exerciseShowSettingsSecurity(String... args) throws Exception {\n+        ProcessBuilder process = new ProcessBuilder(args);\n+        OutputAnalyzer oa = ProcessTools.executeProcess(process);\n+        oa.shouldHaveExitValue(0)\n+                .shouldContain(\"Security properties:\")\n+                .shouldContain(\"Security provider static configuration:\")\n+                .shouldContain(\"Security TLS configuration\");\n+    }\n+\n","filename":"test\/jdk\/java\/security\/Security\/ConfigFileTest.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-        boolean readyStatus = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        boolean readyStatus = rootOcsp.awaitServerReady(60, TimeUnit.SECONDS);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/OCSPTimeout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main Bug6989440\n+ * @run junit Bug6989440\n@@ -40,0 +40,2 @@\n+import org.junit.jupiter.api.Test;\n+\n@@ -44,1 +46,5 @@\n-    public static void main(String[] args) throws Exception {\n+    \/* Multiple instances of Locale Service Provider Pool calling\n+     * getAvailableLocales() should not throw ConcurrentModificationException\n+     *\/\n+    @Test\n+    public void multiThreadAccessTest() throws Exception {\n@@ -61,4 +67,0 @@\n-        public TestThread(Class<? extends LocaleServiceProvider> providerClass) {\n-            cls = providerClass;\n-        }\n-\n@@ -68,4 +70,4 @@\n-                case 0 : cls = LocaleNameProvider.class; break;\n-                case 1 : cls = TimeZoneNameProvider.class; break;\n-                case 2 : cls = DateFormatProvider.class; break;\n-                default : throw new AssertionError(\"Should not reach here\");\n+                case 0 -> cls = LocaleNameProvider.class;\n+                case 1 -> cls = TimeZoneNameProvider.class;\n+                case 2 -> cls = DateFormatProvider.class;\n+                default -> throw new AssertionError(\"Should not reach here\");\n","filename":"test\/jdk\/java\/util\/Locale\/Bug6989440.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit Bug8035133\n@@ -34,0 +35,1 @@\n+import java.util.stream.Stream;\n@@ -35,0 +37,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -36,42 +41,1 @@\n-public class Bug8035133 {\n-\n-    private static boolean err = false;\n-\n-    public static void main(String[] args) {\n-\n-        \/\/ checking Locale.lookup with de-ch;q=0\n-        checkLookup(\"en;q=0.1, *-ch;q=0.5, de-ch;q=0\",\n-                \"de-ch, en, fr-ch\", \"fr-CH\");\n-\n-        \/* checking Locale.lookup with *;q=0 '*' should be ignored\n-         * in lookup\n-         *\/\n-        checkLookup(\"en;q=0.1, *-ch;q=0.5, *;q=0\",\n-                \"de-ch, en, fr-ch\", \"de-CH\");\n-\n-        \/\/ checking Locale.filter with fr-ch;q=0 in BASIC_FILTERING\n-        checkFilter(\"en;q=0.1, fr-ch;q=0.0, de-ch;q=0.5\",\n-                \"de-ch, en, fr-ch\", \"de-CH, en\");\n-\n-        \/\/ checking Locale.filter with *;q=0 in BASIC_FILTERING\n-        checkFilter(\"de-ch;q=0.6, *;q=0\", \"de-ch, fr-ch\", \"\");\n-\n-        \/\/ checking Locale.filter with *;q=0 in BASIC_FILTERING\n-        checkFilter(\"de-ch;q=0.6, de;q=0\", \"de-ch\", \"\");\n-\n-        \/\/ checking Locale.filter with *;q=0.6, en;q=0 in BASIC_FILTERING\n-        checkFilter(\"*;q=0.6, en;q=0\", \"de-ch, hi-in, en\", \"de-CH, hi-IN\");\n-\n-        \/\/ checking Locale.filter with de-ch;q=0 in EXTENDED_FILTERING\n-        checkFilter(\"en;q=0.1, *-ch;q=0.5, de-ch;q=0\",\n-                \"de-ch, en, fr-ch\", \"fr-CH, en\");\n-\n-        \/* checking Locale.filter with *-ch;q=0 in EXTENDED_FILTERING which\n-         * must make filter to return \"\" empty or no match\n-         *\/\n-        checkFilter(\"de-ch;q=0.5, *-ch;q=0\", \"de-ch, fr-ch\", \"\");\n-\n-        \/* checking Locale.filter with *;q=0 in EXTENDED_FILTERING which\n-         * must make filter to return \"\" empty or no match\n-         *\/\n-        checkFilter(\"*-ch;q=0.5, *;q=0\", \"de-ch, fr-ch\", \"\");\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -79,11 +43,1 @@\n-        \/* checking Locale.filter with *;q=0.6, *-Latn;q=0 in\n-         * EXTENDED_FILTERING\n-         *\/\n-        checkFilter(\"*;q=0.6, *-Latn;q=0\", \"de-ch, hi-in, en-Latn\",\n-                \"de-CH, hi-IN\");\n-\n-        if (err) {\n-            throw new RuntimeException(\"[LocaleMatcher method(s) failed]\");\n-        }\n-\n-    }\n+public class Bug8035133 {\n@@ -91,1 +45,4 @@\n-    private static void checkLookup(String ranges, String tags,\n+    \/\/ Ensure weights with 'q=0' work as expected during lookup\n+    @ParameterizedTest\n+    @MethodSource(\"lookupProvider\")\n+    public void lookupTest(String ranges, String tags,\n@@ -98,9 +55,3 @@\n-        String actualLocale\n-                = loc.toLanguageTag();\n-\n-        if (!actualLocale.equals(expectedLocale)) {\n-            System.err.println(\"Locale.lookup failed with ranges: \" + ranges\n-                    + \" Expected: \" + expectedLocale\n-                    + \" Actual: \" + actualLocale);\n-            err = true;\n-        }\n+        String actualLocale = loc.toLanguageTag();\n+        assertEquals(expectedLocale, actualLocale);\n+    }\n@@ -108,0 +59,9 @@\n+    private static Stream<Arguments> lookupProvider() {\n+        return Stream.of(\n+                \/\/ checking Locale.lookup with de-ch;q=0\n+                Arguments.of(\"en;q=0.1, *-ch;q=0.5, de-ch;q=0\",\n+                        \"de-ch, en, fr-ch\", \"fr-CH\"),\n+                \/\/ checking Locale.lookup with *;q=0 '*' should be ignored in lookup\n+                Arguments.of(\"en;q=0.1, *-ch;q=0.5, *;q=0\",\n+                        \"de-ch, en, fr-ch\", \"de-CH\")\n+        );\n@@ -110,1 +70,4 @@\n-    private static void checkFilter(String ranges, String tags,\n+    \/\/ Ensure weights with 'q=0' work as expected during filtering\n+    @ParameterizedTest\n+    @MethodSource(\"filterProvider\")\n+    public void filterTest(String ranges, String tags,\n@@ -118,0 +81,2 @@\n+        assertEquals(expectedLocales, actualLocales);\n+    }\n@@ -119,7 +84,28 @@\n-        if (!actualLocales.equals(expectedLocales)) {\n-            System.err.println(\"Locale.filter failed with ranges: \" + ranges\n-                    + \" Expected: \" + expectedLocales\n-                    + \" Actual: \" + actualLocales);\n-            err = true;\n-        }\n-\n+    private static Stream<Arguments> filterProvider() {\n+        return Stream.of(\n+                \/\/ checking Locale.filter with fr-ch;q=0 in BASIC_FILTERING\n+                Arguments.of(\"en;q=0.1, fr-ch;q=0.0, de-ch;q=0.5\",\n+                        \"de-ch, en, fr-ch\", \"de-CH, en\"),\n+                \/\/ checking Locale.filter with *;q=0 in BASIC_FILTERING\n+                Arguments.of(\"de-ch;q=0.6, *;q=0\", \"de-ch, fr-ch\", \"\"),\n+                \/\/ checking Locale.filter with *;q=0 in BASIC_FILTERING\n+                Arguments.of(\"de-ch;q=0.6, de;q=0\", \"de-ch\", \"\"),\n+                \/\/ checking Locale.filter with *;q=0.6, en;q=0 in BASIC_FILTERING\n+                Arguments.of(\"*;q=0.6, en;q=0\", \"de-ch, hi-in, en\", \"de-CH, hi-IN\"),\n+                \/\/ checking Locale.filter with de-ch;q=0 in EXTENDED_FILTERING\n+                Arguments.of(\"en;q=0.1, *-ch;q=0.5, de-ch;q=0\",\n+                        \"de-ch, en, fr-ch\", \"fr-CH, en\"),\n+                \/* checking Locale.filter with *-ch;q=0 in EXTENDED_FILTERING which\n+                 * must make filter to return \"\" empty or no match\n+                 *\/\n+                Arguments.of(\"de-ch;q=0.5, *-ch;q=0\", \"de-ch, fr-ch\", \"\"),\n+                \/* checking Locale.filter with *;q=0 in EXTENDED_FILTERING which\n+                 * must make filter to return \"\" empty or no match\n+                 *\/\n+                Arguments.of(\"*-ch;q=0.5, *;q=0\", \"de-ch, fr-ch\", \"\"),\n+                \/* checking Locale.filter with *;q=0.6, *-Latn;q=0 in\n+                 * EXTENDED_FILTERING\n+                 *\/\n+                Arguments.of(\"*;q=0.6, *-Latn;q=0\", \"de-ch, hi-in, en-Latn\",\n+                        \"de-CH, hi-IN\")\n+        );\n@@ -158,1 +144,0 @@\n-\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8035133.java","additions":58,"deletions":73,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main Bug8135061\n+ * @run junit Bug8135061\n@@ -38,1 +38,4 @@\n-public class Bug8135061 {\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -40,1 +43,1 @@\n-    public static void main(String[] args) {\n+public class Bug8135061 {\n@@ -42,4 +45,6 @@\n-        \/* lookup should run without throwing any exception and\n-         * return null as the language range does not match with the language\n-         * tag\n-         *\/\n+    \/**\n+     * Lookup should run without throwing any exception and return null as\n+     * the language range does not match with the language tag.\n+     *\/\n+    @Test\n+    public void lookupReturnNullTest() {\n@@ -48,1 +53,0 @@\n-\n@@ -51,4 +55,1 @@\n-            if (match != null) {\n-                throw new RuntimeException(\"Locale.lookup returned non-null: \"\n-                        + match);\n-            }\n+            assertNull(match);\n@@ -60,0 +61,1 @@\n+    }\n@@ -61,6 +63,8 @@\n-        \/* lookup should run without throwing any exception and\n-         * return \"nv\" as the matching tag\n-         *\/\n-        ranges = LanguageRange.parse(\"i-navajo\");\n-        locales = Collections.singleton(Locale.of(\"nv\"));\n-\n+    \/**\n+     * Lookup should run without throwing any exception and return \"nv\"\n+     * as the matching tag.\n+     *\/\n+    @Test\n+    public void lookupReturnValueTest() {\n+        List<LanguageRange> ranges = LanguageRange.parse(\"i-navajo\");\n+        Collection<Locale> locales = Collections.singleton(Locale.of(\"nv\"));\n@@ -69,4 +73,1 @@\n-            if (!match.toLanguageTag().equals(\"nv\")) {\n-                throw new RuntimeException(\"Locale.lookup returned unexpected\"\n-                        + \" result: \" + match);\n-            }\n+            assertEquals(match.toLanguageTag(), \"nv\");\n@@ -78,1 +79,0 @@\n-\n@@ -80,1 +80,0 @@\n-\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8135061.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main Bug8159420\n+ * @run junit\/othervm -Duser.language=tr -Duser.country=TR Bug8159420\n@@ -38,0 +38,3 @@\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n@@ -43,3 +46,2 @@\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n@@ -49,3 +51,4 @@\n-public class Bug8159420 {\n-\n-    static boolean err = false;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -53,1 +56,4 @@\n-    public static void main(String[] args) {\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -55,21 +61,1 @@\n-        Locale origLocale = null;\n-        try {\n-\n-            origLocale = Locale.getDefault();\n-            Locale.setDefault(Locale.of(\"tr\", \"TR\"));\n-            testParse();\n-            testFilter(EXTENDED_FILTERING);\n-            testFilter(AUTOSELECT_FILTERING);\n-            testLookup();\n-            testMapEquivalents();\n-\n-            if (err) {\n-                throw new RuntimeException(\"[LocaleMatcher method(s) in turkish\"\n-                        + \" locale failed]\");\n-            }\n-\n-        } finally {\n-            Locale.setDefault(origLocale);\n-        }\n-\n-    }\n+public class Bug8159420 {\n@@ -77,2 +63,3 @@\n-    \/* Before the fix, the testParse() method was throwing\n-     * IllegalArgumentException in Turkish Locale\n+    \/*\n+     * Ensure parse() does not throw IllegalArgumentException for the Turkish Locale\n+     * with the given input.\n@@ -80,1 +67,2 @@\n-    private static void testParse() {\n+    @Test\n+    public void parseTest() {\n@@ -82,7 +70,1 @@\n-        try {\n-            LanguageRange.parse(ranges);\n-        } catch (Exception ex) {\n-            System.err.println(\"[testParse() failed on range string: \"\n-                    + ranges + \"] due to \"+ex);\n-            err = true;\n-        }\n+        assertDoesNotThrow(() -> LanguageRange.parse(ranges));\n@@ -91,2 +73,3 @@\n-    \/* Before the fix, the testFilter() method was returning empty list in\n-     * Turkish Locale\n+    \/*\n+     * Ensure filter() does not return empty list for the Turkish Locale\n+     * with the given input.\n@@ -94,2 +77,3 @@\n-    private static void testFilter(FilteringMode mode) {\n-\n+    @ParameterizedTest\n+    @MethodSource(\"modes\")\n+    public void filterTest(FilteringMode mode) {\n@@ -102,0 +86,2 @@\n+        assertEquals(expectedLocales, actualLocales);\n+    }\n@@ -103,5 +89,5 @@\n-        if (!expectedLocales.equals(actualLocales)) {\n-            System.err.println(\"testFilter(\" + mode + \") failed on language ranges:\"\n-                    + \" [\" + ranges + \"] and language tags: [\" + tags + \"]\");\n-            err = true;\n-        }\n+    private static Stream<FilteringMode> modes() {\n+        return Stream.of(\n+                EXTENDED_FILTERING,\n+                AUTOSELECT_FILTERING\n+        );\n@@ -110,2 +96,3 @@\n-    \/* Before the fix, the testLookup() method was returning null in Turkish\n-     * Locale\n+    \/*\n+     * Ensure lookup() does not return null for the Turkish Locale with\n+     * the given input.\n@@ -113,2 +100,2 @@\n-    private static void testLookup() {\n-        boolean error = false;\n+    @Test\n+    public void lookupTest() {\n@@ -119,10 +106,3 @@\n-        Locale actualLocale\n-                = Locale.lookup(priorityList, localeList);\n-        String actualLocaleString = \"\";\n-\n-        if (actualLocale != null) {\n-            actualLocaleString = actualLocale.toLanguageTag();\n-        } else {\n-            error = true;\n-        }\n-\n+        Locale actualLocale = Locale.lookup(priorityList, localeList);\n+        assertNotNull(actualLocale);\n+        String actualLocaleString = actualLocale.toLanguageTag();\n@@ -130,11 +110,1 @@\n-\n-        if (!expectedLocale.equals(actualLocaleString)) {\n-            error = true;\n-        }\n-\n-        if (error) {\n-            System.err.println(\"testLookup() failed on language ranges:\"\n-                    + \" [\" + ranges + \"] and language tags: [\" + tags + \"]\");\n-            err = true;\n-        }\n-\n+        assertEquals(expectedLocale, actualLocaleString);\n@@ -143,2 +113,3 @@\n-    \/* Before the fix, testMapEquivalents() method was returning only \"hi-in\"\n-     * in Turkish Locale\n+    \/*\n+     * Ensure mapEquivalents() does not only return \"hi-in\" for the Turkish\n+     * Locale with the given input.\n@@ -146,2 +117,2 @@\n-    private static void testMapEquivalents() {\n-\n+    @Test\n+    public void mapEquivalentsTest() {\n@@ -159,8 +130,3 @@\n-        List<LanguageRange> got\n-                = LanguageRange.mapEquivalents(priorityList, map);\n-\n-        if (!areEqual(expected, got)) {\n-            System.err.println(\"testMapEquivalents() failed\");\n-            err = true;\n-        }\n-\n+        List<LanguageRange> got =\n+                LanguageRange.mapEquivalents(priorityList, map);\n+        assertEquals(expected, got, getDifferences(expected, got));\n@@ -169,1 +135,1 @@\n-    private static boolean areEqual(List<LanguageRange> expected,\n+    private static String getDifferences(List<LanguageRange> expected,\n@@ -171,6 +137,1 @@\n-\n-        boolean error = false;\n-        if (expected.equals(got)) {\n-            return !error;\n-        }\n-\n+        StringBuilder diffs = new StringBuilder();\n@@ -180,2 +141,3 @@\n-            error = true;\n-            System.err.println(\"Found missing range(s): \" + cloneExpected);\n+            diffs.append(\"Found missing range(s): \")\n+                    .append(cloneExpected)\n+                    .append(System.lineSeparator());\n@@ -183,3 +145,2 @@\n-\n-        \/\/ not creating the 'got' clone as the list will not be used after this\n-        got.removeAll(expected);\n+        List<LanguageRange> cloneGot = new ArrayList<>(got);\n+        cloneGot.removeAll(expected);\n@@ -187,2 +148,3 @@\n-            error = true;\n-            System.err.println(\"Found extra range(s): \" + got);\n+            diffs.append(\"Got extra range(s): \")\n+                    .append(cloneGot)\n+                    .append(System.lineSeparator());\n@@ -190,1 +152,1 @@\n-        return !error;\n+        return diffs.toString();\n@@ -223,1 +185,0 @@\n-\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8159420.java","additions":63,"deletions":102,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -30,0 +31,1 @@\n+ * @run junit Bug8166994\n@@ -36,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -37,1 +40,3 @@\n-public class Bug8166994 {\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -39,4 +44,1 @@\n-    public static void main(String[] args) {\n-        List<String> list = Arrays.asList(\"ccq-aa\", \"ybd-aa\", \"rki-aa\");\n-        String ranges = \"ccq-aa\";\n-        testParseConsistency(list, ranges);\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -44,2 +46,1 @@\n-        \/\/ consecutive call to check the language range parse consistency\n-        testParseConsistency(list, ranges);\n+public class Bug8166994 {\n@@ -47,6 +48,7 @@\n-        \/\/ another case with ranges consisting of multiple equivalents and\n-        \/\/ single equivalents\n-        list = Arrays.asList(\"gfx-xz\", \"oun-xz\", \"mwj-xz\", \"vaj-xz\",\n-                \"taj-xy\", \"tsf-xy\");\n-        ranges = \"gfx-xz, taj-xy\";\n-        testParseConsistency(list, ranges);\n+    \/*\n+     * Checks that consecutive calls to parse the same language ranges\n+     * generate the same list of language ranges.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"ranges\")\n+    public void parseConsistencyTest(List<String> list, String ranges) {\n@@ -55,1 +57,1 @@\n-\n+        testParseConsistency(list, ranges);\n@@ -58,0 +60,1 @@\n+    \/\/ Ensure that parsing the ranges returns the expected list.\n@@ -60,5 +63,1 @@\n-        if (!list.equals(priorityList)) {\n-            throw new RuntimeException(\"Failed to parse the language range [\"\n-                    + ranges + \"], Expected: \" + list + \" Found: \"\n-                    + priorityList);\n-        }\n+        assertEquals(list, priorityList, \"Failed to parse the language range:\");\n@@ -73,0 +72,9 @@\n+    \/\/ Ranges that have multiple equivalents and single equivalents.\n+    private static Stream<Arguments> ranges() {\n+        return Stream.of(\n+                Arguments.of(Arrays.asList(\"ccq-aa\", \"ybd-aa\", \"rki-aa\"),\n+                        \"ccq-aa\"),\n+                Arguments.of(Arrays.asList(\"gfx-xz\", \"oun-xz\", \"mwj-xz\",\n+                        \"vaj-xz\", \"taj-xy\", \"tsf-xy\"), \"gfx-xz, taj-xy\")\n+        );\n+    }\n@@ -74,1 +82,0 @@\n-\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8166994.java","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Djava.locale.providers=CLDR Bug8179071\n+ * @run junit\/othervm -Djava.locale.providers=CLDR Bug8179071\n@@ -32,1 +32,1 @@\n-\/**\n+\/*\n@@ -41,1 +41,0 @@\n-import java.util.Map;\n@@ -43,0 +42,9 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -46,2 +54,4 @@\n-    \/\/ Deprecated and Legacy tags.\n-    \/\/ As of CLDR 38, language aliases for some of the legacy tags have been removed.\n+    \/*\n+     * Deprecated and Legacy tags.\n+     * As of CLDR 38, language aliases for some legacy tags have been removed.\n+     *\/\n@@ -53,8 +63,0 @@\n-    \/\/ expected month format data for  locales after language aliases replacement.\n-    private static final Map<String, String> shortJanuaryNames = Map.of( \"pa-PK\", \"\\u0a1c\\u0a28\",\n-                                                          \"uz-AF\" , \"yan\",\n-                                                          \"sr-ME\", \"\\u0458\\u0430\\u043d\",\n-                                                          \"scc\", \"\\u0458\\u0430\\u043d\",\n-                                                          \"sh\", \"jan\",\n-                                                          \"ha-Latn-NE\", \"Jan\",\n-                                                          \"i-lux\", \"Jan.\");\n@@ -62,2 +64,4 @@\n-\n-    private static void test(String tag, String expected) {\n+    \/\/ Ensure the display name for the given tag's January is correct\n+    @ParameterizedTest\n+    @MethodSource(\"shortJanuaryNames\")\n+    public void janDisplayNameTest(String tag, String expected) {\n@@ -68,3 +72,1 @@\n-        if (!actual.equals(expected)) {\n-            throw new RuntimeException(\"failed for locale  \" + tag + \" actual output \" + actual +\"  does not match with  \" + expected);\n-        }\n+        assertEquals(expected, actual);\n@@ -73,11 +75,11 @@\n-    \/**\n-     * getAvailableLocales() should not contain any deprecated or Legacy language tags\n-     *\/\n-    private static void checkInvalidTags() {\n-        Set<String> invalidTags = new HashSet<>();\n-        Arrays.asList(Locale.getAvailableLocales()).stream()\n-                .map(loc -> loc.toLanguageTag())\n-                .forEach( tag -> {if(LegacyAliases.contains(tag)) {invalidTags.add(tag);}});\n-        if (!invalidTags.isEmpty()) {\n-          throw new RuntimeException(\"failed: Deprecated and Legacy tags found  \" + invalidTags  + \" in AvailableLocales \");\n-        }\n+    \/\/ Expected month format data for locales after language aliases replacement.\n+    private static Stream<Arguments> shortJanuaryNames() {\n+        return Stream.of(\n+                Arguments.of(\"pa-PK\", \"\\u0a1c\\u0a28\"),\n+                Arguments.of(\"uz-AF\", \"yan\"),\n+                Arguments.of(\"sr-ME\", \"\\u0458\\u0430\\u043d\"),\n+                Arguments.of(\"scc\", \"\\u0458\\u0430\\u043d\"),\n+                Arguments.of(\"sh\", \"jan\"),\n+                Arguments.of(\"ha-Latn-NE\", \"Jan\"),\n+                Arguments.of(\"i-lux\", \"Jan.\")\n+        );\n@@ -86,3 +88,9 @@\n-    public static void main(String[] args) {\n-        shortJanuaryNames.forEach(Bug8179071::test);\n-        checkInvalidTags();\n+    \/\/ getAvailableLocales() should not contain any deprecated or Legacy language tags\n+    @Test\n+    public void invalidTagsTest() {\n+        Set<String> invalidTags = new HashSet<>();\n+        Arrays.stream(Locale.getAvailableLocales())\n+                .map(Locale::toLanguageTag)\n+                .forEach(tag -> {if(LegacyAliases.contains(tag)) {invalidTags.add(tag);}});\n+        assertTrue(invalidTags.isEmpty(),\n+                \"Deprecated and Legacy tags found  \" + invalidTags + \" in AvailableLocales \");\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8179071.java","additions":41,"deletions":33,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main FilteringModeTest\n+ * @run junit FilteringModeTest\n@@ -35,0 +35,9 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -37,6 +46,0 @@\n-    private static boolean err = false;\n-    private static List<String> modeNames = List.of(\"AUTOSELECT_FILTERING\",\n-                                                    \"EXTENDED_FILTERING\",\n-                                                    \"IGNORE_EXTENDED_RANGES\",\n-                                                    \"MAP_EXTENDED_RANGES\",\n-                                                    \"REJECT_EXTENDED_RANGES\");\n@@ -44,3 +47,7 @@\n-    public static void main(String[] args) throws Exception {\n-        testValues();\n-        testValueOf();\n+    private static final List<String> expectedModeNames = List.of(\n+            \"AUTOSELECT_FILTERING\",\n+            \"EXTENDED_FILTERING\",\n+            \"IGNORE_EXTENDED_RANGES\",\n+            \"MAP_EXTENDED_RANGES\",\n+            \"REJECT_EXTENDED_RANGES\"\n+    );\n@@ -48,3 +55,7 @@\n-        if (err) {\n-            throw new RuntimeException(\"Failed.\");\n-        }\n+    \/\/ Ensure valueOf() exceptions are thrown\n+    @Test\n+    public void valueOfExceptionsTest() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> FilteringMode.valueOf(\"\").name());\n+        assertThrows(NullPointerException.class,\n+                () -> FilteringMode.valueOf(null).name());\n@@ -53,14 +64,7 @@\n-    private static void testValueOf() {\n-        try {\n-            FilteringMode.valueOf(\"\").name();\n-            err = true;\n-            System.err.println(\"IAE should be thrown for valueOf(\\\"\\\").\");\n-        } catch (IllegalArgumentException ex) {\n-        }\n-\n-        try {\n-            FilteringMode.valueOf(null).name();\n-            err = true;\n-            System.err.println(\"NPE should be thrown for valueOf(null).\");\n-        } catch (NullPointerException ex) {\n-        }\n+    \/\/ Ensure valueOf() returns expected results\n+    @ParameterizedTest\n+    @MethodSource(\"modes\")\n+    public void valueOfTest(String expectedName) {\n+        String name = FilteringMode.valueOf(expectedName).name();\n+        assertEquals(expectedName, name);\n+    }\n@@ -68,9 +72,2 @@\n-        modeNames.forEach((expectedName) -> {\n-            String name = FilteringMode.valueOf(expectedName).name();\n-            if (!expectedName.equals(name)) {\n-                err = true;\n-                System.err.println(\"FilteringMode.valueOf(\" + expectedName\n-                        + \") returned unexpected value. Expected: \"\n-                        + expectedName + \", got: \" + name);\n-            }\n-        });\n+    private static Stream<String> modes() {\n+        return expectedModeNames.stream();\n@@ -79,1 +76,3 @@\n-    private static void testValues() {\n+    \/\/ Ensure values() returns expected results\n+    @Test\n+    public void valuesTest() {\n@@ -81,1 +80,1 @@\n-        List<String> modeNames2 = Arrays.stream(modeArray)\n+        List<String> actualNames = Arrays.stream(modeArray)\n@@ -84,6 +83,1 @@\n-\n-        if (!modeNames.equals(modeNames2)) {\n-            err = true;\n-            System.err.println(\"FilteringMode.values() returned unexpected value. Expected:\"\n-                    + modeNames + \" Got:\" + modeNames2);\n-        }\n+        assertEquals(expectedModeNames, actualNames);\n","filename":"test\/jdk\/java\/util\/Locale\/FilteringModeTest.java","additions":39,"deletions":45,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -28,0 +29,1 @@\n+ * @run junit HashCodeTest\n@@ -34,0 +36,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n@@ -36,1 +42,3 @@\n-    public static void main(String[] args) {\n+    \/\/ Ensure Locale.hashCode() has less than 10% conflicts\n+    @Test\n+    public void hashConflictsTest() {\n@@ -43,2 +51,1 @@\n-        for (int i = 0; i < locales.length; i++) {\n-            Locale loc = locales[i];\n+        for (Locale loc : locales) {\n@@ -58,4 +65,2 @@\n-        if (conflicts >= (locales.length \/ 10)) {\n-            throw new RuntimeException(\"too many conflicts: \" + conflicts\n-                    + \" per \" + locales.length + \" locales\");\n-        }\n+        assertFalse(conflicts >= (locales.length \/ 10),\n+                String.format(\"%s conflicts per %s locales\", conflicts, locales.length));\n","filename":"test\/jdk\/java\/util\/Locale\/HashCodeTest.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,2 @@\n-\/**\n+\n+\/*\n@@ -26,0 +27,1 @@\n+ * @summary Tests some localized methods with Thai locale\n@@ -28,1 +30,1 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT ThaiGov\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT ThaiGov\n@@ -31,4 +33,6 @@\n-import java.util.*;\n-import java.text.*;\n-\n-public class ThaiGov {\n+import java.text.DateFormat;\n+import java.text.NumberFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n@@ -36,2 +40,1 @@\n-    ThaiGov() {\n-        System.out.println(\"ThaiGov locale test...\");\n+import org.junit.jupiter.api.Test;\n@@ -39,5 +42,1 @@\n-    }\n-\n-    void numberTest() throws RuntimeException {\n-        final String strExpected = \"\\u0E51\\u0E52\\u002C\\u0E53\\u0E54\\u0E55\\u002C\\u0E56\\u0E57\\u0E58\\u002E\\u0E52\\u0E53\\u0E54\";\n-        final double value =  12345678.234;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -45,5 +44,1 @@\n-        Locale locTH = Locale.of(\"th\", \"TH\", \"TH\");\n-\n-        \/\/ th_TH_TH test\n-        NumberFormat nf = NumberFormat.getInstance(locTH);\n-        String str = nf.format(value);\n+public class ThaiGov {\n@@ -51,3 +46,2 @@\n-        if (!strExpected.equals(str)) {\n-            throw new RuntimeException();\n-        }\n+    private static final double VALUE = 12345678.234;\n+    private static final Locale TH = Locale.of(\"th\", \"TH\", \"TH\");\n@@ -55,0 +49,7 @@\n+    \/\/ Test number formatting for thai\n+    @Test\n+    public void numberTest() {\n+        final String strExpected = \"\\u0E51\\u0E52\\u002C\\u0E53\\u0E54\\u0E55\\u002C\\u0E56\\u0E57\\u0E58\\u002E\\u0E52\\u0E53\\u0E54\";\n+        NumberFormat nf = NumberFormat.getInstance(TH);\n+        String str = nf.format(VALUE);\n+        assertEquals(strExpected, str);\n@@ -57,1 +58,3 @@\n-    void currencyTest() throws RuntimeException {\n+    \/\/ Test currency formatting for Thai\n+    @Test\n+    public void currencyTest() {\n@@ -59,12 +62,3 @@\n-        final double value =  12345678.234;\n-\n-        Locale locTH = Locale.of(\"th\", \"TH\", \"TH\");\n-\n-        \/\/ th_TH_TH test\n-        NumberFormat nf = NumberFormat.getCurrencyInstance(locTH);\n-        String str = nf.format(value);\n-\n-        if (!strExpected.equals(str)) {\n-            throw new RuntimeException();\n-        }\n-\n+        NumberFormat nf = NumberFormat.getCurrencyInstance(TH);\n+        String str = nf.format(VALUE);\n+        assertEquals(strExpected, str);\n@@ -73,4 +67,4 @@\n-    void dateTest() throws RuntimeException {\n-        Locale locTH = Locale.of(\"th\", \"TH\", \"TH\");\n-        TimeZone tz = TimeZone.getTimeZone(\"PST\");\n-\n+    \/\/ Test date formatting for Thai\n+    @Test\n+    public void dateTest() {\n+        TimeZone tz = TimeZone.getTimeZone(\"America\/Los_Angeles\");\n@@ -81,1 +75,1 @@\n-        Calendar cal = Calendar.getInstance(tz, locTH);\n+        Calendar cal = Calendar.getInstance(tz, TH);\n@@ -87,1 +81,1 @@\n-        Date value =  cal.getTime();\n+        Date value = cal.getTime();\n@@ -90,1 +84,1 @@\n-        DateFormat df = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, locTH);\n+        DateFormat df = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, TH);\n@@ -93,5 +87,1 @@\n-\n-        if (!strExpected.equals(str)) {\n-            throw new RuntimeException();\n-        }\n-\n+        assertEquals(strExpected, str);\n@@ -99,18 +89,0 @@\n-\n-    public static void main(String[] args) {\n-\n-        ThaiGov app = new ThaiGov();\n-        System.out.print(\"Running numberTest...\");\n-        app.numberTest();\n-        System.out.print(\"Finished\\n\");\n-        System.out.print(\"Running currencyTest...\");\n-        app.currencyTest();\n-        System.out.print(\"Finished\\n\");\n-        System.out.print(\"Running dateTest...\");\n-        app.dateTest();\n-        System.out.print(\"Finished\\n\");\n-\n-        System.out.println(\"PASSED\");\n-    }\n-\n-\n","filename":"test\/jdk\/java\/util\/Locale\/ThaiGov.java","additions":37,"deletions":65,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,2 @@\n-\/**\n+\n+\/*\n@@ -28,1 +29,1 @@\n- * @run main UseOldISOCodesTest\n+ * @run junit UseOldISOCodesTest\n@@ -30,0 +31,1 @@\n+\n@@ -33,0 +35,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n@@ -34,1 +40,4 @@\n-    public static void main(String[] args) throws Exception {\n+\n+    \/\/ Ensure java.locale.useOldISOCodes is only interpreted at runtime startup\n+    @Test\n+    public void staticInitializationTest() throws Exception {\n@@ -46,0 +55,1 @@\n+            \/\/ Should have no effect\n@@ -48,3 +58,2 @@\n-            if(!obsoleteCode.equals(locale.getLanguage())){\n-                throw new RuntimeException(\"Expected that newcode mapped to old \");\n-            }\n+            assertEquals(obsoleteCode, locale.getLanguage(),\n+                    \"newCode 'he' was not mapped to 'iw' with useOldISOCodes=true\");\n","filename":"test\/jdk\/java\/util\/Locale\/UseOldISOCodesTest.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Iterator;\n+import java.util.TreeSet;\n+import java.util.random.RandomGenerator;\n+import java.util.stream.DoubleStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+\/**\n+ * @test\n+ * @bug 8302987\n+ * @key randomness\n+ *\n+ * @summary Check consistency of RandomGenerator::equiDoubles\n+ * @library \/test\/lib\n+ * @run junit EquiDoublesTest\n+ *\n+ *\/\n+\n+public class EquiDoublesTest {\n+\n+    private static final int SAMPLES = 100_000;\n+\n+    \/*\n+     * A factor to use in the tight*() tests to make sure that\n+     * all equidistant doubles are generated.\n+     *\/\n+    private static final long SAFETY_FACTOR = 100L;\n+    private static final RandomGenerator rnd = RandomFactory.getRandom();\n+\n+    private static double nextUp(double d, int steps) {\n+        for (int i = 0; i < steps; ++i) {\n+            d = Math.nextUp(d);\n+        }\n+        return d;\n+    }\n+\n+    private static double nextDown(double d, int steps) {\n+        for (int i = 0; i < steps; ++i) {\n+            d = Math.nextDown(d);\n+        }\n+        return d;\n+    }\n+\n+    static Arguments[] equi() {\n+        return new Arguments[] {\n+                arguments(0.0, 1e-9),\n+                arguments(1.0, 1.1),\n+                arguments(1.0e23, 1.1e23),\n+                arguments(1.0e300, 1.1e300),\n+                arguments(-1.2, 1.1),\n+                arguments(-1.2e-30, 1.1e6),\n+                arguments(-Double.MIN_VALUE, Double.MIN_VALUE),\n+                arguments(-Double.MAX_VALUE, Double.MAX_VALUE),\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void equi(double l, double r) {\n+        double[] minmax = new double[2];\n+\n+        resetMinmax(minmax);\n+        DoubleStream equi = rnd.equiDoubles(l, r, true, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l <= minmax[0]);\n+        assertTrue(minmax[1] < r);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(l, r, true, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l <= minmax[0]);\n+        assertTrue(minmax[1] <= r);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(l, r, false, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l < minmax[0]);\n+        assertTrue(minmax[1] <= r);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(l, r, false, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l < minmax[0]);\n+        assertTrue(minmax[1] < r);\n+\n+        \/* with negated intervals *\/\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(-r, -l, true, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r <= minmax[0]);\n+        assertTrue(minmax[1] < -l);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r <= minmax[0]);\n+        assertTrue(minmax[1] <= -l);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(-r, -l, false, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r < minmax[0]);\n+        assertTrue(minmax[1] <= -l);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(-r, -l, false, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r < minmax[0]);\n+        assertTrue(minmax[1] < -l);\n+    }\n+\n+    private void resetMinmax(double[] minmax) {\n+        minmax[0] = Double.POSITIVE_INFINITY;\n+        minmax[1] = Double.NEGATIVE_INFINITY;\n+    }\n+\n+    private void updateMinmax(double[] minmax, double d) {\n+        if (d < minmax[0]) {\n+            minmax[0] = d;\n+        }\n+        if (d > minmax[1]) {\n+            minmax[1] = d;\n+        }\n+    }\n+\n+    static Arguments[] tight() {\n+        return new Arguments[] {\n+                arguments(0.0, (short) 100),\n+                arguments(1.0, (short) 100),\n+                arguments(1.1, (short) 100),\n+                arguments(1.0e23, (short) 100),\n+                arguments(1.0e300, (short) 100),\n+                arguments(-1.2, (short) 100),\n+                arguments(-1.2e-30, (short) 100),\n+                arguments(-Double.MIN_VALUE, (short) 100),\n+\n+                arguments(-Double.MIN_VALUE, (short) 2),\n+                arguments(-Double.MAX_VALUE, (short) 2),\n+        };\n+    }\n+\n+    \/*\n+     * All equidistant doubles in a tight range are expected to be generated.\n+     * The arguments must be chosen as to not overlap a value with irregular\n+     * spacing around it.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource\n+    void tight(double l, short steps) {\n+        double r = nextUp(l, steps);\n+\n+        TreeSet<Double> set = new TreeSet<>();\n+        DoubleStream equi = rnd.equiDoubles(l, r, true, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+\n+        \/* with negated intervals *\/\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+    }\n+\n+    static Arguments[] tightWithIrregularSpacing() {\n+        return new Arguments[] {\n+                arguments(0x1p-1, (short) 15, (short) 23),\n+                arguments(0x1p0, (short) 17, (short) 5),\n+                arguments(0x1p1, (short) 7, (short) 8),\n+                arguments(0x1p-600, (short) 28, (short) 33),\n+                arguments(0x1p600, (short) 9, (short) 19),\n+        };\n+    }\n+\n+    \/*\n+     * m must be a power of 2 greater than Double.MIN_NORMAL\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource\n+    void tightWithIrregularSpacing(double m, short lSteps, short rSteps) {\n+        double l = nextDown(m, 2 * lSteps);\n+        double r = nextUp(m, rSteps);\n+        int steps = lSteps + rSteps;\n+\n+        TreeSet<Double> set = new TreeSet<>();\n+        DoubleStream equi = rnd.equiDoubles(l, r, true, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+\n+        \/* with negated intervals *\/\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+    }\n+\n+    private void checkEquidistance(TreeSet<Double> set) {\n+        if (set.size() < 3) {\n+            return;\n+        }\n+        Iterator<Double> iter = set.iterator();\n+        double prev = iter.next();\n+        double curr = iter.next();\n+        double delta = curr - prev;\n+        while (iter.hasNext()) {\n+            prev = curr;\n+            curr = iter.next();\n+            assertEquals(delta, curr - prev);\n+        }\n+    }\n+\n+    static Arguments[] empty() {\n+        return new Arguments[] {\n+                arguments(1.0),\n+                arguments(-1.0),\n+                arguments(0.0),\n+                arguments(nextDown(Double.MAX_VALUE, 1)),\n+                arguments(nextUp(-Double.MAX_VALUE, 1)),\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void empty(double l) {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(l, l, true, false)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(l, nextUp(l, 1), false, false)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(nextDown(l, 1), l, false, false)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(l, l, false, true)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(l, nextDown(l, 1), true, true)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(nextUp(l, 1), l, true, true)\n+        );\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/Random\/EquiDoublesTest.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @run main\/othervm -Xmx8m BasicCancelTest\n+ * @run main\/othervm -Xmx64m BasicCancelTest\n@@ -79,1 +79,1 @@\n-        final long moreThanYouCanChew = Runtime.getRuntime().freeMemory() \/ 4;\n+        final long moreThanYouCanChew = Runtime.getRuntime().maxMemory() \/ 32;\n","filename":"test\/jdk\/java\/util\/concurrent\/ScheduledThreadPoolExecutor\/BasicCancelTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8311867\n+ * @summary Stress test of StructuredTaskScope.shutdown with running and starting threads\n+ * @enablePreview\n+ * @run junit StressShutdown\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StressShutdown {\n+\n+    static final Callable<Void> SLEEP_FOR_A_DAY = () -> {\n+        Thread.sleep(Duration.ofDays(1));\n+        return null;\n+    };\n+\n+    static Stream<Arguments> testCases() {\n+        Stream<ThreadFactory> factories = Stream.of(\n+                Thread.ofPlatform().factory(),\n+                Thread.ofVirtual().factory()\n+        );\n+        \/\/ 0..15 forks before shutdown, 0..15 forks after shutdown\n+        return factories.flatMap(f -> IntStream.range(0, 256)\n+                .mapToObj(x -> Arguments.of(f, x & 0x0F, (x & 0xF0) >> 4)));\n+    }\n+\n+    \/**\n+     * Test StructuredTaskScope.shutdown with running threads and concurrently with\n+     * threads that are starting. The shutdown should interrupt all threads so that\n+     * join wakes up.\n+     *\n+     * @param factory the ThreadFactory to use\n+     * @param beforeShutdown the number of subtasks to fork before shutdown\n+     * @param afterShutdown the number of subtasks to fork after shutdown\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    void testShutdown(ThreadFactory factory, int beforeShutdown, int afterShutdown)\n+        throws InterruptedException\n+    {\n+        try (var scope = new StructuredTaskScope<>(null, factory)) {\n+            \/\/ fork subtasks\n+            for (int i = 0; i < beforeShutdown; i++) {\n+                scope.fork(SLEEP_FOR_A_DAY);\n+            }\n+\n+            \/\/ fork subtask to shutdown\n+            scope.fork(() -> {\n+                scope.shutdown();\n+                return null;\n+            });\n+\n+            \/\/ fork after forking subtask to shutdown\n+            for (int i = 0; i < afterShutdown; i++) {\n+                scope.fork(SLEEP_FOR_A_DAY);\n+            }\n+\n+            scope.join();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StressShutdown.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n@@ -62,1 +64,8 @@\n-        for (byte[] extra : new byte[][] { null, new byte[] {1, 2, 3}}) {\n+        \/\/ A structurally valid extra data example\n+        byte[] sampleExtra = new byte[Short.BYTES*3];\n+        ByteBuffer.wrap(sampleExtra).order(ByteOrder.LITTLE_ENDIAN)\n+                .putShort((short) 123)         \/\/ ID:   123\n+                .putShort((short) Short.BYTES) \/\/ Size: 2\n+                .putShort((short) 42);         \/\/ Data: Two bytes\n+\n+        for (byte[] extra : new byte[][] { null, sampleExtra}) {\n","filename":"test\/jdk\/java\/util\/zip\/TestExtraTime.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-        assertZipException(\".*bad header size.*\");\n+        assertZipException(\".*invalid zip64 extra data field size.*\");\n@@ -274,1 +274,1 @@\n-        assertZipException(\".*bad header size.*\");\n+        assertZipException(\".*extra data field size too long.*\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CorruptedZipFiles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright 2023 Alphabet LLC.  All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     6355567\n+ * @summary Verifies that AdobeMarkerSegment() keeps the available bytes\n+ *          and buffer pointer in sync, when a non-standard length Adobe\n+ *          marker is encountered.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+import javax.imageio.stream.ImageInputStream;\n+\n+public class LargeAdobeMarkerSegmentTest {\n+\n+    private static String fileName = \"jdk_6355567.jpg\";\n+\n+    public static void main(String[] args) throws IOException {\n+      \/*\n+       * Open a JPEG image, and get the metadata. Without the fix for\n+       * 6355567, a NegativeArraySizeException is thrown while reading\n+       * the metadata from the JPEG below.\n+       *\/\n+      String sep = System.getProperty(\"file.separator\");\n+      String dir = System.getProperty(\"test.src\", \".\");\n+      String filePath = dir+sep+fileName;\n+      System.out.println(\"Test file: \" + filePath);\n+      File f = new File(filePath);\n+      ImageInputStream iis = ImageIO.createImageInputStream(f);\n+      ImageReader r = ImageIO.getImageReaders(iis).next();\n+      r.setInput(iis);\n+      r.getImageMetadata(0);\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/LargeAdobeMarkerSegmentTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/jdk_6355567.jpg","binary":true,"status":"added"},{"patch":"@@ -51,0 +51,2 @@\n+    private static final int READ_TIMEOUT_SECS = Integer.getInteger(\"readtimeout\", 30);\n+\n@@ -66,14 +68,37 @@\n-            try (DTLSServer server = new DTLSServer(args[0])) {\n-                List<String> command = List.of(\n-                        Path.of(System.getProperty(\"java.home\"), \"bin\", \"java\").toString(),\n-                        \"DTLSWontNegotiateV10\",\n-                        \/\/ if server is \"DTLS\" then the client should be v1.0 and vice versa\n-                        args[0].equals(DTLS) ? DTLSV_1_0 : DTLS,\n-                        Integer.toString(server.getListeningPortNumber())\n-                );\n-\n-                ProcessBuilder builder = new ProcessBuilder(command);\n-                Process p = builder.inheritIO().start();\n-                server.run();\n-                p.destroy();\n-                System.out.println(\"Success: DTLSv1.0 connection was not established.\");\n+            final int totalAttempts = 5;\n+            int tries;\n+            for (tries = 0 ; tries < totalAttempts ; ++tries) {\n+                try {\n+                    System.out.printf(\"Starting server %d\/%d attempts%n\", tries+1, totalAttempts);\n+                    runServer(args[0]);\n+                    break;\n+                } catch (SocketTimeoutException exc) {\n+                    System.out.println(\"The server timed-out waiting for packets from the client.\");\n+                }\n+            }\n+            if (tries == totalAttempts) {\n+                throw new RuntimeException(\"The server\/client communications timed-out after \" + totalAttempts + \" tries.\");\n+            }\n+        }\n+    }\n+\n+    private static void runServer(String protocol) throws Exception {\n+        \/\/ args: protocol\n+        Process clientProcess = null;\n+        try (DTLSServer server = new DTLSServer(protocol)) {\n+            List<String> command = List.of(\n+                    Path.of(System.getProperty(\"java.home\"), \"bin\", \"java\").toString(),\n+                    \"DTLSWontNegotiateV10\",\n+                    \/\/ if server is \"DTLS\" then the client should be v1.0 and vice versa\n+                    protocol.equals(DTLS) ? DTLSV_1_0 : DTLS,\n+                    Integer.toString(server.getListeningPortNumber())\n+            );\n+\n+            ProcessBuilder builder = new ProcessBuilder(command);\n+            clientProcess = builder.inheritIO().start();\n+            server.run();\n+            System.out.println(\"Success: DTLSv1.0 connection was not established.\");\n+\n+        } finally {\n+            if (clientProcess != null) {\n+                clientProcess.destroy();\n@@ -92,0 +117,3 @@\n+            socket.setSoTimeout(READ_TIMEOUT_SECS * 1000);\n+            log(\"Client listening on port \" + socket.getLocalPort()\n+                    + \". Sending data to server port \" + remotePort);\n@@ -290,0 +318,2 @@\n+            socket.setSoTimeout(READ_TIMEOUT_SECS * 1000);\n+            log(\"Server listening on port: \" + socket.getLocalPort());\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSWontNegotiateV10.java","additions":44,"deletions":14,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    jdk.crypto.ec\/sun.security.ec\n+    java.base\/sun.security.ec\n","filename":"test\/jdk\/javax\/net\/ssl\/TLS\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *          jdk.crypto.ec\/sun.security.ec\n+ *          java.base\/sun.security.ec\n","filename":"test\/jdk\/javax\/net\/ssl\/TLS\/TestJSSEClientDefaultProtocol.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *          jdk.crypto.ec\/sun.security.ec\n+ *          java.base\/sun.security.ec\n@@ -78,0 +78,5 @@\n+ * @run main\/othervm --limit-modules java.base\n+ *              -DSERVER_PROTOCOL=SSLv3,TLSv1,TLSv1.1,TLSv1.2,TLSv1.3\n+ *              -DCLIENT_PROTOCOL=TLSv1.3\n+ *              -DCIPHER=TLS_AES_256_GCM_SHA384\n+ *          TestJSSE\n","filename":"test\/jdk\/javax\/net\/ssl\/TLS\/TestJSSEClientProtocol.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *          jdk.crypto.ec\/sun.security.ec\n+ *          java.base\/sun.security.ec\n","filename":"test\/jdk\/javax\/net\/ssl\/TLS\/TestJSSENoCommonProtocols.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *          jdk.crypto.ec\/sun.security.ec\n+ *          java.base\/sun.security.ec\n@@ -63,0 +63,5 @@\n+ * @run main\/othervm --limit-modules java.base\n+ *              -DSERVER_PROTOCOL=TLSv1.2\n+ *              -DCLIENT_PROTOCOL=TLSv1.3\n+ *              -DCIPHER=TLS_AES_256_GCM_SHA384\n+ *          TestJSSE javax.net.ssl.SSLHandshakeException\n","filename":"test\/jdk\/javax\/net\/ssl\/TLS\/TestJSSEServerProtocol.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8140527\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @summary InternalFrame has incorrect title button width\n+ * @run main InternalFrameTitleButtonTest\n+ *\/\n+\n+import java.awt.Component;\n+import java.awt.Robot;\n+\n+import javax.swing.Icon;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JDesktopPane;\n+import javax.swing.JFrame;\n+import javax.swing.JInternalFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.basic.BasicInternalFrameUI;\n+\n+public class InternalFrameTitleButtonTest {\n+\n+    private static JFrame frame;\n+    private static JInternalFrame iframe;\n+\n+    public static void main(String[] args) throws Exception {\n+        String osName = System.getProperty(\"os.name\");\n+        if (!osName.toLowerCase().contains(\"win\")) {\n+            System.out.println(\"The test is applicable only for Windows.\");\n+            return;\n+        }\n+\n+        UIManager.setLookAndFeel(\n+                   \"com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel\");\n+        try {\n+            test(2);\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+\n+        UIManager.setLookAndFeel(\n+              \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n+        try {\n+            test(14);\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+\n+        System.out.println(\"ok\");\n+    }\n+\n+    private static void test(final int widthAdd) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            frame = new JFrame();\n+\n+            JDesktopPane pane = new JDesktopPane();\n+            frame.setContentPane(pane);\n+            frame.setSize(400, 400);\n+            frame.setVisible(true);\n+\n+            iframe = new JInternalFrame(\"Mail Reader\", true,\n+                    true, true, true);\n+            iframe.setSize(200, 200);\n+            pane.add(iframe);\n+            iframe.setVisible(true);\n+        });\n+\n+        Robot robot = new Robot();\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            JComponent title = ((BasicInternalFrameUI) iframe.getUI()).getNorthPane();\n+            for (int i = 0; i < title.getComponentCount(); i++) {\n+                Component c = title.getComponent(i);\n+                if (c instanceof JButton button\n+                    && !testButtonSize(button, widthAdd)) {\n+                    throw new RuntimeException(\"Wrong title icon size\");\n+                }\n+            }\n+        });\n+    }\n+\n+    private static boolean testButtonSize(final JButton button,\n+                                          final int widthAdd) {\n+        int height = UIManager.getInt(\"InternalFrame.titleButtonHeight\") - 4;\n+        Icon icon = button.getIcon();\n+        return height == button.getHeight()\n+               && (height + widthAdd) == button.getWidth()\n+               && height == icon.getIconHeight()\n+               && (height + widthAdd) == icon.getIconWidth();\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/InternalFrameTitleButtonTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import jdk.internal.classfile.Classfile;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.constant.ClassDesc;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static jdk.internal.classfile.Classfile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 8311172\n+ * @run junit PreviewMinorVersionTest\n+ * @summary Ensures Classfile.PREVIEW_MINOR_VERSION equals that of classes with\n+ *          preview minor version from ClassModel::minorVersion\n+ *\/\n+public class PreviewMinorVersionTest {\n+\n+    @Test\n+    public void testMinorVersionMatches() {\n+        \/\/ compile a class with --enable-preview\n+        \/\/ uses Record feature to trigger forcePreview\n+        var cf = Classfile.of();\n+        var cd = ClassDesc.of(\"Test\");\n+        var bytes = cf.build(cd, cb -> cb\n+                .withSuperclass(CD_Object)\n+                \/\/ old preview minor version,\n+                \/\/ with all bits set to 1\n+                .withVersion(JAVA_17_VERSION, -1)\n+        );\n+\n+        var cm = Classfile.of().parse(bytes);\n+        assertEquals(Classfile.PREVIEW_MINOR_VERSION, cm.minorVersion());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/PreviewMinorVersionTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -47,2 +47,2 @@\n- * @run main\/othervm -XX:NativeMemoryTracking=summary -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents true\n- * @run main\/othervm -XX:NativeMemoryTracking=off -Xms16m -Xmx128m -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents false\n+ * @run main\/othervm -XX:NativeMemoryTracking=summary -Xms16m -Xmx128m -XX:-UseLargePages -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents true\n+ * @run main\/othervm -XX:NativeMemoryTracking=off -Xms16m -Xmx128m -XX:-UseLargePages -Xlog:gc jdk.jfr.event.runtime.TestNativeMemoryUsageEvents false\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeMemoryUsageEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,0 @@\n- * @ignore\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestChunkIntegrity.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+                Asserts.assertEquals(t.getOSName(), null);\n+                Asserts.assertEquals(t.getOSThreadId(), -1L);\n@@ -93,2 +95,0 @@\n-                Asserts.assertEquals(t.getOSName(), \"\");\n-                Asserts.assertEquals(t.getThreadGroup().getName(), \"VirtualThreads\");\n@@ -96,1 +96,1 @@\n-                Asserts.assertEquals(t.getOSThreadId(), 0L);\n+                Asserts.assertEquals(t.getThreadGroup().getName(), \"VirtualThreads\");\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestManyVirtualThreads.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+            Asserts.assertEquals(t.getOSName(), null);\n+            Asserts.assertEquals(t.getOSThreadId(), -1L);\n@@ -78,2 +80,0 @@\n-            Asserts.assertEquals(t.getOSName(), \"\");\n-            Asserts.assertEquals(t.getThreadGroup().getName(), \"VirtualThreads\");\n@@ -81,1 +81,1 @@\n-            Asserts.assertEquals(t.getOSThreadId(), 0L);\n+            Asserts.assertEquals(t.getThreadGroup().getName(), \"VirtualThreads\");\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestNestedVirtualThreads.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.module.ModuleFinder;\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test\n+ * @bug 8308398\n+ * @library \/test\/lib\n+ * @summary Verify jdk.crypto.ec empty module\n+ * @run main ecModuleCheck\n+ *\/\n+\n+\/* This test verifies jdk.crypto.ec is in the image, but not resolvable.\n+ *\/\n+public class ecModuleCheck {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ True if module is found in the image.\n+        assertTrue(ModuleFinder.ofSystem().find(\"jdk.crypto.ec\").isPresent(),\n+            \"jdk.crypto.ec was not found in image.\");\n+        \/\/ Since the module empty, isPresent() should be false.\n+        assertFalse(ModuleLayer.boot().findModule(\"jdk.crypto.ec\").\n+            isPresent(), \"jdk.crypto.ec shouldn't be resolvable.\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ec\/ecModuleCheck.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- *          jdk.crypto.ec\/sun.security.ec.ed\n+ *          java.base\/sun.security.ec.ed\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/TestEdOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules jdk.crypto.ec\/sun.security.ec\n+ * @modules java.base\/sun.security.ec\n","filename":"test\/jdk\/sun\/security\/ec\/xec\/TestXECOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @modules jdk.crypto.ec\/sun.security.ec\n+ * @modules java.base\/sun.security.ec\n","filename":"test\/jdk\/sun\/security\/ec\/xec\/XECIterative.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *      8305975 8304760 8307134\n+ *      8305975 8304760 8307134 8295894\n@@ -50,1 +50,1 @@\n-    private static final int COUNT = 97;\n+    private static final int COUNT = 96;\n@@ -55,1 +55,1 @@\n-            = \"72:03:89:C2:7B:BF:87:87:E1:65:44:6E:43:5C:65:FF:B5:E8:F9:4C:8A:D1:63:6D:D1:91:4C:AD:1C:9A:CB:3B\";\n+            = \"88:D6:74:27:42:58:D3:C7:40:B2:D7:24:93:4B:09:2D:6C:C1:EB:6A:6D:6A:AD:3D:72:D0:DF:8D:B7:59:99:8E\";\n@@ -164,2 +164,0 @@\n-            put(\"secomscrootca1 [jdk]\",\n-                    \"E7:5E:72:ED:9F:56:0E:EC:6E:B4:80:00:73:A4:3F:C3:AD:19:19:5A:39:22:82:01:78:95:97:4A:99:02:6B:6C\");\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @modules jdk.crypto.cryptoki jdk.crypto.ec\/sun.security.ec\n+ * @modules jdk.crypto.cryptoki java.base\/sun.security.ec\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/ReadPKCS12.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-        \/\/ check if jdk.crypto.ec module has been de-privileged\n+        \/\/ check if jdk.crypto.cryptoki module has been de-privileged\n@@ -69,1 +69,1 @@\n-            new CodeSource(new URL(\"jrt:\/jdk.crypto.ec\"), (CodeSigner[])null);\n+            new CodeSource(new URL(\"jrt:\/jdk.crypto.cryptoki\"), (CodeSigner[])null);\n@@ -74,1 +74,1 @@\n-        if (!p.implies(pd, new RuntimePermission(\"loadLibrary.sunec\"))) {\n+        if (!p.implies(pd, new RuntimePermission(\"loadLibrary.j2pkcs11\"))) {\n","filename":"test\/jdk\/sun\/security\/provider\/PolicyFile\/DefaultPolicy.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8164879\n+ * @bug 8164879 8300285\n@@ -30,1 +30,2 @@\n- * @summary Verify AES\/GCM's limits set in the jdk.tls.keyLimits property\n+ * @summary Verify AEAD TLS cipher suite limits set in the jdk.tls.keyLimits\n+ * property\n@@ -36,2 +37,8 @@\n- * @run main SSLEngineKeyLimit 0 server AES\/GCM\/NoPadding keyupdate 1050000\n- * @run main SSLEngineKeyLimit 1 client AES\/GCM\/NoPadding keyupdate 2^22\n+ * @run main SSLEngineKeyLimit 0 server TLS_AES_256_GCM_SHA384\n+ *      AES\/GCM\/NoPadding keyupdate 1050000\n+ * @run main SSLEngineKeyLimit 1 client TLS_AES_256_GCM_SHA384\n+ *      AES\/GCM\/NoPadding keyupdate 2^22\n+ * @run main SSLEngineKeyLimit 0 server TLS_CHACHA20_POLY1305_SHA256\n+ *      AES\/GCM\/NoPadding keyupdate 1050000, ChaCha20-Poly1305 KeyUpdate 1050000\n+ * @run main SSLEngineKeyLimit 1 client TLS_CHACHA20_POLY1305_SHA256\n+ *      AES\/GCM\/NoPadding keyupdate 2^22, ChaCha20-Poly1305 KeyUpdate 2^22\n@@ -81,1 +88,1 @@\n-     * args should have two values:  server|client, <limit size>\n+     * args should have two values:  server|client, cipher suite, <limit size>\n@@ -100,1 +107,1 @@\n-            for (int i = 2; i < args.length; i++) {\n+            for (int i = 3; i < args.length; i++) {\n@@ -115,1 +122,2 @@\n-                    Utils.addTestJavaOpts(\"SSLEngineKeyLimit\", \"p\", args[1]));\n+                    Utils.addTestJavaOpts(\"SSLEngineKeyLimit\", \"p\", args[1],\n+                            args[2]));\n@@ -119,0 +127,2 @@\n+                output.shouldContain(String.format(\n+                        \"\\\"cipher suite\\\"        : \\\"%s\", args[2]));\n@@ -159,1 +169,2 @@\n-        Thread ts = new Thread(serverwrite ? new Client() : new Server());\n+        Thread ts = new Thread(serverwrite ? new Client() :\n+                new Server(args[2]));\n@@ -161,1 +172,1 @@\n-        (serverwrite ? new Server() : new Client()).run();\n+        (serverwrite ? new Server(args[2]) : new Client()).run();\n@@ -398,1 +409,1 @@\n-        Server() throws Exception {\n+        Server(String cipherSuite) throws Exception {\n@@ -403,0 +414,3 @@\n+            if (cipherSuite != null && cipherSuite.length() > 0) {\n+                eng.setEnabledCipherSuites(new String[] { cipherSuite });\n+            }\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineKeyLimit.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8164879\n+ * @bug 8164879 8300285\n@@ -30,4 +30,14 @@\n- * @summary Verify AES\/GCM's limits set in the jdk.tls.keyLimits property\n- * @run main SSLSocketKeyLimit 0 server AES\/GCM\/NoPadding keyupdate 1000000\n- * @run main SSLSocketKeyLimit 0 client AES\/GCM\/NoPadding keyupdate 1000000\n- * @run main SSLSocketKeyLimit 1 client AES\/GCM\/NoPadding keyupdate 2^22\n+ * @summary Verify AEAD TLS cipher suite limits set in the jdk.tls.keyLimits\n+ * property\n+ * @run main SSLSocketKeyLimit 0 server TLS_AES_256_GCM_SHA384\n+ *      AES\/GCM\/NoPadding keyupdate 1000000\n+ * @run main SSLSocketKeyLimit 0 client TLS_AES_256_GCM_SHA384\n+ *      AES\/GCM\/NoPadding keyupdate 1000000\n+ * @run main SSLSocketKeyLimit 1 client TLS_AES_256_GCM_SHA384\n+ *      AES\/GCM\/NoPadding keyupdate 2^22\n+ * @run main SSLSocketKeyLimit 0 server TLS_CHACHA20_POLY1305_SHA256\n+ *      AES\/GCM\/NoPadding keyupdate 1000000, ChaCha20-Poly1305 KeyUpdate 1000000\n+ * @run main SSLSocketKeyLimit 0 client TLS_CHACHA20_POLY1305_SHA256\n+ *      AES\/GCM\/NoPadding keyupdate 1000000, ChaCha20-Poly1305 KeyUpdate 1000000\n+ * @run main SSLSocketKeyLimit 1 client TLS_CHACHA20_POLY1305_SHA256\n+ *      AES\/GCM\/NoPadding keyupdate 2^22, ChaCha20-Poly1305 KeyUpdate 2^22\n@@ -99,1 +109,1 @@\n-     * args should have two values:  server|client, <limit size>\n+     * args should have three values:  server|client, cipher suite, <limit size>\n@@ -113,1 +123,1 @@\n-            for (int i = 2; i < args.length; i++) {\n+            for (int i = 3; i < args.length; i++) {\n@@ -128,1 +138,2 @@\n-                    Utils.addTestJavaOpts(\"SSLSocketKeyLimit\", \"p\", args[1]));\n+                    Utils.addTestJavaOpts(\"SSLSocketKeyLimit\", \"p\", args[1],\n+                            args[2]));\n@@ -132,0 +143,2 @@\n+                output.shouldContain(String.format(\n+                        \"\\\"cipher suite\\\"        : \\\"%s\", args[2]));\n@@ -153,1 +166,1 @@\n-        if (args.length > 0 && args[0].compareToIgnoreCase(\"client\") == 0) {\n+        if (args.length > 0 && args[1].compareToIgnoreCase(\"client\") == 0) {\n@@ -165,1 +178,1 @@\n-        Thread ts = new Thread(new Server());\n+        Thread ts = new Thread(new Server(args[2]));\n@@ -203,1 +216,2 @@\n-            System.out.println(\"Server: connected \" + s.getSession().getCipherSuite());\n+            System.out.println(\"Server: connected \" +\n+                    s.getSession().getCipherSuite());\n@@ -215,1 +229,2 @@\n-                    System.out.println(\"\\nData invalid: \" + HexPrinter.minimal().toString(buf));\n+                    System.out.println(\"\\nData invalid: \" +\n+                            HexPrinter.minimal().toString(buf));\n@@ -240,1 +255,1 @@\n-        Server() {\n+        Server(String cipherSuite) {\n@@ -245,0 +260,3 @@\n+                if (cipherSuite != null && cipherSuite.length() > 0) {\n+                    ss.setEnabledCipherSuites(new String[] { cipherSuite });\n+                }\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketKeyLimit.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.security.*;\n-\n-\/*\n- * Export a private key from the named keychain entry without supplying a\n- * password. See JDK-8062264.\n- *\n- * NOTE: Keychain access controls must already have been lowered to permit\n- *       the target entry to be accessed.\n- *\/\n-public class ExportPrivateKeyNoPwd {\n-\n-    public static final void main(String[] args) throws Exception {\n-\n-        if (args.length != 1) {\n-            throw new Exception(\n-                \"ExportPrivateKeyNoPwd: must supply name of a keystore entry\");\n-        }\n-        String alias = args[0];\n-\n-        KeyStore ks = KeyStore.getInstance(\"KeychainStore\");\n-        System.out.println(\"ExportPrivateKeyNoPwd: loading keychains...\");\n-        ks.load(null, null);\n-\n-        System.out.println(\"ExportPrivateKeyNoPwd: exporting key...\");\n-        Key key = ks.getKey(alias, null);\n-        if (key instanceof PrivateKey) {\n-            System.out.println(\"ExportPrivateKeyNoPwd: exported \" +\n-                key.getAlgorithm() + \" private key from '\" + alias + \"'\");\n-        } else {\n-            throw new Exception(\"Error exporting private key from keychain\");\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/ExportPrivateKeyNoPwd.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 7133495 8062264 8046777 8153005\n+ * @summary KeyChain KeyStore implementation retrieves only one private key entry\n+ * @requires (os.family == \"mac\")\n+ * @library \/test\/lib\n+ * @run main\/othervm\/manual ListKeyChainStore\n+ *\/\n+\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+\n+public class ListKeyChainStore {\n+    private static final String PWD = \"xxxxxx\";\n+    private static final String DEFAULT_KEYTOOL = \"-list -storetype KeychainStore \" +\n+            \"-keystore NONE -storepass \" + PWD;\n+    private static final String USER_DIR = System.getProperty(\"user.dir\", \".\");\n+    private static final String FS = System.getProperty(\"file.separator\");\n+    private static final String PKCS12_KEYSTORE = USER_DIR + FS + \"7133495.p12\";\n+    private static final String KEYCHAIN_FILE = USER_DIR + FS + \"7133495.keychain\";\n+    private static final String TEMPORARY_FILE = USER_DIR + FS + \"7133495.tmp\";\n+    private static final String USER_KEYCHAIN_LIST = USER_DIR + FS + \"user.keychain.list\";\n+    private static final String PRIVATE_KEY_ENTRY = \"PrivateKeyEntry\";\n+\n+    public static void main(String[] args) throws Throwable {\n+        LOG_MSG(\"WARNING: This test doesn't work on macOS virtualized environment. \" +\n+                \"`security list-keychains -s` doesn't update the search order.\");\n+\n+        deleteTestTempFilesIfExists();\n+\n+        \/\/ Get the old security keychain list to restore later\n+        try (PrintStream printStream = new PrintStream(USER_KEYCHAIN_LIST)) {\n+            ProcessTools.executeCommand(\"sh\", \"-c\", \"security list-keychains\")\n+                    .shouldHaveExitValue(0).outputTo(printStream);\n+        }\n+\n+        try {\n+            try (PrintStream printStream = new PrintStream(TEMPORARY_FILE)) {\n+                SecurityTools.keytool(DEFAULT_KEYTOOL).shouldHaveExitValue(0)\n+                        .outputTo(printStream);\n+            }\n+            int oldPrivateKeyCount = countOccurrences(TEMPORARY_FILE, PRIVATE_KEY_ENTRY);\n+            LOG_MSG(\"Found \" + oldPrivateKeyCount + \" private key entries in the \" +\n+                    \"Keychain keystore\");\n+\n+            \/\/ Create the PKCS12 keystore containing 3 public\/private key pairs\n+            LOG_MSG(\"Creating PKCS12 keystore: \" + PKCS12_KEYSTORE);\n+            for (int i = 0; i < 3; i++) {\n+                \/\/ Use legacy encryption and MAC algorithms, refer macOS open radar FB8988319\n+                \/\/ macOS security framework doesn't work with the latest algorithms\n+                SecurityTools.keytool(String.format(\"-J-Dkeystore.pkcs12.legacy -genkeypair\" +\n+                                \" -storetype PKCS12 -keystore %s -storepass %s -keyalg rsa  -dname \" +\n+                                \"CN=CN%d,OU=OU%d,O=O%d,ST=ST%d,C=US -alias 7133495-%d\",\n+                        PKCS12_KEYSTORE, PWD, i, i, i, i, i)).shouldHaveExitValue(0);\n+            }\n+\n+            \/\/ Create the keychain\n+            LOG_MSG(\"Creating keychain: \" + KEYCHAIN_FILE);\n+            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security create-keychain\" +\n+                    \" -p %s %s\", PWD, KEYCHAIN_FILE)).shouldHaveExitValue(0);\n+\n+            \/\/ Unlock the keychain\n+            LOG_MSG(\"Unlock keychain: \" + KEYCHAIN_FILE);\n+            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security unlock-keychain\" +\n+                    \" -p %s %s\", PWD, KEYCHAIN_FILE)).shouldHaveExitValue(0);\n+\n+            \/\/ Import the key pairs from the PKCS12 keystore into the keychain\n+            \/\/ The '-A' option is used to lower the keychain's access controls\n+            LOG_MSG(\"Importing the key pairs from \" + PKCS12_KEYSTORE\n+                    + \" to \" + KEYCHAIN_FILE);\n+            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security import %s -k %s\" +\n+                    \" -f pkcs12 -P %s -A\", PKCS12_KEYSTORE, KEYCHAIN_FILE, PWD)).shouldHaveExitValue(0);\n+\n+            \/\/ Generate a 2048-bit RSA keypair and import into the keychain\n+            \/\/ Its private key is configured with non-default key usage settings\n+            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"certtool ca k=%s \" +\n+                    \"<<EOF\\n\" +\n+                    \"test\\n\" +\n+                    \"r\\n\" +\n+                    \"2048\\n\" +\n+                    \"y\\n\" +\n+                    \"b\\n\" +\n+                    \"s\\n\" +\n+                    \"y\\n\" +\n+                    \"A\\n\" +\n+                    \"US\\n\" +\n+                    \"A\\n\" +\n+                    \"A\\n\" +\n+                    \"\\n\" +\n+                    \"\\n\" +\n+                    \"y\\n\" +\n+                    \"EOF\", KEYCHAIN_FILE)).shouldHaveExitValue(0);\n+\n+            \/\/ Adjust the keychain search order to add KEYCHAIN_FILE to top\n+            try (PrintStream printStream = new PrintStream(TEMPORARY_FILE)) {\n+                printStream.println(\"\\\"\" + KEYCHAIN_FILE + \"\\\"\");\n+                printStream.println(ProcessTools.executeCommand(\"sh\", \"-c\", \"security list-keychains\")\n+                        .shouldHaveExitValue(0).getOutput());\n+            }\n+            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security list-keychains -s %s\",\n+                    ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"xargs < %s\",\n+                            TEMPORARY_FILE)).getOutput()));\n+            LOG_MSG(\"Keychain search order:\");\n+            ProcessTools.executeCommand(\"sh\", \"-c\", \"security list-keychains\");\n+\n+            \/\/ Recount the number of private key entries in the Keychain keystore\n+            \/\/ 3 private keys imported from PKCS12, 1 private key generated by 'certtool'\n+            Files.deleteIfExists(Paths.get(TEMPORARY_FILE));\n+            try (PrintStream printStream = new PrintStream(TEMPORARY_FILE)) {\n+                SecurityTools.keytool(DEFAULT_KEYTOOL).shouldHaveExitValue(0)\n+                        .outputTo(printStream);\n+            }\n+            int newPrivateKeyCount = countOccurrences(TEMPORARY_FILE, PRIVATE_KEY_ENTRY);\n+            LOG_MSG(\"Found \" + newPrivateKeyCount + \" private key entries in \" +\n+                    \"the Keychain keystore\");\n+            if (newPrivateKeyCount < (oldPrivateKeyCount + 4)) {\n+                throw new RuntimeException(\"Error: expected more private key entries in the \" +\n+                        \"Keychain keystore\");\n+            }\n+\n+            \/\/ Export a private key from the keychain (without supplying a password)\n+            \/\/ Access controls have already been lowered (see 'security import ... -A' above)\n+            LOG_MSG(\"Exporting a private key from the keychain\");\n+            KeyStore ks = KeyStore.getInstance(\"KeychainStore\");\n+            ks.load(null, null);\n+            Key key = ks.getKey(\"CN0\", null);\n+            if (key instanceof PrivateKey) {\n+                LOG_MSG(\"Exported \" + key.getAlgorithm() + \" private key from CN0\");\n+            } else {\n+                throw new RuntimeException(\"Error exporting private key from keychain\");\n+            }\n+        } finally {\n+            \/\/ Reset earlier keychain list\n+            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security list-keychains -s %s\",\n+                    ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"xargs < %s\",\n+                            USER_KEYCHAIN_LIST)).getOutput()));\n+\n+            deleteTestTempFilesIfExists();\n+        }\n+    }\n+\n+    private static void deleteTestTempFilesIfExists() throws Throwable {\n+        Files.deleteIfExists(Paths.get(USER_KEYCHAIN_LIST));\n+        Files.deleteIfExists(Paths.get(PKCS12_KEYSTORE));\n+        if (Files.exists(Paths.get(KEYCHAIN_FILE))) {\n+            ProcessTools.executeCommand(\"sh\", \"-c\", String.format(\"security delete-keychain\" +\n+                    \" %s\", KEYCHAIN_FILE)).shouldHaveExitValue(0);\n+        }\n+        Files.deleteIfExists(Paths.get(TEMPORARY_FILE));\n+    }\n+\n+    private static int countOccurrences(String filePath, String word) throws IOException {\n+        int count = 0;\n+        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                if (line.contains(word)) {\n+                    count++;\n+                }\n+            }\n+        }\n+\n+        return count;\n+    }\n+\n+    private static void LOG_MSG(String msg) {\n+        \/\/ ProcessTools and SecurityTools log a lot of messages so pretty format\n+        \/\/ messages logged from this test\n+        System.out.println();\n+        System.out.println(\"==> \" + msg);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/ListKeyChainStore.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -1,188 +0,0 @@\n-#\n-# Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 7133495 8041740 8062264 8046777\n-# @summary [macosx] KeyChain KeyStore implementation retrieves only one private key entry\n-\n-if [ \"${TESTJAVA}\" = \"\" ] ; then\n-    JAVAC_CMD=`which javac`\n-    TESTJAVA=`dirname $JAVAC_CMD`\/..\n-fi\n-\n-if [ \"${TESTSRC}\" = \"\" ] ; then\n-    TESTSRC=\".\"\n-fi\n-if [ \"${TESTCLASSES}\" = \"\" ] ; then\n-    TESTCLASSES=`pwd`\n-fi\n-\n-# Only run on MacOS\n-OS=`uname -s`\n-case \"$OS\" in\n-    Darwin )\n-        ;;\n-    * )\n-        echo \"Will not run test on: ${OS}\"\n-        exit 0;\n-        ;;\n-esac\n-\n-PWD=\"xxxxxx\"\n-KEYTOOL=\"${TESTJAVA}\/bin\/keytool ${TESTTOOLVMOPTS} -storetype KeychainStore -keystore NONE -storepass $PWD\"\n-TEMPORARY_P12=\"$TESTCLASSES\/7133495.p12\"\n-TEMPORARY_KC=\"$TESTCLASSES\/7133495.keychain\"\n-TEMPORARY_LIST=\"$TESTCLASSES\/7133495.tmp\"\n-CLEANUP_P12=\"rm -f $TEMPORARY_P12\"\n-CLEANUP_KC=\"security delete-keychain $TEMPORARY_KC\"\n-CLEANUP_LIST=\"rm -f $TEMPORARY_LIST\"\n-\n-# Count the number of private key entries in the Keychain keystores\n-\n-COUNT=`$KEYTOOL -list | grep PrivateKeyEntry | wc -l`\n-echo \"Found $COUNT private key entries in the Keychain keystores\"\n-\n-# Create a temporary PKCS12 keystore containing 3 public\/private keypairs\n-\n-RESULT=`$CLEANUP_P12`\n-\n-for i in X Y Z\n-do\n-    ${TESTJAVA}\/bin\/keytool ${TESTTOOLVMOPTS} -genkeypair \\\n-        -storetype PKCS12 \\\n-        -keystore $TEMPORARY_P12 \\\n-        -storepass $PWD \\\n-        -keyalg rsa \\\n-        -dname \"CN=$i,OU=$i,O=$i,ST=$i,C=US\" \\\n-        -alias 7133495-$i\n-\n-    if [ $? -ne 0 ]; then\n-        echo \"Error: cannot create keypair $i in the temporary PKCS12 keystore\"\n-        RESULT=`$CLEANUP_P12`\n-        exit 1\n-    fi\n-done\n-echo \"Created a temporary PKCS12 keystore: $TEMPORARY_P12\"\n-\n-# Create a temporary keychain\n-\n-security create-keychain -p $PWD $TEMPORARY_KC\n-if [ $? -ne 0 ]; then\n-    echo \"Error: cannot create the temporary keychain\"\n-    RESULT=`$CLEANUP_P12`\n-    exit 2\n-fi\n-echo \"Created a temporary keychain: $TEMPORARY_KC\"\n-\n-# Unlock the temporary keychain\n-\n-security unlock-keychain -p $PWD $TEMPORARY_KC\n-if [ $? -ne 0 ]; then\n-    echo \"Error: cannot unlock the temporary keychain\"\n-    RESULT=`$CLEANUP_P12`\n-    RESULT=`$CLEANUP_KC`\n-    exit 3\n-fi\n-echo \"Unlocked the temporary keychain\"\n-\n-# Import the keypairs from the PKCS12 keystore into the keychain\n-# (The '-A' option is used to lower the temporary keychain's access controls)\n-\n-security import $TEMPORARY_P12 -k $TEMPORARY_KC -f pkcs12 -P $PWD -A\n-if [ $? -ne 0 ]; then\n-    echo \"Error: cannot import keypairs from PKCS12 keystore into the keychain\"\n-    RESULT=`$CLEANUP_P12`\n-    RESULT=`$CLEANUP_KC`\n-    exit 4\n-fi\n-echo \"Imported keypairs from PKCS12 keystore into the keychain\"\n-\n-# Generate a 2048-bit RSA keypair and import into the temporary keychain\n-# (its private key is configured with non-default key usage settings)\n-\n-certtool c k=$TEMPORARY_KC <<EOF\n-test\n-r\n-2048\n-y\n-b\n-s\n-y\n-A\n-US\n-A\n-A\n-\n-\n-y\n-EOF\n-\n-# Adjust the keychain search order\n-\n-echo \"\\\"$TEMPORARY_KC\\\"\" > $TEMPORARY_LIST\n-security list-keychains >> $TEMPORARY_LIST\n-security list-keychains -s `xargs < ${TEMPORARY_LIST}`\n-`$CLEANUP_LIST`\n-echo \"Temporary keychain search order:\"\n-security list-keychains\n-\n-# Recount the number of private key entries in the Keychain keystores\n-# (3 private keys imported from PKCS12, 1 private key generated by 'certtool')\n-\n-RECOUNT=`$KEYTOOL -list | grep PrivateKeyEntry | wc -l`\n-echo \"Found $RECOUNT private key entries in the Keychain keystore\"\n-if [ $RECOUNT -lt `expr $COUNT + 4` ]; then\n-    echo \"Error: expected >$COUNT private key entries in the Keychain keystores\"\n-    RESULT=`$CLEANUP_P12`\n-    RESULT=`$CLEANUP_KC`\n-    exit 5\n-fi\n-\n-# Export a private key from the keychain (without supplying a password)\n-# Access controls have already been lowered (see 'security import ... -A' above)\n-\n-${TESTJAVA}\/bin\/javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} -d . ${TESTSRC}\/ExportPrivateKeyNoPwd.java || exit 6\n-${TESTJAVA}\/bin\/java ${TESTVMOPTS} ExportPrivateKeyNoPwd x\n-if [ $? -ne 0 ]; then\n-    echo \"Error exporting private key from the temporary keychain\"\n-    RESULT=`$CLEANUP_P12`\n-    RESULT=`$CLEANUP_KC`\n-    exit 6\n-fi\n-echo \"Exported a private key from the temporary keychain\"\n-\n-RESULT=`$CLEANUP_P12`\n-if [ $? -ne 0 ]; then\n-    echo \"Error: cannot remove the temporary PKCS12 keystore\"\n-    exit 7\n-fi\n-echo \"Removed the temporary PKCS12 keystore\"\n-\n-RESULT=`$CLEANUP_KC`\n-if [ $? -ne 0 ]; then\n-    echo \"Error: cannot remove the temporary keychain\"\n-    exit 8\n-fi\n-echo \"Removed the temporary keychain\"\n-\n-exit 0\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/ListKeychainStore.sh","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- *        jdk.crypto.ec\/sun.security.ec.ECKeyPairGenerator\n+ *        java.base\/sun.security.ec.ECKeyPairGenerator\n@@ -33,1 +33,3 @@\n- * @modules jdk.crypto.ec\n+ *\n+ * This test uses RSA, DSA, and EC inside this test directory, not the providers\n+ * from the jdk\n@@ -85,4 +87,1 @@\n-                + File.separator + \"patches\" + File.separator + \"java.base\"\n-                + \" -J--patch-module=jdk.crypto.ec=\"\n-                + System.getProperty(\"test.classes\")\n-                + File.separator + \"patches\" + File.separator + \"jdk.crypto.ec\";\n+                + File.separator + \"patches\" + File.separator + \"java.base\";\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakegen\/DefaultSignatureAlgorithm.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"","filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakegen\/java.base\/sun\/security\/ec\/ECKeyPairGenerator.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakegen\/jdk.crypto.ec\/sun\/security\/ec\/ECKeyPairGenerator.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.tools.jlink.internal.Platform;\n@@ -163,1 +164,1 @@\n-                mods, ByteOrder.nativeOrder(),\n+                mods,\n@@ -192,1 +193,2 @@\n-        DefaultImageBuilder builder = new DefaultImageBuilder(output, Collections.emptyMap());\n+        DefaultImageBuilder builder = new DefaultImageBuilder(output, Collections.emptyMap(),\n+                Platform.runtime());\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.internal.util.OperatingSystem;\n+\n+\/*\n+ * @test\n+ * @bug 8206890\n+ * @summary verify that the image created through jlink uses the byte order of the target platform\n+ * @modules java.base\/jdk.internal.util\n+ * @comment the test asserts the presence of locale specific error message in the test's output,\n+ *          so we explicitly use en_US locale\n+ * @run main\/othervm -Duser.language=en -Duser.country=US JLinkEndianTest\n+ *\/\n+public class JLinkEndianTest {\n+    private static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\"jlink\")\n+            .orElseThrow(() -> new RuntimeException(\"jlink tool not found\"));\n+\n+\n+    public static void main(final String[] args) throws Exception {\n+        testEndianMismatch();\n+        testCorrectEndian();\n+    }\n+\n+    \/**\n+     * Launches jlink with \"--endian\" option whose value doesn't match the target platform.\n+     * Asserts that the jlink process fails with an error.\n+     *\/\n+    private static void testEndianMismatch() throws Exception {\n+        \/\/ we use a --endian value which doesn't match the current platform's endianness.\n+        \/\/ this should cause the jlink image generation against the current platform to fail\n+        final String endianOptVal = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? \"big\" : \"little\";\n+        final String[] args = new String[]{\n+                \"-v\",\n+                \"--endian\", endianOptVal,\n+                \"--add-modules\", \"java.base\",\n+                \"--output\", \"image-should-not-have-been-created\"\n+        };\n+        final StringWriter jlinkStdout = new StringWriter();\n+        final StringWriter jlinkStderr = new StringWriter();\n+        System.out.println(\"Launching jlink with args: \" + Arrays.toString(args));\n+        final int exitCode = JLINK_TOOL.run(new PrintWriter(jlinkStdout),\n+                new PrintWriter(jlinkStderr), args);\n+        System.out.println(jlinkStdout);\n+        System.err.println(jlinkStderr);\n+        if (exitCode == 0) {\n+            throw new AssertionError(\"jlink command was expected to fail but completed with\" +\n+                    \" exit code: \" + exitCode);\n+        }\n+        \/\/ verify the failure was due to the expected error (message)\n+        if (!jlinkStdout.toString().contains(\"does not match endianness of target platform\")) {\n+            throw new AssertionError(\"jlink process' stderr didn't contain the expected\" +\n+                    \" error message\");\n+        }\n+    }\n+\n+    \/**\n+     * Launches jlink with \"--endian\" option whose value matches the target platform's endianness.\n+     * Asserts that the jlink process successfully creates the image.\n+     *\/\n+    private static void testCorrectEndian() throws Exception {\n+        \/\/ we use a --endian value which matches the current platform\n+        final String endianOptVal = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? \"little\" : \"big\";\n+        final Path imageOutDir = Path.of(\"correct-endian-image\");\n+        final String[] args = new String[]{\n+                \"-v\",\n+                \"--endian\", endianOptVal,\n+                \"--add-modules\", \"java.base\",\n+                \"--output\", imageOutDir.toString()\n+        };\n+        final StringWriter jlinkStdout = new StringWriter();\n+        final StringWriter jlinkStderr = new StringWriter();\n+        System.out.println(\"Launching jlink with args: \" + Arrays.toString(args));\n+        final int exitCode = JLINK_TOOL.run(new PrintWriter(jlinkStdout),\n+                new PrintWriter(jlinkStderr), args);\n+        System.out.println(jlinkStdout);\n+        System.err.println(jlinkStderr);\n+        if (exitCode != 0) {\n+            throw new AssertionError(\"jlink command was expected to succeed but completed with\" +\n+                    \" exit code: \" + exitCode);\n+        }\n+        \/\/ trivially verify <image-dir>\/bin\/java exists\n+        final Path javaBinary = OperatingSystem.isWindows()\n+                ? Path.of(imageOutDir.toString(), \"bin\", \"java.exe\")\n+                : Path.of(imageOutDir.toString(), \"bin\", \"java\");\n+        if (!Files.exists(javaBinary)) {\n+            throw new AssertionError(\"jlink image generation was expected to create \"\n+                    + javaBinary + \", but that file is missing\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLinkEndianTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.tools.jlink.internal.Platform;\n@@ -64,1 +65,2 @@\n-        DefaultImageBuilder writer = new DefaultImageBuilder(root, Collections.emptyMap());\n+        DefaultImageBuilder writer = new DefaultImageBuilder(root, Collections.emptyMap(),\n+                Platform.runtime());\n","filename":"test\/jdk\/tools\/jlink\/ResourceDuplicateCheckTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-                    new String[]{\"java.smartcardio\", \"jdk.crypto.ec\"},\n+                    new String[]{\"java.smartcardio\", \"jdk.crypto.cryptoki\"},\n@@ -83,1 +83,1 @@\n-                    new String[]{\"java.smartcardio\", \"jdk.crypto.ec\"},\n+                    new String[]{\"java.smartcardio\", \"jdk.crypto.cryptoki\"},\n@@ -108,1 +108,1 @@\n-                    new String[]{\"jdk.crypto.ec\"},\n+                    new String[]{\"jdk.crypto.cryptoki\"},\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/JLinkOptionsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 6994753 7123582 8305950\n+ * @bug 6994753 7123582 8305950 8281658 8310201\n@@ -70,0 +70,10 @@\n+    private static final String LOCALE_SUMMARY_SETTINGS =\n+                \"Locale settings summary:\";\n+    private static final String AVAILABLE_LOCALES = \"available locales\";\n+    private static final String SEC_PROPS_SETTINGS = \"Security properties:\";\n+    private static final String SEC_SUMMARY_PROPS_SETTINGS =\n+                \"Security settings summary:\";\n+    private static final String SEC_PROVIDER_SETTINGS =\n+                \"Security provider static configuration:\";\n+    private static final String SEC_TLS_SETTINGS = \"Security TLS configuration\";\n+    private static final String BAD_SEC_OPTION_MSG = \"Unrecognized security subcommand\";\n@@ -77,1 +87,8 @@\n-        checkContains(tr, LOCALE_SETTINGS);\n+        checkNotContains(tr, LOCALE_SETTINGS);\n+        checkNotContains(tr, AVAILABLE_LOCALES);\n+        checkContains(tr, LOCALE_SUMMARY_SETTINGS);\n+        \/\/ no verbose security settings unless \"security\" used\n+        checkNotContains(tr, SEC_PROPS_SETTINGS);\n+        checkContains(tr, SEC_SUMMARY_PROPS_SETTINGS);\n+        checkContains(tr, SEC_PROVIDER_SETTINGS);\n+        checkContains(tr, SEC_TLS_SETTINGS);\n@@ -144,0 +161,2 @@\n+        checkContains(tr, AVAILABLE_LOCALES);\n+        checkNotContains(tr, LOCALE_SUMMARY_SETTINGS);\n@@ -147,0 +166,48 @@\n+    static void runTestOptionSecurity() throws IOException {\n+        TestResult tr = doExec(javaCmd, \"-XshowSettings:security\");\n+        checkNotContains(tr, VM_SETTINGS);\n+        checkNotContains(tr, PROP_SETTINGS);\n+        checkContains(tr, SEC_PROPS_SETTINGS);\n+        checkContains(tr, SEC_PROVIDER_SETTINGS);\n+        checkContains(tr, SEC_TLS_SETTINGS);\n+    }\n+\n+    static void runTestOptionSecurityProps() throws IOException {\n+        TestResult tr = doExec(javaCmd, \"-XshowSettings:security:properties\");\n+        checkContains(tr, SEC_PROPS_SETTINGS);\n+        checkNotContains(tr, SEC_PROVIDER_SETTINGS);\n+        checkNotContains(tr, SEC_TLS_SETTINGS);\n+        \/\/ test a well known property for sanity\n+        checkContains(tr, \"keystore.type=pkcs12\");\n+    }\n+\n+    static void runTestOptionSecurityProv() throws IOException {\n+        TestResult tr = doExec(javaCmd, \"-XshowSettings:security:providers\");\n+        checkNotContains(tr, SEC_PROPS_SETTINGS);\n+        checkContains(tr, SEC_PROVIDER_SETTINGS);\n+        checkNotContains(tr, SEC_TLS_SETTINGS);\n+        \/\/ test a well known Provider for sanity\n+        checkContains(tr, \"Provider name: SUN\");\n+        \/\/ test for a well known alias (SunJCE: AlgorithmParameterGenerator.DiffieHellman)\n+        checkContains(tr, \"aliases: [1.2.840.113549.1.3.1, \" +\n+                \"DH, OID.1.2.840.113549.1.3.1]\");\n+    }\n+\n+    static void runTestOptionSecurityTLS() throws IOException {\n+        TestResult tr = doExec(javaCmd, \"-XshowSettings:security:tls\");\n+        checkNotContains(tr, SEC_PROPS_SETTINGS);\n+        checkNotContains(tr, SEC_PROVIDER_SETTINGS);\n+        checkContains(tr, SEC_TLS_SETTINGS);\n+        \/\/ test a well known TLS config for sanity\n+        checkContains(tr, \"TLSv1.2\");\n+    }\n+\n+    \/\/ ensure error message is printed when unrecognized option used\n+    static void runTestOptionBadSecurityOption() throws IOException {\n+        TestResult tr = doExec(javaCmd, \"-XshowSettings:security:bad\");\n+        checkContains(tr, BAD_SEC_OPTION_MSG);\n+        \/\/ we print all security settings in such scenario\n+        checkNotContains(tr, SEC_PROPS_SETTINGS);\n+        checkNotContains(tr, SEC_PROVIDER_SETTINGS);\n+        checkNotContains(tr, SEC_TLS_SETTINGS);\n+    }\n@@ -184,0 +251,5 @@\n+        runTestOptionSecurity();\n+        runTestOptionSecurityProps();\n+        runTestOptionSecurityProv();\n+        runTestOptionSecurityTLS();\n+        runTestOptionBadSecurityOption();\n","filename":"test\/jdk\/tools\/launcher\/Settings.java","additions":74,"deletions":2,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+        map.put(\"vm.jvmci.enabled\", this::vmJvmciEnabled);\n@@ -125,0 +126,4 @@\n+        \/\/ jdk.hasLibgraal is true if the libgraal shared library file is present\n+        map.put(\"jdk.hasLibgraal\", this::hasLibgraal);\n+        \/\/ vm.libgraal.enabled is true if libgraal is used as JIT\n+        map.put(\"vm.libgraal.enabled\", this::isLibgraalEnabled);\n@@ -269,0 +274,14 @@\n+\n+    \/**\n+     * @return true if JVMCI is enabled\n+     *\/\n+    protected String vmJvmciEnabled() {\n+        \/\/ builds with jvmci have this flag\n+        if (\"false\".equals(vmJvmci())) {\n+            return \"false\";\n+        }\n+\n+        return \"\" + Compiler.isJVMCIEnabled();\n+    }\n+\n+\n@@ -475,0 +494,18 @@\n+    \/**\n+     * Check if the libgraal shared library file is present.\n+     *\n+     * @return true if the libgraal shared library file is present.\n+     *\/\n+    protected String hasLibgraal() {\n+        return \"\" + WB.hasLibgraal();\n+    }\n+\n+    \/**\n+     * Check if libgraal is used as JIT compiler.\n+     *\n+     * @return true if libgraal is used as JIT compiler.\n+     *\/\n+    protected String isLibgraalEnabled() {\n+        return \"\" + Compiler.isLibgraalEnabled();\n+    }\n+\n@@ -698,0 +735,1 @@\n+        Collections.sort(lines);\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8312163\n+ * @summary Crash in dominance check when compiling unnamed patterns\n+ * @enablePreview\n+ * @compile\/fail\/ref=T8312163.out -XDrawDiagnostics T8312163.java\n+ *\/\n+public class T8312163 {\n+    sealed interface A permits B {}\n+    record B() implements A {}\n+\n+    record Rec(A a, A b) {}\n+\n+    public void test(Rec r)\n+    {\n+        switch (r) {\n+            case Rec(_, _): break;\n+            case Rec(_, B()):   \/\/ dominated\n+        }\n+\n+        switch (r) {\n+            case Rec(_, B()): break;\n+            case Rec(_, _):\n+        }\n+\n+        switch (r) {\n+            case Rec(_, _): break;\n+            case Rec(_, A a):   \/\/ dominated\n+        }\n+\n+        switch (r) {\n+            case Rec(_, A a): break;\n+            case Rec(_, _): \/\/ dominated\n+        }\n+\n+        \/\/ duplicated unnamed patterns with unnamed pattern variables for reference\n+        switch (r) {\n+            case Rec(var _, var _): break;\n+            case Rec(var _, B()):   \/\/ dominated\n+        }\n+\n+        switch (r) {\n+            case Rec(var _, B()): break;\n+            case Rec(var _, var _):\n+        }\n+\n+        switch (r) {\n+            case Rec(var _, var _): break;\n+            case Rec(var _, A a):   \/\/ dominated\n+        }\n+\n+        switch (r) {\n+            case Rec(var _, A a): break;\n+            case Rec(var _, var _): \/\/ dominated\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8312163.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+T8312163.java:18:18: compiler.err.pattern.dominated\n+T8312163.java:28:18: compiler.err.pattern.dominated\n+T8312163.java:33:18: compiler.err.pattern.dominated\n+T8312163.java:39:18: compiler.err.pattern.dominated\n+T8312163.java:49:18: compiler.err.pattern.dominated\n+T8312163.java:54:18: compiler.err.pattern.dominated\n+- compiler.note.preview.filename: T8312163.java, DEFAULT\n+- compiler.note.preview.recompile\n+6 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/T8312163.out","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.cant.implement.non.atomic\n+\/\/ key: compiler.err.cant.implement.interface\n@@ -26,1 +26,1 @@\n-class CantImplementNonAtomic implements NonAtomic {\n+class CantImplementInterface implements LooselyConsistentValue {\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantImplementInterface.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantImplementNonAtomic.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093\n@@ -2423,0 +2423,28 @@\n+    @Test \/\/JDK-8312093\n+    void testJavadoc() throws IOException {\n+        String code = \"\"\"\n+                      public class Test {\n+                          \/***\/\n+                          void main() {\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,\n+                null, Arrays.asList(new MyFileObject(code)));\n+        Trees trees = Trees.instance(ct);\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        new TreePathScanner<Void, Void>() {\n+            @Override\n+            public Void visitMethod(MethodTree node, Void p) {\n+                if (!node.getName().contentEquals(\"main\")) {\n+                    return null;\n+                }\n+                String comment = trees.getDocComment(getCurrentPath());\n+                assertEquals(\"Expecting empty comment\", \"\", comment);\n+                return null;\n+            }\n+        }.scan(cut, null);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815\n@@ -1543,1 +1543,1 @@\n-    private static final int NESTING_CONSTANT = 5;\n+    private static final int NESTING_CONSTANT = 4;\n@@ -1947,0 +1947,48 @@\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8311038\n+    public void testReducesTooMuch(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   void test(Rec r) {\n+                       switch (r) {\n+                           case Rec(String s) ->\n+                               System.out.println(\"I2\" + s.toString());\n+                           case Rec(Object o) ->\n+                               System.out.println(\"I2\");\n+                       }\n+                   }\n+                   record Rec(Object o) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8311815:\n+    public void testAmbiguousRecordUsage(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                 record Pair(I i1, I i2) {}\n+                 sealed interface I {}\n+                 record C() implements I {}\n+                 record D() implements I {}\n+\n+                 void exhaustinvenessWithInterface(Pair pairI) {\n+                   switch (pairI) {\n+                     case Pair(D fst, C snd) -> {\n+                     }\n+                     case Pair(C fst, C snd) -> {\n+                     }\n+                     case Pair(C fst, I snd) -> {\n+                     }\n+                     case Pair(D fst, D snd) -> {\n+                     }\n+                   }\n+                 }\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8300543 8309336\n+ * @bug 8300543 8309336 8311825\n@@ -72,0 +72,24 @@\n+    int testQualifiedDuplicate1(Object o) {\n+        return switch(o) {\n+            case E1.A -> 1;\n+            case E1.A -> 2;\n+            default -> -1;\n+        };\n+    }\n+\n+    int testQualifiedDuplicate2(E1 e) {\n+        return switch(e) {\n+            case A -> 1;\n+            case E1.A -> 2;\n+            default -> -1;\n+        };\n+    }\n+\n+    int testQualifiedDuplicate3(E1 e) {\n+        return switch(e) {\n+            case E1.A -> 1;\n+            case A -> 2;\n+            default -> -1;\n+        };\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualifiedErrors.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -11,1 +11,4 @@\n-10 errors\n+EnumSwitchQualifiedErrors.java:75:18: compiler.err.duplicate.case.label\n+EnumSwitchQualifiedErrors.java:83:18: compiler.err.duplicate.case.label\n+EnumSwitchQualifiedErrors.java:91:18: compiler.err.duplicate.case.label\n+13 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/EnumSwitchQualifiedErrors.out","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1050,2 +1050,2 @@\n-    public void testImplementingNonAtomic() {\n-        assertFail(\"compiler.err.cant.implement.non.atomic\",\n+    public void testImplementingLooselyConsistentValue() {\n+        assertFail(\"compiler.err.cant.implement.interface\",\n@@ -1053,1 +1053,1 @@\n-                class V implements NonAtomic {}\n+                class V implements LooselyConsistentValue {}\n@@ -1056,1 +1056,1 @@\n-        assertFail(\"compiler.err.cant.implement.non.atomic\",\n+        assertFail(\"compiler.err.cant.implement.interface\",\n@@ -1058,1 +1058,1 @@\n-                value class V implements NonAtomic {}\n+                value class V implements LooselyConsistentValue {}\n@@ -1063,1 +1063,1 @@\n-                abstract class V implements NonAtomic {}\n+                abstract class V implements LooselyConsistentValue {}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -320,0 +320,3 @@\n+\n+  \/\/ Determines if the libgraal shared library file is present.\n+  public native boolean hasLibgraal();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,0 +91,19 @@\n+    \/**\n+     * Check if libgraal is used as JIT compiler.\n+     *\n+     * libraal is enabled if isGraalEnabled is true and:\n+     * - UseJVMCINativeLibrary flag is true\n+     *\n+     * @return true if libgraal is used as JIT compiler.\n+     *\/\n+    public static boolean isLibgraalEnabled() {\n+        if (!isGraalEnabled()) {\n+            return false;\n+        }\n+        Boolean useJvmciNativeLibrary = WB.getBooleanVMFlag(\"UseJVMCINativeLibrary\");\n+        if (useJvmciNativeLibrary == null || !useJvmciNativeLibrary) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/code\/Compiler.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import jdk.internal.classfile.Classfile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n+\n+\/**\n+ * A benchmark ensuring that var and method handle lazy initialization are not\n+ * too slow compared to eager initialization.\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 10, warmups = 5, jvmArgsAppend = {\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\"\n+})\n+public class LazyStaticColdStart {\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    private Class<?> targetClass;\n+\n+    \/**\n+     * Ensures non-initialized targetClass is used and initializes the lazy\/non-lazy handles\n+     * to prevent further creation costs. (see static initializer block comments)\n+     *\/\n+    @Setup(Level.Iteration)\n+    public void setup() throws Throwable {\n+        class Holder {\n+            static final ClassDesc describedClass = LazyStaticColdStart.class.describeConstable().orElseThrow().nested(\"Data\");\n+            static final ClassDesc CD_ThreadLocalRandom = ThreadLocalRandom.class.describeConstable().orElseThrow();\n+            static final ClassDesc CD_Blackhole = Blackhole.class.describeConstable().orElseThrow();\n+            static final MethodTypeDesc MTD_void_long = MethodTypeDesc.of(CD_void, CD_long);\n+            static final MethodTypeDesc MTD_ThreadLocalRandom = MethodTypeDesc.of(CD_ThreadLocalRandom);\n+            static final MethodTypeDesc MTD_long = MethodTypeDesc.of(CD_long);\n+            static final byte[] classBytes = Classfile.of().build(describedClass, clb -> {\n+                clb.withField(\"v\", CD_long, ACC_STATIC);\n+                clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                    cob.constantInstruction(100L);\n+                    cob.invokestatic(CD_Blackhole, \"consumeCPU\", MTD_void_long);\n+                    cob.invokestatic(CD_ThreadLocalRandom, \"current\", MTD_ThreadLocalRandom);\n+                    cob.invokevirtual(CD_ThreadLocalRandom, \"nextLong\", MTD_long);\n+                    cob.putstatic(describedClass, \"v\", CD_long);\n+                    cob.return_();\n+                });\n+            });\n+\n+            \/*\n+             * This static initializer eliminates overheads with initializing VarHandle\/\n+             * MethodHandle infrastructure that's not done in startup, so\n+             * we are only measuring new Class initialization costs.\n+             *\/\n+            static {\n+                class AnotherLazy {\n+                    static long f;\n+                }\n+                try {\n+                    LOOKUP.findStaticVarHandle(AnotherLazy.class, \"f\", long.class); \/\/ lazy static VH\n+                    LOOKUP.findStaticGetter(AnotherLazy.class, \"f\", long.class); \/\/ lazy static MH\n+                    AnotherLazy.f = 5L; \/\/ initialize class\n+                    LOOKUP.findStaticVarHandle(AnotherLazy.class, \"f\", long.class); \/\/ static VH\n+                    LOOKUP.findStaticGetter(AnotherLazy.class, \"f\", long.class); \/\/ static MH\n+                } catch (RuntimeException | Error e) {\n+                    throw e;\n+                } catch (Throwable ex) {\n+                    throw new ExceptionInInitializerError(ex);\n+                }\n+            }\n+        }\n+        targetClass = LOOKUP.defineHiddenClass(Holder.classBytes, false).lookupClass();\n+    }\n+\n+    @Benchmark\n+    public VarHandle varHandleCreateLazy() throws Throwable {\n+        return LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public VarHandle varHandleCreateEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public long varHandleInitializeCallLazy() throws Throwable {\n+        return (long) LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class).get();\n+    }\n+\n+    @Benchmark\n+    public long varHandleInitializeCallEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return (long) LOOKUP.findStaticVarHandle(targetClass, \"v\", long.class).get();\n+    }\n+\n+    @Benchmark\n+    public MethodHandle methodHandleCreateLazy() throws Throwable {\n+        return LOOKUP.findStaticGetter(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public MethodHandle methodHandleCreateEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return LOOKUP.findStaticGetter(targetClass, \"v\", long.class);\n+    }\n+\n+    @Benchmark\n+    public long methodHandleInitializeCallLazy() throws Throwable {\n+        return (long) LOOKUP.findStaticGetter(targetClass, \"v\", long.class).invokeExact();\n+    }\n+\n+    @Benchmark\n+    public long methodHandleInitializeCallEager() throws Throwable {\n+        LOOKUP.ensureInitialized(targetClass);\n+        return (long) LOOKUP.findStaticGetter(targetClass, \"v\", long.class).invokeExact();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/LazyStaticColdStart.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * A benchmark testing lazy static var handle vs regular static var handle,\n+ * to ensure the lazy static var handle doesn't have too much post-initialization\n+ * invocation penalties.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(3)\n+public class VarHandleLazyStaticInvocation {\n+\n+    static final VarHandle initialized;\n+    static final VarHandle lazy;\n+    static long longField;\n+\n+    static {\n+        try {\n+            lazy = MethodHandles.lookup().findStaticVarHandle(Data.class, \"longField\", long.class);\n+            initialized = MethodHandles.lookup().findStaticVarHandle(VarHandleLazyStaticInvocation.class, \"longField\", long.class);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+    static class Data {\n+        static long longField;\n+    }\n+\n+    @Benchmark\n+    public long lazyInvocation() {\n+        lazy.set((long) ThreadLocalRandom.current().nextLong());\n+        return (long) lazy.get();\n+    }\n+\n+    @Benchmark\n+    public long initializedInvocation() {\n+        initialized.set((long) ThreadLocalRandom.current().nextLong());\n+        return (long) initialized.get();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/VarHandleLazyStaticInvocation.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.random;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests java.util.random.RandomGenerator's implementations of nextExponential and nextGaussian\n+ *\/\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class RandomGeneratorExponentialGaussian {\n+\n+    RandomGenerator randomGenerator;\n+\n+    @Param({\"L64X128MixRandom\", \"L64X1024MixRandom\"})\n+    String randomGeneratorName;\n+\n+    @Param({\"false\",\"true\"})\n+    boolean fixedSeed;\n+\n+    double[] buffer;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    @Setup\n+    public void setup() {\n+        buffer = new double[size];\n+        RandomGeneratorFactory factory = RandomGeneratorFactory.of(randomGeneratorName);\n+        randomGenerator = fixedSeed ? factory.create(randomGeneratorName.hashCode()) : factory.create();\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode({Mode.SampleTime, Mode.AverageTime})\n+    public double testNextGaussian() {\n+        return randomGenerator.nextGaussian();\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public double[] testFillBufferWithNextGaussian() {\n+        for (int i = 0; i < size; i++) buffer[i] = randomGenerator.nextGaussian();\n+        return buffer;\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode({Mode.SampleTime, Mode.AverageTime})\n+    public double testNextExponential() {\n+        return randomGenerator.nextExponential();\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public double[] testFillBufferWithNextExponential() {\n+        for (int i = 0; i < size; i++) buffer[i] = randomGenerator.nextExponential();\n+        return buffer;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/random\/RandomGeneratorExponentialGaussian.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.java.util;\n+package org.openjdk.bench.java.util.random;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/random\/RandomGeneratorNext.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/RandomGeneratorNext.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.java.util;\n+package org.openjdk.bench.java.util.random;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/random\/RandomNext.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/RandomNext.java","status":"renamed"}]}