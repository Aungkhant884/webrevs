{"files":[{"patch":"@@ -462,0 +462,3 @@\n+     * To obtain a {@code Class} object for a named primitive type\n+     * such as {@code int} or {@code long} use {@link\n+     * #forPrimitiveName(String)}.\n@@ -802,0 +805,35 @@\n+    \/**\n+     * {@return the {@code Class} object associated with the\n+     * {@linkplain #isPrimitive() primitive type} of the given name}\n+     * If the argument is not the name of a primitive type, {@code\n+     * null} is returned.\n+     *\n+     * @param primitiveName the name of the primitive type to find\n+     *\n+     * @throws NullPointerException if the argument is {@code null}\n+     *\n+     * @jls 4.2 Primitive Types and Values\n+     * @jls 15.8.2 Class Literals\n+     * @since 22\n+     *\/\n+    public static Class<?> forPrimitiveName(String primitiveName) {\n+        return switch(primitiveName) {\n+        \/\/ Integral types\n+        case \"int\"     -> int.class;\n+        case \"long\"    -> long.class;\n+        case \"short\"   -> short.class;\n+        case \"char\"    -> char.class;\n+        case \"byte\"    -> byte.class;\n+\n+        \/\/ Floating-point types\n+        case \"float\"   -> float.class;\n+        case \"double\"  -> double.class;\n+\n+        \/\/ Other types\n+        case \"boolean\" -> boolean.class;\n+        case \"void\"    -> void.class;\n+\n+        default        -> null;\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1776,0 +1776,2 @@\n+                                    } else if (!constants.add(enumSym)) {\n+                                        log.error(label.pos(), Errors.DuplicateCaseLabel);\n@@ -1807,0 +1809,2 @@\n+                                    } else if (!constants.add(s)) {\n+                                        log.error(label.pos(), Errors.DuplicateCaseLabel);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5027,2 +5027,4 @@\n-            if (currentPattern instanceof JCBindingPattern) {\n-                return existingPattern instanceof JCBindingPattern;\n+            if (currentPattern instanceof JCBindingPattern ||\n+                currentPattern instanceof JCAnyPattern) {\n+                return existingPattern instanceof JCBindingPattern ||\n+                       existingPattern instanceof JCAnyPattern;\n@@ -5030,1 +5032,2 @@\n-                if (existingPattern instanceof JCBindingPattern) {\n+                if (existingPattern instanceof JCBindingPattern ||\n+                    existingPattern instanceof JCAnyPattern) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -778,1 +778,1 @@\n-            List<PatternDescription> patterns = List.from(patternSet);\n+            Set<PatternDescription> patterns = patternSet;\n@@ -782,1 +782,1 @@\n-                    List<PatternDescription> updatedPatterns;\n+                    Set<PatternDescription> updatedPatterns;\n@@ -786,1 +786,2 @@\n-                    repeat = updatedPatterns != patterns;\n+                    updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                    repeat = !updatedPatterns.equals(patterns);\n@@ -799,1 +800,1 @@\n-        private boolean checkCovered(Type seltype, List<PatternDescription> patterns) {\n+        private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n@@ -835,1 +836,1 @@\n-        private List<PatternDescription> reduceBindingPatterns(Type selectorType, List<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n@@ -843,1 +844,0 @@\n-                    Set<PatternDescription> toRemove = new HashSet<>();\n@@ -849,0 +849,2 @@\n+                        clazz.complete();\n+\n@@ -874,1 +876,0 @@\n-                                    boolean reduces = false;\n@@ -891,1 +892,0 @@\n-                                            reduces = true;\n@@ -894,4 +894,0 @@\n-\n-                                    if (reduces) {\n-                                        bindings.append(pdOther);\n-                                    }\n@@ -902,1 +898,0 @@\n-                                toRemove.addAll(bindings);\n@@ -908,8 +903,4 @@\n-                    if (!toAdd.isEmpty() || !toRemove.isEmpty()) {\n-                        for (PatternDescription pd : toRemove) {\n-                            patterns = List.filter(patterns, pd);\n-                        }\n-                        for (PatternDescription pd : toAdd) {\n-                            patterns = patterns.prepend(pd);\n-                        }\n-                        return patterns;\n+                    if (!toAdd.isEmpty()) {\n+                        Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n+                        newPatterns.addAll(toAdd);\n+                        return newPatterns;\n@@ -931,0 +922,2 @@\n+                current.complete();\n+\n@@ -957,1 +950,1 @@\n-        private List<PatternDescription> reduceNestedPatterns(List<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns) {\n@@ -976,0 +969,1 @@\n+                Set<RecordPattern> current = new HashSet<>(e.getValue());\n@@ -982,1 +976,1 @@\n-                            e.getValue()\n+                            current\n@@ -1017,1 +1011,1 @@\n-                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(List.collector());\n+                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n@@ -1021,0 +1015,1 @@\n+                            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n@@ -1023,11 +1018,2 @@\n-                            if (nestedPatterns != updatedPatterns) {\n-                                ListBuffer<PatternDescription> result = new ListBuffer<>();\n-                                Set<PatternDescription> toRemove = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-                                toRemove.addAll(join);\n-\n-                                for (PatternDescription p : patterns) {\n-                                    if (!toRemove.contains(p)) {\n-                                        result.append(p);\n-                                    }\n-                                }\n+                            if (!nestedPatterns.equals(updatedPatterns)) {\n+                                current.removeAll(join);\n@@ -1039,1 +1025,1 @@\n-                                    result.append(new RecordPattern(rpOne.recordType(),\n+                                    current.add(new RecordPattern(rpOne.recordType(),\n@@ -1043,1 +1029,0 @@\n-                                return result.toList();\n@@ -1048,0 +1033,7 @@\n+\n+                if (!current.equals(new HashSet<>(e.getValue()))) {\n+                    Set<PatternDescription> result = new HashSet<>(patterns);\n+                    result.removeAll(e.getValue());\n+                    result.addAll(current);\n+                    return result;\n+                }\n@@ -1057,2 +1049,2 @@\n-        private List<PatternDescription> reduceRecordPatterns(List<PatternDescription> patterns) {\n-            var newPatterns = new ListBuffer<PatternDescription>();\n+        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n+            var newPatterns = new HashSet<PatternDescription>();\n@@ -1064,1 +1056,1 @@\n-                        newPatterns.append(reducedPattern);\n+                        newPatterns.add(reducedPattern);\n@@ -1069,1 +1061,1 @@\n-                newPatterns.append(pd);\n+                newPatterns.add(pd);\n@@ -1071,2 +1063,2 @@\n-            return modified ? newPatterns.toList() : patterns;\n-                }\n+            return modified ? newPatterns : patterns;\n+        }\n@@ -1104,0 +1096,17 @@\n+        private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n+            Set<Symbol> existingBindings = patterns.stream()\n+                                                   .filter(pd -> pd instanceof BindingPattern)\n+                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                                   .collect(Collectors.toSet());\n+            Set<PatternDescription> result = new HashSet<>(patterns);\n+\n+            for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n+                PatternDescription pd = it.next();\n+                if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n+                    it.remove();\n+                }\n+            }\n+\n+            return result;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":52,"deletions":43,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -915,0 +915,1 @@\n+            checkSourceLevel(Feature.UNNAMED_VARIABLES);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}