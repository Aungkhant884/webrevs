{"files":[{"patch":"@@ -443,1 +443,1 @@\n-                \"--with-macosx-version-max=10.9.0\",\n+                \"--with-macosx-version-max=10.12.00\",\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1247,0 +1247,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1454,1 +1454,1 @@\n-  if (!is_c1_or_interpreter_only()) {\n+  if (!CompilerConfig::is_c1_only_no_aot_or_jvmci()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,    64 TIERED_ONLY(+64)); \/\/ Tiered compilation has large code-entry alignment.\n+define_pd_global(uintx, CodeCacheSegmentSize,    64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1358,1 +1358,1 @@\n-      __ ldrw(r16, Address(a, rscratch2, Address::lsl(exact_log2(size))));\n+      __ ldrw(temp, Address(a, rscratch2, Address::lsl(exact_log2(size))));\n@@ -1361,1 +1361,1 @@\n-    __ add(rscratch2, rscratch2, size);\n+    __ add(rscratch2, rscratch2, 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -599,4 +599,1 @@\n-void TemplateInterpreterGenerator::generate_counter_incr(\n-        Label* overflow,\n-        Label* profile_method,\n-        Label* profile_method_continue) {\n+void TemplateInterpreterGenerator::generate_counter_incr(Label* overflow) {\n@@ -605,69 +602,12 @@\n-  if (TieredCompilation) {\n-    int increment = InvocationCounter::count_increment;\n-    Label no_mdo;\n-    if (ProfileInterpreter) {\n-      \/\/ Are we profiling?\n-      __ ldr(r0, Address(rmethod, Method::method_data_offset()));\n-      __ cbz(r0, no_mdo);\n-      \/\/ Increment counter in the MDO\n-      const Address mdo_invocation_counter(r0, in_bytes(MethodData::invocation_counter_offset()) +\n-                                                in_bytes(InvocationCounter::counter_offset()));\n-      const Address mask(r0, in_bytes(MethodData::invoke_mask_offset()));\n-      __ increment_mask_and_jump(mdo_invocation_counter, increment, mask, rscratch1, rscratch2, false, Assembler::EQ, overflow);\n-      __ b(done);\n-    }\n-    __ bind(no_mdo);\n-    \/\/ Increment counter in MethodCounters\n-    const Address invocation_counter(rscratch2,\n-                  MethodCounters::invocation_counter_offset() +\n-                  InvocationCounter::counter_offset());\n-    __ get_method_counters(rmethod, rscratch2, done);\n-    const Address mask(rscratch2, in_bytes(MethodCounters::invoke_mask_offset()));\n-    __ increment_mask_and_jump(invocation_counter, increment, mask, rscratch1, r1, false, Assembler::EQ, overflow);\n-    __ bind(done);\n-  } else { \/\/ not TieredCompilation\n-    const Address backedge_counter(rscratch2,\n-                  MethodCounters::backedge_counter_offset() +\n-                  InvocationCounter::counter_offset());\n-    const Address invocation_counter(rscratch2,\n-                  MethodCounters::invocation_counter_offset() +\n-                  InvocationCounter::counter_offset());\n-\n-    __ get_method_counters(rmethod, rscratch2, done);\n-\n-    if (ProfileInterpreter) { \/\/ %%% Merge this into MethodData*\n-      __ ldrw(r1, Address(rscratch2, MethodCounters::interpreter_invocation_counter_offset()));\n-      __ addw(r1, r1, 1);\n-      __ strw(r1, Address(rscratch2, MethodCounters::interpreter_invocation_counter_offset()));\n-    }\n-    \/\/ Update standard invocation counters\n-    __ ldrw(r1, invocation_counter);\n-    __ ldrw(r0, backedge_counter);\n-\n-    __ addw(r1, r1, InvocationCounter::count_increment);\n-    __ andw(r0, r0, InvocationCounter::count_mask_value);\n-\n-    __ strw(r1, invocation_counter);\n-    __ addw(r0, r0, r1);                \/\/ add both counters\n-\n-    \/\/ profile_method is non-null only for interpreted method so\n-    \/\/ profile_method != NULL == !native_call\n-\n-    if (ProfileInterpreter && profile_method != NULL) {\n-      \/\/ Test to see if we should create a method data oop\n-      __ ldr(rscratch2, Address(rmethod, Method::method_counters_offset()));\n-      __ ldrw(rscratch2, Address(rscratch2, in_bytes(MethodCounters::interpreter_profile_limit_offset())));\n-      __ cmpw(r0, rscratch2);\n-      __ br(Assembler::LT, *profile_method_continue);\n-\n-      \/\/ if no method data exists, go to profile_method\n-      __ test_method_data_pointer(rscratch2, *profile_method);\n-    }\n-\n-    {\n-      __ ldr(rscratch2, Address(rmethod, Method::method_counters_offset()));\n-      __ ldrw(rscratch2, Address(rscratch2, in_bytes(MethodCounters::interpreter_invocation_limit_offset())));\n-      __ cmpw(r0, rscratch2);\n-      __ br(Assembler::HS, *overflow);\n-    }\n-    __ bind(done);\n+  int increment = InvocationCounter::count_increment;\n+  Label no_mdo;\n+  if (ProfileInterpreter) {\n+    \/\/ Are we profiling?\n+    __ ldr(r0, Address(rmethod, Method::method_data_offset()));\n+    __ cbz(r0, no_mdo);\n+    \/\/ Increment counter in the MDO\n+    const Address mdo_invocation_counter(r0, in_bytes(MethodData::invocation_counter_offset()) +\n+                                              in_bytes(InvocationCounter::counter_offset()));\n+    const Address mask(r0, in_bytes(MethodData::invoke_mask_offset()));\n+    __ increment_mask_and_jump(mdo_invocation_counter, increment, mask, rscratch1, rscratch2, false, Assembler::EQ, overflow);\n+    __ b(done);\n@@ -675,0 +615,9 @@\n+  __ bind(no_mdo);\n+  \/\/ Increment counter in MethodCounters\n+  const Address invocation_counter(rscratch2,\n+                MethodCounters::invocation_counter_offset() +\n+                InvocationCounter::counter_offset());\n+  __ get_method_counters(rmethod, rscratch2, done);\n+  const Address mask(rscratch2, in_bytes(MethodCounters::invoke_mask_offset()));\n+  __ increment_mask_and_jump(invocation_counter, increment, mask, rscratch1, r1, false, Assembler::EQ, overflow);\n+  __ bind(done);\n@@ -1215,1 +1164,1 @@\n-    generate_counter_incr(&invocation_counter_overflow, NULL, NULL);\n+    generate_counter_incr(&invocation_counter_overflow);\n@@ -1659,8 +1608,1 @@\n-  Label profile_method;\n-  Label profile_method_continue;\n-    generate_counter_incr(&invocation_counter_overflow,\n-                          &profile_method,\n-                          &profile_method_continue);\n-    if (ProfileInterpreter) {\n-      __ bind(profile_method_continue);\n-    }\n+    generate_counter_incr(&invocation_counter_overflow);\n@@ -1719,9 +1661,0 @@\n-    if (ProfileInterpreter) {\n-      \/\/ We have decided to profile this method in the interpreter\n-      __ bind(profile_method);\n-      __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));\n-      __ set_method_data_pointer_for_bcp();\n-      \/\/ don't think we need this\n-      __ get_method(r1);\n-      __ b(profile_method_continue);\n-    }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":24,"deletions":91,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -1876,1 +1876,0 @@\n-  Label profile_method;\n@@ -1903,22 +1902,12 @@\n-    if (TieredCompilation) {\n-      Label no_mdo;\n-      int increment = InvocationCounter::count_increment;\n-      if (ProfileInterpreter) {\n-        \/\/ Are we profiling?\n-        __ ldr(r1, Address(rmethod, in_bytes(Method::method_data_offset())));\n-        __ cbz(r1, no_mdo);\n-        \/\/ Increment the MDO backedge counter\n-        const Address mdo_backedge_counter(r1, in_bytes(MethodData::backedge_counter_offset()) +\n-                                           in_bytes(InvocationCounter::counter_offset()));\n-        const Address mask(r1, in_bytes(MethodData::backedge_mask_offset()));\n-        __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,\n-                                   r0, rscratch1, false, Assembler::EQ,\n-                                   UseOnStackReplacement ? &backedge_counter_overflow : &dispatch);\n-        __ b(dispatch);\n-      }\n-      __ bind(no_mdo);\n-      \/\/ Increment backedge counter in MethodCounters*\n-      __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));\n-      const Address mask(rscratch1, in_bytes(MethodCounters::backedge_mask_offset()));\n-      __ increment_mask_and_jump(Address(rscratch1, be_offset), increment, mask,\n-                                 r0, rscratch2, false, Assembler::EQ,\n+    Label no_mdo;\n+    int increment = InvocationCounter::count_increment;\n+    if (ProfileInterpreter) {\n+      \/\/ Are we profiling?\n+      __ ldr(r1, Address(rmethod, in_bytes(Method::method_data_offset())));\n+      __ cbz(r1, no_mdo);\n+      \/\/ Increment the MDO backedge counter\n+      const Address mdo_backedge_counter(r1, in_bytes(MethodData::backedge_counter_offset()) +\n+                                         in_bytes(InvocationCounter::counter_offset()));\n+      const Address mask(r1, in_bytes(MethodData::backedge_mask_offset()));\n+      __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,\n+                                 r0, rscratch1, false, Assembler::EQ,\n@@ -1926,46 +1915,1 @@\n-    } else { \/\/ not TieredCompilation\n-      \/\/ increment counter\n-      __ ldr(rscratch2, Address(rmethod, Method::method_counters_offset()));\n-      __ ldrw(r0, Address(rscratch2, be_offset));        \/\/ load backedge counter\n-      __ addw(rscratch1, r0, InvocationCounter::count_increment); \/\/ increment counter\n-      __ strw(rscratch1, Address(rscratch2, be_offset));        \/\/ store counter\n-\n-      __ ldrw(r0, Address(rscratch2, inv_offset));    \/\/ load invocation counter\n-      __ andw(r0, r0, (unsigned)InvocationCounter::count_mask_value); \/\/ and the status bits\n-      __ addw(r0, r0, rscratch1);        \/\/ add both counters\n-\n-      if (ProfileInterpreter) {\n-        \/\/ Test to see if we should create a method data oop\n-        __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_profile_limit_offset())));\n-        __ cmpw(r0, rscratch1);\n-        __ br(Assembler::LT, dispatch);\n-\n-        \/\/ if no method data exists, go to profile method\n-        __ test_method_data_pointer(r0, profile_method);\n-\n-        if (UseOnStackReplacement) {\n-          \/\/ check for overflow against w1 which is the MDO taken count\n-          __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));\n-          __ cmpw(r1, rscratch1);\n-          __ br(Assembler::LO, dispatch); \/\/ Intel == Assembler::below\n-\n-          \/\/ When ProfileInterpreter is on, the backedge_count comes\n-          \/\/ from the MethodData*, which value does not get reset on\n-          \/\/ the call to frequency_counter_overflow().  To avoid\n-          \/\/ excessive calls to the overflow routine while the method is\n-          \/\/ being compiled, add a second test to make sure the overflow\n-          \/\/ function is called only once every overflow_frequency.\n-          const int overflow_frequency = 1024;\n-          __ andsw(r1, r1, overflow_frequency - 1);\n-          __ br(Assembler::EQ, backedge_counter_overflow);\n-\n-        }\n-      } else {\n-        if (UseOnStackReplacement) {\n-          \/\/ check for overflow against w0, which is the sum of the\n-          \/\/ counters\n-          __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));\n-          __ cmpw(r0, rscratch1);\n-          __ br(Assembler::HS, backedge_counter_overflow); \/\/ Intel == Assembler::aboveEqual\n-        }\n-      }\n+      __ b(dispatch);\n@@ -1973,0 +1917,7 @@\n+    __ bind(no_mdo);\n+    \/\/ Increment backedge counter in MethodCounters*\n+    __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));\n+    const Address mask(rscratch1, in_bytes(MethodCounters::backedge_mask_offset()));\n+    __ increment_mask_and_jump(Address(rscratch1, be_offset), increment, mask,\n+                               r0, rscratch2, false, Assembler::EQ,\n+                               UseOnStackReplacement ? &backedge_counter_overflow : &dispatch);\n@@ -1984,9 +1935,11 @@\n-  if (UseLoopCounter) {\n-    if (ProfileInterpreter && !TieredCompilation) {\n-      \/\/ Out-of-line code to allocate method data oop.\n-      __ bind(profile_method);\n-      __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));\n-      __ load_unsigned_byte(r1, Address(rbcp, 0));  \/\/ restore target bytecode\n-      __ set_method_data_pointer_for_bcp();\n-      __ b(dispatch);\n-    }\n+  if (UseLoopCounter && UseOnStackReplacement) {\n+    \/\/ invocation counter overflow\n+    __ bind(backedge_counter_overflow);\n+    __ neg(r2, r2);\n+    __ add(r2, r2, rbcp);     \/\/ branch bcp\n+    \/\/ IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)\n+    __ call_VM(noreg,\n+               CAST_FROM_FN_PTR(address,\n+                                InterpreterRuntime::frequency_counter_overflow),\n+               r2);\n+    __ load_unsigned_byte(r1, Address(rbcp, 0));  \/\/ restore target bytecode\n@@ -1994,46 +1947,33 @@\n-    if (UseOnStackReplacement) {\n-      \/\/ invocation counter overflow\n-      __ bind(backedge_counter_overflow);\n-      __ neg(r2, r2);\n-      __ add(r2, r2, rbcp);     \/\/ branch bcp\n-      \/\/ IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)\n-      __ call_VM(noreg,\n-                 CAST_FROM_FN_PTR(address,\n-                                  InterpreterRuntime::frequency_counter_overflow),\n-                 r2);\n-      __ load_unsigned_byte(r1, Address(rbcp, 0));  \/\/ restore target bytecode\n-\n-      \/\/ r0: osr nmethod (osr ok) or NULL (osr not possible)\n-      \/\/ w1: target bytecode\n-      \/\/ r2: scratch\n-      __ cbz(r0, dispatch);     \/\/ test result -- no osr if null\n-      \/\/ nmethod may have been invalidated (VM may block upon call_VM return)\n-      __ ldrb(r2, Address(r0, nmethod::state_offset()));\n-      if (nmethod::in_use != 0)\n-        __ sub(r2, r2, nmethod::in_use);\n-      __ cbnz(r2, dispatch);\n-\n-      \/\/ We have the address of an on stack replacement routine in r0\n-      \/\/ We need to prepare to execute the OSR method. First we must\n-      \/\/ migrate the locals and monitors off of the stack.\n-\n-      __ mov(r19, r0);                             \/\/ save the nmethod\n-\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));\n-\n-      \/\/ r0 is OSR buffer, move it to expected parameter location\n-      __ mov(j_rarg0, r0);\n-\n-      \/\/ remove activation\n-      \/\/ get sender esp\n-      __ ldr(esp,\n-          Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));\n-      \/\/ remove frame anchor\n-      __ leave();\n-      \/\/ Ensure compiled code always sees stack at proper alignment\n-      __ andr(sp, esp, -16);\n-\n-      \/\/ and begin the OSR nmethod\n-      __ ldr(rscratch1, Address(r19, nmethod::osr_entry_point_offset()));\n-      __ br(rscratch1);\n-    }\n+    \/\/ r0: osr nmethod (osr ok) or NULL (osr not possible)\n+    \/\/ w1: target bytecode\n+    \/\/ r2: scratch\n+    __ cbz(r0, dispatch);     \/\/ test result -- no osr if null\n+    \/\/ nmethod may have been invalidated (VM may block upon call_VM return)\n+    __ ldrb(r2, Address(r0, nmethod::state_offset()));\n+    if (nmethod::in_use != 0)\n+      __ sub(r2, r2, nmethod::in_use);\n+    __ cbnz(r2, dispatch);\n+\n+    \/\/ We have the address of an on stack replacement routine in r0\n+    \/\/ We need to prepare to execute the OSR method. First we must\n+    \/\/ migrate the locals and monitors off of the stack.\n+\n+    __ mov(r19, r0);                             \/\/ save the nmethod\n+\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));\n+\n+    \/\/ r0 is OSR buffer, move it to expected parameter location\n+    __ mov(j_rarg0, r0);\n+\n+    \/\/ remove activation\n+    \/\/ get sender esp\n+    __ ldr(esp,\n+        Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+    \/\/ remove frame anchor\n+    __ leave();\n+    \/\/ Ensure compiled code always sees stack at proper alignment\n+    __ andr(sp, esp, -16);\n+\n+    \/\/ and begin the OSR nmethod\n+    __ ldr(rscratch1, Address(r19, nmethod::osr_entry_point_offset()));\n+    __ br(rscratch1);\n@@ -2607,1 +2547,1 @@\n-  if (!is_c1_or_interpreter_only()){\n+  if (!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci()){\n@@ -3325,1 +3265,1 @@\n-  if (!is_c1_or_interpreter_only()) {\n+  if (!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci()) {\n@@ -3413,1 +3353,1 @@\n-  if (!is_c1_or_interpreter_only()) {\n+  if (!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":67,"deletions":127,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -2929,1 +2929,0 @@\n-  assert(patch_code == lir_patch_none, \"Patch code not supported\");\n@@ -2932,0 +2931,1 @@\n+\n@@ -2933,1 +2933,8 @@\n-    __ add_const_optimized(dest->as_pointer_register(), addr->base()->as_pointer_register(), addr->disp());\n+    if (patch_code != lir_patch_none) {\n+      PatchingStub* patch = new PatchingStub(_masm, PatchingStub::access_field_id);\n+      __ load_const32(R0, 0); \/\/ patchable int\n+      __ add(dest->as_pointer_register(), addr->base()->as_pointer_register(), R0);\n+      patching_epilog(patch, patch_code, addr->base()->as_register(), info);\n+    } else {\n+      __ add_const_optimized(dest->as_pointer_register(), addr->base()->as_pointer_register(), addr->disp());\n+    }\n@@ -2935,0 +2942,1 @@\n+    assert(patch_code == lir_patch_none, \"Patch code not supported\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -478,1 +478,4 @@\n-void InterpreterMacroAssembler::load_resolved_reference_at_index(Register result, Register index, Label *L_handle_null) {\n+\/\/ Kills:\n+\/\/   - index\n+void InterpreterMacroAssembler::load_resolved_reference_at_index(Register result, Register index, Register tmp1,\n+                                                                 Label *L_handle_null) {\n@@ -484,2 +487,2 @@\n-  Register tmp = index;  \/\/ reuse\n-  sldi(tmp, index, LogBytesPerHeapOop);\n+  Register tmp2 = index;  \/\/ reuse\n+  sldi(tmp1, index, LogBytesPerHeapOop);\n@@ -494,1 +497,1 @@\n-  cmpd(CCR0, tmp, R0);\n+  cmpd(CCR0, tmp1, R0);\n@@ -500,2 +503,5 @@\n-  add(result, tmp, result);\n-  load_heap_oop(result, arrayOopDesc::base_offset_in_bytes(T_OBJECT), result, tmp, R0, false, 0, L_handle_null);\n+  add(result, tmp1, result);\n+  load_heap_oop(result, arrayOopDesc::base_offset_in_bytes(T_OBJECT), result,\n+                tmp1, tmp2,\n+                MacroAssembler::PRESERVATION_FRAME_LR,\n+                0, L_handle_null);\n@@ -1199,89 +1205,0 @@\n-void InterpreterMacroAssembler::test_invocation_counter_for_mdp(Register invocation_count,\n-                                                                Register method_counters,\n-                                                                Register Rscratch,\n-                                                                Label &profile_continue) {\n-  assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  \/\/ Control will flow to \"profile_continue\" if the counter is less than the\n-  \/\/ limit or if we call profile_method().\n-  Label done;\n-\n-  \/\/ If no method data exists, and the counter is high enough, make one.\n-  lwz(Rscratch, in_bytes(MethodCounters::interpreter_profile_limit_offset()), method_counters);\n-\n-  cmpdi(CCR0, R28_mdx, 0);\n-  \/\/ Test to see if we should create a method data oop.\n-  cmpd(CCR1, Rscratch, invocation_count);\n-  bne(CCR0, done);\n-  bge(CCR1, profile_continue);\n-\n-  \/\/ Build it now.\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));\n-  set_method_data_pointer_for_bcp();\n-  b(profile_continue);\n-\n-  align(32, 12);\n-  bind(done);\n-}\n-\n-void InterpreterMacroAssembler::test_backedge_count_for_osr(Register backedge_count, Register method_counters,\n-                                                            Register target_bcp, Register disp, Register Rtmp) {\n-  assert_different_registers(backedge_count, target_bcp, disp, Rtmp, R4_ARG2);\n-  assert(UseOnStackReplacement,\"Must UseOnStackReplacement to test_backedge_count_for_osr\");\n-\n-  Label did_not_overflow;\n-  Label overflow_with_error;\n-\n-  lwz(Rtmp, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset()), method_counters);\n-  cmpw(CCR0, backedge_count, Rtmp);\n-\n-  blt(CCR0, did_not_overflow);\n-\n-  \/\/ When ProfileInterpreter is on, the backedge_count comes from the\n-  \/\/ methodDataOop, which value does not get reset on the call to\n-  \/\/ frequency_counter_overflow(). To avoid excessive calls to the overflow\n-  \/\/ routine while the method is being compiled, add a second test to make sure\n-  \/\/ the overflow function is called only once every overflow_frequency.\n-  if (ProfileInterpreter) {\n-    const int overflow_frequency = 1024;\n-    andi_(Rtmp, backedge_count, overflow_frequency-1);\n-    bne(CCR0, did_not_overflow);\n-  }\n-\n-  \/\/ Overflow in loop, pass branch bytecode.\n-  subf(R4_ARG2, disp, target_bcp); \/\/ Compute branch bytecode (previous bcp).\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::frequency_counter_overflow), R4_ARG2, true);\n-\n-  \/\/ Was an OSR adapter generated?\n-  cmpdi(CCR0, R3_RET, 0);\n-  beq(CCR0, overflow_with_error);\n-\n-  \/\/ Has the nmethod been invalidated already?\n-  lbz(Rtmp, nmethod::state_offset(), R3_RET);\n-  cmpwi(CCR0, Rtmp, nmethod::in_use);\n-  bne(CCR0, overflow_with_error);\n-\n-  \/\/ Migrate the interpreter frame off of the stack.\n-  \/\/ We can use all registers because we will not return to interpreter from this point.\n-\n-  \/\/ Save nmethod.\n-  const Register osr_nmethod = R31;\n-  mr(osr_nmethod, R3_RET);\n-  set_top_ijava_frame_at_SP_as_last_Java_frame(R1_SP, R11_scratch1);\n-  call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin), R16_thread);\n-  reset_last_Java_frame();\n-  \/\/ OSR buffer is in ARG1\n-\n-  \/\/ Remove the interpreter frame.\n-  merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R0, R11_scratch1, R12_scratch2);\n-\n-  \/\/ Jump to the osr code.\n-  ld(R11_scratch1, nmethod::osr_entry_point_offset(), osr_nmethod);\n-  mtlr(R0);\n-  mtctr(R11_scratch1);\n-  bctr();\n-\n-  align(32, 12);\n-  bind(overflow_with_error);\n-  bind(did_not_overflow);\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":13,"deletions":96,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -337,2 +336,2 @@\n-  #if !defined(_LP64) && defined(TIERED)\n-    if (UseSSE < 2 ) {\n+#if !defined(_LP64) && defined(COMPILER2)\n+  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_aot_or_jvmci()) {\n@@ -342,1 +341,1 @@\n-  #endif \/\/ !_LP64 && TIERED\n+#endif \/\/ !_LP64 && COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -723,2 +723,2 @@\n-#if !defined(_LP64) && defined(TIERED)\n-  if (UseSSE < 2) {\n+#if !defined(_LP64) && defined(COMPILER2)\n+  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_aot_or_jvmci()) {\n@@ -728,1 +728,1 @@\n-#endif \/\/ !_LP64 && TIERED\n+#endif \/\/ !_LP64 && COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#ifndef TIERED\n+#ifndef COMPILER2\n@@ -58,1 +58,1 @@\n-#endif \/\/ !TIERED\n+#endif \/\/ !COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/c1_globals_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,10 +46,35 @@\n-static void save_xmm_registers(MacroAssembler* masm) {\n-    __ subptr(rsp, 64);\n-    __ movdbl(Address(rsp, 0), xmm0);\n-    __ movdbl(Address(rsp, 8), xmm1);\n-    __ movdbl(Address(rsp, 16), xmm2);\n-    __ movdbl(Address(rsp, 24), xmm3);\n-    __ movdbl(Address(rsp, 32), xmm4);\n-    __ movdbl(Address(rsp, 40), xmm5);\n-    __ movdbl(Address(rsp, 48), xmm6);\n-    __ movdbl(Address(rsp, 56), xmm7);\n+static void save_machine_state(MacroAssembler* masm, bool handle_gpr, bool handle_fp) {\n+  if (handle_gpr) {\n+    __ push_IU_state();\n+  }\n+\n+  if (handle_fp) {\n+    \/\/ Some paths can be reached from the c2i adapter with live fp arguments in registers.\n+    LP64_ONLY(assert(Argument::n_float_register_parameters_j == 8, \"8 fp registers to save at java call\"));\n+\n+    if (UseSSE >= 2) {\n+      const int xmm_size = wordSize * LP64_ONLY(2) NOT_LP64(4);\n+      __ subptr(rsp, xmm_size * 8);\n+      __ movdbl(Address(rsp, xmm_size * 0), xmm0);\n+      __ movdbl(Address(rsp, xmm_size * 1), xmm1);\n+      __ movdbl(Address(rsp, xmm_size * 2), xmm2);\n+      __ movdbl(Address(rsp, xmm_size * 3), xmm3);\n+      __ movdbl(Address(rsp, xmm_size * 4), xmm4);\n+      __ movdbl(Address(rsp, xmm_size * 5), xmm5);\n+      __ movdbl(Address(rsp, xmm_size * 6), xmm6);\n+      __ movdbl(Address(rsp, xmm_size * 7), xmm7);\n+    } else if (UseSSE >= 1) {\n+      const int xmm_size = wordSize * LP64_ONLY(1) NOT_LP64(2);\n+      __ subptr(rsp, xmm_size * 8);\n+      __ movflt(Address(rsp, xmm_size * 0), xmm0);\n+      __ movflt(Address(rsp, xmm_size * 1), xmm1);\n+      __ movflt(Address(rsp, xmm_size * 2), xmm2);\n+      __ movflt(Address(rsp, xmm_size * 3), xmm3);\n+      __ movflt(Address(rsp, xmm_size * 4), xmm4);\n+      __ movflt(Address(rsp, xmm_size * 5), xmm5);\n+      __ movflt(Address(rsp, xmm_size * 6), xmm6);\n+      __ movflt(Address(rsp, xmm_size * 7), xmm7);\n+    } else {\n+      __ push_FPU_state();\n+    }\n+  }\n@@ -58,10 +83,32 @@\n-static void restore_xmm_registers(MacroAssembler* masm) {\n-    __ movdbl(xmm0, Address(rsp, 0));\n-    __ movdbl(xmm1, Address(rsp, 8));\n-    __ movdbl(xmm2, Address(rsp, 16));\n-    __ movdbl(xmm3, Address(rsp, 24));\n-    __ movdbl(xmm4, Address(rsp, 32));\n-    __ movdbl(xmm5, Address(rsp, 40));\n-    __ movdbl(xmm6, Address(rsp, 48));\n-    __ movdbl(xmm7, Address(rsp, 56));\n-    __ addptr(rsp, 64);\n+static void restore_machine_state(MacroAssembler* masm, bool handle_gpr, bool handle_fp) {\n+  if (handle_fp) {\n+    if (UseSSE >= 2) {\n+      const int xmm_size = wordSize * LP64_ONLY(2) NOT_LP64(4);\n+      __ movdbl(xmm0, Address(rsp, xmm_size * 0));\n+      __ movdbl(xmm1, Address(rsp, xmm_size * 1));\n+      __ movdbl(xmm2, Address(rsp, xmm_size * 2));\n+      __ movdbl(xmm3, Address(rsp, xmm_size * 3));\n+      __ movdbl(xmm4, Address(rsp, xmm_size * 4));\n+      __ movdbl(xmm5, Address(rsp, xmm_size * 5));\n+      __ movdbl(xmm6, Address(rsp, xmm_size * 6));\n+      __ movdbl(xmm7, Address(rsp, xmm_size * 7));\n+      __ addptr(rsp, xmm_size * 8);\n+    } else if (UseSSE >= 1) {\n+      const int xmm_size = wordSize * LP64_ONLY(1) NOT_LP64(2);\n+      __ movflt(xmm0, Address(rsp, xmm_size * 0));\n+      __ movflt(xmm1, Address(rsp, xmm_size * 1));\n+      __ movflt(xmm2, Address(rsp, xmm_size * 2));\n+      __ movflt(xmm3, Address(rsp, xmm_size * 3));\n+      __ movflt(xmm4, Address(rsp, xmm_size * 4));\n+      __ movflt(xmm5, Address(rsp, xmm_size * 5));\n+      __ movflt(xmm6, Address(rsp, xmm_size * 6));\n+      __ movflt(xmm7, Address(rsp, xmm_size * 7));\n+      __ addptr(rsp, xmm_size * 8);\n+    } else {\n+      __ pop_FPU_state();\n+    }\n+  }\n+\n+  if (handle_gpr) {\n+    __ pop_IU_state();\n+  }\n@@ -112,1 +159,1 @@\n-      __ pusha();                      \/\/ push registers\n+      save_machine_state(masm, \/* handle_gpr = *\/ true, \/* handle_fp = *\/ false);\n@@ -128,1 +175,2 @@\n-      __ popa();\n+      restore_machine_state(masm, \/* handle_gpr = *\/ true, \/* handle_fp = *\/ false);\n+\n@@ -332,0 +380,4 @@\n+  save_machine_state(masm, \/* handle_gpr = *\/ false, \/* handle_fp = *\/ true);\n+\n+  \/\/ The rest is saved with the optimized path\n+\n@@ -365,1 +417,0 @@\n-  save_xmm_registers(masm);\n@@ -383,1 +434,0 @@\n-  restore_xmm_registers(masm);\n@@ -404,0 +454,2 @@\n+  restore_machine_state(masm, \/* handle_gpr = *\/ false, \/* handle_fp = *\/ true);\n+\n@@ -432,6 +484,1 @@\n-    \/\/ The set of registers to be saved+restored is the same as in the write-barrier above.\n-    \/\/ Those are the commonly used registers in the interpreter.\n-    __ pusha();\n-    \/\/ __ push_callee_saved_registers();\n-    __ subptr(rsp, 2 * Interpreter::stackElementSize);\n-    __ movdbl(Address(rsp, 0), xmm0);\n+    save_machine_state(masm, \/* handle_gpr = *\/ true, \/* handle_fp = *\/ true);\n@@ -454,4 +501,2 @@\n-    __ movdbl(xmm0, Address(rsp, 0));\n-    __ addptr(rsp, 2 * Interpreter::stackElementSize);\n-    \/\/__ pop_callee_saved_registers();\n-    __ popa();\n+\n+    restore_machine_state(masm, \/* handle_gpr = *\/ true, \/* handle_fp = *\/ true);\n@@ -522,5 +567,1 @@\n-    __ push_IU_state();\n-    \/\/ That path can be reached from the c2i adapter with live fp\n-    \/\/ arguments in registers.\n-    LP64_ONLY(assert(Argument::n_float_register_parameters_j == 8, \"8 fp registers to save at java call\"));\n-    save_xmm_registers(masm);\n+    save_machine_state(masm, \/* handle_gpr = *\/ true, \/* handle_fp = *\/ true);\n@@ -543,2 +584,2 @@\n-    restore_xmm_registers(masm);\n-    __ pop_IU_state();\n+\n+    restore_machine_state(masm, \/* handle_gpr = *\/ true, \/* handle_fp = *\/ true);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":82,"deletions":41,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,    64 TIERED_ONLY(+64)); \/\/ Tiered compilation has large code-entry alignment.\n+define_pd_global(uintx, CodeCacheSegmentSize,    64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"oops\/method.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2500,1 +2500,0 @@\n-    if (dst->encoding() == src->encoding()) return;\n@@ -2525,1 +2524,0 @@\n-    if (dst->encoding() == src->encoding()) return;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,0 +206,3 @@\n+  \/\/ Move with zero extension\n+  void movfltz(XMMRegister dst, XMMRegister src) { movss(dst, src); }\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -57,1 +58,1 @@\n-    verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),\n+    verify_klass(_masm, klass_reg, VM_CLASS_ID(java_lang_Class),\n@@ -74,1 +75,1 @@\n-                                 Register obj, SystemDictionary::WKID klass_id,\n+                                 Register obj, vmClassID klass_id,\n@@ -76,2 +77,2 @@\n-  InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);\n-  Klass* klass = SystemDictionary::well_known_klass(klass_id);\n+  InstanceKlass** klass_addr = vmClasses::klass_addr_at(klass_id);\n+  Klass* klass = vmClasses::klass_at(klass_id);\n@@ -352,1 +353,1 @@\n-      verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MemberName),\n+      verify_klass(_masm, member_reg, VM_CLASS_ID(java_lang_invoke_MemberName),\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -394,4 +394,1 @@\n-void TemplateInterpreterGenerator::generate_counter_incr(\n-        Label* overflow,\n-        Label* profile_method,\n-        Label* profile_method_continue) {\n+void TemplateInterpreterGenerator::generate_counter_incr(Label* overflow) {\n@@ -400,66 +397,13 @@\n-  if (TieredCompilation) {\n-    int increment = InvocationCounter::count_increment;\n-    Label no_mdo;\n-    if (ProfileInterpreter) {\n-      \/\/ Are we profiling?\n-      __ movptr(rax, Address(rbx, Method::method_data_offset()));\n-      __ testptr(rax, rax);\n-      __ jccb(Assembler::zero, no_mdo);\n-      \/\/ Increment counter in the MDO\n-      const Address mdo_invocation_counter(rax, in_bytes(MethodData::invocation_counter_offset()) +\n-                                                in_bytes(InvocationCounter::counter_offset()));\n-      const Address mask(rax, in_bytes(MethodData::invoke_mask_offset()));\n-      __ increment_mask_and_jump(mdo_invocation_counter, increment, mask, rcx, false, Assembler::zero, overflow);\n-      __ jmp(done);\n-    }\n-    __ bind(no_mdo);\n-    \/\/ Increment counter in MethodCounters\n-    const Address invocation_counter(rax,\n-                  MethodCounters::invocation_counter_offset() +\n-                  InvocationCounter::counter_offset());\n-    __ get_method_counters(rbx, rax, done);\n-    const Address mask(rax, in_bytes(MethodCounters::invoke_mask_offset()));\n-    __ increment_mask_and_jump(invocation_counter, increment, mask, rcx,\n-                               false, Assembler::zero, overflow);\n-    __ bind(done);\n-  } else { \/\/ not TieredCompilation\n-    const Address backedge_counter(rax,\n-                  MethodCounters::backedge_counter_offset() +\n-                  InvocationCounter::counter_offset());\n-    const Address invocation_counter(rax,\n-                  MethodCounters::invocation_counter_offset() +\n-                  InvocationCounter::counter_offset());\n-\n-    __ get_method_counters(rbx, rax, done);\n-\n-    if (ProfileInterpreter) {\n-      __ incrementl(Address(rax,\n-              MethodCounters::interpreter_invocation_counter_offset()));\n-    }\n-    \/\/ Update standard invocation counters\n-    __ movl(rcx, invocation_counter);\n-    __ incrementl(rcx, InvocationCounter::count_increment);\n-    __ movl(invocation_counter, rcx); \/\/ save invocation count\n-\n-    __ movl(rax, backedge_counter);   \/\/ load backedge counter\n-    __ andl(rax, InvocationCounter::count_mask_value); \/\/ mask out the status bits\n-\n-    __ addl(rcx, rax);                \/\/ add both counters\n-\n-    \/\/ profile_method is non-null only for interpreted method so\n-    \/\/ profile_method != NULL == !native_call\n-\n-    if (ProfileInterpreter && profile_method != NULL) {\n-      \/\/ Test to see if we should create a method data oop\n-      __ movptr(rax, Address(rbx, Method::method_counters_offset()));\n-      __ cmp32(rcx, Address(rax, in_bytes(MethodCounters::interpreter_profile_limit_offset())));\n-      __ jcc(Assembler::less, *profile_method_continue);\n-\n-      \/\/ if no method data exists, go to profile_method\n-      __ test_method_data_pointer(rax, *profile_method);\n-    }\n-\n-    __ movptr(rax, Address(rbx, Method::method_counters_offset()));\n-    __ cmp32(rcx, Address(rax, in_bytes(MethodCounters::interpreter_invocation_limit_offset())));\n-    __ jcc(Assembler::aboveEqual, *overflow);\n-    __ bind(done);\n+  int increment = InvocationCounter::count_increment;\n+  Label no_mdo;\n+  if (ProfileInterpreter) {\n+    \/\/ Are we profiling?\n+    __ movptr(rax, Address(rbx, Method::method_data_offset()));\n+    __ testptr(rax, rax);\n+    __ jccb(Assembler::zero, no_mdo);\n+    \/\/ Increment counter in the MDO\n+    const Address mdo_invocation_counter(rax, in_bytes(MethodData::invocation_counter_offset()) +\n+        in_bytes(InvocationCounter::counter_offset()));\n+    const Address mask(rax, in_bytes(MethodData::invoke_mask_offset()));\n+    __ increment_mask_and_jump(mdo_invocation_counter, increment, mask, rcx, false, Assembler::zero, overflow);\n+    __ jmp(done);\n@@ -467,0 +411,10 @@\n+  __ bind(no_mdo);\n+  \/\/ Increment counter in MethodCounters\n+  const Address invocation_counter(rax,\n+      MethodCounters::invocation_counter_offset() +\n+      InvocationCounter::counter_offset());\n+  __ get_method_counters(rbx, rax, done);\n+  const Address mask(rax, in_bytes(MethodCounters::invoke_mask_offset()));\n+  __ increment_mask_and_jump(invocation_counter, increment, mask, rcx,\n+      false, Assembler::zero, overflow);\n+  __ bind(done);\n@@ -868,1 +822,1 @@\n-    generate_counter_incr(&invocation_counter_overflow, NULL, NULL);\n+    generate_counter_incr(&invocation_counter_overflow);\n@@ -1418,8 +1372,1 @@\n-  Label profile_method;\n-  Label profile_method_continue;\n-    generate_counter_incr(&invocation_counter_overflow,\n-                          &profile_method,\n-                          &profile_method_continue);\n-    if (ProfileInterpreter) {\n-      __ bind(profile_method_continue);\n-    }\n+    generate_counter_incr(&invocation_counter_overflow);\n@@ -1480,8 +1427,0 @@\n-    if (ProfileInterpreter) {\n-      \/\/ We have decided to profile this method in the interpreter\n-      __ bind(profile_method);\n-      __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));\n-      __ set_method_data_pointer_for_bcp();\n-      __ get_method(rbx);\n-      __ jmp(profile_method_continue);\n-    }\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":26,"deletions":87,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2266,1 +2266,0 @@\n-  Label profile_method;\n@@ -2295,68 +2294,14 @@\n-    if (TieredCompilation) {\n-      Label no_mdo;\n-      int increment = InvocationCounter::count_increment;\n-      if (ProfileInterpreter) {\n-        \/\/ Are we profiling?\n-        __ movptr(rbx, Address(rcx, in_bytes(Method::method_data_offset())));\n-        __ testptr(rbx, rbx);\n-        __ jccb(Assembler::zero, no_mdo);\n-        \/\/ Increment the MDO backedge counter\n-        const Address mdo_backedge_counter(rbx, in_bytes(MethodData::backedge_counter_offset()) +\n-                                           in_bytes(InvocationCounter::counter_offset()));\n-        const Address mask(rbx, in_bytes(MethodData::backedge_mask_offset()));\n-        __ increment_mask_and_jump(mdo_backedge_counter, increment, mask, rax, false, Assembler::zero,\n-                                   UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n-        __ jmp(dispatch);\n-      }\n-      __ bind(no_mdo);\n-      \/\/ Increment backedge counter in MethodCounters*\n-      __ movptr(rcx, Address(rcx, Method::method_counters_offset()));\n-      const Address mask(rcx, in_bytes(MethodCounters::backedge_mask_offset()));\n-      __ increment_mask_and_jump(Address(rcx, be_offset), increment, mask,\n-                                 rax, false, Assembler::zero,\n-                                 UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n-    } else { \/\/ not TieredCompilation\n-      \/\/ increment counter\n-      __ movptr(rcx, Address(rcx, Method::method_counters_offset()));\n-      __ movl(rax, Address(rcx, be_offset));        \/\/ load backedge counter\n-      __ incrementl(rax, InvocationCounter::count_increment); \/\/ increment counter\n-      __ movl(Address(rcx, be_offset), rax);        \/\/ store counter\n-\n-      __ movl(rax, Address(rcx, inv_offset));    \/\/ load invocation counter\n-\n-      __ andl(rax, InvocationCounter::count_mask_value); \/\/ and the status bits\n-      __ addl(rax, Address(rcx, be_offset));        \/\/ add both counters\n-\n-      if (ProfileInterpreter) {\n-        \/\/ Test to see if we should create a method data oop\n-        __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_profile_limit_offset())));\n-        __ jcc(Assembler::less, dispatch);\n-\n-        \/\/ if no method data exists, go to profile method\n-        __ test_method_data_pointer(rax, profile_method);\n-\n-        if (UseOnStackReplacement) {\n-          \/\/ check for overflow against rbx which is the MDO taken count\n-          __ cmp32(rbx, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));\n-          __ jcc(Assembler::below, dispatch);\n-\n-          \/\/ When ProfileInterpreter is on, the backedge_count comes\n-          \/\/ from the MethodData*, which value does not get reset on\n-          \/\/ the call to frequency_counter_overflow().  To avoid\n-          \/\/ excessive calls to the overflow routine while the method is\n-          \/\/ being compiled, add a second test to make sure the overflow\n-          \/\/ function is called only once every overflow_frequency.\n-          const int overflow_frequency = 1024;\n-          __ andl(rbx, overflow_frequency - 1);\n-          __ jcc(Assembler::zero, backedge_counter_overflow);\n-\n-        }\n-      } else {\n-        if (UseOnStackReplacement) {\n-          \/\/ check for overflow against rax, which is the sum of the\n-          \/\/ counters\n-          __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));\n-          __ jcc(Assembler::aboveEqual, backedge_counter_overflow);\n-\n-        }\n-      }\n+    Label no_mdo;\n+    int increment = InvocationCounter::count_increment;\n+    if (ProfileInterpreter) {\n+      \/\/ Are we profiling?\n+      __ movptr(rbx, Address(rcx, in_bytes(Method::method_data_offset())));\n+      __ testptr(rbx, rbx);\n+      __ jccb(Assembler::zero, no_mdo);\n+      \/\/ Increment the MDO backedge counter\n+      const Address mdo_backedge_counter(rbx, in_bytes(MethodData::backedge_counter_offset()) +\n+          in_bytes(InvocationCounter::counter_offset()));\n+      const Address mask(rbx, in_bytes(MethodData::backedge_mask_offset()));\n+      __ increment_mask_and_jump(mdo_backedge_counter, increment, mask, rax, false, Assembler::zero,\n+          UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n+      __ jmp(dispatch);\n@@ -2364,0 +2309,6 @@\n+    __ bind(no_mdo);\n+    \/\/ Increment backedge counter in MethodCounters*\n+    __ movptr(rcx, Address(rcx, Method::method_counters_offset()));\n+    const Address mask(rcx, in_bytes(MethodCounters::backedge_mask_offset()));\n+    __ increment_mask_and_jump(Address(rcx, be_offset), increment, mask,\n+        rax, false, Assembler::zero, UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n@@ -2377,8 +2328,1 @@\n-    if (ProfileInterpreter && !TieredCompilation) {\n-      \/\/ Out-of-line code to allocate method data oop.\n-      __ bind(profile_method);\n-      __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));\n-      __ set_method_data_pointer_for_bcp();\n-      __ jmp(dispatch);\n-    }\n-\n+      Label set_mdp;\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":21,"deletions":77,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1009,1 +1009,1 @@\n-    if (is_client_compilation_mode_vm()) {\n+    if (!CompilerConfig::is_c2_enabled()) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize, 64 TIERED_ONLY(+64)); \/\/ Tiered compilation has large code-entry alignment.\n+define_pd_global(uintx, CodeCacheSegmentSize, 64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,1 +209,1 @@\n-  virtual bool make_entrant() NOT_TIERED({ ShouldNotReachHere(); return false; });\n+  virtual bool make_entrant();\n","filename":"src\/hotspot\/share\/aot\/aotCompiledMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -449,1 +449,1 @@\n-  if (directive()->BreakAtCompileOption) {\n+  if (env()->break_at_compile()) {\n@@ -591,1 +591,1 @@\n-    _env->record_method_not_compilable(bailout_msg(), !TieredCompilation);\n+    _env->record_method_not_compilable(bailout_msg());\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,2 +274,2 @@\n-  bool is_optimistic() const                             {\n-    return !TieredCompilation &&\n+  bool is_optimistic() {\n+    return CompilerConfig::is_c1_only_no_aot_or_jvmci() && !is_profiling() &&\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4128,1 +4128,1 @@\n-  if (CompilationPolicy::policy()->should_not_inline(compilation()->env(), callee)) {\n+  if (CompilationPolicy::should_not_inline(compilation()->env(), callee)) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-#if defined(IA32) && defined(TIERED)\n+#if defined(IA32) && defined(COMPILER2)\n@@ -498,1 +498,1 @@\n-  if (UseSSE < 2) {\n+  if (UseSSE < 2 && !CompilerConfig::is_c1_only_no_aot_or_jvmci()) {\n@@ -507,1 +507,1 @@\n-#endif \/\/ X86 && TIERED\n+#endif \/\/ IA32 && COMPILER2\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -466,1 +466,1 @@\n-  \/* C2 relies on constant pool entries being resolved (ciTypeFlow), so if TieredCompilation\n+  \/* C2 relies on constant pool entries being resolved (ciTypeFlow), so if tiered compilation\n@@ -469,1 +469,1 @@\n-  if ((TieredCompilation && need_resolve) || !obj->is_loaded() || PatchALot) {\n+  if ((!CompilerConfig::is_c1_only_no_aot_or_jvmci() && need_resolve) || !obj->is_loaded() || PatchALot) {\n@@ -670,1 +670,1 @@\n-  } else if (PrintNotLoaded && (TieredCompilation && new_instance->is_unresolved())) {\n+  } else if (PrintNotLoaded && (!CompilerConfig::is_c1_only_no_aot_or_jvmci() && new_instance->is_unresolved())) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -514,1 +514,1 @@\n-                         SystemDictionary::ValueBootstrapMethods_klass(),\n+                         vmClasses::ValueBootstrapMethods_klass(),\n@@ -591,1 +591,1 @@\n-  osr_nm = CompilationPolicy::policy()->event(enclosing_method, method, branch_bci, bci, level, nm, THREAD);\n+  osr_nm = CompilationPolicy::event(enclosing_method, method, branch_bci, bci, level, nm, THREAD);\n@@ -654,1 +654,1 @@\n-  assert(exception->is_a(SystemDictionary::Throwable_klass()),\n+  assert(exception->is_a(vmClasses::Throwable_klass()),\n@@ -1541,2 +1541,0 @@\n-  assert(!TieredCompilation, \"incompatible with tiered compilation\");\n-\n@@ -1560,1 +1558,1 @@\n-      assert((PENDING_EXCEPTION->is_a(SystemDictionary::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n+      assert((PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -89,3 +91,3 @@\n-#define WK_KLASS_DEFN(name, ignore_s) ciInstanceKlass* ciEnv::_##name = NULL;\n-WK_KLASSES_DO(WK_KLASS_DEFN)\n-#undef WK_KLASS_DEFN\n+#define VM_CLASS_DEFN(name, ignore_s) ciInstanceKlass* ciEnv::_##name = NULL;\n+VM_CLASSES_DO(VM_CLASS_DEFN)\n+#undef VM_CLASS_DEFN\n@@ -827,1 +829,1 @@\n-    ciInstanceKlass* holder    = get_instance_klass(SystemDictionary::MethodHandle_klass());\n+    ciInstanceKlass* holder    = get_instance_klass(vmClasses::MethodHandle_klass());\n@@ -1146,1 +1148,1 @@\n-  if (task() == NULL)  return CompLevel_highest_tier;\n+  if (task() == NULL)  return CompilationPolicy::highest_compile_level();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClassMacros.hpp\"\n@@ -87,3 +87,3 @@\n-#define WK_KLASS_DECL(name, ignore_s) static ciInstanceKlass* _##name;\n-  WK_KLASSES_DO(WK_KLASS_DECL)\n-#undef WK_KLASS_DECL\n+#define VM_CLASS_DECL(name, ignore_s) static ciInstanceKlass* _##name;\n+  VM_CLASSES_DO(VM_CLASS_DECL)\n+#undef VM_CLASS_DECL\n@@ -392,1 +392,1 @@\n-#define WK_KLASS_FUNC(name, ignore_s) \\\n+#define VM_CLASS_FUNC(name, ignore_s) \\\n@@ -396,2 +396,2 @@\n-  WK_KLASSES_DO(WK_KLASS_FUNC)\n-#undef WK_KLASS_FUNC\n+  VM_CLASSES_DO(VM_CLASS_FUNC)\n+#undef VM_CLASS_FUNC\n@@ -462,1 +462,1 @@\n-  void record_method_not_compilable(const char* reason, bool all_tiers = true);\n+  void record_method_not_compilable(const char* reason, bool all_tiers = false);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -300,2 +300,2 @@\n-      assert(SystemDictionary::System_klass() != NULL, \"Check once per vm\");\n-      if (k == SystemDictionary::System_klass()) {\n+      assert(vmClasses::System_klass() != NULL, \"Check once per vm\");\n+      if (k == vmClasses::System_klass()) {\n@@ -319,2 +319,2 @@\n-    assert(SystemDictionary::CallSite_klass() != NULL, \"should be already initialized\");\n-    if (k == SystemDictionary::CallSite_klass() &&\n+    assert(vmClasses::CallSite_klass() != NULL, \"should be already initialized\");\n+    if (k == vmClasses::CallSite_klass() &&\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"jvm.h\"\n+#include \"jvm_constants.h\"\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -46,1 +46,1 @@\n-  if (m == NULL || m->klass() != SystemDictionary::Class_klass()) {\n+  if (m == NULL || m->klass() != vmClasses::Class_klass()) {\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -112,1 +113,1 @@\n-    if (k != SystemDictionary::Object_klass()) {\n+    if (k != vmClasses::Object_klass()) {\n@@ -266,1 +267,1 @@\n-    return SystemDictionary::box_klass_type(get_Klass());\n+    return vmClasses::box_klass_type(get_Klass());\n@@ -785,1 +786,1 @@\n-        if (value->is_a(SystemDictionary::String_klass())) {\n+        if (value->is_a(vmClasses::String_klass())) {\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"oops\/instanceKlass.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -143,1 +142,1 @@\n-  if (ProfileInterpreter || TieredCompilation) {\n+  if (ProfileInterpreter || CompilerConfig::is_c1_profiling()) {\n@@ -479,9 +478,7 @@\n-        if (TieredCompilation) {\n-          \/\/ For a call, it is assumed that either the type of the receiver(s)\n-          \/\/ is recorded or an associated counter is incremented, but not both. With\n-          \/\/ tiered compilation, however, both can happen due to the interpreter and\n-          \/\/ C1 profiling invocations differently. Address that inconsistency here.\n-          if (morphism == 1 && count > 0) {\n-            epsilon = count;\n-            count = 0;\n-          }\n+        \/\/ For a call, it is assumed that either the type of the receiver(s)\n+        \/\/ is recorded or an associated counter is incremented, but not both. With\n+        \/\/ tiered compilation, however, both can happen due to the interpreter and\n+        \/\/ C1 profiling invocations differently. Address that inconsistency here.\n+        if (morphism == 1 && count > 0) {\n+          epsilon = count;\n+          count = 0;\n@@ -914,8 +911,2 @@\n-    if (TieredCompilation) {\n-      \/\/ In tiered the MDO's life is measured directly, so just use the snapshotted counters\n-      counter_life = MAX2(method_data()->invocation_count(), method_data()->backedge_count());\n-    } else {\n-      int current_mileage = method_data()->current_mileage();\n-      int creation_mileage = method_data()->creation_mileage();\n-      counter_life = current_mileage - creation_mileage;\n-    }\n+    \/\/ In tiered the MDO's life is measured directly, so just use the snapshotted counters\n+    counter_life = MAX2(method_data()->invocation_count(), method_data()->backedge_count());\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"compiler\/compilerOracle.hpp\"\n+#include \"oops\/method.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -56,0 +56,1 @@\n+#include \"runtime\/signature.hpp\"\n@@ -158,3 +159,3 @@\n-#define WK_KLASS_DEFN(name, ignore_s)                              \\\n-  if (SystemDictionary::name##_is_loaded()) \\\n-    ciEnv::_##name = get_metadata(SystemDictionary::name())->as_instance_klass();\n+#define VM_CLASS_DEFN(name, ignore_s)                              \\\n+  if (vmClasses::name##_is_loaded()) \\\n+    ciEnv::_##name = get_metadata(vmClasses::name())->as_instance_klass();\n@@ -162,2 +163,2 @@\n-  WK_KLASSES_DO(WK_KLASS_DEFN)\n-#undef WK_KLASS_DEFN\n+  VM_CLASSES_DO(VM_CLASS_DEFN)\n+#undef VM_CLASS_DEFN\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -481,1 +483,1 @@\n-    } else if (!TieredCompilation && (comp_level != CompLevel_highest_tier)) {\n+    } else if (is_c1_compile(comp_level) && !CompilerConfig::is_c1_enabled()) {\n@@ -483,10 +485,4 @@\n-      switch (comp_level) {\n-        case CompLevel_simple:\n-          jio_snprintf(msg, msg_len, \"compilation level %d requires Client VM or TieredCompilation\", comp_level);\n-          break;\n-        case CompLevel_full_optimization:\n-          jio_snprintf(msg, msg_len, \"compilation level %d requires Server VM\", comp_level);\n-          break;\n-        default:\n-          jio_snprintf(msg, msg_len, \"compilation level %d requires TieredCompilation\", comp_level);\n-      }\n+      jio_snprintf(msg, msg_len, \"compilation level %d requires C1\", comp_level);\n+    } else if (is_c2_compile(comp_level) && !CompilerConfig::is_c2_enabled()) {\n+      msg = NEW_RESOURCE_ARRAY(char, msg_len);\n+      jio_snprintf(msg, msg_len, \"compilation level %d requires C2\", comp_level);\n@@ -541,5 +537,1 @@\n-      if (TieredCompilation) {\n-        comp_level = TieredStopAtLevel;\n-      } else {\n-        comp_level = CompLevel_highest_tier;\n-      }\n+      comp_level = CompilationPolicy::highest_compile_level();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciType.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -1153,1 +1154,1 @@\n-    : _location(location), _annotations_present(0)\n+    : _location(location), _annotations_present(0), _contended_group(0)\n@@ -2830,1 +2831,1 @@\n-      if (!SystemDictionary::Parameter_klass_loaded())\n+      if (!vmClasses::Parameter_klass_loaded())\n@@ -4479,2 +4480,2 @@\n-  if (SystemDictionary::Cloneable_klass_loaded()) {\n-    if (ik->is_subtype_of(SystemDictionary::Cloneable_klass())) {\n+  if (vmClasses::Cloneable_klass_loaded()) {\n+    if (ik->is_subtype_of(vmClasses::Cloneable_klass())) {\n@@ -4599,1 +4600,1 @@\n-    if (length == 1 && result->at(0) == SystemDictionary::IdentityObject_klass()) {\n+    if (length == 1 && result->at(0) == vmClasses::IdentityObject_klass()) {\n@@ -5178,1 +5179,1 @@\n-          SystemDictionary::Character_klass(),\n+          vmClasses::Character_klass(),\n@@ -5186,1 +5187,1 @@\n-          SystemDictionary::Character_klass(),\n+          vmClasses::Character_klass(),\n@@ -6577,1 +6578,1 @@\n-  if (_super_class_index > 0 && NULL ==_super_klass) {\n+  if (_super_class_index > 0 && NULL == _super_klass) {\n@@ -6649,1 +6650,1 @@\n-    _temp_local_interfaces->append(SystemDictionary::IdentityObject_klass());\n+    _temp_local_interfaces->append(vmClasses::IdentityObject_klass());\n@@ -6655,1 +6656,1 @@\n-  } else if (itfs_len == 1 && _temp_local_interfaces->at(0) == SystemDictionary::IdentityObject_klass()) {\n+  } else if (itfs_len == 1 && _temp_local_interfaces->at(0) == vmClasses::IdentityObject_klass()) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -403,1 +404,1 @@\n-      if (k->local_interfaces()->at(i) == SystemDictionary::IdentityObject_klass()) {\n+      if (k->local_interfaces()->at(i) == vmClasses::IdentityObject_klass()) {\n@@ -409,1 +410,1 @@\n-      if (lookup_class_by_id(_interfaces->at(i)) == SystemDictionary::IdentityObject_klass()) {\n+      if (lookup_class_by_id(_interfaces->at(i)) == vmClasses::IdentityObject_klass()) {\n@@ -593,1 +594,1 @@\n-                              SystemDictionary::ClassLoader_klass(),\n+                              vmClasses::ClassLoader_klass(),\n@@ -684,1 +685,1 @@\n-    return SystemDictionary::IdentityObject_klass();\n+    return vmClasses::IdentityObject_klass();\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -68,0 +69,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -134,5 +136,0 @@\n-PerfCounter*    ClassLoader::_sync_systemLoaderLockContentionRate = NULL;\n-PerfCounter*    ClassLoader::_sync_nonSystemLoaderLockContentionRate = NULL;\n-PerfCounter*    ClassLoader::_sync_JVMFindLoadedClassLockFreeCounter = NULL;\n-PerfCounter*    ClassLoader::_sync_JVMDefineClassLockFreeCounter = NULL;\n-PerfCounter*    ClassLoader::_sync_JNIDefineClassLockFreeCounter = NULL;\n@@ -1083,1 +1080,1 @@\n-  objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::String_klass(),\n@@ -1464,19 +1461,1 @@\n-\n-    \/\/ The following performance counters are added for measuring the impact\n-    \/\/ of the bug fix of 6365597. They are mainly focused on finding out\n-    \/\/ the behavior of system & user-defined classloader lock, whether\n-    \/\/ ClassLoader.loadClass\/findClass is being called synchronized or not.\n-    NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,\n-                        \"systemLoaderLockContentionRate\");\n-    NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,\n-                        \"nonSystemLoaderLockContentionRate\");\n-    NEWPERFEVENTCOUNTER(_sync_JVMFindLoadedClassLockFreeCounter, SUN_CLS,\n-                        \"jvmFindLoadedClassNoLockCalls\");\n-    NEWPERFEVENTCOUNTER(_sync_JVMDefineClassLockFreeCounter, SUN_CLS,\n-                        \"jvmDefineClassNoLockCalls\");\n-\n-    NEWPERFEVENTCOUNTER(_sync_JNIDefineClassLockFreeCounter, SUN_CLS,\n-                        \"jniDefineClassNoLockCalls\");\n-\n-    NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,\n-                        \"unsafeDefineClassCalls\");\n+    NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS, \"unsafeDefineClassCalls\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -367,1 +368,1 @@\n-      assert(m->is_a(SystemDictionary::Class_klass()), \"invalid mirror\");\n+      assert(m->is_a(vmClasses::Class_klass()), \"invalid mirror\");\n@@ -601,1 +602,1 @@\n-  } else if (class_loader()->is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {\n+  } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n@@ -784,1 +785,1 @@\n-      } else if (class_loader()->is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {\n+      } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvm.h\"\n@@ -33,0 +34,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -92,1 +95,1 @@\n-  { SystemDictionary::WK_KLASS_ENUM_NAME(klass), VM_SYMBOL_ENUM_NAME(name##_name), VM_SYMBOL_ENUM_NAME(signature), may_be_java },\n+  { VM_CLASS_ID(klass), VM_SYMBOL_ENUM_NAME(name##_name), VM_SYMBOL_ENUM_NAME(signature), may_be_java },\n@@ -100,1 +103,1 @@\n-  InstanceKlass* obj = SystemDictionary::Object_klass();\n+  InstanceKlass* obj = vmClasses::Object_klass();\n@@ -220,1 +223,1 @@\n-  InstanceKlass* k = SystemDictionary::String_klass();\n+  InstanceKlass* k = vmClasses::String_klass();\n@@ -243,1 +246,1 @@\n-      assert(fd->field_holder() == SystemDictionary::String_klass(), \"Should be String\");\n+      assert(fd->field_holder() == vmClasses::String_klass(), \"Should be String\");\n@@ -252,1 +255,1 @@\n-  SystemDictionary::String_klass()->do_local_static_fields(&fix);\n+  vmClasses::String_klass()->do_local_static_fields(&fix);\n@@ -262,1 +265,1 @@\n-  obj = SystemDictionary::String_klass()->allocate_instance(CHECK_NH);\n+  obj = vmClasses::String_klass()->allocate_instance(CHECK_NH);\n@@ -742,1 +745,1 @@\n-  assert(java_string->klass() == SystemDictionary::String_klass(),\n+  assert(java_string->klass() == vmClasses::String_klass(),\n@@ -767,1 +770,1 @@\n-  assert(str1->klass() == SystemDictionary::String_klass(),\n+  assert(str1->klass() == vmClasses::String_klass(),\n@@ -769,1 +772,1 @@\n-  assert(str2->klass() == SystemDictionary::String_klass(),\n+  assert(str2->klass() == vmClasses::String_klass(),\n@@ -784,1 +787,1 @@\n-  assert(java_string->klass() == SystemDictionary::String_klass(), \"must be java_string\");\n+  assert(java_string->klass() == vmClasses::String_klass(), \"must be java_string\");\n@@ -994,1 +997,1 @@\n-  if (SystemDictionary::Class_klass_loaded()) {\n+  if (vmClasses::Class_klass_loaded()) {\n@@ -996,1 +999,1 @@\n-    oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())->allocate_instance(k, CHECK);\n+    oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK);\n@@ -1326,2 +1329,2 @@\n-  \/\/ see more details in SystemDictionary::resolve_well_known_classes().\n-  if (!SystemDictionary::Class_klass_loaded()) {\n+  \/\/ see more details in vmClasses::resolve_all().\n+  if (!vmClasses::Class_klass_loaded()) {\n@@ -1498,1 +1501,1 @@\n-  oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())->allocate_instance(NULL, CHECK_NULL);\n+  oop java_class = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(NULL, CHECK_NULL);\n@@ -1505,1 +1508,1 @@\n-  InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());\n+  InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(vmClasses::Class_klass());\n@@ -1643,1 +1646,1 @@\n-  assert(mirror != NULL && mirror->is_a(SystemDictionary::Class_klass()), \"must be a Class\");\n+  assert(mirror != NULL && mirror->is_a(vmClasses::Class_klass()), \"must be a Class\");\n@@ -1663,1 +1666,1 @@\n-  InstanceKlass* k = SystemDictionary::Class_klass();\n+  InstanceKlass* k = vmClasses::Class_klass();\n@@ -1736,1 +1739,1 @@\n-  InstanceKlass* k = SystemDictionary::Thread_klass();\n+  InstanceKlass* k = vmClasses::Thread_klass();\n@@ -1956,1 +1959,1 @@\n-  InstanceKlass* k = SystemDictionary::ThreadGroup_klass();\n+  InstanceKlass* k = vmClasses::ThreadGroup_klass();\n@@ -1982,1 +1985,1 @@\n-  InstanceKlass* k = SystemDictionary::Throwable_klass();\n+  InstanceKlass* k = vmClasses::Throwable_klass();\n@@ -1993,1 +1996,1 @@\n-  InstanceKlass* ik = SystemDictionary::Throwable_klass();\n+  InstanceKlass* ik = vmClasses::Throwable_klass();\n@@ -2419,1 +2422,1 @@\n-  assert(throwable->is_a(SystemDictionary::Throwable_klass()), \"Throwable instance expected\");\n+  assert(throwable->is_a(vmClasses::Throwable_klass()), \"Throwable instance expected\");\n@@ -2423,1 +2426,1 @@\n-                          SystemDictionary::Throwable_klass(),\n+                          vmClasses::Throwable_klass(),\n@@ -2602,1 +2605,1 @@\n-  assert(throwable->is_a(SystemDictionary::Throwable_klass()), \"sanity check\");\n+  assert(throwable->is_a(vmClasses::Throwable_klass()), \"sanity check\");\n@@ -2704,1 +2707,1 @@\n-  InstanceKlass* k = SystemDictionary::StackTraceElement_klass();\n+  InstanceKlass* k = vmClasses::StackTraceElement_klass();\n@@ -2720,1 +2723,1 @@\n-  assert(element->is_a(SystemDictionary::StackTraceElement_klass()), \"sanity check\");\n+  assert(element->is_a(vmClasses::StackTraceElement_klass()), \"sanity check\");\n@@ -2827,1 +2830,1 @@\n-  InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();\n+  InstanceKlass* k = vmClasses::StackFrameInfo_klass();\n@@ -2899,1 +2902,1 @@\n-  InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();\n+  InstanceKlass* k = vmClasses::LiveStackFrameInfo_klass();\n@@ -2934,1 +2937,1 @@\n-  InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();\n+  InstanceKlass* k = vmClasses::reflect_AccessibleObject_klass();\n@@ -2980,1 +2983,1 @@\n-  InstanceKlass* k = SystemDictionary::reflect_Method_klass();\n+  InstanceKlass* k = vmClasses::reflect_Method_klass();\n@@ -2992,1 +2995,1 @@\n-  Klass* klass = SystemDictionary::reflect_Method_klass();\n+  Klass* klass = vmClasses::reflect_Method_klass();\n@@ -3079,1 +3082,1 @@\n-  InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();\n+  InstanceKlass* k = vmClasses::reflect_Constructor_klass();\n@@ -3163,1 +3166,1 @@\n-  InstanceKlass* k = SystemDictionary::reflect_Field_klass();\n+  InstanceKlass* k = vmClasses::reflect_Field_klass();\n@@ -3238,1 +3241,1 @@\n-  InstanceKlass* ik = SystemDictionary::RecordComponent_klass();\n+  InstanceKlass* ik = vmClasses::RecordComponent_klass();\n@@ -3299,1 +3302,1 @@\n-  InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();\n+  InstanceKlass* k = vmClasses::reflect_ConstantPool_klass();\n@@ -3322,1 +3325,1 @@\n-  InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();\n+  InstanceKlass* k = vmClasses::reflect_Parameter_klass();\n@@ -3382,1 +3385,1 @@\n-  return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),\n+  return JavaCalls::construct_new_instance(vmClasses::Module_klass(),\n@@ -3392,1 +3395,1 @@\n-  InstanceKlass* k = SystemDictionary::Module_klass();\n+  InstanceKlass* k = vmClasses::Module_klass();\n@@ -3451,1 +3454,1 @@\n-  InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();\n+  InstanceKlass* k = vmClasses::reflect_ConstantPool_klass();\n@@ -3484,1 +3487,1 @@\n-  InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();\n+  InstanceKlass* k = vmClasses::reflect_UnsafeStaticFieldAccessorImpl_klass();\n@@ -3514,1 +3517,1 @@\n-  InstanceKlass* k = SystemDictionary::Reference_klass();\n+  InstanceKlass* k = vmClasses::Reference_klass();\n@@ -3538,1 +3541,1 @@\n-  assert(!is_reference || ik->is_subclass_of(SystemDictionary::Reference_klass()), \"sanity\");\n+  assert(!is_reference || ik->is_subclass_of(vmClasses::Reference_klass()), \"sanity\");\n@@ -3550,2 +3553,2 @@\n-  InstanceKlass* integerKlass = SystemDictionary::Integer_klass();\n-  InstanceKlass* longKlass = SystemDictionary::Long_klass();\n+  InstanceKlass* integerKlass = vmClasses::Integer_klass();\n+  InstanceKlass* longKlass = vmClasses::Long_klass();\n@@ -3562,1 +3565,1 @@\n-  Klass* k = SystemDictionary::box_klass(type);\n+  Klass* k = vmClasses::box_klass(type);\n@@ -3607,1 +3610,1 @@\n-  BasicType type = SystemDictionary::box_klass_type(box->klass());\n+  BasicType type = vmClasses::box_klass_type(box->klass());\n@@ -3615,1 +3618,1 @@\n-  BasicType type = SystemDictionary::box_klass_type(box->klass());\n+  BasicType type = vmClasses::box_klass_type(box->klass());\n@@ -3649,1 +3652,1 @@\n-  BasicType type = SystemDictionary::box_klass_type(box->klass());\n+  BasicType type = vmClasses::box_klass_type(box->klass());\n@@ -3708,1 +3711,1 @@\n-  InstanceKlass* k = SystemDictionary::SoftReference_klass();\n+  InstanceKlass* k = vmClasses::SoftReference_klass();\n@@ -3723,1 +3726,1 @@\n-  InstanceKlass* ik = SystemDictionary::SoftReference_klass();\n+  InstanceKlass* ik = vmClasses::SoftReference_klass();\n@@ -3729,1 +3732,1 @@\n-  InstanceKlass* ik = SystemDictionary::SoftReference_klass();\n+  InstanceKlass* ik = vmClasses::SoftReference_klass();\n@@ -3749,1 +3752,1 @@\n-  InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();\n+  InstanceKlass* k = vmClasses::DirectMethodHandle_klass();\n@@ -3781,1 +3784,1 @@\n-  InstanceKlass* k = SystemDictionary::MethodHandle_klass();\n+  InstanceKlass* k = vmClasses::MethodHandle_klass();\n@@ -3799,1 +3802,1 @@\n-  InstanceKlass* k = SystemDictionary::MemberName_klass();\n+  InstanceKlass* k = vmClasses::MemberName_klass();\n@@ -3812,1 +3815,1 @@\n-  InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();\n+  InstanceKlass* k = vmClasses::ResolvedMethodName_klass();\n@@ -3827,1 +3830,1 @@\n-  InstanceKlass* k = SystemDictionary::LambdaForm_klass();\n+  InstanceKlass* k = vmClasses::LambdaForm_klass();\n@@ -3864,1 +3867,1 @@\n-  InstanceKlass* k = SystemDictionary::NativeEntryPoint_klass();\n+  InstanceKlass* k = vmClasses::NativeEntryPoint_klass();\n@@ -4018,1 +4021,1 @@\n-  InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();\n+  InstanceKlass* k = vmClasses::ResolvedMethodName_klass();\n@@ -4064,1 +4067,1 @@\n-  InstanceKlass* k = SystemDictionary::MethodType_klass();\n+  InstanceKlass* k = vmClasses::MethodType_klass();\n@@ -4158,1 +4161,1 @@\n-  InstanceKlass* k = SystemDictionary::CallSite_klass();\n+  InstanceKlass* k = vmClasses::CallSite_klass();\n@@ -4183,1 +4186,1 @@\n-  InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();\n+  InstanceKlass* k = vmClasses::ConstantCallSite_klass();\n@@ -4199,1 +4202,1 @@\n-  InstanceKlass* k = SystemDictionary::Context_klass();\n+  InstanceKlass* k = vmClasses::Context_klass();\n@@ -4232,1 +4235,1 @@\n-  InstanceKlass* k = SystemDictionary::AccessControlContext_klass();\n+  InstanceKlass* k = vmClasses::AccessControlContext_klass();\n@@ -4246,1 +4249,1 @@\n-  SystemDictionary::AccessControlContext_klass()->initialize(CHECK_NULL);\n+  vmClasses::AccessControlContext_klass()->initialize(CHECK_NULL);\n@@ -4248,1 +4251,1 @@\n-  oop result = SystemDictionary::AccessControlContext_klass()->allocate_instance(CHECK_NULL);\n+  oop result = vmClasses::AccessControlContext_klass()->allocate_instance(CHECK_NULL);\n@@ -4293,1 +4296,1 @@\n-  InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();\n+  InstanceKlass* k1 = vmClasses::ClassLoader_klass();\n@@ -4374,1 +4377,1 @@\n-    Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();\n+    Klass* delegating_cl_class = vmClasses::reflect_DelegatingClassLoader_klass();\n@@ -4412,1 +4415,1 @@\n-  InstanceKlass* k = SystemDictionary::System_klass();\n+  InstanceKlass* k = vmClasses::System_klass();\n@@ -4444,1 +4447,1 @@\n-    assert(fd->field_holder() == SystemDictionary::UnsafeConstants_klass(), \"Should be UnsafeConstants\");\n+    assert(fd->field_holder() == vmClasses::UnsafeConstants_klass(), \"Should be UnsafeConstants\");\n@@ -4465,1 +4468,1 @@\n-  SystemDictionary::UnsafeConstants_klass()->do_local_static_fields(&fixup);\n+  vmClasses::UnsafeConstants_klass()->do_local_static_fields(&fixup);\n@@ -4492,1 +4495,1 @@\n-  InstanceKlass* k = SystemDictionary::StackTraceElement_klass();\n+  InstanceKlass* k = vmClasses::StackTraceElement_klass();\n@@ -4552,1 +4555,1 @@\n-  InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();\n+  InstanceKlass* k = vmClasses::AssertionStatusDirectives_klass();\n@@ -4591,1 +4594,1 @@\n-  InstanceKlass* k = SystemDictionary::nio_Buffer_klass();\n+  InstanceKlass* k = vmClasses::nio_Buffer_klass();\n@@ -4608,1 +4611,1 @@\n-  InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();\n+  InstanceKlass* k = vmClasses::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();\n@@ -4629,1 +4632,1 @@\n-  InstanceKlass* k = SystemDictionary::vector_VectorPayload_klass();\n+  InstanceKlass* k = vmClasses::vector_VectorPayload_klass();\n@@ -4813,1 +4816,1 @@\n-  InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();\n+  InstanceKlass* k = vmClasses::jdk_internal_vm_jni_SubElementSelector_klass();\n@@ -4935,1 +4938,1 @@\n-  InstanceKlass* k = SystemDictionary::RecordComponent_klass();\n+  InstanceKlass* k = vmClasses::RecordComponent_klass();\n@@ -5011,1 +5014,1 @@\n-  \/\/ java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()\n+  \/\/ java_lang_ref_Reference) earlier inside vmClasses::resolve_all()\n@@ -5027,1 +5030,1 @@\n-  if (klass == SystemDictionary::ClassLoader_klass() ||  \/\/ ClassLoader::loader_data is malloc'ed.\n+  if (klass == vmClasses::ClassLoader_klass() ||  \/\/ ClassLoader::loader_data is malloc'ed.\n@@ -5035,3 +5038,3 @@\n-      klass == SystemDictionary::ResolvedMethodName_klass() ||\n-      klass == SystemDictionary::MemberName_klass() ||\n-      klass == SystemDictionary::Context_klass()) {\n+      klass == vmClasses::ResolvedMethodName_klass() ||\n+      klass == vmClasses::MemberName_klass() ||\n+      klass == vmClasses::Context_klass()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":86,"deletions":83,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -948,1 +948,1 @@\n-    return klass->is_subclass_of(SystemDictionary::MethodHandle_klass());\n+    return klass->is_subclass_of(vmClasses::MethodHandle_klass());\n@@ -975,1 +975,1 @@\n-    return klass->is_subclass_of(SystemDictionary::DirectMethodHandle_klass());\n+    return klass->is_subclass_of(vmClasses::DirectMethodHandle_klass());\n@@ -1003,2 +1003,2 @@\n-    return SystemDictionary::LambdaForm_klass() != NULL &&\n-      klass->is_subclass_of(SystemDictionary::LambdaForm_klass());\n+    return vmClasses::LambdaForm_klass() != NULL &&\n+      klass->is_subclass_of(vmClasses::LambdaForm_klass());\n@@ -1043,2 +1043,2 @@\n-    return SystemDictionary::NativeEntryPoint_klass() != NULL &&\n-      klass->is_subclass_of(SystemDictionary::NativeEntryPoint_klass());\n+    return vmClasses::NativeEntryPoint_klass() != NULL &&\n+      klass->is_subclass_of(vmClasses::NativeEntryPoint_klass());\n@@ -1137,1 +1137,1 @@\n-    return klass->is_subclass_of(SystemDictionary::MemberName_klass());\n+    return klass->is_subclass_of(vmClasses::MemberName_klass());\n@@ -1233,1 +1233,1 @@\n-    return klass->is_subclass_of(SystemDictionary::CallSite_klass());\n+    return klass->is_subclass_of(vmClasses::CallSite_klass());\n@@ -1259,1 +1259,1 @@\n-    return klass->is_subclass_of(SystemDictionary::ConstantCallSite_klass());\n+    return klass->is_subclass_of(vmClasses::ConstantCallSite_klass());\n@@ -1288,1 +1288,1 @@\n-    return klass->is_subclass_of(SystemDictionary::Context_klass());\n+    return klass->is_subclass_of(vmClasses::Context_klass());\n@@ -1356,1 +1356,1 @@\n-    return klass->is_subclass_of(SystemDictionary::ClassLoader_klass());\n+    return klass->is_subclass_of(vmClasses::ClassLoader_klass());\n@@ -1600,1 +1600,1 @@\n-    return klass->is_subclass_of(SystemDictionary::vector_VectorPayload_klass());\n+    return klass->is_subclass_of(vmClasses::vector_VectorPayload_klass());\n@@ -1744,1 +1744,1 @@\n-  const SystemDictionary::WKID klass_id;\n+  const vmClassID klass_id;\n@@ -1750,1 +1750,1 @@\n-  Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }\n+  Klass* klass() const      { return vmClasses::klass_at(klass_id); }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -29,0 +33,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -31,0 +36,143 @@\n+\/\/ SeenThread objects represent list of threads that are\n+\/\/ currently performing a load action on a class.\n+\/\/ For class circularity, set before loading a superclass.\n+\/\/ For bootclasssearchpath, set before calling load_instance_class.\n+\/\/ Defining must be single threaded on a class\/classloader basis\n+\/\/ For DEFINE_CLASS, the head of the queue owns the\n+\/\/ define token and the rest of the threads wait to return the\n+\/\/ result the first thread gets.\n+\/\/ For INLINE_FIELD, set when loading inline type fields for\n+\/\/ class circularity checking.\n+class SeenThread: public CHeapObj<mtInternal> {\n+private:\n+   Thread *_thread;\n+   SeenThread* _stnext;\n+   SeenThread* _stprev;\n+public:\n+   SeenThread(Thread *thread) {\n+       _thread = thread;\n+       _stnext = NULL;\n+       _stprev = NULL;\n+   }\n+   Thread* thread()                const { return _thread;}\n+   void set_thread(Thread *thread) { _thread = thread; }\n+\n+   SeenThread* next()              const { return _stnext;}\n+   void set_next(SeenThread *seen) { _stnext = seen; }\n+   void set_prev(SeenThread *seen) { _stprev = seen; }\n+\n+  void print_action_queue(outputStream* st) {\n+    SeenThread* seen = this;\n+    while (seen != NULL) {\n+      seen->thread()->print_value_on(st);\n+      st->print(\", \");\n+      seen = seen->next();\n+    }\n+  }\n+};\n+\n+SeenThread* PlaceholderEntry::actionToQueue(PlaceholderTable::classloadAction action) {\n+  SeenThread* queuehead = NULL;\n+  switch (action) {\n+    case PlaceholderTable::LOAD_INSTANCE:\n+       queuehead = _loadInstanceThreadQ;\n+       break;\n+    case PlaceholderTable::LOAD_SUPER:\n+       queuehead = _superThreadQ;\n+       break;\n+    case PlaceholderTable::DEFINE_CLASS:\n+       queuehead = _defineThreadQ;\n+       break;\n+    case PlaceholderTable::INLINE_TYPE_FIELD:\n+       queuehead = _inlineTypeFieldQ;\n+       break;\n+    default: Unimplemented();\n+  }\n+  return queuehead;\n+}\n+\n+void PlaceholderEntry::set_threadQ(SeenThread* seenthread, PlaceholderTable::classloadAction action) {\n+  switch (action) {\n+    case PlaceholderTable::LOAD_INSTANCE:\n+       _loadInstanceThreadQ = seenthread;\n+       break;\n+    case PlaceholderTable::LOAD_SUPER:\n+       _superThreadQ = seenthread;\n+       break;\n+    case PlaceholderTable::DEFINE_CLASS:\n+       _defineThreadQ = seenthread;\n+       break;\n+    case PlaceholderTable::INLINE_TYPE_FIELD:\n+       _inlineTypeFieldQ = seenthread;\n+       break;\n+    default: Unimplemented();\n+  }\n+  return;\n+}\n+\n+\/\/ Doubly-linked list of Threads per action for class\/classloader pair\n+\/\/ Class circularity support: links in thread before loading superclass\n+\/\/ bootstrapsearchpath support: links in a thread before load_instance_class\n+\/\/ definers: use as queue of define requestors, including owner of\n+\/\/ define token. Appends for debugging of requestor order\n+void PlaceholderEntry::add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+  assert_lock_strong(SystemDictionary_lock);\n+  SeenThread* threadEntry = new SeenThread(thread);\n+  SeenThread* seen = actionToQueue(action);\n+\n+  if (seen == NULL) {\n+    set_threadQ(threadEntry, action);\n+    return;\n+  }\n+  SeenThread* next;\n+  while ((next = seen->next()) != NULL) {\n+    seen = next;\n+  }\n+  seen->set_next(threadEntry);\n+  threadEntry->set_prev(seen);\n+  return;\n+}\n+\n+bool PlaceholderEntry::check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+  assert_lock_strong(SystemDictionary_lock);\n+  SeenThread* threadQ = actionToQueue(action);\n+  SeenThread* seen = threadQ;\n+  while (seen) {\n+    if (thread == seen->thread()) {\n+      return true;\n+    }\n+    seen = seen->next();\n+  }\n+  return false;\n+}\n+\n+\/\/ returns true if seenthreadQ is now empty\n+\/\/ Note, caller must ensure probe still exists while holding\n+\/\/ SystemDictionary_lock\n+\/\/ ignores if cleanup has already been done\n+\/\/ if found, deletes SeenThread\n+bool PlaceholderEntry::remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n+  assert_lock_strong(SystemDictionary_lock);\n+  SeenThread* threadQ = actionToQueue(action);\n+  SeenThread* seen = threadQ;\n+  SeenThread* prev = NULL;\n+  while (seen) {\n+    if (thread == seen->thread()) {\n+      if (prev) {\n+        prev->set_next(seen->next());\n+      } else {\n+        set_threadQ(seen->next(), action);\n+      }\n+      if (seen->next()) {\n+        seen->next()->set_prev(prev);\n+      }\n+      delete seen;\n+      break;\n+    }\n+    prev = seen;\n+    seen = seen->next();\n+  }\n+  return (actionToQueue(action) == NULL);\n+}\n+\n+\n@@ -120,5 +268,25 @@\n-  \/\/ find_and_add returns probe pointer - old or new\n-  \/\/ If no entry exists, add a placeholder entry\n-  \/\/ If entry exists, reuse entry\n-  \/\/ For both, push SeenThread for classloadAction\n-  \/\/ If LOAD_SUPER, this is used for circularity detection for instanceklass loading.\n+static const char* action_to_string(PlaceholderTable::classloadAction action) {\n+  switch (action) {\n+  case PlaceholderTable::LOAD_INSTANCE: return \"LOAD_INSTANCE\";\n+  case PlaceholderTable::LOAD_SUPER:    return \"LOAD_SUPER\";\n+  case PlaceholderTable::DEFINE_CLASS:  return \"DEFINE_CLASS\";\n+  case PlaceholderTable::INLINE_TYPE_FIELD: return \"INLINE_TYPE_FIELD\";\n+ }\n+ return \"\";\n+}\n+\n+inline void log(PlaceholderEntry* entry, const char* function, PlaceholderTable::classloadAction action) {\n+  if (log_is_enabled(Debug, class, load, placeholders)) {\n+    LogTarget(Debug, class, load, placeholders) lt;\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print(\"%s %s \", function, action_to_string(action));\n+    entry->print_entry(&ls);\n+  }\n+}\n+\n+\/\/ find_and_add returns probe pointer - old or new\n+\/\/ If no entry exists, add a placeholder entry\n+\/\/ If entry exists, reuse entry\n+\/\/ For both, push SeenThread for classloadAction\n+\/\/ If LOAD_SUPER, this is used for circularity detection for instanceklass loading.\n@@ -142,0 +310,1 @@\n+  log(probe, \"find_and_add\", action);\n@@ -166,0 +335,1 @@\n+       log(probe, \"find_and_remove\", action);\n@@ -242,0 +412,2 @@\n+\n+void PlaceholderTable::print() const { return print_on(tty); }\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":178,"deletions":6,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"runtime\/thread.hpp\"\n@@ -32,0 +31,3 @@\n+class Thread;\n+class ClassLoaderData;\n+class Symbol;\n@@ -100,0 +102,1 @@\n+  void print() const;\n@@ -103,37 +106,1 @@\n-\/\/ SeenThread objects represent list of threads that are\n-\/\/ currently performing a load action on a class.\n-\/\/ For class circularity, set before loading a superclass.\n-\/\/ For bootclasssearchpath, set before calling load_instance_class.\n-\/\/ Defining must be single threaded on a class\/classloader basis\n-\/\/ For DEFINE_CLASS, the head of the queue owns the\n-\/\/ define token and the rest of the threads wait to return the\n-\/\/ result the first thread gets.\n-\/\/ For INLINE_FIELD, set when loading inline type fields for\n-\/\/ class circularity checking.\n-class SeenThread: public CHeapObj<mtInternal> {\n-private:\n-   Thread *_thread;\n-   SeenThread* _stnext;\n-   SeenThread* _stprev;\n-public:\n-   SeenThread(Thread *thread) {\n-       _thread = thread;\n-       _stnext = NULL;\n-       _stprev = NULL;\n-   }\n-   Thread* thread()                const { return _thread;}\n-   void set_thread(Thread *thread) { _thread = thread; }\n-\n-   SeenThread* next()              const { return _stnext;}\n-   void set_next(SeenThread *seen) { _stnext = seen; }\n-   void set_prev(SeenThread *seen) { _stprev = seen; }\n-\n-  void print_action_queue(outputStream* st) {\n-    SeenThread* seen = this;\n-    while (seen != NULL) {\n-      seen->thread()->print_value_on(st);\n-      st->print(\", \");\n-      seen = seen->next();\n-    }\n-  }\n-};\n+class SeenThread;\n@@ -149,0 +116,2 @@\n+  friend class PlaceholderTable;\n+\n@@ -165,0 +134,5 @@\n+  SeenThread* actionToQueue(PlaceholderTable::classloadAction action);\n+  void set_threadQ(SeenThread* seenthread, PlaceholderTable::classloadAction action);\n+  void add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n+  bool remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n+\n@@ -210,39 +184,0 @@\n-  SeenThread* actionToQueue(PlaceholderTable::classloadAction action) {\n-    SeenThread* queuehead = NULL;\n-    switch (action) {\n-      case PlaceholderTable::LOAD_INSTANCE:\n-         queuehead = _loadInstanceThreadQ;\n-         break;\n-      case PlaceholderTable::LOAD_SUPER:\n-         queuehead = _superThreadQ;\n-         break;\n-      case PlaceholderTable::DEFINE_CLASS:\n-         queuehead = _defineThreadQ;\n-         break;\n-      case PlaceholderTable::INLINE_TYPE_FIELD:\n-         queuehead = _inlineTypeFieldQ;\n-         break;\n-      default: Unimplemented();\n-    }\n-    return queuehead;\n-  }\n-\n-  void set_threadQ(SeenThread* seenthread, PlaceholderTable::classloadAction action) {\n-    switch (action) {\n-      case PlaceholderTable::LOAD_INSTANCE:\n-         _loadInstanceThreadQ = seenthread;\n-         break;\n-      case PlaceholderTable::LOAD_SUPER:\n-         _superThreadQ = seenthread;\n-         break;\n-      case PlaceholderTable::DEFINE_CLASS:\n-         _defineThreadQ = seenthread;\n-         break;\n-      case PlaceholderTable::INLINE_TYPE_FIELD:\n-         _inlineTypeFieldQ = seenthread;\n-         break;\n-      default: Unimplemented();\n-    }\n-    return;\n-  }\n-\n@@ -265,64 +200,2 @@\n-\/\/ Doubly-linked list of Threads per action for class\/classloader pair\n-\/\/ Class circularity support: links in thread before loading superclass\n-\/\/ bootstrapsearchpath support: links in a thread before load_instance_class\n-\/\/ definers: use as queue of define requestors, including owner of\n-\/\/ define token. Appends for debugging of requestor order\n-  void add_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n-    assert_lock_strong(SystemDictionary_lock);\n-    SeenThread* threadEntry = new SeenThread(thread);\n-    SeenThread* seen = actionToQueue(action);\n-\n-    if (seen == NULL) {\n-      set_threadQ(threadEntry, action);\n-      return;\n-    }\n-    SeenThread* next;\n-    while ((next = seen->next()) != NULL) {\n-      seen = next;\n-    }\n-    seen->set_next(threadEntry);\n-    threadEntry->set_prev(seen);\n-    return;\n-  }\n-\n-  bool check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n-    assert_lock_strong(SystemDictionary_lock);\n-    SeenThread* threadQ = actionToQueue(action);\n-    SeenThread* seen = threadQ;\n-    while (seen) {\n-      if (thread == seen->thread()) {\n-        return true;\n-      }\n-      seen = seen->next();\n-    }\n-    return false;\n-  }\n-\n-  \/\/ returns true if seenthreadQ is now empty\n-  \/\/ Note, caller must ensure probe still exists while holding\n-  \/\/ SystemDictionary_lock\n-  \/\/ ignores if cleanup has already been done\n-  \/\/ if found, deletes SeenThread\n-  bool remove_seen_thread(Thread* thread, PlaceholderTable::classloadAction action) {\n-    assert_lock_strong(SystemDictionary_lock);\n-    SeenThread* threadQ = actionToQueue(action);\n-    SeenThread* seen = threadQ;\n-    SeenThread* prev = NULL;\n-    while (seen) {\n-      if (thread == seen->thread()) {\n-        if (prev) {\n-          prev->set_next(seen->next());\n-        } else {\n-          set_threadQ(seen->next(), action);\n-        }\n-        if (seen->next()) {\n-          seen->next()->set_prev(prev);\n-        }\n-        delete seen;\n-        break;\n-      }\n-      prev = seen;\n-      seen = seen->next();\n-    }\n-    return (actionToQueue(action) == NULL);\n-  }\n+  \/\/ Used for ClassCircularityError checking\n+  bool check_seen_thread(Thread* thread, PlaceholderTable::classloadAction action);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":15,"deletions":142,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -61,1 +62,0 @@\n-#include \"oops\/instanceRefKlass.hpp\"\n@@ -94,1 +94,0 @@\n-PlaceholderTable*      SystemDictionary::_placeholders        = NULL;\n@@ -100,5 +99,0 @@\n-InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]\n-                                                          =  { NULL \/*, NULL...*\/ };\n-\n-InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL \/*, NULL...*\/ };\n-\n@@ -109,1 +103,0 @@\n-\n@@ -112,0 +105,9 @@\n+const int _loader_constraint_size = 107;                     \/\/ number of entries in constraint table\n+const int _resolution_error_size  = 107;                     \/\/ number of entries in resolution error table\n+const int _invoke_method_size     = 139;                     \/\/ number of entries in invoke method table\n+\n+\/\/ Hashtable holding placeholders for classes being loaded.\n+const int _placeholder_table_size = 1009;\n+PlaceholderTable* _placeholders   = NULL;\n+static PlaceholderTable*   placeholders() { return _placeholders; }\n+\n@@ -124,1 +126,1 @@\n-  InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();\n+  InstanceKlass* class_loader_klass = vmClasses::ClassLoader_klass();\n@@ -177,1 +179,1 @@\n-  return (class_loader->klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||\n+  return (class_loader->klass() == vmClasses::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||\n@@ -186,1 +188,1 @@\n-  return (class_loader->klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());\n+  return (class_loader->klass() == vmClasses::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());\n@@ -198,16 +200,0 @@\n-\/\/ This method is added to check how often we have to wait to grab loader\n-\/\/ lock. The results are being recorded in the performance counters defined in\n-\/\/ ClassLoader::_sync_nonSystemLoaderLockContentionRate.\n-void SystemDictionary::check_loader_lock_contention(Thread* thread, Handle loader_lock) {\n-  if (!UsePerfData) {\n-    return;\n-  }\n-\n-  if (loader_lock.is_null()) return;\n-\n-  if (ObjectSynchronizer::query_lock_ownership(thread->as_Java_thread(), loader_lock)\n-      == ObjectSynchronizer::owner_other) {\n-    ClassLoader::sync_nonSystemLoaderLockContentionRate()->inc();\n-  }\n-}\n-\n@@ -238,9 +224,10 @@\n-\/\/ Forwards to resolve_or_null\n-\n-Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {\n-  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);\n-  if (HAS_PENDING_EXCEPTION || klass == NULL) {\n-    \/\/ can return a null klass\n-    klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);\n-  }\n-  return klass;\n+#ifdef ASSERT\n+\/\/ Used to verify that class loading succeeded in adding k to the dictionary.\n+void verify_dictionary_entry(Symbol* class_name, InstanceKlass* k) {\n+  MutexLocker mu(SystemDictionary_lock);\n+  ClassLoaderData* loader_data = k->class_loader_data();\n+  Dictionary* dictionary = loader_data->dictionary();\n+  assert(class_name == k->name(), \"Must be the same\");\n+  unsigned int name_hash = dictionary->compute_hash(class_name);\n+  InstanceKlass* kk = dictionary->find_class(name_hash, class_name);\n+  assert(kk == k, \"should be present in dictionary\");\n@@ -248,0 +235,1 @@\n+#endif\n@@ -249,3 +237,1 @@\n-Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,\n-                                                     bool throw_error,\n-                                                     Klass* klass, TRAPS) {\n+static void handle_resolution_exception(Symbol* class_name, bool throw_error, TRAPS) {\n@@ -255,3 +241,2 @@\n-    \/\/ and if so convert it to a NoClassDefFoundError\n-    \/\/ And chain the original ClassNotFoundException\n-    if (throw_error && PENDING_EXCEPTION->is_a(SystemDictionary::ClassNotFoundException_klass())) {\n+    \/\/ and convert it to a NoClassDefFoundError and chain the original ClassNotFoundException.\n+    if (throw_error && PENDING_EXCEPTION->is_a(vmClasses::ClassNotFoundException_klass())) {\n@@ -259,1 +244,0 @@\n-      assert(klass == NULL, \"Should not have result with exception pending\");\n@@ -262,1 +246,1 @@\n-      THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name->as_C_string(), e);\n+      THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(), class_name->as_C_string(), e);\n@@ -264,1 +248,1 @@\n-      return NULL;\n+      return; \/\/ the caller will throw the incoming exception\n@@ -267,8 +251,7 @@\n-  \/\/ Class not found, throw appropriate error or exception depending on value of throw_error\n-  if (klass == NULL) {\n-    ResourceMark rm(THREAD);\n-    if (throw_error) {\n-      THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name->as_C_string());\n-    } else {\n-      THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name->as_C_string());\n-    }\n+  \/\/ If the class is not found, ie, caller has checked that klass is NULL, throw the appropriate\n+  \/\/ error or exception depending on the value of throw_error.\n+  ResourceMark rm(THREAD);\n+  if (throw_error) {\n+    THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), class_name->as_C_string());\n+  } else {\n+    THROW_MSG(vmSymbols::java_lang_ClassNotFoundException(), class_name->as_C_string());\n@@ -276,1 +259,0 @@\n-  return klass;\n@@ -279,0 +261,1 @@\n+\/\/ Forwards to resolve_or_null\n@@ -280,4 +263,8 @@\n-Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,\n-                                           bool throw_error, TRAPS)\n-{\n-  return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);\n+Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain,\n+                                         bool throw_error, TRAPS) {\n+  Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);\n+  \/\/ Check for pending exception or null klass, and throw exception\n+  if (HAS_PENDING_EXCEPTION || klass == NULL) {\n+    handle_resolution_exception(class_name, throw_error, CHECK_NULL);\n+  }\n+  return klass;\n@@ -286,1 +273,0 @@\n-\n@@ -314,4 +300,0 @@\n-Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {\n-  return resolve_or_null(class_name, Handle(), Handle(), THREAD);\n-}\n-\n@@ -353,1 +335,1 @@\n-\/\/    parse_interfaces - for defineClass & jvmtiRedefineClasses\n+\/\/    parse_interfaces - for defineClass\n@@ -355,1 +337,1 @@\n-\/\/   ClassFileParser - for defineClass & jvmtiRedefineClasses\n+\/\/   ClassFileParser - for defineClass\n@@ -382,3 +364,0 @@\n-\/\/ Must be called, even if superclass is null, since this is\n-\/\/ where the placeholder entry is created which claims this\n-\/\/ thread is loading this class\/classloader.\n@@ -388,2 +367,2 @@\n-\/\/ So be careful to not exit with a CHECK_ macro betweeen these calls.\n-InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,\n+\/\/ So be careful to not exit with a CHECK_ macro between these calls.\n+InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* class_name,\n@@ -399,1 +378,1 @@\n-    InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,\n+    InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(class_name,\n@@ -407,1 +386,1 @@\n-  \/\/ Double-check, if child class is already loaded, just return super-class,interface\n+  \/\/ Double-check, if klass is already loaded, just return super-class,interface\n@@ -410,1 +389,1 @@\n-  \/\/ Make sure there's a placeholder for the *child* before resolving.\n+  \/\/ Make sure there's a placeholder for the *klass* before resolving.\n@@ -416,1 +395,1 @@\n-  \/\/ We might not already have a placeholder if this child_name was\n+  \/\/ We might not already have a placeholder if this class_name was\n@@ -424,2 +403,2 @@\n-  unsigned int name_hash = dictionary->compute_hash(child_name);\n-  assert(placeholders()->compute_hash(child_name) == name_hash, \"they're the same hashcode\");\n+  unsigned int name_hash = dictionary->compute_hash(class_name);\n+  assert(placeholders()->compute_hash(class_name) == name_hash, \"they're the same hashcode\");\n@@ -430,1 +409,1 @@\n-    InstanceKlass* childk = dictionary->find_class(name_hash, child_name);\n+    InstanceKlass* klassk = dictionary->find_class(name_hash, class_name);\n@@ -432,8 +411,5 @@\n-    \/\/ to support \/\/ loading: if child done loading, just return superclass\n-    \/\/ if super_name, & class_loader don't match:\n-    \/\/ if initial define, SD update will give LinkageError\n-    \/\/ if redefine: compare_class_versions will give HIERARCHY_CHANGED\n-    \/\/ so we don't throw an exception here.\n-    \/\/ see: nsk redefclass014 & java.lang.instrument Instrument032\n-    if ((childk != NULL ) && (is_superclass) &&\n-        ((quicksuperk = childk->java_super()) != NULL) &&\n+    \/\/ To support parallel loading: if class is done loading, just return the superclass\n+    \/\/ if the super_name matches class->super()->name() and if the class loaders match.\n+    \/\/ Otherwise, a LinkageError will be thrown later.\n+    if (klassk != NULL && is_superclass &&\n+        ((quicksuperk = klassk->java_super()) != NULL) &&\n@@ -444,1 +420,1 @@\n-      PlaceholderEntry* probe = placeholders()->get_entry(name_hash, child_name, loader_data);\n+      PlaceholderEntry* probe = placeholders()->get_entry(name_hash, class_name, loader_data);\n@@ -450,2 +426,2 @@\n-      \/\/ Be careful not to exit resolve_super\n-      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);\n+      \/\/ Be careful not to exit resolve_super without removing this placeholder.\n+      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);\n@@ -456,1 +432,1 @@\n-      THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name->as_C_string());\n+      THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name->as_C_string());\n@@ -476,1 +452,1 @@\n-    placeholders()->find_and_remove(name_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n+    placeholders()->find_and_remove(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n@@ -479,0 +455,2 @@\n+\n+  \/\/ Check for pending exception or null superk, and throw exception\n@@ -480,6 +458,1 @@\n-    \/\/ can null superk\n-    Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);\n-    assert(k == NULL || k == superk, \"must be\");\n-    if (k == NULL) {\n-      superk = NULL;\n-    }\n+    handle_resolution_exception(super_name, true, CHECK_NULL);\n@@ -568,1 +541,1 @@\n-  InstanceKlass* system_loader = SystemDictionary::ClassLoader_klass();\n+  InstanceKlass* system_loader = vmClasses::ClassLoader_klass();\n@@ -784,1 +757,0 @@\n-  check_loader_lock_contention(THREAD, lockObject);\n@@ -833,11 +805,15 @@\n-    \/\/ add placeholder entry to record loading instance class\n-    \/\/ Five cases:\n-    \/\/ All cases need to prevent modifying bootclasssearchpath\n-    \/\/ in parallel with a classload of same classname\n-    \/\/ Redefineclasses uses existence of the placeholder for the duration\n-    \/\/ of the class load to prevent concurrent redefinition of not completely\n-    \/\/ defined classes.\n-    \/\/ case 1. traditional classloaders that rely on the classloader object lock\n-    \/\/   - no other need for LOAD_INSTANCE\n-    \/\/ case 2. traditional classloaders that break the classloader object lock\n-    \/\/    as a deadlock workaround. Detection of this case requires that\n+    \/\/ Add placeholder entry to record loading instance class\n+    \/\/ Three cases:\n+    \/\/ case 1. Bootstrap classloader\n+    \/\/    This classloader supports parallelism at the classloader level\n+    \/\/    but only allows a single thread to load a class\/classloader pair.\n+    \/\/    The LOAD_INSTANCE placeholder is the mechanism for mutual exclusion.\n+    \/\/ case 2. parallelCapable user level classloaders\n+    \/\/    These class loaders don't lock the object until load_instance_class is\n+    \/\/    called after this placeholder is added.\n+    \/\/    Allow parallel classloading of a class\/classloader pair where mutual\n+    \/\/    exclusion is provided by this lock in the class loader Java code.\n+    \/\/ case 3. traditional classloaders that rely on the classloader object lock\n+    \/\/    There should be no need for need for LOAD_INSTANCE, except:\n+    \/\/ case 4. traditional class loaders that break the classloader object lock\n+    \/\/    as a legacy deadlock workaround. Detection of this case requires that\n@@ -848,7 +824,0 @@\n-    \/\/ case 3. Bootstrap classloader - don't own objectLocker\n-    \/\/    This classloader supports parallelism at the classloader level,\n-    \/\/    but only allows a single load of a class\/classloader pair.\n-    \/\/    No performance benefit and no deadlock issues.\n-    \/\/ case 4. parallelCapable user level classloaders - without objectLocker\n-    \/\/    Allow parallel classloading of a class\/classloader pair\n-\n@@ -865,1 +834,1 @@\n-            \/\/ case 1: traditional: should never see load_in_progress.\n+            \/\/ case 3: traditional: should never see load_in_progress.\n@@ -868,1 +837,1 @@\n-              \/\/ case 3: bootstrap classloader: prevent futile classloading,\n+              \/\/ case 1: bootstrap classloader: prevent futile classloading,\n@@ -873,1 +842,1 @@\n-              \/\/ case 2: traditional with broken classloader lock. wait on first\n+              \/\/ case 4: traditional with broken classloader lock. wait on first\n@@ -890,3 +859,1 @@\n-      \/\/ All cases: add LOAD_INSTANCE holding SystemDictionary_lock\n-      \/\/ case 4: parallelCapable: allow competing threads to try\n-      \/\/ LOAD_INSTANCE in parallel\n+      \/\/ All cases: add LOAD_INSTANCE while holding the SystemDictionary_lock\n@@ -971,8 +938,3 @@\n-#ifdef ASSERT\n-  {\n-    ClassLoaderData* loader_data = loaded_class->class_loader_data();\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    InstanceKlass* kk = find_class(name, loader_data);\n-    assert(kk == loaded_class, \"should be present in dictionary\");\n-  }\n-#endif\n+\n+  \/\/ Make sure we have the right class in the dictionary\n+  DEBUG_ONLY(verify_dictionary_entry(name, loaded_class));\n@@ -1161,1 +1123,0 @@\n-  check_loader_lock_contention(THREAD, lockObject);\n@@ -1194,1 +1155,2 @@\n-  \/\/ find_or_define_instance_class may return a different InstanceKlass\n+  \/\/ find_or_define_instance_class may return a different InstanceKlass,\n+  \/\/ in which case the old k would be deallocated\n@@ -1196,7 +1158,1 @@\n-    InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);\n-    if (!HAS_PENDING_EXCEPTION && defined_k != k) {\n-      \/\/ If a parallel capable class loader already defined this class, register 'k' for cleanup.\n-      assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n-      loader_data->add_to_deallocate_list(k);\n-      k = defined_k;\n-    }\n+    k = find_or_define_instance_class(h_name, class_loader, k, CHECK_NULL);\n@@ -1205,6 +1161,6 @@\n-  }\n-  \/\/ If defining the class throws an exception register 'k' for cleanup.\n-  if (HAS_PENDING_EXCEPTION) {\n-    assert(k != NULL, \"Must have an instance klass here!\");\n-    loader_data->add_to_deallocate_list(k);\n-    return NULL;\n+    \/\/ If defining the class throws an exception register 'k' for cleanup.\n+    if (HAS_PENDING_EXCEPTION) {\n+      assert(k != NULL, \"Must have an instance klass here!\");\n+      loader_data->add_to_deallocate_list(k);\n+      return NULL;\n+    }\n@@ -1215,6 +1171,1 @@\n-  debug_only( {\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-\n-    Klass* check = find_class(h_name, k->class_loader_data());\n-    assert(check == k, \"should be present in the dictionary\");\n-  } );\n+  DEBUG_ONLY(verify_dictionary_entry(h_name, k));\n@@ -1327,1 +1278,1 @@\n-bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,\n+bool SystemDictionary::check_shared_class_super_type(InstanceKlass* klass, InstanceKlass* super_type,\n@@ -1332,1 +1283,1 @@\n-  Klass *found = resolve_super_or_fail(child->name(), super_type->name(),\n+  Klass *found = resolve_super_or_fail(klass->name(), super_type->name(),\n@@ -1338,1 +1289,1 @@\n-    \/\/ so we cannot use the child class.\n+    \/\/ so we cannot use the class.\n@@ -1468,1 +1419,0 @@\n-    check_loader_lock_contention(THREAD, lockObject);\n@@ -1515,45 +1465,0 @@\n-void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {\n-  assert(!Universe::is_fully_initialized(), \"We can make short cuts only during VM initialization\");\n-  assert(klass->is_shared(), \"Must be shared class\");\n-  if (klass->class_loader_data() != NULL) {\n-    return;\n-  }\n-\n-  \/\/ add super and interfaces first\n-  Klass* super = klass->super();\n-  if (super != NULL && super->class_loader_data() == NULL) {\n-    assert(super->is_instance_klass(), \"Super should be instance klass\");\n-    quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);\n-  }\n-\n-  Array<InstanceKlass*>* ifs = klass->local_interfaces();\n-  for (int i = 0; i < ifs->length(); i++) {\n-    InstanceKlass* ik = ifs->at(i);\n-    if (ik->class_loader_data()  == NULL) {\n-      quick_resolve(ik, loader_data, domain, CHECK);\n-    }\n-  }\n-\n-  if (klass->has_inline_type_fields()) {\n-    for (AllFieldStream fs(klass->fields(), klass->constants()); !fs.done(); fs.next()) {\n-      if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE) {\n-        if (!fs.access_flags().is_static()) {\n-          Klass* real_k = SystemDictionary::resolve_inline_type_field_or_fail(&fs,\n-            Handle(THREAD, loader_data->class_loader()), domain, true, CHECK);\n-          Klass* k = klass->get_inline_type_field_klass_or_null(fs.index());\n-          assert(real_k == k, \"oops, the app has substituted a different version of k!\");\n-        } else {\n-          klass->reset_inline_type_field_klass(fs.index());\n-        }\n-      }\n-    }\n-  }\n-\n-  klass->restore_unshareable_info(loader_data, domain, NULL, THREAD);\n-  load_shared_class_misc(klass, loader_data, CHECK);\n-  Dictionary* dictionary = loader_data->dictionary();\n-  unsigned int hash = dictionary->compute_hash(klass->name());\n-  dictionary->add_klass(hash, klass->name(), klass);\n-  add_to_hierarchy(klass);\n-  assert(klass->is_loaded(), \"Must be in at least loaded state\");\n-}\n@@ -1646,11 +1551,1 @@\n-      InstanceKlass* defined_k =\n-        find_or_define_instance_class(class_name, class_loader, k, THREAD);\n-      if (!HAS_PENDING_EXCEPTION && defined_k != k) {\n-        \/\/ If a parallel capable class loader already defined this class, register 'k' for cleanup.\n-        assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n-        loader_data->add_to_deallocate_list(k);\n-        k = defined_k;\n-      } else if (HAS_PENDING_EXCEPTION) {\n-        loader_data->add_to_deallocate_list(k);\n-        return NULL;\n-      }\n+      k = find_or_define_instance_class(class_name, class_loader, k, CHECK_NULL);\n@@ -1678,1 +1573,1 @@\n-    InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();\n+    InstanceKlass* spec_klass = vmClasses::ClassLoader_klass();\n@@ -1725,2 +1620,2 @@\n-  \/\/ Bootstrap and other parallel classloaders don't acquire lock,\n-  \/\/ they use a placeholder token instead.\n+  \/\/ Bootstrap and other parallel classloaders don't acquire a lock,\n+  \/\/ they use placeholder token.\n@@ -1803,2 +1698,2 @@\n-InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,\n-                                                               InstanceKlass* k, TRAPS) {\n+InstanceKlass* SystemDictionary::find_or_define_helper(Symbol* class_name, Handle class_loader,\n+                                                       InstanceKlass* k, TRAPS) {\n@@ -1866,13 +1761,1 @@\n-  return k;\n-}\n-\n-\n-\/\/ ----------------------------------------------------------------------------\n-\/\/ Lookup\n-\n-\/\/ Basic find on classes in the midst of being loaded\n-Symbol* SystemDictionary::find_placeholder(Symbol* class_name,\n-                                           ClassLoaderData* loader_data) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  unsigned int name_hash = placeholders()->compute_hash(class_name);\n-  return placeholders()->find_entry(name_hash, class_name, loader_data);\n+  return HAS_PENDING_EXCEPTION ? NULL : k;\n@@ -1881,17 +1764,15 @@\n-\n-\/\/ Used for assertions and verification only\n-\/\/ Precalculating the hash and index is an optimization because there are many lookups\n-\/\/ before adding the class.\n-InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  #ifndef ASSERT\n-  guarantee(VerifyBeforeGC      ||\n-            VerifyDuringGC      ||\n-            VerifyBeforeExit    ||\n-            VerifyDuringStartup ||\n-            VerifyAfterGC, \"too expensive\");\n-  #endif\n-\n-  Dictionary* dictionary = loader_data->dictionary();\n-  unsigned int name_hash = dictionary->compute_hash(class_name);\n-  return dictionary->find_class(name_hash, class_name);\n+\/\/ If a class loader supports parallel classloading handle parallel define requests.\n+\/\/ find_or_define_instance_class may return a different InstanceKlass\n+InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,\n+                                                               InstanceKlass* k, TRAPS) {\n+  InstanceKlass* defined_k = find_or_define_helper(class_name, class_loader, k, THREAD);\n+  \/\/ Clean up original InstanceKlass if duplicate or error\n+  if (!HAS_PENDING_EXCEPTION && defined_k != k) {\n+    \/\/ If a parallel capable class loader already defined this class, register 'k' for cleanup.\n+    assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n+    k->class_loader_data()->add_to_deallocate_list(k);\n+  } else if (HAS_PENDING_EXCEPTION) {\n+    assert(defined_k == NULL, \"Should not have a klass if there's an exception\");\n+    k->class_loader_data()->add_to_deallocate_list(k);\n+  }\n+  return defined_k;\n@@ -1969,7 +1850,0 @@\n-\/\/ CDS: scan and relocate all classes referenced by _well_known_klasses[].\n-void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {\n-  for (int id = FIRST_WKID; id < WKID_LIMIT; id++) {\n-    it->push(well_known_klass_addr((WKID)id));\n-  }\n-}\n-\n@@ -1996,1 +1870,1 @@\n-  resolve_well_known_classes(CHECK);\n+  vmClasses::resolve_all(CHECK);\n@@ -2003,175 +1877,7 @@\n-\/\/ Compact table of directions on the initialization of klasses:\n-\/\/ TODO: we should change the base type of vmSymbolID from int to short. Then we can declare this\n-\/\/ array as vmSymbolID wk_init_info[] anf avoid all the type casts.\n-static const short wk_init_info[] = {\n-  #define WK_KLASS_INIT_INFO(name, symbol) \\\n-    ((short)VM_SYMBOL_ENUM_NAME(symbol)),\n-\n-  WK_KLASSES_DO(WK_KLASS_INIT_INFO)\n-  #undef WK_KLASS_INIT_INFO\n-  0\n-};\n-\n-#ifdef ASSERT\n-bool SystemDictionary::is_well_known_klass(Symbol* class_name) {\n-  int sid;\n-  for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {\n-    Symbol* symbol = vmSymbols::symbol_at(vmSymbols::as_SID(sid));\n-    if (class_name == symbol) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-bool SystemDictionary::is_well_known_klass(Klass* k) {\n-  return is_well_known_klass(k->name());\n-}\n-#endif\n-\n-bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {\n-  assert(id >= (int)FIRST_WKID && id < (int)WKID_LIMIT, \"oob\");\n-  int sid = wk_init_info[id - FIRST_WKID];\n-  Symbol* symbol = vmSymbols::symbol_at(vmSymbols::as_SID(sid));\n-  InstanceKlass** klassp = &_well_known_klasses[id];\n-\n-#if INCLUDE_CDS\n-  if (UseSharedSpaces && !JvmtiExport::should_post_class_prepare()) {\n-    InstanceKlass* k = *klassp;\n-    assert(k->is_shared_boot_class(), \"must be\");\n-\n-    ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n-    quick_resolve(k, loader_data, Handle(), CHECK_false);\n-    return true;\n-  }\n-#endif \/\/ INCLUDE_CDS\n-\n-  if (!is_wk_klass_loaded(*klassp)) {\n-    Klass* k = resolve_or_fail(symbol, true, CHECK_false);\n-    (*klassp) = InstanceKlass::cast(k);\n-  }\n-  return ((*klassp) != NULL);\n-}\n-\n-void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &start_id, TRAPS) {\n-  assert((int)start_id <= (int)limit_id, \"IDs are out of order!\");\n-  for (int id = (int)start_id; id < (int)limit_id; id++) {\n-    assert(id >= (int)FIRST_WKID && id < (int)WKID_LIMIT, \"oob\");\n-    resolve_wk_klass((WKID)id, CHECK);\n-  }\n-\n-  \/\/ move the starting value forward to the limit:\n-  start_id = limit_id;\n-}\n-\n-void SystemDictionary::resolve_well_known_classes(TRAPS) {\n-  assert(!Object_klass_loaded(), \"well-known classes should only be initialized once\");\n-\n-  \/\/ Create the ModuleEntry for java.base.  This call needs to be done here,\n-  \/\/ after vmSymbols::initialize() is called but before any classes are pre-loaded.\n-  ClassLoader::classLoader_init2(CHECK);\n-\n-  \/\/ Preload commonly used klasses\n-  WKID scan = FIRST_WKID;\n-  \/\/ first do Object, then String, Class\n-#if INCLUDE_CDS\n-  if (UseSharedSpaces) {\n-    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);\n-\n-    \/\/ It's unsafe to access the archived heap regions before they\n-    \/\/ are fixed up, so we must do the fixup as early as possible\n-    \/\/ before the archived java objects are accessed by functions\n-    \/\/ such as java_lang_Class::restore_archived_mirror and\n-    \/\/ ConstantPool::restore_unshareable_info (restores the archived\n-    \/\/ resolved_references array object).\n-    \/\/\n-    \/\/ HeapShared::fixup_mapped_heap_regions() fills the empty\n-    \/\/ spaces in the archived heap regions and may use\n-    \/\/ SystemDictionary::Object_klass(), so we can do this only after\n-    \/\/ Object_klass is resolved. See the above resolve_wk_klasses_through()\n-    \/\/ call. No mirror objects are accessed\/restored in the above call.\n-    \/\/ Mirrors are restored after java.lang.Class is loaded.\n-    HeapShared::fixup_mapped_heap_regions();\n-\n-    \/\/ Initialize the constant pool for the Object_class\n-    assert(Object_klass()->is_shared(), \"must be\");\n-    Object_klass()->constants()->restore_unshareable_info(CHECK);\n-    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);\n-  } else\n-#endif\n-  {\n-    resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);\n-  }\n-\n-  assert(WK_KLASS(Object_klass) != NULL, \"well-known classes should now be initialized\");\n-\n-  java_lang_Object::register_natives(CHECK);\n-\n-  \/\/ Calculate offsets for String and Class classes since they are loaded and\n-  \/\/ can be used after this point.\n-  java_lang_String::compute_offsets();\n-  java_lang_Class::compute_offsets();\n-\n-  \/\/ Fixup mirrors for classes loaded before java.lang.Class.\n-  Universe::initialize_basic_type_mirrors(CHECK);\n-  Universe::fixup_mirrors(CHECK);\n-\n-  \/\/ do a bunch more:\n-  resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);\n-\n-  \/\/ The offsets for jlr.Reference must be computed before\n-  \/\/ InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses\n-  \/\/ the offsets to remove the referent and discovered fields from the oop maps,\n-  \/\/ as they are treated in a special way by the GC. Removing these oops from the\n-  \/\/ oop maps must be done before the usual subclasses of jlr.Reference are loaded.\n-  java_lang_ref_Reference::compute_offsets();\n-\n-  \/\/ Preload ref klasses and set reference types\n-  WK_KLASS(Reference_klass)->set_reference_type(REF_OTHER);\n-  InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));\n-\n-  resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);\n-  WK_KLASS(SoftReference_klass)->set_reference_type(REF_SOFT);\n-  WK_KLASS(WeakReference_klass)->set_reference_type(REF_WEAK);\n-  WK_KLASS(FinalReference_klass)->set_reference_type(REF_FINAL);\n-  WK_KLASS(PhantomReference_klass)->set_reference_type(REF_PHANTOM);\n-\n-  \/\/ JSR 292 classes\n-  WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);\n-  WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);\n-  resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);\n-  resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);\n-  WKID last = WKID_LIMIT;\n-  resolve_wk_klasses_until(last, scan, CHECK);\n-\n-  _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);\n-  _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);\n-  _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);\n-  _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);\n-  _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);\n-  _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);\n-  _box_klasses[T_INT]     = WK_KLASS(Integer_klass);\n-  _box_klasses[T_LONG]    = WK_KLASS(Long_klass);\n-  \/\/_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);\n-  \/\/_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);\n-\n-  if (UseSharedSpaces) {\n-    JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),\n-                      \"All well known classes must be resolved in JVMTI early phase\"));\n-    for (int i = FIRST_WKID; i < last; i++) {\n-      InstanceKlass* k = _well_known_klasses[i];\n-      assert(k->is_shared(), \"must not be replaced by JVMTI class file load hook\");\n-    }\n-  }\n-#endif\n-}\n-\n-\/\/ Tells if a given klass is a box (wrapper class, such as java.lang.Integer).\n-\/\/ If so, returns the basic type it holds.  If not, returns T_OBJECT.\n-BasicType SystemDictionary::box_klass_type(Klass* k) {\n-  assert(k != NULL, \"\");\n-  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-    if (_box_klasses[i] == k)\n-      return (BasicType)i;\n-  }\n-  return T_OBJECT;\n+\/\/ Verify that this placeholder exists since this class is in the middle of loading.\n+void verify_placeholder(Symbol* class_name, ClassLoaderData* loader_data) {\n+  \/\/ Only parallel capable class loaders use placeholder table for define class.\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  unsigned int name_hash = placeholders()->compute_hash(class_name);\n+  Symbol* ph_check =  placeholders()->find_entry(name_hash, class_name, loader_data);\n+  assert(ph_check != NULL, \"This placeholder should exist\");\n@@ -2180,0 +1886,1 @@\n+#endif \/\/ ASSERT\n@@ -2209,2 +1916,0 @@\n-      \/\/ The dictionary only holds instance classes, placeholders\n-      \/\/ also hold array classes.\n@@ -2222,4 +1927,1 @@\n-#ifdef ASSERT\n-    Symbol* ph_check = find_placeholder(name, loader_data);\n-    assert(ph_check == NULL || ph_check == name, \"invalid symbol\");\n-#endif\n+    DEBUG_ONLY(if (is_parallelCapable(class_loader)) verify_placeholder(name, loader_data));\n@@ -2272,6 +1974,0 @@\n-  #ifdef ASSERT\n-    sd_check = dictionary->find_class(hash, name);\n-    assert (sd_check != NULL, \"should have entry in dictionary\");\n-    \/\/ Note: there may be a placeholder entry: for circularity testing\n-    \/\/ or for parallel defines\n-  #endif\n@@ -2615,1 +2311,1 @@\n-  objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);\n+  objArrayHandle appendix_box = oopFactory::new_objArray_handle(vmClasses::Object_klass(), 1, CHECK_NULL);\n@@ -2633,1 +2329,1 @@\n-                         SystemDictionary::MethodHandleNatives_klass(),\n+                         vmClasses::MethodHandleNatives_klass(),\n@@ -2656,2 +2352,2 @@\n-         (InstanceKlass::cast(klass)->is_same_class_package(SystemDictionary::Object_klass()) ||       \/\/ java.lang\n-          InstanceKlass::cast(klass)->is_same_class_package(SystemDictionary::MethodHandle_klass()));  \/\/ java.lang.invoke\n+         (InstanceKlass::cast(klass)->is_same_class_package(vmClasses::Object_klass()) ||       \/\/ java.lang\n+          InstanceKlass::cast(klass)->is_same_class_package(vmClasses::MethodHandle_klass()));  \/\/ java.lang.invoke\n@@ -2726,1 +2422,1 @@\n-  objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));\n+  objArrayHandle pts = oopFactory::new_objArray_handle(vmClasses::Class_klass(), npts, CHECK_(empty));\n@@ -2767,1 +2463,1 @@\n-                         SystemDictionary::MethodHandleNatives_klass(),\n+                         vmClasses::MethodHandleNatives_klass(),\n@@ -2824,1 +2520,1 @@\n-  Handle mname = MemberName_klass()->allocate_instance_handle(CHECK_(empty));\n+  Handle mname = vmClasses::MemberName_klass()->allocate_instance_handle(CHECK_(empty));\n@@ -2853,1 +2549,1 @@\n-                         SystemDictionary::MethodHandleNatives_klass(),\n+                         vmClasses::MethodHandleNatives_klass(),\n@@ -2876,1 +2572,1 @@\n-    appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);\n+    appendix_box = oopFactory::new_objArray_handle(vmClasses::Object_klass(), 1, CHECK);\n@@ -2894,1 +2590,1 @@\n-                         SystemDictionary::MethodHandleNatives_klass(),\n+                         vmClasses::MethodHandleNatives_klass(),\n@@ -2928,4 +2624,0 @@\n-bool SystemDictionary::is_wk_klass_loaded(InstanceKlass* klass) {\n-  return !(klass == NULL || !klass->is_loaded());\n-}\n-\n@@ -2934,1 +2626,1 @@\n-  return !m->is_public() && m->method_holder() == SystemDictionary::Object_klass();\n+  return !m->is_public() && m->method_holder() == vmClasses::Object_klass();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":148,"deletions":456,"binary":false,"changes":604,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-class PlaceholderTable;\n@@ -90,153 +89,0 @@\n-#define WK_KLASS_ENUM_NAME(kname)    kname##_knum\n-\n-\/\/ Certain classes, such as java.lang.Object and java.lang.String,\n-\/\/ are \"well-known\", in the sense that no class loader is allowed\n-\/\/ to provide a different definition.\n-\/\/\n-\/\/ Each well-known class has a short klass name (like object_klass),\n-\/\/ and a vmSymbol name (like java_lang_Object).\n-\/\/\n-\/\/ The order of these definitions is significant: the classes are\n-\/\/ resolved during early VM start-up by resolve_well_known_classes\n-\/\/ in this order. Changing the order may require careful restructuring\n-\/\/ of the VM start-up sequence.\n-\/\/\n-#define WK_KLASSES_DO(do_klass)                                                                                 \\\n-  \/* well-known classes *\/                                                                                      \\\n-  do_klass(Object_klass,                                java_lang_Object                                      ) \\\n-  do_klass(IdentityObject_klass,                        java_lang_IdentityObject                              ) \\\n-  do_klass(String_klass,                                java_lang_String                                      ) \\\n-  do_klass(Class_klass,                                 java_lang_Class                                       ) \\\n-  do_klass(Cloneable_klass,                             java_lang_Cloneable                                   ) \\\n-  do_klass(ClassLoader_klass,                           java_lang_ClassLoader                                 ) \\\n-  do_klass(Serializable_klass,                          java_io_Serializable                                  ) \\\n-  do_klass(System_klass,                                java_lang_System                                      ) \\\n-  do_klass(Throwable_klass,                             java_lang_Throwable                                   ) \\\n-  do_klass(Error_klass,                                 java_lang_Error                                       ) \\\n-  do_klass(ThreadDeath_klass,                           java_lang_ThreadDeath                                 ) \\\n-  do_klass(Exception_klass,                             java_lang_Exception                                   ) \\\n-  do_klass(RuntimeException_klass,                      java_lang_RuntimeException                            ) \\\n-  do_klass(SecurityManager_klass,                       java_lang_SecurityManager                             ) \\\n-  do_klass(ProtectionDomain_klass,                      java_security_ProtectionDomain                        ) \\\n-  do_klass(AccessControlContext_klass,                  java_security_AccessControlContext                    ) \\\n-  do_klass(AccessController_klass,                      java_security_AccessController                        ) \\\n-  do_klass(SecureClassLoader_klass,                     java_security_SecureClassLoader                       ) \\\n-  do_klass(ClassNotFoundException_klass,                java_lang_ClassNotFoundException                      ) \\\n-  do_klass(Record_klass,                                java_lang_Record                                      ) \\\n-  do_klass(NoClassDefFoundError_klass,                  java_lang_NoClassDefFoundError                        ) \\\n-  do_klass(LinkageError_klass,                          java_lang_LinkageError                                ) \\\n-  do_klass(ClassCastException_klass,                    java_lang_ClassCastException                          ) \\\n-  do_klass(ArrayStoreException_klass,                   java_lang_ArrayStoreException                         ) \\\n-  do_klass(VirtualMachineError_klass,                   java_lang_VirtualMachineError                         ) \\\n-  do_klass(InternalError_klass,                         java_lang_InternalError                               ) \\\n-  do_klass(OutOfMemoryError_klass,                      java_lang_OutOfMemoryError                            ) \\\n-  do_klass(StackOverflowError_klass,                    java_lang_StackOverflowError                          ) \\\n-  do_klass(IllegalMonitorStateException_klass,          java_lang_IllegalMonitorStateException                ) \\\n-  do_klass(Reference_klass,                             java_lang_ref_Reference                               ) \\\n-                                                                                                                \\\n-  \/* ref klasses and set reference types *\/                                                                     \\\n-  do_klass(SoftReference_klass,                         java_lang_ref_SoftReference                           ) \\\n-  do_klass(WeakReference_klass,                         java_lang_ref_WeakReference                           ) \\\n-  do_klass(FinalReference_klass,                        java_lang_ref_FinalReference                          ) \\\n-  do_klass(PhantomReference_klass,                      java_lang_ref_PhantomReference                        ) \\\n-  do_klass(Finalizer_klass,                             java_lang_ref_Finalizer                               ) \\\n-                                                                                                                \\\n-  do_klass(Thread_klass,                                java_lang_Thread                                      ) \\\n-  do_klass(ThreadGroup_klass,                           java_lang_ThreadGroup                                 ) \\\n-  do_klass(Properties_klass,                            java_util_Properties                                  ) \\\n-  do_klass(Module_klass,                                java_lang_Module                                      ) \\\n-  do_klass(reflect_AccessibleObject_klass,              java_lang_reflect_AccessibleObject                    ) \\\n-  do_klass(reflect_Field_klass,                         java_lang_reflect_Field                               ) \\\n-  do_klass(reflect_Parameter_klass,                     java_lang_reflect_Parameter                           ) \\\n-  do_klass(reflect_Method_klass,                        java_lang_reflect_Method                              ) \\\n-  do_klass(reflect_Constructor_klass,                   java_lang_reflect_Constructor                         ) \\\n-                                                                                                                \\\n-  \/* NOTE: needed too early in bootstrapping process to have checks based on JDK version *\/                     \\\n-  \/* It's okay if this turns out to be NULL in non-1.4 JDKs. *\/                                                 \\\n-  do_klass(reflect_MagicAccessorImpl_klass,             reflect_MagicAccessorImpl                             ) \\\n-  do_klass(reflect_MethodAccessorImpl_klass,            reflect_MethodAccessorImpl                            ) \\\n-  do_klass(reflect_ConstructorAccessorImpl_klass,       reflect_ConstructorAccessorImpl                       ) \\\n-  do_klass(reflect_DelegatingClassLoader_klass,         reflect_DelegatingClassLoader                         ) \\\n-  do_klass(reflect_ConstantPool_klass,                  reflect_ConstantPool                                  ) \\\n-  do_klass(reflect_UnsafeStaticFieldAccessorImpl_klass, reflect_UnsafeStaticFieldAccessorImpl                 ) \\\n-  do_klass(reflect_CallerSensitive_klass,               reflect_CallerSensitive                               ) \\\n-  do_klass(reflect_NativeConstructorAccessorImpl_klass, reflect_NativeConstructorAccessorImpl                 ) \\\n-                                                                                                                \\\n-  \/* support for dynamic typing; it's OK if these are NULL in earlier JDKs *\/                                   \\\n-  do_klass(DirectMethodHandle_klass,                    java_lang_invoke_DirectMethodHandle                   ) \\\n-  do_klass(MethodHandle_klass,                          java_lang_invoke_MethodHandle                         ) \\\n-  do_klass(VarHandle_klass,                             java_lang_invoke_VarHandle                            ) \\\n-  do_klass(MemberName_klass,                            java_lang_invoke_MemberName                           ) \\\n-  do_klass(ResolvedMethodName_klass,                    java_lang_invoke_ResolvedMethodName                   ) \\\n-  do_klass(MethodHandleNatives_klass,                   java_lang_invoke_MethodHandleNatives                  ) \\\n-  do_klass(LambdaForm_klass,                            java_lang_invoke_LambdaForm                           ) \\\n-  do_klass(MethodType_klass,                            java_lang_invoke_MethodType                           ) \\\n-  do_klass(BootstrapMethodError_klass,                  java_lang_BootstrapMethodError                        ) \\\n-  do_klass(CallSite_klass,                              java_lang_invoke_CallSite                             ) \\\n-  do_klass(NativeEntryPoint_klass,                      jdk_internal_invoke_NativeEntryPoint                  ) \\\n-  do_klass(Context_klass,                               java_lang_invoke_MethodHandleNatives_CallSiteContext  ) \\\n-  do_klass(ConstantCallSite_klass,                      java_lang_invoke_ConstantCallSite                     ) \\\n-  do_klass(MutableCallSite_klass,                       java_lang_invoke_MutableCallSite                      ) \\\n-  do_klass(ValueBootstrapMethods_klass,                 java_lang_invoke_ValueBootstrapMethods                ) \\\n-  do_klass(VolatileCallSite_klass,                      java_lang_invoke_VolatileCallSite                     ) \\\n-  \/* Note: MethodHandle must be first, and VolatileCallSite last in group *\/                                    \\\n-                                                                                                                \\\n-  do_klass(AssertionStatusDirectives_klass,             java_lang_AssertionStatusDirectives                   ) \\\n-  do_klass(StringBuffer_klass,                          java_lang_StringBuffer                                ) \\\n-  do_klass(StringBuilder_klass,                         java_lang_StringBuilder                               ) \\\n-  do_klass(UnsafeConstants_klass,                       jdk_internal_misc_UnsafeConstants                     ) \\\n-  do_klass(internal_Unsafe_klass,                       jdk_internal_misc_Unsafe                              ) \\\n-  do_klass(module_Modules_klass,                        jdk_internal_module_Modules                           ) \\\n-                                                                                                                \\\n-  \/* support for CDS *\/                                                                                         \\\n-  do_klass(ByteArrayInputStream_klass,                  java_io_ByteArrayInputStream                          ) \\\n-  do_klass(URL_klass,                                   java_net_URL                                          ) \\\n-  do_klass(Jar_Manifest_klass,                          java_util_jar_Manifest                                ) \\\n-  do_klass(jdk_internal_loader_BuiltinClassLoader_klass,jdk_internal_loader_BuiltinClassLoader                ) \\\n-  do_klass(jdk_internal_loader_ClassLoaders_klass,      jdk_internal_loader_ClassLoaders                      ) \\\n-  do_klass(jdk_internal_loader_ClassLoaders_AppClassLoader_klass,      jdk_internal_loader_ClassLoaders_AppClassLoader) \\\n-  do_klass(jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass, jdk_internal_loader_ClassLoaders_PlatformClassLoader) \\\n-  do_klass(CodeSource_klass,                            java_security_CodeSource                              ) \\\n-  do_klass(ConcurrentHashMap_klass,                     java_util_concurrent_ConcurrentHashMap                ) \\\n-  do_klass(ArrayList_klass,                             java_util_ArrayList                                   ) \\\n-                                                                                                                \\\n-  do_klass(StackTraceElement_klass,                     java_lang_StackTraceElement                           ) \\\n-                                                                                                                \\\n-  \/* It's okay if this turns out to be NULL in non-1.4 JDKs. *\/                                                 \\\n-  do_klass(nio_Buffer_klass,                            java_nio_Buffer                                       ) \\\n-                                                                                                                \\\n-  \/* Stack Walking *\/                                                                                           \\\n-  do_klass(StackWalker_klass,                           java_lang_StackWalker                                 ) \\\n-  do_klass(AbstractStackWalker_klass,                   java_lang_StackStreamFactory_AbstractStackWalker      ) \\\n-  do_klass(StackFrameInfo_klass,                        java_lang_StackFrameInfo                              ) \\\n-  do_klass(LiveStackFrameInfo_klass,                    java_lang_LiveStackFrameInfo                          ) \\\n-                                                                                                                \\\n-  \/* support for stack dump lock analysis *\/                                                                    \\\n-  do_klass(java_util_concurrent_locks_AbstractOwnableSynchronizer_klass, java_util_concurrent_locks_AbstractOwnableSynchronizer) \\\n-                                                                                                                \\\n-  \/* boxing klasses *\/                                                                                          \\\n-  do_klass(Boolean_klass,                               java_lang_Boolean                                     ) \\\n-  do_klass(Character_klass,                             java_lang_Character                                   ) \\\n-  do_klass(Float_klass,                                 java_lang_Float                                       ) \\\n-  do_klass(Double_klass,                                java_lang_Double                                      ) \\\n-  do_klass(Byte_klass,                                  java_lang_Byte                                        ) \\\n-  do_klass(Short_klass,                                 java_lang_Short                                       ) \\\n-  do_klass(Integer_klass,                               java_lang_Integer                                     ) \\\n-  do_klass(Long_klass,                                  java_lang_Long                                        ) \\\n-                                                                                                                \\\n-  \/* force inline of iterators *\/                                                                               \\\n-  do_klass(Iterator_klass,                              java_util_Iterator                                    ) \\\n-                                                                                                                \\\n-  do_klass(jdk_internal_vm_jni_SubElementSelector_klass, jdk_internal_vm_jni_SubElementSelector               ) \\\n-  \/* support for records *\/                                                                                     \\\n-  do_klass(RecordComponent_klass,                       java_lang_reflect_RecordComponent                     ) \\\n-                                                                                                                \\\n-  \/* support for vectors*\/                                                                                      \\\n-  do_klass(vector_VectorSupport_klass,                  jdk_internal_vm_vector_VectorSupport                  ) \\\n-  do_klass(vector_VectorPayload_klass,                  jdk_internal_vm_vector_VectorPayload                  ) \\\n-  do_klass(vector_Vector_klass,                         jdk_internal_vm_vector_Vector                         ) \\\n-  do_klass(vector_VectorMask_klass,                     jdk_internal_vm_vector_VectorMask                     ) \\\n-  do_klass(vector_VectorShuffle_klass,                  jdk_internal_vm_vector_VectorShuffle                  ) \\\n-                                                                                                                \\\n-  \/*end*\/\n-\n@@ -245,0 +91,1 @@\n+  friend class vmClasses;\n@@ -248,11 +95,0 @@\n-  enum WKID {\n-    NO_WKID = 0,\n-\n-    #define WK_KLASS_ENUM(name, symbol) WK_KLASS_ENUM_NAME(name), WK_KLASS_ENUM_NAME(symbol) = WK_KLASS_ENUM_NAME(name),\n-    WK_KLASSES_DO(WK_KLASS_ENUM)\n-    #undef WK_KLASS_ENUM\n-\n-    WKID_LIMIT,\n-\n-    FIRST_WKID = NO_WKID + 1\n-  };\n@@ -268,6 +104,3 @@\n-  static Klass* resolve_or_fail(Symbol* class_name, bool throw_error, TRAPS);\n-protected:\n-  \/\/ handle error translation for resolve_or_null results\n-  static Klass* handle_resolution_exception(Symbol* class_name, bool throw_error, Klass* klass, TRAPS);\n-\n-public:\n+  static Klass* resolve_or_fail(Symbol* class_name, bool throw_error, TRAPS) {\n+    return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);\n+  }\n@@ -279,1 +112,3 @@\n-  static Klass* resolve_or_null(Symbol* class_name, TRAPS);\n+  static Klass* resolve_or_null(Symbol* class_name, TRAPS) {\n+    return resolve_or_null(class_name, Handle(), Handle(), THREAD);\n+  }\n@@ -283,3 +118,3 @@\n-  \/\/ \"child_name\" is the class whose super class or interface is being resolved.\n-  static InstanceKlass* resolve_super_or_fail(Symbol* child_name,\n-                                              Symbol* class_name,\n+  \/\/ \"class_name\" is the class whose super class or interface is being resolved.\n+  static InstanceKlass* resolve_super_or_fail(Symbol* class_name,\n+                                              Symbol* super_name,\n@@ -320,3 +155,3 @@\n-                                               Handle class_loader,\n-                                               Handle protection_domain,\n-                                               TRAPS);\n+                                             Handle class_loader,\n+                                             Handle protection_domain,\n+                                             TRAPS);\n@@ -360,3 +195,0 @@\n-  \/\/ System loader lock\n-  static oop system_loader_lock();\n-\n@@ -366,1 +198,0 @@\n-public:\n@@ -378,49 +209,0 @@\n-  \/\/ Checked fast access to the well-known classes -- so that you don't try to use them\n-  \/\/ before they are resolved.\n-  static InstanceKlass* check_klass(InstanceKlass* k) {\n-    assert(k != NULL, \"klass not loaded\");\n-    return k;\n-  }\n-\n-  static bool resolve_wk_klass(WKID id, TRAPS);\n-  static InstanceKlass* check_klass_ValhallaClasses(InstanceKlass* k) { return k; }\n-  static void resolve_wk_klasses_until(WKID limit_id, WKID &start_id, TRAPS);\n-  static void resolve_wk_klasses_through(WKID end_id, WKID &start_id, TRAPS) {\n-    int limit = (int)end_id + 1;\n-    resolve_wk_klasses_until((WKID) limit, start_id, THREAD);\n-  }\n-public:\n-  #define WK_KLASS(name) _well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)]\n-\n-  #define WK_KLASS_DECLARE(name, symbol) \\\n-    static InstanceKlass* name() { return check_klass(_well_known_klasses[WK_KLASS_ENUM_NAME(name)]); } \\\n-    static InstanceKlass** name##_addr() {                                                              \\\n-      return &_well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)];                          \\\n-    }                                                                                                   \\\n-    static bool name##_is_loaded() {                                                                    \\\n-      return is_wk_klass_loaded(WK_KLASS(name));                                                        \\\n-    }\n-  WK_KLASSES_DO(WK_KLASS_DECLARE);\n-  #undef WK_KLASS_DECLARE\n-\n-  static InstanceKlass* well_known_klass(WKID id) {\n-    assert(id >= (int)FIRST_WKID && id < (int)WKID_LIMIT, \"oob\");\n-    return _well_known_klasses[id];\n-  }\n-\n-  static InstanceKlass** well_known_klass_addr(WKID id) {\n-    assert(id >= (int)FIRST_WKID && id < (int)WKID_LIMIT, \"oob\");\n-    return &_well_known_klasses[id];\n-  }\n-  static void well_known_klasses_do(MetaspaceClosure* it);\n-\n-  static InstanceKlass* box_klass(BasicType t) {\n-    assert((uint)t < T_VOID+1, \"range check\");\n-    return check_klass(_box_klasses[t]);\n-  }\n-  static BasicType box_klass_type(Klass* k);  \/\/ inverse of box_klass\n-#ifdef ASSERT\n-  static bool is_well_known_klass(Klass* k);\n-  static bool is_well_known_klass(Symbol* class_name);\n-#endif\n-\n@@ -431,1 +213,0 @@\n-  static bool is_wk_klass_loaded(InstanceKlass* klass);\n@@ -434,6 +215,0 @@\n-  static bool Object_klass_loaded()         { return is_wk_klass_loaded(WK_KLASS(Object_klass));             }\n-  static bool Class_klass_loaded()          { return is_wk_klass_loaded(WK_KLASS(Class_klass));              }\n-  static bool Cloneable_klass_loaded()      { return is_wk_klass_loaded(WK_KLASS(Cloneable_klass));          }\n-  static bool Parameter_klass_loaded()      { return is_wk_klass_loaded(WK_KLASS(reflect_Parameter_klass));  }\n-  static bool ClassLoader_klass_loaded()    { return is_wk_klass_loaded(WK_KLASS(ClassLoader_klass));        }\n-\n@@ -451,6 +226,0 @@\n-protected:\n-  \/\/ Mirrors for primitive classes (created eagerly)\n-  static oop check_mirror(oop m) {\n-    assert(m != NULL, \"mirror not initialized\");\n-    return m;\n-  }\n@@ -459,5 +228,0 @@\n-  \/\/ Note:  java_lang_Class::primitive_type is the inverse of java_mirror\n-\n-  \/\/ Check class loader constraints\n-  static bool add_loader_constraint(Symbol* name, Klass* klass_being_linked,  Handle loader1,\n-                                    Handle loader2, TRAPS);\n@@ -537,10 +301,1 @@\n- protected:\n-\n-  enum Constants {\n-    _loader_constraint_size = 107,                     \/\/ number of entries in constraint table\n-    _resolution_error_size  = 107,                     \/\/ number of entries in resolution error table\n-    _invoke_method_size     = 139,                     \/\/ number of entries in invoke method table\n-    _placeholder_table_size = 1009                     \/\/ number of entries in hash table for placeholders\n-  };\n-\n-\n+ private:\n@@ -549,3 +304,0 @@\n-  \/\/ Hashtable holding placeholders for classes being loaded.\n-  static PlaceholderTable*       _placeholders;\n-\n@@ -565,0 +317,9 @@\n+  static InstanceKlass* _well_known_klasses[];\n+\n+private:\n+  \/\/ table of box klasses (int_klass, etc.)\n+  static InstanceKlass* _box_klasses[T_VOID+1];\n+\n+  static OopHandle  _java_system_loader;\n+  static OopHandle  _java_platform_loader;\n+\n@@ -570,2 +331,0 @@\n-  friend class TraversePlaceholdersClosure;\n-  static PlaceholderTable*   placeholders() { return _placeholders; }\n@@ -575,1 +334,1 @@\n-  static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld);\n+private:\n@@ -582,3 +341,11 @@\n-  static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);\n-  static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);\n-  static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);\n+  static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name,\n+                                                       Handle class_loader,\n+                                                       Handle protection_domain, TRAPS);\n+  static Klass* resolve_array_class_or_null(Symbol* class_name,\n+                                            Handle class_loader,\n+                                            Handle protection_domain, TRAPS);\n+  static InstanceKlass* handle_parallel_super_load(Symbol* class_name,\n+                                                   Symbol* supername,\n+                                                   Handle class_loader,\n+                                                   Handle protection_domain,\n+                                                   Handle lockObject, TRAPS);\n@@ -591,3 +358,8 @@\n-  static InstanceKlass* find_or_define_instance_class(Symbol* class_name,\n-                                                Handle class_loader,\n-                                                InstanceKlass* k, TRAPS);\n+  static InstanceKlass* find_or_define_helper(Symbol* class_name,\n+                                              Handle class_loader,\n+                                              InstanceKlass* k, TRAPS);\n+  static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);\n+  static bool is_parallelDefine(Handle class_loader);\n+  static Handle compute_loader_lock_object(Thread* thread, Handle class_loader);\n+  static void check_loader_lock_contention(Thread* thread, Handle loader_lock);\n+\n@@ -601,1 +373,1 @@\n-  static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,\n+  static bool check_shared_class_super_type(InstanceKlass* klass, InstanceKlass* super,\n@@ -606,0 +378,8 @@\n+  \/\/ Second part of load_shared_class\n+  static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;\n+protected:\n+  \/\/ Used by SystemDictionaryShared\n+\n+  static bool add_loader_constraint(Symbol* name, Klass* klass_being_linked,  Handle loader1,\n+                                    Handle loader2, TRAPS);\n+  static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld);\n@@ -617,2 +397,0 @@\n-  \/\/ Second part of load_shared_class\n-  static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;\n@@ -622,5 +400,3 @@\n-  static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);\n-  static Handle compute_loader_lock_object(Thread* thread, Handle class_loader);\n-  static void check_loader_lock_contention(Thread* thread, Handle loader_lock);\n-  static bool is_parallelDefine(Handle class_loader);\n-\n+  static InstanceKlass* find_or_define_instance_class(Symbol* class_name,\n+                                                      Handle class_loader,\n+                                                      InstanceKlass* k, TRAPS);\n@@ -653,5 +429,0 @@\n-  \/\/ Resolve well-known classes so they can be used like SystemDictionary::String_klass()\n-  static void resolve_well_known_classes(TRAPS);\n-  \/\/ quick resolve using CDS for well-known classes only.\n-  static void quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) NOT_CDS_RETURN;\n-\n@@ -665,9 +436,0 @@\n-  static InstanceKlass* _well_known_klasses[];\n-\n-  \/\/ table of box klasses (int_klass, etc.)\n-  static InstanceKlass* _box_klasses[T_VOID+1];\n-\n-private:\n-  static OopHandle  _java_system_loader;\n-  static OopHandle  _java_platform_loader;\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":55,"deletions":293,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -74,3 +76,3 @@\n-      this_class == SystemDictionary::Cloneable_klass() ||\n-      this_class == SystemDictionary::Serializable_klass() ||\n-      this_class == SystemDictionary::IdentityObject_klass();\n+      this_class == vmClasses::Cloneable_klass() ||\n+      this_class == vmClasses::Serializable_klass() ||\n+      this_class == vmClasses::IdentityObject_klass();\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -270,1 +271,1 @@\n-  Klass* refl_magic_klass = SystemDictionary::reflect_MagicAccessorImpl_klass();\n+  Klass* refl_magic_klass = vmClasses::reflect_MagicAccessorImpl_klass();\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_VMCLASSMACROS_HPP\n+#define SHARE_CLASSFILE_VMCLASSMACROS_HPP\n+\n+\/\/ _VM_CLASS_ENUM - internal: should be used only by vmClass*.{hpp,cpp}\n+#define _VM_CLASS_ENUM(kname)    kname##_knum\n+\n+#define VM_CLASS_ID(kname)      vmClassID::_VM_CLASS_ENUM(kname)\n+\n+\/\/ VM_CLASSES_DO iterates the classes that are directly referenced\n+\/\/ by the VM, suhch as java.lang.Object and java.lang.String. These\n+\/\/ classes are resolved at VM bootstrap, before any Java code is executed,\n+\/\/ so no class loader is able to provide a different definition.\n+\/\/\n+\/\/ Each VM class has a short klass name (like Object_klass),\n+\/\/ and a vmSymbol name (like java_lang_Object). Both of these can\n+\/\/ be used to find the vmClassID for this class. The following two\n+\/\/ macros will evaluate to the same value:\n+\/\/\n+\/\/    VM_CLASS_ID(Object_klass)\n+\/\/    VM_CLASS_ID(java_lang_Object)\n+\/\/\n+\/\/ The order of these definitions is significant: the classes are\n+\/\/ resolved by vmClasses::resolve_all() in this order. Changing the\n+\/\/ order may require careful restructuring of the VM start-up sequence.\n+\/\/\n+#define VM_CLASSES_DO(do_klass)                                                                                 \\\n+  \/* well-known classes *\/                                                                                      \\\n+  do_klass(Object_klass,                                java_lang_Object                                      ) \\\n+  do_klass(IdentityObject_klass,                        java_lang_IdentityObject                              ) \\\n+  do_klass(String_klass,                                java_lang_String                                      ) \\\n+  do_klass(Class_klass,                                 java_lang_Class                                       ) \\\n+  do_klass(Cloneable_klass,                             java_lang_Cloneable                                   ) \\\n+  do_klass(ClassLoader_klass,                           java_lang_ClassLoader                                 ) \\\n+  do_klass(Serializable_klass,                          java_io_Serializable                                  ) \\\n+  do_klass(System_klass,                                java_lang_System                                      ) \\\n+  do_klass(Throwable_klass,                             java_lang_Throwable                                   ) \\\n+  do_klass(Error_klass,                                 java_lang_Error                                       ) \\\n+  do_klass(ThreadDeath_klass,                           java_lang_ThreadDeath                                 ) \\\n+  do_klass(Exception_klass,                             java_lang_Exception                                   ) \\\n+  do_klass(RuntimeException_klass,                      java_lang_RuntimeException                            ) \\\n+  do_klass(SecurityManager_klass,                       java_lang_SecurityManager                             ) \\\n+  do_klass(ProtectionDomain_klass,                      java_security_ProtectionDomain                        ) \\\n+  do_klass(AccessControlContext_klass,                  java_security_AccessControlContext                    ) \\\n+  do_klass(AccessController_klass,                      java_security_AccessController                        ) \\\n+  do_klass(SecureClassLoader_klass,                     java_security_SecureClassLoader                       ) \\\n+  do_klass(ClassNotFoundException_klass,                java_lang_ClassNotFoundException                      ) \\\n+  do_klass(Record_klass,                                java_lang_Record                                      ) \\\n+  do_klass(NoClassDefFoundError_klass,                  java_lang_NoClassDefFoundError                        ) \\\n+  do_klass(LinkageError_klass,                          java_lang_LinkageError                                ) \\\n+  do_klass(ClassCastException_klass,                    java_lang_ClassCastException                          ) \\\n+  do_klass(ArrayStoreException_klass,                   java_lang_ArrayStoreException                         ) \\\n+  do_klass(VirtualMachineError_klass,                   java_lang_VirtualMachineError                         ) \\\n+  do_klass(InternalError_klass,                         java_lang_InternalError                               ) \\\n+  do_klass(OutOfMemoryError_klass,                      java_lang_OutOfMemoryError                            ) \\\n+  do_klass(StackOverflowError_klass,                    java_lang_StackOverflowError                          ) \\\n+  do_klass(IllegalMonitorStateException_klass,          java_lang_IllegalMonitorStateException                ) \\\n+  do_klass(Reference_klass,                             java_lang_ref_Reference                               ) \\\n+                                                                                                                \\\n+  \/* ref klasses and set reference types *\/                                                                     \\\n+  do_klass(SoftReference_klass,                         java_lang_ref_SoftReference                           ) \\\n+  do_klass(WeakReference_klass,                         java_lang_ref_WeakReference                           ) \\\n+  do_klass(FinalReference_klass,                        java_lang_ref_FinalReference                          ) \\\n+  do_klass(PhantomReference_klass,                      java_lang_ref_PhantomReference                        ) \\\n+  do_klass(Finalizer_klass,                             java_lang_ref_Finalizer                               ) \\\n+                                                                                                                \\\n+  do_klass(Thread_klass,                                java_lang_Thread                                      ) \\\n+  do_klass(ThreadGroup_klass,                           java_lang_ThreadGroup                                 ) \\\n+  do_klass(Properties_klass,                            java_util_Properties                                  ) \\\n+  do_klass(Module_klass,                                java_lang_Module                                      ) \\\n+  do_klass(reflect_AccessibleObject_klass,              java_lang_reflect_AccessibleObject                    ) \\\n+  do_klass(reflect_Field_klass,                         java_lang_reflect_Field                               ) \\\n+  do_klass(reflect_Parameter_klass,                     java_lang_reflect_Parameter                           ) \\\n+  do_klass(reflect_Method_klass,                        java_lang_reflect_Method                              ) \\\n+  do_klass(reflect_Constructor_klass,                   java_lang_reflect_Constructor                         ) \\\n+                                                                                                                \\\n+  \/* NOTE: needed too early in bootstrapping process to have checks based on JDK version *\/                     \\\n+  \/* It's okay if this turns out to be NULL in non-1.4 JDKs. *\/                                                 \\\n+  do_klass(reflect_MagicAccessorImpl_klass,             reflect_MagicAccessorImpl                             ) \\\n+  do_klass(reflect_MethodAccessorImpl_klass,            reflect_MethodAccessorImpl                            ) \\\n+  do_klass(reflect_ConstructorAccessorImpl_klass,       reflect_ConstructorAccessorImpl                       ) \\\n+  do_klass(reflect_DelegatingClassLoader_klass,         reflect_DelegatingClassLoader                         ) \\\n+  do_klass(reflect_ConstantPool_klass,                  reflect_ConstantPool                                  ) \\\n+  do_klass(reflect_UnsafeStaticFieldAccessorImpl_klass, reflect_UnsafeStaticFieldAccessorImpl                 ) \\\n+  do_klass(reflect_CallerSensitive_klass,               reflect_CallerSensitive                               ) \\\n+  do_klass(reflect_NativeConstructorAccessorImpl_klass, reflect_NativeConstructorAccessorImpl                 ) \\\n+                                                                                                                \\\n+  \/* support for dynamic typing; it's OK if these are NULL in earlier JDKs *\/                                   \\\n+  do_klass(DirectMethodHandle_klass,                    java_lang_invoke_DirectMethodHandle                   ) \\\n+  do_klass(MethodHandle_klass,                          java_lang_invoke_MethodHandle                         ) \\\n+  do_klass(VarHandle_klass,                             java_lang_invoke_VarHandle                            ) \\\n+  do_klass(MemberName_klass,                            java_lang_invoke_MemberName                           ) \\\n+  do_klass(ResolvedMethodName_klass,                    java_lang_invoke_ResolvedMethodName                   ) \\\n+  do_klass(MethodHandleNatives_klass,                   java_lang_invoke_MethodHandleNatives                  ) \\\n+  do_klass(LambdaForm_klass,                            java_lang_invoke_LambdaForm                           ) \\\n+  do_klass(MethodType_klass,                            java_lang_invoke_MethodType                           ) \\\n+  do_klass(BootstrapMethodError_klass,                  java_lang_BootstrapMethodError                        ) \\\n+  do_klass(CallSite_klass,                              java_lang_invoke_CallSite                             ) \\\n+  do_klass(NativeEntryPoint_klass,                      jdk_internal_invoke_NativeEntryPoint                  ) \\\n+  do_klass(Context_klass,                               java_lang_invoke_MethodHandleNatives_CallSiteContext  ) \\\n+  do_klass(ConstantCallSite_klass,                      java_lang_invoke_ConstantCallSite                     ) \\\n+  do_klass(MutableCallSite_klass,                       java_lang_invoke_MutableCallSite                      ) \\\n+  do_klass(ValueBootstrapMethods_klass,                 java_lang_invoke_ValueBootstrapMethods                ) \\\n+  do_klass(VolatileCallSite_klass,                      java_lang_invoke_VolatileCallSite                     ) \\\n+  \/* Note: MethodHandle must be first, and VolatileCallSite last in group *\/                                    \\\n+                                                                                                                \\\n+  do_klass(AssertionStatusDirectives_klass,             java_lang_AssertionStatusDirectives                   ) \\\n+  do_klass(StringBuffer_klass,                          java_lang_StringBuffer                                ) \\\n+  do_klass(StringBuilder_klass,                         java_lang_StringBuilder                               ) \\\n+  do_klass(UnsafeConstants_klass,                       jdk_internal_misc_UnsafeConstants                     ) \\\n+  do_klass(internal_Unsafe_klass,                       jdk_internal_misc_Unsafe                              ) \\\n+  do_klass(module_Modules_klass,                        jdk_internal_module_Modules                           ) \\\n+                                                                                                                \\\n+  \/* support for CDS *\/                                                                                         \\\n+  do_klass(ByteArrayInputStream_klass,                  java_io_ByteArrayInputStream                          ) \\\n+  do_klass(URL_klass,                                   java_net_URL                                          ) \\\n+  do_klass(Jar_Manifest_klass,                          java_util_jar_Manifest                                ) \\\n+  do_klass(jdk_internal_loader_BuiltinClassLoader_klass,jdk_internal_loader_BuiltinClassLoader                ) \\\n+  do_klass(jdk_internal_loader_ClassLoaders_klass,      jdk_internal_loader_ClassLoaders                      ) \\\n+  do_klass(jdk_internal_loader_ClassLoaders_AppClassLoader_klass,      jdk_internal_loader_ClassLoaders_AppClassLoader) \\\n+  do_klass(jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass, jdk_internal_loader_ClassLoaders_PlatformClassLoader) \\\n+  do_klass(CodeSource_klass,                            java_security_CodeSource                              ) \\\n+  do_klass(ConcurrentHashMap_klass,                     java_util_concurrent_ConcurrentHashMap                ) \\\n+  do_klass(ArrayList_klass,                             java_util_ArrayList                                   ) \\\n+                                                                                                                \\\n+  do_klass(StackTraceElement_klass,                     java_lang_StackTraceElement                           ) \\\n+                                                                                                                \\\n+  \/* It's okay if this turns out to be NULL in non-1.4 JDKs. *\/                                                 \\\n+  do_klass(nio_Buffer_klass,                            java_nio_Buffer                                       ) \\\n+                                                                                                                \\\n+  \/* Stack Walking *\/                                                                                           \\\n+  do_klass(StackWalker_klass,                           java_lang_StackWalker                                 ) \\\n+  do_klass(AbstractStackWalker_klass,                   java_lang_StackStreamFactory_AbstractStackWalker      ) \\\n+  do_klass(StackFrameInfo_klass,                        java_lang_StackFrameInfo                              ) \\\n+  do_klass(LiveStackFrameInfo_klass,                    java_lang_LiveStackFrameInfo                          ) \\\n+                                                                                                                \\\n+  \/* support for stack dump lock analysis *\/                                                                    \\\n+  do_klass(java_util_concurrent_locks_AbstractOwnableSynchronizer_klass, java_util_concurrent_locks_AbstractOwnableSynchronizer) \\\n+                                                                                                                \\\n+  \/* boxing klasses *\/                                                                                          \\\n+  do_klass(Boolean_klass,                               java_lang_Boolean                                     ) \\\n+  do_klass(Character_klass,                             java_lang_Character                                   ) \\\n+  do_klass(Float_klass,                                 java_lang_Float                                       ) \\\n+  do_klass(Double_klass,                                java_lang_Double                                      ) \\\n+  do_klass(Byte_klass,                                  java_lang_Byte                                        ) \\\n+  do_klass(Short_klass,                                 java_lang_Short                                       ) \\\n+  do_klass(Integer_klass,                               java_lang_Integer                                     ) \\\n+  do_klass(Long_klass,                                  java_lang_Long                                        ) \\\n+                                                                                                                \\\n+  \/* force inline of iterators *\/                                                                               \\\n+  do_klass(Iterator_klass,                              java_util_Iterator                                    ) \\\n+                                                                                                                \\\n+  do_klass(jdk_internal_vm_jni_SubElementSelector_klass, jdk_internal_vm_jni_SubElementSelector               ) \\\n+  \/* support for records *\/                                                                                     \\\n+  do_klass(RecordComponent_klass,                       java_lang_reflect_RecordComponent                     ) \\\n+                                                                                                                \\\n+  \/* support for vectors*\/                                                                                      \\\n+  do_klass(vector_VectorSupport_klass,                  jdk_internal_vm_vector_VectorSupport                  ) \\\n+  do_klass(vector_VectorPayload_klass,                  jdk_internal_vm_vector_VectorPayload                  ) \\\n+  do_klass(vector_Vector_klass,                         jdk_internal_vm_vector_Vector                         ) \\\n+  do_klass(vector_VectorMask_klass,                     jdk_internal_vm_vector_VectorMask                     ) \\\n+  do_klass(vector_VectorShuffle_klass,                  jdk_internal_vm_vector_VectorShuffle                  ) \\\n+                                                                                                                \\\n+  \/*end*\/\n+\n+#endif \/\/ SHARE_CLASSFILE_VMCLASSMACROS_HPP\n+\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+#include \"jvm_constants.h\"\n+#include \"jvm_io.h\"\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"oops\/method.hpp\"\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-  return _oop_recorder->is_complete() || _oop_recorder->is_complete();\n+  return _oop_recorder->is_complete();\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -63,0 +63,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -461,1 +462,1 @@\n-    task = CompilationPolicy::policy()->select_task(this);\n+    task = CompilationPolicy::select_task(this);\n@@ -634,2 +635,2 @@\n-  _c1_count = CompilationPolicy::policy()->compiler_count(CompLevel_simple);\n-  _c2_count = CompilationPolicy::policy()->compiler_count(CompLevel_full_optimization);\n+  _c1_count = CompilationPolicy::c1_count();\n+  _c2_count = CompilationPolicy::c2_count();\n@@ -797,1 +798,1 @@\n-                       SystemDictionary::Thread_klass(),\n+                       vmClasses::Thread_klass(),\n@@ -1227,5 +1228,3 @@\n-  if (TieredCompilation) {\n-    \/\/ Tiered policy requires MethodCounters to exist before adding a method to\n-    \/\/ the queue. Create if we don't have them yet.\n-    method->get_method_counters(thread);\n-  }\n+  \/\/ Tiered policy requires MethodCounters to exist before adding a method to\n+  \/\/ the queue. Create if we don't have them yet.\n+  method->get_method_counters(thread);\n@@ -1276,1 +1275,1 @@\n-              (vfst.method()->method_holder()->is_subclass_of(SystemDictionary::ClassLoader_klass()) &&\n+              (vfst.method()->method_holder()->is_subclass_of(vmClasses::ClassLoader_klass()) &&\n@@ -1381,3 +1380,0 @@\n-  assert(!TieredCompilation || comp_level <= TieredStopAtLevel, \"Invalid compilation level\");\n-  \/\/ allow any levels for WhiteBox\n-  assert(WhiteBoxAPI || TieredCompilation || comp_level == CompLevel_highest_tier, \"only CompLevel_highest_tier must be used in non-tiered\");\n@@ -1389,2 +1385,1 @@\n-  if (comp == NULL || !comp->can_compile_method(method) ||\n-      compilation_is_prohibited(method, osr_bci, comp_level, directive->ExcludeOption)) {\n+  if (comp == NULL || compilation_is_prohibited(method, osr_bci, comp_level, directive->ExcludeOption)) {\n@@ -1413,5 +1408,0 @@\n-#ifndef TIERED\n-    \/\/ seems like an assert of dubious value\n-    assert(comp_level == CompLevel_highest_tier,\n-           \"all OSR compiles are assumed to be at a single compilation level\");\n-#endif \/\/ TIERED\n@@ -1503,1 +1493,0 @@\n-      CompilationPolicy::policy()->delay_compilation(method());\n@@ -1573,2 +1562,1 @@\n-  if (is_native &&\n-      (!CICompileNatives || comp == NULL || !comp->supports_native())) {\n+  if (is_native && (!CICompileNatives || comp == NULL)) {\n@@ -1581,2 +1569,1 @@\n-  if (is_osr &&\n-      (!CICompileOSR || comp == NULL || !comp->supports_osr())) {\n+  if (is_osr && (!CICompileOSR || comp == NULL)) {\n@@ -2226,1 +2213,1 @@\n-  should_break = directive->BreakAtExecuteOption || task->check_break_at_flags();\n+  should_break = directive->BreakAtCompileOption || task->check_break_at_flags();\n@@ -2311,1 +2298,1 @@\n-      ci_env.record_method_not_compilable(\"no compiler\", !TieredCompilation);\n+      ci_env.record_method_not_compilable(\"no compiler\");\n@@ -2334,1 +2321,1 @@\n-      ci_env.record_method_not_compilable(\"compile failed\", !TieredCompilation);\n+      ci_env.record_method_not_compilable(\"compile failed\");\n@@ -2687,0 +2674,4 @@\n+jlong CompileBroker::total_compilation_ticks() {\n+  return _perf_total_compilation != NULL ? _perf_total_compilation->get_value() : 0;\n+}\n+\n@@ -2716,1 +2707,1 @@\n-    for (int tier = CompLevel_simple; tier <= CompLevel_highest_tier; tier++) {\n+    for (int tier = CompLevel_simple; tier <= CompilationPolicy::highest_compile_level(); tier++) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,1 +280,1 @@\n-#ifndef TIERED\n+#ifndef COMPILER2\n@@ -287,1 +287,1 @@\n-#endif \/\/ !TIERED\n+#endif \/\/ !COMPILER2\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -62,1 +62,0 @@\n-    _rdcq(&_rdc_local_qset),\n@@ -81,1 +80,1 @@\n-                          ? SystemDictionary::String_klass()\n+                          ? vmClasses::String_klass()\n@@ -89,1 +88,1 @@\n-  assert(SystemDictionary::String_klass()->is_final(), \"precondition\");\n+  assert(vmClasses::String_klass()->is_final(), \"precondition\");\n@@ -117,1 +116,0 @@\n-  _rdc_local_qset.flush_queue(_rdcq);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-#include \"runtime\/perfData.hpp\"\n+#include \"runtime\/perfDataTypes.hpp\"\n@@ -249,8 +249,1 @@\n-  void set_gc_cause(GCCause::Cause v) {\n-     if (UsePerfData) {\n-       _gc_lastcause = _gc_cause;\n-       _perf_gc_lastcause->set_value(GCCause::to_string(_gc_lastcause));\n-       _perf_gc_cause->set_value(GCCause::to_string(v));\n-     }\n-    _gc_cause = v;\n-  }\n+  void set_gc_cause(GCCause::Cause v);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"gc\/shared\/accessBarrierSupport.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n@@ -33,0 +31,1 @@\n+class ShenandoahHeap;\n@@ -37,1 +36,1 @@\n-  ShenandoahHeap* _heap;\n+  ShenandoahHeap* const _heap;\n@@ -75,4 +74,0 @@\n-  bool is_a(BarrierSet::Name bsn);\n-\n-  bool is_aligned(HeapWord* hw);\n-\n@@ -162,1 +157,1 @@\n-    \/\/ Needed for loads on non-heap weak references\n+    \/\/ Support for concurrent roots evacuation, updating and weak roots clearing\n@@ -166,1 +161,1 @@\n-    \/\/ Used for catching bad stores\n+    \/\/ Support for concurrent roots marking\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/accessBarrierSupport.inline.hpp\"\n@@ -38,1 +38,0 @@\n-#include \"memory\/iterator.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"oops\/method.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"runtime\/osThread.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvm_io.h\"\n@@ -29,0 +30,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -517,1 +519,1 @@\n-    if (!PENDING_EXCEPTION->is_a(SystemDictionary::Error_klass())) {\n+    if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n@@ -552,1 +554,1 @@\n-        assert((PENDING_EXCEPTION->is_a(SystemDictionary::OutOfMemoryError_klass())),\n+        assert((PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())),\n@@ -599,1 +601,1 @@\n-                                 SystemDictionary::StackOverflowError_klass(),\n+                                 vmClasses::StackOverflowError_klass(),\n@@ -608,1 +610,1 @@\n-                                 SystemDictionary::StackOverflowError_klass(),\n+                                 vmClasses::StackOverflowError_klass(),\n@@ -727,1 +729,1 @@\n-    assert(h_exception->is_a(SystemDictionary::Throwable_klass()),\n+    assert(h_exception->is_a(vmClasses::Throwable_klass()),\n@@ -1021,1 +1023,1 @@\n-  if (!exception->is_a(SystemDictionary::ThreadDeath_klass())) {\n+  if (!exception->is_a(vmClasses::ThreadDeath_klass())) {\n@@ -1023,1 +1025,1 @@\n-                       SystemDictionary::IllegalMonitorStateException_klass(),\n+                       vmClasses::IllegalMonitorStateException_klass(),\n@@ -1089,1 +1091,1 @@\n-    if (resolved_method->method_holder() == SystemDictionary::Object_klass()) {\n+    if (resolved_method->method_holder() == vmClasses::Object_klass()) {\n@@ -1271,1 +1273,1 @@\n-  nmethod* osr_nm = CompilationPolicy::policy()->event(method, method, branch_bci, bci, CompLevel_none, NULL, THREAD);\n+  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, NULL, THREAD);\n@@ -1311,19 +1313,0 @@\n-JRT_ENTRY(void, InterpreterRuntime::profile_method(JavaThread* thread))\n-  \/\/ use UnlockFlagSaver to clear and restore the _do_not_unlock_if_synchronized\n-  \/\/ flag, in case this method triggers classloading which will call into Java.\n-  UnlockFlagSaver fs(thread);\n-\n-  assert(ProfileInterpreter, \"must be profiling interpreter\");\n-  LastFrameAccessor last_frame(thread);\n-  assert(last_frame.is_interpreted_frame(), \"must come from interpreter\");\n-  methodHandle method(thread, last_frame.method());\n-  Method::build_interpreter_method_data(method, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    \/\/ Only metaspace OOM is expected. No Java code executed.\n-    assert((PENDING_EXCEPTION->is_a(SystemDictionary::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n-    CLEAR_PENDING_EXCEPTION;\n-    \/\/ and fall through...\n-  }\n-JRT_END\n-\n-\n@@ -1383,1 +1366,1 @@\n-    assert((PENDING_EXCEPTION->is_a(SystemDictionary::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n+    assert((PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":13,"deletions":30,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,0 @@\n-  static void    profile_method(JavaThread* thread);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -99,1 +100,1 @@\n-  set_handle(SystemDictionary::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);\n+  set_handle(vmClasses::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);\n@@ -162,1 +163,1 @@\n-    Klass* object_klass = SystemDictionary::Object_klass();\n+    Klass* object_klass = vmClasses::Object_klass();\n@@ -353,1 +354,1 @@\n-      result->method_holder() == SystemDictionary::Object_klass()) {\n+      result->method_holder() == vmClasses::Object_klass()) {\n@@ -457,2 +458,2 @@\n-  if ((klass == SystemDictionary::MethodHandle_klass() ||\n-       klass == SystemDictionary::VarHandle_klass()) &&\n+  if ((klass == vmClasses::MethodHandle_klass() ||\n+       klass == vmClasses::VarHandle_klass()) &&\n@@ -491,1 +492,1 @@\n-        Klass* natives = SystemDictionary::MethodHandleNatives_klass();\n+        Klass* natives = vmClasses::MethodHandleNatives_klass();\n@@ -577,1 +578,1 @@\n-      sel_klass == SystemDictionary::Object_klass() &&\n+      sel_klass == vmClasses::Object_klass() &&\n@@ -635,1 +636,1 @@\n-    Klass* resolved_klass = SystemDictionary::MethodHandle_klass();\n+    Klass* resolved_klass = vmClasses::MethodHandle_klass();\n@@ -647,1 +648,1 @@\n-      || (resolved_klass == SystemDictionary::MethodHandle_klass() &&\n+      || (resolved_klass == vmClasses::MethodHandle_klass() &&\n@@ -1202,1 +1203,1 @@\n-                        SystemDictionary::reflect_MagicAccessorImpl_klass());\n+                        vmClasses::reflect_MagicAccessorImpl_klass());\n@@ -1556,1 +1557,1 @@\n-           (resolved_method()->is_final() && resolved_method->method_holder() == SystemDictionary::Object_klass()),\n+           (resolved_method()->is_final() && resolved_method->method_holder() == vmClasses::Object_klass()),\n@@ -1743,2 +1744,2 @@\n-  assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||\n-         resolved_klass == SystemDictionary::VarHandle_klass(), \"\");\n+  assert(resolved_klass == vmClasses::MethodHandle_klass() ||\n+         resolved_klass == vmClasses::VarHandle_klass(), \"\");\n@@ -1804,1 +1805,1 @@\n-    if (!PENDING_EXCEPTION->is_a(SystemDictionary::LinkageError_klass())) {\n+    if (!PENDING_EXCEPTION->is_a(vmClasses::LinkageError_klass())) {\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -221,1 +222,1 @@\n-            MethodHandles::is_signature_polymorphic_name(SystemDictionary::MethodHandle_klass(),\n+            MethodHandles::is_signature_polymorphic_name(vmClasses::MethodHandle_klass(),\n@@ -227,1 +228,1 @@\n-                   MethodHandles::is_signature_polymorphic_name(SystemDictionary::VarHandle_klass(),\n+                   MethodHandles::is_signature_polymorphic_name(vmClasses::VarHandle_klass(),\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -59,1 +60,1 @@\n-  assert(!is_c1_or_interpreter_only(), \"JVMCI is launched, it's not c1\/interpreter only mode\");\n+  assert(!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci(), \"JVMCI is launched, it's not c1\/interpreter only mode\");\n@@ -81,1 +82,1 @@\n-  Array<Method*>* objectMethods = SystemDictionary::Object_klass()->methods();\n+  Array<Method*>* objectMethods = vmClasses::Object_klass()->methods();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -356,1 +358,1 @@\n-  if (executable->klass() == SystemDictionary::reflect_Constructor_klass()) {\n+  if (executable->klass() == vmClasses::reflect_Constructor_klass()) {\n@@ -360,1 +362,1 @@\n-    assert(executable->klass() == SystemDictionary::reflect_Method_klass(), \"wrong type\");\n+    assert(executable->klass() == vmClasses::reflect_Method_klass(), \"wrong type\");\n@@ -377,1 +379,1 @@\n-    if (obj->is_a(SystemDictionary::ResolvedMethodName_klass())) {\n+    if (obj->is_a(vmClasses::ResolvedMethodName_klass())) {\n@@ -435,1 +437,1 @@\n-        if (base_oop->is_a(SystemDictionary::Class_klass())) {\n+        if (base_oop->is_a(vmClasses::Class_klass())) {\n@@ -756,1 +758,1 @@\n-      resolved == SystemDictionary::Object_klass() &&\n+      resolved == vmClasses::Object_klass() &&\n@@ -1820,1 +1822,1 @@\n-  if (lambda_form->is_a(SystemDictionary::LambdaForm_klass())) {\n+  if (lambda_form->is_a(vmClasses::LambdaForm_klass())) {\n@@ -1823,1 +1825,1 @@\n-    JavaCalls::call_special(&result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);\n+    JavaCalls::call_special(&result, lambda_form, vmClasses::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);\n@@ -1877,1 +1879,1 @@\n-    box_klass = SystemDictionary::name##_klass(); \\\n+    box_klass = vmClasses::name##_klass(); \\\n@@ -2662,1 +2664,1 @@\n-                       SystemDictionary::System_klass(),\n+                       vmClasses::System_klass(),\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"runtime\/osThread.hpp\"\n@@ -225,3 +226,0 @@\n-  nonstatic_field(MethodCounters,              _interpreter_invocation_limit,                 int)                                   \\\n-  nonstatic_field(MethodCounters,              _interpreter_backward_branch_limit,            int)                                   \\\n-  nonstatic_field(MethodCounters,              _interpreter_profile_limit,                    int)                                   \\\n@@ -230,1 +228,0 @@\n-  nonstatic_field(MethodCounters,              _interpreter_invocation_count,                 int)                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,0 +142,1 @@\n+  LOG_TAG(placeholders) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -600,1 +601,1 @@\n-\/\/ We must relocate the System::_well_known_klasses only after we have copied the\n+\/\/ We must relocate vmClasses::_klasses[] only after we have copied the\n@@ -603,2 +604,2 @@\n-void ArchiveBuilder::relocate_well_known_klasses() {\n-  log_info(cds)(\"Relocating SystemDictionary::_well_known_klasses[] ... \");\n+void ArchiveBuilder::relocate_vm_classes() {\n+  log_info(cds)(\"Relocating vmClasses::_klasses[] ... \");\n@@ -607,1 +608,1 @@\n-  SystemDictionary::well_known_klasses_do(&doit);\n+  vmClasses::metaspace_pointers_do(&doit);\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,1 @@\n-  void relocate_well_known_klasses();\n+  void relocate_vm_classes();\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -380,1 +380,1 @@\n-  KlassInfoEntry* jlo_cie = cit.lookup(SystemDictionary::Object_klass());\n+  KlassInfoEntry* jlo_cie = cit.lookup(vmClasses::Object_klass());\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -507,1 +508,1 @@\n-    \/\/ SystemDictionary::xxx_klass() are not updated, need to check\n+    \/\/ vmClasses::xxx_klass() are not updated, need to check\n@@ -509,2 +510,2 @@\n-    if (orig_k == SystemDictionary::String_klass() ||\n-        orig_k == SystemDictionary::Object_klass()) {\n+    if (orig_k == vmClasses::String_klass() ||\n+        orig_k == vmClasses::Object_klass()) {\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -34,0 +35,2 @@\n+#include \"utilities\/macros.hpp\"\n+#include <type_traits>\n@@ -99,2 +102,2 @@\n-  \/\/ To work around the lack of a vtable, we use Ref class with templates\n-  \/\/ (see ObjectRef, PrimitiveArrayRef and PointerArrayRef)\n+  \/\/ To work around the lack of a vtable, we use the Ref class with templates\n+  \/\/ (see MSORef, OtherArrayRef, MSOArrayRef, and MSOPointerArrayRef)\n@@ -162,2 +165,2 @@\n-  \/\/ -------------------------------------------------- ObjectRef\n-  template <class T> class ObjectRef : public Ref {\n+  \/\/ MSORef -- iterate an instance of MetaspaceObj\n+  template <class T> class MSORef : public Ref {\n@@ -174,1 +177,1 @@\n-    ObjectRef(T** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n+    MSORef(T** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n@@ -189,2 +192,2 @@\n-  \/\/ -------------------------------------------------- PrimitiveArrayRef\n-  template <class T> class PrimitiveArrayRef : public Ref {\n+  \/\/ abstract base class for MSOArrayRef, MSOPointerArrayRef and OtherArrayRef\n+  template <class T> class ArrayRef : public Ref {\n@@ -192,0 +195,1 @@\n+  protected:\n@@ -195,1 +199,0 @@\n-  protected:\n@@ -200,2 +203,1 @@\n-  public:\n-    PrimitiveArrayRef(Array<T>** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n+    ArrayRef(Array<T>** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n@@ -208,0 +210,8 @@\n+  };\n+\n+  \/\/ OtherArrayRef -- iterate an instance of Array<T>, where T is NOT a subtype of MetaspaceObj.\n+  \/\/ T can be a primitive type, such as int, or a structure. However, we do not scan\n+  \/\/ the fields inside T, so you should not embed any pointers inside T.\n+  template <class T> class OtherArrayRef : public ArrayRef<T> {\n+  public:\n+    OtherArrayRef(Array<T>** mpp, Writability w) : ArrayRef<T>(mpp, w) {}\n@@ -210,2 +220,2 @@\n-      Array<T>* array = dereference();\n-      log_trace(cds)(\"Iter(PrimitiveArray): %p [%d]\", array, array->length());\n+      Array<T>* array = ArrayRef<T>::dereference();\n+      log_trace(cds)(\"Iter(OtherArray): %p [%d]\", array, array->length());\n@@ -215,1 +225,1 @@\n-      log_trace(cds)(\"Iter(PrimitiveArray): %p [%d]\", array, array->length());\n+      log_trace(cds)(\"Iter(OtherArray): %p [%d]\", array, array->length());\n@@ -219,5 +229,8 @@\n-  \/\/ -------------------------------------------------- PointerArrayRef\n-  template <class T> class PointerArrayRef : public Ref {\n-    Array<T*>** _mpp;\n-    Array<T*>* dereference() const {\n-      return *_mpp;\n+  \/\/ MSOArrayRef -- iterate an instance of Array<T>, where T is a subtype of MetaspaceObj.\n+  \/\/ We recursively call T::metaspace_pointers_do() for each element in this array.\n+  template <class T> class MSOArrayRef : public ArrayRef<T> {\n+  public:\n+    MSOArrayRef(Array<T>** mpp, Writability w) : ArrayRef<T>(mpp, w) {}\n+\n+    virtual void metaspace_pointers_do(MetaspaceClosure *it) const {\n+      metaspace_pointers_do_at_impl(it, ArrayRef<T>::dereference());\n@@ -225,3 +238,10 @@\n-  protected:\n-    virtual void** mpp() const {\n-      return (void**)_mpp;\n+    virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {\n+      metaspace_pointers_do_at_impl(it, (Array<T>*)new_loc);\n+    }\n+  private:\n+    void metaspace_pointers_do_at_impl(MetaspaceClosure *it, Array<T>* array) const {\n+      log_trace(cds)(\"Iter(MSOArray): %p [%d]\", array, array->length());\n+      for (int i = 0; i < array->length(); i++) {\n+        T* elm = array->adr_at(i);\n+        elm->metaspace_pointers_do(it);\n+      }\n@@ -229,0 +249,1 @@\n+  };\n@@ -230,0 +251,3 @@\n+  \/\/ MSOPointerArrayRef -- iterate an instance of Array<T*>, where T is a subtype of MetaspaceObj.\n+  \/\/ We recursively call MetaspaceClosure::push() for each pointer in this array.\n+  template <class T> class MSOPointerArrayRef : public ArrayRef<T*> {\n@@ -231,7 +255,1 @@\n-    PointerArrayRef(Array<T*>** mpp, Writability w) : Ref(w), _mpp(mpp) {}\n-\n-    \/\/ all Arrays are read-only by default\n-    virtual bool is_read_only_by_default() const { return true; }\n-    virtual bool not_null()                const { return dereference() != NULL; }\n-    virtual int size()                     const { return dereference()->size(); }\n-    virtual MetaspaceObj::Type msotype()   const { return MetaspaceObj::array_type(sizeof(T*)); }\n+    MSOPointerArrayRef(Array<T*>** mpp, Writability w) : ArrayRef<T*>(mpp, w) {}\n@@ -240,1 +258,1 @@\n-      metaspace_pointers_do_at_impl(it, dereference());\n+      metaspace_pointers_do_at_impl(it, ArrayRef<T*>::dereference());\n@@ -247,1 +265,1 @@\n-      log_trace(cds)(\"Iter(ObjectArray): %p [%d]\", array, array->length());\n+      log_trace(cds)(\"Iter(MSOPointerArray): %p [%d]\", array, array->length());\n@@ -295,4 +313,19 @@\n-  \/\/ When you do:\n-  \/\/     void MyType::metaspace_pointers_do(MetaspaceClosure* it) {\n-  \/\/       it->push(_my_field)\n-  \/\/     }\n+private:\n+  template <class REF_TYPE, typename T>\n+  void push_with_ref(T** mpp, Writability w) {\n+    push_impl(new REF_TYPE(mpp, w));\n+  }\n+\n+public:\n+  \/\/ When MetaspaceClosure::push(...) is called, pick the correct Ref subtype to handle it:\n+  \/\/\n+  \/\/ MetaspaceClosure*      it = ...;\n+  \/\/ Klass*                 o  = ...;  it->push(&o);     => MSORef\n+  \/\/ Array<int>*            a1 = ...;  it->push(&a1);    => OtherArrayRef\n+  \/\/ Array<Annotation>*     a2 = ...;  it->push(&a2);    => MSOArrayRef\n+  \/\/ Array<Klass*>*         a3 = ...;  it->push(&a3);    => MSOPointerArrayRef\n+  \/\/ Array<Array<Klass*>*>* a4 = ...;  it->push(&a4);    => MSOPointerArrayRef\n+  \/\/ Array<Annotation*>*    a5 = ...;  it->push(&a5);    => MSOPointerArrayRef\n+  \/\/\n+  \/\/ Note that the following will fail to compile (to prevent you from adding new fields\n+  \/\/ into the MetaspaceObj subtypes that cannot be properly copied by CDS):\n@@ -300,4 +333,13 @@\n-  \/\/ C++ will try to match the \"most specific\" template function. This one will\n-  \/\/ will be matched if possible (if mpp is an Array<> of any pointer type).\n-  template <typename T> void push(Array<T*>** mpp, Writability w = _default) {\n-    push_impl(new PointerArrayRef<T>(mpp, w));\n+  \/\/ Hashtable*             h  = ...;  it->push(&h);     => Hashtable is not a subclass of MetaspaceObj\n+  \/\/ Array<Hashtable*>*     a6 = ...;  it->push(&a6);    => Hashtable is not a subclass of MetaspaceObj\n+  \/\/ Array<int*>*           a7 = ...;  it->push(&a7);    => int       is not a subclass of MetaspaceObj\n+\n+  template <typename T>\n+  void push(T** mpp, Writability w = _default) {\n+    static_assert(std::is_base_of<MetaspaceObj, T>::value, \"Do not push pointers of arbitrary types\");\n+    push_with_ref<MSORef<T>>(mpp, w);\n+  }\n+\n+  template <typename T, ENABLE_IF(!std::is_base_of<MetaspaceObj, T>::value)>\n+  void push(Array<T>** mpp, Writability w = _default) {\n+    push_with_ref<OtherArrayRef<T>>(mpp, w);\n@@ -306,4 +348,3 @@\n-  \/\/ If the above function doesn't match (mpp is an Array<>, but T is not a pointer type), then\n-  \/\/ this is the second choice.\n-  template <typename T> void push(Array<T>** mpp, Writability w = _default) {\n-    push_impl(new PrimitiveArrayRef<T>(mpp, w));\n+  template <typename T, ENABLE_IF(std::is_base_of<MetaspaceObj, T>::value)>\n+  void push(Array<T>** mpp, Writability w = _default) {\n+    push_with_ref<MSOArrayRef<T>>(mpp, w);\n@@ -312,4 +353,18 @@\n-  \/\/ If the above function doesn't match (mpp is not an Array<> type), then\n-  \/\/ this will be matched by default.\n-  template <class T> void push(T** mpp, Writability w = _default) {\n-    push_impl(new ObjectRef<T>(mpp, w));\n+  template <typename T>\n+  void push(Array<T*>** mpp, Writability w = _default) {\n+    static_assert(std::is_base_of<MetaspaceObj, T>::value, \"Do not push Arrays of arbitrary pointer types\");\n+    push_with_ref<MSOPointerArrayRef<T>>(mpp, w);\n+  }\n+\n+#if 0\n+  \/\/ Enable this block if you're changing the push(...) methods, to test for types that should be\n+  \/\/ disallowed. Each of the following \"push\" calls should result in a compile-time error.\n+  void test_disallowed_types(MetaspaceClosure* it) {\n+    Hashtable<bool, mtInternal>* h  = NULL;\n+    it->push(&h);\n+\n+    Array<Hashtable<bool, mtInternal>*>* a6 = NULL;\n+    it->push(&a6);\n+\n+    Array<int*>* a7 = NULL;\n+    it->push(&a7);\n@@ -317,0 +372,1 @@\n+#endif\n@@ -319,1 +375,1 @@\n-    Ref* ref = new ObjectRef<T>(mpp, _default);\n+    Ref* ref = new MSORef<T>(mpp, _default);\n@@ -327,1 +383,1 @@\n-    Ref* ref = new ObjectRef<T>(mpp, _default);\n+    Ref* ref = new MSORef<T>(mpp, _default);\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":105,"deletions":49,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvm_io.h\"\n@@ -38,0 +39,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -504,1 +506,1 @@\n-  SystemDictionaryShared::serialize_well_known_klasses(soc);\n+  SystemDictionaryShared::serialize_vm_classes(soc);\n@@ -729,2 +731,0 @@\n-  guarantee(SystemDictionary::placeholders()->number_of_entries() == 0,\n-          \"placeholders are not saved\");\n@@ -784,1 +784,1 @@\n-  builder.relocate_well_known_klasses();\n+  builder.relocate_vm_classes();\n@@ -852,1 +852,1 @@\n-  \/\/ (such as SystemDictionary::_well_known_klasses) that may cause these VM operations\n+  \/\/ (such as vmClasses::_klasses) that may cause these VM operations\n@@ -1728,2 +1728,2 @@\n-    log_error(cds)(\"Unable to map CDS archive -- os::vm_allocation_granularity() expected: \" SIZE_FORMAT\n-                   \" actual: %d\", mapinfo->alignment(), os::vm_allocation_granularity());\n+    log_info(cds)(\"Unable to map CDS archive -- os::vm_allocation_granularity() expected: \" SIZE_FORMAT\n+                  \" actual: %d\", mapinfo->alignment(), os::vm_allocation_granularity());\n@@ -1849,0 +1849,5 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (ClassLoaderDataShared::is_full_module_graph_loaded()) {\n+    return true;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -291,1 +292,1 @@\n-  Klass* ok = SystemDictionary::Object_klass();\n+  Klass* ok = vmClasses::Object_klass();\n@@ -353,1 +354,1 @@\n-             SystemDictionary::Cloneable_klass(), \"u3\");\n+             vmClasses::Cloneable_klass(), \"u3\");\n@@ -355,1 +356,1 @@\n-             SystemDictionary::Serializable_klass(), \"u3\");\n+             vmClasses::Serializable_klass(), \"u3\");\n@@ -357,1 +358,1 @@\n-                   SystemDictionary::IdentityObject_klass(), \"u3\");\n+                   vmClasses::IdentityObject_klass(), \"u3\");\n@@ -360,1 +361,1 @@\n-          SystemDictionary::IdentityObject_klass(), \"u3\");\n+          vmClasses::IdentityObject_klass(), \"u3\");\n@@ -365,3 +366,3 @@\n-      _the_array_interfaces_array->at_put(0, SystemDictionary::Cloneable_klass());\n-      _the_array_interfaces_array->at_put(1, SystemDictionary::Serializable_klass());\n-      _the_array_interfaces_array->at_put(2, SystemDictionary::IdentityObject_klass());\n+      _the_array_interfaces_array->at_put(0, vmClasses::Cloneable_klass());\n+      _the_array_interfaces_array->at_put(1, vmClasses::Serializable_klass());\n+      _the_array_interfaces_array->at_put(2, vmClasses::IdentityObject_klass());\n@@ -401,1 +402,1 @@\n-    cast(SystemDictionary::Object_klass())->array_klass(1, CHECK);\n+    cast(vmClasses::Object_klass())->array_klass(1, CHECK);\n@@ -422,1 +423,1 @@\n-    objArrayOop    naked_array = oopFactory::new_objArray(SystemDictionary::Object_klass(), size, CHECK);\n+    objArrayOop    naked_array = oopFactory::new_objArray(vmClasses::Object_klass(), size, CHECK);\n@@ -427,1 +428,1 @@\n-      oop dummy = SystemDictionary::Object_klass()->allocate_instance(CHECK);\n+      oop dummy = vmClasses::Object_klass()->allocate_instance(CHECK);\n@@ -485,1 +486,1 @@\n-  assert(SystemDictionary::Class_klass_loaded(), \"java.lang.Class should be loaded\");\n+  assert(vmClasses::Class_klass_loaded(), \"java.lang.Class should be loaded\");\n@@ -553,1 +554,1 @@\n-  Klass* ok = SystemDictionary::Object_klass();\n+  Klass* ok = vmClasses::Object_klass();\n@@ -638,1 +639,1 @@\n-      SystemDictionary::Throwable_klass()->is_initialized()) {\n+      vmClasses::Throwable_klass()->is_initialized()) {\n@@ -670,1 +671,1 @@\n-  InstanceKlass* ik = SystemDictionary::OutOfMemoryError_klass();\n+  InstanceKlass* ik = vmClasses::OutOfMemoryError_klass();\n@@ -925,1 +926,1 @@\n-                          SystemDictionary::Finalizer_klass(),\n+                          vmClasses::Finalizer_klass(),\n@@ -930,1 +931,1 @@\n-                          SystemDictionary::internal_Unsafe_klass(),\n+                          vmClasses::internal_Unsafe_klass(),\n@@ -935,1 +936,1 @@\n-                          SystemDictionary::internal_Unsafe_klass(),\n+                          vmClasses::internal_Unsafe_klass(),\n@@ -941,1 +942,1 @@\n-                          SystemDictionary::ClassLoader_klass(),\n+                          vmClasses::ClassLoader_klass(),\n@@ -947,1 +948,1 @@\n-                          SystemDictionary::AbstractStackWalker_klass(),\n+                          vmClasses::AbstractStackWalker_klass(),\n@@ -954,1 +955,1 @@\n-                          SystemDictionary::ValueBootstrapMethods_klass(),\n+                          vmClasses::ValueBootstrapMethods_klass(),\n@@ -958,1 +959,1 @@\n-                          SystemDictionary::ValueBootstrapMethods_klass(),\n+                          vmClasses::ValueBootstrapMethods_klass(),\n@@ -986,1 +987,1 @@\n-  objArrayOop the_empty_class_array = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_false);\n+  objArrayOop the_empty_class_array = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_false);\n@@ -1012,1 +1013,1 @@\n-  k = SystemDictionary::VirtualMachineError_klass();\n+  k = vmClasses::VirtualMachineError_klass();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,1 @@\n+  friend class vmClasses;\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -60,1 +60,1 @@\n-  return SystemDictionary::Object_klass();\n+  return vmClasses::Object_klass();\n@@ -97,1 +97,1 @@\n-    set_super(Universe::is_bootstrapping() ? NULL : SystemDictionary::Object_klass());\n+    set_super(Universe::is_bootstrapping() ? NULL : vmClasses::Object_klass());\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-  virtual InstanceKlass* java_super() const;\/\/{ return SystemDictionary::Object_klass(); }\n+  virtual InstanceKlass* java_super() const;\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -200,1 +201,1 @@\n-    objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);\n+    objArrayOop stom = oopFactory::new_objArray(vmClasses::Object_klass(), map_length, CHECK);\n@@ -370,1 +371,1 @@\n-  if (SystemDictionary::Object_klass_loaded()) {\n+  if (vmClasses::Object_klass_loaded()) {\n@@ -387,1 +388,1 @@\n-        objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);\n+        objArrayOop stom = oopFactory::new_objArray(vmClasses::Object_klass(), map_length, CHECK);\n@@ -866,1 +867,1 @@\n-    is_a(SystemDictionary::LinkageError_klass())) {\n+    is_a(vmClasses::LinkageError_klass())) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -979,1 +979,0 @@\n-  unsigned int        _hash;   \/\/ 32-bit hash for item\n@@ -982,0 +981,1 @@\n+  unsigned int        _hash;   \/\/ 32-bit hash for item\n@@ -998,1 +998,1 @@\n-    : _hash(hash), _next(NULL), _symbol(symbol), _value(value) {}\n+    : _next(NULL), _symbol(symbol), _hash(hash), _value(value) {}\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -210,1 +212,1 @@\n-        assert(holder->is_interface() || holder == SystemDictionary::Object_klass(), \"unexpected holder class\");\n+        assert(holder->is_interface() || holder == vmClasses::Object_klass(), \"unexpected holder class\");\n@@ -313,1 +315,1 @@\n-                (method->is_final() && method->method_holder() == SystemDictionary::Object_klass())))),\n+                (method->is_final() && method->method_holder() == vmClasses::Object_klass())))),\n@@ -484,1 +486,1 @@\n-  assert(PENDING_EXCEPTION->is_a(SystemDictionary::LinkageError_klass()),\n+  assert(PENDING_EXCEPTION->is_a(vmClasses::LinkageError_klass()),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  guarantee((!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()), \"Really ?!\");\n+  guarantee((!Universe::is_bootstrapping() || vmClasses::Object_klass_loaded()), \"Really ?!\");\n@@ -403,3 +403,3 @@\n-    secondaries->push(SystemDictionary::Cloneable_klass());\n-    secondaries->push(SystemDictionary::Serializable_klass());\n-    secondaries->push(SystemDictionary::IdentityObject_klass());\n+    secondaries->push(vmClasses::Cloneable_klass());\n+    secondaries->push(vmClasses::Serializable_klass());\n+    secondaries->push(vmClasses::IdentityObject_klass());\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -152,1 +154,1 @@\n-  if (SystemDictionary::ClassLoader_klass_loaded()) {\n+  if (vmClasses::ClassLoader_klass_loaded()) {\n@@ -155,1 +157,1 @@\n-      if (super_klass->is_subtype_of(SystemDictionary::ClassLoader_klass())) {\n+      if (super_klass->is_subtype_of(vmClasses::ClassLoader_klass())) {\n@@ -191,1 +193,1 @@\n-      assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),\n+      assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass()),\n@@ -209,1 +211,1 @@\n-        assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),\n+        assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass()),\n@@ -256,2 +258,0 @@\n-  \/\/ Check for a resolved cp entry, else fall back to a name check.\n-  \/\/ We don't want to resolve any class other than the one being checked.\n@@ -260,13 +260,4 @@\n-    if (_constants->tag_at(cp_index).is_klass()) {\n-      Klass* k2 = _constants->klass_at(cp_index, THREAD);\n-      assert(!HAS_PENDING_EXCEPTION, \"Unexpected exception\");\n-      if (k2 == k) {\n-        log_trace(class, sealed)(\"- class is listed at permitted_subclasses[%d] => cp[%d]\", i, cp_index);\n-        return true;\n-      }\n-    } else {\n-      Symbol* name = _constants->klass_name_at(cp_index);\n-      if (name == k->name()) {\n-        log_trace(class, sealed)(\"- Found it at permitted_subclasses[%d] => cp[%d]\", i, cp_index);\n-        return true;\n-      }\n+    Symbol* name = _constants->klass_name_at(cp_index);\n+    if (name == k->name()) {\n+      log_trace(class, sealed)(\"- Found it at permitted_subclasses[%d] => cp[%d]\", i, cp_index);\n+      return true;\n@@ -315,1 +306,1 @@\n-      if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+      if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n@@ -354,1 +345,1 @@\n-            if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+            if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n@@ -793,1 +784,1 @@\n-         java_super() == SystemDictionary::Record_klass();\n+         java_super() == vmClasses::Record_klass();\n@@ -1341,1 +1332,1 @@\n-    if (e->is_a(SystemDictionary::Error_klass())) {\n+    if (e->is_a(vmClasses::Error_klass())) {\n@@ -1571,1 +1562,1 @@\n-  if (this == SystemDictionary::Class_klass()) {\n+  if (this == vmClasses::Class_klass()) {\n@@ -2707,1 +2698,1 @@\n-  _package_entry = NULL;\n+  init_shared_package_entry();\n@@ -2720,0 +2711,21 @@\n+void InstanceKlass::init_shared_package_entry() {\n+#if !INCLUDE_CDS_JAVA_HEAP\n+  _package_entry = NULL;\n+#else\n+  if (!MetaspaceShared::use_full_module_graph()) {\n+    _package_entry = NULL;\n+  } else if (DynamicDumpSharedSpaces) {\n+    if (!MetaspaceShared::is_in_shared_metaspace(_package_entry)) {\n+      _package_entry = NULL;\n+    }\n+  } else {\n+    if (is_shared_unregistered_class()) {\n+      _package_entry = NULL;\n+    } else {\n+      _package_entry = PackageEntry::get_archived_entry(_package_entry);\n+    }\n+  }\n+  ArchivePtrMarker::mark_pointer((address**)&_package_entry);\n+#endif\n+}\n+\n@@ -3007,0 +3019,9 @@\n+  if (is_shared() && _package_entry == pkg_entry) {\n+    if (MetaspaceShared::use_full_module_graph()) {\n+      \/\/ we can use the saved package\n+      return;\n+    } else {\n+      _package_entry = NULL;\n+    }\n+  }\n+\n@@ -3364,5 +3385,3 @@\n-  if (TieredCompilation) {\n-    nmethod* prev = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), n->comp_level(), true);\n-    assert(prev == NULL || !prev->is_in_use() COMPILER2_PRESENT(|| StressRecompilation),\n-           \"redundant OSR recompilation detected. memory leak in CodeCache!\");\n-  }\n+  nmethod* prev = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), n->comp_level(), true);\n+  assert(prev == NULL || !prev->is_in_use() COMPILER2_PRESENT(|| StressRecompilation),\n+      \"redundant OSR recompilation detected. memory leak in CodeCache!\");\n@@ -3371,10 +3390,5 @@\n-  {\n-    assert(n->is_osr_method(), \"wrong kind of nmethod\");\n-    n->set_osr_link(osr_nmethods_head());\n-    set_osr_nmethods_head(n);\n-    \/\/ Raise the highest osr level if necessary\n-    if (TieredCompilation) {\n-      Method* m = n->method();\n-      m->set_highest_osr_comp_level(MAX2(m->highest_osr_comp_level(), n->comp_level()));\n-    }\n-  }\n+  assert(n->is_osr_method(), \"wrong kind of nmethod\");\n+  n->set_osr_link(osr_nmethods_head());\n+  set_osr_nmethods_head(n);\n+  \/\/ Raise the highest osr level if necessary\n+  n->method()->set_highest_osr_comp_level(MAX2(n->method()->highest_osr_comp_level(), n->comp_level()));\n@@ -3383,6 +3397,4 @@\n-  if (TieredCompilation) {\n-    for (int l = CompLevel_limited_profile; l < n->comp_level(); l++) {\n-      nmethod *inv = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), l, true);\n-      if (inv != NULL && inv->is_in_use()) {\n-        inv->make_not_entrant();\n-      }\n+  for (int l = CompLevel_limited_profile; l < n->comp_level(); l++) {\n+    nmethod *inv = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), l, true);\n+    if (inv != NULL && inv->is_in_use()) {\n+      inv->make_not_entrant();\n@@ -3406,1 +3418,1 @@\n-    if (TieredCompilation && m == cur->method()) {\n+    if (m == cur->method()) {\n@@ -3425,8 +3437,5 @@\n-  if (TieredCompilation) {\n-    cur = next;\n-    while (cur != NULL) {\n-      \/\/ Find max level after n\n-      if (m == cur->method()) {\n-        max_level = MAX2(max_level, cur->comp_level());\n-      }\n-      cur = cur->osr_link();\n+  cur = next;\n+  while (cur != NULL) {\n+    \/\/ Find max level after n\n+    if (m == cur->method()) {\n+      max_level = MAX2(max_level, cur->comp_level());\n@@ -3434,1 +3443,1 @@\n-    m->set_highest_osr_comp_level(max_level);\n+    cur = cur->osr_link();\n@@ -3436,0 +3445,1 @@\n+  m->set_highest_osr_comp_level(max_level);\n@@ -3477,1 +3487,1 @@\n-          if (osr->comp_level() == CompLevel_highest_tier) {\n+          if (osr->comp_level() == CompilationPolicy::highest_compile_level()) {\n@@ -3699,1 +3709,1 @@\n-  if (this == SystemDictionary::String_klass()) {\n+  if (this == vmClasses::String_klass()) {\n@@ -3716,1 +3726,1 @@\n-  if (this == SystemDictionary::Class_klass()) {\n+  if (this == vmClasses::Class_klass()) {\n@@ -3734,1 +3744,1 @@\n-  } else if (this == SystemDictionary::MethodType_klass()) {\n+  } else if (this == vmClasses::MethodType_klass()) {\n@@ -3753,1 +3763,1 @@\n-  if (this == SystemDictionary::String_klass()\n+  if (this == vmClasses::String_klass()\n@@ -3762,1 +3772,1 @@\n-  } else if (this == SystemDictionary::Class_klass()) {\n+  } else if (this == vmClasses::Class_klass()) {\n@@ -3771,1 +3781,1 @@\n-  } else if (this == SystemDictionary::MethodType_klass()) {\n+  } else if (this == vmClasses::MethodType_klass()) {\n@@ -3777,1 +3787,1 @@\n-  } else if (this == SystemDictionary::LambdaForm_klass()) {\n+  } else if (this == vmClasses::LambdaForm_klass()) {\n@@ -3783,1 +3793,1 @@\n-  } else if (this == SystemDictionary::MemberName_klass()) {\n+  } else if (this == vmClasses::MemberName_klass()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":75,"deletions":65,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvm_io.h\"\n@@ -33,0 +34,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -72,1 +74,1 @@\n-         is_subtype_of(SystemDictionary::Cloneable_klass());\n+         is_subtype_of(vmClasses::Cloneable_klass());\n@@ -247,2 +249,2 @@\n-  } else if (k != super() || k == SystemDictionary::Object_klass()) {\n-    assert(super() == NULL || super() == SystemDictionary::Object_klass(),\n+  } else if (k != super() || k == vmClasses::Object_klass()) {\n+    assert(super() == NULL || super() == vmClasses::Object_klass(),\n@@ -476,1 +478,1 @@\n-  Klass* root = SystemDictionary::Object_klass();\n+  Klass* root = vmClasses::Object_klass();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -73,0 +74,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -875,1 +877,1 @@\n-    objArrayOop m_oop = oopFactory::new_objArray(SystemDictionary::Class_klass(), length, CHECK_(objArrayHandle()));\n+    objArrayOop m_oop = oopFactory::new_objArray(vmClasses::Class_klass(), length, CHECK_(objArrayHandle()));\n@@ -881,1 +883,1 @@\n-          !k->is_subclass_of(SystemDictionary::Throwable_klass())) {\n+          !k->is_subclass_of(vmClasses::Throwable_klass())) {\n@@ -1048,1 +1050,1 @@\n-    return is_not_c1_compilable() || is_not_c2_compilable();\n+    return is_not_c1_compilable() && is_not_c2_compilable();\n@@ -1079,1 +1081,1 @@\n-    return is_not_c1_osr_compilable() || is_not_c2_osr_compilable();\n+    return is_not_c1_osr_compilable() && is_not_c2_osr_compilable();\n@@ -1477,1 +1479,1 @@\n-  if (method_holder()->is_subclass_of(SystemDictionary::reflect_MethodAccessorImpl_klass())) {\n+  if (method_holder()->is_subclass_of(vmClasses::reflect_MethodAccessorImpl_klass())) {\n@@ -1522,1 +1524,1 @@\n-  InstanceKlass* holder = SystemDictionary::MethodHandle_klass();\n+  InstanceKlass* holder = vmClasses::MethodHandle_klass();\n@@ -1810,2 +1812,2 @@\n-        if (PENDING_EXCEPTION->is_a(SystemDictionary::ClassNotFoundException_klass()) ||\n-            PENDING_EXCEPTION->is_a(SystemDictionary::LinkageError_klass())) {\n+        if (PENDING_EXCEPTION->is_a(vmClasses::ClassNotFoundException_klass()) ||\n+            PENDING_EXCEPTION->is_a(vmClasses::LinkageError_klass())) {\n@@ -2046,10 +2048,5 @@\n-  MethodCounters *mcs = method_counters();\n-  if (TieredCompilation) {\n-    MethodData* const mdo = method_data();\n-    if (((mcs != NULL) ? mcs->invocation_counter()->carry() : false) ||\n-        ((mdo != NULL) ? mdo->invocation_counter()->carry() : false)) {\n-      return InvocationCounter::count_limit;\n-    } else {\n-      return ((mcs != NULL) ? mcs->invocation_counter()->count() : 0) +\n-             ((mdo != NULL) ? mdo->invocation_counter()->count() : 0);\n-    }\n+  MethodCounters* mcs = method_counters();\n+  MethodData* mdo = method_data();\n+  if (((mcs != NULL) ? mcs->invocation_counter()->carry() : false) ||\n+      ((mdo != NULL) ? mdo->invocation_counter()->carry() : false)) {\n+    return InvocationCounter::count_limit;\n@@ -2057,1 +2054,2 @@\n-    return (mcs == NULL) ? 0 : mcs->invocation_counter()->count();\n+    return ((mcs != NULL) ? mcs->invocation_counter()->count() : 0) +\n+           ((mdo != NULL) ? mdo->invocation_counter()->count() : 0);\n@@ -2062,10 +2060,5 @@\n-  MethodCounters *mcs = method_counters();\n-  if (TieredCompilation) {\n-    MethodData* const mdo = method_data();\n-    if (((mcs != NULL) ? mcs->backedge_counter()->carry() : false) ||\n-        ((mdo != NULL) ? mdo->backedge_counter()->carry() : false)) {\n-      return InvocationCounter::count_limit;\n-    } else {\n-      return ((mcs != NULL) ? mcs->backedge_counter()->count() : 0) +\n-             ((mdo != NULL) ? mdo->backedge_counter()->count() : 0);\n-    }\n+  MethodCounters* mcs = method_counters();\n+  MethodData* mdo = method_data();\n+  if (((mcs != NULL) ? mcs->backedge_counter()->carry() : false) ||\n+      ((mdo != NULL) ? mdo->backedge_counter()->carry() : false)) {\n+    return InvocationCounter::count_limit;\n@@ -2073,1 +2066,2 @@\n-    return (mcs == NULL) ? 0 : mcs->backedge_counter()->count();\n+    return ((mcs != NULL) ? mcs->backedge_counter()->count() : 0) +\n+           ((mdo != NULL) ? mdo->backedge_counter()->count() : 0);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":25,"deletions":31,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-#if INCLUDE_AOT && defined(TIERED)\n+#if INCLUDE_AOT\n@@ -382,9 +382,3 @@\n-#ifdef TIERED\n-  \/\/ We are reusing interpreter_invocation_count as a holder for the previous event count!\n-  \/\/ We can do that since interpreter_invocation_count is not used in tiered.\n-  int prev_event_count() const                   {\n-    if (method_counters() == NULL) {\n-      return 0;\n-    } else {\n-      return method_counters()->interpreter_invocation_count();\n-    }\n+  int prev_event_count() const {\n+    MethodCounters* mcs = method_counters();\n+    return mcs == NULL ? 0 : mcs->prev_event_count();\n@@ -395,1 +389,1 @@\n-      mcs->set_interpreter_invocation_count(count);\n+      mcs->set_prev_event_count(count);\n@@ -398,1 +392,1 @@\n-  jlong prev_time() const                        {\n+  jlong prev_time() const {\n@@ -408,1 +402,1 @@\n-  float rate() const                             {\n+  float rate() const {\n@@ -430,1 +424,0 @@\n-#endif \/\/ TIERED\n@@ -444,1 +437,1 @@\n-  bool was_never_executed()                      { return !was_executed_more_than(0); }\n+  bool was_never_executed()                     { return !was_executed_more_than(0);  }\n@@ -450,15 +443,1 @@\n-  int interpreter_invocation_count() {\n-    if (TieredCompilation) {\n-      return invocation_count();\n-    } else {\n-      MethodCounters* mcs = method_counters();\n-      return (mcs == NULL) ? 0 : mcs->interpreter_invocation_count();\n-    }\n-  }\n-#if COMPILER2_OR_JVMCI\n-  int increment_interpreter_invocation_count(TRAPS) {\n-    if (TieredCompilation) ShouldNotReachHere();\n-    MethodCounters* mcs = get_method_counters(CHECK_0);\n-    return (mcs == NULL) ? 0 : mcs->increment_interpreter_invocation_count();\n-  }\n-#endif\n+  int interpreter_invocation_count()            { return invocation_count();          }\n@@ -467,2 +446,2 @@\n-  int  compiled_invocation_count() const         { return _compiled_invocation_count;  }\n-  void set_compiled_invocation_count(int count)  { _compiled_invocation_count = count; }\n+  int  compiled_invocation_count() const        { return _compiled_invocation_count;  }\n+  void set_compiled_invocation_count(int count) { _compiled_invocation_count = count; }\n@@ -471,1 +450,1 @@\n-  int  compiled_invocation_count() const         { return 0;  }\n+  int  compiled_invocation_count() const        { return 0;  }\n@@ -724,2 +703,0 @@\n-#ifdef TIERED\n-#endif\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":13,"deletions":36,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"runtime\/signature.hpp\"\n@@ -690,1 +690,1 @@\n-  if (is_client_compilation_mode_vm()) {\n+  if (CompilerConfig::is_c1_simple_only() && !ProfileInterpreter) {\n@@ -817,1 +817,1 @@\n-    if (is_server_compilation_mode_vm()) {\n+    if (CompilerConfig::is_c2_enabled()) {\n@@ -1001,1 +1001,1 @@\n-  if (is_client_compilation_mode_vm()) {\n+  if (CompilerConfig::is_c1_simple_only() && !ProfileInterpreter) {\n@@ -1374,19 +1374,1 @@\n-  int mileage = 0;\n-  if (TieredCompilation) {\n-    mileage = MAX2(method->invocation_count(), method->backedge_count());\n-  } else {\n-    int iic = method->interpreter_invocation_count();\n-    if (mileage < iic)  mileage = iic;\n-    MethodCounters* mcs = method->method_counters();\n-    if (mcs != NULL) {\n-      InvocationCounter* ic = mcs->invocation_counter();\n-      InvocationCounter* bc = mcs->backedge_counter();\n-      int icval = ic->count();\n-      if (ic->carry()) icval += CompileThreshold;\n-      if (mileage < icval)  mileage = icval;\n-      int bcval = bc->count();\n-      if (bc->carry()) bcval += CompileThreshold;\n-      if (mileage < bcval)  mileage = bcval;\n-    }\n-  }\n-  return mileage;\n+  return MAX2(method->invocation_count(), method->backedge_count());\n@@ -1396,1 +1378,1 @@\n-  return CompilationPolicy::policy()->is_mature(_method);\n+  return CompilationPolicy::is_mature(_method);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":7,"deletions":25,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -63,1 +63,1 @@\n-  if (!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()) {\n+  if (!Universe::is_bootstrapping() || vmClasses::Object_klass_loaded()) {\n@@ -96,1 +96,1 @@\n-      super_klass = SystemDictionary::Object_klass();\n+      super_klass = vmClasses::Object_klass();\n@@ -386,3 +386,3 @@\n-    secondaries->push(SystemDictionary::Cloneable_klass());\n-    secondaries->push(SystemDictionary::Serializable_klass());\n-    secondaries->push(SystemDictionary::IdentityObject_klass());\n+    secondaries->push(vmClasses::Cloneable_klass());\n+    secondaries->push(vmClasses::Serializable_klass());\n+    secondaries->push(vmClasses::IdentityObject_klass());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/access.hpp\"\n+#include \"oops\/accessDecorators.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -78,1 +79,1 @@\n-  assert(!is_c1_or_interpreter_only(), \"C2 compiler is launched, it's not c1\/interpreter only mode\");\n+  assert(!CompilerConfig::is_c1_or_interpreter_only_no_aot_or_jvmci(), \"C2 compiler is launched, it's not c1\/interpreter only mode\");\n@@ -412,1 +413,1 @@\n-    if (SystemDictionary::reflect_CallerSensitive_klass() == NULL) return false;\n+    if (vmClasses::reflect_CallerSensitive_klass() == NULL) return false;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvm_io.h\"\n@@ -394,0 +395,3 @@\n+  if (dead->Opcode() == Op_Opaque4) {\n+    remove_skeleton_predicate_opaq(dead);\n+  }\n@@ -511,1 +515,1 @@\n-  if (C->directive()->BreakAtCompileOption) {\n+  if (env()->break_at_compile()) {\n@@ -573,0 +577,1 @@\n+                  _skeleton_predicate_opaqs (comp_arena(), 8, 0, NULL),\n@@ -1894,0 +1899,2 @@\n+  assert(!C->major_progress(), \"not cleared\");\n+\n@@ -1902,0 +1909,5 @@\n+\n+    \/\/ Sometimes IGVN sets major progress (e.g., when processing loop nodes).\n+    if (C->major_progress()) {\n+      C->clear_major_progress(); \/\/ ensure that major progress is now clear\n+    }\n@@ -2524,1 +2536,1 @@\n-  if (_directive->BreakAtCompileOption) {\n+  if (env()->break_at_compile()) {\n@@ -3185,1 +3197,1 @@\n-    debug_only( cfg.verify(); )\n+    cfg.verify();\n@@ -4648,6 +4660,1 @@\n-    \/\/ Watch out: The memory initialized by the constructor call PrintInliningBuffer()\n-    \/\/ will be copied into the only initial element. The default destructor of\n-    \/\/ PrintInliningBuffer will be called when leaving the scope here. If it\n-    \/\/ would destuct the  enclosed stringStream _print_inlining_list[0]->_ss\n-    \/\/ would be destructed, too!\n-    _print_inlining_list = new (comp_arena())GrowableArray<PrintInliningBuffer>(comp_arena(), 1, 1, PrintInliningBuffer());\n+    _print_inlining_list = new (comp_arena())GrowableArray<PrintInliningBuffer*>(comp_arena(), 1, 1, new PrintInliningBuffer());\n@@ -4673,1 +4680,1 @@\n-  _print_inlining_list->at(_print_inlining_idx).ss()->write(_print_inlining_stream->base(), _print_inlining_stream->size());\n+  _print_inlining_list->at(_print_inlining_idx)->ss()->write(_print_inlining_stream->base(), _print_inlining_stream->size());\n@@ -4680,1 +4687,1 @@\n-  _print_inlining_list->insert_before(_print_inlining_idx, PrintInliningBuffer());\n+  _print_inlining_list->insert_before(_print_inlining_idx, new PrintInliningBuffer());\n@@ -4683,1 +4690,1 @@\n-Compile::PrintInliningBuffer& Compile::print_inlining_current() {\n+Compile::PrintInliningBuffer* Compile::print_inlining_current() {\n@@ -4690,3 +4697,3 @@\n-      if (print_inlining_current().cg() != cg &&\n-          (print_inlining_current().cg() != NULL ||\n-           print_inlining_current().ss()->size() != 0)) {\n+      if (print_inlining_current()->cg() != cg &&\n+          (print_inlining_current()->cg() != NULL ||\n+           print_inlining_current()->ss()->size() != 0)) {\n@@ -4696,1 +4703,1 @@\n-      print_inlining_current().set_cg(cg);\n+      print_inlining_current()->set_cg(cg);\n@@ -4698,1 +4705,1 @@\n-      if (print_inlining_current().cg() != NULL) {\n+      if (print_inlining_current()->cg() != NULL) {\n@@ -4711,1 +4718,1 @@\n-      if (_print_inlining_list->adr_at(i)->cg() == cg) {\n+      if (_print_inlining_list->at(i)->cg() == cg) {\n@@ -4723,1 +4730,1 @@\n-    assert(print_inlining_current().cg() == cg, \"wrong entry\");\n+    assert(print_inlining_current()->cg() == cg, \"wrong entry\");\n@@ -4725,1 +4732,1 @@\n-    _print_inlining_list->at_put(_print_inlining_idx, PrintInliningBuffer());\n+    _print_inlining_list->at_put(_print_inlining_idx, new PrintInliningBuffer());\n@@ -4727,1 +4734,1 @@\n-    print_inlining_current().set_cg(cg);\n+    print_inlining_current()->set_cg(cg);\n@@ -4742,2 +4749,4 @@\n-      ss.print(\"%s\", _print_inlining_list->adr_at(i)->ss()->as_string());\n-      _print_inlining_list->at(i).freeStream();\n+      PrintInliningBuffer* pib = _print_inlining_list->at(i);\n+      ss.print(\"%s\", pib->ss()->as_string());\n+      delete pib;\n+      DEBUG_ONLY(_print_inlining_list->at_put(i, NULL));\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":32,"deletions":23,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -322,0 +322,1 @@\n+  GrowableArray<Node*>  _skeleton_predicate_opaqs; \/\/ List of Opaque4 nodes for the loop skeleton predicates.\n@@ -400,1 +401,1 @@\n-  class PrintInliningBuffer : public ResourceObj {\n+  class PrintInliningBuffer : public CHeapObj<mtCompiler> {\n@@ -403,1 +404,2 @@\n-    stringStream* _ss;\n+    stringStream   _ss;\n+    static const size_t default_stream_buffer_size = 128;\n@@ -407,1 +409,1 @@\n-      : _cg(NULL) { _ss = new stringStream(); }\n+      : _cg(NULL), _ss(default_stream_buffer_size) {}\n@@ -409,4 +411,2 @@\n-    void freeStream() { _ss->~stringStream(); _ss = NULL; }\n-\n-    stringStream* ss() const { return _ss; }\n-    CallGenerator* cg() const { return _cg; }\n+    stringStream* ss()             { return &_ss; }\n+    CallGenerator* cg()            { return _cg; }\n@@ -417,1 +417,1 @@\n-  GrowableArray<PrintInliningBuffer>* _print_inlining_list;\n+  GrowableArray<PrintInliningBuffer*>* _print_inlining_list;\n@@ -437,1 +437,1 @@\n-  PrintInliningBuffer& print_inlining_current();\n+  PrintInliningBuffer* print_inlining_current();\n@@ -672,1 +672,2 @@\n-  int           predicate_count()         const { return _predicate_opaqs.length();}\n+  int           predicate_count()         const { return _predicate_opaqs.length(); }\n+  int           skeleton_predicate_count() const { return _skeleton_predicate_opaqs.length(); }\n@@ -676,1 +677,2 @@\n-  Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs.at(idx);}\n+  Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs.at(idx); }\n+  Node*         skeleton_predicate_opaque4_node(int idx) const { return _skeleton_predicate_opaqs.at(idx); }\n@@ -704,1 +706,9 @@\n-\n+  void add_skeleton_predicate_opaq(Node* n) {\n+    assert(!_skeleton_predicate_opaqs.contains(n), \"duplicate entry in skeleton predicate opaque4 list\");\n+    _skeleton_predicate_opaqs.append(n);\n+  }\n+  void remove_skeleton_predicate_opaq(Node* n) {\n+    if (skeleton_predicate_count() > 0) {\n+      _skeleton_predicate_opaqs.remove_if_existing(n);\n+    }\n+  }\n@@ -749,2 +759,1 @@\n-    \/\/ Bailouts cover \"all_tiers\" when TieredCompilation is off.\n-    env()->record_method_not_compilable(reason, !TieredCompilation);\n+    env()->record_method_not_compilable(reason);\n@@ -1064,3 +1073,0 @@\n-  \/\/ If \"objs\" contains an ObjectValue whose id is \"id\", returns it, else NULL.\n-  static ObjectValue* sv_for_node_id(GrowableArray<ScopeValue*> *objs, int id);\n-\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1166,0 +1166,8 @@\n+    if (self->is_memory_writer() &&\n+        (LCA->_loop->depth() > early->_loop->depth())) {\n+      \/\/ LCA is an invalid placement for a memory writer: choosing it would\n+      \/\/ cause memory interference, as illustrated in schedule_late().\n+      continue;\n+    }\n+    verify_memory_writer_placement(LCA, self);\n+\n@@ -1253,0 +1261,11 @@\n+#ifdef ASSERT\n+    \/\/ Assert that memory writers (e.g. stores) have a \"home\" block (the block\n+    \/\/ given by their control input), and that this block corresponds to their\n+    \/\/ earliest possible placement. This guarantees that\n+    \/\/ hoist_to_cheaper_block() will always have at least one valid choice.\n+    if (self->is_memory_writer()) {\n+      assert(find_block_for_node(self->in(0)) == early,\n+             \"The home of a memory writer must also be its earliest placement\");\n+    }\n+#endif\n+\n@@ -1277,5 +1296,4 @@\n-      if (C->has_irreducible_loop() && self->bottom_type()->has_memory()) {\n-        \/\/ If the CFG is irreducible, keep memory-writing nodes as close as\n-        \/\/ possible to their original block (given by the control input). This\n-        \/\/ prevents PhaseCFG::hoist_to_cheaper_block() from placing such nodes\n-        \/\/ into descendants of their original loop, as in the following example:\n+      if (C->has_irreducible_loop() && self->is_memory_writer()) {\n+        \/\/ If the CFG is irreducible, place memory writers in their home block.\n+        \/\/ This prevents hoist_to_cheaper_block() from accidentally placing such\n+        \/\/ nodes into deeper loops, as in the following example:\n@@ -1283,1 +1301,1 @@\n-        \/\/ Original placement of store in B1 (loop L1):\n+        \/\/ Home placement of store in B1 (loop L1):\n@@ -1304,3 +1322,7 @@\n-        \/\/ This \"hoist inversion\" can happen due to CFGLoop::compute_freq()'s\n-        \/\/ inaccurate estimation of frequencies for irreducible CFGs, which can\n-        \/\/ lead to for example assigning B1 and B3 a higher frequency than B2.\n+        \/\/ This \"hoist inversion\" can happen due to different factors such as\n+        \/\/ inaccurate estimation of frequencies for irreducible CFGs, and loops\n+        \/\/ with always-taken exits in reducible CFGs. In the reducible case,\n+        \/\/ hoist inversion is prevented by discarding invalid blocks (those in\n+        \/\/ deeper loops than the home block). In the irreducible case, the\n+        \/\/ invalid blocks cannot be identified due to incomplete loop nesting\n+        \/\/ information, hence a conservative solution is taken.\n@@ -1309,1 +1331,1 @@\n-          tty->print_cr(\"# Irreducible loops: schedule in earliest block B%d:\",\n+          tty->print_cr(\"# Irreducible loops: schedule in home block B%d:\",\n@@ -1362,0 +1384,10 @@\n+    if (self->is_memory_writer()) {\n+      \/\/ If the LCA of a memory writer is a descendant of its home loop, hoist\n+      \/\/ it into a valid placement.\n+      while (LCA->_loop->depth() > early->_loop->depth()) {\n+        LCA = LCA->_idom;\n+      }\n+      assert(LCA != NULL, \"a valid LCA must exist\");\n+      verify_memory_writer_placement(LCA, self);\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":43,"deletions":11,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  store_to_memory(NULL, adr_sp, last_sp, T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_sp, last_sp, T_ADDRESS, NoAlias, MemNode::unordered);\n@@ -224,1 +224,1 @@\n-  store_to_memory(NULL, adr_sp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_sp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n@@ -226,1 +226,1 @@\n-  store_to_memory(NULL, adr_last_Java_pc, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_last_Java_pc, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n@@ -229,1 +229,1 @@\n-  store_to_memory(NULL, adr_last_Java_fp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_last_Java_fp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n@@ -240,1 +240,1 @@\n-    store_to_memory(NULL, adr, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+    store_to_memory(control(), adr, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -838,2 +838,1 @@\n-\/\/ Helper function for enforcing certain bytecodes to reexecute if\n-\/\/ deoptimization happens\n+\/\/ Helper function for enforcing certain bytecodes to reexecute if deoptimization happens.\n@@ -910,0 +909,6 @@\n+#ifdef ASSERT\n+    int inputs = 0, not_used; \/\/ initialized by GraphKit::compute_stack_effects()\n+    assert(method() == youngest_jvms->method(), \"sanity\");\n+    assert(compute_stack_effects(inputs, not_used), \"unknown bytecode: %s\", Bytecodes::name(java_bc()));\n+    assert(out_jvms->sp() >= (uint)inputs, \"not enough operands for reexecution\");\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -920,1 +920,2 @@\n-  bool skeleton_predicate_has_opaque(IfNode* iff);\n+  static bool skeleton_predicate_has_opaque(IfNode* iff);\n+  static void get_skeleton_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque = false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1217,1 +1217,1 @@\n-  if (!n->is_If() || n->is_CountedLoopEnd()) {\n+  if (!n->is_If() || n->is_BaseCountedLoopEnd()) {\n@@ -1596,0 +1596,1 @@\n+          Node* outer_loop_clone = NULL;\n@@ -1643,10 +1644,19 @@\n-              if (x_head->is_Loop() && (x_head->is_OuterStripMinedLoop() || x_head->as_Loop()->is_strip_mined()) && is_dominator(n_ctrl, x_head)) {\n-                \/\/ Anti dependence analysis is sometimes too\n-                \/\/ conservative: a store in the outer strip mined loop\n-                \/\/ can prevent a load from floating out of the outer\n-                \/\/ strip mined loop but the load may not be referenced\n-                \/\/ from the safepoint: loop strip mining verification\n-                \/\/ code reports a problem in that case. Make sure the\n-                \/\/ load is not moved in the outer strip mined loop in\n-                \/\/ that case.\n-                x_ctrl = x_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n+              if (x_head->is_Loop() && (x_head->is_OuterStripMinedLoop() || x_head->as_Loop()->is_strip_mined())) {\n+                if (is_dominator(n_ctrl, x_head)) {\n+                  \/\/ Anti dependence analysis is sometimes too\n+                  \/\/ conservative: a store in the outer strip mined loop\n+                  \/\/ can prevent a load from floating out of the outer\n+                  \/\/ strip mined loop but the load may not be referenced\n+                  \/\/ from the safepoint: loop strip mining verification\n+                  \/\/ code reports a problem in that case. Make sure the\n+                  \/\/ load is not moved in the outer strip mined loop in\n+                  \/\/ that case.\n+                  x_ctrl = x_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n+                } else if (x_head->is_OuterStripMinedLoop()) {\n+                  \/\/ Do not add duplicate LoadNodes to the outer strip mined loop\n+                  if (outer_loop_clone != NULL) {\n+                    _igvn.replace_node(x, outer_loop_clone);\n+                    continue;\n+                  }\n+                  outer_loop_clone = x;\n+                }\n@@ -1669,2 +1679,1 @@\n-            BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-            if (!x->is_Load() && !x->is_DecodeNarrowPtr() && !x->is_AddP() && !bs->is_gc_barrier_node(x)) {\n+            if (!x->is_Load() && !x->is_DecodeNarrowPtr()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -650,0 +650,3 @@\n+  if (Opcode() == Op_Opaque4) {\n+    compile->remove_skeleton_predicate_opaq(this);\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1169,0 +1169,3 @@\n+  \/\/ Whether this is a memory-writing machine node.\n+  bool is_memory_writer() const { return is_Mach() && bottom_type()->has_memory(); }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,2 +186,3 @@\n-  ObjectValue* sv_for_node_id(GrowableArray<ScopeValue*> *objs, int id);\n-  void set_sv_for_object_node(GrowableArray<ScopeValue*> *objs, ObjectValue* sv);\n+  \/\/ If \"objs\" contains an ObjectValue whose id is \"id\", returns it, else NULL.\n+  static ObjectValue* sv_for_node_id(GrowableArray<ScopeValue*> *objs, int id);\n+  static void set_sv_for_object_node(GrowableArray<ScopeValue*> *objs, ObjectValue* sv);\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvm_io.h\"\n@@ -28,1 +29,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -829,1 +829,0 @@\n-  Node* lookup = pop();\n@@ -839,0 +838,1 @@\n+    pop(); \/\/ the effect of the instruction execution on the operand stack\n@@ -895,1 +895,1 @@\n-  if( makes_backward_branch && UseLoopSafepoints )\n+  if (makes_backward_branch && UseLoopSafepoints) {\n@@ -897,0 +897,1 @@\n+  }\n@@ -898,0 +899,1 @@\n+  Node* lookup = pop(); \/\/ lookup value\n@@ -904,1 +906,0 @@\n-  Node *lookup = pop();         \/\/ lookup value\n@@ -911,0 +912,1 @@\n+    pop(); \/\/ the effect of the instruction execution on the operand stack\n@@ -987,1 +989,1 @@\n-  if (makes_backward_branch && UseLoopSafepoints)\n+  if (makes_backward_branch && UseLoopSafepoints) {\n@@ -989,0 +991,1 @@\n+  }\n@@ -990,0 +993,1 @@\n+  Node *lookup = pop(); \/\/ lookup value\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1709,0 +1709,4 @@\n+      if (n->in(2)->is_top()) {\n+        \/\/ 'n' is dead. Treat as if zero check is still there to avoid any further optimizations.\n+        return false;\n+      }\n@@ -1715,0 +1719,4 @@\n+      if (n->in(2)->is_top()) {\n+        \/\/ 'n' is dead. Treat as if zero check is still there to avoid any further optimizations.\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -1269,1 +1269,1 @@\n-  if (!(exception->is_a(SystemDictionary::Throwable_klass()))) {\n+  if (!(exception->is_a(vmClasses::Throwable_klass()))) {\n@@ -1429,1 +1429,1 @@\n-  if (!(exception->is_a(SystemDictionary::Throwable_klass()))) {\n+  if (!(exception->is_a(vmClasses::Throwable_klass()))) {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -286,10 +287,0 @@\n-\n-  if (UsePerfData && !class_loader.is_null()) {\n-    \/\/ check whether the current caller thread holds the lock or not.\n-    \/\/ If not, increment the corresponding counter\n-    if (ObjectSynchronizer::\n-        query_lock_ownership(thread, class_loader) !=\n-        ObjectSynchronizer::owner_self) {\n-      ClassLoader::sync_JNIDefineClassLockFreeCounter()->inc();\n-    }\n-  }\n@@ -380,1 +371,1 @@\n-  if (reflected->klass() == SystemDictionary::reflect_Constructor_klass()) {\n+  if (reflected->klass() == vmClasses::reflect_Constructor_klass()) {\n@@ -384,1 +375,1 @@\n-    assert(reflected->klass() == SystemDictionary::reflect_Method_klass(), \"wrong type\");\n+    assert(reflected->klass() == vmClasses::reflect_Method_klass(), \"wrong type\");\n@@ -483,1 +474,1 @@\n-                                 ? SystemDictionary::Object_klass()\n+                                 ? vmClasses::Object_klass()\n@@ -579,1 +570,1 @@\n-    if (ex->is_a(SystemDictionary::ThreadDeath_klass())) {\n+    if (ex->is_a(vmClasses::ThreadDeath_klass())) {\n@@ -588,1 +579,1 @@\n-      if (ex->is_a(SystemDictionary::Throwable_klass())) {\n+      if (ex->is_a(vmClasses::Throwable_klass())) {\n@@ -592,1 +583,1 @@\n-                                SystemDictionary::Throwable_klass(),\n+                                vmClasses::Throwable_klass(),\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -518,1 +518,1 @@\n-  if (mirror->klass() != SystemDictionary::Class_klass()) {\n+  if (mirror->klass() != vmClasses::Class_klass()) {\n@@ -535,1 +535,1 @@\n-      !klass->is_subclass_of(SystemDictionary::Throwable_klass())) {\n+      !klass->is_subclass_of(vmClasses::Throwable_klass())) {\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -83,0 +84,1 @@\n+#include \"runtime\/osThread.hpp\"\n@@ -96,1 +98,0 @@\n-#include \"utilities\/dtrace.hpp\"\n@@ -161,1 +162,1 @@\n-      if (!vfst.method()->method_holder()->is_subclass_of(SystemDictionary::ClassLoader_klass())&&\n+      if (!vfst.method()->method_holder()->is_subclass_of(vmClasses::ClassLoader_klass())&&\n@@ -230,9 +231,0 @@\n-\n-\/\/ Interface version \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\n-JVM_LEAF(jint, JVM_GetInterfaceVersion())\n-  return JVM_INTERFACE_VERSION;\n-JVM_END\n-\n-\n@@ -315,1 +307,1 @@\n-                          SystemDictionary::Properties_klass(),\n+                          vmClasses::Properties_klass(),\n@@ -341,1 +333,1 @@\n-  InstanceKlass* ik = SystemDictionary::String_klass();\n+  InstanceKlass* ik = vmClasses::String_klass();\n@@ -383,1 +375,1 @@\n-#ifdef TIERED\n+#if COMPILER1_AND_COMPILER2\n@@ -391,1 +383,1 @@\n-    #error \"INCLUDE_JVMCI should imply TIERED\"\n+    #error \"INCLUDE_JVMCI should imply COMPILER1_OR_COMPILER2\"\n@@ -395,1 +387,1 @@\n-#endif \/\/ TIERED\n+#endif \/\/ COMPILER1_AND_COMPILER2\n@@ -616,1 +608,1 @@\n-        if (!PENDING_EXCEPTION->is_a(SystemDictionary::Error_klass())) {\n+        if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n@@ -668,1 +660,1 @@\n-    bool cloneable = klass->is_subtype_of(SystemDictionary::Cloneable_klass());\n+    bool cloneable = klass->is_subtype_of(vmClasses::Cloneable_klass());\n@@ -865,13 +857,0 @@\n-static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {\n-  if (loader.is_null()) {\n-    return;\n-  }\n-\n-  \/\/ check whether the current caller thread holds the lock or not.\n-  \/\/ If not, increment the corresponding counter\n-  if (ObjectSynchronizer::query_lock_ownership(THREAD->as_Java_thread(), loader) !=\n-      ObjectSynchronizer::owner_self) {\n-    counter->inc();\n-  }\n-}\n-\n@@ -906,5 +885,0 @@\n-  if (UsePerfData) {\n-    is_lock_held_by_thread(class_loader,\n-                           ClassLoader::sync_JVMDefineClassLockFreeCounter(),\n-                           THREAD);\n-  }\n@@ -1120,6 +1094,0 @@\n-  if (UsePerfData) {\n-    is_lock_held_by_thread(h_loader,\n-                           ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),\n-                           THREAD);\n-  }\n-\n@@ -1192,1 +1160,1 @@\n-    objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);\n+    objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_NULL);\n@@ -1208,1 +1176,1 @@\n-  objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), size, CHECK_NULL);\n@@ -1220,3 +1188,3 @@\n-    result->obj_at_put(0, SystemDictionary::Cloneable_klass()->java_mirror());\n-    result->obj_at_put(1, SystemDictionary::Serializable_klass()->java_mirror());\n-    result->obj_at_put(2, SystemDictionary::IdentityObject_klass()->java_mirror());\n+    result->obj_at_put(0, vmClasses::Cloneable_klass()->java_mirror());\n+    result->obj_at_put(1, vmClasses::Serializable_klass()->java_mirror());\n+    result->obj_at_put(2, vmClasses::IdentityObject_klass()->java_mirror());\n@@ -1336,1 +1304,1 @@\n-    if (method->method_holder() == SystemDictionary::AccessController_klass() &&\n+    if (method->method_holder() == vmClasses::AccessController_klass() &&\n@@ -1376,1 +1344,1 @@\n-  objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),\n+  objArrayOop context = oopFactory::new_objArray(vmClasses::ProtectionDomain_klass(),\n@@ -1424,1 +1392,1 @@\n-    oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);\n+    oop result = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_NULL);\n@@ -1433,1 +1401,1 @@\n-    oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);\n+    oop result = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_NULL);\n@@ -1442,1 +1410,1 @@\n-  objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length\/4, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), length\/4, CHECK_NULL);\n@@ -1472,1 +1440,1 @@\n-    objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);\n+    objArrayOop res = oopFactory::new_objArray(vmClasses::Class_klass(), members, CHECK_NULL);\n@@ -1598,1 +1566,1 @@\n-  if (reflected->klass() == SystemDictionary::reflect_Constructor_klass()) {\n+  if (reflected->klass() == vmClasses::reflect_Constructor_klass()) {\n@@ -1602,1 +1570,1 @@\n-    assert(reflected->klass() == SystemDictionary::reflect_Method_klass(),\n+    assert(reflected->klass() == vmClasses::reflect_Method_klass(),\n@@ -1700,1 +1668,1 @@\n-    objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);\n+    objArrayOop result_oop = oopFactory::new_objArray(vmClasses::reflect_Parameter_klass(), num_params, CHECK_NULL);\n@@ -1729,1 +1697,1 @@\n-    oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);\n+    oop res = oopFactory::new_objArray(vmClasses::reflect_Field_klass(), 0, CHECK_NULL);\n@@ -1751,1 +1719,1 @@\n-  objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::reflect_Field_klass(), num_fields, CHECK_NULL);\n@@ -1801,1 +1769,1 @@\n-      oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);\n+      oopFactory::new_objArray(vmClasses::RecordComponent_klass(), length, CHECK_NULL);\n@@ -1905,1 +1873,1 @@\n-                                           SystemDictionary::reflect_Method_klass(), THREAD);\n+                                           vmClasses::reflect_Method_klass(), THREAD);\n@@ -1913,1 +1881,1 @@\n-                                           SystemDictionary::reflect_Constructor_klass(), THREAD);\n+                                           vmClasses::reflect_Constructor_klass(), THREAD);\n@@ -1973,1 +1941,1 @@\n-    objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n+    objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(),\n@@ -1983,1 +1951,1 @@\n-          if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+          if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n@@ -2017,1 +1985,1 @@\n-        objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n+        objArrayOop r2 = oopFactory::new_objArray(vmClasses::Class_klass(),\n@@ -2051,1 +2019,1 @@\n-    objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n+    objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(),\n@@ -2059,1 +2027,1 @@\n-        if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+        if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n@@ -2080,1 +2048,1 @@\n-      objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n+      objArrayOop r2 = oopFactory::new_objArray(vmClasses::Class_klass(),\n@@ -2258,1 +2226,1 @@\n-  objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);\n+  objArrayOop  dest_o = oopFactory::new_objArray(vmClasses::String_klass(), 3, CHECK_NULL);\n@@ -2307,1 +2275,1 @@\n-  objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);\n+  objArrayOop dest_o = oopFactory::new_objArray(vmClasses::String_klass(), 2, CHECK_NULL);\n@@ -2943,1 +2911,1 @@\n-                          SystemDictionary::Thread_klass(),\n+                          vmClasses::Thread_klass(),\n@@ -3273,1 +3241,1 @@\n-  if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {\n+  if (vmClasses::reflect_CallerSensitive_klass() != NULL) {\n@@ -3276,1 +3244,1 @@\n-    if (!(m->method_holder() == SystemDictionary::SecurityManager_klass() &&\n+    if (!(m->method_holder() == vmClasses::SecurityManager_klass() &&\n@@ -3296,1 +3264,1 @@\n-  objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array->length(), CHECK_NULL);\n+  objArrayOop result = oopFactory::new_objArray(vmClasses::Class_klass(), klass_array->length(), CHECK_NULL);\n@@ -3813,1 +3781,1 @@\n-  objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Thread_klass(), num_threads, CHECK_NULL);\n@@ -3846,1 +3814,1 @@\n-  if (k != SystemDictionary::Thread_klass()) {\n+  if (k != vmClasses::Thread_klass()) {\n@@ -3906,1 +3874,1 @@\n-  objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);\n+  objArrayOop dest_o = oopFactory::new_objArray(vmClasses::Object_klass(), 3, CHECK_NULL);\n@@ -3940,1 +3908,1 @@\n-  InstanceKlass* ik = SystemDictionary::String_klass();\n+  InstanceKlass* ik = vmClasses::String_klass();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":45,"deletions":77,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -902,1 +903,1 @@\n-    if (!ik()->has_injected_identityObject() || iik != SystemDictionary::IdentityObject_klass()) {\n+    if (!ik()->has_injected_identityObject() || iik != vmClasses::IdentityObject_klass()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -414,1 +415,1 @@\n-    if (!k_mirror->is_a(SystemDictionary::Class_klass())) {\n+    if (!k_mirror->is_a(vmClasses::Class_klass())) {\n@@ -857,1 +858,1 @@\n-    if (thread_oop == NULL || !thread_oop->is_a(SystemDictionary::Thread_klass())) {\n+    if (thread_oop == NULL || !thread_oop->is_a(vmClasses::Thread_klass())) {\n@@ -1132,1 +1133,1 @@\n-    if (thread_oop == NULL || !thread_oop->is_a(SystemDictionary::Thread_klass())) {\n+    if (thread_oop == NULL || !thread_oop->is_a(vmClasses::Thread_klass())) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -53,0 +52,1 @@\n+#include \"runtime\/osThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -4241,1 +4242,1 @@\n-  _has_redefined_Object |= the_class == SystemDictionary::Object_klass();\n+  _has_redefined_Object |= the_class == vmClasses::Object_klass();\n@@ -4397,1 +4398,1 @@\n-  assert(!HAS_PENDING_EXCEPTION || (THREAD->pending_exception()->is_a(SystemDictionary::ThreadDeath_klass())), \"redefine exception\");\n+  assert(!HAS_PENDING_EXCEPTION || (THREAD->pending_exception()->is_a(vmClasses::ThreadDeath_klass())), \"redefine exception\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvm_io.h\"\n@@ -29,0 +30,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -84,1 +87,1 @@\n-  assert(SystemDictionary::MethodHandle_klass() != NULL, \"should be present\");\n+  assert(vmClasses::MethodHandle_klass() != NULL, \"should be present\");\n@@ -189,1 +192,1 @@\n-  if (target_klass == SystemDictionary::reflect_Field_klass()) {\n+  if (target_klass == vmClasses::reflect_Field_klass()) {\n@@ -205,1 +208,1 @@\n-  } else if (target_klass == SystemDictionary::reflect_Method_klass()) {\n+  } else if (target_klass == vmClasses::reflect_Method_klass()) {\n@@ -216,1 +219,1 @@\n-  } else if (target_klass == SystemDictionary::reflect_Constructor_klass()) {\n+  } else if (target_klass == vmClasses::reflect_Constructor_klass()) {\n@@ -276,1 +279,1 @@\n-        m_klass_non_interface = SystemDictionary::Object_klass();\n+        m_klass_non_interface = vmClasses::Object_klass();\n@@ -390,1 +393,1 @@\n-  \/\/    if (klass != SystemDictionary::MethodHandle_klass())\n+  \/\/    if (klass != vmClasses::MethodHandle_klass())\n@@ -485,2 +488,1 @@\n-  Klass* mh_klass = SystemDictionary::well_known_klass(\n-                              SystemDictionary::WK_KLASS_ENUM_NAME(MethodHandle_klass) );\n+  Klass* mh_klass = vmClasses::klass_at(VM_CLASS_ID(MethodHandle_klass));\n@@ -492,2 +494,1 @@\n-  Klass* vh_klass = SystemDictionary::well_known_klass(\n-                              SystemDictionary::WK_KLASS_ENUM_NAME(VarHandle_klass) );\n+  Klass* vh_klass = vmClasses::klass_at(VM_CLASS_ID(VarHandle_klass));\n@@ -656,1 +657,1 @@\n-  return SystemDictionary::Object_klass()->java_mirror();\n+  return vmClasses::Object_klass()->java_mirror();\n@@ -677,1 +678,1 @@\n-      return SystemDictionary::Class_klass()->java_mirror();\n+      return vmClasses::Class_klass()->java_mirror();\n@@ -679,1 +680,1 @@\n-      return SystemDictionary::String_klass()->java_mirror();\n+      return vmClasses::String_klass()->java_mirror();\n@@ -722,1 +723,1 @@\n-      defc_klass = SystemDictionary::Object_klass();\n+      defc_klass = vmClasses::Object_klass();\n@@ -739,1 +740,1 @@\n-      (defc == SystemDictionary::MethodHandle_klass() || defc == SystemDictionary::VarHandle_klass()) &&\n+      (defc == vmClasses::MethodHandle_klass() || defc == vmClasses::VarHandle_klass()) &&\n@@ -1320,1 +1321,1 @@\n-  objArrayHandle result = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 2, CHECK_NULL);\n+  objArrayHandle result = oopFactory::new_objArray_handle(vmClasses::Object_klass(), 2, CHECK_NULL);\n@@ -1579,1 +1580,1 @@\n-  assert(SystemDictionary::MethodHandle_klass() != NULL, \"should be present\");\n+  assert(vmClasses::MethodHandle_klass() != NULL, \"should be present\");\n@@ -1581,1 +1582,1 @@\n-  oop mirror = SystemDictionary::MethodHandle_klass()->java_mirror();\n+  oop mirror = vmClasses::MethodHandle_klass()->java_mirror();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -1145,2 +1146,0 @@\n-  Parker* p = NULL;\n-\n@@ -1156,1 +1155,3 @@\n-        p = thr->parker();\n+        Parker* p = thr->parker();\n+        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+        p->unpark();\n@@ -1161,7 +1162,0 @@\n-  \/\/ 'p' points to type-stable-memory if non-NULL. If the target\n-  \/\/ thread terminates before we get here the new user of this\n-  \/\/ Parker will get a 'spurious' unpark - which is perfectly valid.\n-  if (p != NULL) {\n-    HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-    p->unpark();\n-  }\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -38,1 +39,1 @@\n-#include \"compiler\/methodMatcher.hpp\"\n+#include \"compiler\/methodMatcher.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -767,4 +769,0 @@\n-static CompLevel highestCompLevel() {\n-  return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;\n-}\n-\n@@ -857,1 +855,1 @@\n-  if (method == NULL || comp_level > highestCompLevel()) {\n+  if (method == NULL || comp_level > CompilationPolicy::highest_compile_level()) {\n@@ -880,1 +878,1 @@\n-  if (compLevel < CompLevel_none || compLevel > highestCompLevel()) {\n+  if (compLevel < CompLevel_none || compLevel > CompilationPolicy::highest_compile_level()) {\n@@ -978,1 +976,1 @@\n-  if (comp_level > highestCompLevel()) {\n+  if (comp_level > CompilationPolicy::highest_compile_level()) {\n@@ -1000,0 +998,9 @@\n+  \/\/ Check code again because compilation may be finished before Compile_lock is acquired.\n+  if (bci == InvocationEntryBci) {\n+    CompiledMethod* code = mh->code();\n+    if (code != NULL && code->as_nmethod_or_null() != NULL) {\n+      return true;\n+    }\n+  } else if (mh->lookup_osr_nmethod_for(bci, comp_level, false) != NULL) {\n+    return true;\n+  }\n@@ -1104,1 +1111,1 @@\n-  \/\/ set i-counter according to TieredThresholdPolicy::is_method_profiled\n+  \/\/ set i-counter according to CompilationPolicy::is_method_profiled\n@@ -1133,10 +1140,1 @@\n-    mcs->backedge_counter()->init();\n-    mcs->invocation_counter()->init();\n-    mcs->set_interpreter_invocation_count(0);\n-    mcs->set_interpreter_throwout_count(0);\n-\n-#ifdef TIERED\n-    mcs->set_rate(0.0F);\n-    mh->set_prev_event_count(0);\n-    mh->set_prev_time(0);\n-#endif\n+    mcs->clear_counters();\n@@ -1832,1 +1830,1 @@\n-      oopFactory::new_objArray(SystemDictionary::Object_klass(), oop_count, CHECK_NULL);\n+      oopFactory::new_objArray(vmClasses::Object_klass(), oop_count, CHECK_NULL);\n@@ -1853,1 +1851,1 @@\n-        oopFactory::new_objArray(SystemDictionary::Object_klass(), array->length(), CHECK_NULL);\n+        oopFactory::new_objArray(vmClasses::Object_klass(), array->length(), CHECK_NULL);\n@@ -2416,0 +2414,8 @@\n+WB_ENTRY(void, WB_LockCritical(JNIEnv* env, jobject wb))\n+  GCLocker::lock_critical(thread);\n+WB_END\n+\n+WB_ENTRY(void, WB_UnlockCritical(JNIEnv* env, jobject wb))\n+  GCLocker::unlock_critical(thread);\n+WB_END\n+\n@@ -2685,0 +2691,3 @@\n+\n+  {CC\"lockCritical\",    CC\"()V\",                      (void*)&WB_LockCritical},\n+  {CC\"unlockCritical\",  CC\"()V\",                      (void*)&WB_UnlockCritical},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compilerDefinitions.hpp\"\n@@ -1459,7 +1460,5 @@\n-  if (TieredCompilation) {\n-    if (FLAG_IS_DEFAULT(Tier3InvokeNotifyFreqLog)) {\n-      Tier3InvokeNotifyFreqLog = Arguments::_Tier3InvokeNotifyFreqLog;\n-    }\n-    if (FLAG_IS_DEFAULT(Tier4InvocationThreshold)) {\n-      Tier4InvocationThreshold = Arguments::_Tier4InvocationThreshold;\n-    }\n+  if (FLAG_IS_DEFAULT(Tier3InvokeNotifyFreqLog)) {\n+    Tier3InvokeNotifyFreqLog = Arguments::_Tier3InvokeNotifyFreqLog;\n+  }\n+  if (FLAG_IS_DEFAULT(Tier4InvocationThreshold)) {\n+    Tier4InvocationThreshold = Arguments::_Tier4InvocationThreshold;\n@@ -1489,1 +1488,1 @@\n-    if (TieredCompilation) {\n+    if (CompilerConfig::is_c2_or_jvmci_compiler_enabled()) {\n@@ -2149,4 +2148,2 @@\n-  if (TieredCompilation) {\n-    Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;\n-    Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;\n-  }\n+  Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;\n+  Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;\n@@ -3133,2 +3130,0 @@\n-\n-#ifdef TIERED\n@@ -3139,4 +3134,0 @@\n-#else\n-  \/\/ Tiered compilation is undefined.\n-  UNSUPPORTED_OPTION(TieredCompilation);\n-#endif\n@@ -3191,4 +3182,0 @@\n-  UNSUPPORTED_OPTION_INIT(Tier0AOTInvocationThreshold, 0);\n-  UNSUPPORTED_OPTION_INIT(Tier0AOTMinInvocationThreshold, 0);\n-  UNSUPPORTED_OPTION_INIT(Tier0AOTCompileThreshold, 0);\n-  UNSUPPORTED_OPTION_INIT(Tier0AOTBackEdgeThreshold, 0);\n@@ -4027,6 +4014,0 @@\n-#ifndef TIERED\n-  if (FLAG_IS_CMDLINE(CompilationMode)) {\n-    warning(\"CompilationMode has no effect in non-tiered VMs\");\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":9,"deletions":28,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -71,0 +72,1 @@\n+#include \"runtime\/osThread.hpp\"\n@@ -1039,1 +1041,1 @@\n-   BasicType box_type = SystemDictionary::box_klass_type(k);\n+   BasicType box_type = vmClasses::box_klass_type(k);\n@@ -1891,1 +1893,1 @@\n-      assert((PENDING_EXCEPTION->is_a(SystemDictionary::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n+      assert((PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n@@ -2303,1 +2305,1 @@\n-    if (ProfileTraps && !is_client_compilation_mode_vm() && update_trap_state && trap_mdo != NULL) {\n+    if (ProfileTraps && CompilerConfig::is_c2_or_jvmci_compiler_enabled() && update_trap_state && trap_mdo != NULL) {\n@@ -2425,1 +2427,1 @@\n-      CompilationPolicy::policy()->reprofile(trap_scope, nm->is_osr_method());\n+      CompilationPolicy::reprofile(trap_scope, nm->is_osr_method());\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"interpreter\/bytecodes.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -566,0 +566,1 @@\n+  if (buf == NULL || buflen < 1) return;\n@@ -567,0 +568,1 @@\n+  buf[0] = '\\0';\n@@ -568,1 +570,1 @@\n-  if (found) {\n+  if (found && buf[0] != '\\0') {\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"oops\/method.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -40,0 +40,1 @@\n+class CompiledMethod;\n@@ -43,0 +44,2 @@\n+class Method;\n+class methodHandle;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -557,0 +557,6 @@\n+  product(intx, HeapDumpGzipLevel, 0, MANAGEABLE,                           \\\n+          \"When HeapDumpOnOutOfMemoryError is on, the gzip compression \"    \\\n+          \"level of the dump file. 0 (the default) disables gzip \"          \\\n+          \"compression. Otherwise the level must be between 1 and 9.\")      \\\n+          range(0, 9)                                                       \\\n+                                                                            \\\n@@ -1505,0 +1511,3 @@\n+  product(bool, PrintMetaspaceStatisticsAtExit, false, DIAGNOSTIC,          \\\n+          \"Print metaspace statistics upon VM exit.\")                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"oops\/method.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-        if (!PENDING_EXCEPTION->is_a(SystemDictionary::Error_klass())) {\n+        if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -480,2 +480,2 @@\n-  if (SystemDictionary::reflect_MagicAccessorImpl_klass_is_loaded() &&\n-      current_class->is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {\n+  if (vmClasses::reflect_MagicAccessorImpl_klass_is_loaded() &&\n+      current_class->is_subclass_of(vmClasses::reflect_MagicAccessorImpl_klass())) {\n@@ -706,1 +706,1 @@\n-  if (current_class->is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {\n+  if (current_class->is_subclass_of(vmClasses::reflect_MagicAccessorImpl_klass())) {\n@@ -769,1 +769,1 @@\n-  objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));\n+  objArrayOop m = oopFactory::new_objArray(vmClasses::Class_klass(), parameter_count, CHECK_(objArrayHandle()));\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -565,1 +564,1 @@\n-      CompilationPolicy::policy()->do_safepoint_work();\n+      CompilationPolicy::do_safepoint_work();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -794,1 +794,1 @@\n-  Klass* k = SystemDictionary::StackOverflowError_klass();\n+  Klass* k = vmClasses::StackOverflowError_klass();\n@@ -1098,1 +1098,1 @@\n-    SystemDictionary::ValueBootstrapMethods_klass()->initialize(CHECK_NH);\n+    vmClasses::ValueBootstrapMethods_klass()->initialize(CHECK_NH);\n@@ -1101,1 +1101,1 @@\n-    Method* is_subst = SystemDictionary::ValueBootstrapMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n+    Method* is_subst = vmClasses::ValueBootstrapMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n@@ -1275,1 +1275,1 @@\n-           callee_method->method_holder() != SystemDictionary::Object_klass()) {\n+           callee_method->method_holder() != vmClasses::Object_klass()) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -60,25 +61,0 @@\n-class MonitorList {\n-  ObjectMonitor* volatile _head;\n-  volatile size_t _count;\n-  volatile size_t _max;\n-\n-public:\n-  void add(ObjectMonitor* monitor);\n-  size_t unlink_deflated(Thread* self, LogStream* ls, elapsedTimer* timer_p,\n-                         GrowableArray<ObjectMonitor*>* unlinked_list);\n-  size_t count() const;\n-  size_t max() const;\n-\n-  class Iterator;\n-  Iterator iterator() const;\n-};\n-\n-class MonitorList::Iterator {\n-  ObjectMonitor* _current;\n-\n-public:\n-  Iterator(ObjectMonitor* head) : _current(head) {}\n-  bool has_next() const { return _current != NULL; }\n-  ObjectMonitor* next();\n-};\n-\n@@ -242,1 +218,1 @@\n-static MonitorList _in_use_list;\n+MonitorList ObjectSynchronizer::_in_use_list;\n@@ -1070,47 +1046,0 @@\n-\/\/ Be aware of this method could revoke bias of the lock object.\n-\/\/ This method queries the ownership of the lock handle specified by 'h_obj'.\n-\/\/ If the current thread owns the lock, it returns owner_self. If no\n-\/\/ thread owns the lock, it returns owner_none. Otherwise, it will return\n-\/\/ owner_other.\n-ObjectSynchronizer::LockOwnership ObjectSynchronizer::query_lock_ownership\n-(JavaThread *self, Handle h_obj) {\n-  \/\/ The caller must beware this method can revoke bias, and\n-  \/\/ revocation can result in a safepoint.\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(self->thread_state() != _thread_blocked, \"invariant\");\n-\n-  \/\/ Possible mark states: neutral, biased, stack-locked, inflated\n-\n-  if (UseBiasedLocking && h_obj()->mark().has_bias_pattern()) {\n-    \/\/ CASE: biased\n-    BiasedLocking::revoke(h_obj, self);\n-    assert(!h_obj->mark().has_bias_pattern(),\n-           \"biases should be revoked by now\");\n-  }\n-\n-  assert(self == JavaThread::current(), \"Can only be called on current thread\");\n-  oop obj = h_obj();\n-  markWord mark = read_stable_mark(obj);\n-\n-  \/\/ CASE: stack-locked.  Mark points to a BasicLock on the owner's stack.\n-  if (mark.has_locker()) {\n-    return self->is_lock_owned((address)mark.locker()) ?\n-      owner_self : owner_other;\n-  }\n-\n-  \/\/ CASE: inflated. Mark (tagged pointer) points to an ObjectMonitor.\n-  if (mark.has_monitor()) {\n-    \/\/ The first stage of async deflation does not affect any field\n-    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n-    ObjectMonitor* monitor = mark.monitor();\n-    void* owner = monitor->owner();\n-    if (owner == NULL) return owner_none;\n-    return (owner == self ||\n-            self->is_lock_owned((address)owner)) ? owner_self : owner_other;\n-  }\n-\n-  \/\/ CASE: neutral\n-  assert(mark.is_neutral(), \"sanity check\");\n-  return owner_none;           \/\/ it's unlocked\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":73,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/perfData.hpp\"\n@@ -39,0 +38,28 @@\n+class MonitorList {\n+  friend class VMStructs;\n+\n+private:\n+  ObjectMonitor* volatile _head;\n+  volatile size_t _count;\n+  volatile size_t _max;\n+\n+public:\n+  void add(ObjectMonitor* monitor);\n+  size_t unlink_deflated(Thread* self, LogStream* ls, elapsedTimer* timer_p,\n+                         GrowableArray<ObjectMonitor*>* unlinked_list);\n+  size_t count() const;\n+  size_t max() const;\n+\n+  class Iterator;\n+  Iterator iterator() const;\n+};\n+\n+class MonitorList::Iterator {\n+  ObjectMonitor* _current;\n+\n+public:\n+  Iterator(ObjectMonitor* head) : _current(head) {}\n+  bool has_next() const { return _current != NULL; }\n+  ObjectMonitor* next();\n+};\n+\n@@ -43,6 +70,0 @@\n-  typedef enum {\n-    owner_self,\n-    owner_none,\n-    owner_other\n-  } LockOwnership;\n-\n@@ -110,1 +131,0 @@\n-  static LockOwnership query_lock_ownership(JavaThread* self, Handle h_obj);\n@@ -155,0 +175,1 @@\n+  static MonitorList _in_use_list;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -855,1 +856,1 @@\n-                            SystemDictionary::ThreadGroup_klass(),\n+                            vmClasses::ThreadGroup_klass(),\n@@ -862,1 +863,1 @@\n-                            SystemDictionary::ThreadGroup_klass(),\n+                            vmClasses::ThreadGroup_klass(),\n@@ -873,1 +874,1 @@\n-  InstanceKlass* ik = SystemDictionary::Thread_klass();\n+  InstanceKlass* ik = vmClasses::Thread_klass();\n@@ -1051,1 +1052,1 @@\n-  InstanceKlass* ik = SystemDictionary::Thread_klass();\n+  InstanceKlass* ik = vmClasses::Thread_klass();\n@@ -1096,1 +1097,1 @@\n-  Klass* group = SystemDictionary::ThreadGroup_klass();\n+  Klass* group = vmClasses::ThreadGroup_klass();\n@@ -1570,1 +1571,1 @@\n-  _parker(Parker::Allocate(this)),\n+  _parker(),\n@@ -1607,0 +1608,3 @@\n+  \/\/ All callers should have 'this' thread protected by a\n+  \/\/ ThreadsListHandle so that it cannot terminate and deallocate\n+  \/\/ itself.\n@@ -1704,4 +1708,0 @@\n-  \/\/ JSR166 -- return the parker to the free list\n-  Parker::Release(_parker);\n-  _parker = NULL;\n-\n@@ -1867,1 +1867,1 @@\n-      Klass* thread_klass = SystemDictionary::Thread_klass();\n+      Klass* thread_klass = vmClasses::Thread_klass();\n@@ -1894,1 +1894,1 @@\n-        Klass* thread_klass = SystemDictionary::Thread_klass();\n+        Klass* thread_klass = vmClasses::Thread_klass();\n@@ -2152,1 +2152,1 @@\n-    if (!has_pending_exception() || !pending_exception()->is_a(SystemDictionary::ThreadDeath_klass())) {\n+    if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n@@ -2240,1 +2240,1 @@\n-    if (_pending_async_exception == NULL || !_pending_async_exception->is_a(SystemDictionary::ThreadDeath_klass())) {\n+    if (_pending_async_exception == NULL || !_pending_async_exception->is_a(vmClasses::ThreadDeath_klass())) {\n@@ -3133,1 +3133,1 @@\n-      assert(!os::supports_monotonic_clock(),\n+      assert(false,\n@@ -3307,1 +3307,1 @@\n-  Klass* klass = SystemDictionary::System_klass();\n+  Klass* klass = vmClasses::System_klass();\n@@ -3327,1 +3327,1 @@\n-  Klass* klass = SystemDictionary::System_klass();\n+  Klass* klass = vmClasses::System_klass();\n@@ -3349,1 +3349,1 @@\n-  Klass* klass = SystemDictionary::System_klass();\n+  Klass* klass = vmClasses::System_klass();\n@@ -3381,1 +3381,1 @@\n-  InstanceKlass *k = SystemDictionary::UnsafeConstants_klass();\n+  InstanceKlass *k = vmClasses::UnsafeConstants_klass();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/osThread.hpp\"\n@@ -67,0 +67,1 @@\n+class OSThread;\n@@ -69,2 +70,0 @@\n-class ParkEvent;\n-class Parker;\n@@ -1864,1 +1863,1 @@\n-  Parker*    _parker;\n+  Parker _parker;\n@@ -1866,1 +1865,1 @@\n-  Parker*     parker() { return _parker; }\n+  Parker* parker() { return &_parker; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -94,0 +95,1 @@\n+#include \"runtime\/osThread.hpp\"\n@@ -293,3 +295,0 @@\n-  nonstatic_field(MethodCounters,              _interpreter_invocation_limit,                 int)                                   \\\n-  nonstatic_field(MethodCounters,              _interpreter_backward_branch_limit,            int)                                   \\\n-  nonstatic_field(MethodCounters,              _interpreter_profile_limit,                    int)                                   \\\n@@ -298,1 +297,0 @@\n-  COMPILER2_OR_JVMCI_PRESENT(nonstatic_field(MethodCounters, _interpreter_invocation_count,   int))                                  \\\n@@ -461,8 +459,8 @@\n-     static_field(SystemDictionary,            WK_KLASS(Object_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(String_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(Class_klass),                         InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(ClassLoader_klass),                   InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(System_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(Thread_klass),                        InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(ThreadGroup_klass),                   InstanceKlass*)                        \\\n-     static_field(SystemDictionary,            WK_KLASS(MethodHandle_klass),                  InstanceKlass*)                        \\\n+     static_field(vmClasses,                   VM_CLASS_AT(Object_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(String_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(Class_klass),                         InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(ClassLoader_klass),                   InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(System_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(Thread_klass),                        InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(ThreadGroup_klass),                   InstanceKlass*)                     \\\n+     static_field(vmClasses,                   VM_CLASS_AT(MethodHandle_klass),                  InstanceKlass*)                     \\\n@@ -895,0 +893,2 @@\n+  static_field(ObjectSynchronizer,             _in_use_list,                                  MonitorList)                           \\\n+  volatile_nonstatic_field(MonitorList,        _head,                                         ObjectMonitor*)                        \\\n@@ -1327,0 +1327,1 @@\n+  declare_toplevel_type(vmClasses)                                        \\\n@@ -1472,0 +1473,1 @@\n+  declare_toplevel_type(MonitorList)                                      \\\n@@ -2427,6 +2429,0 @@\n-  \/***************************************************\/                   \\\n-  \/* DEFAULT_CACHE_LINE_SIZE (globalDefinitions.hpp) *\/                   \\\n-  \/***************************************************\/                   \\\n-                                                                          \\\n-  declare_preprocessor_constant(\"DEFAULT_CACHE_LINE_SIZE\", DEFAULT_CACHE_LINE_SIZE) \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -66,1 +68,1 @@\n-                         SystemDictionary::module_Modules_klass(),\n+                         vmClasses::module_Modules_klass(),\n@@ -451,1 +453,1 @@\n-  Klass* k = SystemDictionary::System_klass();\n+  Klass* k = vmClasses::System_klass();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -1426,1 +1426,1 @@\n-  if (o->klass() == SystemDictionary::Class_klass()) {\n+  if (o->klass() == vmClasses::Class_klass()) {\n@@ -1516,1 +1516,1 @@\n-      InstanceKlass* oome_ik = SystemDictionary::OutOfMemoryError_klass();\n+      InstanceKlass* oome_ik = vmClasses::OutOfMemoryError_klass();\n@@ -2032,1 +2032,1 @@\n-  const char* dump_file_ext  = \".hprof\";\n+  const char* dump_file_ext  = HeapDumpGzipLevel > 0 ? \".hprof.gz\" : \".hprof\";\n@@ -2099,1 +2099,1 @@\n-  dumper.dump(my_path, tty);\n+  dumper.dump(my_path, tty, HeapDumpGzipLevel);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"jvm.h\"\n+#include \"jvm_constants.h\"\n@@ -30,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"jvm.h\"\n","filename":"src\/hotspot\/share\/utilities\/constantTag.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4403,1 +4403,1 @@\n-     * {@code IndexOutOfBoundsException} if the index is less than {@code 0}\n+     * {@code ArrayIndexOutOfBoundsException} if the index is less than {@code 0}\n@@ -5786,0 +5786,4 @@\n+        if (pos < 0 || (rtype == void.class && pos > targetType.parameterCount()) ||\n+                       (rtype != void.class && pos >= targetType.parameterCount())) {\n+            throw newIllegalArgumentException(\"position is out of range for target\", target, pos);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-    private transient Reference<T> discovered;\n+    private transient Reference<?> discovered;\n@@ -223,1 +223,1 @@\n-    private static native Reference<Object> getAndClearReferencePendingList();\n+    private static native Reference<?> getAndClearReferencePendingList();\n@@ -235,0 +235,10 @@\n+    \/*\n+     * Enqueue a Reference taken from the pending list.  Calling this method\n+     * takes us from the Reference<?> domain of the pending list elements to\n+     * having a Reference<T> with a correspondingly typed queue.\n+     *\/\n+    private void enqueueFromPending() {\n+        var q = queue;\n+        if (q != ReferenceQueue.NULL) q.enqueue(this);\n+    }\n+\n@@ -244,1 +254,1 @@\n-        Reference<Object> pendingList;\n+        Reference<?> pendingList;\n@@ -250,1 +260,1 @@\n-            Reference<Object> ref = pendingList;\n+            Reference<?> ref = pendingList;\n@@ -263,2 +273,1 @@\n-                ReferenceQueue<? super Object> q = ref.queue;\n-                if (q != ReferenceQueue.NULL) q.enqueue(ref);\n+                ref.enqueueFromPending();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+        r = scanAndReduce(node.getModule(), p, r);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1722,0 +1722,1 @@\n+            boolean errorEnumSwitch = TreeInfo.isErrorEnumSwitch(selector, cases);\n@@ -1752,0 +1753,11 @@\n+                        } else if (errorEnumSwitch) {\n+                            \/\/error recovery: the selector is erroneous, and all the case labels\n+                            \/\/are identifiers. This could be an enum switch - don't report resolve\n+                            \/\/error for the case label:\n+                            var prevResolveHelper = rs.basicLogResolveHelper;\n+                            try {\n+                                rs.basicLogResolveHelper = rs.silentLogResolveHelper;\n+                                attribExpr(pat, switchEnv, seltype);\n+                            } finally {\n+                                rs.basicLogResolveHelper = prevResolveHelper;\n+                            }\n@@ -2478,0 +2490,1 @@\n+                    attribExpr(((JCFieldAccess) tree.meth).selected, localEnv, site);\n@@ -2503,0 +2516,2 @@\n+            } else if (site.hasTag(ERROR) && tree.meth.hasTag(SELECT)) {\n+                attribExpr(((JCFieldAccess) tree.meth).selected, localEnv, site);\n@@ -3924,1 +3939,1 @@\n-        if (sym != null && sym.kind.matches(KindSelector.TYP_PCK))\n+        if (sym != null && sym.kind.matches(KindSelector.TYP_PCK) && sym.kind != Kind.ERR)\n@@ -4085,1 +4100,1 @@\n-                log.error(tree.pos(), Errors.InstanceofPatternNoSubtype(clazztype, exprtype));\n+                log.error(tree.pos(), Errors.InstanceofPatternNoSubtype(exprtype, clazztype));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -741,1 +741,2 @@\n-            if ((constants == null || !constants.isEmpty()) && !hasDefault) {\n+            if ((constants == null || !constants.isEmpty()) && !hasDefault &&\n+                !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2685,0 +2685,9 @@\n+        }\n+    };\n+\n+    LogResolveHelper silentLogResolveHelper = new LogResolveHelper() {\n+        public boolean resolveDiagnosticNeeded(Type site, List<Type> argtypes, List<Type> typeargtypes) {\n+            return false;\n+        }\n+        public List<Type> getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List<Type> argtypes) {\n+            return argtypes;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3437,1 +3437,3 @@\n-                if (type.hasTag(TYPEARRAY) && !compound) {\n+                if (typeName != names.var) {\n+                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedHere(typeName));\n+                } else if (type.hasTag(TYPEARRAY) && !compound) {\n@@ -3439,1 +3441,1 @@\n-                    reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n+                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n@@ -3443,1 +3445,1 @@\n-                        reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n+                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.HashMap;\n@@ -29,0 +30,1 @@\n+import java.util.Map;\n@@ -33,6 +35,1 @@\n-import com.sun.tools.javac.util.List;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.Filter;\n-import com.sun.tools.javac.util.ListBuffer;\n-import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.*;\n@@ -55,9 +52,1 @@\n-    private final TokenKind[] key;\n-\n-    \/**  The number of the last entered keyword.\n-     *\/\n-    private int maxKey = 0;\n-\n-    \/** The names of all tokens.\n-     *\/\n-    private Name[] tokenName = new Name[TokenKind.values().length];\n+    private Map<String, TokenKind> keywords = new HashMap<>();\n@@ -78,4 +67,4 @@\n-            if (t.name != null)\n-                enterKeyword(t.name, t);\n-            else\n-                tokenName[t.ordinal()] = null;\n+            if (t.name != null) {\n+                names.fromString(t.name);\n+                keywords.put(t.name, t);\n+            }\n@@ -83,13 +72,0 @@\n-\n-        key = new TokenKind[maxKey+1];\n-        for (int i = 0; i <= maxKey; i++) key[i] = TokenKind.IDENTIFIER;\n-        for (TokenKind t : TokenKind.values()) {\n-            if (t.name != null)\n-                key[tokenName[t.ordinal()].getIndex()] = t;\n-        }\n-    }\n-\n-    private void enterKeyword(String s, TokenKind token) {\n-        Name n = names.fromString(s);\n-        tokenName[token.ordinal()] = n;\n-        if (n.getIndex() > maxKey) maxKey = n.getIndex();\n@@ -104,1 +80,2 @@\n-        return (name.getIndex() > maxKey) ? TokenKind.IDENTIFIER : key[name.getIndex()];\n+        TokenKind t = keywords.get(name.toString());\n+        return (t != null) ? t : TokenKind.IDENTIFIER;\n@@ -108,1 +85,2 @@\n-        return lookupKind(names.fromString(name));\n+        TokenKind t = keywords.get(name);\n+        return (t != null) ? t : TokenKind.IDENTIFIER;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":13,"deletions":35,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1420,1 +1420,1 @@\n-    pattern type {0} is a subtype of expression type {1}\n+    expression type {0} is a subtype of pattern type {1}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -560,0 +560,5 @@\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCModuleDecl getModule() {\n+            return getModuleDecl();\n+        }\n+\n@@ -600,2 +605,3 @@\n-            for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail)\n-                if (!typeDefs.head.hasTag(PACKAGEDEF) && !typeDefs.head.hasTag(IMPORT))\n+            for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail) {\n+                if (!typeDefs.head.hasTag(MODULEDEF)\n+                        && !typeDefs.head.hasTag(PACKAGEDEF) && !typeDefs.head.hasTag(IMPORT)) {\n@@ -603,0 +609,2 @@\n+                }\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+                print(\" \");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1332,0 +1332,5 @@\n+    public static boolean isErrorEnumSwitch(JCExpression selector, List<JCCase> cases) {\n+        return selector.type.tsym.kind == Kinds.Kind.ERR &&\n+               cases.stream().flatMap(c -> c.pats.stream())\n+                             .allMatch(p -> p.hasTag(IDENT));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.code.Types;\n@@ -52,0 +53,1 @@\n+    private final Types types;\n@@ -65,1 +67,1 @@\n-    TypePrinter(JavacMessages messages,\n+    TypePrinter(JavacMessages messages, Types types,\n@@ -68,1 +70,1 @@\n-        this(messages, fullClassNameAndPackageToClass, cs -> cs.flatName().toString(),\n+        this(messages, types, fullClassNameAndPackageToClass, cs -> cs.flatName().toString(),\n@@ -82,1 +84,1 @@\n-    TypePrinter(JavacMessages messages,\n+    TypePrinter(JavacMessages messages, Types types,\n@@ -87,0 +89,1 @@\n+        this.types = types;\n@@ -140,1 +143,1 @@\n-                return OBJECT;\n+                return visit(types.erasure(t), locale);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TypePrinter.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -28,0 +28,1 @@\n+#include \"oops\/instanceKlass.hpp\"\n@@ -88,1 +89,1 @@\n-  oop obj = SystemDictionary::Byte_klass()->allocate_instance(THREAD);\n+  oop obj = vmClasses::Byte_klass()->allocate_instance(THREAD);\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -252,2 +252,0 @@\n-vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses021\/TestDescription.java 8065773 generic-all\n-vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses023\/TestDescription.java 8065773 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -295,1 +295,0 @@\n- -runtime\/ErrorHandling\/TestHeapDumpOnOutOfMemoryErrorInMetaspace.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,8 @@\n+    static void checkAIOOBE(ThrowingRunnable r) {\n+        checkWithThrowable(ArrayIndexOutOfBoundsException.class, null, r);\n+    }\n+\n+    static void checkAIOOBE(Object message, ThrowingRunnable r) {\n+        checkWithThrowable(ArrayIndexOutOfBoundsException.class, message, r);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleBaseTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1231,1 +1231,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1235,1 +1235,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1239,1 +1239,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1243,1 +1243,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1247,1 +1247,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1251,1 +1251,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1255,1 +1255,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1259,1 +1259,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1263,1 +1263,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1267,1 +1267,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1271,1 +1271,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1275,1 +1275,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1279,1 +1279,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1283,1 +1283,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1287,1 +1287,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1291,1 +1291,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1295,1 +1295,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1299,1 +1299,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1303,1 +1303,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1308,1 +1308,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1312,1 +1312,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1316,1 +1316,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1320,1 +1320,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1324,1 +1324,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1328,1 +1328,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1332,1 +1332,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1336,1 +1336,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1340,1 +1340,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessBoolean.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1257,1 +1257,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1261,1 +1261,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1265,1 +1265,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1269,1 +1269,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1273,1 +1273,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1277,1 +1277,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1281,1 +1281,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1285,1 +1285,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1289,1 +1289,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1293,1 +1293,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1297,1 +1297,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1301,1 +1301,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1305,1 +1305,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1309,1 +1309,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1313,1 +1313,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1317,1 +1317,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1321,1 +1321,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1325,1 +1325,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1329,1 +1329,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1333,1 +1333,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1337,1 +1337,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1341,1 +1341,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1345,1 +1345,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1349,1 +1349,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1353,1 +1353,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1357,1 +1357,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1361,1 +1361,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1365,1 +1365,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1369,1 +1369,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1373,1 +1373,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1377,1 +1377,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessByte.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1257,1 +1257,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1261,1 +1261,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1265,1 +1265,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1269,1 +1269,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1273,1 +1273,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1277,1 +1277,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1281,1 +1281,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1285,1 +1285,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1289,1 +1289,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1293,1 +1293,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1297,1 +1297,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1301,1 +1301,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1305,1 +1305,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1309,1 +1309,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1313,1 +1313,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1317,1 +1317,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1321,1 +1321,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1325,1 +1325,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1329,1 +1329,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1333,1 +1333,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1337,1 +1337,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1341,1 +1341,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1345,1 +1345,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1349,1 +1349,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1353,1 +1353,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1357,1 +1357,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1361,1 +1361,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1365,1 +1365,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1369,1 +1369,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1373,1 +1373,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1377,1 +1377,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessChar.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1183,1 +1183,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1187,1 +1187,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1191,1 +1191,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1195,1 +1195,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1199,1 +1199,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1203,1 +1203,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1207,1 +1207,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1211,1 +1211,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1215,1 +1215,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1219,1 +1219,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1223,1 +1223,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1227,1 +1227,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1231,1 +1231,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1235,1 +1235,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1239,1 +1239,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1243,1 +1243,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1247,1 +1247,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1251,1 +1251,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1255,1 +1255,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1259,1 +1259,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1263,1 +1263,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1267,1 +1267,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessDouble.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1183,1 +1183,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1187,1 +1187,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1191,1 +1191,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1195,1 +1195,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1199,1 +1199,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1203,1 +1203,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1207,1 +1207,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1211,1 +1211,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1215,1 +1215,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1219,1 +1219,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1223,1 +1223,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1227,1 +1227,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1231,1 +1231,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1235,1 +1235,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1239,1 +1239,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1243,1 +1243,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1247,1 +1247,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1251,1 +1251,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1255,1 +1255,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1259,1 +1259,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1263,1 +1263,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1267,1 +1267,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessFloat.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1257,1 +1257,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1261,1 +1261,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1265,1 +1265,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1269,1 +1269,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1273,1 +1273,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1277,1 +1277,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1281,1 +1281,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1285,1 +1285,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1289,1 +1289,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1293,1 +1293,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1297,1 +1297,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1301,1 +1301,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1305,1 +1305,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1309,1 +1309,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1313,1 +1313,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1317,1 +1317,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1321,1 +1321,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1325,1 +1325,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1329,1 +1329,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1333,1 +1333,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1337,1 +1337,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1341,1 +1341,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1345,1 +1345,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1349,1 +1349,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1353,1 +1353,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1357,1 +1357,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1361,1 +1361,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1365,1 +1365,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1369,1 +1369,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1373,1 +1373,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1377,1 +1377,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessInt.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1257,1 +1257,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1261,1 +1261,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1265,1 +1265,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1269,1 +1269,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1273,1 +1273,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1277,1 +1277,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1281,1 +1281,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1285,1 +1285,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1289,1 +1289,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1293,1 +1293,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1297,1 +1297,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1301,1 +1301,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1305,1 +1305,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1309,1 +1309,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1313,1 +1313,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1317,1 +1317,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1321,1 +1321,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1325,1 +1325,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1329,1 +1329,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1333,1 +1333,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1337,1 +1337,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1341,1 +1341,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1345,1 +1345,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1349,1 +1349,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1353,1 +1353,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1357,1 +1357,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1361,1 +1361,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1365,1 +1365,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1369,1 +1369,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1373,1 +1373,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1377,1 +1377,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessLong.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1257,1 +1257,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1261,1 +1261,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1265,1 +1265,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1269,1 +1269,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1273,1 +1273,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1277,1 +1277,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1281,1 +1281,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1285,1 +1285,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1289,1 +1289,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1293,1 +1293,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1297,1 +1297,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1301,1 +1301,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1305,1 +1305,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1309,1 +1309,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1313,1 +1313,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1317,1 +1317,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1321,1 +1321,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1325,1 +1325,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1329,1 +1329,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1333,1 +1333,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1337,1 +1337,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1341,1 +1341,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1345,1 +1345,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1349,1 +1349,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1353,1 +1353,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1357,1 +1357,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1361,1 +1361,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1365,1 +1365,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1369,1 +1369,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1373,1 +1373,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1377,1 +1377,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessShort.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1143,1 +1143,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1147,1 +1147,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1151,1 +1151,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1155,1 +1155,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1159,1 +1159,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1163,1 +1163,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1167,1 +1167,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1171,1 +1171,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1175,1 +1175,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1179,1 +1179,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1183,1 +1183,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1187,1 +1187,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1191,1 +1191,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1195,1 +1195,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1199,1 +1199,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1203,1 +1203,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1207,1 +1207,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1211,1 +1211,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1215,1 +1215,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessString.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -913,1 +913,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -919,1 +919,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -925,1 +925,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -931,1 +931,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -937,1 +937,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -944,1 +944,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessBoolean.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,1 +974,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -980,1 +980,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -986,1 +986,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -992,1 +992,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -998,1 +998,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1004,1 +1004,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1010,1 +1010,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessByte.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,1 +974,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -980,1 +980,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -986,1 +986,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -992,1 +992,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -998,1 +998,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1004,1 +1004,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1010,1 +1010,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessChar.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -745,1 +745,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -751,1 +751,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -757,1 +757,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -763,1 +763,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -769,1 +769,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -775,1 +775,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessDouble.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -745,1 +745,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -751,1 +751,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -757,1 +757,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -763,1 +763,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -769,1 +769,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -775,1 +775,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessFloat.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,1 +974,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -980,1 +980,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -986,1 +986,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -992,1 +992,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -998,1 +998,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1004,1 +1004,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1010,1 +1010,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessInt.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,1 +974,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -980,1 +980,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -986,1 +986,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -992,1 +992,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -998,1 +998,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1004,1 +1004,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1010,1 +1010,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessLong.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,1 +974,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -980,1 +980,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -986,1 +986,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -992,1 +992,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -998,1 +998,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1004,1 +1004,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1010,1 +1010,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessShort.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -648,1 +648,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -654,1 +654,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -660,1 +660,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -666,1 +666,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -672,1 +672,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessString.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1819,1 +1819,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1823,1 +1823,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1827,1 +1827,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1831,1 +1831,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1835,1 +1835,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1839,1 +1839,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1843,1 +1843,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1847,1 +1847,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1852,1 +1852,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1856,1 +1856,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1860,1 +1860,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1864,1 +1864,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1868,1 +1868,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1872,1 +1872,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1876,1 +1876,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1880,1 +1880,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1884,1 +1884,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1888,1 +1888,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1892,1 +1892,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1898,1 +1898,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1902,1 +1902,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1906,1 +1906,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1912,1 +1912,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1916,1 +1916,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1920,1 +1920,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1924,1 +1924,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1928,1 +1928,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1932,1 +1932,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1936,1 +1936,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1940,1 +1940,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n@@ -1944,1 +1944,1 @@\n-            checkIOOBE(() -> {\n+            checkAIOOBE(() -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestAccess.java.template","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1136,1 +1136,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1142,1 +1142,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1149,1 +1149,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1155,1 +1155,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1161,1 +1161,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1169,1 +1169,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n@@ -1177,1 +1177,1 @@\n-                checkIOOBE(am, () -> {\n+                checkAIOOBE(am, () -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestMethodHandleAccess.java.template","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -247,0 +247,5 @@\n+        \/\/ Interpreted mode cannot enable JVMCI\n+        if (vmCompMode().equals(\"Xint\")) {\n+          return \"false\";\n+        }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -660,0 +660,4 @@\n+\n+  public native void lockCritical();\n+\n+  public native void unlockCritical();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}