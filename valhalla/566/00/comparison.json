{"files":[{"patch":"@@ -84,1 +84,15 @@\n-  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : NULL;\n+  if (in(0) && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+\n+  \/\/ Push cast through InlineTypePtrNode\n+  InlineTypePtrNode* vt = in(1)->isa_InlineTypePtr();\n+  if (vt != NULL && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n+    Node* cast = clone();\n+    cast->set_req(1, vt->get_oop());\n+    vt = vt->clone()->as_InlineTypePtr();\n+    vt->set_oop(phase->transform(cast));\n+    return vt;\n+  }\n+\n+  return NULL;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1935,0 +1935,2 @@\n+  ResourceMark rm;\n+  Node_List casts;\n@@ -1936,7 +1938,8 @@\n-    Node* n = in(i)->uncast();\n-    Node* other = NULL;\n-    if (n->is_InlineTypeBase()) {\n-      other = n;\n-    } else if (phase->type(n)->is_zero_type()) {\n-      other = InlineTypePtrNode::make_null(*phase, vk);\n-    } else {\n+    Node* n = in(i);\n+    while (n->is_ConstraintCast()) {\n+      casts.push(n);\n+      n = n->in(1);\n+    }\n+    if (phase->type(n)->is_zero_type()) {\n+      n = InlineTypePtrNode::make_null(*phase, vk);\n+    } else if (n->is_Phi()) {\n@@ -1944,1 +1947,9 @@\n-      other = phase->transform(n->as_Phi()->push_inline_types_through(phase, can_reshape, vk, is_init));\n+      n = phase->transform(n->as_Phi()->push_inline_types_through(phase, can_reshape, vk, is_init));\n+    }\n+    while (casts.size() != 0) {\n+      \/\/ Update the cast input and let ConstraintCastNode::Ideal push it through the InlineTypePtrNode\n+      Node* cast = casts.pop();\n+      phase->hash_delete(cast);\n+      cast->set_req(1, n);\n+      n = phase->transform(cast);\n+      assert(n->is_InlineTypePtr(), \"Failed to push cast through InlineTypePtr\");\n@@ -1947,1 +1958,1 @@\n-    vt->merge_with(phase, other->as_InlineTypeBase(), i, transform);\n+    vt->merge_with(phase, n->as_InlineTypeBase(), i, transform);\n@@ -2506,1 +2517,1 @@\n-  if (EnableValhalla && req() > 2 && progress == NULL) {\n+  if (EnableValhalla && (_type->isa_ptr() || _type->isa_inlinetype()) && req() > 2 && progress == NULL) {\n@@ -2523,1 +2534,7 @@\n-        n = n->uncast();\n+        while (n->is_ConstraintCast()) {\n+          if (phase->type(n->in(1))->filter_speculative(n->bottom_type()) == Type::TOP) {\n+            can_optimize = false;\n+            break;\n+          }\n+          n = n->in(1);\n+        }\n@@ -2531,1 +2548,1 @@\n-        } else if (n->is_Phi() && can_reshape) {\n+        } else if (n->is_Phi() && can_reshape && (n->bottom_type()->isa_ptr() || n->bottom_type()->isa_inlinetype())) {\n@@ -2541,0 +2558,1 @@\n+\/\/ TODO 8275400\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1913,0 +1913,2 @@\n+    } else if (n->is_CheckCastPP()) {\n+      wq.push(n->in(1));\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -700,2 +700,2 @@\n-  if (oop->uncast()->isa_InlineTypePtr()) {\n-    InlineTypePtrNode* vtptr = oop->uncast()->as_InlineTypePtr();\n+  if (oop->isa_InlineTypePtr()) {\n+    InlineTypePtrNode* vtptr = oop->as_InlineTypePtr();\n@@ -1109,0 +1109,5 @@\n+  const Type* t = phase->type(get_oop())->filter_speculative(_type);\n+  if (t->singleton()) {\n+    \/\/ Don't replace InlineTypePtr by a constant\n+    t = _type;\n+  }\n@@ -1111,1 +1116,1 @@\n-    return _type->join_speculative(TypePtr::NOTNULL);\n+    t = t->join_speculative(TypePtr::NOTNULL);\n@@ -1113,1 +1118,1 @@\n-  return _type;\n+  return t;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1244,3 +1244,2 @@\n-  InlineTypePtrNode* vt = (base != NULL) ? base->uncast()->isa_InlineTypePtr() : NULL;\n-  if (vt != NULL && offset > oopDesc::klass_offset_in_bytes()) {\n-    Node* value = vt->field_value_by_offset((int)offset, true);\n+  if (base != NULL && base->is_InlineTypePtr() && offset > oopDesc::klass_offset_in_bytes()) {\n+    Node* value = base->as_InlineTypePtr()->field_value_by_offset((int)offset, true);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2356,1 +2356,1 @@\n-        Asserts.assertEquals(test82(), test82Result);\n+        Asserts.assertEquals(test85(), test85Result);\n@@ -2413,1 +2413,1 @@\n-    public void test87_verifier(RunInfo info) {\n+    public void test87_verifier() {\n@@ -2418,0 +2418,54 @@\n+\n+    static primitive class Test88Value {\n+        int x = 0;\n+    }\n+\n+    static class Test88MyClass {\n+        int x = 0;\n+        int y = rI;\n+    }\n+\n+    @ForceInline\n+    Object test88Helper() {\n+        return new Test88Value();\n+    }\n+\n+    \/\/ Test LoadNode::Identity optimization with always failing checkcast\n+    @Test\n+    public int test88() {\n+        Object obj = test88Helper();\n+        return ((Test88MyClass)obj).y;\n+    }\n+\n+    @Run(test = \"test88\")\n+    public void test88_verifier() {\n+        try {\n+            test88();\n+            throw new RuntimeException(\"No ClassCastException thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test88 but with Phi\n+    @Test\n+    public int test89(boolean b) {\n+        Test88MyClass obj = b ? (Test88MyClass)test88Helper() : (Test88MyClass)test88Helper();\n+        return obj.y;\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier() {\n+        try {\n+            test89(false);\n+            throw new RuntimeException(\"No ClassCastException thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test89(true);\n+            throw new RuntimeException(\"No ClassCastException thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"}]}