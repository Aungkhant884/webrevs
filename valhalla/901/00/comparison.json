{"files":[{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @summary Smoke test for parsing of bang types\n- * @compile BangTypeParsingTest.java\n- *\/\n-\n-import java.util.function.*;\n-import java.util.*;\n-\n-class Test {\n-    \/\/ fields\n-    Object? o1;\n-    Object! o2;\n-\n-    \/\/ method parameters\n-    void m1(Object? o) { }\n-    void m2(Object! o) { }\n-\n-    \/\/ method returns\n-    Object? m1() { return null; }\n-    Object! m2() { return null; }\n-\n-    \/\/ locals\n-    void testLocals() {\n-        Object? o1;\n-        Object! o2;\n-    }\n-\n-    \/\/ generics - field\n-    Consumer<Object?> co1;\n-    Consumer<Object!> co2;\n-\n-    \/\/ generics - method param\n-    void m3(Consumer<Object?> co) { }\n-    void m4(Consumer<Object!> co) { }\n-\n-    \/\/ generics - method return\n-    Consumer<Object?> m3() { return null; }\n-    Consumer<Object!> m4() { return null; }\n-\n-    \/\/ generics - local\n-    void testGenericLocals() {\n-        Consumer<Object?> co1;\n-        Consumer<Object!> co2;\n-    }\n-\n-    \/\/ lambdas\n-    void testLambdas() {\n-        Consumer<Object?> co1 = (Object? co) -> {};\n-        Consumer<Object!> co2 = (Object! co) -> {};\n-    }\n-\n-    void testGenericLambdas() {\n-        Consumer<Consumer<Object?>> co1 = (Consumer<Object?> co) -> {};\n-        Consumer<Consumer<Object!>> co2 = (Consumer<Object!> co) -> {};\n-        Consumer<Function<Object?, Object!>> co3 = (Function<Object?, Object!> co) -> {};\n-        Consumer<Function<Object!, Object?>> co4 = (Function<Object!, Object?> co) -> {};\n-        Consumer<Consumer<Consumer<Consumer<Object?>>>> co5 = (Consumer<Consumer<Consumer<Object?>>> co) -> {};\n-        Consumer<Consumer<Consumer<Consumer<Object!>>>> co6 = (Consumer<Consumer<Consumer<Object!>>> co) -> {};\n-    }\n-\n-    \/\/ type test patterns\n-\n-    void testTypeTestPatterns(Object o) {\n-        switch (o) {\n-            case Integer! i -> throw new AssertionError();\n-            case String? s -> throw new AssertionError();\n-                default -> throw new AssertionError();\n-        }\n-    }\n-\n-    sealed interface I<X> {}\n-    final class A implements I<Integer> { }\n-\n-    void genericTypeTestPatterns(A o) {\n-        switch (o) {\n-            case I<Integer!> i -> { }\n-        }\n-        switch (o) {\n-            case I<Integer?> i -> { }\n-        }\n-    }\n-\n-    sealed interface I2<X> {}\n-    final class A2 implements I2<I<Integer>> { }\n-\n-    void genericTypeTestPatterns(A2 o) {\n-        switch (o) {\n-            case I2<I<Integer!>> i -> { }\n-        }\n-        switch (o) {\n-            case I2<I<Integer?>> i -> { }\n-        }\n-    }\n-\n-    sealed interface I3<X> {}\n-    final class A3 implements I3<I2<I<Integer>>> { }\n-\n-    void genericTypeTestPatterns(A3 o) {\n-        switch (o) {\n-            case I3<I2<I<Integer!>>> i -> { }\n-        }\n-        switch (o) {\n-            case I3<I2<I<Integer?>>> i -> { }\n-        }\n-    }\n-\n-    \/\/ record patterns\n-\n-    record R(A a) { }\n-\n-    void genericRecordPatterns(R o) {\n-        switch (o) {\n-            case R?(I<Integer?> i) -> { }\n-        }\n-        switch (o) {\n-            case R!(I<Integer!> i) -> { }\n-        }\n-    }\n-\n-    record R2(A2 a2) { }\n-\n-    void genericRecordPatterns(R2 o) {\n-        switch (o) {\n-            case R2?(I2<I<Integer?>> i) -> { }\n-        }\n-        switch (o) {\n-            case R2!(I2<I<Integer!>> i) -> { }\n-        }\n-    }\n-\n-    record R3(A3 a3) { }\n-\n-    void genericRecordPatterns(R3 o) {\n-        switch (o) {\n-            case R3?(I3<I2<I<Integer?>>> i) -> { }\n-        }\n-        switch (o) {\n-            case R3!(I3<I2<I<Integer!>>> i) -> { }\n-        }\n-    }\n-\n-    \/\/ instanceof\/cast\n-\n-    void testInstanceOf(Object o) {\n-        boolean r1 = o instanceof String?;\n-        boolean r2 = o instanceof String!;\n-    }\n-\n-    void testInstanceRecord(R r) {\n-        boolean r1 = r instanceof R(I<Integer?> i);\n-        boolean r2 = r instanceof R(I<Integer!> i);\n-    }\n-\n-    void testCast(Object o) {\n-        String? s1 = (String?)o;\n-        String! s2 = (String!)o;\n-    }\n-\n-    void testGenericCast(A a) {\n-        I<Integer?> i1 = (I<Integer?>)a;\n-        I<Integer!> i2 = (I<Integer!>)a;\n-    }\n-\n-    void testGenericCast2(A a) {\n-        I?<Integer?> i1 = (I?<Integer?>)a;\n-        I!<Integer!> i2 = (I!<Integer!>)a;\n-    }\n-\n-    \/\/ arrays\n-\n-    Object?[]![]?[]! oarr;\n-    Function?<Object?[]![]?, Function<Object?[]![]?, Object?[]![]?>>[]![]? garr;\n-\n-    \/\/ patterns and for-each\n-\n-    void forEachPatterns(List<R> o) {\n-        for (R?(I<Integer?> i) : o) { }\n-        for (R!(I<Integer!> i) : o) { }\n-    }\n-\n-    void forEachPatterns2(List<R2> o) {\n-        for (R2?(I2<I?<Integer?>> i) : o) { }\n-        for (R2 !(I2<I!<Integer!>> i) : o) { }\n-    }\n-\n-    void forEachPatterns3(List<R3> o) {\n-        for (R3?(I3?<I2?<I<Integer?>>> i) : o) { }\n-        for (R3!(I3!<I2!<I<Integer!>>> i) : o) { }\n-    }\n-\n-    void mBad1(Object o) {\n-        String s1 = o instanceof String ? (String)o : null;\n-        String s2 = o instanceof String? ? (String)o : null;\n-    }\n-\n-    void mBad2(Object o) {\n-        String s1 = o instanceof String ? \"\" : null;\n-        String s2 = o instanceof String? ? \"\" : null;\n-    }\n-\n-    void testPatternRule(Object o) {\n-        switch (o) {\n-            case String? s -> { }\n-                default -> { }\n-        }\n-    }\n-\n-    void testPatternCol(Object o) {\n-        switch (o) {\n-            case String? s: { }\n-            default: { }\n-        }\n-    }\n-\n-    void testInstanceOfAndInfix1(Object a, boolean b) {\n-        boolean x1 = a instanceof String? && b;\n-        boolean x2 = a instanceof String! && b;\n-    }\n-\n-    void testInstanceOfAndInfix2(Object a, boolean b) {\n-        boolean x1 = a instanceof String? s && b;\n-        boolean x2 = a instanceof String! s && b;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/bang\/BangTypeParsingTest.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -25,1 +25,1 @@\n- * BangTypesCompilationTests\n+ * NullabilityCompilationTests\n@@ -36,1 +36,1 @@\n- * @run testng\/othervm BangTypesCompilationTests\n+ * @run testng\/othervm NullabilityCompilationTests\n@@ -49,1 +49,1 @@\n-public class BangTypesCompilationTests extends CompilationTestCase {\n+public class NullabilityCompilationTests extends CompilationTestCase {\n@@ -53,1 +53,1 @@\n-    public BangTypesCompilationTests() {\n+    public NullabilityCompilationTests() {\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityCompilationTests.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/langtools\/tools\/javac\/bang\/BangTypesCompilationTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @summary Smoke test for parsing of bang types\n+ * @compile NullabilityParsingTest.java\n+ *\/\n+\n+import java.util.function.*;\n+import java.util.*;\n+\n+class NullabilityParsingTest {\n+    \/\/ fields\n+    Object! o2;\n+\n+    \/\/ method parameters\n+    void m2(Object! o) { }\n+\n+    \/\/ method returns\n+    Object! m2() { return new Object(); }\n+\n+    \/\/ locals\n+    void testLocals() {\n+        Object! o2;\n+    }\n+\n+    \/\/ generics - field\n+    Consumer<Object!> co2;\n+\n+    \/\/ generics - method param\n+    void m4(Consumer<Object!> co) { }\n+\n+    \/\/ generics - method return\n+    Consumer<Object!> m4() { return null; }\n+\n+    \/\/ generics - local\n+    void testGenericLocals() {\n+        Consumer<Object!> co2;\n+    }\n+\n+    \/\/ lambdas\n+    void testLambdas() {\n+        Consumer<Object!> co2 = (Object! co) -> {};\n+    }\n+\n+    void testGenericLambdas() {\n+        Consumer<Consumer<Object!>> co2 = (Consumer<Object!> co) -> {};\n+        Consumer<Function<Object!, Object!>> co3 = (Function<Object!, Object!> co) -> {};\n+        Consumer<Consumer<Consumer<Consumer<Object!>>>> co6 = (Consumer<Consumer<Consumer<Object!>>> co) -> {};\n+    }\n+\n+    \/\/ type test patterns\n+\n+    void testTypeTestPatterns(Object o) {\n+        switch (o) {\n+            case Integer! i -> throw new AssertionError();\n+            case String! s -> throw new AssertionError();\n+            default -> throw new AssertionError();\n+        }\n+    }\n+\n+    sealed interface I<X> {}\n+    final class A implements I<Integer> { }\n+\n+    void genericTypeTestPatterns(A o) {\n+        switch (o) {\n+            case I<Integer!> i -> { }\n+        }\n+    }\n+\n+    sealed interface I2<X> {}\n+    final class A2 implements I2<I<Integer>> { }\n+\n+    void genericTypeTestPatterns(A2 o) {\n+        switch (o) {\n+            case I2<I<Integer!>> i -> { }\n+        }\n+    }\n+\n+    sealed interface I3<X> {}\n+    final class A3 implements I3<I2<I<Integer>>> { }\n+\n+    void genericTypeTestPatterns(A3 o) {\n+        switch (o) {\n+            case I3<I2<I<Integer!>>> i -> { }\n+        }\n+    }\n+\n+    \/\/ record patterns\n+\n+    record R(A a) { }\n+\n+    void genericRecordPatterns(R o) {\n+        switch (o) {\n+            case R!(I<Integer!> i) -> { }\n+        }\n+    }\n+\n+    record R2(A2 a2) { }\n+\n+    void genericRecordPatterns(R2 o) {\n+        switch (o) {\n+            case R2!(I2<I<Integer!>> i) -> { }\n+        }\n+    }\n+\n+    record R3(A3 a3) { }\n+\n+    void genericRecordPatterns(R3 o) {\n+        switch (o) {\n+            case R3!(I3<I2<I<Integer!>>> i) -> { }\n+        }\n+    }\n+\n+    \/\/ instanceof\/cast\n+\n+    void testInstanceOf(Object o) {\n+        boolean r2 = o instanceof String!;\n+    }\n+\n+    void testInstanceRecord(R r) {\n+        boolean r2 = r instanceof R(I<Integer!> i);\n+    }\n+\n+    void testCast(Object o) {\n+        String! s2 = (String!)o;\n+    }\n+\n+    void testGenericCast(A a) {\n+        I<Integer!> i2 = (I<Integer!>)a;\n+    }\n+\n+    void testGenericCast2(A a) {\n+        I!<Integer!> i2 = (I!<Integer!>)a;\n+    }\n+\n+    \/\/ arrays\n+\n+    Object![]![]![]! oarr;\n+    Function!<Object![]![]!, Function<Object![]![]!, Object![]![]!>>[]![]! garr;\n+\n+    void mBad1(Object o) {\n+        String s1 = o instanceof String ? (String)o : null;\n+        String s2 = o instanceof String! ? (String)o : null;\n+    }\n+\n+    void mBad2(Object o) {\n+        String s1 = o instanceof String ? \"\" : null;\n+        String s2 = o instanceof String! ? \"\" : null;\n+    }\n+\n+    void testPatternRule(Object o) {\n+        switch (o) {\n+            case String! s -> { }\n+                default -> { }\n+        }\n+    }\n+\n+    void testPatternCol(Object o) {\n+        switch (o) {\n+            case String! s: { }\n+            default: { }\n+        }\n+    }\n+\n+    void testInstanceOfAndInfix1(Object a, boolean b) {\n+        boolean x2 = a instanceof String! && b;\n+    }\n+\n+    void testInstanceOfAndInfix2(Object a, boolean b) {\n+        boolean x2 = a instanceof String! s && b;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingTest.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/bang\/RuntimeNullChecks.java","status":"renamed"}]}