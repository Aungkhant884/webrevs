{"files":[{"patch":"@@ -133,1 +133,1 @@\n-  \/\/ Check array klass layout helper for flatten or null-free arrays...\n+  \/\/ Check array klass layout helper for flat or null-free arrays...\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-        if (element_klass->can_be_inline_klass() && (!element_klass->is_inlinetype() || element_klass->as_inline_klass()->flatten_array())) {\n+        if (element_klass->can_be_inline_klass() && (!element_klass->is_inlinetype() || element_klass->as_inline_klass()->flat_array())) {\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1870,1 +1870,1 @@\n-      if (!klass->can_be_inline_klass() || (klass->is_inlinetype() && !klass->as_inline_klass()->flatten_array())) {\n+      if (!klass->can_be_inline_klass() || (klass->is_inlinetype() && !klass->as_inline_klass()->flat_array())) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1682,2 +1682,2 @@\n-  tty->print_cr(\" _load_flattened_array_slowcase_cnt:   %u\", _load_flat_array_slowcase_cnt);\n-  tty->print_cr(\" _store_flattened_array_slowcase_cnt:  %u\", _store_flat_array_slowcase_cnt);\n+  tty->print_cr(\" _load_flat_array_slowcase_cnt:   %u\", _load_flat_array_slowcase_cnt);\n+  tty->print_cr(\" _store_flat_array_slowcase_cnt:  %u\", _store_flat_array_slowcase_cnt);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-bool ciInlineKlass::flatten_array() const {\n-  GUARDED_VM_ENTRY(return to_InlineKlass()->flatten_array();)\n+bool ciInlineKlass::flat_array() const {\n+  GUARDED_VM_ENTRY(return to_InlineKlass()->flat_array();)\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  bool flatten_array() const;\n+  bool flat_array() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  virtual bool flatten_array() const        { return false; }\n+  virtual bool flat_array() const           { return false; }\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -641,1 +641,1 @@\n-          \/\/ static fields are never flatten\n+          \/\/ static fields are never flat\n@@ -659,1 +659,1 @@\n-            \/\/ volatile fields are currently never flatten, this could change in the future\n+            \/\/ Currently, volatile fields are never flat, this could change in the future\n@@ -742,1 +742,1 @@\n-          \/\/ static fields are never flatten\n+          \/\/ static fields are never flat\n@@ -759,1 +759,1 @@\n-            \/\/ volatile fields are currently never flatten, this could change in the future\n+            \/\/ Currently, volatile fields are never flat, this could change in the future\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-\/\/ A flatArrayOop is an array containing inline types (may include flatten embedded oop elements).\n+\/\/ A flatArrayOop is an array containing flattened inline types (no indirection).\n+\/\/ It may include embedded oops in its elements.\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-bool InlineKlass::flatten_array() {\n+bool InlineKlass::flat_array() {\n@@ -186,1 +186,1 @@\n-        if (flatten_array()) {\n+        if (flat_array()) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  bool flatten_array();\n+  bool flat_array();\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-    assert(!InlineKlass::cast(element_klass())->flatten_array(), \"Expected flatArrayOop allocation\");\n+    assert(!InlineKlass::cast(element_klass())->flat_array(), \"Expected flatArrayOop allocation\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-    \/\/ In the case of a flattened inline type array, each field has its\n+    \/\/ In the case of a flat inline type array, each field has its\n@@ -671,1 +671,1 @@\n-    \/\/ In the case of a flattened inline type array, each field has its\n+    \/\/ In the case of a flat inline type array, each field has its\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -428,1 +428,1 @@\n-      assert(!field->is_flat(), \"flattened field encountered\");\n+      assert(!field->is_flat(), \"flat field encountered\");\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -801,1 +801,1 @@\n-        \/\/ Result might still be allocated (for example, if it has been stored to a non-flattened field)\n+        \/\/ Result might still be allocated (for example, if it has been stored to a non-flat field)\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1190,1 +1190,1 @@\n-  \/\/ Split if can cause the flattened array branch of an array load to\n+  \/\/ Split if can cause the flat array branch of an array load to\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -997,1 +997,1 @@\n-    DefaultValue,                     \/\/ default value in case of non-flattened inline type array\n+    DefaultValue,                     \/\/ default value in case of non-flat inline type array\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1028,1 +1028,1 @@\n-\/\/ note that these functions assume that the _adr_type field is flattened\n+\/\/ note that these functions assume that the _adr_type field is flat\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1390,1 +1390,1 @@\n-    \/\/ For flattened inline type array, each field has its own slice so\n+    \/\/ For flat inline type array, each field has its own slice so\n@@ -2064,1 +2064,1 @@\n-  \/\/ Initially, all flattened array accesses share the same slice to\n+  \/\/ Initially, all flat array accesses share the same slice to\n@@ -2066,3 +2066,3 @@\n-  \/\/ to a flattened array) correct. We're done with parsing so we\n-  \/\/ now know all flattened array accesses in this compile\n-  \/\/ unit. Let's move flattened array accesses to their own slice,\n+  \/\/ to a flat array) correct. We're done with parsing so we\n+  \/\/ now know all flat array accesses in this compile\n+  \/\/ unit. Let's move flat array accesses to their own slice,\n@@ -2078,1 +2078,1 @@\n-  \/\/ Alias index currently shared by all flattened memory accesses\n+  \/\/ Alias index currently shared by all flat memory accesses\n@@ -2081,1 +2081,1 @@\n-  \/\/ Find MergeMem nodes and flattened array accesses\n+  \/\/ Find MergeMem nodes and flat array accesses\n@@ -2111,1 +2111,1 @@\n-    \/\/ We are going to change the slice for the flattened array\n+    \/\/ We are going to change the slice for the flat array\n@@ -2157,1 +2157,1 @@\n-    \/\/ Now let's fix the memory graph so each flattened array access\n+    \/\/ Now let's fix the memory graph so each flat array access\n@@ -2263,1 +2263,1 @@\n-              \/\/ branch that handles flattened arrays hidden under\n+              \/\/ branch that handles flat arrays hidden under\n@@ -2267,1 +2267,1 @@\n-              \/\/ known flattened array.\n+              \/\/ known flat array.\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2129,1 +2129,1 @@\n-      \/\/ Non-flattened inline type arrays are initialized with\n+      \/\/ Non-flat inline type arrays are initialized with\n@@ -2984,1 +2984,1 @@\n-  return adr_type->is_ptr()->flattened_offset();\n+  return adr_type->is_ptr()->flat_offset();\n@@ -3139,1 +3139,1 @@\n-      \/\/ In the case of a flattened inline type array, each field has its\n+      \/\/ In the case of a flat inline type array, each field has its\n@@ -3173,1 +3173,1 @@\n-    \/\/ In the case of a flattened inline type array, each field has its\n+    \/\/ In the case of a flat inline type array, each field has its\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1678,1 +1678,1 @@\n-    \/\/ Store to non-flattened field. Buffer the inline type and make sure\n+    \/\/ Store to non-flat field. Buffer the inline type and make sure\n@@ -3571,2 +3571,2 @@\n-  bool not_flattened = !UseFlatArray || not_inline || (toop->is_inlinetypeptr() && !toop->inline_klass()->flatten_array());\n-  if (EnableValhalla && not_flattened) {\n+  bool not_flat = !UseFlatArray || not_inline || (toop->is_inlinetypeptr() && !toop->inline_klass()->flat_array());\n+  if (EnableValhalla && not_flat) {\n@@ -3599,1 +3599,1 @@\n-          \/\/ Casting array element to a non-flattened type, mark array as not flat.\n+          \/\/ Casting array element to a non-flat type, mark array as not flat.\n@@ -3869,1 +3869,1 @@\n-    bool can_be_flattened = false;\n+    bool can_be_flat = false;\n@@ -3874,1 +3874,1 @@\n-      can_be_flattened = ary_type->can_be_inline_array() && (!elem->is_inlinetypeptr() || elem->inline_klass()->flatten_array());\n+      can_be_flat = ary_type->can_be_inline_array() && (!elem->is_inlinetypeptr() || elem->inline_klass()->flat_array());\n@@ -3876,1 +3876,1 @@\n-    if (!can_be_flattened && (xklass || (klass_t->isa_aryklassptr() && klass_t->is_aryklassptr()->elem() != Type::BOTTOM))) {\n+    if (!can_be_flat && (xklass || (klass_t->isa_aryklassptr() && klass_t->is_aryklassptr()->elem() != Type::BOTTOM))) {\n@@ -3961,1 +3961,1 @@\n-        \/\/ Initially all flattened array accesses share a single slice\n+        \/\/ Initially all flat array accesses share a single slice\n@@ -3963,1 +3963,1 @@\n-        \/\/ it can optimize flattened array accesses properly once they\n+        \/\/ it can optimize flat array accesses properly once they\n@@ -4272,2 +4272,2 @@\n-  \/\/ - null-free, flattened: MyValue.val[] (ciFlatArrayKlass \"[QMyValue\")\n-  \/\/ Check if array is a null-free, non-flattened inline type array\n+  \/\/ - null-free, flat     : MyValue.val[] (ciFlatArrayKlass \"[QMyValue\")\n+  \/\/ Check if array is a null-free, non-flat inline type array\n@@ -4292,1 +4292,1 @@\n-    \/\/ Null-free, non-flattened inline type array, initialize with the default value\n+    \/\/ Null-free, non-flat inline type array, initialize with the default value\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    bool no_circularity = !gvn->C->has_circular_inline_type() || !gvn->is_IterGVN() || field_is_flattened(i);\n+    bool no_circularity = !gvn->C->has_circular_inline_type() || !gvn->is_IterGVN() || field_is_flat(i);\n@@ -194,1 +194,1 @@\n-\/\/ If 'recursive' is true, flattened inline type fields will be resolved recursively.\n+\/\/ If 'recursive' is true, flat inline type fields will be resolved recursively.\n@@ -196,1 +196,1 @@\n-  \/\/ If the field at 'offset' belongs to a flattened inline type field, 'index' refers to the\n+  \/\/ If the field at 'offset' belongs to a flat inline type field, 'index' refers to the\n@@ -203,2 +203,2 @@\n-    if (field_is_flattened(index)) {\n-      \/\/ Flattened inline type field\n+    if (field_is_flat(index)) {\n+      \/\/ Flat inline type field\n@@ -244,1 +244,1 @@\n-bool InlineTypeNode::field_is_flattened(uint index) const {\n+bool InlineTypeNode::field_is_flat(uint index) const {\n@@ -280,1 +280,1 @@\n-    Node* value = field_value_by_offset(offset, true \/* include flattened inline type fields *\/);\n+    Node* value = field_value_by_offset(offset, true \/* include flat inline type fields *\/);\n@@ -337,1 +337,1 @@\n-  \/\/ Now scalarize non-flattened fields\n+  \/\/ Now scalarize non-flat fields\n@@ -354,1 +354,1 @@\n-    \/\/ In the case of a flattened inline type array, each field has its own slice\n+    \/\/ In the case of a flat inline type array, each field has its own slice\n@@ -383,1 +383,1 @@\n-      if (!field_is_flattened(i) && visited.contains(ft)) {\n+      if (!field_is_flat(i) && visited.contains(ft)) {\n@@ -418,3 +418,3 @@\n-    } else if (field_is_flattened(i)) {\n-      \/\/ Recursively load the flattened inline type field\n-      value = make_from_flattened_impl(kit, ft->as_inline_klass(), base, ptr, holder, offset, decorators, visited);\n+    } else if (field_is_flat(i)) {\n+      \/\/ Recursively load the flat inline type field\n+      value = make_from_flat_impl(kit, ft->as_inline_klass(), base, ptr, holder, offset, decorators, visited);\n@@ -463,1 +463,1 @@\n-void InlineTypeNode::store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n+void InlineTypeNode::store_flat(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {\n@@ -482,3 +482,3 @@\n-    if (field_is_flattened(i)) {\n-      \/\/ Recursively store the flattened inline type field\n-      value->as_InlineType()->store_flattened(kit, base, ptr, holder, offset, decorators);\n+    if (field_is_flat(i)) {\n+      \/\/ Recursively store the flat inline type field\n+      value->as_InlineType()->store_flat(kit, base, ptr, holder, offset, decorators);\n@@ -642,2 +642,2 @@\n-     if (field_is_flattened(i)) {\n-       \/\/ Flattened inline type field\n+     if (field_is_flat(i)) {\n+       \/\/ Flat inline type field\n@@ -646,1 +646,1 @@\n-       \/\/ Non-flattened inline type field\n+       \/\/ Non-flat inline type field\n@@ -770,1 +770,1 @@\n-    if (!vt->field_is_flattened(i) && visited.contains(ft)) {\n+    if (!vt->field_is_flat(i) && visited.contains(ft)) {\n@@ -887,1 +887,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {\n+InlineTypeNode* InlineTypeNode::make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {\n@@ -890,1 +890,1 @@\n-  return make_from_flattened_impl(kit, vk, obj, ptr, holder, holder_offset, decorators, visited);\n+  return make_from_flat_impl(kit, vk, obj, ptr, holder, holder_offset, decorators, visited);\n@@ -893,2 +893,2 @@\n-\/\/ GraphKit wrapper for the 'make_from_flattened' method\n-InlineTypeNode* InlineTypeNode::make_from_flattened_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited) {\n+\/\/ GraphKit wrapper for the 'make_from_flat' method\n+InlineTypeNode* InlineTypeNode::make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited) {\n@@ -899,1 +899,1 @@\n-  \/\/ a flattened inline type field at 'holder_offset' or from an inline type array.\n+  \/\/ a flat inline type field at 'holder_offset' or from an inline type array.\n@@ -1003,1 +1003,1 @@\n-      } else if (field_is_flattened(i) && vt->is_InlineType()) {\n+      } else if (field_is_flat(i) && vt->is_InlineType()) {\n@@ -1056,2 +1056,2 @@\n-    if (field_is_flattened(i)) {\n-      \/\/ Flattened inline type field\n+    if (field_is_flat(i)) {\n+      \/\/ Flat inline type field\n@@ -1061,1 +1061,1 @@\n-        \/\/ Non-flattened inline type field\n+        \/\/ Non-flat inline type field\n@@ -1114,2 +1114,2 @@\n-    if (field_is_flattened(i)) {\n-      \/\/ Flattened inline type field\n+    if (field_is_flat(i)) {\n+      \/\/ Flat inline type field\n@@ -1128,1 +1128,1 @@\n-      \/\/ Non-flattened inline type field\n+      \/\/ Non-flat inline type field\n@@ -1217,1 +1217,1 @@\n-    if (!vt->field_is_flattened(i) && visited.contains(ft)) {\n+    if (!vt->field_is_flat(i) && visited.contains(ft)) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  static InlineTypeNode* make_from_flattened_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n@@ -86,2 +86,2 @@\n-  \/\/ Create and initialize by loading the field values from a flattened field or array\n-  static InlineTypeNode* make_from_flattened(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n+  \/\/ Create and initialize by loading the field values from a flat field or array\n+  static InlineTypeNode* make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n@@ -119,1 +119,1 @@\n-  bool          field_is_flattened(uint index) const;\n+  bool          field_is_flat(uint index) const;\n@@ -125,2 +125,2 @@\n-  \/\/ Store the inline type as a flattened (headerless) representation\n-  void store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n+  \/\/ Store the inline type as a flat (headerless) representation\n+  void store_flat(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0, DecoratorSet decorators = IN_HEAP | MO_UNORDERED) const;\n@@ -140,1 +140,1 @@\n-  \/\/ Allocate all non-flattened inline type fields\n+  \/\/ Allocate all non-flat inline type fields\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2555,1 +2555,1 @@\n-          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, base, holder, offset, decorators);\n+          p = InlineTypeNode::make_from_flat(this, inline_klass, base, base, holder, offset, decorators);\n@@ -2557,1 +2557,1 @@\n-          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, adr, nullptr, 0, decorators);\n+          p = InlineTypeNode::make_from_flat(this, inline_klass, base, adr, nullptr, 0, decorators);\n@@ -2608,1 +2608,1 @@\n-        val->as_InlineType()->store_flattened(this, base, base, holder, offset, decorators);\n+        val->as_InlineType()->store_flat(this, base, base, holder, offset, decorators);\n@@ -2610,1 +2610,1 @@\n-        val->as_InlineType()->store_flattened(this, base, adr, nullptr, 0, decorators);\n+        val->as_InlineType()->store_flat(this, base, adr, nullptr, 0, decorators);\n@@ -5359,1 +5359,1 @@\n-        \/\/ Flattened inline type array may have object field that would require a\n+        \/\/ Flat inline type array may have object field that would require a\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  if (head->is_flattened_arrays()) {\n+  if (head->is_flat_arrays()) {\n@@ -125,2 +125,2 @@\n-  \/\/ Collect all non-flattened array checks for unswitching to create a fast loop\n-  \/\/ without checks (only non-flattened array accesses) and a slow loop with checks.\n+  \/\/ Collect all non-flat array checks for unswitching to create a fast loop\n+  \/\/ without checks (only non-flat array accesses) and a slow loop with checks.\n@@ -247,1 +247,1 @@\n-    \/\/ Leave the flattened array checks in the slow loop and\n+    \/\/ Leave the flat array checks in the slow loop and\n@@ -249,1 +249,1 @@\n-    head_clone->mark_flattened_arrays();\n+    head_clone->mark_flat_arrays();\n@@ -293,2 +293,2 @@\n-    \/\/ Flattened array checks are used on array access to switch between\n-    \/\/ a legacy object array access and a flattened inline type array\n+    \/\/ Flat array checks are used on array access to switch between\n+    \/\/ a legacy object array access and a flat inline type array\n@@ -298,1 +298,1 @@\n-    \/\/ some accesses are to flattened arrays. Flattened array checks\n+    \/\/ some accesses are to flat arrays. Flat array checks\n@@ -300,1 +300,1 @@\n-    \/\/ slow loop (false proj) as it can have a mix of flattened\/legacy accesses.\n+    \/\/ slow loop (false proj) as it can have a mix of flat\/legacy accesses.\n@@ -307,1 +307,1 @@\n-    \/\/ Combine all checks into a single one that fails if one array is flattened\n+    \/\/ Combine all checks into a single one that fails if one array is a flat array\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  bool is_flattened_arrays() const { return _loop_flags & FlattenedArrays; }\n+  bool is_flat_arrays() const { return _loop_flags & FlattenedArrays; }\n@@ -117,1 +117,1 @@\n-  void mark_flattened_arrays() { _loop_flags |= FlattenedArrays; }\n+  void mark_flat_arrays() { _loop_flags |= FlattenedArrays; }\n@@ -1541,1 +1541,1 @@\n-  bool flatten_array_element_type_check(Node *n);\n+  bool flat_array_element_type_check(Node *n);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1381,1 +1381,1 @@\n-bool PhaseIdealLoop::flatten_array_element_type_check(Node *n) {\n+bool PhaseIdealLoop::flat_array_element_type_check(Node *n) {\n@@ -1384,3 +1384,3 @@\n-  \/\/ can't be stored in a flattened array and the load of the value\n-  \/\/ happens with a flattened array check then: push the type check\n-  \/\/ through the phi of the flattened array check. This needs special\n+  \/\/ can't be stored in a flat array and the load of the value\n+  \/\/ happens with a flat array check then: push the type check\n+  \/\/ through the phi of the flat array check. This needs special\n@@ -1485,1 +1485,1 @@\n-  if (flatten_array_element_type_check(n)) {\n+  if (flat_array_element_type_check(n)) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-    \/\/ In the case of a flattened inline type array, each field has its\n+    \/\/ In the case of a flat inline type array, each field has its\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-        int adr_offset = atype->flattened_offset();\n+        int adr_offset = atype->flat_offset();\n@@ -322,1 +322,1 @@\n-        \/\/ In the case of a flattened inline type array, each field has its\n+        \/\/ In the case of a flat inline type array, each field has its\n@@ -352,1 +352,1 @@\n-  int offset = adr_t->flattened_offset();\n+  int offset = adr_t->flat_offset();\n@@ -467,1 +467,1 @@\n-  int offset = adr_t->flattened_offset();\n+  int offset = adr_t->flat_offset();\n@@ -494,1 +494,1 @@\n-             atype->is_known_instance_field() && atype->flattened_offset() == offset &&\n+             atype->is_known_instance_field() && atype->flat_offset() == offset &&\n@@ -578,1 +578,1 @@\n-    if (vt->field_is_flattened(i)) {\n+    if (vt->field_is_flat(i)) {\n@@ -700,2 +700,2 @@\n-              if (vt->field_value(i) == use && !vt->field_is_flattened(i)) {\n-                can_eliminate = false; \/\/ Use in non-flattened field\n+              if (vt->field_value(i) == use && !vt->field_is_flat(i)) {\n+                can_eliminate = false; \/\/ Use in non-flat field\n@@ -846,1 +846,1 @@\n-        \/\/ Flattened inline type array\n+        \/\/ Flat inline type array\n@@ -895,1 +895,1 @@\n-      assert(vk->flatten_array(), \"must be flattened\");\n+      assert(vk->flat_array(), \"must be flat\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-  assert(UseFlatArray, \"can never be flattened\");\n+  assert(UseFlatArray, \"can never be flat\");\n@@ -1447,1 +1447,1 @@\n-  \/\/ We have no stub to copy flattened inline type arrays with oop\n+  \/\/ We have no stub to copy flat inline type arrays with oop\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -619,1 +619,1 @@\n-      \/\/ Speculate on varargs Object array being not null-free (and therefore also not flattened)\n+      \/\/ Speculate on varargs Object array being not null-free (and therefore also not flat)\n@@ -2377,1 +2377,1 @@\n-        \/\/ Returning from root or an incrementally inlined method. Make sure all non-flattened\n+        \/\/ Returning from root or an incrementally inlined method. Make sure all non-flat\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-    \/\/ Load from flattened inline type array\n-    Node* vt = InlineTypeNode::make_from_flattened(this, elemtype->inline_klass(), ary, adr);\n+    \/\/ Load from flat inline type array\n+    Node* vt = InlineTypeNode::make_from_flat(this, elemtype->inline_klass(), ary, adr);\n@@ -91,1 +91,1 @@\n-    \/\/ Load from non-flattened inline type array (elements can never be null)\n+    \/\/ Load from non-flat inline type array (elements can never be null)\n@@ -94,1 +94,1 @@\n-    \/\/ Cannot statically determine if array is flattened, emit runtime check\n+    \/\/ Cannot statically determine if array is a flat array, emit runtime check\n@@ -96,1 +96,1 @@\n-           (!elemptr->is_inlinetypeptr() || elemptr->inline_klass()->flatten_array()), \"array can't be flattened\");\n+           (!elemptr->is_inlinetypeptr() || elemptr->inline_klass()->flat_array()), \"array can't be flat\");\n@@ -101,1 +101,1 @@\n-      \/\/ non-flattened\n+      \/\/ non-flat array\n@@ -114,1 +114,1 @@\n-      \/\/ flattened\n+      \/\/ flat array\n@@ -117,1 +117,1 @@\n-        \/\/ Element type is known, cast and load from flattened representation\n+        \/\/ Element type is known, cast and load from flat representation\n@@ -119,1 +119,1 @@\n-        assert(vk->flatten_array() && elemptr->maybe_null(), \"never\/always flat - should be optimized\");\n+        assert(vk->flat_array() && elemptr->maybe_null(), \"never\/always flat - should be optimized\");\n@@ -124,1 +124,1 @@\n-        \/\/ Re-execute flattened array load if buffering triggers deoptimization\n+        \/\/ Re-execute flat array load if buffering triggers deoptimization\n@@ -128,1 +128,1 @@\n-        Node* vt = InlineTypeNode::make_from_flattened(this, vk, cast, casted_adr)->buffer(this, false);\n+        Node* vt = InlineTypeNode::make_from_flat(this, vk, cast, casted_adr)->buffer(this, false);\n@@ -134,2 +134,2 @@\n-        \/\/ Below membars keep this access to an unknown flattened array correctly\n-        \/\/ ordered with other unknown and known flattened array accesses.\n+        \/\/ Below membars keep this access to an unknown flat array correctly\n+        \/\/ ordered with other unknown and known flat array accesses.\n@@ -140,1 +140,1 @@\n-          \/\/ Re-execute flattened array load if runtime call triggers deoptimization\n+          \/\/ Re-execute flat array load if runtime call triggers deoptimization\n@@ -157,2 +157,2 @@\n-        \/\/ Keep track of the information that the inline type is flattened in arrays\n-        const Type* unknown_value = elemptr->is_instptr()->cast_to_flatten_array();\n+        \/\/ Keep track of the information that the inline type is in flat arrays\n+        const Type* unknown_value = elemptr->is_instptr()->cast_to_flat_array();\n@@ -179,1 +179,1 @@\n-  \/\/ Loading a non-flattened inline type\n+  \/\/ Loading an inline type from a non-flat array\n@@ -214,1 +214,1 @@\n-    bool not_flattened = not_null_free || (tval->is_inlinetypeptr() && !tval->inline_klass()->flatten_array());\n+    bool not_flat = not_null_free || (tval->is_inlinetypeptr() && !tval->inline_klass()->flat_array());\n@@ -221,2 +221,2 @@\n-    } else if (!ary_t->is_not_flat() && not_flattened) {\n-      \/\/ Storing a non-flattened value, mark array as not flat.\n+    } else if (!ary_t->is_not_flat() && not_flat) {\n+      \/\/ Storing to a non-flat array, mark array as not flat.\n@@ -230,1 +230,1 @@\n-      \/\/ Store to flattened inline type array\n+      \/\/ Store to flat inline type array\n@@ -232,1 +232,1 @@\n-      \/\/ Re-execute flattened array store if buffering triggers deoptimization\n+      \/\/ Re-execute flat array store if buffering triggers deoptimization\n@@ -236,1 +236,1 @@\n-      cast_val->as_InlineType()->store_flattened(this, ary, adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+      cast_val->as_InlineType()->store_flat(this, ary, adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -239,1 +239,1 @@\n-      \/\/ Store to non-flattened inline type array (elements can never be null)\n+      \/\/ Store to non-flat inline type array (elements can never be null)\n@@ -246,3 +246,3 @@\n-      \/\/ Array might be flattened, emit runtime checks (for nullptr, a simple inline_array_null_guard is sufficient).\n-      assert(UseFlatArray && !not_flattened && elemtype->is_oopptr()->can_be_inline_type() &&\n-             !ary_t->klass_is_exact() && !ary_t->is_not_null_free(), \"array can't be flattened\");\n+      \/\/ Array might be a flat array, emit runtime checks (for nullptr, a simple inline_array_null_guard is sufficient).\n+      assert(UseFlatArray && !not_flat && elemtype->is_oopptr()->can_be_inline_type() &&\n+             !ary_t->klass_is_exact() && !ary_t->is_not_null_free(), \"array can't be a flat array\");\n@@ -251,1 +251,1 @@\n-        \/\/ non-flattened\n+        \/\/ non-flat array\n@@ -261,1 +261,1 @@\n-        \/\/ flattened\n+        \/\/ flat array\n@@ -281,1 +281,1 @@\n-          assert(vk->flatten_array() && elemtype->maybe_null(), \"never\/always flat - should be optimized\");\n+          assert(vk->flat_array() && elemtype->maybe_null(), \"never\/always flat - should be optimized\");\n@@ -290,1 +290,1 @@\n-          \/\/ Re-execute flattened array store if buffering triggers deoptimization\n+          \/\/ Re-execute flat array store if buffering triggers deoptimization\n@@ -294,1 +294,1 @@\n-          val->as_InlineType()->store_flattened(this, casted_ary, casted_adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+          val->as_InlineType()->store_flat(this, casted_ary, casted_adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -298,2 +298,2 @@\n-          \/\/ Below membars keep this access to an unknown flattened array correctly\n-          \/\/ ordered with other unknown and known flattened array accesses.\n+          \/\/ Below membars keep this access to an unknown flat array correctly\n+          \/\/ ordered with other unknown and known flat array accesses.\n@@ -316,1 +316,1 @@\n-      \/\/ Array is not flattened but may be null free\n+      \/\/ Array is not flat but may be null free\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-    \/\/ Loading from a flattened inline type field.\n-    ld = InlineTypeNode::make_from_flattened(this, field_klass->as_inline_klass(), obj, obj, field->holder(), offset);\n+    \/\/ Loading from a flat inline type field.\n+    ld = InlineTypeNode::make_from_flat(this, field_klass->as_inline_klass(), obj, obj, field->holder(), offset);\n@@ -239,1 +239,1 @@\n-    \/\/ Storing to a flattened inline type field.\n+    \/\/ Storing to a flat inline type field.\n@@ -244,1 +244,1 @@\n-    val->as_InlineType()->store_flattened(this, obj, obj, field->holder(), offset);\n+    val->as_InlineType()->store_flat(this, obj, obj, field->holder(), offset);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1048,2 +1048,2 @@\n-      if ((r0->flatten_array() && r1->not_flatten_array()) ||\n-          (r1->flatten_array() && r0->not_flatten_array())) {\n+      if ((r0->flat_array() && r1->not_flat_array()) ||\n+          (r1->flat_array() && r0->not_flat_array())) {\n@@ -1054,1 +1054,1 @@\n-        \/\/ One type is a non-flattened array and the other type is a flattened array. Must be unrelated.\n+        \/\/ One type is a non-flat array and the other type is a flat array. Must be unrelated.\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  if (subk->flatten_array() && superk->not_flatten_array()) {\n+  if (subk->flat_array() && superk->not_flat_array()) {\n@@ -58,1 +58,1 @@\n-    \/\/ The subtype is a non-flattened array and the supertype is a flattened array. Must be unrelated.\n+    \/\/ The subtype is a non-flat array and the supertype is a flat array. Must be unrelated.\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3862,1 +3862,1 @@\n-    \/\/ Determine null-free\/flattened properties\n+    \/\/ Determine null-free\/flat properties\n@@ -3869,1 +3869,1 @@\n-    bool not_flat = !UseFlatArray || not_null_free || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->flatten_array());\n+    bool not_flat = !UseFlatArray || not_null_free || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->flat_array());\n@@ -4169,1 +4169,1 @@\n-                         bool flatten_array, int instance_id, const TypePtr* speculative, int inline_depth)\n+                         bool flat_array, int instance_id, const TypePtr* speculative, int inline_depth)\n@@ -4171,1 +4171,1 @@\n-    _flatten_array(flatten_array) {\n+    _flat_array(flat_array) {\n@@ -4176,2 +4176,2 @@\n-  assert(!klass()->flatten_array() || flatten_array, \"Should be flat in array\");\n-  assert(!flatten_array || can_be_inline_type(), \"Only inline types can be flat in array\");\n+  assert(!klass()->flat_array() || flat_array, \"Should be flat in array\");\n+  assert(!flat_array || can_be_inline_type(), \"Only inline types can be flat in array\");\n@@ -4187,1 +4187,1 @@\n-                                     bool flatten_array,\n+                                     bool flat_array,\n@@ -4210,1 +4210,1 @@\n-  flatten_array = flatten_array || k->flatten_array();\n+  flat_array = flat_array || k->flat_array();\n@@ -4214,1 +4214,1 @@\n-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, interfaces, xk, o, offset, flatten_array, instance_id, speculative, inline_depth))->hashcons();\n+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, interfaces, xk, o, offset, flat_array, instance_id, speculative, inline_depth))->hashcons();\n@@ -4280,1 +4280,1 @@\n-  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : nullptr, _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : nullptr, _offset, _flat_array, _instance_id, _speculative, _inline_depth);\n@@ -4291,1 +4291,1 @@\n-  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n+  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);\n@@ -4297,1 +4297,1 @@\n-  return make(_ptr, klass(), _interfaces, _klass_is_exact, const_oop(), _offset, _flatten_array, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);\n@@ -4399,1 +4399,1 @@\n-                  (ptr == Constant ? const_oop() : nullptr), offset, flatten_array(), instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : nullptr), offset, flat_array(), instance_id, speculative, depth);\n@@ -4427,1 +4427,1 @@\n-                  (ptr == Constant ? const_oop() : nullptr), offset, flatten_array(), instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : nullptr), offset, flat_array(), instance_id, speculative, depth);\n@@ -4467,1 +4467,1 @@\n-    bool res_flatten_array = false;\n+    bool res_flat_array = false;\n@@ -4469,1 +4469,1 @@\n-    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk, res_flatten_array);\n+    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk, res_flat_array);\n@@ -4510,1 +4510,1 @@\n-      res = make(ptr, res_klass, interfaces, res_xk, o, off, res_flatten_array, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, interfaces, res_xk, o, off, res_flat_array, instance_id, speculative, depth);\n@@ -4522,1 +4522,1 @@\n-                                                            ciKlass*& res_klass, bool& res_xk, bool& res_flatten_array) {\n+                                                            ciKlass*& res_klass, bool& res_xk, bool& res_flat_array) {\n@@ -4525,4 +4525,4 @@\n-  bool this_flatten_array = this_type->flatten_array();\n-  bool other_flatten_array = other_type->flatten_array();\n-  bool this_flatten_array_orig = this_flatten_array;\n-  bool other_flatten_array_orig = other_flatten_array;\n+  bool this_flat_array = this_type->flat_array();\n+  bool other_flat_array = other_type->flat_array();\n+  bool this_flat_array_orig = this_flat_array;\n+  bool other_flat_array_orig = other_flat_array;\n@@ -4539,1 +4539,1 @@\n-  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk && this_flatten_array == other_flatten_array) {\n+  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk && this_flat_array == other_flat_array) {\n@@ -4542,1 +4542,1 @@\n-    res_flatten_array = this_flatten_array;\n+    res_flat_array = this_flat_array;\n@@ -4582,2 +4582,2 @@\n-    flat_array = below_centerline(ptr) ? (this_flatten_array && other_flatten_array) : (this_flatten_array || other_flatten_array);\n-  } else if (!other_xk && this_type->is_meet_subtype_of(other_type) && (!other_flatten_array || this_flatten_array)) {\n+    flat_array = below_centerline(ptr) ? (this_flat_array && other_flat_array) : (this_flat_array || other_flat_array);\n+  } else if (!other_xk && this_type->is_meet_subtype_of(other_type) && (!other_flat_array || this_flat_array)) {\n@@ -4586,2 +4586,2 @@\n-    flat_array = this_flatten_array;\n-  } else if (!this_xk && other_type->is_meet_subtype_of(this_type) && (!this_flatten_array || other_flatten_array)) {\n+    flat_array = this_flat_array;\n+  } else if (!this_xk && other_type->is_meet_subtype_of(this_type) && (!this_flat_array || other_flat_array)) {\n@@ -4590,1 +4590,1 @@\n-    flat_array = other_flatten_array;\n+    flat_array = other_flat_array;\n@@ -4597,1 +4597,1 @@\n-      this_flatten_array = other_flatten_array = flat_array;\n+      this_flat_array = other_flat_array = flat_array;\n@@ -4601,1 +4601,1 @@\n-      this_flatten_array = other_flatten_array;\n+      this_flat_array = other_flat_array;\n@@ -4605,1 +4605,1 @@\n-      other_flatten_array = this_flatten_array;\n+      other_flat_array = this_flat_array;\n@@ -4608,1 +4608,1 @@\n-      this_flatten_array = flat_array;\n+      this_flat_array = flat_array;\n@@ -4619,1 +4619,1 @@\n-    res_flatten_array = this_flatten_array;\n+    res_flat_array = this_flat_array;\n@@ -4636,1 +4636,1 @@\n-  res_flatten_array = this_flatten_array_orig && other_flatten_array_orig;\n+  res_flat_array = this_flat_array_orig && other_flat_array_orig;\n@@ -4656,1 +4656,1 @@\n-  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), flatten_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4665,1 +4665,1 @@\n-    flatten_array() == p->flatten_array() &&\n+    flat_array() == p->flat_array() &&\n@@ -4673,1 +4673,1 @@\n-  return klass()->hash() + TypeOopPtr::hash() + _interfaces.hash() + (uint)flatten_array();\n+  return klass()->hash() + TypeOopPtr::hash() + _interfaces.hash() + (uint)flat_array();\n@@ -4731,2 +4731,2 @@\n-  if (flatten_array() && !klass()->is_inlinetype()) {\n-    st->print(\" (flatten array)\");\n+  if (flat_array() && !klass()->is_inlinetype()) {\n+    st->print(\" (flat array)\");\n@@ -4747,1 +4747,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset), flatten_array(),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),\n@@ -4752,1 +4752,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), Offset(offset), flatten_array(),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), Offset(offset), flat_array(),\n@@ -4761,1 +4761,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flatten_array(),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flat_array(),\n@@ -4769,1 +4769,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flatten_array(), _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);\n@@ -4774,1 +4774,1 @@\n-  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flatten_array(), instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);\n@@ -4777,1 +4777,1 @@\n-const TypeInstPtr *TypeInstPtr::cast_to_flatten_array() const {\n+const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {\n@@ -4792,1 +4792,1 @@\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, Offset(0), flatten_array());\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, Offset(0), flat_array());\n@@ -5201,1 +5201,1 @@\n-      \/\/ Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.\n+      \/\/ Meeting flat inline type array with non-flat array. Adjust (field) offset accordingly.\n@@ -5208,1 +5208,1 @@\n-        off = Offset(flattened_offset()).meet(Offset(tap->flattened_offset()));\n+        off = Offset(flat_offset()).meet(Offset(tap->flat_offset()));\n@@ -5210,1 +5210,1 @@\n-      } else if (flattened_offset() == tap->flattened_offset()) {\n+      } else if (flat_offset() == tap->flat_offset()) {\n@@ -5252,1 +5252,1 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact() && !tp->flatten_array()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact() && !tp->flat_array()) {\n@@ -5271,1 +5271,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact() && !tp->flatten_array()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact() && !tp->flat_array()) {\n@@ -5572,2 +5572,2 @@\n-\/\/ Return offset incremented by field_offset for flattened inline type arrays\n-int TypeAryPtr::flattened_offset() const {\n+\/\/ Return offset incremented by field_offset for flat inline type arrays\n+int TypeAryPtr::flat_offset() const {\n@@ -6080,1 +6080,1 @@\n-    if (isa_instklassptr() && is_instklassptr()->flatten_array()) st->print(\":flatten array\");\n+    if (isa_instklassptr() && is_instklassptr()->flat_array()) st->print(\":flat array\");\n@@ -6098,1 +6098,1 @@\n-    flatten_array() == p->flatten_array() &&\n+    flat_array() == p->flat_array() &&\n@@ -6103,1 +6103,1 @@\n-  return klass()->hash() + TypeKlassPtr::hash() + (uint)flatten_array();\n+  return klass()->hash() + TypeKlassPtr::hash() + (uint)flat_array();\n@@ -6106,2 +6106,2 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, Offset offset, bool flatten_array) {\n-  flatten_array = flatten_array || k->flatten_array();\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, Offset offset, bool flat_array) {\n+  flat_array = flat_array || k->flat_array();\n@@ -6110,1 +6110,1 @@\n-    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, interfaces, offset, flatten_array))->hashcons();\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, interfaces, offset, flat_array))->hashcons();\n@@ -6118,1 +6118,1 @@\n-  return make(_ptr, klass(), _interfaces, xadd_offset(offset), flatten_array());\n+  return make(_ptr, klass(), _interfaces, xadd_offset(offset), flat_array());\n@@ -6122,1 +6122,1 @@\n-  return make(_ptr, klass(), _interfaces, Offset(offset), flatten_array());\n+  return make(_ptr, klass(), _interfaces, Offset(offset), flat_array());\n@@ -6129,1 +6129,1 @@\n-  return make(ptr, _klass, _interfaces, _offset, flatten_array());\n+  return make(ptr, _klass, _interfaces, _offset, flat_array());\n@@ -6145,1 +6145,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset, flatten_array());\n+  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset, flat_array());\n@@ -6177,1 +6177,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, nullptr, Offset(0), flatten_array() && !klass()->is_inlinetype());\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, nullptr, Offset(0), flat_array() && !klass()->is_inlinetype());\n@@ -6218,1 +6218,1 @@\n-      return make(ptr, klass(), _interfaces, offset, flatten_array());\n+      return make(ptr, klass(), _interfaces, offset, flat_array());\n@@ -6257,2 +6257,2 @@\n-    bool res_flatten_array = false;\n-    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk, res_flatten_array)) {\n+    bool res_flat_array = false;\n+    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk, res_flat_array)) {\n@@ -6266,1 +6266,1 @@\n-        const Type* res = make(ptr, res_klass, interfaces, off, res_flatten_array);\n+        const Type* res = make(ptr, res_klass, interfaces, off, res_flat_array);\n@@ -6327,1 +6327,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset(), flatten_array());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset(), flat_array());\n@@ -6478,1 +6478,1 @@\n-                                                     !k->as_array_klass()->element_klass()->flatten_array());\n+                                                     !k->as_array_klass()->element_klass()->flat_array());\n@@ -6666,1 +6666,1 @@\n-      not_flat = !UseFlatArray || not_null_free || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->flatten_array());\n+      not_flat = !UseFlatArray || not_null_free || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->flat_array());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":72,"deletions":72,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -798,2 +798,2 @@\n-  const bool _flat;             \/\/ Array is flattened\n-  const bool _not_flat;         \/\/ Array is never flattened\n+  const bool _flat;             \/\/ Array is flat\n+  const bool _not_flat;         \/\/ Array is never flat\n@@ -1021,1 +1021,1 @@\n-                                                            ciKlass*& res_klass, bool& res_xk, bool& res_flatten_array);\n+                                                            ciKlass*& res_klass, bool& res_xk, bool& res_flat_array);\n@@ -1053,1 +1053,1 @@\n-  virtual int flattened_offset() const { return offset(); }\n+  virtual int flat_offset() const { return offset(); }\n@@ -1091,2 +1091,2 @@\n-  virtual bool flatten_array()      const { return false; }\n-  virtual bool not_flatten_array()  const { return false; }\n+  virtual bool flat_array()         const { return false; }\n+  virtual bool not_flat_array()     const { return false; }\n@@ -1325,1 +1325,1 @@\n-              bool flatten_array, int instance_id, const TypePtr* speculative,\n+              bool flat_array, int instance_id, const TypePtr* speculative,\n@@ -1330,1 +1330,1 @@\n-  bool _flatten_array;     \/\/ Type is flat in arrays\n+  bool _flat_array;     \/\/ Type is flat in arrays\n@@ -1378,1 +1378,1 @@\n-                                 bool flatten_array = false,\n+                                 bool flat_array = false,\n@@ -1410,3 +1410,3 @@\n-  virtual const TypeInstPtr* cast_to_flatten_array() const;\n-  virtual bool flatten_array() const { return _flatten_array; }\n-  virtual bool not_flatten_array() const { return !can_be_inline_type() || (_klass->is_inlinetype() && !flatten_array()); }\n+  virtual const TypeInstPtr* cast_to_flat_array() const;\n+  virtual bool flat_array() const { return _flat_array; }\n+  virtual bool not_flat_array() const { return !can_be_inline_type() || (_klass->is_inlinetype() && !flat_array()); }\n@@ -1471,1 +1471,1 @@\n-  \/\/ For flattened inline type arrays, each field of the inline type in\n+  \/\/ For flat inline type arrays, each field of the inline type in\n@@ -1565,1 +1565,1 @@\n-  int flattened_offset() const;\n+  int flat_offset() const;\n@@ -1741,2 +1741,2 @@\n-  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, Offset offset, bool flatten_array)\n-    : TypeKlassPtr(InstKlassPtr, ptr, klass, interfaces, offset), _flatten_array(flatten_array) {\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, Offset offset, bool flat_array)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, interfaces, offset), _flat_array(flat_array) {\n@@ -1748,1 +1748,1 @@\n-  const bool _flatten_array; \/\/ Type is flat in arrays\n+  const bool _flat_array; \/\/ Type is flat in arrays\n@@ -1767,1 +1767,1 @@\n-  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, Offset offset, bool flatten_array = false);\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, Offset offset, bool flat_array = false);\n@@ -1790,2 +1790,2 @@\n-  virtual bool flatten_array() const { return _flatten_array; }\n-  virtual bool not_flatten_array() const { return !_klass->can_be_inline_klass() || (_klass->is_inlinetype() && !flatten_array()); }\n+  virtual bool flat_array() const { return _flat_array; }\n+  virtual bool not_flat_array() const { return !_klass->can_be_inline_klass() || (_klass->is_inlinetype() && !flat_array()); }\n@@ -1809,1 +1809,1 @@\n-  const bool _not_flat;      \/\/ Array is never flattened\n+  const bool _not_flat;      \/\/ Array is never flat\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1645,1 +1645,1 @@\n-  assert(vk->flatten_array(), \"should only be used for flat inline type arrays\");\n+  assert(vk->flat_array(), \"should only be used for flat inline type arrays\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}