{"files":[{"patch":"@@ -99,0 +99,2 @@\n+  product(bool, UseSIMDForBigIntegerShiftIntrinsics, true,              \\\n+          \"Use SIMD instructions for left\/right shift of BigInteger\")   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -555,1 +555,3 @@\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind));\n+  set_last_Java_frame(esp, rfp, (address)pc(), rscratch1);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n+  reset_last_Java_frame(true);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3986,0 +3986,232 @@\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Input:\n+  \/\/   c_rarg0   - newArr address\n+  \/\/   c_rarg1   - oldArr address\n+  \/\/   c_rarg2   - newIdx\n+  \/\/   c_rarg3   - shiftCount\n+  \/\/   c_rarg4   - numIter\n+  \/\/\n+  address generate_bigIntegerRightShift() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerRightShiftWorker\");\n+    address start = __ pc();\n+\n+    Label ShiftSIMDLoop, ShiftTwoLoop, ShiftThree, ShiftTwo, ShiftOne, Exit;\n+\n+    Register newArr        = c_rarg0;\n+    Register oldArr        = c_rarg1;\n+    Register newIdx        = c_rarg2;\n+    Register shiftCount    = c_rarg3;\n+    Register numIter       = c_rarg4;\n+    Register idx           = numIter;\n+\n+    Register newArrCur     = rscratch1;\n+    Register shiftRevCount = rscratch2;\n+    Register oldArrCur     = r13;\n+    Register oldArrNext    = r14;\n+\n+    FloatRegister oldElem0        = v0;\n+    FloatRegister oldElem1        = v1;\n+    FloatRegister newElem         = v2;\n+    FloatRegister shiftVCount     = v3;\n+    FloatRegister shiftVRevCount  = v4;\n+\n+    __ cbz(idx, Exit);\n+\n+    __ add(newArr, newArr, newIdx, Assembler::LSL, 2);\n+\n+    \/\/ left shift count\n+    __ movw(shiftRevCount, 32);\n+    __ subw(shiftRevCount, shiftRevCount, shiftCount);\n+\n+    \/\/ numIter too small to allow a 4-words SIMD loop, rolling back\n+    __ cmp(numIter, (u1)4);\n+    __ br(Assembler::LT, ShiftThree);\n+\n+    __ dup(shiftVCount,    __ T4S, shiftCount);\n+    __ dup(shiftVRevCount, __ T4S, shiftRevCount);\n+    __ negr(shiftVCount,   __ T4S, shiftVCount);\n+\n+    __ BIND(ShiftSIMDLoop);\n+\n+    \/\/ Calculate the load addresses\n+    __ sub(idx, idx, 4);\n+    __ add(oldArrNext, oldArr, idx, Assembler::LSL, 2);\n+    __ add(newArrCur,  newArr, idx, Assembler::LSL, 2);\n+    __ add(oldArrCur,  oldArrNext, 4);\n+\n+    \/\/ Load 4 words and process\n+    __ ld1(oldElem0,  __ T4S,  Address(oldArrCur));\n+    __ ld1(oldElem1,  __ T4S,  Address(oldArrNext));\n+    __ ushl(oldElem0, __ T4S,  oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T4S,  oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T16B, oldElem0, oldElem1);\n+    __ st1(newElem,   __ T4S,  Address(newArrCur));\n+\n+    __ cmp(idx, (u1)4);\n+    __ br(Assembler::LT, ShiftTwoLoop);\n+    __ b(ShiftSIMDLoop);\n+\n+    __ BIND(ShiftTwoLoop);\n+    __ cbz(idx, Exit);\n+    __ cmp(idx, (u1)1);\n+    __ br(Assembler::EQ, ShiftOne);\n+\n+    \/\/ Calculate the load addresses\n+    __ sub(idx, idx, 2);\n+    __ add(oldArrNext, oldArr, idx, Assembler::LSL, 2);\n+    __ add(newArrCur,  newArr, idx, Assembler::LSL, 2);\n+    __ add(oldArrCur,  oldArrNext, 4);\n+\n+    \/\/ Load 2 words and process\n+    __ ld1(oldElem0,  __ T2S, Address(oldArrCur));\n+    __ ld1(oldElem1,  __ T2S, Address(oldArrNext));\n+    __ ushl(oldElem0, __ T2S, oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T2S, oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T8B, oldElem0, oldElem1);\n+    __ st1(newElem,   __ T2S, Address(newArrCur));\n+    __ b(ShiftTwoLoop);\n+\n+    __ BIND(ShiftThree);\n+    __ tbz(idx, 1, ShiftOne);\n+    __ tbz(idx, 0, ShiftTwo);\n+    __ ldrw(r10,  Address(oldArr, 12));\n+    __ ldrw(r11,  Address(oldArr, 8));\n+    __ lsrvw(r10, r10, shiftCount);\n+    __ lslvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr, 8));\n+\n+    __ BIND(ShiftTwo);\n+    __ ldrw(r10,  Address(oldArr, 8));\n+    __ ldrw(r11,  Address(oldArr, 4));\n+    __ lsrvw(r10, r10, shiftCount);\n+    __ lslvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr, 4));\n+\n+    __ BIND(ShiftOne);\n+    __ ldrw(r10,  Address(oldArr, 4));\n+    __ ldrw(r11,  Address(oldArr));\n+    __ lsrvw(r10, r10, shiftCount);\n+    __ lslvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr));\n+\n+    __ BIND(Exit);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Input:\n+  \/\/   c_rarg0   - newArr address\n+  \/\/   c_rarg1   - oldArr address\n+  \/\/   c_rarg2   - newIdx\n+  \/\/   c_rarg3   - shiftCount\n+  \/\/   c_rarg4   - numIter\n+  \/\/\n+  address generate_bigIntegerLeftShift() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerLeftShiftWorker\");\n+    address start = __ pc();\n+\n+    Label ShiftSIMDLoop, ShiftTwoLoop, ShiftThree, ShiftTwo, ShiftOne, Exit;\n+\n+    Register newArr        = c_rarg0;\n+    Register oldArr        = c_rarg1;\n+    Register newIdx        = c_rarg2;\n+    Register shiftCount    = c_rarg3;\n+    Register numIter       = c_rarg4;\n+\n+    Register shiftRevCount = rscratch1;\n+    Register oldArrNext    = rscratch2;\n+\n+    FloatRegister oldElem0        = v0;\n+    FloatRegister oldElem1        = v1;\n+    FloatRegister newElem         = v2;\n+    FloatRegister shiftVCount     = v3;\n+    FloatRegister shiftVRevCount  = v4;\n+\n+    __ cbz(numIter, Exit);\n+\n+    __ add(oldArrNext, oldArr, 4);\n+    __ add(newArr, newArr, newIdx, Assembler::LSL, 2);\n+\n+    \/\/ right shift count\n+    __ movw(shiftRevCount, 32);\n+    __ subw(shiftRevCount, shiftRevCount, shiftCount);\n+\n+    \/\/ numIter too small to allow a 4-words SIMD loop, rolling back\n+    __ cmp(numIter, (u1)4);\n+    __ br(Assembler::LT, ShiftThree);\n+\n+    __ dup(shiftVCount,     __ T4S, shiftCount);\n+    __ dup(shiftVRevCount,  __ T4S, shiftRevCount);\n+    __ negr(shiftVRevCount, __ T4S, shiftVRevCount);\n+\n+    __ BIND(ShiftSIMDLoop);\n+\n+    \/\/ load 4 words and process\n+    __ ld1(oldElem0,  __ T4S,  __ post(oldArr, 16));\n+    __ ld1(oldElem1,  __ T4S,  __ post(oldArrNext, 16));\n+    __ ushl(oldElem0, __ T4S,  oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T4S,  oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T16B, oldElem0, oldElem1);\n+    __ st1(newElem,   __ T4S,  __ post(newArr, 16));\n+    __ sub(numIter,   numIter, 4);\n+\n+    __ cmp(numIter, (u1)4);\n+    __ br(Assembler::LT, ShiftTwoLoop);\n+    __ b(ShiftSIMDLoop);\n+\n+    __ BIND(ShiftTwoLoop);\n+    __ cbz(numIter, Exit);\n+    __ cmp(numIter, (u1)1);\n+    __ br(Assembler::EQ, ShiftOne);\n+\n+    \/\/ load 2 words and process\n+    __ ld1(oldElem0,  __ T2S,  __ post(oldArr, 8));\n+    __ ld1(oldElem1,  __ T2S,  __ post(oldArrNext, 8));\n+    __ ushl(oldElem0, __ T2S,  oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T2S,  oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T8B,  oldElem0, oldElem1);\n+    __ st1(newElem,   __ T2S,  __ post(newArr, 8));\n+    __ sub(numIter,   numIter, 2);\n+    __ b(ShiftTwoLoop);\n+\n+    __ BIND(ShiftThree);\n+    __ ldrw(r10,  __ post(oldArr, 4));\n+    __ ldrw(r11,  __ post(oldArrNext, 4));\n+    __ lslvw(r10, r10, shiftCount);\n+    __ lsrvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  __ post(newArr, 4));\n+    __ tbz(numIter, 1, Exit);\n+    __ tbz(numIter, 0, ShiftOne);\n+\n+    __ BIND(ShiftTwo);\n+    __ ldrw(r10,  __ post(oldArr, 4));\n+    __ ldrw(r11,  __ post(oldArrNext, 4));\n+    __ lslvw(r10, r10, shiftCount);\n+    __ lsrvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  __ post(newArr, 4));\n+\n+    __ BIND(ShiftOne);\n+    __ ldrw(r10,  Address(oldArr));\n+    __ ldrw(r11,  Address(oldArrNext));\n+    __ lslvw(r10, r10, shiftCount);\n+    __ lsrvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr));\n+\n+    __ BIND(Exit);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -6425,0 +6657,5 @@\n+    if (UseSIMDForBigIntegerShiftIntrinsics) {\n+      StubRoutines::_bigIntegerRightShiftWorker = generate_bigIntegerRightShift();\n+      StubRoutines::_bigIntegerLeftShiftWorker  = generate_bigIntegerLeftShift();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":237,"deletions":0,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -614,0 +614,4 @@\n+void InterpreterMacroAssembler::push_i_or_ptr(Register r) {\n+  push(r);\n+}\n+\n@@ -1008,1 +1012,3 @@\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind));\n+  set_last_Java_frame(rthread, noreg, rbp, (address)pc());\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n+  reset_last_Java_frame(rthread, true);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -142,0 +142,4 @@\n+\n+  \/\/ On x86, pushing a ptr or an int is semantically identical, but we\n+  \/\/ maintain a distinction for clarity and for making it easier to change\n+  \/\/ semantics in the future\n@@ -145,0 +149,5 @@\n+  \/\/ push_i_or_ptr is provided for when explicitly allowing either a ptr or\n+  \/\/ an int might have some advantage, while still documenting the fact that a\n+  \/\/ ptr might be pushed to the stack.\n+  void push_i_or_ptr(Register r = rax);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1770,3 +1770,0 @@\n-  aep = __ pc();     \/\/ atos entry point\n-      __ push_ptr();\n-      __ jmp(L);\n@@ -1791,2 +1788,2 @@\n-  bep = cep = sep = iep = __ pc();      \/\/ [bcsi]tos entry point\n-      __ push_i();\n+  aep = bep = cep = sep = iep = __ pc();      \/\/ [abcsi]tos entry point\n+      __ push_i_or_ptr();\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3215,0 +3215,6 @@\n+  LIR_Opr opr = get_operand(reg_num);\n+  assert(opr->is_valid(), \"unknown register\");\n+  opr->print(out);\n+}\n+\n+LIR_Opr LinearScan::get_operand(int reg_num) {\n@@ -3234,1 +3240,1 @@\n-    assert(false, \"unknown register\");\n+    \/\/ reg_num == -1 or a virtual register, return the illegal operand\n@@ -3236,1 +3242,1 @@\n-  opr->print(out);\n+  return opr;\n@@ -4601,1 +4607,1 @@\n-void Interval::print_on(outputStream* out) const {\n+void Interval::print_on(outputStream* out, bool is_cfg_printer) const {\n@@ -4611,5 +4617,9 @@\n-\n-  if (reg_num() < LIR_OprDesc::vreg_base) {\n-    LinearScan::print_reg_num(out, assigned_reg());\n-  } else if (assigned_reg() != -1 && (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {\n-    LinearScan::calc_operand_for_interval(this)->print(out);\n+\n+  if (is_cfg_printer) {\n+    \/\/ Special version for compatibility with C1 Visualizer.\n+    LIR_Opr opr = LinearScan::get_operand(reg_num());\n+    if (opr->is_valid()) {\n+      out->print(\"\\\"\");\n+      opr->print(out);\n+      out->print(\"\\\" \");\n+    }\n@@ -4618,2 +4628,10 @@\n-    \/\/ Virtual register that has no assigned register yet.\n-    out->print(\"[ANY]\");\n+    \/\/ Improved output for normal debugging.\n+    if (reg_num() < LIR_OprDesc::vreg_base) {\n+      LinearScan::print_reg_num(out, assigned_reg());\n+    } else if (assigned_reg() != -1 && (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {\n+      LinearScan::calc_operand_for_interval(this)->print(out);\n+    } else {\n+      \/\/ Virtual register that has no assigned register yet.\n+      out->print(\"[ANY]\");\n+    }\n+    out->print(\" \");\n@@ -4621,2 +4639,1 @@\n-\n-  out->print(\" %d %d \", split_parent()->reg_num(), (register_hint(false) != NULL ? register_hint(false)->reg_num() : -1));\n+  out->print(\"%d %d \", split_parent()->reg_num(), (register_hint(false) != NULL ? register_hint(false)->reg_num() : -1));\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -790,3 +790,0 @@\n-  \/\/ Accessibility checks are performed in ciEnv::get_method_by_index_impl.\n-  assert(check_klass_accessibility(accessor, holder->get_Klass()), \"holder not accessible\");\n-\n@@ -795,2 +792,8 @@\n-  Method* dest_method;\n-  LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::AccessCheck::required, LinkInfo::LoaderConstraintCheck::required, tag);\n+\n+  \/\/ Accessibility checks are performed in ciEnv::get_method_by_index_impl.\n+  assert(check_klass_accessibility(accessor, holder_klass), \"holder not accessible\");\n+\n+  LinkInfo link_info(holder_klass, name, sig, accessor_klass,\n+                     LinkInfo::AccessCheck::required,\n+                     LinkInfo::LoaderConstraintCheck::required,\n+                     tag);\n@@ -798,20 +801,12 @@\n-  case Bytecodes::_invokestatic:\n-    dest_method =\n-      LinkResolver::resolve_static_call_or_null(link_info);\n-    break;\n-  case Bytecodes::_invokespecial:\n-    dest_method =\n-      LinkResolver::resolve_special_call_or_null(link_info);\n-    break;\n-  case Bytecodes::_invokeinterface:\n-    dest_method =\n-      LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n-    break;\n-  case Bytecodes::_invokevirtual:\n-    dest_method =\n-      LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n-    break;\n-  default: ShouldNotReachHere();\n-  }\n-\n-  return dest_method;\n+    case Bytecodes::_invokestatic:\n+      return LinkResolver::resolve_static_call_or_null(link_info);\n+    case Bytecodes::_invokespecial:\n+      return LinkResolver::resolve_special_call_or_null(link_info);\n+    case Bytecodes::_invokeinterface:\n+      return LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n+    case Bytecodes::_invokevirtual:\n+      return LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n+    default:\n+      fatal(\"Unhandled bytecode: %s\", Bytecodes::name(bc));\n+      return NULL; \/\/ silence compiler warnings\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -3800,6 +3800,0 @@\n-bool ClassFileParser::supports_records() {\n-  return _major_version == JVM_CLASSFILE_MAJOR_VERSION &&\n-         _minor_version == JAVA_PREVIEW_MINOR_VERSION &&\n-         Arguments::enable_preview();\n-}\n-\n@@ -4053,8 +4047,7 @@\n-        } else if (_major_version >= JAVA_14_VERSION) {\n-          if (tag == vmSymbols::tag_record()) {\n-            \/\/ Skip over Record attribute if not supported or if super class is\n-            \/\/ not java.lang.Record.\n-            if (supports_records() &&\n-                cp->klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {\n-              if (parsed_record_attribute) {\n-                classfile_parse_error(\"Multiple Record attributes in class file %s\", THREAD);\n+\n+        } else if (_major_version >= JAVA_15_VERSION) {\n+          \/\/ Check for PermittedSubclasses tag\n+          if (tag == vmSymbols::tag_permitted_subclasses()) {\n+            if (supports_sealed_types()) {\n+              if (parsed_permitted_subclasses_attribute) {\n+                classfile_parse_error(\"Multiple PermittedSubclasses attributes in class file %s\", CHECK);\n@@ -4063,3 +4056,15 @@\n-              \/\/ Check that class is final and not abstract.\n-              if (!_access_flags.is_final() || _access_flags.is_abstract()) {\n-                classfile_parse_error(\"Record attribute in non-final or abstract class file %s\", THREAD);\n+              \/\/ Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.\n+              if (_access_flags.is_final()) {\n+                classfile_parse_error(\"PermittedSubclasses attribute in final class file %s\", CHECK);\n+                return;\n+              }\n+              parsed_permitted_subclasses_attribute = true;\n+              permitted_subclasses_attribute_start = cfs->current();\n+              permitted_subclasses_attribute_length = attribute_length;\n+            }\n+            cfs->skip_u1(attribute_length, CHECK);\n+\n+          } else if (_major_version >= JAVA_16_VERSION) {\n+            if (tag == vmSymbols::tag_record()) {\n+              if (parsed_record_attribute) {\n+                classfile_parse_error(\"Multiple Record attributes in class file %s\", THREAD);\n@@ -4071,37 +4076,0 @@\n-            } else if (log_is_enabled(Info, class, record)) {\n-              \/\/ Log why the Record attribute was ignored.  Note that if the\n-              \/\/ class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and\n-              \/\/ --enable-preview wasn't specified then a java.lang.UnsupportedClassVersionError\n-              \/\/ exception would have been thrown.\n-              ResourceMark rm(THREAD);\n-              if (supports_records()) {\n-                log_info(class, record)(\n-                  \"Ignoring Record attribute in class %s because super type is not java.lang.Record\",\n-                  _class_name->as_C_string());\n-              } else {\n-                log_info(class, record)(\n-                  \"Ignoring Record attribute in class %s because class file version is not %d.65535\",\n-                   _class_name->as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);\n-            }\n-          } else if (_major_version >= JAVA_15_VERSION) {\n-            \/\/ Check for PermittedSubclasses tag\n-            if (tag == vmSymbols::tag_permitted_subclasses()) {\n-              if (supports_sealed_types()) {\n-                if (parsed_permitted_subclasses_attribute) {\n-                  classfile_parse_error(\"Multiple PermittedSubclasses attributes in class file %s\", THREAD);\n-                  return;\n-                }\n-                \/\/ Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.\n-                if (_access_flags.is_final()) {\n-                  classfile_parse_error(\"PermittedSubclasses attribute in final class file %s\", THREAD);\n-                  return;\n-                }\n-                parsed_permitted_subclasses_attribute = true;\n-                permitted_subclasses_attribute_start = cfs->current();\n-                permitted_subclasses_attribute_length = attribute_length;\n-              }\n-              cfs->skip_u1(attribute_length, CHECK);\n-            } else {\n-              \/\/ Unknown attribute\n-              cfs->skip_u1(attribute_length, CHECK);\n-            }\n@@ -4643,7 +4611,1 @@\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_VerifyError(),\n-        \"class %s cannot inherit from final class %s\",\n-        this_klass->external_name(),\n-        super_ik->external_name());\n+      classfile_icce_error(\"class %s cannot inherit from final class %s\", super_ik, THREAD);\n@@ -4794,9 +4756,6 @@\n-              Exceptions::fthrow(THREAD_AND_LOCATION,\n-                                 vmSymbols::java_lang_VerifyError(),\n-                                 \"class %s overrides final method %s.%s%s\",\n-                                 this_klass->external_name(),\n-                                 super_m->method_holder()->external_name(),\n-                                 name->as_C_string(),\n-                                 signature->as_C_string()\n-                                 );\n-              return;\n+              THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                        err_msg(\"class %s overrides final method %s.%s%s\",\n+                                this_klass->external_name(),\n+                                super_m->method_holder()->external_name(),\n+                                name->as_C_string(),\n+                                signature->as_C_string()));\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":29,"deletions":70,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  template(java_version_name,                         \"java_version\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1421,4 +1421,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::at_unwind(JavaThread* thread))\n-  \/\/ JRT_END does an implicit safepoint check, hence we are guaranteed to block\n-  \/\/ if this is called during a safepoint\n-\n+JRT_LEAF(void, InterpreterRuntime::at_unwind(JavaThread* thread))\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -48,0 +49,27 @@\n+class AdapterHandlerEntry;\n+\n+class MethodTrampolineInfo {\n+  address _c2i_entry_trampoline;\n+  address _c2i_inline_ro_entry_trampoline;\n+  address _c2i_inline_entry_trampoline;\n+  AdapterHandlerEntry** _adapter_trampoline;\n+public:\n+  address c2i_entry_trampoline() { return _c2i_entry_trampoline; }\n+  address c2i_inline_ro_entry_trampoline() { return _c2i_inline_ro_entry_trampoline; }\n+  address c2i_inline_entry_trampoline() { return _c2i_inline_entry_trampoline; }\n+  AdapterHandlerEntry** adapter_trampoline() { return _adapter_trampoline; }\n+  void set_c2i_entry_trampoline(address addr) { _c2i_entry_trampoline = addr; }\n+  void set_c2i_inline_ro_entry_trampoline(address addr) { _c2i_inline_ro_entry_trampoline = addr; }\n+  void set_c2i_inline_entry_trampoline(address addr) { _c2i_inline_entry_trampoline = addr; }\n+  void set_adapter_trampoline(AdapterHandlerEntry** entry) { _adapter_trampoline = entry; }\n+};\n+\n+class AdapterToTrampoline : public ResourceHashtable<\n+  AdapterHandlerEntry*, MethodTrampolineInfo,\n+  primitive_hash<AdapterHandlerEntry*>,\n+  primitive_equals<AdapterHandlerEntry*>,\n+  941, \/\/ prime number\n+  ResourceObj::C_HEAP> {};\n+\n+static AdapterToTrampoline* _adapter_to_trampoline = NULL;\n+\n@@ -262,0 +290,2 @@\n+    allocate_method_trampoline_info();\n+    allocate_method_trampolines();\n@@ -812,0 +842,92 @@\n+\n+void ArchiveBuilder::allocate_method_trampolines_for(InstanceKlass* ik) {\n+  if (ik->methods() != NULL) {\n+    for (int j = 0; j < ik->methods()->length(); j++) {\n+      \/\/ Walk the methods in a deterministic order so that the trampolines are\n+      \/\/ created in a deterministic order.\n+      Method* m = ik->methods()->at(j);\n+      AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n+      MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n+      if (info->c2i_entry_trampoline() == NULL) {\n+        info->set_c2i_entry_trampoline(\n+          (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size()));\n+        info->set_c2i_inline_ro_entry_trampoline(\n+         (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size()));\n+        info->set_c2i_inline_entry_trampoline(\n+         (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size()));\n+        info->set_adapter_trampoline(\n+          (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*)));\n+      }\n+    }\n+  }\n+}\n+\n+void ArchiveBuilder::allocate_method_trampolines() {\n+  for (int i = 0; i < _klasses->length(); i++) {\n+    Klass* k = _klasses->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      allocate_method_trampolines_for(ik);\n+    }\n+  }\n+}\n+\n+\/\/ Allocate MethodTrampolineInfo for all Methods that will be archived. Also\n+\/\/ return the total number of bytes needed by the method trampolines in the MC\n+\/\/ region.\n+size_t ArchiveBuilder::allocate_method_trampoline_info() {\n+  size_t total = 0;\n+  size_t each_method_bytes =\n+    align_up(SharedRuntime::trampoline_size(), BytesPerWord) * 3 +\n+    align_up(sizeof(AdapterHandlerEntry*), BytesPerWord);\n+\n+  if (_adapter_to_trampoline == NULL) {\n+    _adapter_to_trampoline = new (ResourceObj::C_HEAP, mtClass)AdapterToTrampoline();\n+  }\n+  int count = 0;\n+  for (int i = 0; i < _klasses->length(); i++) {\n+    Klass* k = _klasses->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      if (ik->methods() != NULL) {\n+        for (int j = 0; j < ik->methods()->length(); j++) {\n+          Method* m = ik->methods()->at(j);\n+          AdapterHandlerEntry* ent = m->adapter(); \/\/ different methods can share the same AdapterHandlerEntry\n+          bool is_created = false;\n+          MethodTrampolineInfo* info = _adapter_to_trampoline->put_if_absent(ent, &is_created);\n+          if (is_created) {\n+            count++;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  if (count == 0) {\n+    \/\/ We have nothing to archive, but let's avoid having an empty region.\n+    total = SharedRuntime::trampoline_size();\n+  } else {\n+    total = count * each_method_bytes;\n+  }\n+  return align_up(total, SharedSpaceObjectAlignment);\n+}\n+\n+void ArchiveBuilder::update_method_trampolines() {\n+  for (int i = 0; i < klasses()->length(); i++) {\n+    Klass* k = klasses()->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      Array<Method*>* methods = ik->methods();\n+      for (int j = 0; j < methods->length(); j++) {\n+        Method* m = methods->at(j);\n+        AdapterHandlerEntry* ent = m->adapter();\n+        MethodTrampolineInfo* info = _adapter_to_trampoline->get(ent);\n+        \/\/ m is the \"copy\" of the original Method, but its adapter() field is still valid because\n+        \/\/ we haven't called make_klasses_shareable() yet.\n+        m->set_from_compiled_entry(info->c2i_entry_trampoline());\n+        m->set_from_compiled_inline_ro_entry(info->c2i_inline_ro_entry_trampoline());\n+        m->set_from_compiled_inline_entry(info->c2i_inline_entry_trampoline());\n+        m->set_adapter_trampoline(info->adapter_trampoline());\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":122,"deletions":0,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -289,0 +289,7 @@\n+\n+  \/\/ Method trampolines related functions\n+  void allocate_method_trampolines();\n+  void allocate_method_trampolines_for(InstanceKlass* ik);\n+  size_t allocate_method_trampoline_info();\n+  void update_method_trampolines();\n+\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -775,0 +775,3 @@\n+  log_info(cds)(\"Update method trampolines\");\n+  builder.update_method_trampolines();\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1149,20 +1149,7 @@\n-  if (DynamicDumpSharedSpaces) {\n-    assert(_from_compiled_entry != NULL, \"sanity\");\n-  } else {\n-    \/\/ TODO: Simplify the adapter trampoline allocation for static archiving.\n-    \/\/       Remove the use of CDSAdapterHandlerEntry.\n-    CDSAdapterHandlerEntry* cds_adapter = (CDSAdapterHandlerEntry*)adapter();\n-    constMethod()->set_adapter_trampoline(cds_adapter->get_adapter_trampoline());\n-\n-    _from_compiled_entry = cds_adapter->get_c2i_entry_trampoline();\n-    assert(*((int*)_from_compiled_entry) == 0,\n-           \"instructions must be zeros during dump time, to be initialized at run time\");\n-\n-    _from_compiled_inline_ro_entry = cds_adapter->get_c2i_inline_ro_entry_trampoline();\n-    assert(*((int*)_from_compiled_inline_ro_entry) == 0,\n-           \"instructions must be zeros during dump time, to be initialized at run time\");\n-\n-    _from_compiled_inline_entry = cds_adapter->get_c2i_inline_entry_trampoline();\n-    assert(*((int*)_from_compiled_inline_entry) == 0,\n-           \"instructions must be zeros during dump time, to be initialized at run time\");\n-  }\n+  assert(_from_compiled_entry != NULL, \"sanity\");\n+  assert(*((int*)_from_compiled_entry) == 0,\n+         \"must be NULL during dump time, to be initialized at run time\");\n+  assert(*((int*)_from_compiled_inline_ro_entry) == 0,\n+         \"must be NULL during dump time, to be initialized at run time\");\n+  assert(*((int*)_from_compiled_inline_entry) == 0,\n+         \"must be NULL during dump time, to be initialized at run time\");\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -940,2 +940,0 @@\n-  set_do_count_invocations(false);\n-  set_do_method_data_update(false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,2 +287,0 @@\n-  bool                  _do_count_invocations;  \/\/ True if we generate code to count invocations\n-  bool                  _do_method_data_update; \/\/ True if we generate code to update MethodData*s\n@@ -579,4 +577,0 @@\n-  bool              do_count_invocations() const{ return _do_count_invocations; }\n-  void          set_do_count_invocations(bool z){ _do_count_invocations = z; }\n-  bool              do_method_data_update() const { return _do_method_data_update; }\n-  void          set_do_method_data_update(bool z) { _do_method_data_update = z; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -652,4 +652,0 @@\n-  \/\/ Bump method data counters (We profile *before* the call is made\n-  \/\/ because exceptions don't return to the call site.)\n-  profile_call(receiver);\n-\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,2 +333,0 @@\n-  bool          _count_invocations;  \/\/ update and test invocation counter\n-  bool          _method_data_update; \/\/ update method data oop\n@@ -380,2 +378,0 @@\n-  bool          count_invocations() const  { return _count_invocations; }\n-  bool          method_data_update() const { return _method_data_update; }\n@@ -504,3 +500,0 @@\n-  \/\/ Helper function to setup for type-profile based inlining\n-  bool prepare_type_profile_inline(ciInstanceKlass* prof_klass, ciMethod* prof_method);\n-\n@@ -565,3 +558,3 @@\n-  void    jump_if_true_fork(IfNode *ifNode, int dest_bci_if_true, int prof_table_index, bool unc);\n-  void    jump_if_false_fork(IfNode *ifNode, int dest_bci_if_false, int prof_table_index, bool unc);\n-  void    jump_if_always_fork(int dest_bci_if_true, int prof_table_index, bool unc);\n+  void    jump_if_true_fork(IfNode *ifNode, int dest_bci_if_true, bool unc);\n+  void    jump_if_false_fork(IfNode *ifNode, int dest_bci_if_false, bool unc);\n+  void    jump_if_always_fork(int dest_bci_if_true, bool unc);\n@@ -577,17 +570,0 @@\n-  \/\/ helper functions for methodData style profiling\n-  void test_counter_against_threshold(Node* cnt, int limit);\n-  void increment_and_test_invocation_counter(int limit);\n-  void test_for_osr_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize offset, int limit);\n-  Node* method_data_addressing(ciMethodData* md, ciProfileData* data, ByteSize offset, Node* idx = NULL, uint stride = 0);\n-  void increment_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize offset, Node* idx = NULL, uint stride = 0);\n-  void set_md_flag_at(ciMethodData* md, ciProfileData* data, int flag_constant);\n-\n-  void profile_method_entry();\n-  void profile_taken_branch(int target_bci, bool force_update = false);\n-  void profile_not_taken_branch(bool force_update = false);\n-  void profile_call(Node* receiver);\n-  void profile_generic_call();\n-  void profile_receiver_type(Node* receiver);\n-  void profile_ret(int target_bci);\n-  void profile_null_checkcast();\n-  void profile_switch_case(int table_index);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -492,3 +492,0 @@\n-  _count_invocations = C->do_count_invocations();\n-  _method_data_update = C->do_method_data_update();\n-\n@@ -1300,4 +1297,0 @@\n-\n-  if (depth() == 1) {\n-    increment_and_test_invocation_counter(Tier2CompileThreshold);\n-  }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -649,1 +649,1 @@\n-void Parse::jump_if_true_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {\n+void Parse::jump_if_true_fork(IfNode *iff, int dest_bci_if_true, bool unc) {\n@@ -662,1 +662,0 @@\n-      profile_switch_case(prof_table_index);\n@@ -672,1 +671,1 @@\n-void Parse::jump_if_false_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {\n+void Parse::jump_if_false_fork(IfNode *iff, int dest_bci_if_true, bool unc) {\n@@ -685,1 +684,0 @@\n-      profile_switch_case(prof_table_index);\n@@ -695,1 +693,1 @@\n-void Parse::jump_if_always_fork(int dest_bci, int prof_table_index, bool unc) {\n+void Parse::jump_if_always_fork(int dest_bci, bool unc) {\n@@ -705,1 +703,0 @@\n-    profile_switch_case(prof_table_index);\n@@ -720,4 +717,0 @@\n-\/\/ Default value for methodData switch indexing. Must be a negative value to avoid\n-\/\/ conflict with any legal switch index.\n-#define NullTableIndex -1\n-\n@@ -729,1 +722,0 @@\n-  int _table_index;             \/\/ index into method data table\n@@ -736,1 +728,0 @@\n-  int  table_index() const     { return _table_index; }\n@@ -740,1 +731,1 @@\n-  void setRange(jint lo, jint hi, int dest, int table_index, float cnt) {\n+  void setRange(jint lo, jint hi, int dest, float cnt) {\n@@ -742,1 +733,1 @@\n-    _lo = lo, _hi = hi; _dest = dest; _table_index = table_index; _cnt = cnt;\n+    _lo = lo, _hi = hi; _dest = dest; _cnt = cnt;\n@@ -745,1 +736,1 @@\n-  bool adjoinRange(jint lo, jint hi, int dest, int table_index, float cnt, bool trim_ranges) {\n+  bool adjoinRange(jint lo, jint hi, int dest, float cnt, bool trim_ranges) {\n@@ -747,1 +738,1 @@\n-    if (lo == _hi+1 && table_index == _table_index) {\n+    if (lo == _hi+1) {\n@@ -777,2 +768,2 @@\n-  void set (jint value, int dest, int table_index, float cnt) {\n-    setRange(value, value, dest, table_index, cnt);\n+  void set (jint value, int dest, float cnt) {\n+    setRange(value, value, dest, cnt);\n@@ -780,2 +771,2 @@\n-  bool adjoin(jint value, int dest, int table_index, float cnt, bool trim_ranges) {\n-    return adjoinRange(value, value, dest, table_index, cnt, trim_ranges);\n+  bool adjoin(jint value, int dest, float cnt, bool trim_ranges) {\n+    return adjoinRange(value, value, dest, cnt, trim_ranges);\n@@ -784,1 +775,1 @@\n-    return adjoinRange(other._lo, other._hi, other._dest, other._table_index, other._cnt, false);\n+    return adjoinRange(other._lo, other._hi, other._dest, other._cnt, false);\n@@ -835,1 +826,1 @@\n-      r.setRange(r.lo(), r.hi(), never_reached, r.table_index(), r.cnt());\n+      r.setRange(r.lo(), r.hi(), never_reached, r.cnt());\n@@ -864,1 +855,1 @@\n-  bool trim_ranges = !method_data_update() && !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n+  bool trim_ranges = !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n@@ -876,1 +867,1 @@\n-    ranges[++rp].setRange(min_jint, lo_index-1, default_dest, NullTableIndex, cnt);\n+    ranges[++rp].setRange(min_jint, lo_index-1, default_dest, cnt);\n@@ -882,1 +873,0 @@\n-    int  table_index = method_data_update() ? j : NullTableIndex;\n@@ -887,2 +877,2 @@\n-    if (rp < 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {\n-      ranges[++rp].set(match_int, dest, table_index, cnt);\n+    if (rp < 0 || !ranges[rp].adjoin(match_int, dest, cnt, trim_ranges)) {\n+      ranges[++rp].set(match_int, dest, cnt);\n@@ -898,2 +888,2 @@\n-    if (!ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, cnt, trim_ranges)) {\n-      ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, cnt);\n+    if (!ranges[rp].adjoinRange(highest+1, max_jint, default_dest, cnt, trim_ranges)) {\n+      ranges[++rp].setRange(highest+1, max_jint, default_dest, cnt);\n@@ -937,1 +927,1 @@\n-  bool trim_ranges = !method_data_update() && !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n+  bool trim_ranges = !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n@@ -977,1 +967,0 @@\n-    int  table_index = method_data_update() ? j : NullTableIndex;\n@@ -980,1 +969,1 @@\n-    if (match_int != next_lo && (rp < 0 || !ranges[rp].adjoinRange(next_lo, match_int-1, default_dest, NullTableIndex, c, trim_ranges))) {\n+    if (match_int != next_lo && (rp < 0 || !ranges[rp].adjoinRange(next_lo, match_int-1, default_dest, c, trim_ranges))) {\n@@ -982,1 +971,1 @@\n-      ranges[++rp].setRange(next_lo, match_int-1, default_dest, NullTableIndex, c);\n+      ranges[++rp].setRange(next_lo, match_int-1, default_dest, c);\n@@ -984,1 +973,1 @@\n-    if (rp < 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {\n+    if (rp < 0 || !ranges[rp].adjoin(match_int, dest, cnt, trim_ranges)) {\n@@ -986,1 +975,1 @@\n-      ranges[++rp].set(match_int, dest, table_index, cnt);\n+      ranges[++rp].set(match_int, dest, cnt);\n@@ -992,2 +981,2 @@\n-      !ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest), trim_ranges)) {\n-    ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest));\n+      !ranges[rp].adjoinRange(highest+1, max_jint, default_dest, default_cnt * ((float)max_jint - highest), trim_ranges)) {\n+    ranges[++rp].setRange(highest+1, max_jint, default_dest, default_cnt * ((float)max_jint - highest));\n@@ -1152,1 +1141,1 @@\n-          prev.setRange(prev.lo(), sr->hi(), prev.dest(), prev.table_index(), prev.cnt());\n+          prev.setRange(prev.lo(), sr->hi(), prev.dest(), prev.cnt());\n@@ -1179,1 +1168,1 @@\n-    jump_if_true_fork(iff, most_freq.dest(), most_freq.table_index(), false);\n+    jump_if_true_fork(iff, most_freq.dest(), false);\n@@ -1195,3 +1184,0 @@\n-  \/\/ Don't make jump table if profiling\n-  if (method_data_update())  return false;\n-\n@@ -1275,1 +1261,1 @@\n-    jump_if_true_fork(iff, default_dest, NullTableIndex, trim_ranges && trimmed_cnt == 0);\n+    jump_if_true_fork(iff, default_dest, trim_ranges && trimmed_cnt == 0);\n@@ -1335,1 +1321,1 @@\n-        jump_if_always_fork(r->dest(), r->table_index(), trim_ranges && r->cnt() == 0);\n+        jump_if_always_fork(r->dest(), trim_ranges && r->cnt() == 0);\n@@ -1347,1 +1333,1 @@\n-  bool trim_ranges = !method_data_update() && !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n+  bool trim_ranges = !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n@@ -1388,1 +1374,1 @@\n-      lo->setRange(min_val, lo->hi(), lo->dest(), lo->table_index(), lo->cnt());\n+      lo->setRange(min_val, lo->hi(), lo->dest(), lo->cnt());\n@@ -1394,1 +1380,1 @@\n-      hi->setRange(hi->lo(), max_val, hi->dest(), hi->table_index(), hi->cnt());\n+      hi->setRange(hi->lo(), max_val, hi->dest(), hi->cnt());\n@@ -1409,1 +1395,1 @@\n-    jump_if_always_fork(lo->dest(), lo->table_index(), trim_ranges && lo->cnt() == 0);\n+    jump_if_always_fork(lo->dest(), trim_ranges && lo->cnt() == 0);\n@@ -1447,1 +1433,1 @@\n-      jump_if_false_fork(iff_ne, mid->dest(), mid->table_index(), trim_ranges && mid->cnt() == 0);\n+      jump_if_false_fork(iff_ne, mid->dest(), trim_ranges && mid->cnt() == 0);\n@@ -1476,1 +1462,1 @@\n-        jump_if_true_fork(iff_ge, mid->dest(), mid->table_index(), trim_ranges && cnt == 0);\n+        jump_if_true_fork(iff_ge, mid->dest(), trim_ranges && cnt == 0);\n@@ -1493,1 +1479,1 @@\n-        jump_if_always_fork(lo->dest(), lo->table_index(), trim_ranges && lo->cnt() == 0);\n+        jump_if_always_fork(lo->dest(), trim_ranges && lo->cnt() == 0);\n@@ -1628,3 +1614,0 @@\n-  \/\/ Update method data\n-  profile_taken_branch(jsr_bci);\n-\n@@ -1652,1 +1635,0 @@\n-  profile_ret(target->flow()->start());\n@@ -1864,5 +1846,0 @@\n-    \/\/ We need to mark this branch as taken so that if we recompile we will\n-    \/\/ see that it is possible. In the tiered system the interpreter doesn't\n-    \/\/ do profiling and by the time we get to the lower tier from the interpreter\n-    \/\/ the path may be cold again. Make sure it doesn't look untaken\n-    profile_taken_branch(target_bci, !ProfileInterpreter);\n@@ -1902,2 +1879,0 @@\n-      \/\/ Update method data\n-      profile_taken_branch(target_bci);\n@@ -1922,2 +1897,0 @@\n-    \/\/ Update method data\n-    profile_not_taken_branch();\n@@ -1944,5 +1917,0 @@\n-    \/\/ We need to mark this branch as taken so that if we recompile we will\n-    \/\/ see that it is possible. In the tiered system the interpreter doesn't\n-    \/\/ do profiling and by the time we get to the lower tier from the interpreter\n-    \/\/ the path may be cold again. Make sure it doesn't look untaken\n-    profile_taken_branch(target_bci, !ProfileInterpreter);\n@@ -2023,2 +1991,0 @@\n-      \/\/ Update method data\n-      profile_taken_branch(target_bci);\n@@ -2050,2 +2016,0 @@\n-    \/\/ Update method data\n-    profile_not_taken_branch();\n@@ -3494,3 +3458,0 @@\n-    \/\/ Update method data\n-    profile_taken_branch(target_bci);\n-\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":37,"deletions":76,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -93,3 +93,0 @@\n-    if (!stopped()) {\n-      profile_null_checkcast();\n-    }\n@@ -414,284 +411,0 @@\n-\n-\/\/=============================================================================\n-\/\/\n-\/\/ parser methods for profiling\n-\n-\n-\/\/----------------------test_counter_against_threshold ------------------------\n-void Parse::test_counter_against_threshold(Node* cnt, int limit) {\n-  \/\/ Test the counter against the limit and uncommon trap if greater.\n-\n-  \/\/ This code is largely copied from the range check code in\n-  \/\/ array_addressing()\n-\n-  \/\/ Test invocation count vs threshold\n-  Node *threshold = makecon(TypeInt::make(limit));\n-  Node *chk   = _gvn.transform( new CmpUNode( cnt, threshold) );\n-  BoolTest::mask btest = BoolTest::lt;\n-  Node *tst   = _gvn.transform( new BoolNode( chk, btest) );\n-  \/\/ Branch to failure if threshold exceeded\n-  { BuildCutout unless(this, tst, PROB_ALWAYS);\n-    uncommon_trap(Deoptimization::Reason_age,\n-                  Deoptimization::Action_maybe_recompile);\n-  }\n-}\n-\n-\/\/----------------------increment_and_test_invocation_counter-------------------\n-void Parse::increment_and_test_invocation_counter(int limit) {\n-  if (!count_invocations()) return;\n-\n-  \/\/ Get the Method* node.\n-  ciMethod* m = method();\n-  MethodCounters* counters_adr = m->ensure_method_counters();\n-  if (counters_adr == NULL) {\n-    C->record_failure(\"method counters allocation failed\");\n-    return;\n-  }\n-\n-  Node* ctrl = control();\n-  const TypePtr* adr_type = TypeRawPtr::make((address) counters_adr);\n-  Node *counters_node = makecon(adr_type);\n-  Node* adr_iic_node = basic_plus_adr(counters_node, counters_node,\n-    MethodCounters::interpreter_invocation_counter_offset_in_bytes());\n-  Node* cnt = make_load(ctrl, adr_iic_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-\n-  test_counter_against_threshold(cnt, limit);\n-\n-  \/\/ Add one to the counter and store\n-  Node* incr = _gvn.transform(new AddINode(cnt, _gvn.intcon(1)));\n-  store_to_memory(ctrl, adr_iic_node, incr, T_INT, adr_type, MemNode::unordered);\n-}\n-\n-\/\/----------------------------method_data_addressing---------------------------\n-Node* Parse::method_data_addressing(ciMethodData* md, ciProfileData* data, ByteSize counter_offset, Node* idx, uint stride) {\n-  \/\/ Get offset within MethodData* of the data array\n-  ByteSize data_offset = MethodData::data_offset();\n-\n-  \/\/ Get cell offset of the ProfileData within data array\n-  int cell_offset = md->dp_to_di(data->dp());\n-\n-  \/\/ Add in counter_offset, the # of bytes into the ProfileData of counter or flag\n-  int offset = in_bytes(data_offset) + cell_offset + in_bytes(counter_offset);\n-\n-  const TypePtr* adr_type = TypeMetadataPtr::make(md);\n-  Node* mdo = makecon(adr_type);\n-  Node* ptr = basic_plus_adr(mdo, mdo, offset);\n-\n-  if (stride != 0) {\n-    Node* str = _gvn.MakeConX(stride);\n-    Node* scale = _gvn.transform( new MulXNode( idx, str ) );\n-    ptr   = _gvn.transform( new AddPNode( mdo, ptr, scale ) );\n-  }\n-\n-  return ptr;\n-}\n-\n-\/\/--------------------------increment_md_counter_at----------------------------\n-void Parse::increment_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize counter_offset, Node* idx, uint stride) {\n-  Node* adr_node = method_data_addressing(md, data, counter_offset, idx, stride);\n-\n-  const TypePtr* adr_type = _gvn.type(adr_node)->is_ptr();\n-  Node* cnt  = make_load(NULL, adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-  Node* incr = _gvn.transform(new AddINode(cnt, _gvn.intcon(DataLayout::counter_increment)));\n-  store_to_memory(NULL, adr_node, incr, T_INT, adr_type, MemNode::unordered);\n-}\n-\n-\/\/--------------------------test_for_osr_md_counter_at-------------------------\n-void Parse::test_for_osr_md_counter_at(ciMethodData* md, ciProfileData* data, ByteSize counter_offset, int limit) {\n-  Node* adr_node = method_data_addressing(md, data, counter_offset);\n-\n-  const TypePtr* adr_type = _gvn.type(adr_node)->is_ptr();\n-  Node* cnt  = make_load(NULL, adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-\n-  test_counter_against_threshold(cnt, limit);\n-}\n-\n-\/\/-------------------------------set_md_flag_at--------------------------------\n-void Parse::set_md_flag_at(ciMethodData* md, ciProfileData* data, int flag_constant) {\n-  Node* adr_node = method_data_addressing(md, data, DataLayout::flags_offset());\n-\n-  const TypePtr* adr_type = _gvn.type(adr_node)->is_ptr();\n-  Node* flags = make_load(NULL, adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-  Node* incr = _gvn.transform(new OrINode(flags, _gvn.intcon(flag_constant)));\n-  store_to_memory(NULL, adr_node, incr, T_INT, adr_type, MemNode::unordered);\n-}\n-\n-\/\/----------------------------profile_taken_branch-----------------------------\n-void Parse::profile_taken_branch(int target_bci, bool force_update) {\n-  \/\/ This is a potential osr_site if we have a backedge.\n-  int cur_bci = bci();\n-  bool osr_site =\n-    (target_bci <= cur_bci) && count_invocations() && UseOnStackReplacement;\n-\n-  \/\/ If we are going to OSR, restart at the target bytecode.\n-  set_bci(target_bci);\n-\n-  \/\/ To do: factor out the the limit calculations below. These duplicate\n-  \/\/ the similar limit calculations in the interpreter.\n-\n-  if (method_data_update() || force_update) {\n-    ciMethodData* md = method()->method_data();\n-    assert(md != NULL, \"expected valid ciMethodData\");\n-    ciProfileData* data = md->bci_to_data(cur_bci);\n-    assert(data != NULL && data->is_JumpData(), \"need JumpData for taken branch\");\n-    increment_md_counter_at(md, data, JumpData::taken_offset());\n-  }\n-\n-  \/\/ In the new tiered system this is all we need to do. In the old\n-  \/\/ (c2 based) tiered sytem we must do the code below.\n-#ifndef TIERED\n-  if (method_data_update()) {\n-    ciMethodData* md = method()->method_data();\n-    if (osr_site) {\n-      ciProfileData* data = md->bci_to_data(cur_bci);\n-      assert(data != NULL && data->is_JumpData(), \"need JumpData for taken branch\");\n-      int limit = (int)((int64_t)CompileThreshold\n-                   * (OnStackReplacePercentage - InterpreterProfilePercentage) \/ 100);\n-      test_for_osr_md_counter_at(md, data, JumpData::taken_offset(), limit);\n-    }\n-  } else {\n-    \/\/ With method data update off, use the invocation counter to trigger an\n-    \/\/ OSR compilation, as done in the interpreter.\n-    if (osr_site) {\n-      int limit = (int)((int64_t)CompileThreshold * OnStackReplacePercentage \/ 100);\n-      increment_and_test_invocation_counter(limit);\n-    }\n-  }\n-#endif \/\/ TIERED\n-\n-  \/\/ Restore the original bytecode.\n-  set_bci(cur_bci);\n-}\n-\n-\/\/--------------------------profile_not_taken_branch---------------------------\n-void Parse::profile_not_taken_branch(bool force_update) {\n-\n-  if (method_data_update() || force_update) {\n-    ciMethodData* md = method()->method_data();\n-    assert(md != NULL, \"expected valid ciMethodData\");\n-    ciProfileData* data = md->bci_to_data(bci());\n-    assert(data != NULL && data->is_BranchData(), \"need BranchData for not taken branch\");\n-    increment_md_counter_at(md, data, BranchData::not_taken_offset());\n-  }\n-\n-}\n-\n-\/\/---------------------------------profile_call--------------------------------\n-void Parse::profile_call(Node* receiver) {\n-  if (!method_data_update()) return;\n-\n-  switch (bc()) {\n-  case Bytecodes::_invokevirtual:\n-  case Bytecodes::_invokeinterface:\n-    profile_receiver_type(receiver);\n-    break;\n-  case Bytecodes::_invokestatic:\n-  case Bytecodes::_invokedynamic:\n-  case Bytecodes::_invokespecial:\n-    profile_generic_call();\n-    break;\n-  default: fatal(\"unexpected call bytecode\");\n-  }\n-}\n-\n-\/\/------------------------------profile_generic_call---------------------------\n-void Parse::profile_generic_call() {\n-  assert(method_data_update(), \"must be generating profile code\");\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for not taken branch\");\n-  increment_md_counter_at(md, data, CounterData::count_offset());\n-}\n-\n-\/\/-----------------------------profile_receiver_type---------------------------\n-void Parse::profile_receiver_type(Node* receiver) {\n-  assert(method_data_update(), \"must be generating profile code\");\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_ReceiverTypeData(), \"need ReceiverTypeData here\");\n-\n-  \/\/ Skip if we aren't tracking receivers\n-  if (TypeProfileWidth < 1) {\n-    increment_md_counter_at(md, data, CounterData::count_offset());\n-    return;\n-  }\n-  ciReceiverTypeData* rdata = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n-\n-  Node* method_data = method_data_addressing(md, rdata, in_ByteSize(0));\n-\n-  \/\/ Using an adr_type of TypePtr::BOTTOM to work around anti-dep problems.\n-  \/\/ A better solution might be to use TypeRawPtr::BOTTOM with RC_NARROW_MEM.\n-  make_runtime_call(RC_LEAF, OptoRuntime::profile_receiver_type_Type(),\n-                    CAST_FROM_FN_PTR(address,\n-                                     OptoRuntime::profile_receiver_type_C),\n-                    \"profile_receiver_type_C\",\n-                    TypePtr::BOTTOM,\n-                    method_data, receiver);\n-}\n-\n-\/\/---------------------------------profile_ret---------------------------------\n-void Parse::profile_ret(int target_bci) {\n-  if (!method_data_update()) return;\n-\n-  \/\/ Skip if we aren't tracking ret targets\n-  if (TypeProfileWidth < 1) return;\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_RetData(), \"need RetData for ret\");\n-  ciRetData* ret_data = (ciRetData*)data->as_RetData();\n-\n-  \/\/ Look for the target_bci is already in the table\n-  uint row;\n-  bool table_full = true;\n-  for (row = 0; row < ret_data->row_limit(); row++) {\n-    int key = ret_data->bci(row);\n-    table_full &= (key != RetData::no_bci);\n-    if (key == target_bci) break;\n-  }\n-\n-  if (row >= ret_data->row_limit()) {\n-    \/\/ The target_bci was not found in the table.\n-    if (!table_full) {\n-      \/\/ XXX: Make slow call to update RetData\n-    }\n-    return;\n-  }\n-\n-  \/\/ the target_bci is already in the table\n-  increment_md_counter_at(md, data, RetData::bci_count_offset(row));\n-}\n-\n-\/\/--------------------------profile_null_checkcast----------------------------\n-void Parse::profile_null_checkcast() {\n-  \/\/ Set the null-seen flag, done in conjunction with the usual null check. We\n-  \/\/ never unset the flag, so this is a one-way switch.\n-  if (!method_data_update()) return;\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_BitData(), \"need BitData for checkcast\");\n-  set_md_flag_at(md, data, BitData::null_seen_byte_constant());\n-}\n-\n-\/\/-----------------------------profile_switch_case-----------------------------\n-void Parse::profile_switch_case(int table_index) {\n-  if (!method_data_update()) return;\n-\n-  ciMethodData* md = method()->method_data();\n-  assert(md != NULL, \"expected valid ciMethodData\");\n-\n-  ciProfileData* data = md->bci_to_data(bci());\n-  assert(data != NULL && data->is_MultiBranchData(), \"need MultiBranchData for switch case\");\n-  if (table_index >= 0) {\n-    increment_md_counter_at(md, data, MultiBranchData::case_count_offset(table_index));\n-  } else {\n-    increment_md_counter_at(md, data, MultiBranchData::default_count_offset());\n-  }\n-}\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":0,"deletions":287,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -1219,54 +1219,0 @@\n-\/\/-------------- methodData update helpers\n-\n-const TypeFunc* OptoRuntime::profile_receiver_type_Type() {\n-  \/\/ create input type (domain)\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeAryPtr::NOTNULL;    \/\/ methodData pointer\n-  fields[TypeFunc::Parms+1] = TypeInstPtr::BOTTOM;    \/\/ receiver oop\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type\n-  fields = TypeTuple::fields(1);\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n-  return TypeFunc::make(domain, range);\n-}\n-\n-JRT_LEAF(void, OptoRuntime::profile_receiver_type_C(DataLayout* data, oopDesc* receiver))\n-  if (receiver == NULL) return;\n-  Klass* receiver_klass = receiver->klass();\n-\n-  intptr_t* mdp = ((intptr_t*)(data)) + DataLayout::header_size_in_cells();\n-  int empty_row = -1;           \/\/ free row, if any is encountered\n-\n-  \/\/ ReceiverTypeData* vc = new ReceiverTypeData(mdp);\n-  for (uint row = 0; row < ReceiverTypeData::row_limit(); row++) {\n-    \/\/ if (vc->receiver(row) == receiver_klass)\n-    int receiver_off = ReceiverTypeData::receiver_cell_index(row);\n-    intptr_t row_recv = *(mdp + receiver_off);\n-    if (row_recv == (intptr_t) receiver_klass) {\n-      \/\/ vc->set_receiver_count(row, vc->receiver_count(row) + DataLayout::counter_increment);\n-      int count_off = ReceiverTypeData::receiver_count_cell_index(row);\n-      *(mdp + count_off) += DataLayout::counter_increment;\n-      return;\n-    } else if (row_recv == 0) {\n-      \/\/ else if (vc->receiver(row) == NULL)\n-      empty_row = (int) row;\n-    }\n-  }\n-\n-  if (empty_row != -1) {\n-    int receiver_off = ReceiverTypeData::receiver_cell_index(empty_row);\n-    \/\/ vc->set_receiver(empty_row, receiver_klass);\n-    *(mdp + receiver_off) = (intptr_t) receiver_klass;\n-    \/\/ vc->set_receiver_count(empty_row, DataLayout::counter_increment);\n-    int count_off = ReceiverTypeData::receiver_count_cell_index(empty_row);\n-    *(mdp + count_off) = DataLayout::counter_increment;\n-  } else {\n-    \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n-    \/\/ Increment total counter to indicate polymorphic case.\n-    intptr_t* count_p = (intptr_t*)(((uint8_t*)(data)) + in_bytes(CounterData::count_offset()));\n-    *count_p += DataLayout::counter_increment;\n-  }\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -232,3 +232,0 @@\n-  \/\/ Leaf routines helping with method data update\n-  static void profile_receiver_type_C(DataLayout* data, oopDesc* receiver);\n-\n@@ -307,3 +304,0 @@\n-  \/\/ leaf methodData routine types\n-  static const TypeFunc* profile_receiver_type_Type();\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2561,1 +2561,1 @@\n-    : BasicHashtable<mtCode>(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }\n+    : BasicHashtable<mtCode>(293, (sizeof(AdapterHandlerEntry))) { }\n@@ -2570,3 +2570,0 @@\n-    if (DumpSharedSpaces) {\n-      ((CDSAdapterHandlerEntry*)entry)->init();\n-    }\n@@ -3442,13 +3439,0 @@\n-#if INCLUDE_CDS\n-\n-void CDSAdapterHandlerEntry::init() {\n-  assert(DumpSharedSpaces, \"used during dump time only\");\n-  _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());\n-  _c2i_inline_ro_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());\n-  _c2i_inline_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());\n-  _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));\n-};\n-\n-#endif \/\/ INCLUDE_CDS\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -734,18 +734,0 @@\n-\/\/ This class is used only with DumpSharedSpaces==true. It holds extra information\n-\/\/ that's used only during CDS dump time.\n-\/\/ For details, see comments around Method::link_method()\n-class CDSAdapterHandlerEntry: public AdapterHandlerEntry {\n-  address               _c2i_entry_trampoline;           \/\/ allocated from shared spaces \"MC\" region\n-  address               _c2i_inline_ro_entry_trampoline; \/\/ allocated from shared spaces \"MC\" region\n-  address               _c2i_inline_entry_trampoline;    \/\/ allocated from shared spaces \"MC\" region\n-  AdapterHandlerEntry** _adapter_trampoline;             \/\/ allocated from shared spaces \"MD\" region\n-\n-public:\n-  address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }\n-  address get_c2i_inline_ro_entry_trampoline()   const { return _c2i_inline_ro_entry_trampoline; }\n-  address get_c2i_inline_entry_trampoline()      const { return _c2i_inline_entry_trampoline; }\n-  AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }\n-  void init() NOT_CDS_RETURN;\n-};\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -898,0 +898,1 @@\n+char java_version[64] = \"\";\n@@ -903,0 +904,22 @@\n+\/\/ extract the JRE version string from java.lang.VersionProps.java_version\n+static const char* get_java_version(TRAPS) {\n+  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n+                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+  fieldDescriptor fd;\n+  bool found = k != NULL &&\n+               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_version_name(),\n+                                                        vmSymbols::string_signature(), &fd);\n+  if (found) {\n+    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    if (name_oop == NULL) {\n+      return NULL;\n+    }\n+    const char* name = java_lang_String::as_utf8_string(name_oop,\n+                                                        java_version,\n+                                                        sizeof(java_version));\n+    return name;\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n@@ -3387,0 +3410,1 @@\n+  JDK_Version::set_java_version(get_java_version(THREAD));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2531,7 +2531,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -2574,1 +2567,1 @@\n-     * @since 14\n+     * @since 16\n@@ -2576,3 +2569,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n-    @SuppressWarnings(\"preview\")\n@@ -3875,7 +3865,0 @@\n-     * {@preview Associated with records, a preview feature of the Java language.\n-     *\n-     *           This method is associated with <i>records<\/i>, a preview\n-     *           feature of the Java language. Preview features\n-     *           may be removed in a future release, or upgraded to permanent\n-     *           features of the Java language.}\n-     *\n@@ -3894,1 +3877,1 @@\n-     * @since 14\n+     * @since 16\n@@ -3896,2 +3879,0 @@\n-    @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                 essentialAPI=false)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-    private static final AtomicInteger counter = new AtomicInteger(0);\n+    private static final AtomicInteger counter = new AtomicInteger();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,0 +272,2 @@\n+    exports sun.nio.fs to\n+        jdk.net;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -657,9 +657,1 @@\n-         * {@preview Associated with records, a preview feature of the Java language.\n-         *\n-         *           This enum constant is associated with <i>records<\/i>, a preview\n-         *           feature of the Java language. Preview features\n-         *           may be removed in a future release, or upgraded to permanent\n-         *           features of the Java language.}\n-         *\n-         *\n-         * @since 14\n+         * @since 16\n@@ -668,2 +660,0 @@\n-        @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,\n-                                     essentialAPI=false)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -163,2 +163,1 @@\n-        allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &&\n-                Feature.RECORDS.allowedInSource(source);\n+        allowRecords = Feature.RECORDS.allowedInSource(source);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,2 +153,1 @@\n-        allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &&\n-                Feature.RECORDS.allowedInSource(source);\n+        allowRecords = Feature.RECORDS.allowedInSource(source);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -284,2 +284,1 @@\n-        allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &&\n-                Feature.RECORDS.allowedInSource(source);\n+        allowRecords = Feature.RECORDS.allowedInSource(source);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -191,2 +191,1 @@\n-        this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &&\n-                Feature.RECORDS.allowedInSource(source);\n+        this.allowRecords = Feature.RECORDS.allowedInSource(source);\n@@ -3852,1 +3851,1 @@\n-            if (token.kind == IDENTIFIER && token.name() == names.record && preview.isEnabled()) {\n+            if (token.kind == IDENTIFIER && token.name() == names.record) {\n@@ -4349,1 +4348,1 @@\n-             checkSourceLevel(Feature.RECORDS);\n+            checkSourceLevel(Feature.RECORDS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+ -runtime\/Thread\/ThreadCountLimit.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}