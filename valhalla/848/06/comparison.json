{"files":[{"patch":"@@ -277,1 +277,1 @@\n-  $1_FLAGS += $$($1_JAVAC_FLAGS)\n+  $1_FLAGS += $$($1_JAVAC_FLAGS) -XDenablePrimitiveClasses\n","filename":"make\/common\/JavaCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3147,0 +3147,16 @@\n+void Assembler::vmovw(XMMRegister dst, Register src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6E, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovw(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x7E, (0xC0 | encode));\n+}\n+\n@@ -7314,0 +7330,16 @@\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n@@ -11483,1 +11515,1 @@\n-  \/\/ of form {0F, 0F_38, 0F_3A}\n+  \/\/ of form {0F, 0F_38, 0F_3A, MAP5}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -550,0 +550,1 @@\n+    VEX_OPCODE_MAP5  = 0x5,\n@@ -1652,0 +1653,3 @@\n+  void vmovw(XMMRegister dst, Register src);\n+  void vmovw(Register dst, XMMRegister src);\n+\n@@ -2397,0 +2401,2 @@\n+  void evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -952,0 +952,1 @@\n+    _features &= ~CPU_AVX512_FP16;\n@@ -985,0 +986,1 @@\n+      _features &= ~CPU_AVX512_FP16;\n@@ -3020,0 +3022,3 @@\n+\n+    if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)\n+      result |= CPU_AVX512_FP16;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -278,1 +278,3 @@\n-                           : 11;\n+                           : 2,\n+              avx512_fp16  : 1,\n+                           : 8;\n@@ -393,1 +395,2 @@\n-    decl(AVX512_IFMA,       \"avx512_ifma\",       58) \/* Integer Vector FMA instructions*\/\n+    decl(AVX512_IFMA,       \"avx512_ifma\",       58) \/* Integer Vector FMA instructions*\/ \\\n+    decl(AVX512_FP16,       \"avx512_fp16\",       59) \/* AVX512 FP16 ISA support*\/\n@@ -699,0 +702,1 @@\n+  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1454,0 +1454,7 @@\n+    case Op_AddHF:\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -1725,0 +1732,5 @@\n+    case Op_AddVHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -10152,0 +10164,9 @@\n+instruct reinterpretS2H (regF dst, rRegI src)\n+%{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -10153,0 +10174,31 @@\n+instruct reinterpretH2S (rRegI dst, regF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$Register, $src$$XMMRegister);\n+    __ movswl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct addFP16_scalar (regF dst, regF src1, regF src2)\n+%{\n+  match(Set dst (AddHF src1 src2));\n+  format %{ \"vaddsh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ evaddsh($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddVHF (vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (AddVHF src1 src2));\n+  format %{ \"vaddph $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evaddph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -4204,1 +4204,1 @@\n-    \"AddVB\",\"AddVS\",\"AddVI\",\"AddVL\",\"AddVF\",\"AddVD\",\n+    \"AddVB\",\"AddVHF\", \"AddVS\",\"AddVI\",\"AddVL\",\"AddVF\",\"AddVD\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4698,0 +4698,16 @@\n+\/\/ utility function to skip over internal jdk primitive classes used to override the need for passing\n+\/\/ an explict JVM flag EnablePrimitiveClasses.\n+bool ClassFileParser::is_jdk_internal_class(const Symbol* class_name) const {\n+  if (vmSymbols::java_lang_Float16() == class_name) {\n+    return (EnablePrimitiveClasses = true);\n+  }\n+  return false;\n+}\n+\n+bool ClassFileParser::is_jdk_internal_class_sig(const char* sig) const {\n+  if (strstr(sig, vmSymbols::java_lang_Float16_signature()->as_C_string())) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -4728,1 +4744,1 @@\n-  if (is_primitive_class && !EnablePrimitiveClasses) {\n+  if (is_primitive_class && !is_jdk_internal_class(_class_name) && !EnablePrimitiveClasses) {\n@@ -5160,1 +5176,1 @@\n-      if ( (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) || (!EnablePrimitiveClasses)) {\n+      if ( (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) || (!EnablePrimitiveClasses && !is_jdk_internal_class_sig(signature))) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -220,0 +220,4 @@\n+  bool is_jdk_internal_class(const Symbol* class_name) const;\n+\n+  bool is_jdk_internal_class_sig(const char* sig) const;\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+  do_klass(Float16_klass,                               java_lang_Float16                                     ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,0 +198,6 @@\n+                                                                                                                        \\\n+  \/* Float16 intrinsics, similar to what we have in Math. *\/                                                            \\\n+  do_intrinsic(_sum_float16,              java_lang_Float16,      sum_name,           floa16_float16_signature,  F_S)   \\\n+   do_name(sum_name, \"sum\")                                                                                             \\\n+   do_signature(floa16_float16_signature, \"(Qjava\/lang\/Float16;Qjava\/lang\/Float16;)Qjava\/lang\/Float16;\")                \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  template(java_lang_Float16,                         \"java\/lang\/Float16\")                        \\\n+  template(java_lang_Float16_signature,               \"Qjava\/lang\/Float16;\")                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -545,0 +545,3 @@\n+  if (vmSymbols::java_lang_Float16() == name()) {\n+    EnablePrimitiveClasses = true;\n+  }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-\/\/ Add 2 floats\n+\/\/ Add 2 half-precision floats\n@@ -134,0 +134,8 @@\n+\/\/------------------------------AddHFNode---------------------------------------\n+\/\/ Add 2 floats\n+class AddHFNode : public AddFNode {\n+public:\n+  AddHFNode( Node *in1, Node *in2 ) : AddFNode(in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -752,1 +752,3 @@\n-\n+  case vmIntrinsics::_sum_float16:\n+    if (!Matcher::match_rule_supported(Op_AddHF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+macro(AddHF)\n@@ -376,0 +377,1 @@\n+macro(AddVHF)\n@@ -489,0 +491,2 @@\n+macro(ReinterpretS2HF)\n+macro(ReinterpretHF2S)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -856,0 +856,32 @@\n+\n+const Type* ReinterpretS2HFNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type( in(1) );\n+  \/\/ Convert FP16 constant value to Float constant value, this will allow\n+  \/\/ further constant folding to be done at float granularity by value routines\n+  \/\/ of FP16 IR nodes.\n+  if (type->isa_int() && type->is_int()->is_con()) {\n+     jshort hfval = type->is_int()->get_con();\n+     jfloat fval = StubRoutines::hf2f(hfval);\n+     return TypeF::make(fval);\n+  }\n+  return Type::FLOAT;\n+}\n+\n+Node* ReinterpretS2HFNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReinterpretHF2S) {\n+     assert(in(1)->in(1)->bottom_type()->isa_float(), \"\");\n+     return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+const Type* ReinterpretHF2SNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type( in(1) );\n+  \/\/ Convert Float constant value to FP16 constant value.\n+  if (type->isa_float_constant()) {\n+     jfloat fval = type->is_float_constant()->_f;\n+     jshort hfval = StubRoutines::f2hf(fval);\n+     return TypeInt::make(hfval);\n+  }\n+  return TypeInt::SHORT;\n+}\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -176,0 +176,19 @@\n+class ReinterpretS2HFNode : public Node {\n+  public:\n+  ReinterpretS2HFNode(Node* in1) : Node(0, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n+class ReinterpretHF2SNode : public Node {\n+  public:\n+  ReinterpretHF2SNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::SHORT; }\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,3 +53,0 @@\n-  \/\/ Get the klass defining the field layout of the inline type\n-  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n-\n@@ -80,0 +77,3 @@\n+  \/\/ Get the klass defining the field layout of the inline type\n+  ciInlineKlass* inline_klass() const { return type()->inline_klass(); }\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -547,0 +547,2 @@\n+  case vmIntrinsics::_sum_float16:              return inline_fp16_operations(intrinsic_id());\n+\n@@ -4897,0 +4899,28 @@\n+bool LibraryCallKit::inline_fp16_operations(vmIntrinsics::ID id) {\n+  if (!Matcher::match_rule_supported(Op_ReinterpretS2HF) ||\n+      !Matcher::match_rule_supported(Op_ReinterpretHF2S)) {\n+    return false;\n+  }\n+\n+  Node* result = nullptr;\n+  Node* val1 = argument(0);  \/\/ receiver\n+  Node* val2 = argument(1);  \/\/ argument\n+  assert(val1->is_InlineType() && val2->is_InlineType(), \"\");\n+\n+  Node* fld1 = _gvn.transform(new ReinterpretS2HFNode(val1->as_InlineType()->field_value(0)));\n+  Node* fld2 = _gvn.transform(new ReinterpretS2HFNode(val2->as_InlineType()->field_value(0)));\n+\n+  switch (id) {\n+  case vmIntrinsics::_sum_float16:   result = _gvn.transform(new AddHFNode(fld1, fld2)); break;\n+\n+  default:\n+    fatal_unexpected_iid(id);\n+    break;\n+  }\n+  InlineTypeNode* box = InlineTypeNode::make_uninitialized(_gvn, val1->as_InlineType()->inline_klass(), true);\n+  Node* short_result  = _gvn.transform(new ReinterpretHF2SNode(result));\n+  box->set_field_value(0, short_result);\n+  set_result(_gvn.transform(box));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -306,0 +306,1 @@\n+  bool inline_fp16_operations(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2906,0 +2906,7 @@\n+      } else if (opc == Op_ReinterpretS2HF || opc == Op_ReinterpretHF2S) {\n+        assert(n->req() == 2, \"only one input expected\");\n+        BasicType bt = velt_basic_type(n);\n+        const TypeVect* vt = TypeVect::make(bt, vlen);\n+        Node* in = vector_opd(p, 1);\n+        vn = VectorReinterpretNode::make(in, vt, vt);\n+        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n@@ -3761,0 +3768,3 @@\n+  if (VectorNode::is_float16_node(n->Opcode())) {\n+    return TypeInt::SHORT;\n+  }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  case Op_AddHF: return (bt == T_SHORT ? Op_AddVHF : 0);\n@@ -270,0 +271,3 @@\n+  case Op_ReinterpretS2HF:\n+  case Op_ReinterpretHF2S:\n+    return Op_VectorReinterpret;\n@@ -608,0 +612,10 @@\n+bool VectorNode::is_float16_node(int opc) {\n+  switch (opc) {\n+  case Op_AddHF:\n+  case Op_ReinterpretS2HF:\n+     return true;\n+  default:\n+     return false;\n+  }\n+}\n+\n@@ -677,1 +691,1 @@\n-  case Op_AddI: case Op_AddL: case Op_AddF: case Op_AddD:\n+  case Op_AddI: case Op_AddHF: case Op_AddL: case Op_AddF: case Op_AddD:\n@@ -735,0 +749,1 @@\n+  case Op_AddVHF: return new AddVHFNode(n1, n2, vt);\n@@ -1736,0 +1751,4 @@\n+VectorNode* VectorReinterpretNode::make(Node* n, const TypeVect* dst_vt, const TypeVect* src_vt) {\n+  return new VectorReinterpretNode(n, dst_vt, src_vt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -109,0 +109,2 @@\n+  static bool is_float16_node(int opc);\n+\n@@ -189,0 +191,8 @@\n+\/\/------------------------------AddVHFNode--------------------------------------\n+\/\/ Vector add float\n+class AddVHFNode : public VectorNode {\n+public:\n+  AddVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -1547,0 +1557,2 @@\n+\n+  static VectorNode* make(Node* n, const TypeVect* dst_vt, const TypeVect* src_vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1408,0 +1408,1 @@\n+  declare_c2_type(AddHFNode, AddNode)                                     \\\n@@ -1426,0 +1427,2 @@\n+  declare_c2_type(ReinterpretS2HFNode, Node)                              \\\n+  declare_c2_type(ReinterpretHF2SNode, Node)                              \\\n@@ -1683,0 +1686,1 @@\n+  declare_c2_type(AddVHFNode, VectorNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.constant.Constable;\n+import java.lang.constant.ConstantDesc;\n+import java.util.Optional;\n+\n+import jdk.internal.math.FloatConsts;\n+import jdk.internal.math.FloatingDecimal;\n+import jdk.internal.math.FloatToDecimal;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/**\n+ * The {@code Float16} is a primitive value class holding 16-bit data in IEEE 754 binary16 format\n+ * {@code Float16} contains a single field whose type is {@code short}.\n+ *\n+ * Binary16 Format:\n+ *   S EEEEE  MMMMMMMMMM\n+ *   Sign        - 1 bit\n+ *   Exponent    - 5 bits\n+ *   Significand - 10 bits\n+ *\n+ * <p>This is a <a href=\"https:\/\/openjdk.org\/jeps\/401\">primitive value class<\/a> and its objects are\n+ * identity-less non-nullable value objects.\n+ *\n+ * @author Jatin Bhateja\n+ * @since 20.00\n+ *\/\n+\n+\/\/ Currently Float16 is a primitive class but in future will be aligned with\n+\/\/ Enhanced Primitive Boxes described by JEP-402 (https:\/\/openjdk.org\/jeps\/402)\n+public primitive class Float16 extends Number {\n+    private final short value;\n+\n+   \/**\n+    * Returns a {@code Float16} instance wrapping IEEE 754 binary16\n+    * encoded {@code short} value.\n+    *\n+    * @param  value a short value.\n+    * @since  20\n+    *\/\n+    private Float16 (short value ) {\n+        this.value = value;\n+    }\n+\n+   \/**\n+    * Returns a {@code Float16} instance wrapping IEEE 754 binary16\n+    * encoded {@code short} value.\n+    *\n+    * @param  value a short value.\n+    * @return a {@code Float16} instance representing {@code value}.\n+    * @since  20\n+    *\/\n+    public static Float16 valueOf(short value) {\n+       return new Float16(value);\n+    }\n+\n+    \/**\n+     * Returns the value of this {@code Float16} as a {@code byte} after\n+     * a narrowing primitive conversion.\n+     *\n+     * @return  the binary16 encoded {@code short} value represented by this object\n+     *          converted to type {@code byte}\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    public byte byteValue() {\n+        return (byte)Float.float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * Returns the value of this {@code Float16} as a {@code short}\n+     * after a narrowing primitive conversion.\n+     *\n+     * @return  the binary16 encoded {@code short} value represented by this object\n+     *          converted to type {@code short}\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     * @since 1.1\n+     *\/\n+    public short shortValue() {\n+        return (short)Float.float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * Returns the value of this {@code Float16} as an {@code int} after\n+     * a widening primitive conversion.\n+     *\n+     * @return  the binary16 encoded {@code short} value represented by this object\n+     *          converted to type {@code int}\n+     * @jls 5.1.3 Widening Primitive Conversion\n+     *\/\n+    public int intValue() {\n+        return (int)Float.float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * Returns value of this {@code Float16} as a {@code long} after a\n+     * widening conversion.\n+     *\n+     * @return  the binary16 encoded {@code short} value represented by this object\n+     *          converted to type {@code long}\n+     * @jls 5.1.3 Widening Primitive Conversion\n+     *\/\n+    public long longValue() {\n+        return (long)Float.float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * Returns the {@code float} value of this {@code Float16} object.\n+     *\n+     * @return the binary16 encoded {@code short} value represented by this object\n+     *         converted to type {@code float}\n+     *\/\n+    public float floatValue() {\n+        return Float.float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * Returns the value of this {@code Float16} as a {@code double}\n+     * after a widening primitive conversion.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @return the binary16 encoded {@code short} value represented by this\n+     *         object converted to type {@code double}\n+     * @jls 5.1.2 Widening Primitive Conversion\n+     *\/\n+    public double doubleValue() {\n+        return (double)Float.float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * Adds two {@code Float16} values together as per the + operator semantics.\n+     *\n+     * @apiNote This method corresponds to the addition operation\n+     * defined in IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the sum of {@code a} and {@code b}\n+     * @since 20\n+     *\/\n+    @IntrinsicCandidate\n+    public static Float16 sum(Float16 a, Float16 b) {\n+       return Float16.valueOf(Float.floatToFloat16(Float.float16ToFloat(a.float16ToRawShortBits()) + Float.float16ToFloat(b.float16ToRawShortBits())));\n+    }\n+\n+    \/**\n+     * Return raw short value.\n+     * @return raw binary16 encoded {@code short} value represented by this object.\n+     * @since 20\n+     *\/\n+    public short float16ToRawShortBits() { return value; }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -235,0 +235,1 @@\n+        AVX512_FP16,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug     8308363\n+* @summary Validate compiler IR for FP16 scalar operations.\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @compile -XDenablePrimitiveClasses TestFP16ScalarAdd.java\n+* @run driver compiler.vectorization.TestFP16ScalarAdd\n+*\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+\n+public class TestFP16ScalarAdd {\n+    private static final int count = 1024;\n+\n+    private short[] src;\n+    private short[] dst;\n+    private short res;\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestFP16ScalarAdd.class);\n+    }\n+\n+    public TestFP16ScalarAdd() {\n+        src = new short[count];\n+        dst = new short[count];\n+        for (int i = 0; i < count; i++) {\n+            src[i] = Float.floatToFloat16(i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"avx512_fp16\", \"true\"}, counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"})\n+    public void test1() {\n+        Float16 res = Float16.valueOf((short)0);\n+        for (int i = 0; i < count; i++) {\n+            res = Float16.sum(res, Float16.valueOf(src[i]));\n+            dst[i] = res.float16ToRawShortBits();\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"avx512_fp16\", \"true\"}, failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S})\n+    public void test2() {\n+        Float16 hf0 = Float16.valueOf((short)0);\n+        Float16 hf1 = Float16.valueOf((short)15360);\n+        Float16 hf2 = Float16.valueOf((short)16384);\n+        Float16 hf3 = Float16.valueOf((short)16896);\n+        Float16 hf4 = Float16.valueOf((short)17408);\n+        res = Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4).float16ToRawShortBits();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestFP16ScalarAdd.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -154,0 +154,5 @@\n+    public static final String ADD_HF = PREFIX + \"ADD_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_HF, \"AddHF\");\n+    }\n+\n@@ -174,0 +179,5 @@\n+    public static final String ADD_VHF = PREFIX + \"ADD_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VHF, \"AddVHF\");\n+    }\n+\n@@ -896,0 +906,10 @@\n+    public static final String REINTERPRET_S2HF = PREFIX + \"REINTERPRET_S2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_S2HF, \"ReinterpretS2HF\");\n+    }\n+\n+    public static final String REINTERPRET_HF2S = PREFIX + \"REINTERPRET_HF2S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_HF2S, \"ReinterpretHF2S\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+        \"avx512_fp16\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test vectorization of Float16.sum operation.\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @compile -XDenablePrimitiveClasses TestFloat16VectorSum.java\n+* @run driver compiler.vectorization.TestFloat16VectorSum\n+*\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+\n+\n+public class TestFloat16VectorSum {\n+    private Float16[] input;\n+    private Float16[] output;\n+    private static final int LEN = 2048;\n+    private Random rng;\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestFloat16VectorSum.class);\n+    }\n+\n+    public TestFloat16VectorSum() {\n+        input  = new Float16[LEN];\n+        output = new Float16[LEN];\n+        rng = new Random(42);\n+        for (int i = 0; i < LEN; ++i) {\n+            input[i] = Float16.valueOf(Float.floatToFloat16(rng.nextFloat()));\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(applyIfCPUFeature = {\"avx512_fp16\" , \"true\"}, counts = {IRNode.ADD_VHF, \" >= 1\"})\n+    public void vectorSumFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Float16.sum(input[i], input[i]);\n+        }\n+        checkResult();\n+    }\n+\n+    public void checkResult() {\n+        for (int i = 0; i < LEN; ++i) {\n+            Float16 expected = Float16.sum(input[i], input[i]);\n+            if (output[i].float16ToRawShortBits() != expected.float16ToRawShortBits()) {\n+                throw new RuntimeException(\"Invalid result: output[\" + i + \"] = \" + output[i].float16ToRawShortBits() + \" != \" + expected.float16ToRawShortBits());\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorSum.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8308363\n+ * @summary Test FP16 reduction operations.\n+ * @compile -XDenablePrimitiveClasses FP16ReductionOperations.java\n+ * @run main\/othervm -XX:+EnablePrimitiveClasses -XX:-TieredCompilation -Xbatch FP16ReductionOperations\n+ *\/\n+\n+import java.util.Random;\n+\n+public class FP16ReductionOperations {\n+\n+    public static Random r = new Random(1024);\n+\n+    public static short test_reduction_add_constants() {\n+        Float16 hf0 = Float16.valueOf((short)0);\n+        Float16 hf1 = Float16.valueOf((short)15360);\n+        Float16 hf2 = Float16.valueOf((short)16384);\n+        Float16 hf3 = Float16.valueOf((short)16896);\n+        Float16 hf4 = Float16.valueOf((short)17408);\n+        return Float16.sum(Float16.sum(Float16.sum(Float16.sum(hf0, hf1), hf2), hf3), hf4).float16ToRawShortBits();\n+    }\n+\n+    public static short expected_reduction_add_constants() {\n+        Float16 hf0 = Float16.valueOf((short)0);\n+        Float16 hf1 = Float16.valueOf((short)15360);\n+        Float16 hf2 = Float16.valueOf((short)16384);\n+        Float16 hf3 = Float16.valueOf((short)16896);\n+        Float16 hf4 = Float16.valueOf((short)17408);\n+        return Float.floatToFloat16(Float.float16ToFloat(hf0.float16ToRawShortBits()) +\n+                                    Float.float16ToFloat(hf1.float16ToRawShortBits()) +\n+                                    Float.float16ToFloat(hf2.float16ToRawShortBits()) +\n+                                    Float.float16ToFloat(hf3.float16ToRawShortBits()) +\n+                                    Float.float16ToFloat(hf4.float16ToRawShortBits()));\n+    }\n+\n+    public static void test_reduction_constants(char oper) {\n+        short actual = 0;\n+        short expected = 0;\n+        switch(oper) {\n+            case '+' ->  {\n+                             actual = test_reduction_add_constants();\n+                             expected = expected_reduction_add_constants();\n+                         }\n+            default  ->  throw new AssertionError(\"Unsupported Operation.\");\n+        }\n+        if (actual != expected) {\n+            throw new AssertionError(\"Result mismatch!, expected = \" + expected + \" actual = \" + actual);\n+        }\n+    }\n+\n+    public static short test_reduction_add(short [] arr) {\n+        Float16 res = Float16.valueOf((short)0);\n+        for (int i = 0; i < arr.length; i++) {\n+            res = Float16.sum(res, Float16.valueOf(arr[i]));\n+        }\n+        return res.float16ToRawShortBits();\n+    }\n+\n+    public static short expected_reduction_add(short [] arr) {\n+        short res = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(arr[i]));\n+        }\n+        return res;\n+    }\n+\n+    public static void test_reduction(char oper, short [] arr) {\n+        short actual = 0;\n+        short expected = 0;\n+        switch(oper) {\n+            case '+' ->  {\n+                             actual = test_reduction_add(arr);\n+                             expected = expected_reduction_add(arr);\n+                         }\n+            default  ->  throw new AssertionError(\"Unsupported Operation.\");\n+        }\n+        if (actual != expected) {\n+            throw new AssertionError(\"Result mismatch!, expected = \" + expected + \" actual = \" + actual);\n+        }\n+    }\n+\n+    public static short [] get_fp16_array(int size) {\n+        short [] arr = new short[size];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = Float.floatToFloat16(r.nextFloat());\n+        }\n+        return arr;\n+    }\n+\n+    public static void main(String [] args) {\n+        int res = 0;\n+        short [] input = get_fp16_array(1024);\n+        short [] special_values = {\n+              32256,          \/\/ NAN\n+              31744,          \/\/ +Inf\n+              (short)-1024,   \/\/ -Inf\n+              0,              \/\/ +0.0\n+              (short)-32768,  \/\/ -0.0\n+        };\n+        for (int i = 0;  i < 1000; i++) {\n+            test_reduction('+', input);\n+            test_reduction('+', special_values);\n+            test_reduction_constants('+');\n+        }\n+        System.out.println(\"PASS\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ReductionOperations.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8308363\n+ * @summary Initial compiler support for Float16.add operation.\n+ * @compile -XDenablePrimitiveClasses FP16ScalarOperations.java\n+ * @run main\/othervm -XX:+EnablePrimitiveClasses -XX:-TieredCompilation -Xbatch FP16ScalarOperations\n+ *\/\n+\n+import java.util.Random;\n+\n+public class FP16ScalarOperations {\n+\n+    public static Random r = new Random(1024);\n+\n+    public static short actual_value(char oper, short val1, short val2) {\n+        Float16 obj1 = Float16.valueOf(val1);\n+        Float16 obj2 = Float16.valueOf(val2);\n+        switch ((int)oper) {\n+            case '+' : return Float16.sum(obj1, obj2).float16ToRawShortBits();\n+            default  : throw new AssertionError(\"Unsupported Operation!\");\n+        }\n+    }\n+\n+    public static void test_add(short [] arr1, short arr2[]) {\n+        for (int i = 0; i < arr1.length; i++) {\n+            validate('+', arr1[i], arr2[i]);\n+        }\n+    }\n+\n+    public static short expected_value(char oper, short input1, short input2) {\n+        switch((int)oper) {\n+            case '+' : return Float.floatToFloat16(Float.float16ToFloat(input1) + Float.float16ToFloat(input2));\n+            default  : throw new AssertionError(\"Unsupported Operation!\");\n+        }\n+    }\n+    public static void validate(char oper, short input1, short input2) {\n+        short actual = actual_value(oper, input1, input2);\n+        short expected = expected_value(oper, input1, input2);\n+        if (actual != expected) {\n+            throw new AssertionError(\"Test Failed: \" + input1 + \" + \" + input2 + \" : \" + actual + \" != \" + expected);\n+        }\n+    }\n+\n+    public static short [] get_fp16_array(int size) {\n+        short [] arr = new short[size];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = Float.floatToFloat16(r.nextFloat());\n+        }\n+        return arr;\n+    }\n+\n+    public static void main(String [] args) {\n+        int res = 0;\n+        short [] input1 = get_fp16_array(1024);\n+        short [] input2 = get_fp16_array(1024);\n+        short [] special_values = {\n+              32256,          \/\/ NAN\n+              31744,          \/\/ +Inf\n+              (short)-1024,   \/\/ -Inf\n+              0,              \/\/ +0.0\n+              (short)-32768,  \/\/ -0.0\n+        };\n+        for (int i = 0;  i < 1000; i++) {\n+            test_add(input1, input2);\n+            test_add(special_values, special_values);\n+        }\n+        System.out.println(\"PASS\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ScalarOperations.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}