{"files":[{"patch":"@@ -38,1 +38,1 @@\n-                             : unsafe.getReference(obj, fieldOffset);\n+                             : unsafe.getReference(obj, fieldOffset, field.getType());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeObjectFieldAccessorImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-                             : unsafe.getReferenceVolatile(obj, fieldOffset);\n+                             : unsafe.getReferenceVolatile(obj, fieldOffset, field.getType());\n@@ -86,1 +86,1 @@\n-        unsafe.putReferenceVolatile(obj, fieldOffset, value);\n+            unsafe.putReferenceVolatile(obj, fieldOffset, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeQualifiedObjectFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-                             : unsafe.getReferenceVolatile(base, fieldOffset);\n+                             : unsafe.getReferenceVolatile(base, fieldOffset, field.getType());\n@@ -84,1 +84,1 @@\n-        unsafe.putReferenceVolatile(base, fieldOffset, value);\n+            unsafe.putReferenceVolatile(base, fieldOffset, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeQualifiedStaticObjectFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-                             : unsafe.getReference(base, fieldOffset);\n+                             : unsafe.getReference(base, fieldOffset, field.getType());\n@@ -82,1 +82,1 @@\n-        unsafe.putReference(base, fieldOffset, value);\n+            unsafe.putReference(base, fieldOffset, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeStaticObjectFieldAccessorImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @compile --enable-preview --source ${jdk.version} UninitializedInlineValueTest.java\n+ * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=128 UninitializedInlineValueTest\n+ * @run testng\/othervm --enable-preview -XX:InlineFieldMaxFlatSize=0 UninitializedInlineValueTest\n+ * @summary Test reflection and method handle on accessing a field of inline type\n+ *          that may be flattened or non-flattened\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class UninitializedInlineValueTest {\n+    static inline class EmptyInline {\n+        public boolean isEmpty() {\n+            return true;\n+        }\n+    }\n+\n+    static inline class InlineValue {\n+        Object o;\n+        EmptyInline empty;\n+        InlineValue() {\n+            this.o = null;\n+            this.empty = new EmptyInline();\n+        }\n+    }\n+\n+    static class MutableValue {\n+        Object o;\n+        EmptyInline empty;\n+        volatile EmptyInline vempty;\n+    }\n+\n+    @Test\n+    public void emptyInlineClass() throws ReflectiveOperationException {\n+        EmptyInline e = new EmptyInline();\n+        Field[] fields = e.getClass().getDeclaredFields();\n+        assertTrue(fields.length == 0);\n+    }\n+\n+    @Test\n+    public void testInlineValue() throws ReflectiveOperationException {\n+        InlineValue v = new InlineValue();\n+        Field f0 = v.getClass().getDeclaredField(\"o\");\n+        Object o = f0.get(v);\n+        assertTrue(o == null);\n+\n+        \/\/ field of inline type must be non-null\n+        Field f1 = v.getClass().getDeclaredField(\"empty\");\n+        assertTrue(f1.getType() == EmptyInline.class);\n+        EmptyInline empty = (EmptyInline)f1.get(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+    }\n+\n+    @Test\n+    public void testMutableValue() throws ReflectiveOperationException {\n+        MutableValue v = new MutableValue();\n+        Field f0 = v.getClass().getDeclaredField(\"o\");\n+        f0.set(v, null);\n+        assertTrue( f0.get(v) == null);\n+\n+        \/\/ field of inline type must be non-null\n+        Field f1 = v.getClass().getDeclaredField(\"empty\");\n+        assertTrue(f1.getType() == EmptyInline.class);\n+        EmptyInline empty = (EmptyInline)f1.get(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+\n+        Field f2 = v.getClass().getDeclaredField(\"vempty\");\n+        assertTrue(f2.getType() == EmptyInline.class);\n+        EmptyInline vempty = (EmptyInline)f2.get(v);\n+        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n+\n+        f1.set(v, new EmptyInline());\n+        assertTrue((EmptyInline)f1.get(v) == new EmptyInline());\n+        f2.set(v, new EmptyInline());\n+        assertTrue((EmptyInline)f2.get(v) == new EmptyInline());\n+    }\n+\n+    @Test\n+    public void testMethodHandleInlineValue() throws Throwable {\n+        InlineValue v = new InlineValue();\n+        MethodHandle mh = MethodHandles.lookup().findGetter(InlineValue.class, \"empty\", EmptyInline.class);\n+        EmptyInline empty = (EmptyInline) mh.invokeExact(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+    }\n+\n+    @Test\n+    public void testMethodHandleMutableValue() throws Throwable {\n+        MutableValue v = new MutableValue();\n+        MethodHandle getter = MethodHandles.lookup().findGetter(MutableValue.class, \"empty\", EmptyInline.class);\n+        EmptyInline empty = (EmptyInline) getter.invokeExact(v);\n+        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n+\n+        MethodHandle getter1 = MethodHandles.lookup().findGetter(MutableValue.class, \"vempty\", EmptyInline.class);\n+        EmptyInline vempty = (EmptyInline) getter1.invokeExact(v);\n+        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n+\n+        MethodHandle setter = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyInline.class);\n+        setter.invokeExact(v, new EmptyInline());\n+        empty = (EmptyInline) getter.invokeExact(v);\n+        assertTrue(empty == new EmptyInline());\n+\n+        MethodHandle setter1 = MethodHandles.lookup().findSetter(MutableValue.class, \"vempty\", EmptyInline.class);\n+        setter1.invokeExact(v, new EmptyInline());\n+        vempty = (EmptyInline) getter1.invokeExact(v);\n+        assertTrue(vempty == new EmptyInline());\n+    }\n+\n+    @Test(expectedExceptions = { IllegalAccessException.class})\n+    public void noWriteAccess() throws ReflectiveOperationException {\n+        InlineValue v = new InlineValue();\n+        Field f = v.getClass().getDeclaredField(\"empty\");\n+        f.set(v, null);\n+    }\n+\n+    @Test(expectedExceptions = { NullPointerException.class})\n+    public void nonNullableField_reflection() throws ReflectiveOperationException {\n+        MutableValue v = new MutableValue();\n+        Field f = v.getClass().getDeclaredField(\"empty\");\n+        f.set(v, null);\n+    }\n+\n+    @Test(expectedExceptions = { NullPointerException.class})\n+    public void nonNullableField_MethodHandle() throws Throwable {\n+        MutableValue v = new MutableValue();\n+        MethodHandle mh = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", EmptyInline.class);\n+        EmptyInline.ref e = null;\n+        EmptyInline empty = (EmptyInline) mh.invokeExact(v, (EmptyInline)e);\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/UninitializedInlineValueTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}