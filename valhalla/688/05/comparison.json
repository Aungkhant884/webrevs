{"files":[{"patch":"@@ -474,34 +474,0 @@\n-  {\n-    bool identity_object_implemented = false;\n-    bool identity_object_specified = false;\n-    bool value_object_implemented = false;\n-    bool value_object_specified = false;\n-    for (i = 0; i < actual_num_interfaces; i++) {\n-      if (k->local_interfaces()->at(i) == vmClasses::IdentityObject_klass()) {\n-        identity_object_implemented = true;\n-        break;\n-      }\n-      if (k->local_interfaces()->at(i) == vmClasses::ValueObject_klass()) {\n-        value_object_implemented = true;\n-        break;\n-      }\n-    }\n-    for (i = 0; i < specified_num_interfaces; i++) {\n-      if (lookup_class_by_id(_interfaces->at(i)) == vmClasses::IdentityObject_klass()) {\n-        identity_object_specified = true;\n-        break;\n-      }\n-      if (lookup_class_by_id(_interfaces->at(i)) == vmClasses::ValueObject_klass()) {\n-        value_object_specified = true;\n-        break;\n-      }\n-    }\n-\n-    if ( (identity_object_implemented  && !identity_object_specified) ||\n-         (value_object_implemented && !value_object_specified) ){\n-      \/\/ Backwards compatibility -- older classlists do not know about\n-      \/\/ java.lang.IdentityObject or java.lang.ValueObject\n-      expected_num_interfaces--;\n-    }\n-  }\n-\n@@ -736,11 +702,0 @@\n-  if (interface_name == vmSymbols::java_lang_IdentityObject()) {\n-    \/\/ Backwards compatibility -- older classlists do not know about\n-    \/\/ java.lang.IdentityObject.\n-    return vmClasses::IdentityObject_klass();\n-  }\n-  if (interface_name == vmSymbols::java_lang_ValueObject()) {\n-    \/\/ Backwards compatibility -- older classlists do not know about\n-    \/\/ java.lang.ValueObject.\n-    return vmClasses::ValueObject_klass();\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -910,1 +910,1 @@\n-          \"Inline type %s attempts to implement interface java.lang.IdentityObject\",\n+          \"Inline type %s has an identity type as supertytype\",\n@@ -923,8 +923,0 @@\n-      if (ik->name() == vmSymbols::java_lang_IdentityObject()) {\n-        _implements_identityObject = true;\n-      }\n-      if (ik->name() == vmSymbols::java_lang_ValueObject()) {\n-        \/\/ further checks for \"is_invalid_super_for_inline_type()\" needed later\n-        \/\/ needs field parsing, delay unitl post_process_parse_stream()\n-        _implements_valueObject = true;\n-      }\n@@ -4555,7 +4547,0 @@\n-    if (length == 1 && result->at(0) == vmClasses::IdentityObject_klass()) {\n-      return Universe::the_single_IdentityObject_klass_array();\n-    }\n-    if (length == 1 && result->at(0) == vmClasses::ValueObject_klass()) {\n-      return Universe::the_single_ValueObject_klass_array();\n-    }\n-\n@@ -4597,1 +4582,1 @@\n-        !super_ik->is_permits_value_class()) {\n+        super_ik->is_identity_class()) {\n@@ -4832,1 +4817,1 @@\n-      (is_value_class && (is_interface || is_abstract || is_enum || !is_final || is_permits_value_class)) ||\n+      (is_value_class && (is_enum || is_permits_value_class)) ||\n@@ -4834,1 +4819,1 @@\n-      (is_primitive_class && !is_value_class)) {\n+      (is_primitive_class && (!is_value_class || !is_final || is_interface || is_abstract))) {\n@@ -5610,1 +5595,1 @@\n-\/\/ does not implement interface java.lang.IdentityObject (checked elsewhere), has\n+\/\/ is not declared with the identity modifier (checked elsewhere), has\n@@ -5616,3 +5601,0 @@\n-  if (class_name() == vmSymbols::java_lang_IdentityObject()) {\n-    return true;\n-  }\n@@ -5682,7 +5664,0 @@\n-  if (_has_injected_identityObject) {\n-    ik->set_has_injected_identityObject();\n-  }\n-  if (_has_injected_valueObject) {\n-    ik->set_has_injected_primitiveObject();\n-  }\n-\n@@ -5923,10 +5898,0 @@\n-  \/\/ the common single interface arrays need setup here to provide the\n-  \/\/ correct answer to \"compute_transitive_interfaces()\", during\n-  \/\/ \"SystemDictionary::initialize()\"\n-  if (ik->name() == vmSymbols::java_lang_IdentityObject()) {\n-    Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);\n-  }\n-  if (ik->name() == vmSymbols::java_lang_ValueObject()) {\n-    Universe::initialize_the_single_ValueObject_klass_array(ik, CHECK);\n-  }\n-\n@@ -6028,4 +5993,0 @@\n-  _implements_identityObject(false),\n-  _has_injected_identityObject(false),\n-  _implements_valueObject(false),\n-  _has_injected_valueObject(false),\n@@ -6506,17 +6467,0 @@\n-  if (EnableValhalla && !is_inline_type() && invalid_inline_super() && (_super_klass == NULL || !_super_klass->invalid_inline_super())\n-      && !_implements_identityObject && class_name() != vmSymbols::java_lang_IdentityObject()) {\n-    _temp_local_interfaces->append(vmClasses::IdentityObject_klass());\n-    _has_injected_identityObject = true;\n-  }\n-  \/\/ Check if declared as PrimitiveObject...else add if needed\n-  if (_implements_valueObject) {\n-    if (!is_inline_type() && invalid_inline_super()) {\n-      classfile_icce_error(\"class %s can not implement %s, neither valid inline classes or valid supertype\",\n-                            vmClasses::ValueObject_klass(), THREAD);\n-      return;\n-    }\n-  } else if (is_inline_type()) {\n-    _temp_local_interfaces->append(vmClasses::ValueObject_klass());\n-    _has_injected_valueObject = true;\n-  }\n-\n@@ -6526,4 +6470,0 @@\n-  } else if (itfs_len == 1 && _temp_local_interfaces->at(0) == vmClasses::IdentityObject_klass()) {\n-    _local_interfaces = Universe::the_single_IdentityObject_klass_array();\n-  } else if (itfs_len == 1 && _temp_local_interfaces->at(0) == vmClasses::ValueObject_klass()) {\n-    _local_interfaces = Universe::the_single_ValueObject_klass_array();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":5,"deletions":65,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -211,4 +211,0 @@\n-  bool _implements_identityObject;\n-  bool _has_injected_identityObject;\n-  bool _implements_valueObject;\n-  bool _has_injected_valueObject;\n@@ -607,0 +603,1 @@\n+  bool is_identity_class() const { return _access_flags.is_identity_class(); }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-    \/\/ to interfaces java.lang.Cloneable, java.io.Serializable,\n-    \/\/ and java.lang.IdentityObject.\n+    \/\/ to interfaces java.lang.Cloneable and java.io.Serializable\n@@ -77,2 +76,1 @@\n-      this_class == vmClasses::Serializable_klass() ||\n-      this_class == vmClasses::IdentityObject_klass();\n+      this_class == vmClasses::Serializable_klass();\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-  do_klass(IdentityObject_klass,                        java_lang_IdentityObject                              ) \\\n-  do_klass(ValueObject_klass,                           java_lang_ValueObject                             ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-  template(java_lang_IdentityObject,                  \"java\/lang\/IdentityObject\")                 \\\n-  template(java_lang_ValueObject,                     \"java\/lang\/ValueObject\")                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,2 +139,0 @@\n-Array<InstanceKlass*>* Universe::_the_single_IdentityObject_klass_array = NULL;\n-Array<InstanceKlass*>* Universe::_the_single_ValueObject_klass_array = NULL;\n@@ -225,2 +223,0 @@\n-  it->push(&_the_single_IdentityObject_klass_array);\n-  it->push(&_the_single_ValueObject_klass_array);\n@@ -277,2 +273,0 @@\n-  f->do_ptr((void**)&_the_single_IdentityObject_klass_array);\n-  f->do_ptr((void**)&_the_single_ValueObject_klass_array);\n@@ -335,1 +329,1 @@\n-        _the_array_interfaces_array     = MetadataFactory::new_array<Klass*>(null_cld, 3, NULL, CHECK);\n+        _the_array_interfaces_array     = MetadataFactory::new_array<Klass*>(null_cld, 2, NULL, CHECK);\n@@ -362,2 +356,0 @@\n-      assert(_the_array_interfaces_array->at(2) ==\n-                   vmClasses::IdentityObject_klass(), \"u3\");\n@@ -365,4 +357,0 @@\n-      assert(_the_single_IdentityObject_klass_array->at(0) ==\n-          vmClasses::IdentityObject_klass(), \"u3\");\n-      assert(_the_single_ValueObject_klass_array->at(0) ==\n-          vmClasses::ValueObject_klass(), \"u3\");\n@@ -375,1 +363,0 @@\n-      _the_array_interfaces_array->at_put(2, vmClasses::IdentityObject_klass());\n@@ -485,17 +472,0 @@\n-void Universe::initialize_the_single_IdentityObject_klass_array(InstanceKlass* ik, TRAPS) {\n-    assert(_the_single_IdentityObject_klass_array == NULL, \"Must not be initialized twice\");\n-    assert(ik->name() == vmSymbols::java_lang_IdentityObject(), \"Must be\");\n-    Array<InstanceKlass*>* array = MetadataFactory::new_array<InstanceKlass*>(ik->class_loader_data(), 1, NULL, CHECK);\n-    array->at_put(0, ik);\n-    _the_single_IdentityObject_klass_array = array;\n-}\n-\n-void Universe::initialize_the_single_ValueObject_klass_array(InstanceKlass* ik, TRAPS) {\n-    assert(_the_single_ValueObject_klass_array == NULL, \"Must not be initialized twice\");\n-    assert(ik->name() == vmSymbols::java_lang_ValueObject(), \"Must be\");\n-    Array<InstanceKlass*>* array = MetadataFactory::new_array<InstanceKlass*>(ik->class_loader_data(), 1, NULL, CHECK);\n-    array->at_put(0, ik);\n-    _the_single_ValueObject_klass_array = array;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":31,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -127,2 +127,0 @@\n-  static Array<InstanceKlass*>* _the_single_IdentityObject_klass_array;  \/\/ Common single interface array for IdentityObjects\n-  static Array<InstanceKlass*>* _the_single_ValueObject_klass_array; \/\/ Common single interface array for PrimitiveObjects\n@@ -293,12 +291,0 @@\n-  static Array<InstanceKlass*>*  the_single_IdentityObject_klass_array() {\n-    assert(_the_single_IdentityObject_klass_array != NULL, \"Must be initialized before use\");\n-    assert(_the_single_IdentityObject_klass_array->length() == 1, \"Sanity check\");\n-    return _the_single_IdentityObject_klass_array;\n-  }\n-  static void initialize_the_single_IdentityObject_klass_array(InstanceKlass* ik, TRAPS);\n-  static Array<InstanceKlass*>*  the_single_ValueObject_klass_array() {\n-    assert(_the_single_ValueObject_klass_array != NULL, \"Must be initialized before use\");\n-    assert(_the_single_ValueObject_klass_array->length() == 1, \"Sanity check\");\n-    return _the_single_ValueObject_klass_array;\n-  }\n-  static void initialize_the_single_ValueObject_klass_array(InstanceKlass* ik, TRAPS);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -421,1 +421,0 @@\n-  assert(elem_supers->length() > 0, \"Must at least include the PrimitiveObject interface\");\n@@ -424,1 +423,1 @@\n-  GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+4);\n+  GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+2);\n@@ -428,1 +427,0 @@\n-  secondaries->push(vmClasses::IdentityObject_klass());\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -600,3 +600,1 @@\n-    if (ti != sti && ti != NULL && !ti->is_shared() &&\n-        ti != Universe::the_single_IdentityObject_klass_array() &&\n-        ti != Universe::the_single_ValueObject_klass_array()) {\n+    if (ti != sti && ti != NULL && !ti->is_shared()) {\n@@ -609,3 +607,1 @@\n-      local_interfaces != NULL && !local_interfaces->is_shared() &&\n-      local_interfaces != Universe::the_single_IdentityObject_klass_array() &&\n-      local_interfaces != Universe::the_single_ValueObject_klass_array()) {\n+      local_interfaces != NULL && !local_interfaces->is_shared()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -286,2 +286,0 @@\n-    _misc_has_injected_identityObject         = 1 << 20, \/\/ IdentityObject has been injected by the JVM\n-    _misc_has_injected_primitiveObject        = 1 << 21  \/\/ PrimitiveObject has been injected by the JVM\n@@ -479,16 +477,0 @@\n-  bool has_injected_identityObject() const {\n-    return (_misc_flags & _misc_has_injected_identityObject) != 0;\n-  }\n-\n-  void set_has_injected_identityObject() {\n-    _misc_flags |= _misc_has_injected_identityObject;\n-  }\n-\n-  bool has_injected_valueObject() const {\n-    return (_misc_flags & _misc_has_injected_primitiveObject) != 0;\n-  }\n-\n-  void set_has_injected_primitiveObject() {\n-    _misc_flags |= _misc_has_injected_primitiveObject;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -673,0 +673,1 @@\n+  bool is_identity_class() const        { return _access_flags.is_identity_class(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -428,1 +428,1 @@\n-    GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+3);\n+    GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(num_elem_supers+2);\n@@ -431,1 +431,0 @@\n-    secondaries->push(vmClasses::IdentityObject_klass());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1190,1 +1190,1 @@\n-    size = 3;\n+    size = 2;\n@@ -1205,1 +1205,1 @@\n-    \/\/ All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject\n+    \/\/ All arrays implement java.lang.Cloneable and java.io.Serializable\n@@ -1208,1 +1208,0 @@\n-    result->obj_at_put(2, vmClasses::IdentityObject_klass()->java_mirror());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -929,2 +929,1 @@\n-  write_u2(num_interfaces -\n-           (ik()->has_injected_identityObject() || ik()->has_injected_valueObject() ? 1 : 0));\n+  write_u2(num_interfaces);\n@@ -935,4 +934,1 @@\n-    if ( (!ik()->has_injected_identityObject() || iik != vmClasses::IdentityObject_klass()) &&\n-         (!ik()->has_injected_valueObject() || iik != vmClasses::ValueObject_klass())) {\n-      write_u2(class_symbol_to_cpool_index(iik->name()));\n-    }\n+    write_u2(class_symbol_to_cpool_index(iik->name()));\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -336,9 +336,0 @@\n-  \/\/ Cannot redefine or retransform interface java.lang.IdentityObject.\n-  if (k->name() == vmSymbols::java_lang_IdentityObject()) {\n-    return false;\n-  }\n-  \/\/ Cannot redefine or retransform interface java.lang.ValueObject.\n-  if (k->name() == vmSymbols::java_lang_ValueObject()) {\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2294,2 +2294,0 @@\n-  declare_constant(InstanceKlass::_misc_has_injected_primitiveObject)     \\\n-  declare_constant(InstanceKlass::_misc_has_injected_identityObject)      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+  bool is_identity_class  () const     { return (_flags & JVM_ACC_IDENTITY    ) != 0; }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1765,1 +1765,0 @@\n-                \/\/ Skip IdentityObject to keep the computed SVUID the same.\n@@ -1767,2 +1766,1 @@\n-                    if (!\"java.lang.IdentityObject\".equals(ifaceNames[i]))\n-                        dout.writeUTF(ifaceNames[i]);\n+                    dout.writeUTF(ifaceNames[i]);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,2 +205,2 @@\n-    private static final int VALUE_CLASS     = 0x00000100;\n-    private static final int PERMITS_VALUE   = 0x00000040;\n+    private static final int VALUE_CLASS     = 0x00000040;\n+    private static final int PERMITS_VALUE   = 0x00000100;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public final class Identity implements IdentityObject {\n+public final class Identity {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Identity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-\/**\n- * A restricted interface implemented by all identity objects.\n- *\n- * IdentityObject: An object with identity.\n- *\n- * *Identity* is a property of certain objects, determined at instance creation\n- * time and preserved throughout the life of the object. While an object's field\n- * values may change, its identity is constant. Object identities are unique: no\n- * two objects created by different instance creation operations can have the same\n- * identity.\n- *\n- * Every object is either an *identity object* or a *value object*. Value\n- * objects lack identity.\n- *\n- * The following operations have special behavior when applied to identity objects:\n- *\n- * - The `==` operator, and the default implementation of the `Object.equals`\n- * method, compare the identities of their operands, producing `true` for an\n- * identity object only if the object is being compared to itself.\n- *\n- * - The `System.identityHashCode` method, and the default implementation of the\n- * `Object.hashCode` method, generate a hash code from an identity object's\n- * identity.\n- *\n- * - The `synchronized` modifier and `synchronized` statement are only able to\n- * successfully acquire a lock when applied to an identity object.\n- *\n- * A class may implement `IdentityObject` or `ValueObject`, but never both.\n- * Value classes always implement `ValueObject`, while all other concrete\n- * classes (except `Object`) implicitly implement `IdentityObject`.\n- *\n- * Abstract classes and interfaces may implement or extend this interface if they\n- * wish to guarantee that all instances of the class or interface have identity.\n- *\n- * @since Valhalla\n- *\/\n-public interface IdentityObject {\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/IdentityObject.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-\/**\n- * A restricted interface implemented by all value objects.\n- *\n- * A value object is an instance of a value class, lacking identity.\n- *\n- * Every object is either an *identity object* or a *value object*. Identity\n- * objects have a unique identity determined for them at instance creation time and\n- * preserved throughout their life.\n- *\n- * value objects do *not* have an identity. Instead, they simply aggregate a\n- * set of immutable field values. The lack of identity enables certain performance\n- * optimizations by Java Virtual Machine implementations.\n- * The following operations have special behavior when applied to value\n- * objects:\n- *\n- * - The `==` operator, and the default implementation of the `Object.equals`\n- * method, compare the values of the operands' fields. Value objects\n- * created at different points in a program may be `==`.\n- *\n- * - The `System.identityHashCode` method, and the default implementation of the\n- * `Object.hashCode` method, generate a hash code from the hash codes of a\n- * value object's fields.\n- *\n- * - The `synchronized` modifier and `synchronized` statement always fail when\n- * applied to a value object.\n- *\n- * A class may implement `ValueObject` or `IdentityObject`, but never both.\n- * Value classes always implement `ValueObject`, while all other concrete\n- * classes (except `Object`) implicitly implement `IdentityObject`.\n- *\n- * Abstract classes and interfaces may implement or extend this interface if they\n- * wish to guarantee that all instances of the class or interface are value\n- * objects.\n- *\n- * @since Valhalla\n- *\/\n-\n-public interface ValueObject {\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ValueObject.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -47,0 +47,1 @@\n+    JVM_ACC_IDENTITY      = 0x0020,\n@@ -49,1 +50,1 @@\n-    JVM_ACC_PERMITS_VALUE = 0x0040,\n+    JVM_ACC_VALUE         = 0x0040,\n@@ -53,1 +54,1 @@\n-    JVM_ACC_VALUE         = 0x0100,\n+    JVM_ACC_PERMITS_VALUE = 0x0100,\n","filename":"src\/java.base\/share\/native\/include\/classfile_constants.h.template","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -94,0 +94,6 @@\n+    \/**\n+     * The modifier {@code identity}\n+     * @since 18\n+     *\/\n+    IDENTITY,\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-    public static final int ACC_SUPER    = 0x0020;\n+    public static final int ACC_IDENTITY = 0x0020;\n+    public static final int ACC_VALUE    = 0x0040;\n@@ -117,1 +118,0 @@\n-    public static final int ACC_VALUE    = 0x0100;\n@@ -120,1 +120,0 @@\n-    public static final int ACC_PERMITS_VALUE = 0x0040;\n@@ -148,2 +147,5 @@\n-    \/** Flag is set for an abstract class that meets the various needs\n-     *  that qualify it to be the super class of a value\/primitive class\n+    \/** Flag is set for a class or interface whose instances have identity\n+     * i.e. class\/interface declarations that are expressly declared with\n+     * the modifier `identity' or (b) any concrete class not declared with the\n+     * modifier `value' (c) abstract class not declared `value' but meets various\n+     * stipulations (d) older class files with ACC_SUPER bit set\n@@ -151,1 +153,1 @@\n-    public static final int PERMITS_VALUE            = 1<<19;\n+    public static final int IDENTITY_TYPE            = 1<<19;\n@@ -425,1 +427,1 @@\n-        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC | ACC_PERMITS_VALUE,\n+        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC | ACC_IDENTITY,\n@@ -518,1 +520,6 @@\n-        PERMITS_VALUE(Flags.PERMITS_VALUE),\n+        IDENTITY_TYPE(Flags.IDENTITY_TYPE) {\n+            @Override\n+            public String toString() {\n+                return \"identity\";\n+            }\n+        },\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -424,1 +424,13 @@\n-        return (flags() & VALUE_CLASS) != 0;\n+        return !isInterface() && (flags() & VALUE_CLASS) != 0;\n+    }\n+\n+    public boolean isIdentityClass() {\n+        return !isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+    }\n+\n+    public boolean isValueInterface() {\n+        return isInterface() && (flags() & VALUE_CLASS) != 0;\n+    }\n+\n+    public boolean isIdentityInterface() {\n+        return isInterface() && (flags() & IDENTITY_TYPE) != 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -225,2 +225,0 @@\n-    public final Type identityObjectType;\n-    public final Type valueObjectType;\n@@ -611,2 +609,0 @@\n-        identityObjectType = enterClass(\"java.lang.IdentityObject\");\n-        valueObjectType = enterClass(\"java.lang.ValueObject\");\n@@ -630,2 +626,0 @@\n-        synthesizeEmptyInterfaceIfMissing(identityObjectType);\n-        synthesizeEmptyInterfaceIfMissing(valueObjectType);\n@@ -653,1 +647,1 @@\n-                List.of(cloneableType, serializableType, identityObjectType);\n+                List.of(cloneableType, serializableType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -248,0 +248,12 @@\n+    public boolean isValueInterface() {\n+        return false;\n+    }\n+\n+    public boolean isIdentityClass() {\n+        return false;\n+    }\n+\n+    public boolean isIdentityInterface() {\n+        return false;\n+    }\n+\n@@ -1353,0 +1365,15 @@\n+        @Override\n+        public boolean isValueInterface() {\n+            return tsym != null && tsym.isValueInterface();\n+        }\n+\n+        @Override\n+        public boolean isIdentityClass() {\n+            return !isReferenceProjection() && tsym != null && tsym.isIdentityClass();\n+        }\n+\n+        @Override\n+        public boolean isIdentityInterface() {\n+            return isInterface() && tsym.isIdentityInterface();\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -797,5 +797,9 @@\n-            \/\/ Not functional if extending either of the top interface types.\n-            Type topInterface;\n-            if ((topInterface = asSuper(origin.type, syms.identityObjectType.tsym)) != null ||\n-                    (topInterface = asSuper(origin.type, syms.valueObjectType.tsym)) != null) {\n-                throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.MayNotExtendTopInterfaceType(topInterface)));\n+            \/\/ an interface must be neither an identity interface nor a value interface to be functional.\n+            List<Type> allInterfaces = closure(origin.type);\n+            for (Type iface : allInterfaces) {\n+                if (iface.isValueInterface()) {\n+                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.ValueInterfaceNonfunctional));\n+                }\n+                if (iface.isIdentityInterface()) {\n+                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.IdentityInterfaceNonfunctional));\n+                }\n@@ -1246,2 +1250,1 @@\n-                        || sname == names.java_io_Serializable\n-                        || sname == names.java_lang_IdentityObject;\n+                        || sname == names.java_io_Serializable;\n@@ -2261,19 +2264,0 @@\n-        if (sym == syms.identityObjectType.tsym) {\n-            \/\/ IdentityObject is a super interface of every concrete identity class other than jlO\n-            if (t.tsym == syms.objectType.tsym)\n-                return null;\n-            if (t.hasTag(ARRAY))\n-                return syms.identityObjectType;\n-            if (t.hasTag(CLASS) && !t.isValueClass() && !t.isReferenceProjection() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n-                return syms.identityObjectType;\n-            }\n-            if (implicitIdentityType(t)) {\n-                return syms.identityObjectType;\n-            } \/\/ else fall through and look for explicit coded super interface\n-        } else if (sym == syms.valueObjectType.tsym) {\n-            if (t.isValueClass() || t.isReferenceProjection())\n-                return syms.valueObjectType;\n-            if (t.hasTag(ARRAY) || t.tsym == syms.objectType.tsym)\n-                return null;\n-            \/\/ else fall through and look for explicit coded super interface\n-        }\n@@ -2341,0 +2325,17 @@\n+    public boolean isIdentityType(Type t) {\n+        if (t.isPrimitiveClass() || t.isReferenceProjection() || t.isValueClass() || t.isValueInterface()) {\n+            return false;\n+        }\n+        if (t.tsym == syms.objectType.tsym) {\n+            return false;\n+        }\n+        if (t.hasTag(ARRAY))\n+            return true;\n+        if (t.hasTag(CLASS) && !t.isValueClass() && !t.isReferenceProjection() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n+            return true;\n+        }\n+        if (implicitIdentityType(t)) {\n+            return true;\n+        }\n+        return false;\n+    }\n@@ -2343,1 +2344,1 @@\n-            \/* An abstract class can be declared to implement either IdentityObject or ValueObject;\n+            \/* An abstract class can be declared with the identity\/value modifier;\n@@ -2345,1 +2346,1 @@\n-             * a synchronized instance method, it implicitly implements IdentityObject.\n+             * a synchronized instance method, it implicitly is an Identity type.\n@@ -4282,1 +4283,1 @@\n-                        syms.cloneableType, syms.identityObjectType), true);\n+                        syms.cloneableType), true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -769,1 +769,1 @@\n-            if ((st.tsym.flags() & PERMITS_VALUE) != 0) {\n+            if ((st.tsym.flags() & IDENTITY_TYPE) == 0) {\n@@ -772,0 +772,1 @@\n+            \/\/ TODO: If an IDENTITY_TYPE we may not issue an error below, if older abstract class qualifies\n@@ -894,6 +895,0 @@\n-        \/* Not appropriate to check\n-         *     if (types.asSuper(t, syms.identityObjectType.tsym) != null)\n-         * since jlO, interface types and abstract types may fail that check\n-         * at compile time.\n-         *\/\n-\n@@ -1480,2 +1475,2 @@\n-            \/\/ value classes are implicitly final\n-            if ((flags & VALUE_CLASS) != 0)\n+            \/\/ concrete value classes are implicitly final\n+            if ((flags & (ABSTRACT | INTERFACE | VALUE_CLASS)) == VALUE_CLASS)\n@@ -1484,2 +1479,2 @@\n-            \/\/ ACC_PERMITS_VALUE a legal class flag, but not a legal class modifier\n-            mask &= ~ACC_PERMITS_VALUE;\n+            \/\/ TYPs can't be declared synchronized\n+            mask &= ~SYNCHRONIZED;\n@@ -1514,1 +1509,5 @@\n-                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS | VALUE_CLASS)\n+                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                 &&\n+                 checkDisjoint(pos, flags,\n+                        IDENTITY_TYPE,\n+                        PRIMITIVE_CLASS | VALUE_CLASS)\n@@ -2779,10 +2778,0 @@\n-\n-        boolean implementsIdentityObject = types.asSuper(c.referenceProjectionOrSelf(), syms.identityObjectType.tsym) != null;\n-        boolean implementsValueObject = types.asSuper(c.referenceProjectionOrSelf(), syms.valueObjectType.tsym) != null;\n-        if (c.isValueClass() && implementsIdentityObject) {\n-            log.error(pos, Errors.ValueClassMustNotImplementIdentityObject(c));\n-        } else if (implementsValueObject && !c.isValueClass() && !c.isReferenceProjection() && !c.tsym.isInterface() && !c.tsym.isAbstract()) {\n-            log.error(pos, Errors.IdentityClassMustNotImplementValueObject(c));\n-        } else if (implementsValueObject && implementsIdentityObject) {\n-            log.error(pos, Errors.MutuallyIncompatibleSuperInterfaces(c));\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1103,0 +1103,3 @@\n+                if ((tree.sym.flags() & (ABSTRACT | INTERFACE | VALUE_CLASS)) == 0) {\n+                    tree.sym.flags_field |= IDENTITY_TYPE;\n+                }\n@@ -1104,2 +1107,2 @@\n-                    if (types.asSuper(tree.sym.type, syms.identityObjectType.tsym) == null) {\n-                        tree.sym.flags_field |= PERMITS_VALUE;\n+                    if (types.isIdentityType(tree.sym.type)) {\n+                        tree.sym.flags_field |= IDENTITY_TYPE;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2806,3 +2806,3 @@\n-        if ((flags & ACC_PERMITS_VALUE) != 0) {\n-            flags &= ~ACC_PERMITS_VALUE;\n-            flags |= PERMITS_VALUE;\n+        if ((flags & ACC_IDENTITY) != 0) {\n+            flags &= ~ACC_IDENTITY;\n+            flags |= IDENTITY_TYPE;\n@@ -2810,1 +2810,1 @@\n-        return flags & ~ACC_SUPER; \/\/ SUPER and SYNCHRONIZED bits overloaded\n+        return flags;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -221,7 +221,0 @@\n-\n-    \/** Return flags as a string, separated by \" \".\n-     *\/\n-    public static String classFlagNames(long flags) {\n-        return flagNames(flags).replace(\"VOLATILE\", \"PERMITS_VALUE\");\n-    }\n-\n@@ -247,1 +240,1 @@\n-            \"SUPER\", \"VOLATILE\", \"TRANSIENT\", \"NATIVE\", \"INTERFACE\",\n+            \"IDENTITY\", \"VOLATILE\", \"TRANSIENT\", \"NATIVE\", \"INTERFACE\",\n@@ -843,1 +836,1 @@\n-                pw.println(\"---\" + classFlagNames(flags));\n+                pw.println(\"---\" + flagNames(flags));\n@@ -1582,1 +1575,0 @@\n-            if ((flags & INTERFACE) == 0) flags |= ACC_SUPER;\n@@ -1589,1 +1581,1 @@\n-            pw.println(\"---\" + classFlagNames(flags));\n+            pw.println(\"---\" + flagNames(flags));\n@@ -1760,2 +1752,2 @@\n-        if ((flags & PERMITS_VALUE) != 0)\n-            result |= ACC_PERMITS_VALUE;\n+        if ((flags & IDENTITY_TYPE) != 0)\n+            result |= ACC_IDENTITY;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2789,1 +2789,1 @@\n-        if ((isPrimitiveModifier() && allowPrimitiveClasses) || isValueModifier() && allowValueClasses) {\n+        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n@@ -3337,0 +3337,4 @@\n+                if (isIdentityModifier()) {\n+                    flag = Flags.IDENTITY_TYPE;\n+                    break;\n+                }\n@@ -3612,0 +3616,7 @@\n+        if (name == names.identity) {\n+            if (allowPrimitiveClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n@@ -4514,2 +4525,2 @@\n-                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive value || new primitive Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.primitive\n+                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n+                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n@@ -4540,2 +4551,2 @@\n-                case IDENTIFIER: \/\/ value record R || value value || value primitive || new value Comparable() {} ??\n-                    if (next.name() == names.record || next.name() == names.value\n+                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n+                    if (next.name() == names.record || next.name() == names.value || next.name() == names.identity\n@@ -4554,0 +4565,26 @@\n+    protected boolean isIdentityModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.identity) {\n+            boolean isIdentityModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM:\n+                    isIdentityModifier = true;\n+                    break;\n+                case IDENTIFIER: \/\/ identity record R || identity primitive || || identity identity || identity value || new identity Comparable() {}\n+                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                            || next.name() == names.value || (mode & EXPR) != 0)\n+                        isIdentityModifier = true;\n+                    break;\n+            }\n+            if (isIdentityModifier) {\n+                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -266,3 +266,5 @@\n-# 0: type\n-compiler.misc.may.not.extend.top.interface.type=\\\n-    since it extends {0}\n+compiler.misc.value.interface.nonfunctional=\\\n+    since it is a value interface\n+\n+compiler.misc.identity.interface.nonfunctional=\\\n+    since it is an identity interface\n@@ -3950,12 +3952,0 @@\n-# 0: type\n-compiler.err.value.class.must.not.implement.identity.object=\\\n-    The value class {0} attempts to implement the incompatible interface IdentityObject\n-\n-# 0: type\n-compiler.err.identity.class.must.not.implement.value.object=\\\n-    The identity class {0} attempts to implement the incompatible interface ValueObject\n-\n-# 0: type\n-compiler.err.mutually.incompatible.super.interfaces=\\\n-    The type {0} attempts to implement the mutually incompatible interfaces ValueObject and IdentityObject\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    public final Name identity;\n@@ -121,1 +122,0 @@\n-    public final Name java_lang_IdentityObject;\n@@ -300,0 +300,1 @@\n+        identity = fromString(\"identity\");\n@@ -317,1 +318,0 @@\n-        java_lang_IdentityObject = fromString(\"java.lang.IdentityObject\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-  private static int MISC_HAS_INJECTED_PRIMITIVEOBJECT;\n-  private static int MISC_HAS_INJECTED_IDENTITYOBJECT;\n@@ -139,2 +137,0 @@\n-    MISC_HAS_INJECTED_PRIMITIVEOBJECT = db.lookupIntConstant(\"InstanceKlass::_misc_has_injected_primitiveObject\").intValue();\n-    MISC_HAS_INJECTED_IDENTITYOBJECT  = db.lookupIntConstant(\"InstanceKlass::_misc_has_injected_identityObject\").intValue();\n@@ -575,8 +571,0 @@\n-  public boolean hasInjectedIdentityObject() {\n-    return (getMiscFlags() & MISC_HAS_INJECTED_IDENTITYOBJECT) != 0;\n-  }\n-\n-  public boolean hasInjectedPrimitiveObject() {\n-    return (getMiscFlags() & MISC_HAS_INJECTED_PRIMITIVEOBJECT) != 0;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -356,3 +356,0 @@\n-        if (klass.hasInjectedIdentityObject() || klass.hasInjectedPrimitiveObject()) {\n-            nb_interfaces--;\n-        }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-    private HotSpotResolvedObjectTypeImpl identityObjectType;\n@@ -130,7 +129,0 @@\n-    HotSpotResolvedObjectTypeImpl getJavaLangIdentityObject() {\n-        if (identityObjectType == null) {\n-            identityObjectType = (HotSpotResolvedObjectTypeImpl) fromClass(IdentityObject.class);\n-        }\n-        return identityObjectType;\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-                HotSpotResolvedObjectTypeImpl[] types = new HotSpotResolvedObjectTypeImpl[3];\n+                HotSpotResolvedObjectTypeImpl[] types = new HotSpotResolvedObjectTypeImpl[2];\n@@ -291,1 +291,0 @@\n-                types[2] = runtime().getJavaLangIdentityObject();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    public static final int ACC_SUPER         = 0x0020; \/\/ class\n+    public static final int ACC_IDENTITY      = 0x0020; \/\/ class, inner\n@@ -48,1 +48,1 @@\n-    public static final int ACC_PERMITS_VALUE = 0x0040; \/\/  (non inner abstract) class\n+    public static final int ACC_VALUE         = 0x0040; \/\/ class, inner,\n@@ -53,1 +53,0 @@\n-    public static final int ACC_VALUE         = 0x0100; \/\/                      class\n@@ -88,1 +87,1 @@\n-        ACC_PUBLIC, ACC_FINAL, ACC_ABSTRACT, ACC_PRIMITIVE, ACC_VALUE\n+        ACC_PUBLIC, ACC_FINAL, ACC_IDENTITY, ACC_ABSTRACT, ACC_PRIMITIVE, ACC_VALUE\n@@ -92,2 +91,2 @@\n-        ACC_PUBLIC, ACC_FINAL, ACC_SUPER, ACC_INTERFACE, ACC_ABSTRACT,\n-        ACC_SYNTHETIC, ACC_ANNOTATION, ACC_ENUM, ACC_MODULE, ACC_PRIMITIVE, ACC_VALUE, ACC_PERMITS_VALUE\n+        ACC_PUBLIC, ACC_FINAL, ACC_IDENTITY, ACC_INTERFACE, ACC_ABSTRACT,\n+        ACC_SYNTHETIC, ACC_ANNOTATION, ACC_ENUM, ACC_MODULE, ACC_PRIMITIVE, ACC_VALUE\n@@ -106,1 +105,1 @@\n-        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,\n+        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_IDENTITY,\n@@ -111,1 +110,1 @@\n-        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SUPER,\n+        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_IDENTITY,\n@@ -203,2 +202,2 @@\n-            case ACC_SYNCHRONIZED:\n-                return \"synchronized\";\n+            case 0x20:\n+                return (t == Kind.Class || t == Kind.InnerClass) ? \"identity\" : \"synchronized\";\n@@ -207,4 +206,4 @@\n-            case ACC_VOLATILE:\n-                return \"volatile\";\n-            case 0x100:\n-                return (t == Kind.Class || t == Kind.InnerClass) ? \"value\" : \"native\";\n+            case 0x40:\n+                return (t == Kind.Class || t == Kind.InnerClass) ? \"value\" : \"volatile\";\n+            case ACC_NATIVE:\n+                return \"native\";\n@@ -235,1 +234,1 @@\n-            return (t == Kind.Class ? \"ACC_SUPER\" : \"ACC_SYNCHRONIZED\");\n+            return ((t == Kind.Class || t == Kind.InnerClass) ? \"ACC_IDENTITY\" : \"ACC_SYNCHRONIZED\");\n@@ -237,1 +236,1 @@\n-            return (t == Kind.Field ? \"ACC_VOLATILE\" : t == Kind.Method ? \"ACC_BRIDGE\" : \"ACC_PERMITS_VALUE\");\n+            return (t == Kind.Field ? \"ACC_VOLATILE\" : t == Kind.Method ? \"ACC_BRIDGE\" : \"ACC_VALUE\");\n@@ -240,2 +239,2 @@\n-        case 0x100:\n-            return (t == Kind.Class || t == Kind.InnerClass) ? \"ACC_VALUE\" : \"ACC_NATIVE\";\n+        case ACC_NATIVE:\n+            return \"ACC_NATIVE\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-  0x0931; \/\/ access\n+  0x0851; \/\/ access\n@@ -522,1 +522,1 @@\n-  0x0931; \/\/ access\n+  0x0851; \/\/ access\n@@ -678,1 +678,1 @@\n-  0x0931; \/\/ access\n+  0x0851; \/\/ access\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  0x0930; \/\/ access\n+  0x0850; \/\/ access\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue5.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  0x0130; \/\/ access [ ACC_SUPER ACC_FINAL ]\n+  0x0050; \/\/ access [ ACC_VALUE ACC_FINAL ]\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/HiddenPoint.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  0x0561; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_SUPER ACC_ABSTRACT ACC_PERMITS_VALUE ]\n+  0x0441; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_ABSTRACT ]\n@@ -222,1 +222,1 @@\n-  0x0461; \/\/ access [ ACC_PUBLIC ACC_SUPER ACC_ABSTRACT ACC_PERMITS_VALUE ]\n+  0x0421; \/\/ access [ ACC_PUBLIC ACC_SUPER ACC_ABSTRACT ]\n@@ -364,1 +364,1 @@\n-  0x0471; \/\/ access [ ACC_FINAL ACC_PUBLIC ACC_SUPER ACC_ABSTRACT ACC_PERMITS_VALUE ]\n+  0x0431; \/\/ access [ ACC_FINAL ACC_PUBLIC ACC_SUPER ACC_ABSTRACT ]\n@@ -506,1 +506,1 @@\n-  0x0661; \/\/ access [ ACC_INTERFACE ACC_PUBLIC ACC_SUPER ACC_ABSTRACT ACC_PERMITS_VALUE ]\n+  0x0621; \/\/ access [ ACC_INTERFACE ACC_PUBLIC ACC_SUPER ACC_ABSTRACT ]\n@@ -648,1 +648,1 @@\n-  0x0461; \/\/ access [ ACC_PUBLIC ACC_SUPER ACC_ABSTRACT ACC_PERMITS_VALUE ]\n+  0x0421; \/\/ access [ ACC_PUBLIC ACC_SUPER ACC_ABSTRACT ]\n@@ -790,1 +790,1 @@\n-  0x0061; \/\/ access [ ACC_PUBLIC ACC_SUPER ACC_PERMITS_VALUE ]\n+  0x0021; \/\/ access [ ACC_PUBLIC ACC_SUPER ]\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCCFETests.jcod","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-  0x0131; \/\/ access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACCICCETests.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                \"Illegal class modifiers in class AbstractPV_ACC_VALUE (a permits_value class)\");\n+                \"Illegal class modifiers in class AbstractPV_ACC_VALUE (a value class)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/ACC_CFETest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-  0x04930; \/\/ access [  ACC_VALUE ACC_PRIMITIVE ACC_ENUM(bad) ACC_SUPER ACC_FINAL ]\n+  0x04850; \/\/ access [  ACC_VALUE ACC_PRIMITIVE ACC_ENUM(bad) ACC_FINAL ]\n@@ -395,1 +395,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -676,1 +676,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -946,1 +946,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -1224,1 +1224,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -1539,1 +1539,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -1817,1 +1817,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -2089,1 +2089,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -2519,1 +2519,1 @@\n-  0x0131; \/\/ access [ ACC_PUBLIC ACC_SUPER ACC_FINAL ]\n+  0x0051; \/\/ access [ ACC_VALUE ACC_PUBLIC ACC_FINAL ]\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/cfpTests.jcod","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -195,1 +195,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -296,1 +296,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -390,1 +390,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -481,1 +481,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -571,1 +571,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -669,1 +669,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -763,1 +763,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -880,1 +880,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -1086,1 +1086,1 @@\n-  0x0930; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_SUPER ACC_FINAL ]\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n@@ -1303,1 +1303,1 @@\n-  0x0931; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_SUPER ACC_FINAL ]\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/verifierTests.jcod","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        if (is.length != 3)\n+        if (is.length != 2)\n@@ -102,3 +102,0 @@\n-        if (!is[2].getCanonicalName().equals(\"java.lang.IdentityObject\"))\n-            thisFailed = true;\n-\n@@ -108,1 +105,1 @@\n-            System.out.println(\"Should contain exactly Cloneable, Serializable and IdentityObject in that order.\");\n+            System.out.println(\"Should contain exactly Cloneable and Serializable in that order.\");\n","filename":"test\/jdk\/java\/lang\/Class\/ArrayMethods.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -70,6 +70,0 @@\n-                \/\/ Adjust according to JDK-8237952\n-                if (!toTest.isPrimitive() && !toTest.isArray() && toTest != Object.class) {\n-                    assert (res.length == 1);\n-                    assert (res[0].getType() == IdentityObject.class);\n-                    continue;\n-                }\n","filename":"test\/jdk\/java\/lang\/annotation\/typeAnnotations\/GetAnnotatedInterfaces.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,4 +63,0 @@\n-                    if (isMod && klass == java.lang.IdentityObject.class) {\n-                        System.err.println(\"Error: java.lang.IdentityObject class returned as modifiable: \" + klass);\n-                        fail = true;\n-                    }\n","filename":"test\/jdk\/java\/lang\/instrument\/IsModifiableClassAgent.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -263,2 +263,2 @@\n-    class C implements IdentityObject { }\n-    primitive class T implements ValueObject { }\n+    class C { }\n+    primitive class T { }\n@@ -271,0 +271,1 @@\n+        Class<?> [] empty_intfs = new Class<?>[0];\n@@ -272,7 +273,7 @@\n-                new Object[]{ new BasicTest(), new Class<?>[] { IdentityObject.class }},\n-                new Object[]{ point, new Class<?>[] { ValueObject.class }},\n-                new Object[]{ new T(), new Class<?>[] { ValueObject.class }},\n-                new Object[]{ new C(), new Class<?>[] { IdentityObject.class }},\n-                new Object[]{ Objects.newIdentity(), new Class<?>[] { IdentityObject.class }},\n-                new Object[]{ array, new Class<?>[] { Cloneable.class, Serializable.class, IdentityObject.class }},\n-                new Object[]{ value, new Class<?>[] { ValueObject.class }},\n+                new Object[]{ new BasicTest(), empty_intfs },\n+                new Object[]{ point, empty_intfs },\n+                new Object[]{ new T(), empty_intfs },\n+                new Object[]{ new C(), empty_intfs },\n+                new Object[]{ Objects.newIdentity(), empty_intfs },\n+                new Object[]{ array, new Class<?>[] { Cloneable.class, Serializable.class }},\n+                new Object[]{ value, empty_intfs },\n@@ -286,7 +287,0 @@\n-        if (type.isValue()) {\n-            assertTrue(ValueObject.class.isAssignableFrom(type));\n-            assertTrue(o instanceof ValueObject);\n-        } else {\n-            assertTrue(IdentityObject.class.isAssignableFrom(type));\n-            assertTrue(o instanceof IdentityObject);\n-        }\n","filename":"test\/jdk\/valhalla\/valuetypes\/BasicTest.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        { anonClasses.put(getClass().getName(), 0); }\n+        { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n@@ -55,1 +55,1 @@\n-            { anonClasses.put(getClass().getName(), 0); }\n+            { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n@@ -63,1 +63,1 @@\n-            { anonClasses.put(getClass().getName(), 0); }\n+            { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n@@ -68,1 +68,1 @@\n-        { anonClasses.put(getClass().getName(), 0); }\n+        { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n@@ -73,1 +73,1 @@\n-            { anonClasses.put(getClass().getName(), 0); }\n+            { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n@@ -81,1 +81,1 @@\n-            { anonClasses.put(getClass().getName(), 0); }\n+            { anonClasses.put(getClass().getName(), ACC_IDENTITY); }\n@@ -106,2 +106,2 @@\n-                   ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM;\n-        int classExpected = (expected & mask) | ACC_SUPER;\n+                   ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM | ACC_IDENTITY;\n+        int classExpected = (expected & mask);\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousClassFlags.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n---- SUPER\n+--- IDENTITY\n@@ -5,1 +5,1 @@\n----\n+--- IDENTITY\n@@ -8,1 +8,1 @@\n---- SUPER\n+--- IDENTITY\n@@ -10,1 +10,1 @@\n---- STATIC\n+--- STATIC IDENTITY\n@@ -13,1 +13,1 @@\n---- SUPER\n+--- IDENTITY\n@@ -15,1 +15,1 @@\n---- PRIVATE\n+--- PRIVATE IDENTITY\n@@ -18,1 +18,1 @@\n---- SUPER\n+--- IDENTITY\n@@ -20,1 +20,1 @@\n---- PRIVATE STATIC\n+--- PRIVATE STATIC IDENTITY\n@@ -23,1 +23,1 @@\n---- FINAL SUPER\n+--- FINAL IDENTITY\n@@ -25,1 +25,1 @@\n---- FINAL\n+--- FINAL IDENTITY\n@@ -28,1 +28,1 @@\n---- FINAL SUPER\n+--- FINAL IDENTITY\n@@ -30,1 +30,1 @@\n---- STATIC FINAL\n+--- STATIC FINAL IDENTITY\n@@ -33,1 +33,1 @@\n---- FINAL SUPER\n+--- FINAL IDENTITY\n@@ -35,1 +35,1 @@\n---- PRIVATE FINAL\n+--- PRIVATE FINAL IDENTITY\n@@ -38,1 +38,1 @@\n---- FINAL SUPER\n+--- FINAL IDENTITY\n@@ -40,1 +40,1 @@\n---- PRIVATE STATIC FINAL\n+--- PRIVATE STATIC FINAL IDENTITY\n@@ -43,1 +43,1 @@\n---- SUPER ABSTRACT\n+--- IDENTITY ABSTRACT\n@@ -45,1 +45,1 @@\n---- ABSTRACT\n+--- IDENTITY ABSTRACT\n@@ -48,1 +48,1 @@\n---- SUPER PERMITS_VALUE ABSTRACT\n+--- ABSTRACT\n@@ -50,1 +50,1 @@\n---- STATIC PERMITS_VALUE ABSTRACT\n+--- STATIC ABSTRACT\n@@ -53,1 +53,1 @@\n---- SUPER ABSTRACT\n+--- IDENTITY ABSTRACT\n@@ -55,1 +55,1 @@\n---- PRIVATE ABSTRACT\n+--- PRIVATE IDENTITY ABSTRACT\n@@ -58,1 +58,1 @@\n---- SUPER PERMITS_VALUE ABSTRACT\n+--- ABSTRACT\n@@ -60,1 +60,1 @@\n---- PRIVATE STATIC PERMITS_VALUE ABSTRACT\n+--- PRIVATE STATIC ABSTRACT\n@@ -63,1 +63,1 @@\n---- PUBLIC SUPER\n+--- PUBLIC IDENTITY\n@@ -65,1 +65,1 @@\n---- PROTECTED\n+--- PROTECTED IDENTITY\n@@ -68,1 +68,1 @@\n---- PUBLIC SUPER\n+--- PUBLIC IDENTITY\n@@ -70,1 +70,1 @@\n---- PROTECTED STATIC\n+--- PROTECTED STATIC IDENTITY\n@@ -73,1 +73,1 @@\n---- PUBLIC SUPER\n+--- PUBLIC IDENTITY\n@@ -75,1 +75,1 @@\n---- PUBLIC\n+--- PUBLIC IDENTITY\n@@ -78,1 +78,1 @@\n---- PUBLIC SUPER\n+--- PUBLIC IDENTITY\n@@ -80,1 +80,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n@@ -83,1 +83,1 @@\n---- PUBLIC FINAL SUPER\n+--- PUBLIC FINAL IDENTITY\n@@ -85,1 +85,1 @@\n---- PROTECTED FINAL\n+--- PROTECTED FINAL IDENTITY\n@@ -88,1 +88,1 @@\n---- PUBLIC FINAL SUPER\n+--- PUBLIC FINAL IDENTITY\n@@ -90,1 +90,1 @@\n---- PROTECTED STATIC FINAL\n+--- PROTECTED STATIC FINAL IDENTITY\n@@ -93,1 +93,1 @@\n---- PUBLIC FINAL SUPER\n+--- PUBLIC FINAL IDENTITY\n@@ -95,1 +95,1 @@\n---- PUBLIC FINAL\n+--- PUBLIC FINAL IDENTITY\n@@ -98,1 +98,1 @@\n---- PUBLIC FINAL SUPER\n+--- PUBLIC FINAL IDENTITY\n@@ -100,1 +100,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -103,1 +103,1 @@\n---- PUBLIC SUPER ABSTRACT\n+--- PUBLIC IDENTITY ABSTRACT\n@@ -105,1 +105,1 @@\n---- PROTECTED ABSTRACT\n+--- PROTECTED IDENTITY ABSTRACT\n@@ -108,1 +108,1 @@\n---- PUBLIC SUPER PERMITS_VALUE ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -110,1 +110,1 @@\n---- PROTECTED STATIC PERMITS_VALUE ABSTRACT\n+--- PROTECTED STATIC ABSTRACT\n@@ -113,1 +113,1 @@\n---- PUBLIC SUPER ABSTRACT\n+--- PUBLIC IDENTITY ABSTRACT\n@@ -115,1 +115,1 @@\n---- PUBLIC ABSTRACT\n+--- PUBLIC IDENTITY ABSTRACT\n@@ -118,1 +118,1 @@\n---- PUBLIC SUPER PERMITS_VALUE ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -120,1 +120,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -203,1 +203,1 @@\n---- SUPER\n+--- IDENTITY\n@@ -237,1 +237,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -239,1 +239,1 @@\n---- PUBLIC ABSTRACT\n+--- PUBLIC IDENTITY ABSTRACT\n@@ -241,1 +241,1 @@\n---- PROTECTED STATIC PERMITS_VALUE ABSTRACT\n+--- PROTECTED STATIC ABSTRACT\n@@ -243,1 +243,1 @@\n---- PROTECTED ABSTRACT\n+--- PROTECTED IDENTITY ABSTRACT\n@@ -245,1 +245,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -247,1 +247,1 @@\n---- PUBLIC FINAL\n+--- PUBLIC FINAL IDENTITY\n@@ -249,1 +249,1 @@\n---- PROTECTED STATIC FINAL\n+--- PROTECTED STATIC FINAL IDENTITY\n@@ -251,1 +251,1 @@\n---- PROTECTED FINAL\n+--- PROTECTED FINAL IDENTITY\n@@ -253,1 +253,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n@@ -255,1 +255,1 @@\n---- PUBLIC\n+--- PUBLIC IDENTITY\n@@ -257,1 +257,1 @@\n---- PROTECTED STATIC\n+--- PROTECTED STATIC IDENTITY\n@@ -259,1 +259,1 @@\n---- PROTECTED\n+--- PROTECTED IDENTITY\n@@ -261,1 +261,1 @@\n---- PRIVATE STATIC PERMITS_VALUE ABSTRACT\n+--- PRIVATE STATIC ABSTRACT\n@@ -263,1 +263,1 @@\n---- PRIVATE ABSTRACT\n+--- PRIVATE IDENTITY ABSTRACT\n@@ -265,1 +265,1 @@\n---- STATIC PERMITS_VALUE ABSTRACT\n+--- STATIC ABSTRACT\n@@ -267,1 +267,1 @@\n---- ABSTRACT\n+--- IDENTITY ABSTRACT\n@@ -269,1 +269,1 @@\n---- PRIVATE STATIC FINAL\n+--- PRIVATE STATIC FINAL IDENTITY\n@@ -271,1 +271,1 @@\n---- PRIVATE FINAL\n+--- PRIVATE FINAL IDENTITY\n@@ -273,1 +273,1 @@\n---- STATIC FINAL\n+--- STATIC FINAL IDENTITY\n@@ -275,1 +275,1 @@\n---- FINAL\n+--- FINAL IDENTITY\n@@ -277,1 +277,1 @@\n---- PRIVATE STATIC\n+--- PRIVATE STATIC IDENTITY\n@@ -279,1 +279,1 @@\n---- PRIVATE\n+--- PRIVATE IDENTITY\n@@ -281,1 +281,1 @@\n---- STATIC\n+--- STATIC IDENTITY\n@@ -283,1 +283,1 @@\n----\n+--- IDENTITY\n@@ -286,1 +286,1 @@\n---- PUBLIC SUPER\n+--- PUBLIC IDENTITY\n@@ -288,1 +288,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n@@ -291,1 +291,1 @@\n---- PUBLIC SUPER\n+--- PUBLIC IDENTITY\n@@ -293,1 +293,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n@@ -296,1 +296,1 @@\n---- PUBLIC SUPER\n+--- PUBLIC IDENTITY\n@@ -298,1 +298,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n@@ -301,1 +301,1 @@\n---- PUBLIC SUPER\n+--- PUBLIC IDENTITY\n@@ -303,1 +303,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n@@ -306,1 +306,1 @@\n---- PUBLIC FINAL SUPER\n+--- PUBLIC FINAL IDENTITY\n@@ -308,1 +308,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -311,1 +311,1 @@\n---- PUBLIC FINAL SUPER\n+--- PUBLIC FINAL IDENTITY\n@@ -313,1 +313,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -316,1 +316,1 @@\n---- PUBLIC FINAL SUPER\n+--- PUBLIC FINAL IDENTITY\n@@ -318,1 +318,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -321,1 +321,1 @@\n---- PUBLIC FINAL SUPER\n+--- PUBLIC FINAL IDENTITY\n@@ -323,1 +323,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -326,1 +326,1 @@\n---- PUBLIC SUPER PERMITS_VALUE ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -328,1 +328,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -331,1 +331,1 @@\n---- PUBLIC SUPER PERMITS_VALUE ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -333,1 +333,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -336,1 +336,1 @@\n---- PUBLIC SUPER PERMITS_VALUE ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -338,1 +338,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -341,1 +341,1 @@\n---- PUBLIC SUPER PERMITS_VALUE ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -343,1 +343,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -404,1 +404,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -406,1 +406,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -408,1 +408,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -410,1 +410,1 @@\n---- PUBLIC STATIC PERMITS_VALUE ABSTRACT\n+--- PUBLIC STATIC ABSTRACT\n@@ -412,1 +412,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -414,1 +414,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -416,1 +416,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -418,1 +418,1 @@\n---- PUBLIC STATIC FINAL\n+--- PUBLIC STATIC FINAL IDENTITY\n@@ -420,1 +420,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n@@ -422,1 +422,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n@@ -424,1 +424,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n@@ -426,1 +426,1 @@\n---- PUBLIC STATIC\n+--- PUBLIC STATIC IDENTITY\n","filename":"test\/langtools\/tools\/javac\/ClassFileModifiers\/ClassModifiers.out","additions":109,"deletions":109,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n---- SUPER\n+--- IDENTITY\n@@ -11,1 +11,1 @@\n---- PUBLIC FINAL SUPER\n+--- PUBLIC FINAL IDENTITY\n@@ -20,1 +20,1 @@\n---- SUPER\n+--- IDENTITY\n@@ -25,1 +25,1 @@\n---- FINAL SUPER\n+--- FINAL IDENTITY\n@@ -34,1 +34,1 @@\n---- SUPER\n+--- IDENTITY\n","filename":"test\/langtools\/tools\/javac\/ClassFileModifiers\/MemberModifiers.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        setInnerOtherModifiers(Modifier.EMPTY, Modifier.ABSTRACT, Modifier.STATIC);\n+        setInnerOtherModifiers(Modifier.EMPTY, Modifier.ABSTRACT, Modifier.STATIC, Modifier.IDENTITY);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerAnnotationsInInnerClassTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        setPrefix(\"class Anonymous { int f; } {new Anonymous() {\");\n+        setPrefix(\"class Anonymous { int f; } {new Anonymous() {\"); \/\/ impose identity to make testing predictable.\n@@ -80,1 +80,1 @@\n-        class2Flags.put(\"1\", new HashSet<>() {});\n+        class2Flags.put(\"1\", new HashSet<>(Arrays.asList(\"ACC_IDENTITY\")));\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesInAnonymousClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-            sb.append(\"class Local { int f; \");\n+            sb.append(\"class Local { int f; \"); \/\/ impose identity to make testing predictable.\n@@ -153,0 +153,1 @@\n+        set.add(\"ACC_IDENTITY\");\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesInLocalClassTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,1 +284,1 @@\n-                sb.append(\"int f;\\n\");\n+                sb.append(\"int f;\\n\"); \/\/ impose identity to make testing predicatable\n@@ -296,1 +296,1 @@\n-                                                \"int f; \" : \"\"; \/\/ inhibit PERMITS_VALUE\n+                                                \"int f; \" : \"\"; \/\/ impose identity to make testing predicatable\n@@ -384,0 +384,1 @@\n+                flags.add(\"ACC_IDENTITY\");\n@@ -421,0 +422,1 @@\n+                flags.add(\"ACC_IDENTITY\");\n@@ -426,0 +428,1 @@\n+                flags.add(\"ACC_IDENTITY\");\n@@ -449,1 +452,2 @@\n-        STATIC(\"static\"), EMPTY(\"\");\n+        STATIC(\"static\"), EMPTY(\"\"),\n+        IDENTITY(\"identity\");\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/innerclasses\/InnerClassesTestBase.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4,2 +4,3 @@\n- * @summary Javac fails to implicitly type abstract classes as implementing IdentityObject\n- * @compile\/fail\/ref=ImplicitIdentityTypeTest.out -XDrawDiagnostics ImplicitIdentityTypeTest.java\n+ * @summary Javac fails to implicitly type abstract classes as having identity\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @run main ImplicitIdentityTypeTest\n@@ -17,0 +18,2 @@\n+import com.sun.tools.classfile.*;\n+\n@@ -32,16 +35,34 @@\n-    void check() {\n-        IdentityObject i;\n-        A a = null;\n-        B b = null;\n-        C c = null;\n-        D d = null;\n-        E e = null;\n-        F f = null;\n-        G g = null;\n-        H h = null;\n-\n-        i = a; \/\/ Error.\n-        i = b; \/\/ Error.\n-\n-        \/\/ The following assignments are kosher.\n-        i = c; i = d; i = e; i = f; i = g; i = h;\n+    public static void main(String [] args) throws Exception {\n+\n+        ClassFile cls = ClassFile.read(ImplicitIdentityTypeTest.class.getResourceAsStream(\"ImplicitIdentityTypeTest$A.class\"));\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n+\n+        cls = ClassFile.read(ImplicitIdentityTypeTest.class.getResourceAsStream(\"ImplicitIdentityTypeTest$B.class\"));\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n+\n+        cls = ClassFile.read(ImplicitIdentityTypeTest.class.getResourceAsStream(\"ImplicitIdentityTypeTest$C.class\"));\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+\n+        cls = ClassFile.read(ImplicitIdentityTypeTest.class.getResourceAsStream(\"ImplicitIdentityTypeTest$D.class\"));\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+\n+        cls = ClassFile.read(ImplicitIdentityTypeTest.class.getResourceAsStream(\"ImplicitIdentityTypeTest$E.class\"));\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+\n+        cls = ClassFile.read(ImplicitIdentityTypeTest.class.getResourceAsStream(\"ImplicitIdentityTypeTest$F.class\"));\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+\n+        cls = ClassFile.read(ImplicitIdentityTypeTest.class.getResourceAsStream(\"ImplicitIdentityTypeTest$G.class\"));\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+\n+        cls = ClassFile.read(ImplicitIdentityTypeTest.class.getResourceAsStream(\"ImplicitIdentityTypeTest$H.class\"));\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ImplicitIdentityTypeTest.java","additions":39,"deletions":18,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-ImplicitIdentityTypeTest.java:43:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ImplicitIdentityTypeTest.A, java.lang.IdentityObject)\n-ImplicitIdentityTypeTest.java:44:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ImplicitIdentityTypeTest.B, java.lang.IdentityObject)\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ImplicitIdentityTypeTest.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8237955\n- * @summary Identity types that have no declaration sites fail to be IdentityObjects\n- * @run main\/othervm InstanceOfTopTypeTest\n- *\/\n-\n-public class InstanceOfTopTypeTest {\n-    static primitive class V {\n-        int x = 42;\n-    }\n-\n-    public static void main(String [] args) {\n-        int points = 0;\n-        Object o = new InstanceOfTopTypeTest();\n-        if (o instanceof IdentityObject)\n-            points++;     \/\/ 1\n-        if (o instanceof ValueObject)\n-            throw new AssertionError(\"Broken\");\n-        o = new V();\n-        if (o instanceof IdentityObject)\n-            throw new AssertionError(\"Broken\");\n-        if (o instanceof ValueObject)\n-            points++; \/\/ 2\n-        Object [] oa = new InstanceOfTopTypeTest[] { new InstanceOfTopTypeTest() };\n-        if (oa instanceof IdentityObject)\n-            points++; \/\/ 3\n-        if (oa[0] instanceof IdentityObject)\n-            points++; \/\/ 4\n-        if (oa[0] instanceof ValueObject)\n-            throw new AssertionError(\"Broken\");\n-        oa = new V[] { new V() };\n-        if (oa instanceof IdentityObject)\n-            points++; \/\/ 5\n-        if (oa[0] instanceof IdentityObject)\n-            throw new AssertionError(\"Broken\");\n-        if (oa[0] instanceof ValueObject)\n-            points++; \/\/ 6\n-        if (points != 6)\n-            throw new AssertionError(\"Broken top type set up \" + points);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InstanceOfTopTypeTest.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -50,1 +50,1 @@\n-              \"  flags: (0x0930) ACC_FINAL, ACC_SUPER, ACC_PRIMITIVE, ACC_VALUE\",\n+              \"  flags: (0x0850) ACC_FINAL, ACC_PRIMITIVE, ACC_VALUE\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/QTypeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/**\n- * @test \/nodynamiccopyright\/\n- * @bug 8237069\n- * @summary Introduce and wire-in the new top interfaces\n- * @compile\/fail\/ref=TopInterfaceNegativeTest.out -XDrawDiagnostics TopInterfaceNegativeTest.java\n- *\/\n-\n-public class TopInterfaceNegativeTest  {\n-\n-    interface ID extends IdentityObject {}\n-    interface II extends InlineObject {}\n-\n-    interface IID0 extends IdentityObject, IdentityObject {}\n-    interface IID1 extends IdentityObject, InlineObject {}\n-    interface IID2 extends IdentityObject, II {}\n-    interface IID3 extends IdentityObject, ID {}\n-    interface IID4 extends InlineObject, II {}\n-    interface IID5 extends ID, II {}\n-\n-    static class C1 implements InlineObject {}\n-    static class C2 implements II {}\n-    static class C3 implements IdentityObject {}\n-    static class C4 implements ID {}\n-    static class C5 implements IdentityObject, IdentityObject {}\n-    static class C6 implements IdentityObject, ID {}\n-    static class C7 implements II, ID {}\n-\n-    static primitive class V1 implements IdentityObject { int x = 0; }\n-    static primitive class V2 implements InlineObject {}\n-    static primitive class V3 implements InlineObject, InlineObject  {}\n-\n-    void foo(V2 v) {\n-        if (v instanceof IdentityObject)\n-            throw new AssertionError(\"Expected inline object but found identity object\");\n-    }\n-    abstract class abs implements IdentityObject {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TopInterfaceNegativeTest.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-TopInterfaceNegativeTest.java:29:42: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)\n-TopInterfaceNegativeTest.java:11:26: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)\n-TopInterfaceNegativeTest.java:13:44: compiler.err.repeated.interface\n-TopInterfaceNegativeTest.java:14:44: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)\n-TopInterfaceNegativeTest.java:17:28: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)\n-TopInterfaceNegativeTest.java:20:32: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)\n-TopInterfaceNegativeTest.java:24:48: compiler.err.repeated.interface\n-TopInterfaceNegativeTest.java:30:42: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)\n-TopInterfaceNegativeTest.java:30:56: compiler.err.cant.resolve.location: kindname.class, InlineObject, , , (compiler.misc.location: kindname.class, TopInterfaceNegativeTest, null)\n-TopInterfaceNegativeTest.java:28:22: compiler.err.value.class.must.not.implement.identity.object: TopInterfaceNegativeTest.V1\n-TopInterfaceNegativeTest.java:33:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TopInterfaceNegativeTest.V2, java.lang.IdentityObject)\n-11 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TopInterfaceNegativeTest.out","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8237069\n- * @summary Introduce and wire-in the new top interfaces\n- * @run main\/othervm TopInterfaceTest\n- *\/\n-\n-public class TopInterfaceTest  {\n-\n-    static class C {}\n-\n-    static primitive class V {\n-        int x = 42;\n-    }\n-\n-    interface I {\n-    }\n-\n-    @interface A {\n-    }\n-\n-    public static void main(String args[]) {\n-\n-        V inln_o = new V();\n-        C id_o = new C();\n-\n-\n-        Class<?> [] ca = inln_o.getClass().getInterfaces();\n-        if (ca.length != 1 || !ca[0].getCanonicalName().equals(\"java.lang.ValueObject\"))\n-            throw new AssertionError(\"Found wrong super interfaces\");\n-\n-        \/\/ Check that V's super class is Object in class file.\n-        Class<?> jlo = inln_o.getClass().getSuperclass();\n-        if (!jlo.getCanonicalName().equals(\"java.lang.Object\"))\n-            throw new AssertionError(\"Wrong super type for value type\");\n-        if (jlo.getInterfaces().length != 0)\n-            throw new AssertionError(\"Wrong number of super interfaces for jlO\");\n-\n-        if (!(id_o instanceof IdentityObject))\n-            throw new AssertionError(\"Expected identity Object\");\n-\n-\n-\n-        \/\/ Check that no super interface injection has happened for interfaces.\n-        if (I.class.getInterfaces().length != 0)\n-            throw new AssertionError(\"Found extraneous super interfaces\");\n-\n-        \/\/ Check that no super interface injection has happened for annotation types.\n-        ca = A.class.getInterfaces();\n-        if (ca.length != 1)\n-            throw new AssertionError(\"Found extraneous super interfaces\");\n-        if (!ca[0].getCanonicalName().equals(\"java.lang.annotation.Annotation\"))\n-            throw new AssertionError(\"Found wrong super interfaces\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TopInterfaceTest.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237955\n- * @summary Identity types that have no declaration sites fail to be IdentityObjects\n- * @compile -XDrawDiagnostics UndeclaredIdentityObjectsTest.java\n- *\/\n-\n-public class UndeclaredIdentityObjectsTest {\n-    static class G<T> {}\n-    public static void main(String [] args) {\n-        Object [] oa = new UndeclaredIdentityObjectsTest[] {\n-                                new UndeclaredIdentityObjectsTest()\n-                       };\n-        if (!(oa instanceof IdentityObject))\n-            throw new AssertionError(\"Arrays are broken\");\n-        Object o = new G<String>();\n-        if (!(o instanceof IdentityObject))\n-            throw new AssertionError(\"Parameterized type are broken\");\n-        if (!(oa[0] instanceof IdentityObject)) \/\/ can only be determined at runtime\n-            System.out.println(\"Arrays are broken!\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UndeclaredIdentityObjectsTest.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -47,1 +47,1 @@\n-        if (superInterfaces.length != 2)\n+        if (superInterfaces.length != 1)\n@@ -52,2 +52,0 @@\n-        if (!superInterfaces[1].equals(ValueObject.class))\n-            throw new AssertionError(\"Wrong super interfaces for UnifiedPrimitiveClassNestHostTest\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/UnifiedPrimitiveClassNestHostTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9,2 +9,2 @@\n-    value interface I { int x = 10; } \/\/ Error\n-    value abstract class A { int x = 10; } \/\/ Error\n+    value interface I { int x = 10; }\n+    value abstract class A { int x = 10; }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckMakeDefault.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-CheckMakeDefault.java:9:11: compiler.err.illegal.combination.of.modifiers: interface, value\n-CheckMakeDefault.java:10:20: compiler.err.illegal.combination.of.modifiers: abstract, value\n@@ -13,1 +11,1 @@\n-12 errors\n+10 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckMakeDefault.out","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Javac should verify\/ensure that a Functional interface implements neither IdentityObject nor ValueObject\n+ * @summary Javac should verify\/ensure that a Functional interface proclaims neither identity nor valueness\n@@ -11,1 +11,1 @@\n-    interface I extends IdentityObject  { \/\/ Error\n+    identity interface I { \/\/ Error\n@@ -19,1 +19,1 @@\n-    interface K extends ValueObject  { \/\/ Error\n+    value interface K { \/\/ Error\n@@ -23,1 +23,1 @@\n-    interface L extends IdentityObject {\n+    identity interface L {\n@@ -27,1 +27,1 @@\n-    interface M extends ValueObject {\n+    value interface M {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FunctionalInterfaceTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,5 +1,5 @@\n-FunctionalInterfaceTest.java:10:5: compiler.err.bad.functional.intf.anno.1: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.I, (compiler.misc.may.not.extend.top.interface.type: java.lang.IdentityObject))\n-FunctionalInterfaceTest.java:15:5: compiler.err.bad.functional.intf.anno.1: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.J, (compiler.misc.may.not.extend.top.interface.type: java.lang.IdentityObject))\n-FunctionalInterfaceTest.java:18:5: compiler.err.bad.functional.intf.anno.1: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.K, (compiler.misc.may.not.extend.top.interface.type: java.lang.ValueObject))\n-FunctionalInterfaceTest.java:32:21: compiler.err.prob.found.req: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.L, (compiler.misc.may.not.extend.top.interface.type: java.lang.IdentityObject))\n-FunctionalInterfaceTest.java:33:21: compiler.err.prob.found.req: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.M, (compiler.misc.may.not.extend.top.interface.type: java.lang.ValueObject))\n+FunctionalInterfaceTest.java:10:5: compiler.err.bad.functional.intf.anno.1: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.I, (compiler.misc.identity.interface.nonfunctional))\n+FunctionalInterfaceTest.java:15:5: compiler.err.bad.functional.intf.anno.1: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.J, (compiler.misc.identity.interface.nonfunctional))\n+FunctionalInterfaceTest.java:18:5: compiler.err.bad.functional.intf.anno.1: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.K, (compiler.misc.value.interface.nonfunctional))\n+FunctionalInterfaceTest.java:32:21: compiler.err.prob.found.req: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.L, (compiler.misc.identity.interface.nonfunctional))\n+FunctionalInterfaceTest.java:33:21: compiler.err.prob.found.req: (compiler.misc.not.a.functional.intf.1: FunctionalInterfaceTest.M, (compiler.misc.value.interface.nonfunctional))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FunctionalInterfaceTest.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @summary Abstract classes that allow value subclasses should be marked ACC_PERMITS_VALUE (0x0040)\n+ * @summary Abstract classes that allow value subclasses should NOT be marked ACC_IDENTITY\n@@ -39,1 +39,1 @@\n-       \/\/ Not ACC_PERMITS_VALUE as it extends an identity class.\n+       \/\/ ACC_IDENTITY as it extends an identity class.\n@@ -42,2 +42,2 @@\n-    static abstract class A1 implements IdentityObject {\n-       \/\/ Not ACC_PERMITS_VALUE as it implements IdentityObject\n+    static abstract identity class A1 {\n+       \/\/ ACC_IDENTITY\n@@ -47,1 +47,1 @@\n-        int f; \/\/ Not ACC_PERMITS_VALUE as it declares an instance field.\n+        int f; \/\/ ACC_IDENTITY as it declares an instance field.\n@@ -51,1 +51,1 @@\n-        \/\/ Not ACC_PERMITS_VALUE as it extends an implicit identity class.\n+        \/\/ ACC_IDENTITY as it extends an implicit identity class.\n@@ -55,1 +55,1 @@\n-        \/\/ Not ACC_PERMITS_VALUE as it declares a non-empty initializer block.\n+        \/\/ ACC_IDENTITY as it declares a non-empty initializer block.\n@@ -62,1 +62,1 @@\n-        \/\/ Not ACC_PERMITS_VALUE as it extends an implicit identity class.\n+        \/\/ ACC_IDENTITY as it extends an implicit identity class.\n@@ -66,1 +66,1 @@\n-        \/\/ Not ACC_PERMITS_VALUE as declares a synchronized method.\n+        \/\/ ACC_IDENTITY as declares a synchronized method.\n@@ -72,1 +72,1 @@\n-        \/\/ Not ACC_PERMITS_VALUE as it extends an implicit identity class.\n+        \/\/ ACC_IDENTITY as it extends an implicit identity class.\n@@ -76,1 +76,1 @@\n-        \/\/ Not ACC_PERMITS_VALUE as it is an inner class\n+        \/\/ ACC_IDENTITY as it is an inner class\n@@ -80,1 +80,1 @@\n-        \/\/ Not ACC_PERMITS_VALUE as it defines a arg'ed constructor.\n+        \/\/ ACC_IDENTITY as it defines a arg'ed constructor.\n@@ -85,1 +85,1 @@\n-        \/\/ ACC_PERMITS_VALUE as its constructor is deemed empty due to mere vacuous chaining.\n+        \/\/ !ACC_IDENTITY as its constructor is deemed empty due to mere vacuous chaining.\n@@ -91,1 +91,1 @@\n-        \/\/ Not ACC_PERMITS_VALUE as it defines a non empty constructor.\n+        \/\/ ACC_IDENTITY as it defines a non empty constructor.\n@@ -97,1 +97,1 @@\n-    static abstract class A11 { \/\/ Permits value.\n+    static abstract class A11 { \/\/ !ACC_IDENTITY.\n@@ -113,2 +113,2 @@\n-    static abstract class A12 extends A11 implements ValueObject {\n-        \/\/ Permits value\n+    static abstract value class A12 extends A11 {\n+        \/\/ !ACC_IDENTITY\n@@ -118,1 +118,1 @@\n-        \/\/ Permits value\n+        \/\/ !ACC_IDENTITY\n@@ -124,2 +124,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -128,2 +128,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -132,2 +132,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -136,2 +136,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -140,2 +140,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -144,2 +144,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -148,2 +148,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -152,2 +152,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -156,2 +156,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -160,2 +160,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -164,2 +164,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should be set!\");\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n@@ -167,2 +167,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -171,1 +171,1 @@\n-        \/\/ The following are all proper ACC_PERMITS_VALUE classes\n+        \/\/ The following are all proper non-identity classes\n@@ -173,2 +173,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should be set!\");\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n@@ -177,2 +177,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should be set!\");\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n@@ -181,2 +181,2 @@\n-        if (!cls.access_flags.is(AccessFlags.ACC_PERMITS_VALUE))\n-            throw new Exception(\"ACC_PERMITS_VALUE flag should be set!\");\n+        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/PermitsValueTest.java","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -38,3 +38,3 @@\n-    \/\/ The class does not implement—directly or indirectly—IdentityObject.\n-    \/\/ This implies that the superclass is either Object or a stateless abstract class.\n-    value class IdentityValue implements IdentityObject { \/\/ Error, can't implement this\n+\n+    \/\/ A value identity class is an oxymoron\n+    value identity class IdentityValue { \/\/ Error, bad modifier combination.\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SemanticsViolationsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,2 +1,1 @@\n-SemanticsViolationsTest.java:16:20: compiler.err.illegal.combination.of.modifiers: abstract, value\n-SemanticsViolationsTest.java:17:11: compiler.err.illegal.combination.of.modifiers: interface, value\n+SemanticsViolationsTest.java:40:20: compiler.err.illegal.combination.of.modifiers: identity, value\n@@ -6,1 +5,0 @@\n-SemanticsViolationsTest.java:12:5: compiler.err.identity.class.must.not.implement.value.object: SemanticsViolationsTest.Subclass\n@@ -9,1 +7,0 @@\n-SemanticsViolationsTest.java:40:11: compiler.err.value.class.must.not.implement.identity.object: SemanticsViolationsTest.IdentityValue\n@@ -18,1 +15,1 @@\n-17 errors\n+14 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/SemanticsViolationsTest.out","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4,2 +4,1 @@\n-ValueAnnotationTest.java:11:12: compiler.err.identity.class.must.not.implement.value.object: ValueAnnotationTest.Z\n-4 errors\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueAnnotationTest.out","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-         \"flags: (0x0130) ACC_FINAL, ACC_SUPER, ACC_VALUE\",\n+         \"flags: (0x0050) ACC_FINAL, ACC_VALUE\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueCreationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-               \"flags: (0x4030) ACC_FINAL, ACC_SUPER, ACC_ENUM\",\n+               \"flags: (0x4030) ACC_FINAL, ACC_IDENTITY, ACC_ENUM\",\n","filename":"test\/langtools\/tools\/javap\/4870651\/T4870651.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        \"public class JavapTaskCtorFailWithNPE {\\n\" +\n+        \"public identity class JavapTaskCtorFailWithNPE {\\n\" +\n","filename":"test\/langtools\/tools\/javap\/8006334\/JavapTaskCtorFailWithNPE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        verify(E.class.getName(),    \"flags: \\\\(0x4030\\\\) ACC_FINAL, ACC_SUPER, ACC_ENUM\");\n+        verify(E.class.getName(),    \"flags: \\\\(0x4030\\\\) ACC_FINAL, ACC_IDENTITY, ACC_ENUM\");\n","filename":"test\/langtools\/tools\/javap\/T4975569.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-                  \"#CK Test#GK #EK { }\\n\"\n+                  \"identity #CK Test#GK #EK { }\\n\"\n","filename":"test\/langtools\/tools\/javap\/TestSuperclass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    int ACC_PERMITS_VALUE = 0x0040; \/\/ class, inner\n+    int ACC_VALUE         = 0x0040; \/\/ class, inner\n@@ -50,1 +50,1 @@\n-    int ACC_VALUE         = 0x0100; \/\/ class, inner\n+    int ACC_PERMITS_VALUE = 0x0100; \/\/ class, inner\n","filename":"test\/lib\/org\/openjdk\/asmtools\/jasm\/RuntimeConstants.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}