{"files":[{"patch":"@@ -272,1 +272,1 @@\n-  $1_FLAGS += -g -Xlint:all $$($1_TARGET_RELEASE) $$(PARANOIA_FLAGS) $$(JAVA_WARNINGS_ARE_ERRORS)\n+  $1_FLAGS += -g -XDenablePrimitiveClasses -Xlint:all $$($1_TARGET_RELEASE) $$(PARANOIA_FLAGS) $$(JAVA_WARNINGS_ARE_ERRORS)\n","filename":"make\/common\/JavaCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5152,1 +5152,5 @@\n-  VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+  \/\/FIXME: VectorPayload class no longer holds the Object payload.\n+  \/\/Multi-field based payloads have been moved to leaf level\n+  \/\/concrete classes. Offset recorded here is used for object\n+  \/\/re-construction during de-opt.\n+  \/\/ VECTORPAYLOAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,0 +194,7 @@\n+  \/* support multi-field based vectors *\/                                                                       \\\n+  do_klass(vector_VectorPayloadMF64_klass,              jdk_internal_vm_vector_VectorPayloadMF64              ) \\\n+  do_klass(vector_VectorPayloadMF128_klass,             jdk_internal_vm_vector_VectorPayloadMF128             ) \\\n+  do_klass(vector_VectorPayloadMF256_klass,             jdk_internal_vm_vector_VectorPayloadMF256             ) \\\n+  do_klass(vector_VectorPayloadMF512_klass,             jdk_internal_vm_vector_VectorPayloadMF512             ) \\\n+                                                                                                                \\\n+                                                                                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-\/\/ Mapping function names to values. New entries should be added below.\n@@ -53,0 +52,1 @@\n+\/\/ Mapping function names to values. New entries should be added below.\n@@ -97,3 +97,7 @@\n-  template(payload_name,                              \"payload\")                                            \\\n-  template(ETYPE_name,                                \"ETYPE\")                                              \\\n-  template(VLENGTH_name,                              \"VLENGTH\")                                            \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512\") \\\n+  template(payload_name,                              \"payload\")                                  \\\n+  template(ETYPE_name,                                \"ETYPE\")                                    \\\n+  template(VLENGTH_name,                              \"VLENGTH\")                                  \\\n@@ -268,0 +272,6 @@\n+  \/* VectorAPI support *\/                                                                         \\\n+  template(vector_VectorPayloadMF64_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64;\")  \\\n+  template(vector_VectorPayloadMF128_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128;\") \\\n+  template(vector_VectorPayloadMF256_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256;\") \\\n+  template(vector_VectorPayloadMF512_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512;\") \\\n+                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -29,0 +30,1 @@\n+import jdk.internal.vm.annotation.MultiField;\n@@ -31,0 +33,1 @@\n+\n@@ -32,0 +35,1 @@\n+import java.lang.reflect.*;\n@@ -151,1 +155,7 @@\n-    public static class VectorSpecies<E> {}\n+    public static class VectorSpecies<E> { }\n+\n+    public abstract static class VectorPayload {\n+        protected abstract Object getPayload();\n+    }\n+\n+    public static abstract class Vector<E> extends VectorPayload { }\n@@ -153,1 +163,1 @@\n-    public static class VectorPayload {\n+    public static class VectorShuffle<E> extends VectorPayload {\n@@ -156,1 +166,4 @@\n-        public VectorPayload(Object payload) {\n+        protected final Object getPayload() {\n+            return VectorSupport.maybeRebox(this).payload;\n+        }\n+        public VectorShuffle(Object payload) {\n@@ -159,0 +172,4 @@\n+    }\n+\n+    public static class VectorMask<E> extends VectorPayload {\n+        private final Object payload; \/\/ array of primitives\n@@ -163,0 +180,3 @@\n+        public VectorMask(Object payload) {\n+            this.payload = payload;\n+        }\n@@ -165,3 +185,14 @@\n-    public static class Vector<E> extends VectorPayload {\n-        public Vector(Object payload) {\n-            super(payload);\n+    public abstract static class VectorPayloadMF {\n+        public abstract long multiFieldOffset();\n+\n+        private static VectorPayloadMF newInstanceFactory(int elemSize, int length)  {\n+            VectorPayloadMF obj = null;\n+            int vecSize = elemSize * length;\n+            switch(vecSize) {\n+                case 8: obj = new VectorPayloadMF64(); break;\n+                case 16: obj = new VectorPayloadMF128(); break;\n+                case 32: obj = new VectorPayloadMF256(); break;\n+                case 64: obj = new VectorPayloadMF512(); break;\n+                default: assert false : \"Unhandled vector size\";\n+            }\n+            return obj;\n@@ -169,1 +200,0 @@\n-    }\n@@ -171,3 +201,2 @@\n-    public static class VectorShuffle<E> extends VectorPayload {\n-        public VectorShuffle(Object payload) {\n-            super(payload);\n+        public static VectorPayloadMF createVectPayloadInstance(int elemSize, int length) {\n+            return newInstanceFactory(elemSize, length);\n@@ -175,4 +204,21 @@\n-    }\n-    public static class VectorMask<E> extends VectorPayload {\n-        public VectorMask(Object payload) {\n-            super(payload);\n+\n+        public static VectorPayloadMF createVectPayloadInstanceB(int elemSize, int length, byte [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putByte(obj, start_offset + i * Byte.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public static VectorPayloadMF createVectPayloadInstanceS(int elemSize, int length, short [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putShort(obj, start_offset + i * Short.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n@@ -180,0 +226,105 @@\n+\n+        public static VectorPayloadMF createVectPayloadInstanceI(int elemSize, int length, int [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putInt(obj, start_offset + i * Integer.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public static VectorPayloadMF createVectPayloadInstanceL(int elemSize, int length, long [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putLong(obj, start_offset + i * Long.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public static VectorPayloadMF createVectPayloadInstanceF(int elemSize, int length, float [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putFloat(obj, start_offset + i * Float.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public static VectorPayloadMF createVectPayloadInstanceD(int elemSize, int length, double [] init) {\n+            VectorPayloadMF obj = newInstanceFactory(elemSize, length);\n+            long start_offset = obj.multiFieldOffset();\n+            obj = Unsafe.getUnsafe().makePrivateBuffer(obj);\n+            for (int i = 0; i < length; i++) {\n+                Unsafe.getUnsafe().putDouble(obj, start_offset + i * Double.BYTES, init[i]);\n+            }\n+            obj = Unsafe.getUnsafe().finishPrivateBuffer(obj);\n+            return obj;\n+        }\n+\n+        public int length(int elemSize) {\n+            try {\n+                var field = this.getClass().getDeclaredField(\"mfield\");\n+                var msanno = field.getAnnotationsByType(MultiField.class);\n+\n+                Objects.nonNull(msanno);\n+\n+                assert msanno.length == 1;\n+                return msanno[0].value() \/ elemSize;\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            return -1;\n+        }\n+\n+        public static long multiFieldOffset(Class<? extends VectorPayloadMF> cls) {\n+            try {\n+                var field = cls.getDeclaredField(\"mfield\");\n+                return Unsafe.getUnsafe().objectFieldOffset(field);\n+            } catch (Exception e) {\n+                System.out.println(e);\n+            }\n+            return -1L;\n+        }\n+    }\n+\n+    public primitive static class VectorPayloadMF64 extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF128 extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF256 extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n+    }\n+\n+    public primitive static class VectorPayloadMF512 extends VectorPayloadMF {\n+        @MultiField(value = 64)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET;}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":165,"deletions":14,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.vm.vector.VectorSupport;\n@@ -36,1 +37,2 @@\n-abstract class AbstractSpecies<E> extends jdk.internal.vm.vector.VectorSupport.VectorSpecies<E>\n+\n+abstract class AbstractSpecies<E> extends VectorSupport.VectorSpecies<E>\n@@ -114,0 +116,2 @@\n+    @Stable \/\/lazy JIT constant\n+    AbstractVector<E> dummyVectorMF;\n@@ -313,0 +317,10 @@\n+    @ForceInline\n+    \/*package-private*\/\n+    AbstractVector<E> dummyVectorMF() {\n+        \/\/ This JITs to a constant value:\n+        AbstractVector<E> dummy = dummyVectorMF;\n+        if (dummy != null)  return dummy;\n+        \/\/ The rest of this computation is probably not JIT-ted.\n+        return makeDummyVectorMF();\n+    }\n+\n@@ -321,0 +335,48 @@\n+    VectorSupport.VectorPayloadMF createVectorMF(Object initarr) {\n+        VectorSupport.VectorPayloadMF za = null;\n+        switch (laneType.switchKey) {\n+        case LaneType.SK_FLOAT:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceF(elementByteSize(), laneCount, (float[])initarr);\n+            break;\n+        case LaneType.SK_DOUBLE:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceD(elementByteSize(), laneCount, (double[])initarr);\n+            break;\n+        case LaneType.SK_BYTE:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceB(elementByteSize(), laneCount, (byte[])initarr);\n+            break;\n+        case LaneType.SK_SHORT:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceS(elementByteSize(), laneCount, (short[])initarr);\n+            break;\n+        case LaneType.SK_INT:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceI(elementByteSize(), laneCount, (int[])initarr);\n+            break;\n+        case LaneType.SK_LONG:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstanceL(elementByteSize(), laneCount, (long[])initarr);\n+            break;\n+        default:\n+            assert false : \"Unsupported elemType in createVectorMF\";\n+            break;\n+        }\n+        return za;\n+    }\n+\n+    private AbstractVector<E> makeDummyVectorMF() {\n+        Object za = null;\n+        switch (laneType.switchKey) {\n+        case LaneType.SK_FLOAT:\n+        case LaneType.SK_DOUBLE:\n+        case LaneType.SK_BYTE:\n+        case LaneType.SK_SHORT:\n+        case LaneType.SK_INT:\n+        case LaneType.SK_LONG:\n+            za = VectorSupport.VectorPayloadMF.createVectPayloadInstance(elementByteSize(), laneCount);\n+            break;\n+        default:\n+            assert false : \"Unsupported elemType in makeDummyVectorMF\";\n+            break;\n+        }\n+        return dummyVector = vectorFactory.apply(za);\n+        \/\/ This is the only use of vectorFactory.\n+        \/\/ All other factory requests are routed\n+        \/\/ through the dummy vector.\n+    }\n@@ -328,1 +390,1 @@\n-        return dummyVector().maskFromArray(bits);\n+        return dummyVectorMF().maskFromArray(bits);\n@@ -335,1 +397,1 @@\n-        return dummyVector().shuffleFromArray(sourceIndexes, offset);\n+        return dummyVectorMF().shuffleFromArray(sourceIndexes, offset);\n@@ -342,1 +404,1 @@\n-        return dummyVector().shuffleFromArray(sourceIndexes, 0);\n+        return dummyVectorMF().shuffleFromArray(sourceIndexes, 0);\n@@ -349,1 +411,1 @@\n-        return dummyVector().shuffleFromOp(fn);\n+        return dummyVectorMF().shuffleFromOp(fn);\n@@ -358,1 +420,1 @@\n-            return dummyVector().iotaShuffle();\n+            return dummyVectorMF().iotaShuffle();\n@@ -360,1 +422,1 @@\n-            return dummyVector().iotaShuffle(start, step, wrap);\n+            return dummyVectorMF().iotaShuffle(start, step, wrap);\n@@ -455,1 +517,1 @@\n-    abstract AbstractVector<E> rvOp(RVOp f);\n+    abstract AbstractVector<E> rvOpMF(RVOp f);\n@@ -467,1 +529,1 @@\n-        return dummyVector().maskFromArray(res);\n+        return dummyVectorMF().maskFromArray(res);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":71,"deletions":9,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-@SuppressWarnings(\"cast\")\n+@SuppressWarnings({\"cast\", \"missing-explicit-ctor\"})\n@@ -71,5 +71,0 @@\n-    \/*package-private*\/\n-    AbstractVector(Object bits) {\n-        super(bits);\n-    }\n-\n@@ -81,0 +76,3 @@\n+    \/*package-private*\/\n+    abstract long multiFieldOffset();\n+\n@@ -702,2 +700,2 @@\n-            rvtype = rspi.dummyVector().getClass();\n-            vtype = vspi.dummyVector().getClass();\n+            rvtype = rspi.dummyVectorMF().getClass();\n+            vtype = vspi.dummyVectorMF().getClass();\n@@ -716,1 +714,1 @@\n-            rvtype = rsp.dummyVector().getClass();  \/\/ (profile)\n+            rvtype = rsp.dummyVectorMF().getClass();  \/\/ (profile)\n@@ -728,1 +726,1 @@\n-            rvtype = rsp.dummyVector().getClass();  \/\/ (profile)\n+            rvtype = rsp.dummyVectorMF().getClass();  \/\/ (profile)\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Byte128Vector extends ByteVector {\n+value class Byte128Vector extends ByteVector {\n@@ -57,2 +58,10 @@\n-    Byte128Vector(byte[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+\n+    private final VectorSupport.VectorPayloadMF128 payload;\n+\n+    Byte128Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Byte128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Byte128Vector(Object v) {\n-        this((byte[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Byte128Vector ZERO = new Byte128Vector(new byte[VLENGTH]);\n-    static final Byte128Vector IOTA = new Byte128Vector(VSPECIES.iotaArray());\n+    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 16));\n+    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 16, (byte [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Byte128Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Byte128Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Byte128Vector uOp(FUnOp f) {\n-        return (Byte128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Byte128Vector uOpMF(FUnOp f) {\n+        return (Byte128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Byte128Vector uOp(VectorMask<Byte> m, FUnOp f) {\n+    Byte128Vector uOpMF(VectorMask<Byte> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Byte128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Byte128Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Byte128Vector bOp(Vector<Byte> v, FBinOp f) {\n-        return (Byte128Vector) super.bOpTemplate((Byte128Vector)v, f);  \/\/ specialize\n+    Byte128Vector bOpMF(Vector<Byte> v, FBinOp f) {\n+        return (Byte128Vector) super.bOpTemplateMF((Byte128Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Byte128Vector bOp(Vector<Byte> v,\n+    Byte128Vector bOpMF(Vector<Byte> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Byte128Vector)v, (Byte128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Byte128Vector)v, (Byte128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Byte128Vector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n+    Byte128Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Byte128Vector)v1, (Byte128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte128Vector)v1, (Byte128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Byte128Vector tOp(Vector<Byte> v1, Vector<Byte> v2,\n+    Byte128Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Byte128Vector)v1, (Byte128Vector)v2,\n-                              (Byte128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte128Vector)v1, (Byte128Vector)v2,\n+                                (Byte128Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -536,6 +555,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getByte(vecpayload, start_offset + ix * Byte.BYTES);\n+                             });\n@@ -569,1 +589,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -573,3 +593,6 @@\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putByte(tpayload, start_offset + ix * Byte.BYTES, (byte)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Byte256Vector extends ByteVector {\n+value class Byte256Vector extends ByteVector {\n@@ -57,2 +58,10 @@\n-    Byte256Vector(byte[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+\n+    private final VectorSupport.VectorPayloadMF256 payload;\n+\n+    Byte256Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Byte256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Byte256Vector(Object v) {\n-        this((byte[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Byte256Vector ZERO = new Byte256Vector(new byte[VLENGTH]);\n-    static final Byte256Vector IOTA = new Byte256Vector(VSPECIES.iotaArray());\n+    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 32));\n+    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 32, (byte [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Byte256Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Byte256Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Byte256Vector uOp(FUnOp f) {\n-        return (Byte256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Byte256Vector uOpMF(FUnOp f) {\n+        return (Byte256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Byte256Vector uOp(VectorMask<Byte> m, FUnOp f) {\n+    Byte256Vector uOpMF(VectorMask<Byte> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Byte256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Byte256Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Byte256Vector bOp(Vector<Byte> v, FBinOp f) {\n-        return (Byte256Vector) super.bOpTemplate((Byte256Vector)v, f);  \/\/ specialize\n+    Byte256Vector bOpMF(Vector<Byte> v, FBinOp f) {\n+        return (Byte256Vector) super.bOpTemplateMF((Byte256Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Byte256Vector bOp(Vector<Byte> v,\n+    Byte256Vector bOpMF(Vector<Byte> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Byte256Vector)v, (Byte256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Byte256Vector)v, (Byte256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Byte256Vector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n+    Byte256Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Byte256Vector)v1, (Byte256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte256Vector)v1, (Byte256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Byte256Vector tOp(Vector<Byte> v1, Vector<Byte> v2,\n+    Byte256Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Byte256Vector)v1, (Byte256Vector)v2,\n-                              (Byte256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte256Vector)v1, (Byte256Vector)v2,\n+                                (Byte256Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -552,6 +571,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getByte(vecpayload, start_offset + ix * Byte.BYTES);\n+                             });\n@@ -601,1 +621,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -605,3 +625,6 @@\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putByte(tpayload, start_offset + ix * Byte.BYTES, (byte)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Byte512Vector extends ByteVector {\n+value class Byte512Vector extends ByteVector {\n@@ -57,2 +58,10 @@\n-    Byte512Vector(byte[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+\n+    private final VectorSupport.VectorPayloadMF512 payload;\n+\n+    Byte512Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Byte512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Byte512Vector(Object v) {\n-        this((byte[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Byte512Vector ZERO = new Byte512Vector(new byte[VLENGTH]);\n-    static final Byte512Vector IOTA = new Byte512Vector(VSPECIES.iotaArray());\n+    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 64));\n+    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 64, (byte [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Byte512Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Byte512Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Byte512Vector uOp(FUnOp f) {\n-        return (Byte512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Byte512Vector uOpMF(FUnOp f) {\n+        return (Byte512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Byte512Vector uOp(VectorMask<Byte> m, FUnOp f) {\n+    Byte512Vector uOpMF(VectorMask<Byte> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Byte512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Byte512Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Byte512Vector bOp(Vector<Byte> v, FBinOp f) {\n-        return (Byte512Vector) super.bOpTemplate((Byte512Vector)v, f);  \/\/ specialize\n+    Byte512Vector bOpMF(Vector<Byte> v, FBinOp f) {\n+        return (Byte512Vector) super.bOpTemplateMF((Byte512Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Byte512Vector bOp(Vector<Byte> v,\n+    Byte512Vector bOpMF(Vector<Byte> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Byte512Vector)v, (Byte512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Byte512Vector)v, (Byte512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Byte512Vector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n+    Byte512Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Byte512Vector)v1, (Byte512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte512Vector)v1, (Byte512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Byte512Vector tOp(Vector<Byte> v1, Vector<Byte> v2,\n+    Byte512Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Byte512Vector)v1, (Byte512Vector)v2,\n-                              (Byte512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte512Vector)v1, (Byte512Vector)v2,\n+                                (Byte512Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -584,6 +603,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getByte(vecpayload, start_offset + ix * Byte.BYTES);\n+                             });\n@@ -665,1 +685,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -669,3 +689,6 @@\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putByte(tpayload, start_offset + ix * Byte.BYTES, (byte)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Byte64Vector extends ByteVector {\n+value class Byte64Vector extends ByteVector {\n@@ -57,2 +58,10 @@\n-    Byte64Vector(byte[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+\n+    private final VectorSupport.VectorPayloadMF64 payload;\n+\n+    Byte64Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Byte64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Byte64Vector(Object v) {\n-        this((byte[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Byte64Vector ZERO = new Byte64Vector(new byte[VLENGTH]);\n-    static final Byte64Vector IOTA = new Byte64Vector(VSPECIES.iotaArray());\n+    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.createVectPayloadInstance(Byte.BYTES, 8));\n+    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(Byte.BYTES, 8, (byte [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Byte64Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Byte64Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Byte64Vector uOp(FUnOp f) {\n-        return (Byte64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Byte64Vector uOpMF(FUnOp f) {\n+        return (Byte64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Byte64Vector uOp(VectorMask<Byte> m, FUnOp f) {\n+    Byte64Vector uOpMF(VectorMask<Byte> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Byte64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Byte64Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Byte64Vector bOp(Vector<Byte> v, FBinOp f) {\n-        return (Byte64Vector) super.bOpTemplate((Byte64Vector)v, f);  \/\/ specialize\n+    Byte64Vector bOpMF(Vector<Byte> v, FBinOp f) {\n+        return (Byte64Vector) super.bOpTemplateMF((Byte64Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Byte64Vector bOp(Vector<Byte> v,\n+    Byte64Vector bOpMF(Vector<Byte> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Byte64Vector)v, (Byte64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Byte64Vector)v, (Byte64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Byte64Vector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n+    Byte64Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Byte64Vector)v1, (Byte64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte64Vector)v1, (Byte64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Byte64Vector tOp(Vector<Byte> v1, Vector<Byte> v2,\n+    Byte64Vector tOpMF(Vector<Byte> v1, Vector<Byte> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Byte64Vector)v1, (Byte64Vector)v2,\n-                              (Byte64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Byte64Vector)v1, (Byte64Vector)v2,\n+                                (Byte64Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -528,6 +547,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getByte(vecpayload, start_offset + ix * Byte.BYTES);\n+                             });\n@@ -553,1 +573,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -557,3 +577,6 @@\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putByte(tpayload, start_offset + ix * Byte.BYTES, (byte)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,920 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class ByteMaxVector extends ByteVector {\n-    static final ByteSpecies VSPECIES =\n-        (ByteSpecies) ByteVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<ByteMaxVector> VCLASS = ByteMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n-\n-    ByteMaxVector(byte[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as ByteMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    ByteMaxVector(Object v) {\n-        this((byte[]) v);\n-    }\n-\n-    static final ByteMaxVector ZERO = new ByteMaxVector(new byte[VLENGTH]);\n-    static final ByteMaxVector IOTA = new ByteMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public ByteSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Byte> elementType() { return byte.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Byte.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxVector broadcast(byte e) {\n-        return (ByteMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxVector broadcast(long e) {\n-        return (ByteMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxMask maskFromArray(boolean[] bits) {\n-        return new ByteMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle iotaShuffle() { return ByteMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    ByteMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle shuffleFromBytes(byte[] reorder) { return new ByteMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ByteMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new ByteMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector vectorFactory(byte[] vec) {\n-        return new ByteMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector uOp(FUnOp f) {\n-        return (ByteMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector uOp(VectorMask<Byte> m, FUnOp f) {\n-        return (ByteMaxVector)\n-            super.uOpTemplate((ByteMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector bOp(Vector<Byte> v, FBinOp f) {\n-        return (ByteMaxVector) super.bOpTemplate((ByteMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector bOp(Vector<Byte> v,\n-                     VectorMask<Byte> m, FBinOp f) {\n-        return (ByteMaxVector)\n-            super.bOpTemplate((ByteMaxVector)v, (ByteMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector tOp(Vector<Byte> v1, Vector<Byte> v2, FTriOp f) {\n-        return (ByteMaxVector)\n-            super.tOpTemplate((ByteMaxVector)v1, (ByteMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector tOp(Vector<Byte> v1, Vector<Byte> v2,\n-                     VectorMask<Byte> m, FTriOp f) {\n-        return (ByteMaxVector)\n-            super.tOpTemplate((ByteMaxVector)v1, (ByteMaxVector)v2,\n-                              (ByteMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Byte,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector lanewise(Unary op) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector lanewise(Unary op, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector lanewise(Binary op, Vector<Byte> v) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector lanewise(Binary op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline ByteMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e) {\n-        return (ByteMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline ByteMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewiseShiftTemplate(op, ByteMaxMask.class, e, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    ByteMaxVector\n-    lanewise(Ternary op, Vector<Byte> v1, Vector<Byte> v2) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    ByteMaxVector\n-    lanewise(Ternary op, Vector<Byte> v1, Vector<Byte> v2, VectorMask<Byte> m) {\n-        return (ByteMaxVector) super.lanewiseTemplate(op, ByteMaxMask.class, v1, v2, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    ByteMaxVector addIndex(int scale) {\n-        return (ByteMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final byte reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final byte reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Byte> m) {\n-        return super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Byte> m) {\n-        return (long) super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask test(Test op) {\n-        return super.testTemplate(ByteMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask test(Test op, VectorMask<Byte> m) {\n-        return super.testTemplate(ByteMaxMask.class, op, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask compare(Comparison op, Vector<Byte> v) {\n-        return super.compareTemplate(ByteMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask compare(Comparison op, byte s) {\n-        return super.compareTemplate(ByteMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(ByteMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ByteMaxMask compare(Comparison op, Vector<Byte> v, VectorMask<Byte> m) {\n-        return super.compareTemplate(ByteMaxMask.class, op, v, (ByteMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector blend(Vector<Byte> v, VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.blendTemplate(ByteMaxMask.class,\n-                                (ByteMaxVector) v,\n-                                (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector slice(int origin, Vector<Byte> v) {\n-        return (ByteMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector slice(int origin) {\n-        return (ByteMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector unslice(int origin, Vector<Byte> w, int part) {\n-        return (ByteMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector unslice(int origin, Vector<Byte> w, int part, VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.unsliceTemplate(ByteMaxMask.class,\n-                                  origin, w, part,\n-                                  (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector unslice(int origin) {\n-        return (ByteMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector rearrange(VectorShuffle<Byte> s) {\n-        return (ByteMaxVector)\n-            super.rearrangeTemplate(ByteMaxShuffle.class,\n-                                    (ByteMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector rearrange(VectorShuffle<Byte> shuffle,\n-                                  VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.rearrangeTemplate(ByteMaxShuffle.class,\n-                                    ByteMaxMask.class,\n-                                    (ByteMaxShuffle) shuffle,\n-                                    (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector rearrange(VectorShuffle<Byte> s,\n-                                  Vector<Byte> v) {\n-        return (ByteMaxVector)\n-            super.rearrangeTemplate(ByteMaxShuffle.class,\n-                                    (ByteMaxShuffle) s,\n-                                    (ByteMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector compress(VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.compressTemplate(ByteMaxMask.class,\n-                                   (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector expand(VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.expandTemplate(ByteMaxMask.class,\n-                                   (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector selectFrom(Vector<Byte> v) {\n-        return (ByteMaxVector)\n-            super.selectFromTemplate((ByteMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ByteMaxVector selectFrom(Vector<Byte> v,\n-                                   VectorMask<Byte> m) {\n-        return (ByteMaxVector)\n-            super.selectFromTemplate((ByteMaxVector) v,\n-                                     (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public byte lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return laneHelper(i);\n-    }\n-\n-    public byte laneHelper(int i) {\n-        return (byte) VectorSupport.extract(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    byte[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public ByteMaxVector withLane(int i, byte e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public ByteMaxVector withLaneHelper(int i, byte e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)e,\n-                                (v, ix, bits) -> {\n-                                    byte[] res = v.vec().clone();\n-                                    res[ix] = (byte)bits;\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class ByteMaxMask extends AbstractMask<Byte> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n-\n-        ByteMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        ByteMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        ByteMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public ByteSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        ByteMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new ByteMaxMask(res);\n-        }\n-\n-        @Override\n-        ByteMaxMask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((ByteMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new ByteMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        ByteMaxVector toVector() {\n-            return (ByteMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask eq(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            ByteMaxMask m = (ByteMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask compress() {\n-            return (ByteMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                ByteMaxVector.class, ByteMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask and(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            ByteMaxMask m = (ByteMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxMask or(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            ByteMaxMask m = (ByteMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @ForceInline\n-        \/* package-private *\/\n-        ByteMaxMask xor(VectorMask<Byte> mask) {\n-            Objects.requireNonNull(mask);\n-            ByteMaxMask m = (ByteMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static ByteMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final ByteMaxMask  TRUE_MASK = new ByteMaxMask(true);\n-        private static final ByteMaxMask FALSE_MASK = new ByteMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class ByteMaxShuffle extends AbstractShuffle<Byte> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n-\n-        ByteMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public ByteMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public ByteMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public ByteMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public ByteSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final ByteMaxShuffle IOTA = new ByteMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public ByteMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ByteMaxVector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            ByteMaxShuffle s = (ByteMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new ByteMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromArray0(byte[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m, int offsetInRange) {\n-        return super.fromArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromBooleanArray0(boolean[] a, int offset) {\n-        return super.fromBooleanArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m, int offsetInRange) {\n-        return super.fromBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(byte[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n-        super.intoBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n-        super.intoMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":0,"deletions":920,"binary":false,"changes":920,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    ByteVector(byte[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public ByteVector() {}\n@@ -99,0 +99,2 @@\n+    abstract VectorPayloadMF vec_mf();\n+\n@@ -108,0 +110,2 @@\n+    abstract ByteVector vectorFactory(VectorPayloadMF vec);\n+\n@@ -127,1 +131,1 @@\n-    ByteVector vOp(FVOp f) {\n+    ByteVector vOpMF(FVOp f) {\n@@ -132,1 +136,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +142,1 @@\n-    ByteVector vOp(VectorMask<Byte> m, FVOp f) {\n+    ByteVector vOpMF(VectorMask<Byte> m, FVOp f) {\n@@ -145,1 +150,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +163,1 @@\n-    ByteVector uOp(FUnOp f);\n+    ByteVector uOpMF(FUnOp f);\n@@ -160,5 +166,8 @@\n-    ByteVector uOpTemplate(FUnOp f) {\n-        byte[] vec = vec();\n-        byte[] res = new byte[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    ByteVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(i, v));\n@@ -166,1 +175,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +181,1 @@\n-    ByteVector uOp(VectorMask<Byte> m,\n+    ByteVector uOpMF(VectorMask<Byte> m,\n@@ -175,1 +185,1 @@\n-    ByteVector uOpTemplate(VectorMask<Byte> m,\n+    ByteVector uOpTemplateMF(VectorMask<Byte> m,\n@@ -178,1 +188,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,2 +190,0 @@\n-        byte[] vec = vec();\n-        byte[] res = new byte[length()];\n@@ -183,2 +191,7 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, mbits[i] ? f.apply(i, v): v);\n@@ -186,1 +199,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +212,1 @@\n-    ByteVector bOp(Vector<Byte> o,\n+    ByteVector bOpMF(Vector<Byte> o,\n@@ -202,1 +216,1 @@\n-    ByteVector bOpTemplate(Vector<Byte> o,\n+    ByteVector bOpTemplateMF(Vector<Byte> o,\n@@ -204,5 +218,9 @@\n-        byte[] res = new byte[length()];\n-        byte[] vec1 = this.vec();\n-        byte[] vec2 = ((ByteVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +228,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +234,1 @@\n-    ByteVector bOp(Vector<Byte> o,\n+    ByteVector bOpMF(Vector<Byte> o,\n@@ -220,1 +239,1 @@\n-    ByteVector bOpTemplate(Vector<Byte> o,\n+    ByteVector bOpTemplateMF(Vector<Byte> o,\n@@ -224,1 +243,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,3 +245,0 @@\n-        byte[] res = new byte[length()];\n-        byte[] vec1 = this.vec();\n-        byte[] vec2 = ((ByteVector)o).vec();\n@@ -230,2 +246,9 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n@@ -233,1 +256,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +269,1 @@\n-    ByteVector tOp(Vector<Byte> o1,\n+    ByteVector tOpMF(Vector<Byte> o1,\n@@ -250,1 +274,1 @@\n-    ByteVector tOpTemplate(Vector<Byte> o1,\n+    ByteVector tOpTemplateMF(Vector<Byte> o1,\n@@ -253,6 +277,11 @@\n-        byte[] res = new byte[length()];\n-        byte[] vec1 = this.vec();\n-        byte[] vec2 = ((ByteVector)o1).vec();\n-        byte[] vec3 = ((ByteVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ByteVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((ByteVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n+            byte v3 = Unsafe.getUnsafe().getByte(vec3, start_offset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +289,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +295,1 @@\n-    ByteVector tOp(Vector<Byte> o1,\n+    ByteVector tOpMF(Vector<Byte> o1,\n@@ -271,1 +301,1 @@\n-    ByteVector tOpTemplate(Vector<Byte> o1,\n+    ByteVector tOpTemplateMF(Vector<Byte> o1,\n@@ -276,1 +306,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,4 +308,0 @@\n-        byte[] res = new byte[length()];\n-        byte[] vec1 = this.vec();\n-        byte[] vec2 = ((ByteVector)o1).vec();\n-        byte[] vec3 = ((ByteVector)o2).vec();\n@@ -283,2 +309,11 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ByteVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((ByteVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n+            byte v3 = Unsafe.getUnsafe().getByte(vec3, start_offset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    byte rOp(byte v, VectorMask<Byte> m, FBinOp f);\n+    byte rOpMF(byte v, VectorMask<Byte> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    byte rOpTemplate(byte v, VectorMask<Byte> m, FBinOp f) {\n+    byte rOpTemplateMF(byte v, VectorMask<Byte> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,1 +337,1 @@\n-        byte[] vec = vec();\n+        VectorPayloadMF vec = this.vec_mf();\n@@ -303,2 +339,5 @@\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n+            v = mbits[i] ? f.apply(i, v, v1) : v;\n@@ -311,4 +350,7 @@\n-    byte rOpTemplate(byte v, FBinOp f) {\n-        byte[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    byte rOpTemplateMF(byte v, FBinOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +371,1 @@\n-    <M> ByteVector ldOp(M memory, int offset,\n+    <M> ByteVector ldOpMF(M memory, int offset,\n@@ -331,4 +373,7 @@\n-        \/\/dummy; no vec = vec();\n-        byte[] res = new byte[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Byte.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +381,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +388,1 @@\n-    <M> ByteVector ldOp(M memory, int offset,\n+    <M> ByteVector ldOpMF(M memory, int offset,\n@@ -345,2 +391,5 @@\n-        \/\/byte[] vec = vec();\n-        byte[] res = new byte[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Byte.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -348,1 +397,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -350,1 +399,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +402,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +406,1 @@\n+\n@@ -364,1 +415,1 @@\n-    ByteVector ldLongOp(MemorySegment memory, long offset,\n+    ByteVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +417,7 @@\n-        \/\/dummy; no vec = vec();\n-        byte[] res = new byte[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Byte.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +425,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +432,1 @@\n-    ByteVector ldLongOp(MemorySegment memory, long offset,\n+    ByteVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,2 +435,5 @@\n-        \/\/byte[] vec = vec();\n-        byte[] res = new byte[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Byte.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -383,1 +441,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -385,1 +443,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +446,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +461,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +463,5 @@\n-        byte[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n@@ -411,1 +472,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +474,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,1 +477,1 @@\n-        byte[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -418,1 +479,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -420,1 +483,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n@@ -425,0 +488,1 @@\n+\n@@ -432,1 +496,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +498,5 @@\n-        byte[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n@@ -443,1 +509,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,1 +512,1 @@\n-        byte[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -448,1 +514,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -450,1 +518,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n@@ -469,1 +537,1 @@\n-    AbstractMask<Byte> bTest(int cond,\n+    AbstractMask<Byte> bTestMF(int cond,\n@@ -472,5 +540,9 @@\n-        byte[] vec1 = vec();\n-        byte[] vec2 = ((ByteVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec_mf();\n+        int length = vspecies().length();\n+        long start_offset = this.multiFieldOffset();\n+        boolean[] bits = new boolean[length];\n+        for (int i = 0; i < length; i++) {\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n+            bits[i] = f.apply(cond, i, v1, v2);\n@@ -565,1 +637,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -725,1 +797,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) -a);\n+                    v0.uOpMF(m, (i, a) -> (byte) -a);\n@@ -727,1 +799,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (byte) Math.abs(a));\n@@ -729,1 +801,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> (byte) bitCount(a));\n@@ -731,1 +803,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (byte) numberOfTrailingZeros(a));\n@@ -733,1 +805,1 @@\n-                    v0.uOp(m, (i, a) -> (byte) numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (byte) numberOfLeadingZeros(a));\n@@ -735,1 +807,1 @@\n-                    v0.uOp(m, (i, a) -> reverse(a));\n+                    v0.uOpMF(m, (i, a) -> reverse(a));\n@@ -737,1 +809,1 @@\n-                    v0.uOp(m, (i, a) -> a);\n+                    v0.uOpMF(m, (i, a) -> a);\n@@ -787,1 +859,1 @@\n-            BIN_IMPL.find(op, opc, ByteVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, ByteVector::binaryOperationsMF));\n@@ -847,1 +919,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a + b));\n@@ -849,1 +921,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a - b));\n@@ -851,1 +923,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a * b));\n@@ -853,1 +925,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a \/ b));\n@@ -855,1 +927,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.max(a, b));\n@@ -857,1 +929,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.min(a, b));\n@@ -859,1 +931,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a & b));\n@@ -861,1 +933,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a | b));\n@@ -863,1 +935,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (byte)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a ^ b));\n@@ -865,1 +937,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (byte)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)(a << n));\n@@ -867,1 +939,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (byte)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)(a >> n));\n@@ -869,1 +941,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n@@ -871,1 +943,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -873,1 +945,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -878,0 +950,35 @@\n+    private static BinaryOperation<ByteVector, VectorMask<Byte>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (byte)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+            default: return null;\n+        }\n+    }\n+\n+\n@@ -1042,1 +1149,1 @@\n-                    v.uOp(m, (i, a) -> (byte)(a << n));\n+                    v.uOpMF(m, (i, a) -> (byte)(a << n));\n@@ -1044,1 +1151,1 @@\n-                    v.uOp(m, (i, a) -> (byte)(a >> n));\n+                    v.uOpMF(m, (i, a) -> (byte)(a >> n));\n@@ -1046,1 +1153,1 @@\n-                    v.uOp(m, (i, a) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> (byte)((a & LSHR_SETUP_MASK) >>> n));\n@@ -1048,1 +1155,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -1050,1 +1157,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -2049,1 +2156,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2071,1 +2178,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2200,1 +2307,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2407,1 +2514,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2439,1 +2546,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2467,1 +2574,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2475,1 +2582,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2817,1 +2924,1 @@\n-                    toBits(v.rOp((byte)0, m, (i, a, b) -> (byte)(a + b)));\n+                    toBits(v.rOpMF((byte)0, m, (i, a, b) -> (byte)(a + b)));\n@@ -2819,1 +2926,1 @@\n-                    toBits(v.rOp((byte)1, m, (i, a, b) -> (byte)(a * b)));\n+                    toBits(v.rOpMF((byte)1, m, (i, a, b) -> (byte)(a * b)));\n@@ -2821,1 +2928,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (byte) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (byte) Math.min(a, b)));\n@@ -2823,1 +2930,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (byte) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (byte) Math.max(a, b)));\n@@ -2825,1 +2932,1 @@\n-                    toBits(v.rOp((byte)-1, m, (i, a, b) -> (byte)(a & b)));\n+                    toBits(v.rOpMF((byte)-1, m, (i, a, b) -> (byte)(a & b)));\n@@ -2827,1 +2934,1 @@\n-                    toBits(v.rOp((byte)0, m, (i, a, b) -> (byte)(a | b)));\n+                    toBits(v.rOpMF((byte)0, m, (i, a, b) -> (byte)(a | b)));\n@@ -2829,1 +2936,1 @@\n-                    toBits(v.rOp((byte)0, m, (i, a, b) -> (byte)(a ^ b)));\n+                    toBits(v.rOpMF((byte)0, m, (i, a, b) -> (byte)(a ^ b)));\n@@ -2977,1 +3084,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -3052,1 +3159,1 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3098,1 +3205,1 @@\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3209,1 +3316,1 @@\n-        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        return vsp.vOpMF(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n@@ -3256,1 +3363,1 @@\n-        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        return vsp.vOpMF(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n@@ -3384,1 +3491,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3386,0 +3493,1 @@\n+\n@@ -3457,1 +3565,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -3499,1 +3607,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -3537,1 +3645,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3620,1 +3728,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -3668,1 +3776,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -3746,1 +3854,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3763,1 +3871,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3780,1 +3888,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3797,1 +3905,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3811,1 +3919,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, ByteVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, ByteVector::memorySegmentGet);\n@@ -3827,1 +3935,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, ByteVector::memorySegmentGet);\n@@ -3846,1 +3954,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3863,1 +3971,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3882,1 +3990,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3895,1 +4003,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, ByteVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, ByteVector::memorySegmentSet);\n@@ -3912,1 +4020,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, ByteVector::memorySegmentSet);\n@@ -4142,1 +4250,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -4212,0 +4320,6 @@\n+        @ForceInline\n+        @Override final\n+        ByteVector dummyVectorMF() {\n+            return (ByteVector) super.dummyVectorMF();\n+        }\n+\n@@ -4215,1 +4329,1 @@\n-        ByteVector rvOp(RVOp f) {\n+        ByteVector rvOpMF(RVOp f) {\n@@ -4221,1 +4335,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4224,1 +4339,1 @@\n-        ByteVector vOp(FVOp f) {\n+        ByteVector vOpMF(FVOp f) {\n@@ -4229,1 +4344,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4232,1 +4348,1 @@\n-        ByteVector vOp(VectorMask<Byte> m, FVOp f) {\n+        ByteVector vOpMF(VectorMask<Byte> m, FVOp f) {\n@@ -4240,1 +4356,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4245,1 +4362,1 @@\n-        <M> ByteVector ldOp(M memory, int offset,\n+        <M> ByteVector ldOpMF(M memory, int offset,\n@@ -4247,1 +4364,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -4252,1 +4369,1 @@\n-        <M> ByteVector ldOp(M memory, int offset,\n+        <M> ByteVector ldOpMF(M memory, int offset,\n@@ -4255,1 +4372,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -4258,0 +4375,1 @@\n+\n@@ -4260,1 +4378,1 @@\n-        ByteVector ldLongOp(MemorySegment memory, long offset,\n+        ByteVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -4262,1 +4380,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -4267,1 +4385,1 @@\n-        ByteVector ldLongOp(MemorySegment memory, long offset,\n+        ByteVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -4270,1 +4388,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -4275,2 +4393,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -4281,2 +4399,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Byte> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Byte> m,\n@@ -4284,1 +4402,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -4287,0 +4405,1 @@\n+\n@@ -4289,2 +4408,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -4295,1 +4414,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -4298,1 +4417,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -4312,2 +4431,3 @@\n-            if ((Class<?>) vectorType() == ByteMaxVector.class)\n-                return ByteMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ByteMaxVector.class)\n+            \/\/    return ByteMaxVector.ZERO;\n@@ -4326,2 +4446,3 @@\n-            if ((Class<?>) vectorType() == ByteMaxVector.class)\n-                return ByteMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ByteMaxVector.class)\n+            \/\/    return ByteMaxVector.IOTA;\n@@ -4341,2 +4462,3 @@\n-            if ((Class<?>) vectorType() == ByteMaxVector.class)\n-                return ByteMaxVector.ByteMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ByteMaxVector.class)\n+            \/\/    return ByteMaxVector.ByteMaxMask.maskAll(bit);\n@@ -4351,0 +4473,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            byte [] init = new byte[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (byte)i;\n+            }\n+           return init;\n+        }\n@@ -4367,1 +4499,2 @@\n-            case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n@@ -4401,1 +4534,2 @@\n-    public static final VectorSpecies<Byte> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Byte> SPECIES_MAX\n@@ -4406,0 +4540,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":348,"deletions":213,"binary":false,"changes":561,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Double128Vector extends DoubleVector {\n+value class Double128Vector extends DoubleVector {\n@@ -57,2 +58,6 @@\n-    Double128Vector(double[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+\n+    private final VectorSupport.VectorPayloadMF128 payload;\n+\n+    Double128Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF128)value;\n@@ -61,4 +66,2 @@\n-    \/\/ For compatibility as Double128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Double128Vector(Object v) {\n-        this((double[]) v);\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -67,2 +70,7 @@\n-    static final Double128Vector ZERO = new Double128Vector(new double[VLENGTH]);\n-    static final Double128Vector IOTA = new Double128Vector(VSPECIES.iotaArray());\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n+    }\n+\n+    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 2));\n+    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 2, (double [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Double128Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Double128Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Double128Vector uOp(FUnOp f) {\n-        return (Double128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Double128Vector uOpMF(FUnOp f) {\n+        return (Double128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Double128Vector uOp(VectorMask<Double> m, FUnOp f) {\n+    Double128Vector uOpMF(VectorMask<Double> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Double128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Double128Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Double128Vector bOp(Vector<Double> v, FBinOp f) {\n-        return (Double128Vector) super.bOpTemplate((Double128Vector)v, f);  \/\/ specialize\n+    Double128Vector bOpMF(Vector<Double> v, FBinOp f) {\n+        return (Double128Vector) super.bOpTemplateMF((Double128Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Double128Vector bOp(Vector<Double> v,\n+    Double128Vector bOpMF(Vector<Double> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Double128Vector)v, (Double128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Double128Vector)v, (Double128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Double128Vector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n+    Double128Vector tOpMF(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Double128Vector)v1, (Double128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Double128Vector)v1, (Double128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Double128Vector tOp(Vector<Double> v1, Vector<Double> v2,\n+    Double128Vector tOpMF(Vector<Double> v1, Vector<Double> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Double128Vector)v1, (Double128Vector)v2,\n-                              (Double128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Double128Vector)v1, (Double128Vector)v2,\n+                                (Double128Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -514,2 +533,3 @@\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Double.doubleToLongBits(Unsafe.getUnsafe().getDouble(vecpayload, start_offset + ix * Double.BYTES));\n@@ -534,3 +554,6 @@\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putDouble(tpayload, start_offset + ix * Double.BYTES, Double.longBitsToDouble((long)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Double256Vector extends DoubleVector {\n+value class Double256Vector extends DoubleVector {\n@@ -57,2 +58,6 @@\n-    Double256Vector(double[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+\n+    private final VectorSupport.VectorPayloadMF256 payload;\n+\n+    Double256Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF256)value;\n@@ -61,4 +66,2 @@\n-    \/\/ For compatibility as Double256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Double256Vector(Object v) {\n-        this((double[]) v);\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -67,2 +70,7 @@\n-    static final Double256Vector ZERO = new Double256Vector(new double[VLENGTH]);\n-    static final Double256Vector IOTA = new Double256Vector(VSPECIES.iotaArray());\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n+    }\n+\n+    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 4));\n+    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 4, (double [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Double256Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Double256Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Double256Vector uOp(FUnOp f) {\n-        return (Double256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Double256Vector uOpMF(FUnOp f) {\n+        return (Double256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Double256Vector uOp(VectorMask<Double> m, FUnOp f) {\n+    Double256Vector uOpMF(VectorMask<Double> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Double256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Double256Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Double256Vector bOp(Vector<Double> v, FBinOp f) {\n-        return (Double256Vector) super.bOpTemplate((Double256Vector)v, f);  \/\/ specialize\n+    Double256Vector bOpMF(Vector<Double> v, FBinOp f) {\n+        return (Double256Vector) super.bOpTemplateMF((Double256Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Double256Vector bOp(Vector<Double> v,\n+    Double256Vector bOpMF(Vector<Double> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Double256Vector)v, (Double256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Double256Vector)v, (Double256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Double256Vector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n+    Double256Vector tOpMF(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Double256Vector)v1, (Double256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Double256Vector)v1, (Double256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Double256Vector tOp(Vector<Double> v1, Vector<Double> v2,\n+    Double256Vector tOpMF(Vector<Double> v1, Vector<Double> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Double256Vector)v1, (Double256Vector)v2,\n-                              (Double256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Double256Vector)v1, (Double256Vector)v2,\n+                                (Double256Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -516,2 +535,3 @@\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Double.doubleToLongBits(Unsafe.getUnsafe().getDouble(vecpayload, start_offset + ix * Double.BYTES));\n@@ -538,3 +558,6 @@\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putDouble(tpayload, start_offset + ix * Double.BYTES, Double.longBitsToDouble((long)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Double512Vector extends DoubleVector {\n+value class Double512Vector extends DoubleVector {\n@@ -57,2 +58,6 @@\n-    Double512Vector(double[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+\n+    private final VectorSupport.VectorPayloadMF512 payload;\n+\n+    Double512Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF512)value;\n@@ -61,4 +66,2 @@\n-    \/\/ For compatibility as Double512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Double512Vector(Object v) {\n-        this((double[]) v);\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -67,2 +70,7 @@\n-    static final Double512Vector ZERO = new Double512Vector(new double[VLENGTH]);\n-    static final Double512Vector IOTA = new Double512Vector(VSPECIES.iotaArray());\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n+    }\n+\n+    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 8));\n+    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 8, (double [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Double512Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Double512Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Double512Vector uOp(FUnOp f) {\n-        return (Double512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Double512Vector uOpMF(FUnOp f) {\n+        return (Double512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Double512Vector uOp(VectorMask<Double> m, FUnOp f) {\n+    Double512Vector uOpMF(VectorMask<Double> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Double512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Double512Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Double512Vector bOp(Vector<Double> v, FBinOp f) {\n-        return (Double512Vector) super.bOpTemplate((Double512Vector)v, f);  \/\/ specialize\n+    Double512Vector bOpMF(Vector<Double> v, FBinOp f) {\n+        return (Double512Vector) super.bOpTemplateMF((Double512Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Double512Vector bOp(Vector<Double> v,\n+    Double512Vector bOpMF(Vector<Double> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Double512Vector)v, (Double512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Double512Vector)v, (Double512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Double512Vector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n+    Double512Vector tOpMF(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Double512Vector)v1, (Double512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Double512Vector)v1, (Double512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Double512Vector tOp(Vector<Double> v1, Vector<Double> v2,\n+    Double512Vector tOpMF(Vector<Double> v1, Vector<Double> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Double512Vector)v1, (Double512Vector)v2,\n-                              (Double512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Double512Vector)v1, (Double512Vector)v2,\n+                                (Double512Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -520,2 +539,3 @@\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Double.doubleToLongBits(Unsafe.getUnsafe().getDouble(vecpayload, start_offset + ix * Double.BYTES));\n@@ -546,3 +566,6 @@\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putDouble(tpayload, start_offset + ix * Double.BYTES, Double.longBitsToDouble((long)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Double64Vector extends DoubleVector {\n+value class Double64Vector extends DoubleVector {\n@@ -57,2 +58,6 @@\n-    Double64Vector(double[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+\n+    private final VectorSupport.VectorPayloadMF64 payload;\n+\n+    Double64Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF64)value;\n@@ -61,4 +66,2 @@\n-    \/\/ For compatibility as Double64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Double64Vector(Object v) {\n-        this((double[]) v);\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -67,2 +70,7 @@\n-    static final Double64Vector ZERO = new Double64Vector(new double[VLENGTH]);\n-    static final Double64Vector IOTA = new Double64Vector(VSPECIES.iotaArray());\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n+    }\n+\n+    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.createVectPayloadInstance(Double.BYTES, 1));\n+    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(Double.BYTES, 1, (double [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Double64Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Double64Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Double64Vector uOp(FUnOp f) {\n-        return (Double64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Double64Vector uOpMF(FUnOp f) {\n+        return (Double64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Double64Vector uOp(VectorMask<Double> m, FUnOp f) {\n+    Double64Vector uOpMF(VectorMask<Double> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Double64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Double64Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Double64Vector bOp(Vector<Double> v, FBinOp f) {\n-        return (Double64Vector) super.bOpTemplate((Double64Vector)v, f);  \/\/ specialize\n+    Double64Vector bOpMF(Vector<Double> v, FBinOp f) {\n+        return (Double64Vector) super.bOpTemplateMF((Double64Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Double64Vector bOp(Vector<Double> v,\n+    Double64Vector bOpMF(Vector<Double> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Double64Vector)v, (Double64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Double64Vector)v, (Double64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Double64Vector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n+    Double64Vector tOpMF(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Double64Vector)v1, (Double64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Double64Vector)v1, (Double64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Double64Vector tOp(Vector<Double> v1, Vector<Double> v2,\n+    Double64Vector tOpMF(Vector<Double> v1, Vector<Double> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Double64Vector)v1, (Double64Vector)v2,\n-                              (Double64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Double64Vector)v1, (Double64Vector)v2,\n+                                (Double64Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -513,2 +532,3 @@\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Double.doubleToLongBits(Unsafe.getUnsafe().getDouble(vecpayload, start_offset + ix * Double.BYTES));\n@@ -532,3 +552,6 @@\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putDouble(tpayload, start_offset + ix * Double.BYTES, Double.longBitsToDouble((long)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1,901 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class DoubleMaxVector extends DoubleVector {\n-    static final DoubleSpecies VSPECIES =\n-        (DoubleSpecies) DoubleVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<DoubleMaxVector> VCLASS = DoubleMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n-\n-    DoubleMaxVector(double[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as DoubleMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    DoubleMaxVector(Object v) {\n-        this((double[]) v);\n-    }\n-\n-    static final DoubleMaxVector ZERO = new DoubleMaxVector(new double[VLENGTH]);\n-    static final DoubleMaxVector IOTA = new DoubleMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public DoubleSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Double> elementType() { return double.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Double.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxVector broadcast(double e) {\n-        return (DoubleMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxVector broadcast(long e) {\n-        return (DoubleMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxMask maskFromArray(boolean[] bits) {\n-        return new DoubleMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle iotaShuffle() { return DoubleMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    DoubleMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle shuffleFromBytes(byte[] reorder) { return new DoubleMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle shuffleFromArray(int[] indexes, int i) { return new DoubleMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new DoubleMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector vectorFactory(double[] vec) {\n-        return new DoubleMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector uOp(FUnOp f) {\n-        return (DoubleMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector uOp(VectorMask<Double> m, FUnOp f) {\n-        return (DoubleMaxVector)\n-            super.uOpTemplate((DoubleMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector bOp(Vector<Double> v, FBinOp f) {\n-        return (DoubleMaxVector) super.bOpTemplate((DoubleMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector bOp(Vector<Double> v,\n-                     VectorMask<Double> m, FBinOp f) {\n-        return (DoubleMaxVector)\n-            super.bOpTemplate((DoubleMaxVector)v, (DoubleMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector tOp(Vector<Double> v1, Vector<Double> v2, FTriOp f) {\n-        return (DoubleMaxVector)\n-            super.tOpTemplate((DoubleMaxVector)v1, (DoubleMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    DoubleMaxVector tOp(Vector<Double> v1, Vector<Double> v2,\n-                     VectorMask<Double> m, FTriOp f) {\n-        return (DoubleMaxVector)\n-            super.tOpTemplate((DoubleMaxVector)v1, (DoubleMaxVector)v2,\n-                              (DoubleMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    double rOp(double v, VectorMask<Double> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Double,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector lanewise(Unary op) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector lanewise(Unary op, VectorMask<Double> m) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector lanewise(Binary op, Vector<Double> v) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector lanewise(Binary op, Vector<Double> v, VectorMask<Double> m) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    DoubleMaxVector\n-    lanewise(Ternary op, Vector<Double> v1, Vector<Double> v2) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    DoubleMaxVector\n-    lanewise(Ternary op, Vector<Double> v1, Vector<Double> v2, VectorMask<Double> m) {\n-        return (DoubleMaxVector) super.lanewiseTemplate(op, DoubleMaxMask.class, v1, v2, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    DoubleMaxVector addIndex(int scale) {\n-        return (DoubleMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final double reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final double reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Double> m) {\n-        return super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Double> m) {\n-        return (long) super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(DoubleMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask test(Test op) {\n-        return super.testTemplate(DoubleMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask test(Test op, VectorMask<Double> m) {\n-        return super.testTemplate(DoubleMaxMask.class, op, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask compare(Comparison op, Vector<Double> v) {\n-        return super.compareTemplate(DoubleMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask compare(Comparison op, double s) {\n-        return super.compareTemplate(DoubleMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(DoubleMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final DoubleMaxMask compare(Comparison op, Vector<Double> v, VectorMask<Double> m) {\n-        return super.compareTemplate(DoubleMaxMask.class, op, v, (DoubleMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector blend(Vector<Double> v, VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.blendTemplate(DoubleMaxMask.class,\n-                                (DoubleMaxVector) v,\n-                                (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector slice(int origin, Vector<Double> v) {\n-        return (DoubleMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector slice(int origin) {\n-        return (DoubleMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector unslice(int origin, Vector<Double> w, int part) {\n-        return (DoubleMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector unslice(int origin, Vector<Double> w, int part, VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.unsliceTemplate(DoubleMaxMask.class,\n-                                  origin, w, part,\n-                                  (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector unslice(int origin) {\n-        return (DoubleMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector rearrange(VectorShuffle<Double> s) {\n-        return (DoubleMaxVector)\n-            super.rearrangeTemplate(DoubleMaxShuffle.class,\n-                                    (DoubleMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector rearrange(VectorShuffle<Double> shuffle,\n-                                  VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.rearrangeTemplate(DoubleMaxShuffle.class,\n-                                    DoubleMaxMask.class,\n-                                    (DoubleMaxShuffle) shuffle,\n-                                    (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector rearrange(VectorShuffle<Double> s,\n-                                  Vector<Double> v) {\n-        return (DoubleMaxVector)\n-            super.rearrangeTemplate(DoubleMaxShuffle.class,\n-                                    (DoubleMaxShuffle) s,\n-                                    (DoubleMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector compress(VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.compressTemplate(DoubleMaxMask.class,\n-                                   (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector expand(VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.expandTemplate(DoubleMaxMask.class,\n-                                   (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector selectFrom(Vector<Double> v) {\n-        return (DoubleMaxVector)\n-            super.selectFromTemplate((DoubleMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public DoubleMaxVector selectFrom(Vector<Double> v,\n-                                   VectorMask<Double> m) {\n-        return (DoubleMaxVector)\n-            super.selectFromTemplate((DoubleMaxVector) v,\n-                                     (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public double lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        long bits = laneHelper(i);\n-        return Double.longBitsToDouble(bits);\n-    }\n-\n-    public long laneHelper(int i) {\n-        return (long) VectorSupport.extract(\n-                     VCLASS, ETYPE, VLENGTH,\n-                     this, i,\n-                     (vec, ix) -> {\n-                     double[] vecarr = vec.vec();\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n-                     });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public DoubleMaxVector withLane(int i, double e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public DoubleMaxVector withLaneHelper(int i, double e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)Double.doubleToLongBits(e),\n-                                (v, ix, bits) -> {\n-                                    double[] res = v.vec().clone();\n-                                    res[ix] = Double.longBitsToDouble((long)bits);\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class DoubleMaxMask extends AbstractMask<Double> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n-\n-        DoubleMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        DoubleMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        DoubleMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public DoubleSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        DoubleMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new DoubleMaxMask(res);\n-        }\n-\n-        @Override\n-        DoubleMaxMask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((DoubleMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new DoubleMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        DoubleMaxVector toVector() {\n-            return (DoubleMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask eq(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            DoubleMaxMask m = (DoubleMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask compress() {\n-            return (DoubleMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                DoubleMaxVector.class, DoubleMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask and(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            DoubleMaxMask m = (DoubleMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxMask or(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            DoubleMaxMask m = (DoubleMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @ForceInline\n-        \/* package-private *\/\n-        DoubleMaxMask xor(VectorMask<Double> mask) {\n-            Objects.requireNonNull(mask);\n-            DoubleMaxMask m = (DoubleMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static DoubleMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final DoubleMaxMask  TRUE_MASK = new DoubleMaxMask(true);\n-        private static final DoubleMaxMask FALSE_MASK = new DoubleMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class DoubleMaxShuffle extends AbstractShuffle<Double> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n-\n-        DoubleMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public DoubleMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public DoubleMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public DoubleMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public DoubleSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final DoubleMaxShuffle IOTA = new DoubleMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public DoubleMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((DoubleMaxVector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {\n-            DoubleMaxShuffle s = (DoubleMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new DoubleMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromArray0(double[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m, int offsetInRange) {\n-        return super.fromArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(double[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(double[] a, int offset, VectorMask<Double> m) {\n-        super.intoArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        super.intoArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n-        super.intoMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":0,"deletions":901,"binary":false,"changes":901,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    DoubleVector(double[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public DoubleVector() {}\n@@ -99,0 +99,2 @@\n+    abstract VectorPayloadMF vec_mf();\n+\n@@ -108,0 +110,2 @@\n+    abstract DoubleVector vectorFactory(VectorPayloadMF vec);\n+\n@@ -127,1 +131,1 @@\n-    DoubleVector vOp(FVOp f) {\n+    DoubleVector vOpMF(FVOp f) {\n@@ -132,1 +136,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +142,1 @@\n-    DoubleVector vOp(VectorMask<Double> m, FVOp f) {\n+    DoubleVector vOpMF(VectorMask<Double> m, FVOp f) {\n@@ -145,1 +150,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +163,1 @@\n-    DoubleVector uOp(FUnOp f);\n+    DoubleVector uOpMF(FUnOp f);\n@@ -160,5 +166,8 @@\n-    DoubleVector uOpTemplate(FUnOp f) {\n-        double[] vec = vec();\n-        double[] res = new double[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    DoubleVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(i, v));\n@@ -166,1 +175,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +181,1 @@\n-    DoubleVector uOp(VectorMask<Double> m,\n+    DoubleVector uOpMF(VectorMask<Double> m,\n@@ -175,1 +185,1 @@\n-    DoubleVector uOpTemplate(VectorMask<Double> m,\n+    DoubleVector uOpTemplateMF(VectorMask<Double> m,\n@@ -178,1 +188,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,2 +190,0 @@\n-        double[] vec = vec();\n-        double[] res = new double[length()];\n@@ -183,2 +191,7 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, mbits[i] ? f.apply(i, v): v);\n@@ -186,1 +199,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +212,1 @@\n-    DoubleVector bOp(Vector<Double> o,\n+    DoubleVector bOpMF(Vector<Double> o,\n@@ -202,1 +216,1 @@\n-    DoubleVector bOpTemplate(Vector<Double> o,\n+    DoubleVector bOpTemplateMF(Vector<Double> o,\n@@ -204,5 +218,9 @@\n-        double[] res = new double[length()];\n-        double[] vec1 = this.vec();\n-        double[] vec2 = ((DoubleVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +228,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +234,1 @@\n-    DoubleVector bOp(Vector<Double> o,\n+    DoubleVector bOpMF(Vector<Double> o,\n@@ -220,1 +239,1 @@\n-    DoubleVector bOpTemplate(Vector<Double> o,\n+    DoubleVector bOpTemplateMF(Vector<Double> o,\n@@ -224,1 +243,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,3 +245,0 @@\n-        double[] res = new double[length()];\n-        double[] vec1 = this.vec();\n-        double[] vec2 = ((DoubleVector)o).vec();\n@@ -230,2 +246,9 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n@@ -233,1 +256,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +269,1 @@\n-    DoubleVector tOp(Vector<Double> o1,\n+    DoubleVector tOpMF(Vector<Double> o1,\n@@ -250,1 +274,1 @@\n-    DoubleVector tOpTemplate(Vector<Double> o1,\n+    DoubleVector tOpTemplateMF(Vector<Double> o1,\n@@ -253,6 +277,11 @@\n-        double[] res = new double[length()];\n-        double[] vec1 = this.vec();\n-        double[] vec2 = ((DoubleVector)o1).vec();\n-        double[] vec3 = ((DoubleVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((DoubleVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((DoubleVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n+            double v3 = Unsafe.getUnsafe().getDouble(vec3, start_offset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +289,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +295,1 @@\n-    DoubleVector tOp(Vector<Double> o1,\n+    DoubleVector tOpMF(Vector<Double> o1,\n@@ -271,1 +301,1 @@\n-    DoubleVector tOpTemplate(Vector<Double> o1,\n+    DoubleVector tOpTemplateMF(Vector<Double> o1,\n@@ -276,1 +306,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,4 +308,0 @@\n-        double[] res = new double[length()];\n-        double[] vec1 = this.vec();\n-        double[] vec2 = ((DoubleVector)o1).vec();\n-        double[] vec3 = ((DoubleVector)o2).vec();\n@@ -283,2 +309,11 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((DoubleVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((DoubleVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n+            double v3 = Unsafe.getUnsafe().getDouble(vec3, start_offset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    double rOp(double v, VectorMask<Double> m, FBinOp f);\n+    double rOpMF(double v, VectorMask<Double> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    double rOpTemplate(double v, VectorMask<Double> m, FBinOp f) {\n+    double rOpTemplateMF(double v, VectorMask<Double> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,1 +337,1 @@\n-        double[] vec = vec();\n+        VectorPayloadMF vec = this.vec_mf();\n@@ -303,2 +339,5 @@\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n+            v = mbits[i] ? f.apply(i, v, v1) : v;\n@@ -311,4 +350,7 @@\n-    double rOpTemplate(double v, FBinOp f) {\n-        double[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    double rOpTemplateMF(double v, FBinOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +371,1 @@\n-    <M> DoubleVector ldOp(M memory, int offset,\n+    <M> DoubleVector ldOpMF(M memory, int offset,\n@@ -331,4 +373,7 @@\n-        \/\/dummy; no vec = vec();\n-        double[] res = new double[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Double.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +381,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +388,1 @@\n-    <M> DoubleVector ldOp(M memory, int offset,\n+    <M> DoubleVector ldOpMF(M memory, int offset,\n@@ -345,2 +391,5 @@\n-        \/\/double[] vec = vec();\n-        double[] res = new double[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Double.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -348,1 +397,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -350,1 +399,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +402,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +406,1 @@\n+\n@@ -364,1 +415,1 @@\n-    DoubleVector ldLongOp(MemorySegment memory, long offset,\n+    DoubleVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +417,7 @@\n-        \/\/dummy; no vec = vec();\n-        double[] res = new double[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Double.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +425,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +432,1 @@\n-    DoubleVector ldLongOp(MemorySegment memory, long offset,\n+    DoubleVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,2 +435,5 @@\n-        \/\/double[] vec = vec();\n-        double[] res = new double[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Double.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -383,1 +441,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -385,1 +443,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +446,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +461,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +463,5 @@\n-        double[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n@@ -411,1 +472,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +474,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,1 +477,1 @@\n-        double[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -418,1 +479,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -420,1 +483,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n@@ -425,0 +488,1 @@\n+\n@@ -432,1 +496,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +498,5 @@\n-        double[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n@@ -443,1 +509,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,1 +512,1 @@\n-        double[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -448,1 +514,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -450,1 +518,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n@@ -469,1 +537,1 @@\n-    AbstractMask<Double> bTest(int cond,\n+    AbstractMask<Double> bTestMF(int cond,\n@@ -472,5 +540,9 @@\n-        double[] vec1 = vec();\n-        double[] vec2 = ((DoubleVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec_mf();\n+        int length = vspecies().length();\n+        long start_offset = this.multiFieldOffset();\n+        boolean[] bits = new boolean[length];\n+        for (int i = 0; i < length; i++) {\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n+            bits[i] = f.apply(cond, i, v1, v2);\n@@ -554,1 +626,1 @@\n-                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                        ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -708,1 +780,1 @@\n-                    v0.uOp(m, (i, a) -> (double) -a);\n+                    v0.uOpMF(m, (i, a) -> (double) -a);\n@@ -710,1 +782,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.abs(a));\n@@ -712,1 +784,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.sin(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.sin(a));\n@@ -714,1 +786,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.cos(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.cos(a));\n@@ -716,1 +788,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.tan(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.tan(a));\n@@ -718,1 +790,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.asin(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.asin(a));\n@@ -720,1 +792,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.acos(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.acos(a));\n@@ -722,1 +794,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.atan(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.atan(a));\n@@ -724,1 +796,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.exp(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.exp(a));\n@@ -726,1 +798,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.log(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.log(a));\n@@ -728,1 +800,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.log10(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.log10(a));\n@@ -730,1 +802,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.sqrt(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.sqrt(a));\n@@ -732,1 +804,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.cbrt(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.cbrt(a));\n@@ -734,1 +806,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.sinh(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.sinh(a));\n@@ -736,1 +808,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.cosh(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.cosh(a));\n@@ -738,1 +810,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.tanh(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.tanh(a));\n@@ -740,1 +812,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.expm1(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.expm1(a));\n@@ -742,1 +814,1 @@\n-                    v0.uOp(m, (i, a) -> (double) Math.log1p(a));\n+                    v0.uOpMF(m, (i, a) -> (double) Math.log1p(a));\n@@ -777,1 +849,1 @@\n-            BIN_IMPL.find(op, opc, DoubleVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, DoubleVector::binaryOperationsMF));\n@@ -821,1 +893,27 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.min(a, b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.hypot(a, b));\n+            default: return null;\n+        }\n+    }\n+\n+    private static BinaryOperation<DoubleVector, VectorMask<Double>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a + b));\n@@ -823,1 +921,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a - b));\n@@ -825,1 +923,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a * b));\n@@ -827,1 +925,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)(a \/ b));\n@@ -829,1 +927,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.max(a, b));\n@@ -831,1 +929,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double)Math.min(a, b));\n@@ -833,1 +931,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -835,1 +933,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double) Math.atan2(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.atan2(a, b));\n@@ -837,1 +935,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double) Math.pow(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.pow(a, b));\n@@ -839,1 +937,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (double) Math.hypot(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (double) Math.hypot(a, b));\n@@ -844,0 +942,1 @@\n+\n@@ -1031,1 +1130,1 @@\n-                    v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n+                    v0.tOpMF(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n@@ -1895,1 +1994,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -1917,1 +2016,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2042,1 +2141,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2249,1 +2348,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2281,1 +2380,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2309,1 +2408,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2317,1 +2416,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2637,1 +2736,1 @@\n-                    toBits(v.rOp((double)0, m, (i, a, b) -> (double)(a + b)));\n+                    toBits(v.rOpMF((double)0, m, (i, a, b) -> (double)(a + b)));\n@@ -2639,1 +2738,1 @@\n-                    toBits(v.rOp((double)1, m, (i, a, b) -> (double)(a * b)));\n+                    toBits(v.rOpMF((double)1, m, (i, a, b) -> (double)(a * b)));\n@@ -2641,1 +2740,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (double) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (double) Math.min(a, b)));\n@@ -2643,1 +2742,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (double) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (double) Math.max(a, b)));\n@@ -2775,1 +2874,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -2860,1 +2959,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -2869,1 +2968,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -2872,0 +2971,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -2886,1 +2987,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -3072,1 +3173,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3074,0 +3175,1 @@\n+\n@@ -3153,1 +3255,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3161,1 +3263,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3164,0 +3266,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3180,1 +3284,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -3303,1 +3407,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3320,1 +3424,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3346,1 +3450,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3355,1 +3459,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3358,0 +3462,2 @@\n+             *\/\n+            assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3373,1 +3479,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -3388,1 +3494,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, DoubleVector::memorySegmentGet);\n@@ -3404,1 +3510,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, DoubleVector::memorySegmentGet);\n@@ -3423,1 +3529,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3440,1 +3546,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3462,1 +3568,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3470,1 +3576,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3473,0 +3579,3 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n+\n@@ -3490,1 +3599,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -3507,1 +3616,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, DoubleVector::memorySegmentSet);\n@@ -3524,1 +3633,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, DoubleVector::memorySegmentSet);\n@@ -3745,1 +3854,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -3815,0 +3924,6 @@\n+        @ForceInline\n+        @Override final\n+        DoubleVector dummyVectorMF() {\n+            return (DoubleVector) super.dummyVectorMF();\n+        }\n+\n@@ -3818,1 +3933,1 @@\n-        DoubleVector rvOp(RVOp f) {\n+        DoubleVector rvOpMF(RVOp f) {\n@@ -3824,1 +3939,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3827,1 +3943,1 @@\n-        DoubleVector vOp(FVOp f) {\n+        DoubleVector vOpMF(FVOp f) {\n@@ -3832,1 +3948,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3835,1 +3952,1 @@\n-        DoubleVector vOp(VectorMask<Double> m, FVOp f) {\n+        DoubleVector vOpMF(VectorMask<Double> m, FVOp f) {\n@@ -3843,1 +3960,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3848,1 +3966,1 @@\n-        <M> DoubleVector ldOp(M memory, int offset,\n+        <M> DoubleVector ldOpMF(M memory, int offset,\n@@ -3850,1 +3968,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -3855,1 +3973,1 @@\n-        <M> DoubleVector ldOp(M memory, int offset,\n+        <M> DoubleVector ldOpMF(M memory, int offset,\n@@ -3858,1 +3976,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -3861,0 +3979,1 @@\n+\n@@ -3863,1 +3982,1 @@\n-        DoubleVector ldLongOp(MemorySegment memory, long offset,\n+        DoubleVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3865,1 +3984,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -3870,1 +3989,1 @@\n-        DoubleVector ldLongOp(MemorySegment memory, long offset,\n+        DoubleVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3873,1 +3992,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -3878,2 +3997,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -3884,2 +4003,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Double> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Double> m,\n@@ -3887,1 +4006,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -3890,0 +4009,1 @@\n+\n@@ -3892,2 +4012,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -3898,1 +4018,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -3901,1 +4021,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -3915,2 +4035,3 @@\n-            if ((Class<?>) vectorType() == DoubleMaxVector.class)\n-                return DoubleMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == DoubleMaxVector.class)\n+            \/\/    return DoubleMaxVector.ZERO;\n@@ -3929,2 +4050,3 @@\n-            if ((Class<?>) vectorType() == DoubleMaxVector.class)\n-                return DoubleMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == DoubleMaxVector.class)\n+            \/\/    return DoubleMaxVector.IOTA;\n@@ -3944,2 +4066,3 @@\n-            if ((Class<?>) vectorType() == DoubleMaxVector.class)\n-                return DoubleMaxVector.DoubleMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == DoubleMaxVector.class)\n+            \/\/    return DoubleMaxVector.DoubleMaxMask.maskAll(bit);\n@@ -3954,0 +4077,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            double [] init = new double[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (double)i;\n+            }\n+           return init;\n+        }\n@@ -3970,1 +4103,2 @@\n-            case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n@@ -4004,1 +4138,2 @@\n-    public static final VectorSpecies<Double> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Double> SPECIES_MAX\n@@ -4009,0 +4144,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":349,"deletions":213,"binary":false,"changes":562,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Float128Vector extends FloatVector {\n+value class Float128Vector extends FloatVector {\n@@ -57,2 +58,6 @@\n-    Float128Vector(float[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+\n+    private final VectorSupport.VectorPayloadMF128 payload;\n+\n+    Float128Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF128)value;\n@@ -61,4 +66,2 @@\n-    \/\/ For compatibility as Float128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Float128Vector(Object v) {\n-        this((float[]) v);\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -67,2 +70,7 @@\n-    static final Float128Vector ZERO = new Float128Vector(new float[VLENGTH]);\n-    static final Float128Vector IOTA = new Float128Vector(VSPECIES.iotaArray());\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n+    }\n+\n+    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 4));\n+    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 4, (float [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Float128Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Float128Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Float128Vector uOp(FUnOp f) {\n-        return (Float128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Float128Vector uOpMF(FUnOp f) {\n+        return (Float128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Float128Vector uOp(VectorMask<Float> m, FUnOp f) {\n+    Float128Vector uOpMF(VectorMask<Float> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Float128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Float128Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Float128Vector bOp(Vector<Float> v, FBinOp f) {\n-        return (Float128Vector) super.bOpTemplate((Float128Vector)v, f);  \/\/ specialize\n+    Float128Vector bOpMF(Vector<Float> v, FBinOp f) {\n+        return (Float128Vector) super.bOpTemplateMF((Float128Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Float128Vector bOp(Vector<Float> v,\n+    Float128Vector bOpMF(Vector<Float> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Float128Vector)v, (Float128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Float128Vector)v, (Float128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Float128Vector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n+    Float128Vector tOpMF(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Float128Vector)v1, (Float128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Float128Vector)v1, (Float128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Float128Vector tOp(Vector<Float> v1, Vector<Float> v2,\n+    Float128Vector tOpMF(Vector<Float> v1, Vector<Float> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Float128Vector)v1, (Float128Vector)v2,\n-                              (Float128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Float128Vector)v1, (Float128Vector)v2,\n+                                (Float128Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -516,2 +535,3 @@\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Float.floatToIntBits(Unsafe.getUnsafe().getFloat(vecpayload, start_offset + ix * Float.BYTES));\n@@ -538,3 +558,6 @@\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putFloat(tpayload, start_offset + ix * Float.BYTES, Float.intBitsToFloat((int)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Float256Vector extends FloatVector {\n+value class Float256Vector extends FloatVector {\n@@ -57,2 +58,6 @@\n-    Float256Vector(float[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+\n+    private final VectorSupport.VectorPayloadMF256 payload;\n+\n+    Float256Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF256)value;\n@@ -61,4 +66,2 @@\n-    \/\/ For compatibility as Float256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Float256Vector(Object v) {\n-        this((float[]) v);\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -67,2 +70,7 @@\n-    static final Float256Vector ZERO = new Float256Vector(new float[VLENGTH]);\n-    static final Float256Vector IOTA = new Float256Vector(VSPECIES.iotaArray());\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n+    }\n+\n+    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 8));\n+    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 8, (float [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Float256Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Float256Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Float256Vector uOp(FUnOp f) {\n-        return (Float256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Float256Vector uOpMF(FUnOp f) {\n+        return (Float256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Float256Vector uOp(VectorMask<Float> m, FUnOp f) {\n+    Float256Vector uOpMF(VectorMask<Float> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Float256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Float256Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Float256Vector bOp(Vector<Float> v, FBinOp f) {\n-        return (Float256Vector) super.bOpTemplate((Float256Vector)v, f);  \/\/ specialize\n+    Float256Vector bOpMF(Vector<Float> v, FBinOp f) {\n+        return (Float256Vector) super.bOpTemplateMF((Float256Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Float256Vector bOp(Vector<Float> v,\n+    Float256Vector bOpMF(Vector<Float> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Float256Vector)v, (Float256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Float256Vector)v, (Float256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Float256Vector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n+    Float256Vector tOpMF(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Float256Vector)v1, (Float256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Float256Vector)v1, (Float256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Float256Vector tOp(Vector<Float> v1, Vector<Float> v2,\n+    Float256Vector tOpMF(Vector<Float> v1, Vector<Float> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Float256Vector)v1, (Float256Vector)v2,\n-                              (Float256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Float256Vector)v1, (Float256Vector)v2,\n+                                (Float256Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -520,2 +539,3 @@\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Float.floatToIntBits(Unsafe.getUnsafe().getFloat(vecpayload, start_offset + ix * Float.BYTES));\n@@ -546,3 +566,6 @@\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putFloat(tpayload, start_offset + ix * Float.BYTES, Float.intBitsToFloat((int)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Float512Vector extends FloatVector {\n+value class Float512Vector extends FloatVector {\n@@ -57,2 +58,6 @@\n-    Float512Vector(float[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+\n+    private final VectorSupport.VectorPayloadMF512 payload;\n+\n+    Float512Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF512)value;\n@@ -61,4 +66,2 @@\n-    \/\/ For compatibility as Float512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Float512Vector(Object v) {\n-        this((float[]) v);\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -67,2 +70,7 @@\n-    static final Float512Vector ZERO = new Float512Vector(new float[VLENGTH]);\n-    static final Float512Vector IOTA = new Float512Vector(VSPECIES.iotaArray());\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n+    }\n+\n+    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 16));\n+    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 16, (float [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Float512Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Float512Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Float512Vector uOp(FUnOp f) {\n-        return (Float512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Float512Vector uOpMF(FUnOp f) {\n+        return (Float512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Float512Vector uOp(VectorMask<Float> m, FUnOp f) {\n+    Float512Vector uOpMF(VectorMask<Float> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Float512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Float512Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Float512Vector bOp(Vector<Float> v, FBinOp f) {\n-        return (Float512Vector) super.bOpTemplate((Float512Vector)v, f);  \/\/ specialize\n+    Float512Vector bOpMF(Vector<Float> v, FBinOp f) {\n+        return (Float512Vector) super.bOpTemplateMF((Float512Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Float512Vector bOp(Vector<Float> v,\n+    Float512Vector bOpMF(Vector<Float> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Float512Vector)v, (Float512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Float512Vector)v, (Float512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Float512Vector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n+    Float512Vector tOpMF(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Float512Vector)v1, (Float512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Float512Vector)v1, (Float512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Float512Vector tOp(Vector<Float> v1, Vector<Float> v2,\n+    Float512Vector tOpMF(Vector<Float> v1, Vector<Float> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Float512Vector)v1, (Float512Vector)v2,\n-                              (Float512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Float512Vector)v1, (Float512Vector)v2,\n+                                (Float512Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -528,2 +547,3 @@\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Float.floatToIntBits(Unsafe.getUnsafe().getFloat(vecpayload, start_offset + ix * Float.BYTES));\n@@ -562,3 +582,6 @@\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putFloat(tpayload, start_offset + ix * Float.BYTES, Float.intBitsToFloat((int)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Float64Vector extends FloatVector {\n+value class Float64Vector extends FloatVector {\n@@ -57,2 +58,6 @@\n-    Float64Vector(float[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+\n+    private final VectorSupport.VectorPayloadMF64 payload;\n+\n+    Float64Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF64)value;\n@@ -61,4 +66,2 @@\n-    \/\/ For compatibility as Float64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Float64Vector(Object v) {\n-        this((float[]) v);\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -67,2 +70,7 @@\n-    static final Float64Vector ZERO = new Float64Vector(new float[VLENGTH]);\n-    static final Float64Vector IOTA = new Float64Vector(VSPECIES.iotaArray());\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n+    }\n+\n+    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.createVectPayloadInstance(Float.BYTES, 2));\n+    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(Float.BYTES, 2, (float [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Float64Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Float64Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Float64Vector uOp(FUnOp f) {\n-        return (Float64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Float64Vector uOpMF(FUnOp f) {\n+        return (Float64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Float64Vector uOp(VectorMask<Float> m, FUnOp f) {\n+    Float64Vector uOpMF(VectorMask<Float> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Float64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Float64Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Float64Vector bOp(Vector<Float> v, FBinOp f) {\n-        return (Float64Vector) super.bOpTemplate((Float64Vector)v, f);  \/\/ specialize\n+    Float64Vector bOpMF(Vector<Float> v, FBinOp f) {\n+        return (Float64Vector) super.bOpTemplateMF((Float64Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Float64Vector bOp(Vector<Float> v,\n+    Float64Vector bOpMF(Vector<Float> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Float64Vector)v, (Float64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Float64Vector)v, (Float64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Float64Vector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n+    Float64Vector tOpMF(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Float64Vector)v1, (Float64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Float64Vector)v1, (Float64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Float64Vector tOp(Vector<Float> v1, Vector<Float> v2,\n+    Float64Vector tOpMF(Vector<Float> v1, Vector<Float> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Float64Vector)v1, (Float64Vector)v2,\n-                              (Float64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Float64Vector)v1, (Float64Vector)v2,\n+                                (Float64Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -514,2 +533,3 @@\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)Float.floatToIntBits(Unsafe.getUnsafe().getFloat(vecpayload, start_offset + ix * Float.BYTES));\n@@ -534,3 +554,6 @@\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putFloat(tpayload, start_offset + ix * Float.BYTES, Float.intBitsToFloat((int)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1,901 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class FloatMaxVector extends FloatVector {\n-    static final FloatSpecies VSPECIES =\n-        (FloatSpecies) FloatVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<FloatMaxVector> VCLASS = FloatMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n-\n-    FloatMaxVector(float[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as FloatMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    FloatMaxVector(Object v) {\n-        this((float[]) v);\n-    }\n-\n-    static final FloatMaxVector ZERO = new FloatMaxVector(new float[VLENGTH]);\n-    static final FloatMaxVector IOTA = new FloatMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public FloatSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Float> elementType() { return float.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Float.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxVector broadcast(float e) {\n-        return (FloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxVector broadcast(long e) {\n-        return (FloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxMask maskFromArray(boolean[] bits) {\n-        return new FloatMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle iotaShuffle() { return FloatMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    FloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle shuffleFromBytes(byte[] reorder) { return new FloatMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new FloatMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new FloatMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector vectorFactory(float[] vec) {\n-        return new FloatMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector uOp(FUnOp f) {\n-        return (FloatMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector uOp(VectorMask<Float> m, FUnOp f) {\n-        return (FloatMaxVector)\n-            super.uOpTemplate((FloatMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector bOp(Vector<Float> v, FBinOp f) {\n-        return (FloatMaxVector) super.bOpTemplate((FloatMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector bOp(Vector<Float> v,\n-                     VectorMask<Float> m, FBinOp f) {\n-        return (FloatMaxVector)\n-            super.bOpTemplate((FloatMaxVector)v, (FloatMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector tOp(Vector<Float> v1, Vector<Float> v2, FTriOp f) {\n-        return (FloatMaxVector)\n-            super.tOpTemplate((FloatMaxVector)v1, (FloatMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    FloatMaxVector tOp(Vector<Float> v1, Vector<Float> v2,\n-                     VectorMask<Float> m, FTriOp f) {\n-        return (FloatMaxVector)\n-            super.tOpTemplate((FloatMaxVector)v1, (FloatMaxVector)v2,\n-                              (FloatMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    float rOp(float v, VectorMask<Float> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Float,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector lanewise(Unary op) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector lanewise(Unary op, VectorMask<Float> m) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector lanewise(Binary op, Vector<Float> v) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector lanewise(Binary op, Vector<Float> v, VectorMask<Float> m) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    FloatMaxVector\n-    lanewise(Ternary op, Vector<Float> v1, Vector<Float> v2) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    FloatMaxVector\n-    lanewise(Ternary op, Vector<Float> v1, Vector<Float> v2, VectorMask<Float> m) {\n-        return (FloatMaxVector) super.lanewiseTemplate(op, FloatMaxMask.class, v1, v2, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    FloatMaxVector addIndex(int scale) {\n-        return (FloatMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final float reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final float reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Float> m) {\n-        return super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Float> m) {\n-        return (long) super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(FloatMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask test(Test op) {\n-        return super.testTemplate(FloatMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask test(Test op, VectorMask<Float> m) {\n-        return super.testTemplate(FloatMaxMask.class, op, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask compare(Comparison op, Vector<Float> v) {\n-        return super.compareTemplate(FloatMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask compare(Comparison op, float s) {\n-        return super.compareTemplate(FloatMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(FloatMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final FloatMaxMask compare(Comparison op, Vector<Float> v, VectorMask<Float> m) {\n-        return super.compareTemplate(FloatMaxMask.class, op, v, (FloatMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector blend(Vector<Float> v, VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.blendTemplate(FloatMaxMask.class,\n-                                (FloatMaxVector) v,\n-                                (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector slice(int origin, Vector<Float> v) {\n-        return (FloatMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector slice(int origin) {\n-        return (FloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector unslice(int origin, Vector<Float> w, int part) {\n-        return (FloatMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector unslice(int origin, Vector<Float> w, int part, VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.unsliceTemplate(FloatMaxMask.class,\n-                                  origin, w, part,\n-                                  (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector unslice(int origin) {\n-        return (FloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector rearrange(VectorShuffle<Float> s) {\n-        return (FloatMaxVector)\n-            super.rearrangeTemplate(FloatMaxShuffle.class,\n-                                    (FloatMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector rearrange(VectorShuffle<Float> shuffle,\n-                                  VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.rearrangeTemplate(FloatMaxShuffle.class,\n-                                    FloatMaxMask.class,\n-                                    (FloatMaxShuffle) shuffle,\n-                                    (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector rearrange(VectorShuffle<Float> s,\n-                                  Vector<Float> v) {\n-        return (FloatMaxVector)\n-            super.rearrangeTemplate(FloatMaxShuffle.class,\n-                                    (FloatMaxShuffle) s,\n-                                    (FloatMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector compress(VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.compressTemplate(FloatMaxMask.class,\n-                                   (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector expand(VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.expandTemplate(FloatMaxMask.class,\n-                                   (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector selectFrom(Vector<Float> v) {\n-        return (FloatMaxVector)\n-            super.selectFromTemplate((FloatMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public FloatMaxVector selectFrom(Vector<Float> v,\n-                                   VectorMask<Float> m) {\n-        return (FloatMaxVector)\n-            super.selectFromTemplate((FloatMaxVector) v,\n-                                     (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public float lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        int bits = laneHelper(i);\n-        return Float.intBitsToFloat(bits);\n-    }\n-\n-    public int laneHelper(int i) {\n-        return (int) VectorSupport.extract(\n-                     VCLASS, ETYPE, VLENGTH,\n-                     this, i,\n-                     (vec, ix) -> {\n-                     float[] vecarr = vec.vec();\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n-                     });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public FloatMaxVector withLane(int i, float e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public FloatMaxVector withLaneHelper(int i, float e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)Float.floatToIntBits(e),\n-                                (v, ix, bits) -> {\n-                                    float[] res = v.vec().clone();\n-                                    res[ix] = Float.intBitsToFloat((int)bits);\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class FloatMaxMask extends AbstractMask<Float> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n-\n-        FloatMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        FloatMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        FloatMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public FloatSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        FloatMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new FloatMaxMask(res);\n-        }\n-\n-        @Override\n-        FloatMaxMask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((FloatMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new FloatMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        FloatMaxVector toVector() {\n-            return (FloatMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask eq(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            FloatMaxMask m = (FloatMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask compress() {\n-            return (FloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                FloatMaxVector.class, FloatMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask and(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            FloatMaxMask m = (FloatMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxMask or(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            FloatMaxMask m = (FloatMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @ForceInline\n-        \/* package-private *\/\n-        FloatMaxMask xor(VectorMask<Float> mask) {\n-            Objects.requireNonNull(mask);\n-            FloatMaxMask m = (FloatMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static FloatMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final FloatMaxMask  TRUE_MASK = new FloatMaxMask(true);\n-        private static final FloatMaxMask FALSE_MASK = new FloatMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class FloatMaxShuffle extends AbstractShuffle<Float> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n-\n-        FloatMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public FloatMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public FloatMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public FloatMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public FloatSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final FloatMaxShuffle IOTA = new FloatMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public FloatMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((FloatMaxVector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {\n-            FloatMaxShuffle s = (FloatMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new FloatMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromArray0(float[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m, int offsetInRange) {\n-        return super.fromArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(float[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(float[] a, int offset, VectorMask<Float> m) {\n-        super.intoArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        super.intoArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n-        super.intoMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":0,"deletions":901,"binary":false,"changes":901,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    FloatVector(float[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public FloatVector() {}\n@@ -99,0 +99,2 @@\n+    abstract VectorPayloadMF vec_mf();\n+\n@@ -108,0 +110,2 @@\n+    abstract FloatVector vectorFactory(VectorPayloadMF vec);\n+\n@@ -127,1 +131,1 @@\n-    FloatVector vOp(FVOp f) {\n+    FloatVector vOpMF(FVOp f) {\n@@ -132,1 +136,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +142,1 @@\n-    FloatVector vOp(VectorMask<Float> m, FVOp f) {\n+    FloatVector vOpMF(VectorMask<Float> m, FVOp f) {\n@@ -145,1 +150,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +163,1 @@\n-    FloatVector uOp(FUnOp f);\n+    FloatVector uOpMF(FUnOp f);\n@@ -160,5 +166,8 @@\n-    FloatVector uOpTemplate(FUnOp f) {\n-        float[] vec = vec();\n-        float[] res = new float[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    FloatVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(i, v));\n@@ -166,1 +175,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +181,1 @@\n-    FloatVector uOp(VectorMask<Float> m,\n+    FloatVector uOpMF(VectorMask<Float> m,\n@@ -175,1 +185,1 @@\n-    FloatVector uOpTemplate(VectorMask<Float> m,\n+    FloatVector uOpTemplateMF(VectorMask<Float> m,\n@@ -178,1 +188,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,2 +190,0 @@\n-        float[] vec = vec();\n-        float[] res = new float[length()];\n@@ -183,2 +191,7 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, mbits[i] ? f.apply(i, v): v);\n@@ -186,1 +199,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +212,1 @@\n-    FloatVector bOp(Vector<Float> o,\n+    FloatVector bOpMF(Vector<Float> o,\n@@ -202,1 +216,1 @@\n-    FloatVector bOpTemplate(Vector<Float> o,\n+    FloatVector bOpTemplateMF(Vector<Float> o,\n@@ -204,5 +218,9 @@\n-        float[] res = new float[length()];\n-        float[] vec1 = this.vec();\n-        float[] vec2 = ((FloatVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +228,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +234,1 @@\n-    FloatVector bOp(Vector<Float> o,\n+    FloatVector bOpMF(Vector<Float> o,\n@@ -220,1 +239,1 @@\n-    FloatVector bOpTemplate(Vector<Float> o,\n+    FloatVector bOpTemplateMF(Vector<Float> o,\n@@ -224,1 +243,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,3 +245,0 @@\n-        float[] res = new float[length()];\n-        float[] vec1 = this.vec();\n-        float[] vec2 = ((FloatVector)o).vec();\n@@ -230,2 +246,9 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n@@ -233,1 +256,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +269,1 @@\n-    FloatVector tOp(Vector<Float> o1,\n+    FloatVector tOpMF(Vector<Float> o1,\n@@ -250,1 +274,1 @@\n-    FloatVector tOpTemplate(Vector<Float> o1,\n+    FloatVector tOpTemplateMF(Vector<Float> o1,\n@@ -253,8 +277,14 @@\n-        float[] res = new float[length()];\n-        float[] vec1 = this.vec();\n-        float[] vec2 = ((FloatVector)o1).vec();\n-        float[] vec3 = ((FloatVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n-        }\n-        return vectorFactory(res);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((FloatVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((FloatVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n+            float v3 = Unsafe.getUnsafe().getFloat(vec3, start_offset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(i, v1, v2, v3));\n+        }\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +295,1 @@\n-    FloatVector tOp(Vector<Float> o1,\n+    FloatVector tOpMF(Vector<Float> o1,\n@@ -271,1 +301,1 @@\n-    FloatVector tOpTemplate(Vector<Float> o1,\n+    FloatVector tOpTemplateMF(Vector<Float> o1,\n@@ -276,1 +306,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,4 +308,0 @@\n-        float[] res = new float[length()];\n-        float[] vec1 = this.vec();\n-        float[] vec2 = ((FloatVector)o1).vec();\n-        float[] vec3 = ((FloatVector)o2).vec();\n@@ -283,4 +309,14 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n-        }\n-        return vectorFactory(res);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((FloatVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((FloatVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n+            float v3 = Unsafe.getUnsafe().getFloat(vec3, start_offset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+        }\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    float rOp(float v, VectorMask<Float> m, FBinOp f);\n+    float rOpMF(float v, VectorMask<Float> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    float rOpTemplate(float v, VectorMask<Float> m, FBinOp f) {\n+    float rOpTemplateMF(float v, VectorMask<Float> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,1 +337,1 @@\n-        float[] vec = vec();\n+        VectorPayloadMF vec = this.vec_mf();\n@@ -303,2 +339,5 @@\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n+            v = mbits[i] ? f.apply(i, v, v1) : v;\n@@ -311,4 +350,7 @@\n-    float rOpTemplate(float v, FBinOp f) {\n-        float[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    float rOpTemplateMF(float v, FBinOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +371,1 @@\n-    <M> FloatVector ldOp(M memory, int offset,\n+    <M> FloatVector ldOpMF(M memory, int offset,\n@@ -331,4 +373,7 @@\n-        \/\/dummy; no vec = vec();\n-        float[] res = new float[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Float.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +381,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +388,1 @@\n-    <M> FloatVector ldOp(M memory, int offset,\n+    <M> FloatVector ldOpMF(M memory, int offset,\n@@ -345,2 +391,5 @@\n-        \/\/float[] vec = vec();\n-        float[] res = new float[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Float.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -348,1 +397,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -350,1 +399,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +402,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +406,1 @@\n+\n@@ -364,1 +415,1 @@\n-    FloatVector ldLongOp(MemorySegment memory, long offset,\n+    FloatVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +417,7 @@\n-        \/\/dummy; no vec = vec();\n-        float[] res = new float[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Float.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +425,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +432,1 @@\n-    FloatVector ldLongOp(MemorySegment memory, long offset,\n+    FloatVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,2 +435,5 @@\n-        \/\/float[] vec = vec();\n-        float[] res = new float[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Float.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -383,1 +441,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -385,1 +443,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +446,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +461,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +463,5 @@\n-        float[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n@@ -411,1 +472,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +474,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,1 +477,1 @@\n-        float[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -418,1 +479,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -420,1 +483,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n@@ -425,0 +488,1 @@\n+\n@@ -432,1 +496,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +498,5 @@\n-        float[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n@@ -443,1 +509,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,1 +512,1 @@\n-        float[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -448,1 +514,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -450,1 +518,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n@@ -469,1 +537,1 @@\n-    AbstractMask<Float> bTest(int cond,\n+    AbstractMask<Float> bTestMF(int cond,\n@@ -472,5 +540,9 @@\n-        float[] vec1 = vec();\n-        float[] vec2 = ((FloatVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec_mf();\n+        int length = vspecies().length();\n+        long start_offset = this.multiFieldOffset();\n+        boolean[] bits = new boolean[length];\n+        for (int i = 0; i < length; i++) {\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n+            bits[i] = f.apply(cond, i, v1, v2);\n@@ -554,1 +626,1 @@\n-                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                        ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -708,1 +780,1 @@\n-                    v0.uOp(m, (i, a) -> (float) -a);\n+                    v0.uOpMF(m, (i, a) -> (float) -a);\n@@ -710,1 +782,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.abs(a));\n@@ -712,1 +784,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.sin(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.sin(a));\n@@ -714,1 +786,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.cos(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.cos(a));\n@@ -716,1 +788,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.tan(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.tan(a));\n@@ -718,1 +790,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.asin(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.asin(a));\n@@ -720,1 +792,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.acos(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.acos(a));\n@@ -722,1 +794,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.atan(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.atan(a));\n@@ -724,1 +796,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.exp(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.exp(a));\n@@ -726,1 +798,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.log(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.log(a));\n@@ -728,1 +800,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.log10(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.log10(a));\n@@ -730,1 +802,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.sqrt(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.sqrt(a));\n@@ -732,1 +804,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.cbrt(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.cbrt(a));\n@@ -734,1 +806,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.sinh(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.sinh(a));\n@@ -736,1 +808,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.cosh(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.cosh(a));\n@@ -738,1 +810,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.tanh(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.tanh(a));\n@@ -740,1 +812,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.expm1(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.expm1(a));\n@@ -742,1 +814,1 @@\n-                    v0.uOp(m, (i, a) -> (float) Math.log1p(a));\n+                    v0.uOpMF(m, (i, a) -> (float) Math.log1p(a));\n@@ -777,1 +849,1 @@\n-            BIN_IMPL.find(op, opc, FloatVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, FloatVector::binaryOperationsMF));\n@@ -821,1 +893,27 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.min(a, b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.hypot(a, b));\n+            default: return null;\n+        }\n+    }\n+\n+    private static BinaryOperation<FloatVector, VectorMask<Float>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a + b));\n@@ -823,1 +921,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a - b));\n@@ -825,1 +923,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a * b));\n@@ -827,1 +925,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)(a \/ b));\n@@ -829,1 +927,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.max(a, b));\n@@ -831,1 +929,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float)Math.min(a, b));\n@@ -833,1 +931,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -835,1 +933,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float) Math.atan2(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.atan2(a, b));\n@@ -837,1 +935,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float) Math.pow(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.pow(a, b));\n@@ -839,1 +937,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (float) Math.hypot(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (float) Math.hypot(a, b));\n@@ -844,0 +942,1 @@\n+\n@@ -1031,1 +1130,1 @@\n-                    v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n+                    v0.tOpMF(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n@@ -1907,1 +2006,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -1929,1 +2028,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2054,1 +2153,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2261,1 +2360,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2293,1 +2392,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2321,1 +2420,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2329,1 +2428,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2657,1 +2756,1 @@\n-                    toBits(v.rOp((float)0, m, (i, a, b) -> (float)(a + b)));\n+                    toBits(v.rOpMF((float)0, m, (i, a, b) -> (float)(a + b)));\n@@ -2659,1 +2758,1 @@\n-                    toBits(v.rOp((float)1, m, (i, a, b) -> (float)(a * b)));\n+                    toBits(v.rOpMF((float)1, m, (i, a, b) -> (float)(a * b)));\n@@ -2661,1 +2760,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (float) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (float) Math.min(a, b)));\n@@ -2663,1 +2762,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (float) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (float) Math.max(a, b)));\n@@ -2799,1 +2898,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -2892,1 +2991,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -3078,1 +3177,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3080,0 +3179,1 @@\n+\n@@ -3167,1 +3267,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -3290,1 +3390,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3307,1 +3407,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3342,1 +3442,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -3357,1 +3457,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, FloatVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, FloatVector::memorySegmentGet);\n@@ -3373,1 +3473,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, FloatVector::memorySegmentGet);\n@@ -3392,1 +3492,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3409,1 +3509,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3440,1 +3540,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -3457,1 +3557,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, FloatVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, FloatVector::memorySegmentSet);\n@@ -3474,1 +3574,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, FloatVector::memorySegmentSet);\n@@ -3695,1 +3795,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -3765,0 +3865,6 @@\n+        @ForceInline\n+        @Override final\n+        FloatVector dummyVectorMF() {\n+            return (FloatVector) super.dummyVectorMF();\n+        }\n+\n@@ -3768,1 +3874,1 @@\n-        FloatVector rvOp(RVOp f) {\n+        FloatVector rvOpMF(RVOp f) {\n@@ -3774,1 +3880,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3777,1 +3884,1 @@\n-        FloatVector vOp(FVOp f) {\n+        FloatVector vOpMF(FVOp f) {\n@@ -3782,1 +3889,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3785,1 +3893,1 @@\n-        FloatVector vOp(VectorMask<Float> m, FVOp f) {\n+        FloatVector vOpMF(VectorMask<Float> m, FVOp f) {\n@@ -3793,1 +3901,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3798,1 +3907,1 @@\n-        <M> FloatVector ldOp(M memory, int offset,\n+        <M> FloatVector ldOpMF(M memory, int offset,\n@@ -3800,1 +3909,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -3805,1 +3914,1 @@\n-        <M> FloatVector ldOp(M memory, int offset,\n+        <M> FloatVector ldOpMF(M memory, int offset,\n@@ -3808,1 +3917,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -3811,0 +3920,1 @@\n+\n@@ -3813,1 +3923,1 @@\n-        FloatVector ldLongOp(MemorySegment memory, long offset,\n+        FloatVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3815,1 +3925,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -3820,1 +3930,1 @@\n-        FloatVector ldLongOp(MemorySegment memory, long offset,\n+        FloatVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3823,1 +3933,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -3828,2 +3938,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -3834,2 +3944,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Float> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Float> m,\n@@ -3837,1 +3947,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -3840,0 +3950,1 @@\n+\n@@ -3842,2 +3953,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -3848,1 +3959,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -3851,1 +3962,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -3865,2 +3976,3 @@\n-            if ((Class<?>) vectorType() == FloatMaxVector.class)\n-                return FloatMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == FloatMaxVector.class)\n+            \/\/    return FloatMaxVector.ZERO;\n@@ -3879,2 +3991,3 @@\n-            if ((Class<?>) vectorType() == FloatMaxVector.class)\n-                return FloatMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == FloatMaxVector.class)\n+            \/\/    return FloatMaxVector.IOTA;\n@@ -3894,2 +4007,3 @@\n-            if ((Class<?>) vectorType() == FloatMaxVector.class)\n-                return FloatMaxVector.FloatMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == FloatMaxVector.class)\n+            \/\/    return FloatMaxVector.FloatMaxMask.maskAll(bit);\n@@ -3904,0 +4018,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            float [] init = new float[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (float)i;\n+            }\n+           return init;\n+        }\n@@ -3920,1 +4044,2 @@\n-            case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n@@ -3954,1 +4079,2 @@\n-    public static final VectorSpecies<Float> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Float> SPECIES_MAX\n@@ -3959,0 +4085,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":334,"deletions":207,"binary":false,"changes":541,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Int128Vector extends IntVector {\n+value class Int128Vector extends IntVector {\n@@ -57,2 +58,10 @@\n-    Int128Vector(int[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+\n+    private final VectorSupport.VectorPayloadMF128 payload;\n+\n+    Int128Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Int128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Int128Vector(Object v) {\n-        this((int[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Int128Vector ZERO = new Int128Vector(new int[VLENGTH]);\n-    static final Int128Vector IOTA = new Int128Vector(VSPECIES.iotaArray());\n+    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 4));\n+    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 4, (int [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Int128Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Int128Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Int128Vector uOp(FUnOp f) {\n-        return (Int128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Int128Vector uOpMF(FUnOp f) {\n+        return (Int128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Int128Vector uOp(VectorMask<Integer> m, FUnOp f) {\n+    Int128Vector uOpMF(VectorMask<Integer> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Int128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Int128Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Int128Vector bOp(Vector<Integer> v, FBinOp f) {\n-        return (Int128Vector) super.bOpTemplate((Int128Vector)v, f);  \/\/ specialize\n+    Int128Vector bOpMF(Vector<Integer> v, FBinOp f) {\n+        return (Int128Vector) super.bOpTemplateMF((Int128Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Int128Vector bOp(Vector<Integer> v,\n+    Int128Vector bOpMF(Vector<Integer> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Int128Vector)v, (Int128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Int128Vector)v, (Int128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Int128Vector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n+    Int128Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Int128Vector)v1, (Int128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Int128Vector)v1, (Int128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Int128Vector tOp(Vector<Integer> v1, Vector<Integer> v2,\n+    Int128Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Int128Vector)v1, (Int128Vector)v2,\n-                              (Int128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Int128Vector)v1, (Int128Vector)v2,\n+                                (Int128Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -524,6 +543,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getInt(vecpayload, start_offset + ix * Integer.BYTES);\n+                             });\n@@ -545,1 +565,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -549,3 +569,6 @@\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putInt(tpayload, start_offset + ix * Integer.BYTES, (int)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Int256Vector extends IntVector {\n+value class Int256Vector extends IntVector {\n@@ -57,2 +58,10 @@\n-    Int256Vector(int[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+\n+    private final VectorSupport.VectorPayloadMF256 payload;\n+\n+    Int256Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Int256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Int256Vector(Object v) {\n-        this((int[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Int256Vector ZERO = new Int256Vector(new int[VLENGTH]);\n-    static final Int256Vector IOTA = new Int256Vector(VSPECIES.iotaArray());\n+    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 8));\n+    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 8, (int [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Int256Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Int256Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Int256Vector uOp(FUnOp f) {\n-        return (Int256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Int256Vector uOpMF(FUnOp f) {\n+        return (Int256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Int256Vector uOp(VectorMask<Integer> m, FUnOp f) {\n+    Int256Vector uOpMF(VectorMask<Integer> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Int256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Int256Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Int256Vector bOp(Vector<Integer> v, FBinOp f) {\n-        return (Int256Vector) super.bOpTemplate((Int256Vector)v, f);  \/\/ specialize\n+    Int256Vector bOpMF(Vector<Integer> v, FBinOp f) {\n+        return (Int256Vector) super.bOpTemplateMF((Int256Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Int256Vector bOp(Vector<Integer> v,\n+    Int256Vector bOpMF(Vector<Integer> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Int256Vector)v, (Int256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Int256Vector)v, (Int256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Int256Vector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n+    Int256Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Int256Vector)v1, (Int256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Int256Vector)v1, (Int256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Int256Vector tOp(Vector<Integer> v1, Vector<Integer> v2,\n+    Int256Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Int256Vector)v1, (Int256Vector)v2,\n-                              (Int256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Int256Vector)v1, (Int256Vector)v2,\n+                                (Int256Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -528,6 +547,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getInt(vecpayload, start_offset + ix * Integer.BYTES);\n+                             });\n@@ -553,1 +573,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -557,3 +577,6 @@\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putInt(tpayload, start_offset + ix * Integer.BYTES, (int)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Int512Vector extends IntVector {\n+value class Int512Vector extends IntVector {\n@@ -57,2 +58,10 @@\n-    Int512Vector(int[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+\n+    private final VectorSupport.VectorPayloadMF512 payload;\n+\n+    Int512Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Int512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Int512Vector(Object v) {\n-        this((int[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Int512Vector ZERO = new Int512Vector(new int[VLENGTH]);\n-    static final Int512Vector IOTA = new Int512Vector(VSPECIES.iotaArray());\n+    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 16));\n+    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 16, (int [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Int512Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Int512Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Int512Vector uOp(FUnOp f) {\n-        return (Int512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Int512Vector uOpMF(FUnOp f) {\n+        return (Int512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Int512Vector uOp(VectorMask<Integer> m, FUnOp f) {\n+    Int512Vector uOpMF(VectorMask<Integer> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Int512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Int512Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Int512Vector bOp(Vector<Integer> v, FBinOp f) {\n-        return (Int512Vector) super.bOpTemplate((Int512Vector)v, f);  \/\/ specialize\n+    Int512Vector bOpMF(Vector<Integer> v, FBinOp f) {\n+        return (Int512Vector) super.bOpTemplateMF((Int512Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Int512Vector bOp(Vector<Integer> v,\n+    Int512Vector bOpMF(Vector<Integer> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Int512Vector)v, (Int512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Int512Vector)v, (Int512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Int512Vector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n+    Int512Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Int512Vector)v1, (Int512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Int512Vector)v1, (Int512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Int512Vector tOp(Vector<Integer> v1, Vector<Integer> v2,\n+    Int512Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Int512Vector)v1, (Int512Vector)v2,\n-                              (Int512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Int512Vector)v1, (Int512Vector)v2,\n+                                (Int512Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -536,6 +555,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getInt(vecpayload, start_offset + ix * Integer.BYTES);\n+                             });\n@@ -569,1 +589,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -573,3 +593,6 @@\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putInt(tpayload, start_offset + ix * Integer.BYTES, (int)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Int64Vector extends IntVector {\n+value class Int64Vector extends IntVector {\n@@ -57,2 +58,10 @@\n-    Int64Vector(int[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+\n+    private final VectorSupport.VectorPayloadMF64 payload;\n+\n+    Int64Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Int64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Int64Vector(Object v) {\n-        this((int[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Int64Vector ZERO = new Int64Vector(new int[VLENGTH]);\n-    static final Int64Vector IOTA = new Int64Vector(VSPECIES.iotaArray());\n+    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.createVectPayloadInstance(Integer.BYTES, 2));\n+    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(Integer.BYTES, 2, (int [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Int64Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Int64Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Int64Vector uOp(FUnOp f) {\n-        return (Int64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Int64Vector uOpMF(FUnOp f) {\n+        return (Int64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Int64Vector uOp(VectorMask<Integer> m, FUnOp f) {\n+    Int64Vector uOpMF(VectorMask<Integer> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Int64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Int64Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Int64Vector bOp(Vector<Integer> v, FBinOp f) {\n-        return (Int64Vector) super.bOpTemplate((Int64Vector)v, f);  \/\/ specialize\n+    Int64Vector bOpMF(Vector<Integer> v, FBinOp f) {\n+        return (Int64Vector) super.bOpTemplateMF((Int64Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Int64Vector bOp(Vector<Integer> v,\n+    Int64Vector bOpMF(Vector<Integer> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Int64Vector)v, (Int64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Int64Vector)v, (Int64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Int64Vector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n+    Int64Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Int64Vector)v1, (Int64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Int64Vector)v1, (Int64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Int64Vector tOp(Vector<Integer> v1, Vector<Integer> v2,\n+    Int64Vector tOpMF(Vector<Integer> v1, Vector<Integer> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Int64Vector)v1, (Int64Vector)v2,\n-                              (Int64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Int64Vector)v1, (Int64Vector)v2,\n+                                (Int64Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -522,6 +541,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getInt(vecpayload, start_offset + ix * Integer.BYTES);\n+                             });\n@@ -541,1 +561,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -545,3 +565,6 @@\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putInt(tpayload, start_offset + ix * Integer.BYTES, (int)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,924 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class IntMaxVector extends IntVector {\n-    static final IntSpecies VSPECIES =\n-        (IntSpecies) IntVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<IntMaxVector> VCLASS = IntMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n-\n-    IntMaxVector(int[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as IntMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    IntMaxVector(Object v) {\n-        this((int[]) v);\n-    }\n-\n-    static final IntMaxVector ZERO = new IntMaxVector(new int[VLENGTH]);\n-    static final IntMaxVector IOTA = new IntMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public IntSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Integer> elementType() { return int.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Integer.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxVector broadcast(int e) {\n-        return (IntMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxVector broadcast(long e) {\n-        return (IntMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxMask maskFromArray(boolean[] bits) {\n-        return new IntMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle iotaShuffle() { return IntMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    IntMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle shuffleFromBytes(byte[] reorder) { return new IntMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle shuffleFromArray(int[] indexes, int i) { return new IntMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new IntMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    IntMaxVector vectorFactory(int[] vec) {\n-        return new IntMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector uOp(FUnOp f) {\n-        return (IntMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector uOp(VectorMask<Integer> m, FUnOp f) {\n-        return (IntMaxVector)\n-            super.uOpTemplate((IntMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector bOp(Vector<Integer> v, FBinOp f) {\n-        return (IntMaxVector) super.bOpTemplate((IntMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector bOp(Vector<Integer> v,\n-                     VectorMask<Integer> m, FBinOp f) {\n-        return (IntMaxVector)\n-            super.bOpTemplate((IntMaxVector)v, (IntMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector tOp(Vector<Integer> v1, Vector<Integer> v2, FTriOp f) {\n-        return (IntMaxVector)\n-            super.tOpTemplate((IntMaxVector)v1, (IntMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    IntMaxVector tOp(Vector<Integer> v1, Vector<Integer> v2,\n-                     VectorMask<Integer> m, FTriOp f) {\n-        return (IntMaxVector)\n-            super.tOpTemplate((IntMaxVector)v1, (IntMaxVector)v2,\n-                              (IntMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Integer,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector lanewise(Unary op) {\n-        return (IntMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector lanewise(Unary op, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector lanewise(Binary op, Vector<Integer> v) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector lanewise(Binary op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline IntMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e) {\n-        return (IntMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline IntMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewiseShiftTemplate(op, IntMaxMask.class, e, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    IntMaxVector\n-    lanewise(Ternary op, Vector<Integer> v1, Vector<Integer> v2) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    IntMaxVector\n-    lanewise(Ternary op, Vector<Integer> v1, Vector<Integer> v2, VectorMask<Integer> m) {\n-        return (IntMaxVector) super.lanewiseTemplate(op, IntMaxMask.class, v1, v2, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    IntMaxVector addIndex(int scale) {\n-        return (IntMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final int reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final int reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Integer> m) {\n-        return super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Integer> m) {\n-        return (long) super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask test(Test op) {\n-        return super.testTemplate(IntMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask test(Test op, VectorMask<Integer> m) {\n-        return super.testTemplate(IntMaxMask.class, op, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask compare(Comparison op, Vector<Integer> v) {\n-        return super.compareTemplate(IntMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask compare(Comparison op, int s) {\n-        return super.compareTemplate(IntMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(IntMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final IntMaxMask compare(Comparison op, Vector<Integer> v, VectorMask<Integer> m) {\n-        return super.compareTemplate(IntMaxMask.class, op, v, (IntMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector blend(Vector<Integer> v, VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.blendTemplate(IntMaxMask.class,\n-                                (IntMaxVector) v,\n-                                (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector slice(int origin, Vector<Integer> v) {\n-        return (IntMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector slice(int origin) {\n-        return (IntMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector unslice(int origin, Vector<Integer> w, int part) {\n-        return (IntMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector unslice(int origin, Vector<Integer> w, int part, VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.unsliceTemplate(IntMaxMask.class,\n-                                  origin, w, part,\n-                                  (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector unslice(int origin) {\n-        return (IntMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector rearrange(VectorShuffle<Integer> s) {\n-        return (IntMaxVector)\n-            super.rearrangeTemplate(IntMaxShuffle.class,\n-                                    (IntMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector rearrange(VectorShuffle<Integer> shuffle,\n-                                  VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.rearrangeTemplate(IntMaxShuffle.class,\n-                                    IntMaxMask.class,\n-                                    (IntMaxShuffle) shuffle,\n-                                    (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector rearrange(VectorShuffle<Integer> s,\n-                                  Vector<Integer> v) {\n-        return (IntMaxVector)\n-            super.rearrangeTemplate(IntMaxShuffle.class,\n-                                    (IntMaxShuffle) s,\n-                                    (IntMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector compress(VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.compressTemplate(IntMaxMask.class,\n-                                   (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector expand(VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.expandTemplate(IntMaxMask.class,\n-                                   (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector selectFrom(Vector<Integer> v) {\n-        return (IntMaxVector)\n-            super.selectFromTemplate((IntMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public IntMaxVector selectFrom(Vector<Integer> v,\n-                                   VectorMask<Integer> m) {\n-        return (IntMaxVector)\n-            super.selectFromTemplate((IntMaxVector) v,\n-                                     (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public int lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return laneHelper(i);\n-    }\n-\n-    public int laneHelper(int i) {\n-        return (int) VectorSupport.extract(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    int[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public IntMaxVector withLane(int i, int e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public IntMaxVector withLaneHelper(int i, int e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)e,\n-                                (v, ix, bits) -> {\n-                                    int[] res = v.vec().clone();\n-                                    res[ix] = (int)bits;\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class IntMaxMask extends AbstractMask<Integer> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n-\n-        IntMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        IntMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        IntMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public IntSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        IntMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new IntMaxMask(res);\n-        }\n-\n-        @Override\n-        IntMaxMask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((IntMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new IntMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        IntMaxVector toVector() {\n-            return (IntMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask eq(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            IntMaxMask m = (IntMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask compress() {\n-            return (IntMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                IntMaxVector.class, IntMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask and(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            IntMaxMask m = (IntMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxMask or(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            IntMaxMask m = (IntMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @ForceInline\n-        \/* package-private *\/\n-        IntMaxMask xor(VectorMask<Integer> mask) {\n-            Objects.requireNonNull(mask);\n-            IntMaxMask m = (IntMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static IntMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final IntMaxMask  TRUE_MASK = new IntMaxMask(true);\n-        private static final IntMaxMask FALSE_MASK = new IntMaxMask(false);\n-\n-\n-        static boolean[] maskLowerHalf() {\n-            boolean[] a = new boolean[VLENGTH];\n-            int len = a.length >> 1;\n-            for (int i = 0; i < len; i++) {\n-                a[i] = true;\n-            }\n-            return a;\n-        }\n-\n-        static final IntMaxMask LOWER_HALF_TRUE_MASK = new IntMaxMask(maskLowerHalf());\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class IntMaxShuffle extends AbstractShuffle<Integer> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n-\n-        IntMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public IntMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public IntMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public IntMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public IntSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final IntMaxShuffle IOTA = new IntMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public IntMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, IntMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((IntMaxVector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            IntMaxShuffle s = (IntMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new IntMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromArray0(int[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m, int offsetInRange) {\n-        return super.fromArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(int[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(int[] a, int offset, VectorMask<Integer> m) {\n-        super.intoArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        super.intoArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n-        super.intoMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":0,"deletions":924,"binary":false,"changes":924,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    IntVector(int[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public IntVector() {}\n@@ -99,0 +99,2 @@\n+    abstract VectorPayloadMF vec_mf();\n+\n@@ -108,0 +110,2 @@\n+    abstract IntVector vectorFactory(VectorPayloadMF vec);\n+\n@@ -127,1 +131,1 @@\n-    IntVector vOp(FVOp f) {\n+    IntVector vOpMF(FVOp f) {\n@@ -132,1 +136,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +142,1 @@\n-    IntVector vOp(VectorMask<Integer> m, FVOp f) {\n+    IntVector vOpMF(VectorMask<Integer> m, FVOp f) {\n@@ -145,1 +150,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +163,1 @@\n-    IntVector uOp(FUnOp f);\n+    IntVector uOpMF(FUnOp f);\n@@ -160,5 +166,8 @@\n-    IntVector uOpTemplate(FUnOp f) {\n-        int[] vec = vec();\n-        int[] res = new int[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    IntVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v));\n@@ -166,1 +175,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +181,1 @@\n-    IntVector uOp(VectorMask<Integer> m,\n+    IntVector uOpMF(VectorMask<Integer> m,\n@@ -175,1 +185,1 @@\n-    IntVector uOpTemplate(VectorMask<Integer> m,\n+    IntVector uOpTemplateMF(VectorMask<Integer> m,\n@@ -178,1 +188,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,2 +190,0 @@\n-        int[] vec = vec();\n-        int[] res = new int[length()];\n@@ -183,2 +191,7 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v): v);\n@@ -186,1 +199,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +212,1 @@\n-    IntVector bOp(Vector<Integer> o,\n+    IntVector bOpMF(Vector<Integer> o,\n@@ -202,1 +216,1 @@\n-    IntVector bOpTemplate(Vector<Integer> o,\n+    IntVector bOpTemplateMF(Vector<Integer> o,\n@@ -204,5 +218,9 @@\n-        int[] res = new int[length()];\n-        int[] vec1 = this.vec();\n-        int[] vec2 = ((IntVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +228,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +234,1 @@\n-    IntVector bOp(Vector<Integer> o,\n+    IntVector bOpMF(Vector<Integer> o,\n@@ -220,1 +239,1 @@\n-    IntVector bOpTemplate(Vector<Integer> o,\n+    IntVector bOpTemplateMF(Vector<Integer> o,\n@@ -224,1 +243,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,3 +245,0 @@\n-        int[] res = new int[length()];\n-        int[] vec1 = this.vec();\n-        int[] vec2 = ((IntVector)o).vec();\n@@ -230,2 +246,9 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n@@ -233,1 +256,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +269,1 @@\n-    IntVector tOp(Vector<Integer> o1,\n+    IntVector tOpMF(Vector<Integer> o1,\n@@ -250,1 +274,1 @@\n-    IntVector tOpTemplate(Vector<Integer> o1,\n+    IntVector tOpTemplateMF(Vector<Integer> o1,\n@@ -253,6 +277,11 @@\n-        int[] res = new int[length()];\n-        int[] vec1 = this.vec();\n-        int[] vec2 = ((IntVector)o1).vec();\n-        int[] vec3 = ((IntVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((IntVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((IntVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n+            int v3 = Unsafe.getUnsafe().getInt(vec3, start_offset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +289,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +295,1 @@\n-    IntVector tOp(Vector<Integer> o1,\n+    IntVector tOpMF(Vector<Integer> o1,\n@@ -271,1 +301,1 @@\n-    IntVector tOpTemplate(Vector<Integer> o1,\n+    IntVector tOpTemplateMF(Vector<Integer> o1,\n@@ -276,1 +306,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,4 +308,0 @@\n-        int[] res = new int[length()];\n-        int[] vec1 = this.vec();\n-        int[] vec2 = ((IntVector)o1).vec();\n-        int[] vec3 = ((IntVector)o2).vec();\n@@ -283,2 +309,11 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((IntVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((IntVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n+            int v3 = Unsafe.getUnsafe().getInt(vec3, start_offset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    int rOp(int v, VectorMask<Integer> m, FBinOp f);\n+    int rOpMF(int v, VectorMask<Integer> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    int rOpTemplate(int v, VectorMask<Integer> m, FBinOp f) {\n+    int rOpTemplateMF(int v, VectorMask<Integer> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,1 +337,1 @@\n-        int[] vec = vec();\n+        VectorPayloadMF vec = this.vec_mf();\n@@ -303,2 +339,5 @@\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n+            v = mbits[i] ? f.apply(i, v, v1) : v;\n@@ -311,4 +350,7 @@\n-    int rOpTemplate(int v, FBinOp f) {\n-        int[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    int rOpTemplateMF(int v, FBinOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +371,1 @@\n-    <M> IntVector ldOp(M memory, int offset,\n+    <M> IntVector ldOpMF(M memory, int offset,\n@@ -331,4 +373,7 @@\n-        \/\/dummy; no vec = vec();\n-        int[] res = new int[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Integer.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +381,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +388,1 @@\n-    <M> IntVector ldOp(M memory, int offset,\n+    <M> IntVector ldOpMF(M memory, int offset,\n@@ -345,2 +391,5 @@\n-        \/\/int[] vec = vec();\n-        int[] res = new int[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Integer.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -348,1 +397,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -350,1 +399,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +402,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +406,1 @@\n+\n@@ -364,1 +415,1 @@\n-    IntVector ldLongOp(MemorySegment memory, long offset,\n+    IntVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +417,7 @@\n-        \/\/dummy; no vec = vec();\n-        int[] res = new int[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Integer.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +425,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +432,1 @@\n-    IntVector ldLongOp(MemorySegment memory, long offset,\n+    IntVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,2 +435,5 @@\n-        \/\/int[] vec = vec();\n-        int[] res = new int[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Integer.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -383,1 +441,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -385,1 +443,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +446,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +461,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +463,5 @@\n-        int[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n@@ -411,1 +472,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +474,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,1 +477,1 @@\n-        int[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -418,1 +479,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -420,1 +483,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n@@ -425,0 +488,1 @@\n+\n@@ -432,1 +496,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +498,5 @@\n-        int[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n@@ -443,1 +509,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,1 +512,1 @@\n-        int[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -448,1 +514,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -450,1 +518,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n@@ -469,1 +537,1 @@\n-    AbstractMask<Integer> bTest(int cond,\n+    AbstractMask<Integer> bTestMF(int cond,\n@@ -472,5 +540,9 @@\n-        int[] vec1 = vec();\n-        int[] vec2 = ((IntVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec_mf();\n+        int length = vspecies().length();\n+        long start_offset = this.multiFieldOffset();\n+        boolean[] bits = new boolean[length];\n+        for (int i = 0; i < length; i++) {\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n+            bits[i] = f.apply(cond, i, v1, v2);\n@@ -565,1 +637,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -725,1 +797,1 @@\n-                    v0.uOp(m, (i, a) -> (int) -a);\n+                    v0.uOpMF(m, (i, a) -> (int) -a);\n@@ -727,1 +799,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Math.abs(a));\n@@ -729,1 +801,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.bitCount(a));\n@@ -731,1 +803,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.numberOfTrailingZeros(a));\n@@ -733,1 +805,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.numberOfLeadingZeros(a));\n@@ -735,1 +807,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.reverse(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.reverse(a));\n@@ -737,1 +809,1 @@\n-                    v0.uOp(m, (i, a) -> (int) Integer.reverseBytes(a));\n+                    v0.uOpMF(m, (i, a) -> (int) Integer.reverseBytes(a));\n@@ -787,1 +859,1 @@\n-            BIN_IMPL.find(op, opc, IntVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, IntVector::binaryOperationsMF));\n@@ -847,1 +919,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a + b));\n@@ -849,1 +921,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a - b));\n@@ -851,1 +923,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a * b));\n@@ -853,1 +925,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a \/ b));\n@@ -855,1 +927,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.max(a, b));\n@@ -857,1 +929,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.min(a, b));\n@@ -859,1 +931,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a & b));\n@@ -861,1 +933,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a | b));\n@@ -863,1 +935,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (int)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a ^ b));\n@@ -865,1 +937,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (int)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)(a << n));\n@@ -867,1 +939,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (int)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)(a >> n));\n@@ -869,1 +941,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n@@ -871,1 +943,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -873,1 +945,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -875,1 +947,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> Integer.compress(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Integer.compress(a, n));\n@@ -877,1 +949,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> Integer.expand(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Integer.expand(a, n));\n@@ -882,0 +954,39 @@\n+    private static BinaryOperation<IntVector, VectorMask<Integer>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (int)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Integer.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Integer.expand(a, n));\n+            default: return null;\n+        }\n+    }\n+\n+\n@@ -1046,1 +1157,1 @@\n-                    v.uOp(m, (i, a) -> (int)(a << n));\n+                    v.uOpMF(m, (i, a) -> (int)(a << n));\n@@ -1048,1 +1159,1 @@\n-                    v.uOp(m, (i, a) -> (int)(a >> n));\n+                    v.uOpMF(m, (i, a) -> (int)(a >> n));\n@@ -1050,1 +1161,1 @@\n-                    v.uOp(m, (i, a) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> (int)((a & LSHR_SETUP_MASK) >>> n));\n@@ -1052,1 +1163,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -1054,1 +1165,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -2034,1 +2145,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2056,1 +2167,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2185,1 +2296,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2392,1 +2503,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2424,1 +2535,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2452,1 +2563,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2460,1 +2571,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2802,1 +2913,1 @@\n-                    toBits(v.rOp((int)0, m, (i, a, b) -> (int)(a + b)));\n+                    toBits(v.rOpMF((int)0, m, (i, a, b) -> (int)(a + b)));\n@@ -2804,1 +2915,1 @@\n-                    toBits(v.rOp((int)1, m, (i, a, b) -> (int)(a * b)));\n+                    toBits(v.rOpMF((int)1, m, (i, a, b) -> (int)(a * b)));\n@@ -2806,1 +2917,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (int) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (int) Math.min(a, b)));\n@@ -2808,1 +2919,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (int) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (int) Math.max(a, b)));\n@@ -2810,1 +2921,1 @@\n-                    toBits(v.rOp((int)-1, m, (i, a, b) -> (int)(a & b)));\n+                    toBits(v.rOpMF((int)-1, m, (i, a, b) -> (int)(a & b)));\n@@ -2812,1 +2923,1 @@\n-                    toBits(v.rOp((int)0, m, (i, a, b) -> (int)(a | b)));\n+                    toBits(v.rOpMF((int)0, m, (i, a, b) -> (int)(a | b)));\n@@ -2814,1 +2925,1 @@\n-                    toBits(v.rOp((int)0, m, (i, a, b) -> (int)(a ^ b)));\n+                    toBits(v.rOpMF((int)0, m, (i, a, b) -> (int)(a ^ b)));\n@@ -2955,1 +3066,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -3048,1 +3159,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -3234,1 +3345,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3236,0 +3347,1 @@\n+\n@@ -3323,1 +3435,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -3446,1 +3558,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3463,1 +3575,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3498,1 +3610,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -3513,1 +3625,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, IntVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, IntVector::memorySegmentGet);\n@@ -3529,1 +3641,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, IntVector::memorySegmentGet);\n@@ -3548,1 +3660,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3565,1 +3677,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3596,1 +3708,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -3613,1 +3725,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, IntVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, IntVector::memorySegmentSet);\n@@ -3630,1 +3742,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, IntVector::memorySegmentSet);\n@@ -3851,1 +3963,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -3921,0 +4033,6 @@\n+        @ForceInline\n+        @Override final\n+        IntVector dummyVectorMF() {\n+            return (IntVector) super.dummyVectorMF();\n+        }\n+\n@@ -3924,1 +4042,1 @@\n-        IntVector rvOp(RVOp f) {\n+        IntVector rvOpMF(RVOp f) {\n@@ -3930,1 +4048,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3933,1 +4052,1 @@\n-        IntVector vOp(FVOp f) {\n+        IntVector vOpMF(FVOp f) {\n@@ -3938,1 +4057,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3941,1 +4061,1 @@\n-        IntVector vOp(VectorMask<Integer> m, FVOp f) {\n+        IntVector vOpMF(VectorMask<Integer> m, FVOp f) {\n@@ -3949,1 +4069,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3954,1 +4075,1 @@\n-        <M> IntVector ldOp(M memory, int offset,\n+        <M> IntVector ldOpMF(M memory, int offset,\n@@ -3956,1 +4077,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -3961,1 +4082,1 @@\n-        <M> IntVector ldOp(M memory, int offset,\n+        <M> IntVector ldOpMF(M memory, int offset,\n@@ -3964,1 +4085,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -3967,0 +4088,1 @@\n+\n@@ -3969,1 +4091,1 @@\n-        IntVector ldLongOp(MemorySegment memory, long offset,\n+        IntVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3971,1 +4093,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -3976,1 +4098,1 @@\n-        IntVector ldLongOp(MemorySegment memory, long offset,\n+        IntVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3979,1 +4101,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -3984,2 +4106,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -3990,2 +4112,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Integer> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Integer> m,\n@@ -3993,1 +4115,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -3996,0 +4118,1 @@\n+\n@@ -3998,2 +4121,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -4004,1 +4127,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -4007,1 +4130,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -4021,2 +4144,3 @@\n-            if ((Class<?>) vectorType() == IntMaxVector.class)\n-                return IntMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == IntMaxVector.class)\n+            \/\/    return IntMaxVector.ZERO;\n@@ -4035,2 +4159,3 @@\n-            if ((Class<?>) vectorType() == IntMaxVector.class)\n-                return IntMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == IntMaxVector.class)\n+            \/\/    return IntMaxVector.IOTA;\n@@ -4050,2 +4175,3 @@\n-            if ((Class<?>) vectorType() == IntMaxVector.class)\n-                return IntMaxVector.IntMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == IntMaxVector.class)\n+            \/\/    return IntMaxVector.IntMaxMask.maskAll(bit);\n@@ -4060,0 +4186,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            int [] init = new int[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (int)i;\n+            }\n+           return init;\n+        }\n@@ -4076,1 +4212,2 @@\n-            case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;\n@@ -4110,1 +4247,2 @@\n-    public static final VectorSpecies<Integer> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Integer> SPECIES_MAX\n@@ -4115,0 +4253,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":346,"deletions":207,"binary":false,"changes":553,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Long128Vector extends LongVector {\n+value class Long128Vector extends LongVector {\n@@ -57,2 +58,10 @@\n-    Long128Vector(long[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+\n+    private final VectorSupport.VectorPayloadMF128 payload;\n+\n+    Long128Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Long128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Long128Vector(Object v) {\n-        this((long[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Long128Vector ZERO = new Long128Vector(new long[VLENGTH]);\n-    static final Long128Vector IOTA = new Long128Vector(VSPECIES.iotaArray());\n+    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 2));\n+    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 2, (long [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -169,0 +181,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Long128Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Long128Vector(vec);\n+    }\n+\n@@ -185,2 +204,2 @@\n-    Long128Vector uOp(FUnOp f) {\n-        return (Long128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Long128Vector uOpMF(FUnOp f) {\n+        return (Long128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -191,1 +210,1 @@\n-    Long128Vector uOp(VectorMask<Long> m, FUnOp f) {\n+    Long128Vector uOpMF(VectorMask<Long> m, FUnOp f) {\n@@ -193,1 +212,1 @@\n-            super.uOpTemplate((Long128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Long128Mask)m, f);  \/\/ specialize\n@@ -200,2 +219,2 @@\n-    Long128Vector bOp(Vector<Long> v, FBinOp f) {\n-        return (Long128Vector) super.bOpTemplate((Long128Vector)v, f);  \/\/ specialize\n+    Long128Vector bOpMF(Vector<Long> v, FBinOp f) {\n+        return (Long128Vector) super.bOpTemplateMF((Long128Vector)v, f);  \/\/ specialize\n@@ -206,1 +225,1 @@\n-    Long128Vector bOp(Vector<Long> v,\n+    Long128Vector bOpMF(Vector<Long> v,\n@@ -209,2 +228,2 @@\n-            super.bOpTemplate((Long128Vector)v, (Long128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Long128Vector)v, (Long128Mask)m,\n+                                f);  \/\/ specialize\n@@ -217,1 +236,1 @@\n-    Long128Vector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n+    Long128Vector tOpMF(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n@@ -219,2 +238,2 @@\n-            super.tOpTemplate((Long128Vector)v1, (Long128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Long128Vector)v1, (Long128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -225,1 +244,1 @@\n-    Long128Vector tOp(Vector<Long> v1, Vector<Long> v2,\n+    Long128Vector tOpMF(Vector<Long> v1, Vector<Long> v2,\n@@ -228,2 +247,2 @@\n-            super.tOpTemplate((Long128Vector)v1, (Long128Vector)v2,\n-                              (Long128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Long128Vector)v1, (Long128Vector)v2,\n+                                (Long128Mask)m, f);  \/\/ specialize\n@@ -234,2 +253,2 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -512,6 +531,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getLong(vecpayload, start_offset + ix * Long.BYTES);\n+                             });\n@@ -531,1 +551,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -535,3 +555,6 @@\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putLong(tpayload, start_offset + ix * Long.BYTES, (long)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Long256Vector extends LongVector {\n+value class Long256Vector extends LongVector {\n@@ -57,2 +58,10 @@\n-    Long256Vector(long[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+\n+    private final VectorSupport.VectorPayloadMF256 payload;\n+\n+    Long256Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Long256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Long256Vector(Object v) {\n-        this((long[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Long256Vector ZERO = new Long256Vector(new long[VLENGTH]);\n-    static final Long256Vector IOTA = new Long256Vector(VSPECIES.iotaArray());\n+    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 4));\n+    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 4, (long [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -169,0 +181,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Long256Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Long256Vector(vec);\n+    }\n+\n@@ -185,2 +204,2 @@\n-    Long256Vector uOp(FUnOp f) {\n-        return (Long256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Long256Vector uOpMF(FUnOp f) {\n+        return (Long256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -191,1 +210,1 @@\n-    Long256Vector uOp(VectorMask<Long> m, FUnOp f) {\n+    Long256Vector uOpMF(VectorMask<Long> m, FUnOp f) {\n@@ -193,1 +212,1 @@\n-            super.uOpTemplate((Long256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Long256Mask)m, f);  \/\/ specialize\n@@ -200,2 +219,2 @@\n-    Long256Vector bOp(Vector<Long> v, FBinOp f) {\n-        return (Long256Vector) super.bOpTemplate((Long256Vector)v, f);  \/\/ specialize\n+    Long256Vector bOpMF(Vector<Long> v, FBinOp f) {\n+        return (Long256Vector) super.bOpTemplateMF((Long256Vector)v, f);  \/\/ specialize\n@@ -206,1 +225,1 @@\n-    Long256Vector bOp(Vector<Long> v,\n+    Long256Vector bOpMF(Vector<Long> v,\n@@ -209,2 +228,2 @@\n-            super.bOpTemplate((Long256Vector)v, (Long256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Long256Vector)v, (Long256Mask)m,\n+                                f);  \/\/ specialize\n@@ -217,1 +236,1 @@\n-    Long256Vector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n+    Long256Vector tOpMF(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n@@ -219,2 +238,2 @@\n-            super.tOpTemplate((Long256Vector)v1, (Long256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Long256Vector)v1, (Long256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -225,1 +244,1 @@\n-    Long256Vector tOp(Vector<Long> v1, Vector<Long> v2,\n+    Long256Vector tOpMF(Vector<Long> v1, Vector<Long> v2,\n@@ -228,2 +247,2 @@\n-            super.tOpTemplate((Long256Vector)v1, (Long256Vector)v2,\n-                              (Long256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Long256Vector)v1, (Long256Vector)v2,\n+                                (Long256Mask)m, f);  \/\/ specialize\n@@ -234,2 +253,2 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -514,6 +533,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getLong(vecpayload, start_offset + ix * Long.BYTES);\n+                             });\n@@ -535,1 +555,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -539,3 +559,6 @@\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putLong(tpayload, start_offset + ix * Long.BYTES, (long)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Long512Vector extends LongVector {\n+value class Long512Vector extends LongVector {\n@@ -57,2 +58,10 @@\n-    Long512Vector(long[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+\n+    private final VectorSupport.VectorPayloadMF512 payload;\n+\n+    Long512Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Long512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Long512Vector(Object v) {\n-        this((long[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Long512Vector ZERO = new Long512Vector(new long[VLENGTH]);\n-    static final Long512Vector IOTA = new Long512Vector(VSPECIES.iotaArray());\n+    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 8));\n+    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 8, (long [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -169,0 +181,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Long512Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Long512Vector(vec);\n+    }\n+\n@@ -185,2 +204,2 @@\n-    Long512Vector uOp(FUnOp f) {\n-        return (Long512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Long512Vector uOpMF(FUnOp f) {\n+        return (Long512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -191,1 +210,1 @@\n-    Long512Vector uOp(VectorMask<Long> m, FUnOp f) {\n+    Long512Vector uOpMF(VectorMask<Long> m, FUnOp f) {\n@@ -193,1 +212,1 @@\n-            super.uOpTemplate((Long512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Long512Mask)m, f);  \/\/ specialize\n@@ -200,2 +219,2 @@\n-    Long512Vector bOp(Vector<Long> v, FBinOp f) {\n-        return (Long512Vector) super.bOpTemplate((Long512Vector)v, f);  \/\/ specialize\n+    Long512Vector bOpMF(Vector<Long> v, FBinOp f) {\n+        return (Long512Vector) super.bOpTemplateMF((Long512Vector)v, f);  \/\/ specialize\n@@ -206,1 +225,1 @@\n-    Long512Vector bOp(Vector<Long> v,\n+    Long512Vector bOpMF(Vector<Long> v,\n@@ -209,2 +228,2 @@\n-            super.bOpTemplate((Long512Vector)v, (Long512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Long512Vector)v, (Long512Mask)m,\n+                                f);  \/\/ specialize\n@@ -217,1 +236,1 @@\n-    Long512Vector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n+    Long512Vector tOpMF(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n@@ -219,2 +238,2 @@\n-            super.tOpTemplate((Long512Vector)v1, (Long512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Long512Vector)v1, (Long512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -225,1 +244,1 @@\n-    Long512Vector tOp(Vector<Long> v1, Vector<Long> v2,\n+    Long512Vector tOpMF(Vector<Long> v1, Vector<Long> v2,\n@@ -228,2 +247,2 @@\n-            super.tOpTemplate((Long512Vector)v1, (Long512Vector)v2,\n-                              (Long512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Long512Vector)v1, (Long512Vector)v2,\n+                                (Long512Mask)m, f);  \/\/ specialize\n@@ -234,2 +253,2 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -518,6 +537,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getLong(vecpayload, start_offset + ix * Long.BYTES);\n+                             });\n@@ -543,1 +563,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -547,3 +567,6 @@\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putLong(tpayload, start_offset + ix * Long.BYTES, (long)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Long64Vector extends LongVector {\n+value class Long64Vector extends LongVector {\n@@ -57,2 +58,10 @@\n-    Long64Vector(long[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+\n+    private final VectorSupport.VectorPayloadMF64 payload;\n+\n+    Long64Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Long64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Long64Vector(Object v) {\n-        this((long[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Long64Vector ZERO = new Long64Vector(new long[VLENGTH]);\n-    static final Long64Vector IOTA = new Long64Vector(VSPECIES.iotaArray());\n+    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.createVectPayloadInstance(Long.BYTES, 1));\n+    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(Long.BYTES, 1, (long [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -169,0 +181,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Long64Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Long64Vector(vec);\n+    }\n+\n@@ -185,2 +204,2 @@\n-    Long64Vector uOp(FUnOp f) {\n-        return (Long64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Long64Vector uOpMF(FUnOp f) {\n+        return (Long64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -191,1 +210,1 @@\n-    Long64Vector uOp(VectorMask<Long> m, FUnOp f) {\n+    Long64Vector uOpMF(VectorMask<Long> m, FUnOp f) {\n@@ -193,1 +212,1 @@\n-            super.uOpTemplate((Long64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Long64Mask)m, f);  \/\/ specialize\n@@ -200,2 +219,2 @@\n-    Long64Vector bOp(Vector<Long> v, FBinOp f) {\n-        return (Long64Vector) super.bOpTemplate((Long64Vector)v, f);  \/\/ specialize\n+    Long64Vector bOpMF(Vector<Long> v, FBinOp f) {\n+        return (Long64Vector) super.bOpTemplateMF((Long64Vector)v, f);  \/\/ specialize\n@@ -206,1 +225,1 @@\n-    Long64Vector bOp(Vector<Long> v,\n+    Long64Vector bOpMF(Vector<Long> v,\n@@ -209,2 +228,2 @@\n-            super.bOpTemplate((Long64Vector)v, (Long64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Long64Vector)v, (Long64Mask)m,\n+                                f);  \/\/ specialize\n@@ -217,1 +236,1 @@\n-    Long64Vector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n+    Long64Vector tOpMF(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n@@ -219,2 +238,2 @@\n-            super.tOpTemplate((Long64Vector)v1, (Long64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Long64Vector)v1, (Long64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -225,1 +244,1 @@\n-    Long64Vector tOp(Vector<Long> v1, Vector<Long> v2,\n+    Long64Vector tOpMF(Vector<Long> v1, Vector<Long> v2,\n@@ -228,2 +247,2 @@\n-            super.tOpTemplate((Long64Vector)v1, (Long64Vector)v2,\n-                              (Long64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Long64Vector)v1, (Long64Vector)v2,\n+                                (Long64Mask)m, f);  \/\/ specialize\n@@ -234,2 +253,2 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -511,6 +530,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getLong(vecpayload, start_offset + ix * Long.BYTES);\n+                             });\n@@ -529,1 +549,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -533,3 +553,6 @@\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putLong(tpayload, start_offset + ix * Long.BYTES, (long)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,903 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class LongMaxVector extends LongVector {\n-    static final LongSpecies VSPECIES =\n-        (LongSpecies) LongVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<LongMaxVector> VCLASS = LongMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n-\n-    LongMaxVector(long[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as LongMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    LongMaxVector(Object v) {\n-        this((long[]) v);\n-    }\n-\n-    static final LongMaxVector ZERO = new LongMaxVector(new long[VLENGTH]);\n-    static final LongMaxVector IOTA = new LongMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public LongSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Long> elementType() { return long.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Long.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxVector broadcast(long e) {\n-        return (LongMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    LongMaxMask maskFromArray(boolean[] bits) {\n-        return new LongMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle iotaShuffle() { return LongMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    LongMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle shuffleFromBytes(byte[] reorder) { return new LongMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle shuffleFromArray(int[] indexes, int i) { return new LongMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new LongMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    LongMaxVector vectorFactory(long[] vec) {\n-        return new LongMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector uOp(FUnOp f) {\n-        return (LongMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector uOp(VectorMask<Long> m, FUnOp f) {\n-        return (LongMaxVector)\n-            super.uOpTemplate((LongMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector bOp(Vector<Long> v, FBinOp f) {\n-        return (LongMaxVector) super.bOpTemplate((LongMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector bOp(Vector<Long> v,\n-                     VectorMask<Long> m, FBinOp f) {\n-        return (LongMaxVector)\n-            super.bOpTemplate((LongMaxVector)v, (LongMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector tOp(Vector<Long> v1, Vector<Long> v2, FTriOp f) {\n-        return (LongMaxVector)\n-            super.tOpTemplate((LongMaxVector)v1, (LongMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    LongMaxVector tOp(Vector<Long> v1, Vector<Long> v2,\n-                     VectorMask<Long> m, FTriOp f) {\n-        return (LongMaxVector)\n-            super.tOpTemplate((LongMaxVector)v1, (LongMaxVector)v2,\n-                              (LongMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    long rOp(long v, VectorMask<Long> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Long,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector lanewise(Unary op) {\n-        return (LongMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector lanewise(Unary op, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector lanewise(Binary op, Vector<Long> v) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector lanewise(Binary op, Vector<Long> v, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline LongMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e) {\n-        return (LongMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline LongMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewiseShiftTemplate(op, LongMaxMask.class, e, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    LongMaxVector\n-    lanewise(Ternary op, Vector<Long> v1, Vector<Long> v2) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    LongMaxVector\n-    lanewise(Ternary op, Vector<Long> v1, Vector<Long> v2, VectorMask<Long> m) {\n-        return (LongMaxVector) super.lanewiseTemplate(op, LongMaxMask.class, v1, v2, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    LongMaxVector addIndex(int scale) {\n-        return (LongMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Long> m) {\n-        return super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Long> m) {\n-        return (long) super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask test(Test op) {\n-        return super.testTemplate(LongMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask test(Test op, VectorMask<Long> m) {\n-        return super.testTemplate(LongMaxMask.class, op, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask compare(Comparison op, Vector<Long> v) {\n-        return super.compareTemplate(LongMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(LongMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public final LongMaxMask compare(Comparison op, Vector<Long> v, VectorMask<Long> m) {\n-        return super.compareTemplate(LongMaxMask.class, op, v, (LongMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector blend(Vector<Long> v, VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.blendTemplate(LongMaxMask.class,\n-                                (LongMaxVector) v,\n-                                (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector slice(int origin, Vector<Long> v) {\n-        return (LongMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector slice(int origin) {\n-        return (LongMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector unslice(int origin, Vector<Long> w, int part) {\n-        return (LongMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector unslice(int origin, Vector<Long> w, int part, VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.unsliceTemplate(LongMaxMask.class,\n-                                  origin, w, part,\n-                                  (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector unslice(int origin) {\n-        return (LongMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector rearrange(VectorShuffle<Long> s) {\n-        return (LongMaxVector)\n-            super.rearrangeTemplate(LongMaxShuffle.class,\n-                                    (LongMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector rearrange(VectorShuffle<Long> shuffle,\n-                                  VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.rearrangeTemplate(LongMaxShuffle.class,\n-                                    LongMaxMask.class,\n-                                    (LongMaxShuffle) shuffle,\n-                                    (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector rearrange(VectorShuffle<Long> s,\n-                                  Vector<Long> v) {\n-        return (LongMaxVector)\n-            super.rearrangeTemplate(LongMaxShuffle.class,\n-                                    (LongMaxShuffle) s,\n-                                    (LongMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector compress(VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.compressTemplate(LongMaxMask.class,\n-                                   (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector expand(VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.expandTemplate(LongMaxMask.class,\n-                                   (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector selectFrom(Vector<Long> v) {\n-        return (LongMaxVector)\n-            super.selectFromTemplate((LongMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public LongMaxVector selectFrom(Vector<Long> v,\n-                                   VectorMask<Long> m) {\n-        return (LongMaxVector)\n-            super.selectFromTemplate((LongMaxVector) v,\n-                                     (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public long lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return laneHelper(i);\n-    }\n-\n-    public long laneHelper(int i) {\n-        return (long) VectorSupport.extract(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    long[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public LongMaxVector withLane(int i, long e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public LongMaxVector withLaneHelper(int i, long e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)e,\n-                                (v, ix, bits) -> {\n-                                    long[] res = v.vec().clone();\n-                                    res[ix] = (long)bits;\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class LongMaxMask extends AbstractMask<Long> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n-\n-        LongMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        LongMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        LongMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public LongSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        LongMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new LongMaxMask(res);\n-        }\n-\n-        @Override\n-        LongMaxMask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((LongMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new LongMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        LongMaxVector toVector() {\n-            return (LongMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask eq(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            LongMaxMask m = (LongMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask compress() {\n-            return (LongMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                LongMaxVector.class, LongMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask and(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            LongMaxMask m = (LongMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxMask or(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            LongMaxMask m = (LongMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @ForceInline\n-        \/* package-private *\/\n-        LongMaxMask xor(VectorMask<Long> mask) {\n-            Objects.requireNonNull(mask);\n-            LongMaxMask m = (LongMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static LongMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final LongMaxMask  TRUE_MASK = new LongMaxMask(true);\n-        private static final LongMaxMask FALSE_MASK = new LongMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class LongMaxShuffle extends AbstractShuffle<Long> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n-\n-        LongMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public LongMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public LongMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public LongMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public LongSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final LongMaxShuffle IOTA = new LongMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public LongMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, LongMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((LongMaxVector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {\n-            LongMaxShuffle s = (LongMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new LongMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromArray0(long[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m, int offsetInRange) {\n-        return super.fromArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(long[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(long[] a, int offset, VectorMask<Long> m) {\n-        super.intoArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        super.intoArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n-        super.intoMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m);\n-    }\n-\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":0,"deletions":903,"binary":false,"changes":903,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    LongVector(long[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public LongVector() {}\n@@ -99,0 +99,2 @@\n+    abstract VectorPayloadMF vec_mf();\n+\n@@ -108,0 +110,2 @@\n+    abstract LongVector vectorFactory(VectorPayloadMF vec);\n+\n@@ -127,1 +131,1 @@\n-    LongVector vOp(FVOp f) {\n+    LongVector vOpMF(FVOp f) {\n@@ -132,1 +136,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +142,1 @@\n-    LongVector vOp(VectorMask<Long> m, FVOp f) {\n+    LongVector vOpMF(VectorMask<Long> m, FVOp f) {\n@@ -145,1 +150,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +163,1 @@\n-    LongVector uOp(FUnOp f);\n+    LongVector uOpMF(FUnOp f);\n@@ -160,5 +166,8 @@\n-    LongVector uOpTemplate(FUnOp f) {\n-        long[] vec = vec();\n-        long[] res = new long[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    LongVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(i, v));\n@@ -166,1 +175,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +181,1 @@\n-    LongVector uOp(VectorMask<Long> m,\n+    LongVector uOpMF(VectorMask<Long> m,\n@@ -175,1 +185,1 @@\n-    LongVector uOpTemplate(VectorMask<Long> m,\n+    LongVector uOpTemplateMF(VectorMask<Long> m,\n@@ -178,1 +188,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,2 +190,0 @@\n-        long[] vec = vec();\n-        long[] res = new long[length()];\n@@ -183,2 +191,7 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, mbits[i] ? f.apply(i, v): v);\n@@ -186,1 +199,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +212,1 @@\n-    LongVector bOp(Vector<Long> o,\n+    LongVector bOpMF(Vector<Long> o,\n@@ -202,1 +216,1 @@\n-    LongVector bOpTemplate(Vector<Long> o,\n+    LongVector bOpTemplateMF(Vector<Long> o,\n@@ -204,5 +218,9 @@\n-        long[] res = new long[length()];\n-        long[] vec1 = this.vec();\n-        long[] vec2 = ((LongVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +228,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +234,1 @@\n-    LongVector bOp(Vector<Long> o,\n+    LongVector bOpMF(Vector<Long> o,\n@@ -220,1 +239,1 @@\n-    LongVector bOpTemplate(Vector<Long> o,\n+    LongVector bOpTemplateMF(Vector<Long> o,\n@@ -224,1 +243,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,3 +245,0 @@\n-        long[] res = new long[length()];\n-        long[] vec1 = this.vec();\n-        long[] vec2 = ((LongVector)o).vec();\n@@ -230,2 +246,9 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n@@ -233,1 +256,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +269,1 @@\n-    LongVector tOp(Vector<Long> o1,\n+    LongVector tOpMF(Vector<Long> o1,\n@@ -250,1 +274,1 @@\n-    LongVector tOpTemplate(Vector<Long> o1,\n+    LongVector tOpTemplateMF(Vector<Long> o1,\n@@ -253,6 +277,11 @@\n-        long[] res = new long[length()];\n-        long[] vec1 = this.vec();\n-        long[] vec2 = ((LongVector)o1).vec();\n-        long[] vec3 = ((LongVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((LongVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((LongVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n+            long v3 = Unsafe.getUnsafe().getLong(vec3, start_offset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +289,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +295,1 @@\n-    LongVector tOp(Vector<Long> o1,\n+    LongVector tOpMF(Vector<Long> o1,\n@@ -271,1 +301,1 @@\n-    LongVector tOpTemplate(Vector<Long> o1,\n+    LongVector tOpTemplateMF(Vector<Long> o1,\n@@ -276,1 +306,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,4 +308,0 @@\n-        long[] res = new long[length()];\n-        long[] vec1 = this.vec();\n-        long[] vec2 = ((LongVector)o1).vec();\n-        long[] vec3 = ((LongVector)o2).vec();\n@@ -283,2 +309,11 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((LongVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((LongVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n+            long v3 = Unsafe.getUnsafe().getLong(vec3, start_offset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    long rOp(long v, VectorMask<Long> m, FBinOp f);\n+    long rOpMF(long v, VectorMask<Long> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    long rOpTemplate(long v, VectorMask<Long> m, FBinOp f) {\n+    long rOpTemplateMF(long v, VectorMask<Long> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,1 +337,1 @@\n-        long[] vec = vec();\n+        VectorPayloadMF vec = this.vec_mf();\n@@ -303,2 +339,5 @@\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n+            v = mbits[i] ? f.apply(i, v, v1) : v;\n@@ -311,4 +350,7 @@\n-    long rOpTemplate(long v, FBinOp f) {\n-        long[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    long rOpTemplateMF(long v, FBinOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +371,1 @@\n-    <M> LongVector ldOp(M memory, int offset,\n+    <M> LongVector ldOpMF(M memory, int offset,\n@@ -331,4 +373,7 @@\n-        \/\/dummy; no vec = vec();\n-        long[] res = new long[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Long.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +381,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +388,1 @@\n-    <M> LongVector ldOp(M memory, int offset,\n+    <M> LongVector ldOpMF(M memory, int offset,\n@@ -345,2 +391,5 @@\n-        \/\/long[] vec = vec();\n-        long[] res = new long[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Long.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -348,1 +397,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -350,1 +399,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +402,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +406,1 @@\n+\n@@ -364,1 +415,1 @@\n-    LongVector ldLongOp(MemorySegment memory, long offset,\n+    LongVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +417,7 @@\n-        \/\/dummy; no vec = vec();\n-        long[] res = new long[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Long.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +425,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +432,1 @@\n-    LongVector ldLongOp(MemorySegment memory, long offset,\n+    LongVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,2 +435,5 @@\n-        \/\/long[] vec = vec();\n-        long[] res = new long[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Long.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -383,1 +441,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -385,1 +443,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +446,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +461,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +463,5 @@\n-        long[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n@@ -411,1 +472,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +474,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,1 +477,1 @@\n-        long[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -418,1 +479,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -420,1 +483,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n@@ -425,0 +488,1 @@\n+\n@@ -432,1 +496,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +498,5 @@\n-        long[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n@@ -443,1 +509,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,1 +512,1 @@\n-        long[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -448,1 +514,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -450,1 +518,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n@@ -469,1 +537,1 @@\n-    AbstractMask<Long> bTest(int cond,\n+    AbstractMask<Long> bTestMF(int cond,\n@@ -472,5 +540,9 @@\n-        long[] vec1 = vec();\n-        long[] vec2 = ((LongVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec_mf();\n+        int length = vspecies().length();\n+        long start_offset = this.multiFieldOffset();\n+        boolean[] bits = new boolean[length];\n+        for (int i = 0; i < length; i++) {\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n+            bits[i] = f.apply(cond, i, v1, v2);\n@@ -565,1 +637,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -683,1 +755,1 @@\n-                    v0.uOp(m, (i, a) -> (long) -a);\n+                    v0.uOpMF(m, (i, a) -> (long) -a);\n@@ -685,1 +757,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Math.abs(a));\n@@ -687,1 +759,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.bitCount(a));\n@@ -689,1 +761,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.numberOfTrailingZeros(a));\n@@ -691,1 +763,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.numberOfLeadingZeros(a));\n@@ -693,1 +765,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.reverse(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.reverse(a));\n@@ -695,1 +767,1 @@\n-                    v0.uOp(m, (i, a) -> (long) Long.reverseBytes(a));\n+                    v0.uOpMF(m, (i, a) -> (long) Long.reverseBytes(a));\n@@ -745,1 +817,1 @@\n-            BIN_IMPL.find(op, opc, LongVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, LongVector::binaryOperationsMF));\n@@ -805,1 +877,39 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Long.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Long.expand(a, n));\n+            default: return null;\n+        }\n+    }\n+\n+    private static BinaryOperation<LongVector, VectorMask<Long>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a + b));\n@@ -807,1 +917,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a - b));\n@@ -809,1 +919,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a * b));\n@@ -811,1 +921,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a \/ b));\n@@ -813,1 +923,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.max(a, b));\n@@ -815,1 +925,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)Math.min(a, b));\n@@ -817,1 +927,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a & b));\n@@ -819,1 +929,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a | b));\n@@ -821,1 +931,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (long)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (long)(a ^ b));\n@@ -823,1 +933,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (long)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)(a << n));\n@@ -825,1 +935,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (long)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)(a >> n));\n@@ -827,1 +937,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n@@ -829,1 +939,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -831,1 +941,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -833,1 +943,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> Long.compress(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Long.compress(a, n));\n@@ -835,1 +945,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> Long.expand(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> Long.expand(a, n));\n@@ -840,0 +950,1 @@\n+\n@@ -959,1 +1070,1 @@\n-                    v.uOp(m, (i, a) -> (long)(a << n));\n+                    v.uOpMF(m, (i, a) -> (long)(a << n));\n@@ -961,1 +1072,1 @@\n-                    v.uOp(m, (i, a) -> (long)(a >> n));\n+                    v.uOpMF(m, (i, a) -> (long)(a >> n));\n@@ -963,1 +1074,1 @@\n-                    v.uOp(m, (i, a) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> (long)((a & LSHR_SETUP_MASK) >>> n));\n@@ -965,1 +1076,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -967,1 +1078,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -1947,1 +2058,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -1969,1 +2080,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2072,1 +2183,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2258,1 +2369,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2290,1 +2401,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2318,1 +2429,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2326,1 +2437,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2668,1 +2779,1 @@\n-                    toBits(v.rOp((long)0, m, (i, a, b) -> (long)(a + b)));\n+                    toBits(v.rOpMF((long)0, m, (i, a, b) -> (long)(a + b)));\n@@ -2670,1 +2781,1 @@\n-                    toBits(v.rOp((long)1, m, (i, a, b) -> (long)(a * b)));\n+                    toBits(v.rOpMF((long)1, m, (i, a, b) -> (long)(a * b)));\n@@ -2672,1 +2783,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (long) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (long) Math.min(a, b)));\n@@ -2674,1 +2785,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (long) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (long) Math.max(a, b)));\n@@ -2676,1 +2787,1 @@\n-                    toBits(v.rOp((long)-1, m, (i, a, b) -> (long)(a & b)));\n+                    toBits(v.rOpMF((long)-1, m, (i, a, b) -> (long)(a & b)));\n@@ -2678,1 +2789,1 @@\n-                    toBits(v.rOp((long)0, m, (i, a, b) -> (long)(a | b)));\n+                    toBits(v.rOpMF((long)0, m, (i, a, b) -> (long)(a | b)));\n@@ -2680,1 +2791,1 @@\n-                    toBits(v.rOp((long)0, m, (i, a, b) -> (long)(a ^ b)));\n+                    toBits(v.rOpMF((long)0, m, (i, a, b) -> (long)(a ^ b)));\n@@ -2816,1 +2927,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -2901,1 +3012,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -2910,1 +3021,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -2913,0 +3024,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -2927,1 +3040,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -3113,1 +3226,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3115,0 +3228,1 @@\n+\n@@ -3194,1 +3308,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3202,1 +3316,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3205,0 +3319,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3221,1 +3337,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -3344,1 +3460,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3361,1 +3477,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3387,1 +3503,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3396,1 +3512,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3399,0 +3515,2 @@\n+             *\/\n+            assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3414,1 +3532,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -3429,1 +3547,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, LongVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, LongVector::memorySegmentGet);\n@@ -3445,1 +3563,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, LongVector::memorySegmentGet);\n@@ -3464,1 +3582,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3481,1 +3599,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3503,1 +3621,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3511,1 +3629,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3514,0 +3632,3 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n+\n@@ -3531,1 +3652,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -3548,1 +3669,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, LongVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, LongVector::memorySegmentSet);\n@@ -3565,1 +3686,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, LongVector::memorySegmentSet);\n@@ -3786,1 +3907,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -3847,0 +3968,6 @@\n+        @ForceInline\n+        @Override final\n+        LongVector dummyVectorMF() {\n+            return (LongVector) super.dummyVectorMF();\n+        }\n+\n@@ -3850,1 +3977,1 @@\n-        LongVector rvOp(RVOp f) {\n+        LongVector rvOpMF(RVOp f) {\n@@ -3856,1 +3983,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3859,1 +3987,1 @@\n-        LongVector vOp(FVOp f) {\n+        LongVector vOpMF(FVOp f) {\n@@ -3864,1 +3992,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3867,1 +3996,1 @@\n-        LongVector vOp(VectorMask<Long> m, FVOp f) {\n+        LongVector vOpMF(VectorMask<Long> m, FVOp f) {\n@@ -3875,1 +4004,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -3880,1 +4010,1 @@\n-        <M> LongVector ldOp(M memory, int offset,\n+        <M> LongVector ldOpMF(M memory, int offset,\n@@ -3882,1 +4012,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -3887,1 +4017,1 @@\n-        <M> LongVector ldOp(M memory, int offset,\n+        <M> LongVector ldOpMF(M memory, int offset,\n@@ -3890,1 +4020,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -3893,0 +4023,1 @@\n+\n@@ -3895,1 +4026,1 @@\n-        LongVector ldLongOp(MemorySegment memory, long offset,\n+        LongVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3897,1 +4028,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -3902,1 +4033,1 @@\n-        LongVector ldLongOp(MemorySegment memory, long offset,\n+        LongVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -3905,1 +4036,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -3910,2 +4041,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -3916,2 +4047,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Long> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Long> m,\n@@ -3919,1 +4050,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -3922,0 +4053,1 @@\n+\n@@ -3924,2 +4056,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -3930,1 +4062,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -3933,1 +4065,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -3947,2 +4079,3 @@\n-            if ((Class<?>) vectorType() == LongMaxVector.class)\n-                return LongMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == LongMaxVector.class)\n+            \/\/    return LongMaxVector.ZERO;\n@@ -3961,2 +4094,3 @@\n-            if ((Class<?>) vectorType() == LongMaxVector.class)\n-                return LongMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == LongMaxVector.class)\n+            \/\/    return LongMaxVector.IOTA;\n@@ -3976,2 +4110,3 @@\n-            if ((Class<?>) vectorType() == LongMaxVector.class)\n-                return LongMaxVector.LongMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == LongMaxVector.class)\n+            \/\/    return LongMaxVector.LongMaxMask.maskAll(bit);\n@@ -3986,0 +4121,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            long [] init = new long[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (long)i;\n+            }\n+           return init;\n+        }\n@@ -4002,1 +4147,2 @@\n-            case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;\n@@ -4036,1 +4182,2 @@\n-    public static final VectorSpecies<Long> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Long> SPECIES_MAX\n@@ -4041,0 +4188,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":363,"deletions":215,"binary":false,"changes":578,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Short128Vector extends ShortVector {\n+value class Short128Vector extends ShortVector {\n@@ -57,2 +58,10 @@\n-    Short128Vector(short[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF128.class);\n+\n+    private final VectorSupport.VectorPayloadMF128 payload;\n+\n+    Short128Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF128)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Short128Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Short128Vector(Object v) {\n-        this((short[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Short128Vector ZERO = new Short128Vector(new short[VLENGTH]);\n-    static final Short128Vector IOTA = new Short128Vector(VSPECIES.iotaArray());\n+    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 8));\n+    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 8, (short [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Short128Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Short128Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Short128Vector uOp(FUnOp f) {\n-        return (Short128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Short128Vector uOpMF(FUnOp f) {\n+        return (Short128Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Short128Vector uOp(VectorMask<Short> m, FUnOp f) {\n+    Short128Vector uOpMF(VectorMask<Short> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Short128Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Short128Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Short128Vector bOp(Vector<Short> v, FBinOp f) {\n-        return (Short128Vector) super.bOpTemplate((Short128Vector)v, f);  \/\/ specialize\n+    Short128Vector bOpMF(Vector<Short> v, FBinOp f) {\n+        return (Short128Vector) super.bOpTemplateMF((Short128Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Short128Vector bOp(Vector<Short> v,\n+    Short128Vector bOpMF(Vector<Short> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Short128Vector)v, (Short128Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Short128Vector)v, (Short128Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Short128Vector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n+    Short128Vector tOpMF(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Short128Vector)v1, (Short128Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Short128Vector)v1, (Short128Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Short128Vector tOp(Vector<Short> v1, Vector<Short> v2,\n+    Short128Vector tOpMF(Vector<Short> v1, Vector<Short> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Short128Vector)v1, (Short128Vector)v2,\n-                              (Short128Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Short128Vector)v1, (Short128Vector)v2,\n+                                (Short128Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -528,6 +547,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getShort(vecpayload, start_offset + ix * Short.BYTES);\n+                             });\n@@ -553,1 +573,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -557,3 +577,6 @@\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putShort(tpayload, start_offset + ix * Short.BYTES, (short)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Short256Vector extends ShortVector {\n+value class Short256Vector extends ShortVector {\n@@ -57,2 +58,10 @@\n-    Short256Vector(short[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF256.class);\n+\n+    private final VectorSupport.VectorPayloadMF256 payload;\n+\n+    Short256Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF256)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Short256Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Short256Vector(Object v) {\n-        this((short[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Short256Vector ZERO = new Short256Vector(new short[VLENGTH]);\n-    static final Short256Vector IOTA = new Short256Vector(VSPECIES.iotaArray());\n+    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 16));\n+    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 16, (short [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Short256Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Short256Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Short256Vector uOp(FUnOp f) {\n-        return (Short256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Short256Vector uOpMF(FUnOp f) {\n+        return (Short256Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Short256Vector uOp(VectorMask<Short> m, FUnOp f) {\n+    Short256Vector uOpMF(VectorMask<Short> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Short256Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Short256Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Short256Vector bOp(Vector<Short> v, FBinOp f) {\n-        return (Short256Vector) super.bOpTemplate((Short256Vector)v, f);  \/\/ specialize\n+    Short256Vector bOpMF(Vector<Short> v, FBinOp f) {\n+        return (Short256Vector) super.bOpTemplateMF((Short256Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Short256Vector bOp(Vector<Short> v,\n+    Short256Vector bOpMF(Vector<Short> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Short256Vector)v, (Short256Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Short256Vector)v, (Short256Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Short256Vector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n+    Short256Vector tOpMF(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Short256Vector)v1, (Short256Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Short256Vector)v1, (Short256Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Short256Vector tOp(Vector<Short> v1, Vector<Short> v2,\n+    Short256Vector tOpMF(Vector<Short> v1, Vector<Short> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Short256Vector)v1, (Short256Vector)v2,\n-                              (Short256Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Short256Vector)v1, (Short256Vector)v2,\n+                                (Short256Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -536,6 +555,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getShort(vecpayload, start_offset + ix * Short.BYTES);\n+                             });\n@@ -569,1 +589,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -573,3 +593,6 @@\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putShort(tpayload, start_offset + ix * Short.BYTES, (short)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Short512Vector extends ShortVector {\n+value class Short512Vector extends ShortVector {\n@@ -57,2 +58,10 @@\n-    Short512Vector(short[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF512.class);\n+\n+    private final VectorSupport.VectorPayloadMF512 payload;\n+\n+    Short512Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF512)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Short512Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Short512Vector(Object v) {\n-        this((short[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Short512Vector ZERO = new Short512Vector(new short[VLENGTH]);\n-    static final Short512Vector IOTA = new Short512Vector(VSPECIES.iotaArray());\n+    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 32));\n+    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 32, (short [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Short512Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Short512Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Short512Vector uOp(FUnOp f) {\n-        return (Short512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Short512Vector uOpMF(FUnOp f) {\n+        return (Short512Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Short512Vector uOp(VectorMask<Short> m, FUnOp f) {\n+    Short512Vector uOpMF(VectorMask<Short> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Short512Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Short512Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Short512Vector bOp(Vector<Short> v, FBinOp f) {\n-        return (Short512Vector) super.bOpTemplate((Short512Vector)v, f);  \/\/ specialize\n+    Short512Vector bOpMF(Vector<Short> v, FBinOp f) {\n+        return (Short512Vector) super.bOpTemplateMF((Short512Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Short512Vector bOp(Vector<Short> v,\n+    Short512Vector bOpMF(Vector<Short> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Short512Vector)v, (Short512Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Short512Vector)v, (Short512Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Short512Vector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n+    Short512Vector tOpMF(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Short512Vector)v1, (Short512Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Short512Vector)v1, (Short512Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Short512Vector tOp(Vector<Short> v1, Vector<Short> v2,\n+    Short512Vector tOpMF(Vector<Short> v1, Vector<Short> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Short512Vector)v1, (Short512Vector)v2,\n-                              (Short512Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Short512Vector)v1, (Short512Vector)v2,\n+                                (Short512Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -552,6 +571,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getShort(vecpayload, start_offset + ix * Short.BYTES);\n+                             });\n@@ -601,1 +621,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -605,3 +625,6 @@\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putShort(tpayload, start_offset + ix * Short.BYTES, (short)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class Short64Vector extends ShortVector {\n+value class Short64Vector extends ShortVector {\n@@ -57,2 +58,10 @@\n-    Short64Vector(short[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF64.class);\n+\n+    private final VectorSupport.VectorPayloadMF64 payload;\n+\n+    Short64Vector(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF64)value;\n+    }\n+\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n@@ -61,4 +70,3 @@\n-    \/\/ For compatibility as Short64Vector::new,\n-    \/\/ stored into species.vectorFactory.\n-    Short64Vector(Object v) {\n-        this((short[]) v);\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final Short64Vector ZERO = new Short64Vector(new short[VLENGTH]);\n-    static final Short64Vector IOTA = new Short64Vector(VSPECIES.iotaArray());\n+    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.createVectPayloadInstance(Short.BYTES, 4));\n+    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(Short.BYTES, 4, (short [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -174,0 +186,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Short64Vector vectorFactory(VectorPayloadMF vec) {\n+        return new Short64Vector(vec);\n+    }\n+\n@@ -190,2 +209,2 @@\n-    Short64Vector uOp(FUnOp f) {\n-        return (Short64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    Short64Vector uOpMF(FUnOp f) {\n+        return (Short64Vector) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -196,1 +215,1 @@\n-    Short64Vector uOp(VectorMask<Short> m, FUnOp f) {\n+    Short64Vector uOpMF(VectorMask<Short> m, FUnOp f) {\n@@ -198,1 +217,1 @@\n-            super.uOpTemplate((Short64Mask)m, f);  \/\/ specialize\n+            super.uOpTemplateMF((Short64Mask)m, f);  \/\/ specialize\n@@ -205,2 +224,2 @@\n-    Short64Vector bOp(Vector<Short> v, FBinOp f) {\n-        return (Short64Vector) super.bOpTemplate((Short64Vector)v, f);  \/\/ specialize\n+    Short64Vector bOpMF(Vector<Short> v, FBinOp f) {\n+        return (Short64Vector) super.bOpTemplateMF((Short64Vector)v, f);  \/\/ specialize\n@@ -211,1 +230,1 @@\n-    Short64Vector bOp(Vector<Short> v,\n+    Short64Vector bOpMF(Vector<Short> v,\n@@ -214,2 +233,2 @@\n-            super.bOpTemplate((Short64Vector)v, (Short64Mask)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF((Short64Vector)v, (Short64Mask)m,\n+                                f);  \/\/ specialize\n@@ -222,1 +241,1 @@\n-    Short64Vector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n+    Short64Vector tOpMF(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n@@ -224,2 +243,2 @@\n-            super.tOpTemplate((Short64Vector)v1, (Short64Vector)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF((Short64Vector)v1, (Short64Vector)v2,\n+                                f);  \/\/ specialize\n@@ -230,1 +249,1 @@\n-    Short64Vector tOp(Vector<Short> v1, Vector<Short> v2,\n+    Short64Vector tOpMF(Vector<Short> v1, Vector<Short> v2,\n@@ -233,2 +252,2 @@\n-            super.tOpTemplate((Short64Vector)v1, (Short64Vector)v2,\n-                              (Short64Mask)m, f);  \/\/ specialize\n+            super.tOpTemplateMF((Short64Vector)v1, (Short64Vector)v2,\n+                                (Short64Mask)m, f);  \/\/ specialize\n@@ -239,2 +258,2 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -524,6 +543,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().getShort(vecpayload, start_offset + ix * Short.BYTES);\n+                             });\n@@ -545,1 +565,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -549,3 +569,6 @@\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().putShort(tpayload, start_offset + ix * Short.BYTES, (short)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":60,"deletions":37,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,920 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.vector;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.function.IntUnaryOperator;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.vector.VectorSupport;\n-\n-import static jdk.internal.vm.vector.VectorSupport.*;\n-\n-import static jdk.incubator.vector.VectorOperators.*;\n-\n-\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n-\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n-final class ShortMaxVector extends ShortVector {\n-    static final ShortSpecies VSPECIES =\n-        (ShortSpecies) ShortVector.SPECIES_MAX;\n-\n-    static final VectorShape VSHAPE =\n-        VSPECIES.vectorShape();\n-\n-    static final Class<ShortMaxVector> VCLASS = ShortMaxVector.class;\n-\n-    static final int VSIZE = VSPECIES.vectorBitSize();\n-\n-    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n-\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n-\n-    ShortMaxVector(short[] v) {\n-        super(v);\n-    }\n-\n-    \/\/ For compatibility as ShortMaxVector::new,\n-    \/\/ stored into species.vectorFactory.\n-    ShortMaxVector(Object v) {\n-        this((short[]) v);\n-    }\n-\n-    static final ShortMaxVector ZERO = new ShortMaxVector(new short[VLENGTH]);\n-    static final ShortMaxVector IOTA = new ShortMaxVector(VSPECIES.iotaArray());\n-\n-    static {\n-        \/\/ Warm up a few species caches.\n-        \/\/ If we do this too much we will\n-        \/\/ get NPEs from bootstrap circularity.\n-        VSPECIES.dummyVector();\n-        VSPECIES.withLanes(LaneType.BYTE);\n-    }\n-\n-    \/\/ Specialized extractors\n-\n-    @ForceInline\n-    final @Override\n-    public ShortSpecies vspecies() {\n-        \/\/ ISSUE:  This should probably be a @Stable\n-        \/\/ field inside AbstractVector, rather than\n-        \/\/ a megamorphic method.\n-        return VSPECIES;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public final Class<Short> elementType() { return short.class; }\n-\n-    @ForceInline\n-    @Override\n-    public final int elementSize() { return Short.SIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final VectorShape shape() { return VSHAPE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int length() { return VLENGTH; }\n-\n-    @ForceInline\n-    @Override\n-    public final int bitSize() { return VSIZE; }\n-\n-    @ForceInline\n-    @Override\n-    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxVector broadcast(short e) {\n-        return (ShortMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxVector broadcast(long e) {\n-        return (ShortMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxMask maskFromArray(boolean[] bits) {\n-        return new ShortMaxMask(bits);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle iotaShuffle() { return ShortMaxShuffle.IOTA; }\n-\n-    @ForceInline\n-    ShortMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-      if (wrap) {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle shuffleFromBytes(byte[] reorder) { return new ShortMaxShuffle(reorder); }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ShortMaxShuffle(indexes, i); }\n-\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new ShortMaxShuffle(fn); }\n-\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector vectorFactory(short[] vec) {\n-        return new ShortMaxVector(vec);\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ByteMaxVector asByteVectorRaw() {\n-        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    AbstractVector<?> asVectorRaw(LaneType laneType) {\n-        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n-    }\n-\n-    \/\/ Unary operator\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector uOp(FUnOp f) {\n-        return (ShortMaxVector) super.uOpTemplate(f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector uOp(VectorMask<Short> m, FUnOp f) {\n-        return (ShortMaxVector)\n-            super.uOpTemplate((ShortMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    \/\/ Binary operator\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector bOp(Vector<Short> v, FBinOp f) {\n-        return (ShortMaxVector) super.bOpTemplate((ShortMaxVector)v, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector bOp(Vector<Short> v,\n-                     VectorMask<Short> m, FBinOp f) {\n-        return (ShortMaxVector)\n-            super.bOpTemplate((ShortMaxVector)v, (ShortMaxMask)m,\n-                              f);  \/\/ specialize\n-    }\n-\n-    \/\/ Ternary operator\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector tOp(Vector<Short> v1, Vector<Short> v2, FTriOp f) {\n-        return (ShortMaxVector)\n-            super.tOpTemplate((ShortMaxVector)v1, (ShortMaxVector)v2,\n-                              f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    ShortMaxVector tOp(Vector<Short> v1, Vector<Short> v2,\n-                     VectorMask<Short> m, FTriOp f) {\n-        return (ShortMaxVector)\n-            super.tOpTemplate((ShortMaxVector)v1, (ShortMaxVector)v2,\n-                              (ShortMaxMask)m, f);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    final @Override\n-    short rOp(short v, VectorMask<Short> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> convertShape(VectorOperators.Conversion<Short,F> conv,\n-                           VectorSpecies<F> rsp, int part) {\n-        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final <F>\n-    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n-        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized algebraic operations:\n-\n-    \/\/ The following definition forces a specialized version of this\n-    \/\/ crucial method into the v-table of this class.  A call to add()\n-    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n-    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n-    \/\/ for this particular class, enabling it to generate precise\n-    \/\/ code.\n-    \/\/\n-    \/\/ There is probably no benefit to the JIT to specialize the\n-    \/\/ masked or broadcast versions of the lanewise method.\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector lanewise(Unary op) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector lanewise(Unary op, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector lanewise(Binary op, Vector<Short> v) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector lanewise(Binary op, Vector<Short> v, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline ShortMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e) {\n-        return (ShortMaxVector) super.lanewiseShiftTemplate(op, e);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline ShortMaxVector\n-    lanewiseShift(VectorOperators.Binary op, int e, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewiseShiftTemplate(op, ShortMaxMask.class, e, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/*package-private*\/\n-    @Override\n-    @ForceInline\n-    public final\n-    ShortMaxVector\n-    lanewise(Ternary op, Vector<Short> v1, Vector<Short> v2) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    ShortMaxVector\n-    lanewise(Ternary op, Vector<Short> v1, Vector<Short> v2, VectorMask<Short> m) {\n-        return (ShortMaxVector) super.lanewiseTemplate(op, ShortMaxMask.class, v1, v2, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final\n-    ShortMaxVector addIndex(int scale) {\n-        return (ShortMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n-    }\n-\n-    \/\/ Type specific horizontal reductions\n-\n-    @Override\n-    @ForceInline\n-    public final short reduceLanes(VectorOperators.Associative op) {\n-        return super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final short reduceLanes(VectorOperators.Associative op,\n-                                    VectorMask<Short> m) {\n-        return super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op) {\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final long reduceLanesToLong(VectorOperators.Associative op,\n-                                        VectorMask<Short> m) {\n-        return (long) super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialized\n-    }\n-\n-    @ForceInline\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n-    }\n-\n-    \/\/ Specialized unary testing\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask test(Test op) {\n-        return super.testTemplate(ShortMaxMask.class, op);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask test(Test op, VectorMask<Short> m) {\n-        return super.testTemplate(ShortMaxMask.class, op, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    \/\/ Specialized comparisons\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask compare(Comparison op, Vector<Short> v) {\n-        return super.compareTemplate(ShortMaxMask.class, op, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask compare(Comparison op, short s) {\n-        return super.compareTemplate(ShortMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask compare(Comparison op, long s) {\n-        return super.compareTemplate(ShortMaxMask.class, op, s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public final ShortMaxMask compare(Comparison op, Vector<Short> v, VectorMask<Short> m) {\n-        return super.compareTemplate(ShortMaxMask.class, op, v, (ShortMaxMask) m);\n-    }\n-\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector blend(Vector<Short> v, VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.blendTemplate(ShortMaxMask.class,\n-                                (ShortMaxVector) v,\n-                                (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector slice(int origin, Vector<Short> v) {\n-        return (ShortMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector slice(int origin) {\n-        return (ShortMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector unslice(int origin, Vector<Short> w, int part) {\n-        return (ShortMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector unslice(int origin, Vector<Short> w, int part, VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.unsliceTemplate(ShortMaxMask.class,\n-                                  origin, w, part,\n-                                  (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector unslice(int origin) {\n-        return (ShortMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector rearrange(VectorShuffle<Short> s) {\n-        return (ShortMaxVector)\n-            super.rearrangeTemplate(ShortMaxShuffle.class,\n-                                    (ShortMaxShuffle) s);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector rearrange(VectorShuffle<Short> shuffle,\n-                                  VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.rearrangeTemplate(ShortMaxShuffle.class,\n-                                    ShortMaxMask.class,\n-                                    (ShortMaxShuffle) shuffle,\n-                                    (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector rearrange(VectorShuffle<Short> s,\n-                                  Vector<Short> v) {\n-        return (ShortMaxVector)\n-            super.rearrangeTemplate(ShortMaxShuffle.class,\n-                                    (ShortMaxShuffle) s,\n-                                    (ShortMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector compress(VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.compressTemplate(ShortMaxMask.class,\n-                                   (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector expand(VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.expandTemplate(ShortMaxMask.class,\n-                                   (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector selectFrom(Vector<Short> v) {\n-        return (ShortMaxVector)\n-            super.selectFromTemplate((ShortMaxVector) v);  \/\/ specialize\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public ShortMaxVector selectFrom(Vector<Short> v,\n-                                   VectorMask<Short> m) {\n-        return (ShortMaxVector)\n-            super.selectFromTemplate((ShortMaxVector) v,\n-                                     (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    public short lane(int i) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return laneHelper(i);\n-    }\n-\n-    public short laneHelper(int i) {\n-        return (short) VectorSupport.extract(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    short[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public ShortMaxVector withLane(int i, short e) {\n-        if (i < 0 || i >= VLENGTH) {\n-            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n-        }\n-        return withLaneHelper(i, e);\n-    }\n-\n-    public ShortMaxVector withLaneHelper(int i, short e) {\n-        return VectorSupport.insert(\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)e,\n-                                (v, ix, bits) -> {\n-                                    short[] res = v.vec().clone();\n-                                    res[ix] = (short)bits;\n-                                    return v.vectorFactory(res);\n-                                });\n-    }\n-\n-    \/\/ Mask\n-\n-    static final class ShortMaxMask extends AbstractMask<Short> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n-\n-        ShortMaxMask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n-\n-        ShortMaxMask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n-        }\n-\n-        ShortMaxMask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n-        }\n-\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n-        }\n-\n-        @ForceInline\n-        final @Override\n-        public ShortSpecies vspecies() {\n-            \/\/ ISSUE:  This should probably be a @Stable\n-            \/\/ field inside AbstractMask, rather than\n-            \/\/ a megamorphic method.\n-            return VSPECIES;\n-        }\n-\n-        @ForceInline\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        ShortMaxMask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new ShortMaxMask(res);\n-        }\n-\n-        @Override\n-        ShortMaxMask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((ShortMaxMask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new ShortMaxMask(res);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public final\n-        ShortMaxVector toVector() {\n-            return (ShortMaxVector) super.toVectorTemplate();  \/\/ specialize\n-        }\n-\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask eq(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            ShortMaxMask m = (ShortMaxMask)mask;\n-            return xor(m.not());\n-        }\n-\n-        \/\/ Unary operations\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask not() {\n-            return xor(maskAll(true));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask compress() {\n-            return (ShortMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n-                ShortMaxVector.class, ShortMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n-        }\n-\n-\n-        \/\/ Binary operations\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask and(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            ShortMaxMask m = (ShortMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxMask or(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            ShortMaxMask m = (ShortMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n-        }\n-\n-        @ForceInline\n-        \/* package-private *\/\n-        ShortMaxMask xor(VectorMask<Short> mask) {\n-            Objects.requireNonNull(mask);\n-            ShortMaxMask m = (ShortMaxMask)mask;\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n-        }\n-\n-        \/\/ Mask Query operations\n-\n-        @Override\n-        @ForceInline\n-        public int trueCount() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int firstTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public int lastTrue() {\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public long toLong() {\n-            if (length() > Long.SIZE) {\n-                throw new UnsupportedOperationException(\"too many lanes for one long\");\n-            }\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> toLongHelper(m.getBits()));\n-        }\n-\n-        \/\/ Reductions\n-\n-        @Override\n-        @ForceInline\n-        public boolean anyTrue() {\n-            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public boolean allTrue() {\n-            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));\n-        }\n-\n-        @ForceInline\n-        \/*package-private*\/\n-        static ShortMaxMask maskAll(boolean bit) {\n-            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VLENGTH,\n-                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n-                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n-        }\n-        private static final ShortMaxMask  TRUE_MASK = new ShortMaxMask(true);\n-        private static final ShortMaxMask FALSE_MASK = new ShortMaxMask(false);\n-\n-    }\n-\n-    \/\/ Shuffle\n-\n-    static final class ShortMaxShuffle extends AbstractShuffle<Short> {\n-        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n-\n-        ShortMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public ShortMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n-        }\n-\n-        public ShortMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n-        }\n-\n-        public ShortMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n-        }\n-\n-        @Override\n-        public ShortSpecies vspecies() {\n-            return VSPECIES;\n-        }\n-\n-        static {\n-            \/\/ There must be enough bits in the shuffle lanes to encode\n-            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n-        }\n-        static final ShortMaxShuffle IOTA = new ShortMaxShuffle(IDENTITY);\n-\n-        @Override\n-        @ForceInline\n-        public ShortMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ShortMaxVector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {\n-            ShortMaxShuffle s = (ShortMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n-            }\n-            return new ShortMaxShuffle(r);\n-        }\n-    }\n-\n-    \/\/ ================================================\n-\n-    \/\/ Specialized low-level memory operations.\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromArray0(short[] a, int offset) {\n-        return super.fromArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m, int offsetInRange) {\n-        return super.fromArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromCharArray0(char[] a, int offset) {\n-        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m, int offsetInRange) {\n-        return super.fromCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n-        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m, int offsetInRange) {\n-        return super.fromMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m, offsetInRange);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(short[] a, int offset) {\n-        super.intoArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoArray0(short[] a, int offset, VectorMask<Short> m) {\n-        super.intoArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);\n-    }\n-\n-\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n-        super.intoMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoCharArray0(char[] a, int offset, VectorMask<Short> m) {\n-        super.intoCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);\n-    }\n-\n-    \/\/ End of specialized low-level memory operations.\n-\n-    \/\/ ================================================\n-\n-}\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":0,"deletions":920,"binary":false,"changes":920,"status":"deleted"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    ShortVector(short[] vec) {\n-        super(vec);\n-    }\n-\n@@ -59,0 +55,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public ShortVector() {}\n@@ -99,0 +99,2 @@\n+    abstract VectorPayloadMF vec_mf();\n+\n@@ -108,0 +110,2 @@\n+    abstract ShortVector vectorFactory(VectorPayloadMF vec);\n+\n@@ -127,1 +131,1 @@\n-    ShortVector vOp(FVOp f) {\n+    ShortVector vOpMF(FVOp f) {\n@@ -132,1 +136,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -137,1 +142,1 @@\n-    ShortVector vOp(VectorMask<Short> m, FVOp f) {\n+    ShortVector vOpMF(VectorMask<Short> m, FVOp f) {\n@@ -145,1 +150,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -157,1 +163,1 @@\n-    ShortVector uOp(FUnOp f);\n+    ShortVector uOpMF(FUnOp f);\n@@ -160,5 +166,8 @@\n-    ShortVector uOpTemplate(FUnOp f) {\n-        short[] vec = vec();\n-        short[] res = new short[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    ShortVector uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(i, v));\n@@ -166,1 +175,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -171,1 +181,1 @@\n-    ShortVector uOp(VectorMask<Short> m,\n+    ShortVector uOpMF(VectorMask<Short> m,\n@@ -175,1 +185,1 @@\n-    ShortVector uOpTemplate(VectorMask<Short> m,\n+    ShortVector uOpTemplateMF(VectorMask<Short> m,\n@@ -178,1 +188,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -180,2 +190,0 @@\n-        short[] vec = vec();\n-        short[] res = new short[length()];\n@@ -183,2 +191,7 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, mbits[i] ? f.apply(i, v): v);\n@@ -186,1 +199,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -198,1 +212,1 @@\n-    ShortVector bOp(Vector<Short> o,\n+    ShortVector bOpMF(Vector<Short> o,\n@@ -202,1 +216,1 @@\n-    ShortVector bOpTemplate(Vector<Short> o,\n+    ShortVector bOpTemplateMF(Vector<Short> o,\n@@ -204,5 +218,9 @@\n-        short[] res = new short[length()];\n-        short[] vec1 = this.vec();\n-        short[] vec2 = ((ShortVector)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(i, v1, v2));\n@@ -210,1 +228,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -215,1 +234,1 @@\n-    ShortVector bOp(Vector<Short> o,\n+    ShortVector bOpMF(Vector<Short> o,\n@@ -220,1 +239,1 @@\n-    ShortVector bOpTemplate(Vector<Short> o,\n+    ShortVector bOpTemplateMF(Vector<Short> o,\n@@ -224,1 +243,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -226,3 +245,0 @@\n-        short[] res = new short[length()];\n-        short[] vec1 = this.vec();\n-        short[] vec2 = ((ShortVector)o).vec();\n@@ -230,2 +246,9 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n@@ -233,1 +256,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -245,1 +269,1 @@\n-    ShortVector tOp(Vector<Short> o1,\n+    ShortVector tOpMF(Vector<Short> o1,\n@@ -250,1 +274,1 @@\n-    ShortVector tOpTemplate(Vector<Short> o1,\n+    ShortVector tOpTemplateMF(Vector<Short> o1,\n@@ -253,6 +277,11 @@\n-        short[] res = new short[length()];\n-        short[] vec1 = this.vec();\n-        short[] vec2 = ((ShortVector)o1).vec();\n-        short[] vec3 = ((ShortVector)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ShortVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((ShortVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n+            short v3 = Unsafe.getUnsafe().getShort(vec3, start_offset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(i, v1, v2, v3));\n@@ -260,1 +289,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -265,1 +295,1 @@\n-    ShortVector tOp(Vector<Short> o1,\n+    ShortVector tOpMF(Vector<Short> o1,\n@@ -271,1 +301,1 @@\n-    ShortVector tOpTemplate(Vector<Short> o1,\n+    ShortVector tOpTemplateMF(Vector<Short> o1,\n@@ -276,1 +306,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -278,4 +308,0 @@\n-        short[] res = new short[length()];\n-        short[] vec1 = this.vec();\n-        short[] vec2 = ((ShortVector)o1).vec();\n-        short[] vec3 = ((ShortVector)o2).vec();\n@@ -283,2 +309,11 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ShortVector)o1).vec_mf();\n+        VectorPayloadMF vec3 = ((ShortVector)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n+            short v3 = Unsafe.getUnsafe().getShort(vec3, start_offset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n@@ -286,1 +321,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -293,1 +329,1 @@\n-    short rOp(short v, VectorMask<Short> m, FBinOp f);\n+    short rOpMF(short v, VectorMask<Short> m, FBinOp f);\n@@ -297,1 +333,1 @@\n-    short rOpTemplate(short v, VectorMask<Short> m, FBinOp f) {\n+    short rOpTemplateMF(short v, VectorMask<Short> m, FBinOp f) {\n@@ -299,1 +335,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -301,1 +337,1 @@\n-        short[] vec = vec();\n+        VectorPayloadMF vec = this.vec_mf();\n@@ -303,2 +339,5 @@\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n+            v = mbits[i] ? f.apply(i, v, v1) : v;\n@@ -311,4 +350,7 @@\n-    short rOpTemplate(short v, FBinOp f) {\n-        short[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    short rOpTemplateMF(short v, FBinOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -329,1 +371,1 @@\n-    <M> ShortVector ldOp(M memory, int offset,\n+    <M> ShortVector ldOpMF(M memory, int offset,\n@@ -331,4 +373,7 @@\n-        \/\/dummy; no vec = vec();\n-        short[] res = new short[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Short.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -336,1 +381,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -342,1 +388,1 @@\n-    <M> ShortVector ldOp(M memory, int offset,\n+    <M> ShortVector ldOpMF(M memory, int offset,\n@@ -345,2 +391,5 @@\n-        \/\/short[] vec = vec();\n-        short[] res = new short[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Short.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -348,1 +397,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -350,1 +399,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -353,1 +402,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -356,0 +406,1 @@\n+\n@@ -364,1 +415,1 @@\n-    ShortVector ldLongOp(MemorySegment memory, long offset,\n+    ShortVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -366,4 +417,7 @@\n-        \/\/dummy; no vec = vec();\n-        short[] res = new short[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Short.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -371,1 +425,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -377,1 +432,1 @@\n-    ShortVector ldLongOp(MemorySegment memory, long offset,\n+    ShortVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -380,2 +435,5 @@\n-        \/\/short[] vec = vec();\n-        short[] res = new short[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                Short.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -383,1 +441,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -385,1 +443,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -388,1 +446,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -402,1 +461,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -404,3 +463,5 @@\n-        short[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n@@ -411,1 +472,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -413,1 +474,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -416,1 +477,1 @@\n-        short[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -418,1 +479,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -420,1 +483,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n@@ -425,0 +488,1 @@\n+\n@@ -432,1 +496,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -434,3 +498,5 @@\n-        short[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n@@ -443,1 +509,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -446,1 +512,1 @@\n-        short[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -448,1 +514,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -450,1 +518,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n@@ -469,1 +537,1 @@\n-    AbstractMask<Short> bTest(int cond,\n+    AbstractMask<Short> bTestMF(int cond,\n@@ -472,5 +540,9 @@\n-        short[] vec1 = vec();\n-        short[] vec2 = ((ShortVector)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec_mf();\n+        int length = vspecies().length();\n+        long start_offset = this.multiFieldOffset();\n+        boolean[] bits = new boolean[length];\n+        for (int i = 0; i < length; i++) {\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n+            bits[i] = f.apply(cond, i, v1, v2);\n@@ -565,1 +637,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -725,1 +797,1 @@\n-                    v0.uOp(m, (i, a) -> (short) -a);\n+                    v0.uOpMF(m, (i, a) -> (short) -a);\n@@ -727,1 +799,1 @@\n-                    v0.uOp(m, (i, a) -> (short) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> (short) Math.abs(a));\n@@ -729,1 +801,1 @@\n-                    v0.uOp(m, (i, a) -> (short) bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> (short) bitCount(a));\n@@ -731,1 +803,1 @@\n-                    v0.uOp(m, (i, a) -> (short) numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (short) numberOfTrailingZeros(a));\n@@ -733,1 +805,1 @@\n-                    v0.uOp(m, (i, a) -> (short) numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> (short) numberOfLeadingZeros(a));\n@@ -735,1 +807,1 @@\n-                    v0.uOp(m, (i, a) -> reverse(a));\n+                    v0.uOpMF(m, (i, a) -> reverse(a));\n@@ -737,1 +809,1 @@\n-                    v0.uOp(m, (i, a) -> (short) Short.reverseBytes(a));\n+                    v0.uOpMF(m, (i, a) -> (short) Short.reverseBytes(a));\n@@ -787,1 +859,1 @@\n-            BIN_IMPL.find(op, opc, ShortVector::binaryOperations));\n+            BIN_IMPL.find(op, opc, ShortVector::binaryOperationsMF));\n@@ -847,1 +919,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a + b));\n@@ -849,1 +921,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a - b));\n@@ -851,1 +923,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a * b));\n@@ -853,1 +925,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a \/ b));\n@@ -855,1 +927,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.max(a, b));\n@@ -857,1 +929,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.min(a, b));\n@@ -859,1 +931,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a & b));\n@@ -861,1 +933,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a | b));\n@@ -863,1 +935,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> (short)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a ^ b));\n@@ -865,1 +937,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (short)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)(a << n));\n@@ -867,1 +939,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (short)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)(a >> n));\n@@ -869,1 +941,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n@@ -871,1 +943,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -873,1 +945,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -878,0 +950,35 @@\n+    private static BinaryOperation<ShortVector, VectorMask<Short>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)Math.min(a, b));\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> (short)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+            default: return null;\n+        }\n+    }\n+\n+\n@@ -1042,1 +1149,1 @@\n-                    v.uOp(m, (i, a) -> (short)(a << n));\n+                    v.uOpMF(m, (i, a) -> (short)(a << n));\n@@ -1044,1 +1151,1 @@\n-                    v.uOp(m, (i, a) -> (short)(a >> n));\n+                    v.uOpMF(m, (i, a) -> (short)(a >> n));\n@@ -1046,1 +1153,1 @@\n-                    v.uOp(m, (i, a) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> (short)((a & LSHR_SETUP_MASK) >>> n));\n@@ -1048,1 +1155,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -1050,1 +1157,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -2050,1 +2157,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2072,1 +2179,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2201,1 +2308,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2408,1 +2515,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2440,1 +2547,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2468,1 +2575,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2476,1 +2583,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2818,1 +2925,1 @@\n-                    toBits(v.rOp((short)0, m, (i, a, b) -> (short)(a + b)));\n+                    toBits(v.rOpMF((short)0, m, (i, a, b) -> (short)(a + b)));\n@@ -2820,1 +2927,1 @@\n-                    toBits(v.rOp((short)1, m, (i, a, b) -> (short)(a * b)));\n+                    toBits(v.rOpMF((short)1, m, (i, a, b) -> (short)(a * b)));\n@@ -2822,1 +2929,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (short) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> (short) Math.min(a, b)));\n@@ -2824,1 +2931,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (short) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> (short) Math.max(a, b)));\n@@ -2826,1 +2933,1 @@\n-                    toBits(v.rOp((short)-1, m, (i, a, b) -> (short)(a & b)));\n+                    toBits(v.rOpMF((short)-1, m, (i, a, b) -> (short)(a & b)));\n@@ -2828,1 +2935,1 @@\n-                    toBits(v.rOp((short)0, m, (i, a, b) -> (short)(a | b)));\n+                    toBits(v.rOpMF((short)0, m, (i, a, b) -> (short)(a | b)));\n@@ -2830,1 +2937,1 @@\n-                    toBits(v.rOp((short)0, m, (i, a, b) -> (short)(a ^ b)));\n+                    toBits(v.rOpMF((short)0, m, (i, a, b) -> (short)(a ^ b)));\n@@ -2978,1 +3085,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -3053,1 +3160,1 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3099,1 +3206,1 @@\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3202,1 +3309,1 @@\n-        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -3249,1 +3356,1 @@\n-        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -3383,1 +3490,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3385,0 +3492,1 @@\n+\n@@ -3456,1 +3564,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -3498,1 +3606,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -3531,1 +3639,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3608,1 +3716,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -3653,1 +3761,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -3732,1 +3840,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3749,1 +3857,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3765,1 +3873,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -3782,1 +3890,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -3797,1 +3905,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, ShortVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, ShortVector::memorySegmentGet);\n@@ -3813,1 +3921,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, ShortVector::memorySegmentGet);\n@@ -3832,1 +3940,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -3849,1 +3957,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -3864,1 +3972,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, ShortVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, ShortVector::memorySegmentSet);\n@@ -3881,1 +3989,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, ShortVector::memorySegmentSet);\n@@ -3899,1 +4007,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -4136,1 +4244,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -4206,0 +4314,6 @@\n+        @ForceInline\n+        @Override final\n+        ShortVector dummyVectorMF() {\n+            return (ShortVector) super.dummyVectorMF();\n+        }\n+\n@@ -4209,1 +4323,1 @@\n-        ShortVector rvOp(RVOp f) {\n+        ShortVector rvOpMF(RVOp f) {\n@@ -4215,1 +4329,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4218,1 +4333,1 @@\n-        ShortVector vOp(FVOp f) {\n+        ShortVector vOpMF(FVOp f) {\n@@ -4223,1 +4338,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4226,1 +4342,1 @@\n-        ShortVector vOp(VectorMask<Short> m, FVOp f) {\n+        ShortVector vOpMF(VectorMask<Short> m, FVOp f) {\n@@ -4234,1 +4350,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -4239,1 +4356,1 @@\n-        <M> ShortVector ldOp(M memory, int offset,\n+        <M> ShortVector ldOpMF(M memory, int offset,\n@@ -4241,1 +4358,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -4246,1 +4363,1 @@\n-        <M> ShortVector ldOp(M memory, int offset,\n+        <M> ShortVector ldOpMF(M memory, int offset,\n@@ -4249,1 +4366,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -4252,0 +4369,1 @@\n+\n@@ -4254,1 +4372,1 @@\n-        ShortVector ldLongOp(MemorySegment memory, long offset,\n+        ShortVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -4256,1 +4374,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -4261,1 +4379,1 @@\n-        ShortVector ldLongOp(MemorySegment memory, long offset,\n+        ShortVector ldLongOpMF(MemorySegment memory, long offset,\n@@ -4264,1 +4382,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -4269,2 +4387,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -4275,2 +4393,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Short> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<Short> m,\n@@ -4278,1 +4396,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -4281,0 +4399,1 @@\n+\n@@ -4283,2 +4402,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -4289,1 +4408,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -4292,1 +4411,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -4306,2 +4425,3 @@\n-            if ((Class<?>) vectorType() == ShortMaxVector.class)\n-                return ShortMaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ShortMaxVector.class)\n+            \/\/    return ShortMaxVector.ZERO;\n@@ -4320,2 +4440,3 @@\n-            if ((Class<?>) vectorType() == ShortMaxVector.class)\n-                return ShortMaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ShortMaxVector.class)\n+            \/\/    return ShortMaxVector.IOTA;\n@@ -4335,2 +4456,3 @@\n-            if ((Class<?>) vectorType() == ShortMaxVector.class)\n-                return ShortMaxVector.ShortMaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == ShortMaxVector.class)\n+            \/\/    return ShortMaxVector.ShortMaxMask.maskAll(bit);\n@@ -4345,0 +4467,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            short [] init = new short[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = (short)i;\n+            }\n+           return init;\n+        }\n@@ -4361,1 +4493,2 @@\n-            case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n@@ -4395,1 +4528,2 @@\n-    public static final VectorSpecies<Short> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<Short> SPECIES_MAX\n@@ -4400,0 +4534,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":348,"deletions":213,"binary":false,"changes":561,"status":"modified"},{"patch":"@@ -1174,1 +1174,1 @@\n-@SuppressWarnings(\"exports\")\n+@SuppressWarnings({\"exports\", \"missing-explicit-ctor\"})\n@@ -1177,5 +1177,4 @@\n-    \/\/ This type is sealed within its package.\n-    \/\/ Users cannot roll their own vector types.\n-    Vector(Object bits) {\n-        super(bits);\n-    }\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public Vector() {}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+@SuppressWarnings({\"cast\"})  \/\/ warning: redundant cast\n@@ -54,4 +54,0 @@\n-    $abstractvectortype$($type$[] vec) {\n-        super(vec);\n-    }\n-\n@@ -63,0 +59,4 @@\n+    \/**\n+     * Default Constructor for abstract vector.\n+     *\/\n+    public $abstractvectortype$() {}\n@@ -103,0 +103,2 @@\n+    abstract VectorPayloadMF vec_mf();\n+\n@@ -112,0 +114,2 @@\n+    abstract $abstractvectortype$ vectorFactory(VectorPayloadMF vec);\n+\n@@ -131,1 +135,1 @@\n-    $abstractvectortype$ vOp(FVOp f) {\n+    $abstractvectortype$ vOpMF(FVOp f) {\n@@ -136,1 +140,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -141,1 +146,1 @@\n-    $abstractvectortype$ vOp(VectorMask<$Boxtype$> m, FVOp f) {\n+    $abstractvectortype$ vOpMF(VectorMask<$Boxtype$> m, FVOp f) {\n@@ -149,1 +154,2 @@\n-        return vectorFactory(res);\n+        VectorPayloadMF vec_mf = vspecies().createVectorMF(res);\n+        return vectorFactory(vec_mf);\n@@ -161,1 +167,1 @@\n-    $abstractvectortype$ uOp(FUnOp f);\n+    $abstractvectortype$ uOpMF(FUnOp f);\n@@ -164,5 +170,8 @@\n-    $abstractvectortype$ uOpTemplate(FUnOp f) {\n-        $type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec[i]);\n+    $abstractvectortype$ uOpTemplateMF(FUnOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(i, v));\n@@ -170,1 +179,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -175,1 +185,1 @@\n-    $abstractvectortype$ uOp(VectorMask<$Boxtype$> m,\n+    $abstractvectortype$ uOpMF(VectorMask<$Boxtype$> m,\n@@ -179,1 +189,1 @@\n-    $abstractvectortype$ uOpTemplate(VectorMask<$Boxtype$> m,\n+    $abstractvectortype$ uOpTemplateMF(VectorMask<$Boxtype$> m,\n@@ -182,1 +192,1 @@\n-            return uOpTemplate(f);\n+            return uOpTemplateMF(f);\n@@ -184,2 +194,0 @@\n-        $type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n@@ -187,2 +195,7 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, mbits[i] ? f.apply(i, v): v);\n@@ -190,1 +203,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -202,1 +216,1 @@\n-    $abstractvectortype$ bOp(Vector<$Boxtype$> o,\n+    $abstractvectortype$ bOpMF(Vector<$Boxtype$> o,\n@@ -206,1 +220,1 @@\n-    $abstractvectortype$ bOpTemplate(Vector<$Boxtype$> o,\n+    $abstractvectortype$ bOpTemplateMF(Vector<$Boxtype$> o,\n@@ -208,5 +222,9 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(i, v1, v2));\n@@ -214,1 +232,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -219,1 +238,1 @@\n-    $abstractvectortype$ bOp(Vector<$Boxtype$> o,\n+    $abstractvectortype$ bOpMF(Vector<$Boxtype$> o,\n@@ -224,1 +243,1 @@\n-    $abstractvectortype$ bOpTemplate(Vector<$Boxtype$> o,\n+    $abstractvectortype$ bOpTemplateMF(Vector<$Boxtype$> o,\n@@ -228,1 +247,1 @@\n-            return bOpTemplate(o, f);\n+            return bOpTemplateMF(o, f);\n@@ -230,3 +249,0 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o).vec();\n@@ -234,2 +250,9 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n@@ -237,1 +260,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -249,1 +273,1 @@\n-    $abstractvectortype$ tOp(Vector<$Boxtype$> o1,\n+    $abstractvectortype$ tOpMF(Vector<$Boxtype$> o1,\n@@ -254,1 +278,1 @@\n-    $abstractvectortype$ tOpTemplate(Vector<$Boxtype$> o1,\n+    $abstractvectortype$ tOpTemplateMF(Vector<$Boxtype$> o1,\n@@ -257,6 +281,11 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o1).vec();\n-        $type$[] vec3 = (($abstractvectortype$)o2).vec();\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec_mf();\n+        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n+            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, start_offset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(i, v1, v2, v3));\n@@ -264,1 +293,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -269,1 +299,1 @@\n-    $abstractvectortype$ tOp(Vector<$Boxtype$> o1,\n+    $abstractvectortype$ tOpMF(Vector<$Boxtype$> o1,\n@@ -275,1 +305,1 @@\n-    $abstractvectortype$ tOpTemplate(Vector<$Boxtype$> o1,\n+    $abstractvectortype$ tOpTemplateMF(Vector<$Boxtype$> o1,\n@@ -280,1 +310,1 @@\n-            return tOpTemplate(o1, o2, f);\n+            return tOpTemplateMF(o1, o2, f);\n@@ -282,4 +312,0 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o1).vec();\n-        $type$[] vec3 = (($abstractvectortype$)o2).vec();\n@@ -287,2 +313,11 @@\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec_mf();\n+        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec_mf();\n+        VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec1);\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n+            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, start_offset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n@@ -290,1 +325,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -297,1 +333,1 @@\n-    $type$ rOp($type$ v, VectorMask<$Boxtype$> m, FBinOp f);\n+    $type$ rOpMF($type$ v, VectorMask<$Boxtype$> m, FBinOp f);\n@@ -301,1 +337,1 @@\n-    $type$ rOpTemplate($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n+    $type$ rOpTemplateMF($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n@@ -303,1 +339,1 @@\n-            return rOpTemplate(v, f);\n+            return rOpTemplateMF(v, f);\n@@ -305,1 +341,1 @@\n-        $type$[] vec = vec();\n+        VectorPayloadMF vec = this.vec_mf();\n@@ -307,2 +343,5 @@\n-        for (int i = 0; i < vec.length; i++) {\n-            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n+            v = mbits[i] ? f.apply(i, v, v1) : v;\n@@ -315,4 +354,7 @@\n-    $type$ rOpTemplate($type$ v, FBinOp f) {\n-        $type$[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            v = f.apply(i, v, vec[i]);\n+    $type$ rOpTemplateMF($type$ v, FBinOp f) {\n+        VectorPayloadMF vec = this.vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n+            v = f.apply(i, v, v1);\n@@ -333,1 +375,1 @@\n-    <M> $abstractvectortype$ ldOp(M memory, int offset,\n+    <M> $abstractvectortype$ ldOpMF(M memory, int offset,\n@@ -335,4 +377,7 @@\n-        \/\/dummy; no vec = vec();\n-        $type$[] res = new $type$[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                $Boxtype$.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -340,1 +385,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -346,1 +392,1 @@\n-    <M> $abstractvectortype$ ldOp(M memory, int offset,\n+    <M> $abstractvectortype$ ldOpMF(M memory, int offset,\n@@ -349,2 +395,5 @@\n-        \/\/$type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                $Boxtype$.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -352,1 +401,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -354,1 +403,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -357,1 +406,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -360,0 +410,1 @@\n+\n@@ -368,1 +419,1 @@\n-    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+    $abstractvectortype$ ldLongOpMF(MemorySegment memory, long offset,\n@@ -370,4 +421,7 @@\n-        \/\/dummy; no vec = vec();\n-        $type$[] res = new $type$[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                $Boxtype$.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -375,1 +429,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -381,1 +436,1 @@\n-    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+    $abstractvectortype$ ldLongOpMF(MemorySegment memory, long offset,\n@@ -384,2 +439,5 @@\n-        \/\/$type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n+        int length = vspecies().length();\n+        VectorPayloadMF tpayload =\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+                $Boxtype$.BYTES, length));\n+        long start_offset = this.multiFieldOffset();\n@@ -387,1 +445,1 @@\n-        for (int i = 0; i < res.length; i++) {\n+        for (int i = 0; i < length; i++) {\n@@ -389,1 +447,1 @@\n-                res[i] = f.apply(memory, offset, i);\n+                Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -392,1 +450,2 @@\n-        return vectorFactory(res);\n+        tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+        return vectorFactory(tpayload);\n@@ -406,1 +465,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -408,3 +467,5 @@\n-        $type$[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n@@ -415,1 +476,1 @@\n-    @ForceInline\n+   @ForceInline\n@@ -417,1 +478,1 @@\n-    <M> void stOp(M memory, int offset,\n+    <M> void stOpMF(M memory, int offset,\n@@ -420,1 +481,1 @@\n-        $type$[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -422,1 +483,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -424,1 +487,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n@@ -429,0 +492,1 @@\n+\n@@ -436,1 +500,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -438,3 +502,5 @@\n-        $type$[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n+        VectorPayloadMF vec = vec_mf();\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n@@ -447,1 +513,1 @@\n-    void stLongOp(MemorySegment memory, long offset,\n+    void stLongOpMF(MemorySegment memory, long offset,\n@@ -450,1 +516,1 @@\n-        $type$[] vec = vec();\n+        VectorPayloadMF vec = vec_mf();\n@@ -452,1 +518,3 @@\n-        for (int i = 0; i < vec.length; i++) {\n+        long start_offset = this.multiFieldOffset();\n+        int length = vspecies().length();\n+        for (int i = 0; i < length; i++) {\n@@ -454,1 +522,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n@@ -473,1 +541,1 @@\n-    AbstractMask<$Boxtype$> bTest(int cond,\n+    AbstractMask<$Boxtype$> bTestMF(int cond,\n@@ -476,5 +544,9 @@\n-        $type$[] vec1 = vec();\n-        $type$[] vec2 = (($abstractvectortype$)o).vec();\n-        boolean[] bits = new boolean[length()];\n-        for (int i = 0; i < length(); i++){\n-            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        VectorPayloadMF vec1 = this.vec_mf();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec_mf();\n+        int length = vspecies().length();\n+        long start_offset = this.multiFieldOffset();\n+        boolean[] bits = new boolean[length];\n+        for (int i = 0; i < length; i++) {\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n+            bits[i] = f.apply(cond, i, v1, v2);\n@@ -580,1 +652,1 @@\n-                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                        ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -584,1 +656,1 @@\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+                                ((bits_, s_) -> s_.rvOpMF(i -> bits_)));\n@@ -751,1 +823,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) -a);\n+                    v0.uOpMF(m, (i, a) -> ($type$) -a);\n@@ -753,1 +825,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.abs(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.abs(a));\n@@ -757,1 +829,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.bitCount(a));\n@@ -759,1 +831,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.numberOfTrailingZeros(a));\n@@ -761,1 +833,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.numberOfLeadingZeros(a));\n@@ -763,1 +835,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverse(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.reverse(a));\n@@ -766,1 +838,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) bitCount(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) bitCount(a));\n@@ -768,1 +840,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) numberOfTrailingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) numberOfTrailingZeros(a));\n@@ -770,1 +842,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) numberOfLeadingZeros(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) numberOfLeadingZeros(a));\n@@ -772,1 +844,1 @@\n-                    v0.uOp(m, (i, a) -> reverse(a));\n+                    v0.uOpMF(m, (i, a) -> reverse(a));\n@@ -777,1 +849,1 @@\n-                    v0.uOp(m, (i, a) -> a);\n+                    v0.uOpMF(m, (i, a) -> a);\n@@ -780,1 +852,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverseBytes(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) $Boxtype$.reverseBytes(a));\n@@ -786,1 +858,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.sin(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.sin(a));\n@@ -788,1 +860,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.cos(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.cos(a));\n@@ -790,1 +862,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.tan(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.tan(a));\n@@ -792,1 +864,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.asin(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.asin(a));\n@@ -794,1 +866,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.acos(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.acos(a));\n@@ -796,1 +868,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.atan(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.atan(a));\n@@ -798,1 +870,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.exp(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.exp(a));\n@@ -800,1 +872,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.log(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.log(a));\n@@ -802,1 +874,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.log10(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.log10(a));\n@@ -804,1 +876,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.sqrt(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.sqrt(a));\n@@ -806,1 +878,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.cbrt(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.cbrt(a));\n@@ -808,1 +880,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.sinh(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.sinh(a));\n@@ -810,1 +882,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.cosh(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.cosh(a));\n@@ -812,1 +884,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.tanh(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.tanh(a));\n@@ -814,1 +886,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.expm1(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.expm1(a));\n@@ -816,1 +888,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.log1p(a));\n+                    v0.uOpMF(m, (i, a) -> ($type$) Math.log1p(a));\n@@ -871,1 +943,1 @@\n-            BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperations));\n+            BIN_IMPL.find(op, opc, $abstractvectortype$::binaryOperationsMF));\n@@ -942,1 +1014,53 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a + b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a + b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a - b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a * b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n+#if[BITWISE]\n+            case VECTOR_OP_AND: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a & b));\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a | b));\n+            case VECTOR_OP_XOR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a ^ b));\n+            case VECTOR_OP_LSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)(a << n));\n+            case VECTOR_OP_RSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)(a >> n));\n+            case VECTOR_OP_URSHIFT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n+            case VECTOR_OP_LROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+            case VECTOR_OP_RROTATE: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+#if[intOrLong]\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> $Boxtype$.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, n) -> $Boxtype$.expand(a, n));\n+#end[intOrLong]\n+#end[BITWISE]\n+#if[FP]\n+            case VECTOR_OP_OR: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));\n+#end[FP]\n+            default: return null;\n+        }\n+    }\n+\n+    private static BinaryOperation<$abstractvectortype$, VectorMask<$Boxtype$>> binaryOperationsMF(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a + b));\n@@ -944,1 +1068,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a - b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a - b));\n@@ -946,1 +1070,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a * b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a * b));\n@@ -948,1 +1072,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n@@ -950,1 +1074,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n@@ -952,1 +1076,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n@@ -955,1 +1079,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a & b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a & b));\n@@ -957,1 +1081,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a | b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a | b));\n@@ -959,1 +1083,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a ^ b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$)(a ^ b));\n@@ -961,1 +1085,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> ($type$)(a << n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)(a << n));\n@@ -963,1 +1087,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> ($type$)(a >> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)(a >> n));\n@@ -965,1 +1089,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n@@ -967,1 +1091,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateLeft(a, (int)n));\n@@ -969,1 +1093,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> rotateRight(a, (int)n));\n@@ -972,1 +1096,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.compress(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> $Boxtype$.compress(a, n));\n@@ -974,1 +1098,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.expand(a, n));\n+                    v0.bOpMF(v1, vm, (i, a, n) -> $Boxtype$.expand(a, n));\n@@ -979,1 +1103,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -981,1 +1105,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.atan2(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.atan2(a, b));\n@@ -983,1 +1107,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));\n@@ -985,1 +1109,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));\n+                    v0.bOpMF(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));\n@@ -991,0 +1115,1 @@\n+\n@@ -1170,1 +1295,1 @@\n-                    v.uOp(m, (i, a) -> ($type$)(a << n));\n+                    v.uOpMF(m, (i, a) -> ($type$)(a << n));\n@@ -1172,1 +1297,1 @@\n-                    v.uOp(m, (i, a) -> ($type$)(a >> n));\n+                    v.uOpMF(m, (i, a) -> ($type$)(a >> n));\n@@ -1174,1 +1299,1 @@\n-                    v.uOp(m, (i, a) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOpMF(m, (i, a) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n@@ -1176,1 +1301,1 @@\n-                    v.uOp(m, (i, a) -> rotateLeft(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateLeft(a, (int)n));\n@@ -1178,1 +1303,1 @@\n-                    v.uOp(m, (i, a) -> rotateRight(a, (int)n));\n+                    v.uOpMF(m, (i, a) -> rotateRight(a, (int)n));\n@@ -1297,1 +1422,1 @@\n-                    v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n+                    v0.tOpMF(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n@@ -2420,1 +2545,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2442,1 +2567,1 @@\n-                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                    = v0.bTestMF(cond, v1, (cond_, i, a, b)\n@@ -2575,1 +2700,1 @@\n-            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+            (v0, v1, m_) -> v0.bOpMF(v1, m_, (i, a, b) -> b));\n@@ -2784,1 +2909,1 @@\n-            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+            (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2816,1 +2941,1 @@\n-                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                   (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -2844,1 +2969,1 @@\n-                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                (v0, s_, m_) -> v0.uOpMF((i, a) -> {\n@@ -2852,1 +2977,1 @@\n-                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                (v1, s_, m_) -> v1.uOpMF((i, a) -> {\n@@ -3323,1 +3448,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a + b)));\n+                    toBits(v.rOpMF(($type$)0, m, (i, a, b) -> ($type$)(a + b)));\n@@ -3325,1 +3450,1 @@\n-                    toBits(v.rOp(($type$)1, m, (i, a, b) -> ($type$)(a * b)));\n+                    toBits(v.rOpMF(($type$)1, m, (i, a, b) -> ($type$)(a * b)));\n@@ -3327,1 +3452,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($type$) Math.min(a, b)));\n+                    toBits(v.rOpMF(MAX_OR_INF, m, (i, a, b) -> ($type$) Math.min(a, b)));\n@@ -3329,1 +3454,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($type$) Math.max(a, b)));\n+                    toBits(v.rOpMF(MIN_OR_INF, m, (i, a, b) -> ($type$) Math.max(a, b)));\n@@ -3332,1 +3457,1 @@\n-                    toBits(v.rOp(($type$)-1, m, (i, a, b) -> ($type$)(a & b)));\n+                    toBits(v.rOpMF(($type$)-1, m, (i, a, b) -> ($type$)(a & b)));\n@@ -3334,1 +3459,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a | b)));\n+                    toBits(v.rOpMF(($type$)0, m, (i, a, b) -> ($type$)(a | b)));\n@@ -3336,1 +3461,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a ^ b)));\n+                    toBits(v.rOpMF(($type$)0, m, (i, a, b) -> ($type$)(a ^ b)));\n@@ -3549,1 +3674,1 @@\n-        return vsp.dummyVector().fromArray0(a, offset);\n+        return vsp.dummyVectorMF().fromArray0(a, offset);\n@@ -3625,1 +3750,1 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3645,1 +3770,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -3654,1 +3779,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -3657,0 +3782,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -3677,1 +3804,1 @@\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(n -> c[idx + iMap[idy+n]]));\n@@ -3725,1 +3852,1 @@\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> a[offset + indexMap[mapOffset + n]]);\n@@ -3845,1 +3972,1 @@\n-        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -3892,1 +4019,1 @@\n-        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        return vsp.vOpMF(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n@@ -4004,1 +4131,1 @@\n-        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        return vsp.vOpMF(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n@@ -4051,1 +4178,1 @@\n-        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        return vsp.vOpMF(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n@@ -4189,1 +4316,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -4191,0 +4318,1 @@\n+\n@@ -4263,1 +4391,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -4283,1 +4411,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -4291,1 +4419,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -4294,0 +4422,2 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -4316,1 +4446,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOpMF(arr, off,\n@@ -4360,1 +4490,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -4408,1 +4538,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -4485,1 +4615,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -4530,1 +4660,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -4569,1 +4699,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -4652,1 +4782,1 @@\n-        stOp(a, offset,\n+        stOpMF(a, offset,\n@@ -4700,1 +4830,1 @@\n-        stOp(a, offset, m,\n+        stOpMF(a, offset, m,\n@@ -4779,1 +4909,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -4796,1 +4926,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -4824,1 +4954,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -4833,1 +4963,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -4836,0 +4966,2 @@\n+             *\/\n+            assert false : \"Unhandled case for Multi-field based MaxVector\";\n@@ -4857,1 +4989,1 @@\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            s.vOpMF(vm, n -> c[idx + iMap[idy+n]]));\n@@ -4873,1 +5005,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -4890,1 +5022,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -4907,1 +5039,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n+            (arr, off, s) -> s.ldOpMF(arr, (int) off,\n@@ -4924,1 +5056,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+            (arr, off, s, vm) -> s.ldOpMF(arr, (int) off, vm,\n@@ -4939,1 +5071,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, $abstractvectortype$::memorySegmentGet);\n@@ -4955,1 +5087,1 @@\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentGet);\n+                    return s.ldLongOpMF((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentGet);\n@@ -4974,1 +5106,1 @@\n-            -> v.stOp(arr, (int) off,\n+            -> v.stOpMF(arr, (int) off,\n@@ -4991,1 +5123,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -5015,1 +5147,1 @@\n-        IntVector vix;\n+        IntVector vix = null;\n@@ -5023,1 +5155,1 @@\n-            vix = IntVector\n+            \/*vix = IntVector\n@@ -5026,0 +5158,3 @@\n+             *\/\n+             assert false : \"Unhandled case for Multi-field based MaxVector\";\n+\n@@ -5049,1 +5184,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOpMF(arr, off, vm,\n@@ -5072,1 +5207,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -5086,1 +5221,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, $abstractvectortype$::memorySegmentSet);\n@@ -5103,1 +5238,1 @@\n-                    v.stLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentSet);\n+                    v.stLongOpMF((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentSet);\n@@ -5122,1 +5257,1 @@\n-            -> v.stOp(arr, (int) off, vm,\n+            -> v.stOpMF(arr, (int) off, vm,\n@@ -5394,1 +5529,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (bits_, s_) -> s_.rvOpMF(i -> bits_));\n@@ -5471,0 +5606,6 @@\n+        @ForceInline\n+        @Override final\n+        $abstractvectortype$ dummyVectorMF() {\n+            return ($abstractvectortype$) super.dummyVectorMF();\n+        }\n+\n@@ -5474,1 +5615,1 @@\n-        $abstractvectortype$ rvOp(RVOp f) {\n+        $abstractvectortype$ rvOpMF(RVOp f) {\n@@ -5480,1 +5621,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -5483,1 +5625,1 @@\n-        $Type$Vector vOp(FVOp f) {\n+        $Type$Vector vOpMF(FVOp f) {\n@@ -5488,1 +5630,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -5491,1 +5634,1 @@\n-        $Type$Vector vOp(VectorMask<$Boxtype$> m, FVOp f) {\n+        $Type$Vector vOpMF(VectorMask<$Boxtype$> m, FVOp f) {\n@@ -5499,1 +5642,2 @@\n-            return dummyVector().vectorFactory(res);\n+            VectorPayloadMF vec_mf = createVectorMF(res);\n+            return dummyVectorMF().vectorFactory(vec_mf);\n@@ -5504,1 +5648,1 @@\n-        <M> $abstractvectortype$ ldOp(M memory, int offset,\n+        <M> $abstractvectortype$ ldOpMF(M memory, int offset,\n@@ -5506,1 +5650,1 @@\n-            return dummyVector().ldOp(memory, offset, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, f);\n@@ -5511,1 +5655,1 @@\n-        <M> $abstractvectortype$ ldOp(M memory, int offset,\n+        <M> $abstractvectortype$ ldOpMF(M memory, int offset,\n@@ -5514,1 +5658,1 @@\n-            return dummyVector().ldOp(memory, offset, m, f);\n+            return dummyVectorMF().ldOpMF(memory, offset, m, f);\n@@ -5517,0 +5661,1 @@\n+\n@@ -5519,1 +5664,1 @@\n-        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+        $abstractvectortype$ ldLongOpMF(MemorySegment memory, long offset,\n@@ -5521,1 +5666,1 @@\n-            return dummyVector().ldLongOp(memory, offset, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, f);\n@@ -5526,1 +5671,1 @@\n-        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+        $abstractvectortype$ ldLongOpMF(MemorySegment memory, long offset,\n@@ -5529,1 +5674,1 @@\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n+            return dummyVectorMF().ldLongOpMF(memory, offset, m, f);\n@@ -5534,2 +5679,2 @@\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n+        <M> void stOpMF(M memory, int offset, FStOp<M> f) {\n+            dummyVectorMF().stOpMF(memory, offset, f);\n@@ -5540,2 +5685,2 @@\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<$Boxtype$> m,\n+        <M> void stOpMF(M memory, int offset,\n+                     AbstractMask<$Boxtype$> m,\n@@ -5543,1 +5688,1 @@\n-            dummyVector().stOp(memory, offset, m, f);\n+            dummyVectorMF().stOpMF(memory, offset, m, f);\n@@ -5546,0 +5691,1 @@\n+\n@@ -5548,2 +5694,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        void stLongOpMF(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVectorMF().stLongOpMF(memory, offset, f);\n@@ -5554,1 +5700,1 @@\n-        void stLongOp(MemorySegment memory, long offset,\n+        void stLongOpMF(MemorySegment memory, long offset,\n@@ -5557,1 +5703,1 @@\n-            dummyVector().stLongOp(memory, offset, m, f);\n+            dummyVectorMF().stLongOpMF(memory, offset, m, f);\n@@ -5571,2 +5717,3 @@\n-            if ((Class<?>) vectorType() == $Type$MaxVector.class)\n-                return $Type$MaxVector.ZERO;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == $Type$MaxVector.class)\n+            \/\/    return $Type$MaxVector.ZERO;\n@@ -5585,2 +5732,3 @@\n-            if ((Class<?>) vectorType() == $Type$MaxVector.class)\n-                return $Type$MaxVector.IOTA;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == $Type$MaxVector.class)\n+            \/\/    return $Type$MaxVector.IOTA;\n@@ -5600,2 +5748,3 @@\n-            if ((Class<?>) vectorType() == $Type$MaxVector.class)\n-                return $Type$MaxVector.$Type$MaxMask.maskAll(bit);\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/if ((Class<?>) vectorType() == $Type$MaxVector.class)\n+            \/\/    return $Type$MaxVector.$Type$MaxMask.maskAll(bit);\n@@ -5610,0 +5759,10 @@\n+\n+        @Override\n+        Object iotaArray() {\n+            int laneCount = laneCount();\n+            $type$ [] init = new $type$[laneCount];\n+            for (int i = 0; i < laneCount; i++) {\n+                init[i] = ($type$)i;\n+            }\n+           return init;\n+        }\n@@ -5626,1 +5785,2 @@\n-            case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;\n+            \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+            \/\/case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;\n@@ -5660,1 +5820,2 @@\n-    public static final VectorSpecies<$Boxtype$> SPECIES_MAX\n+    \/\/ FIXME: Enable once multi-field based MaxVector is supported.\n+    \/*public static final VectorSpecies<$Boxtype$> SPECIES_MAX\n@@ -5665,0 +5826,1 @@\n+     *\/\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":424,"deletions":262,"binary":false,"changes":686,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -42,1 +43,1 @@\n-final class $vectortype$ extends $abstractvectortype$ {\n+value class $vectortype$ extends $abstractvectortype$ {\n@@ -57,2 +58,6 @@\n-    $vectortype$($type$[] v) {\n-        super(v);\n+    static final long MFOFFSET = VectorPayloadMF.multiFieldOffset(VectorSupport.VectorPayloadMF$bits$.class);\n+\n+    private final VectorSupport.VectorPayloadMF$bits$ payload;\n+\n+    $vectortype$(Object value) {\n+        this.payload = (VectorSupport.VectorPayloadMF$bits$)value;\n@@ -61,4 +66,7 @@\n-    \/\/ For compatibility as $vectortype$::new,\n-    \/\/ stored into species.vectorFactory.\n-    $vectortype$(Object v) {\n-        this(($type$[]) v);\n+    VectorPayloadMF vec_mf() {\n+        return payload;\n+    }\n+\n+    @Override\n+    protected final Object getPayload() {\n+       return vec_mf();\n@@ -67,2 +75,2 @@\n-    static final $vectortype$ ZERO = new $vectortype$(new $type$[VLENGTH]);\n-    static final $vectortype$ IOTA = new $vectortype$(VSPECIES.iotaArray());\n+    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.createVectPayloadInstance($Boxtype$.BYTES, $numLanes$));\n+    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($Boxtype$.BYTES, $numLanes$, ($type$ [])(VSPECIES.iotaArray())));\n@@ -74,1 +82,1 @@\n-        VSPECIES.dummyVector();\n+        VSPECIES.dummyVectorMF();\n@@ -113,0 +121,4 @@\n+    @ForceInline\n+    @Override\n+    public final long multiFieldOffset() { return MFOFFSET; }\n+\n@@ -176,0 +188,7 @@\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    $vectortype$ vectorFactory(VectorPayloadMF vec) {\n+        return new $vectortype$(vec);\n+    }\n+\n@@ -192,2 +211,2 @@\n-    $vectortype$ uOp(FUnOp f) {\n-        return ($vectortype$) super.uOpTemplate(f);  \/\/ specialize\n+    $vectortype$ uOpMF(FUnOp f) {\n+        return ($vectortype$) super.uOpTemplateMF(f);  \/\/ specialize\n@@ -198,1 +217,1 @@\n-    $vectortype$ uOp(VectorMask<$Boxtype$> m, FUnOp f) {\n+    $vectortype$ uOpMF(VectorMask<$Boxtype$> m, FUnOp f) {\n@@ -200,1 +219,1 @@\n-            super.uOpTemplate(($masktype$)m, f);  \/\/ specialize\n+            super.uOpTemplateMF(($masktype$)m, f);  \/\/ specialize\n@@ -207,2 +226,2 @@\n-    $vectortype$ bOp(Vector<$Boxtype$> v, FBinOp f) {\n-        return ($vectortype$) super.bOpTemplate(($vectortype$)v, f);  \/\/ specialize\n+    $vectortype$ bOpMF(Vector<$Boxtype$> v, FBinOp f) {\n+        return ($vectortype$) super.bOpTemplateMF(($vectortype$)v, f);  \/\/ specialize\n@@ -213,1 +232,1 @@\n-    $vectortype$ bOp(Vector<$Boxtype$> v,\n+    $vectortype$ bOpMF(Vector<$Boxtype$> v,\n@@ -216,2 +235,2 @@\n-            super.bOpTemplate(($vectortype$)v, ($masktype$)m,\n-                              f);  \/\/ specialize\n+            super.bOpTemplateMF(($vectortype$)v, ($masktype$)m,\n+                                f);  \/\/ specialize\n@@ -224,1 +243,1 @@\n-    $vectortype$ tOp(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2, FTriOp f) {\n+    $vectortype$ tOpMF(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2, FTriOp f) {\n@@ -226,2 +245,2 @@\n-            super.tOpTemplate(($vectortype$)v1, ($vectortype$)v2,\n-                              f);  \/\/ specialize\n+            super.tOpTemplateMF(($vectortype$)v1, ($vectortype$)v2,\n+                                f);  \/\/ specialize\n@@ -232,1 +251,1 @@\n-    $vectortype$ tOp(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2,\n+    $vectortype$ tOpMF(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2,\n@@ -235,2 +254,2 @@\n-            super.tOpTemplate(($vectortype$)v1, ($vectortype$)v2,\n-                              ($masktype$)m, f);  \/\/ specialize\n+            super.tOpTemplateMF(($vectortype$)v1, ($vectortype$)v2,\n+                                ($masktype$)m, f);  \/\/ specialize\n@@ -241,2 +260,2 @@\n-    $type$ rOp($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n-        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    $type$ rOpMF($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n+        return super.rOpTemplateMF(v, m, f);  \/\/ specialize\n@@ -563,2 +582,3 @@\n-                     $type$[] vecarr = vec.vec();\n-                     return (long)$Type$.$type$To$Bitstype$Bits(vecarr[ix]);\n+                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         long start_offset = vecpayload.multiFieldOffset();\n+                         return (long)$Type$.$type$To$Bitstype$Bits(Unsafe.getUnsafe().get$Type$(vecpayload, start_offset + ix * $Boxtype$.BYTES));\n@@ -612,3 +632,6 @@\n-                                    $type$[] res = v.vec().clone();\n-                                    res[ix] = $Type$.$bitstype$BitsTo$Type$(($bitstype$)bits);\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().put$Type$(tpayload, start_offset + ix * $Boxtype$.BYTES, $Type$.$bitstype$BitsTo$Type$(($bitstype$)bits));\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n@@ -711,6 +734,7 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i,\n-                                (vec, ix) -> {\n-                                    $type$[] vecarr = vec.vec();\n-                                    return (long)vecarr[ix];\n-                                });\n+                             VCLASS, ETYPE, VLENGTH,\n+                             this, i,\n+                             (vec, ix) -> {\n+                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 long start_offset = vecpayload.multiFieldOffset();\n+                                 return (long)Unsafe.getUnsafe().get$Type$(vecpayload, start_offset + ix * $Boxtype$.BYTES);\n+                             });\n@@ -811,1 +835,1 @@\n-        return VectorSupport.insert(\n+       return VectorSupport.insert(\n@@ -815,3 +839,6 @@\n-                                    $type$[] res = v.vec().clone();\n-                                    res[ix] = ($type$)bits;\n-                                    return v.vectorFactory(res);\n+                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF tpayload = Unsafe.getUnsafe().makePrivateBuffer(vec);\n+                                    long start_offset = tpayload.multiFieldOffset();\n+                                    Unsafe.getUnsafe().put$Type$(tpayload, start_offset + ix * $Boxtype$.BYTES, ($type$)bits);\n+                                    tpayload = Unsafe.getUnsafe().finishPrivateBuffer(tpayload);\n+                                    return v.vectorFactory(tpayload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":69,"deletions":42,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  Boxinitials=\"$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})\"\n@@ -122,1 +123,1 @@\n-  args=\"$args -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n+  args=\"$args -K$kind -DBoxtype=$Boxtype -DBoxinitials=$Boxinitials -DWideboxtype=$Wideboxtype\"\n@@ -147,1 +148,2 @@\n-  for bits in 64 128 256 512 Max\n+  # for bits in 64 128 256 512 Max\n+  for bits in 64 128 256 512\n@@ -193,1 +195,1 @@\n-    bitargs=\"$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape\"\n+    bitargs=\"$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -DnumLanes=$numLanes  -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation ByteMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch ByteMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation DoubleMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch DoubleMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation IntMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch IntMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation LongMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch LongMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation ShortMaxVectorTests\n+ * @run testng\/othervm -ea -esa -Xbatch ShortMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  for bits in 64 128 256 512 Max\n+  for bits in 64 128 256 512\n@@ -211,1 +211,1 @@\n-  for bits in 64 128 256 512 Max\n+  for bits in 64 128 256 512\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}