{"files":[{"patch":"@@ -186,0 +186,1 @@\n+JVM_PrintWarningAtDynamicAgentLoad\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,5 +102,0 @@\n-NSK_GC_LOCK_MALLOC_INCLUDES := \\\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/gc\/lock\/malloc \\\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native \\\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n-\n@@ -182,2 +177,0 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libMallocLocker := $(NSK_GC_LOCK_MALLOC_INCLUDES)\n-\n@@ -878,1 +871,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c libnativeStack.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c libnativeStack.c exeGetCreatedJavaVMs.c\n@@ -1521,0 +1514,1 @@\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeGetCreatedJavaVMs := -ljvm -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -667,5 +667,0 @@\n-\/\/ Class for heapbase register\n-reg_class heapbase_reg(\n-    R27, R27_H\n-);\n-\n@@ -1247,2 +1242,2 @@\n-      _NO_SPECIAL_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);\n-      _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);\n+      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n@@ -1254,2 +1249,2 @@\n-      _NO_SPECIAL_REG_mask.SUBTRACT(_FP_REG_mask);\n-      _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_FP_REG_mask);\n+      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n@@ -5362,11 +5357,0 @@\n-\/\/ heap base register -- used for encoding immN0\n-\n-operand iRegIHeapbase()\n-%{\n-  constraint(ALLOC_IN_RC(heapbase_reg));\n-  match(RegI);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -15091,36 +15075,0 @@\n-instruct convI2B(iRegINoSp dst, iRegIorL2I src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmpw $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmpw(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct convP2B(iRegINoSp dst, iRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{\n-    \"cmp  $src, zr\\n\\t\"\n-    \"cset $dst, ne\"\n-  %}\n-\n-  ins_encode %{\n-    __ cmp(as_Register($src$$reg), zr);\n-    __ cset(as_Register($dst$$reg), Assembler::NE);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":56,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -7075,0 +7075,165 @@\n+  \/\/ In sun.security.util.math.intpoly.IntegerPolynomial1305, integers\n+  \/\/ are represented as long[5], with BITS_PER_LIMB = 26.\n+  \/\/ Pack five 26-bit limbs into three 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register dest2, Register src) {\n+    __ ldp(dest0, rscratch1, Address(src, 0));     \/\/ 26 bits\n+    __ add(dest0, dest0, rscratch1, Assembler::LSL, 26);  \/\/ 26 bits\n+    __ ldp(rscratch1, rscratch2, Address(src, 2 * sizeof (jlong)));\n+    __ add(dest0, dest0, rscratch1, Assembler::LSL, 52);  \/\/ 12 bits\n+\n+    __ add(dest1, zr, rscratch1, Assembler::LSR, 12);     \/\/ 14 bits\n+    __ add(dest1, dest1, rscratch2, Assembler::LSL, 14);  \/\/ 26 bits\n+    __ ldr(rscratch1, Address(src, 4 * sizeof (jlong)));\n+    __ add(dest1, dest1, rscratch1, Assembler::LSL, 40);  \/\/ 24 bits\n+\n+    if (dest2->is_valid()) {\n+      __ add(dest2, zr, rscratch1, Assembler::LSR, 24);     \/\/ 2 bits\n+    } else {\n+#ifdef ASSERT\n+      Label OK;\n+      __ cmp(zr, rscratch1, Assembler::LSR, 24);     \/\/ 2 bits\n+      __ br(__ EQ, OK);\n+      __ stop(\"high bits of Poly1305 integer should be zero\");\n+      __ should_not_reach_here();\n+      __ bind(OK);\n+#endif\n+    }\n+  }\n+\n+  \/\/ As above, but return only a 128-bit integer, packed into two\n+  \/\/ 64-bit registers.\n+  void pack_26(Register dest0, Register dest1, Register src) {\n+    pack_26(dest0, dest1, noreg, src);\n+  }\n+\n+  \/\/ Multiply and multiply-accumulate unsigned 64-bit registers.\n+  void wide_mul(Register prod_lo, Register prod_hi, Register n, Register m) {\n+    __ mul(prod_lo, n, m);\n+    __ umulh(prod_hi, n, m);\n+  }\n+  void wide_madd(Register sum_lo, Register sum_hi, Register n, Register m) {\n+    wide_mul(rscratch1, rscratch2, n, m);\n+    __ adds(sum_lo, sum_lo, rscratch1);\n+    __ adc(sum_hi, sum_hi, rscratch2);\n+  }\n+\n+  \/\/ Poly1305, RFC 7539\n+\n+  \/\/ See https:\/\/loup-vaillant.fr\/tutorials\/poly1305-design for a\n+  \/\/ description of the tricks used to simplify and accelerate this\n+  \/\/ computation.\n+\n+  address generate_poly1305_processBlocks() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"poly1305_processBlocks\");\n+    address start = __ pc();\n+    Label here;\n+    __ enter();\n+    RegSet callee_saved = RegSet::range(r19, r28);\n+    __ push(callee_saved, sp);\n+\n+    RegSetIterator<Register> regs = (RegSet::range(c_rarg0, r28) - r18_tls - rscratch1 - rscratch2).begin();\n+\n+    \/\/ Arguments\n+    const Register input_start = *regs, length = *++regs, acc_start = *++regs, r_start = *++regs;\n+\n+    \/\/ R_n is the 128-bit randomly-generated key, packed into two\n+    \/\/ registers.  The caller passes this key to us as long[5], with\n+    \/\/ BITS_PER_LIMB = 26.\n+    const Register R_0 = *++regs, R_1 = *++regs;\n+    pack_26(R_0, R_1, r_start);\n+\n+    \/\/ RR_n is (R_n >> 2) * 5\n+    const Register RR_0 = *++regs, RR_1 = *++regs;\n+    __ lsr(RR_0, R_0, 2);\n+    __ add(RR_0, RR_0, RR_0, Assembler::LSL, 2);\n+    __ lsr(RR_1, R_1, 2);\n+    __ add(RR_1, RR_1, RR_1, Assembler::LSL, 2);\n+\n+    \/\/ U_n is the current checksum\n+    const Register U_0 = *++regs, U_1 = *++regs, U_2 = *++regs;\n+    pack_26(U_0, U_1, U_2, acc_start);\n+\n+    static constexpr int BLOCK_LENGTH = 16;\n+    Label DONE, LOOP;\n+\n+    __ cmp(length, checked_cast<u1>(BLOCK_LENGTH));\n+    __ br(Assembler::LT, DONE); {\n+      __ bind(LOOP);\n+\n+      \/\/ S_n is to be the sum of U_n and the next block of data\n+      const Register S_0 = *++regs, S_1 = *++regs, S_2 = *++regs;\n+      __ ldp(S_0, S_1, __ post(input_start, 2 * wordSize));\n+      __ adds(S_0, U_0, S_0);\n+      __ adcs(S_1, U_1, S_1);\n+      __ adc(S_2, U_2, zr);\n+      __ add(S_2, S_2, 1);\n+\n+      const Register U_0HI = *++regs, U_1HI = *++regs;\n+\n+      \/\/ NB: this logic depends on some of the special properties of\n+      \/\/ Poly1305 keys. In particular, because we know that the top\n+      \/\/ four bits of R_0 and R_1 are zero, we can add together\n+      \/\/ partial products without any risk of needing to propagate a\n+      \/\/ carry out.\n+      wide_mul(U_0, U_0HI, S_0, R_0);  wide_madd(U_0, U_0HI, S_1, RR_1); wide_madd(U_0, U_0HI, S_2, RR_0);\n+      wide_mul(U_1, U_1HI, S_0, R_1);  wide_madd(U_1, U_1HI, S_1, R_0);  wide_madd(U_1, U_1HI, S_2, RR_1);\n+      __ andr(U_2, R_0, 3);\n+      __ mul(U_2, S_2, U_2);\n+\n+      \/\/ Recycle registers S_0, S_1, S_2\n+      regs = (regs.remaining() + S_0 + S_1 + S_2).begin();\n+\n+      \/\/ Partial reduction mod 2**130 - 5\n+      __ adds(U_1, U_0HI, U_1);\n+      __ adc(U_2, U_1HI, U_2);\n+      \/\/ Sum now in U_2:U_1:U_0.\n+      \/\/ Dead: U_0HI, U_1HI.\n+      regs = (regs.remaining() + U_0HI + U_1HI).begin();\n+\n+      \/\/ U_2:U_1:U_0 += (U_2 >> 2) * 5 in two steps\n+\n+      \/\/ First, U_2:U_1:U_0 += (U_2 >> 2)\n+      __ lsr(rscratch1, U_2, 2);\n+      __ andr(U_2, U_2, (u8)3);\n+      __ adds(U_0, U_0, rscratch1);\n+      __ adcs(U_1, U_1, zr);\n+      __ adc(U_2, U_2, zr);\n+      \/\/ Second, U_2:U_1:U_0 += (U_2 >> 2) << 2\n+      __ adds(U_0, U_0, rscratch1, Assembler::LSL, 2);\n+      __ adcs(U_1, U_1, zr);\n+      __ adc(U_2, U_2, zr);\n+\n+      __ sub(length, length, checked_cast<u1>(BLOCK_LENGTH));\n+      __ cmp(length, checked_cast<u1>(BLOCK_LENGTH));\n+      __ br(~ Assembler::LT, LOOP);\n+    }\n+\n+    \/\/ Further reduce modulo 2^130 - 5\n+    __ lsr(rscratch1, U_2, 2);\n+    __ add(rscratch1, rscratch1, rscratch1, Assembler::LSL, 2); \/\/ rscratch1 = U_2 * 5\n+    __ adds(U_0, U_0, rscratch1); \/\/ U_0 += U_2 * 5\n+    __ adcs(U_1, U_1, zr);\n+    __ andr(U_2, U_2, (u1)3);\n+    __ adc(U_2, U_2, zr);\n+\n+    \/\/ Unpack the sum into five 26-bit limbs and write to memory.\n+    __ ubfiz(rscratch1, U_0, 0, 26);\n+    __ ubfx(rscratch2, U_0, 26, 26);\n+    __ stp(rscratch1, rscratch2, Address(acc_start));\n+    __ ubfx(rscratch1, U_0, 52, 12);\n+    __ bfi(rscratch1, U_1, 12, 14);\n+    __ ubfx(rscratch2, U_1, 14, 26);\n+    __ stp(rscratch1, rscratch2, Address(acc_start, 2 * sizeof (jlong)));\n+    __ ubfx(rscratch1, U_1, 40, 24);\n+    __ bfi(rscratch1, U_2, 24, 3);\n+    __ str(rscratch1, Address(acc_start, 4 * sizeof (jlong)));\n+\n+    __ bind(DONE);\n+    __ pop(callee_saved, sp);\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8297,0 +8462,4 @@\n+    if (UsePoly1305Intrinsics) {\n+      StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":169,"deletions":0,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -3834,1 +3834,1 @@\n-  __ cmp(rscratch1, (u1)InlineKlassKind);\n+  __ cmp(rscratch1, (u1)Klass::InlineKlassKind);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -927,1 +927,1 @@\n-    \/\/ template code:\n+    \/\/ template code (for LM_LEGACY):\n@@ -941,1 +941,1 @@\n-    const Register displaced_header = R7_ARG5;\n+    const Register header           = R7_ARG5;\n@@ -949,1 +949,1 @@\n-    assert_different_registers(displaced_header, object_mark_addr, current_header, tmp);\n+    assert_different_registers(header, object_mark_addr, current_header, tmp);\n@@ -953,2 +953,2 @@\n-    \/\/ Load markWord from object into displaced_header.\n-    ld(displaced_header, oopDesc::mark_offset_in_bytes(), object);\n+    \/\/ Load markWord from object into header.\n+    ld(header, oopDesc::mark_offset_in_bytes(), object);\n@@ -963,2 +963,4 @@\n-    \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-    ori(displaced_header, displaced_header, markWord::unlocked_value);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      fast_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+      b(count_locking);\n+    } else if (LockingMode == LM_LEGACY) {\n@@ -966,4 +968,2 @@\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset +\n-                            BasicLock::displaced_header_offset_in_bytes();\n+      \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n+      ori(header, header, markWord::unlocked_value);\n@@ -971,2 +971,4 @@\n-    \/\/ Initialize the box (Must happen before we update the object mark!).\n-    std(displaced_header, mark_offset, monitor);\n+      \/\/ monitor->lock()->set_displaced_header(displaced_header);\n+      const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n+      const int mark_offset = lock_offset +\n+                              BasicLock::displaced_header_offset_in_bytes();\n@@ -974,1 +976,2 @@\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n+      \/\/ Initialize the box (Must happen before we update the object mark!).\n+      std(header, mark_offset, monitor);\n@@ -976,19 +979,1 @@\n-    \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-    addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-    \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-    \/\/ CmpxchgX sets CCR0 to cmpX(current, displaced).\n-    cmpxchgd(\/*flag=*\/CCR0,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/displaced_header, \/*exchange_value=*\/monitor,\n-             \/*where=*\/object_mark_addr,\n-             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-             noreg,\n-             &cas_failed,\n-             \/*check without membar and ldarx first*\/true);\n-\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object and we have now locked it.\n-    b(count_locking);\n-    bind(cas_failed);\n+      \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n@@ -996,3 +981,2 @@\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n+      \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n+      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n@@ -1000,1 +984,11 @@\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n+      \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n+      \/\/ CmpxchgX sets CCR0 to cmpX(current, displaced).\n+      cmpxchgd(\/*flag=*\/CCR0,\n+               \/*current_value=*\/current_header,\n+               \/*compare_value=*\/header, \/*exchange_value=*\/monitor,\n+               \/*where=*\/object_mark_addr,\n+               MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+               MacroAssembler::cmpxchgx_hint_acquire_lock(),\n+               noreg,\n+               &cas_failed,\n+               \/*check without membar and ldarx first*\/true);\n@@ -1002,3 +996,4 @@\n-    \/\/ Check if owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    sub(current_header, current_header, R1_SP);\n+      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+      \/\/ object and we have now locked it.\n+      b(count_locking);\n+      bind(cas_failed);\n@@ -1006,2 +1001,3 @@\n-    assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-    load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n+      \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n+      \/\/   \/\/ Simple recursive case.\n+      \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1009,6 +1005,16 @@\n-    and_(R0\/*==0?*\/, current_header, tmp);\n-    \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-    \/\/ header indicating it is a recursive lock.\n-    bne(CCR0, slow_case);\n-    std(R0\/*==0!*\/, mark_offset, monitor);\n-    b(count_locking);\n+      \/\/ We did not see an unlocked object so try the fast recursive case.\n+\n+      \/\/ Check if owner is self by comparing the value in the markWord of object\n+      \/\/ (current_header) with the stack pointer.\n+      sub(current_header, current_header, R1_SP);\n+\n+      assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n+      load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n+\n+      and_(R0\/*==0?*\/, current_header, tmp);\n+      \/\/ If condition is true we are done and hence we can store 0 in the displaced\n+      \/\/ header indicating it is a recursive lock.\n+      bne(CCR0, slow_case);\n+      std(R0\/*==0!*\/, mark_offset, monitor);\n+      b(count_locking);\n+    }\n@@ -1023,1 +1029,5 @@\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), object);\n+    } else {\n+      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n+    }\n@@ -1045,1 +1055,1 @@\n-    \/\/ template code:\n+    \/\/ template code (for LM_LEGACY):\n@@ -1059,1 +1069,1 @@\n-    const Register displaced_header = R8_ARG6;\n+    const Register header           = R8_ARG6;\n@@ -1066,1 +1076,1 @@\n-    assert_different_registers(object, displaced_header, object_mark_addr, current_header);\n+    assert_different_registers(object, header, object_mark_addr, current_header);\n@@ -1068,3 +1078,4 @@\n-    \/\/ Test first if we are in the fast recursive case.\n-    ld(displaced_header, in_bytes(BasicObjectLock::lock_offset()) +\n-                         BasicLock::displaced_header_offset_in_bytes(), monitor);\n+    if (LockingMode != LM_LIGHTWEIGHT) {\n+      \/\/ Test first if we are in the fast recursive case.\n+      ld(header, in_bytes(BasicObjectLock::lock_offset()) +\n+                 BasicLock::displaced_header_offset_in_bytes(), monitor);\n@@ -1072,3 +1083,4 @@\n-    \/\/ If the displaced header is zero, we have a recursive unlock.\n-    cmpdi(CCR0, displaced_header, 0);\n-    beq(CCR0, free_slot); \/\/ recursive unlock\n+      \/\/ If the displaced header is zero, we have a recursive unlock.\n+      cmpdi(CCR0, header, 0);\n+      beq(CCR0, free_slot); \/\/ recursive unlock\n+    }\n@@ -1084,14 +1096,35 @@\n-    addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-    \/\/ We have the displaced header in displaced_header. If the lock is still\n-    \/\/ lightweight, it will contain the monitor address and we'll store the\n-    \/\/ displaced header back into the object's mark word.\n-    \/\/ CmpxchgX sets CCR0 to cmpX(current, monitor).\n-    cmpxchgd(\/*flag=*\/CCR0,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/monitor, \/*exchange_value=*\/displaced_header,\n-             \/*where=*\/object_mark_addr,\n-             MacroAssembler::MemBarRel,\n-             MacroAssembler::cmpxchgx_hint_release_lock(),\n-             noreg,\n-             &slow_case);\n+\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n+      \/\/ must handle it.\n+      Register tmp = current_header;\n+      \/\/ First check for lock-stack underflow.\n+      lwz(tmp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n+      cmplwi(CCR0, tmp, (unsigned)LockStack::start_offset());\n+      ble(CCR0, slow_case);\n+      \/\/ Then check if the top of the lock-stack matches the unlocked object.\n+      addi(tmp, tmp, -oopSize);\n+      ldx(tmp, tmp, R16_thread);\n+      cmpd(CCR0, tmp, object);\n+      bne(CCR0, slow_case);\n+\n+      ld(header, oopDesc::mark_offset_in_bytes(), object);\n+      andi_(R0, header, markWord::monitor_value);\n+      bne(CCR0, slow_case);\n+      fast_unlock(object, header, slow_case);\n+    } else {\n+      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n+\n+      \/\/ We have the displaced header in displaced_header. If the lock is still\n+      \/\/ lightweight, it will contain the monitor address and we'll store the\n+      \/\/ displaced header back into the object's mark word.\n+      \/\/ CmpxchgX sets CCR0 to cmpX(current, monitor).\n+      cmpxchgd(\/*flag=*\/CCR0,\n+               \/*current_value=*\/current_header,\n+               \/*compare_value=*\/monitor, \/*exchange_value=*\/header,\n+               \/*where=*\/object_mark_addr,\n+               MacroAssembler::MemBarRel,\n+               MacroAssembler::cmpxchgx_hint_release_lock(),\n+               noreg,\n+               &slow_case);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":105,"deletions":72,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -3020,1 +3020,1 @@\n-    __ set_byte_if_not_zero(dest);\n+    __ setb(Assembler::notZero, dest);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-  __ jcc(Assembler::zero, error); \/\/ if klass is NULL it is broken\n+  __ jcc(Assembler::zero, error); \/\/ if klass is null it is broken\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    __ jcc(Assembler::equal, L_already_dirty);\n+    __ jccb(Assembler::equal, L_already_dirty);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-         \" last_sp != nullptr\");\n+         \" last_sp isn't null\");\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4617,0 +4617,119 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register scan_temp,\n+                                                  Register temp_reg2,\n+                                                  Register receiver,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  assert_different_registers(recv_klass, method_result, holder_klass, resolved_klass, scan_temp, temp_reg2, receiver);\n+  Register temp_itbl_klass = method_result;\n+  Register temp_reg = (temp_reg2 == noreg ? recv_klass : temp_reg2); \/\/ reuse recv_klass register on 32-bit x86 impl\n+\n+  int vtable_base = in_bytes(Klass::vtable_start_offset());\n+  int itentry_off = in_bytes(itableMethodEntry::method_offset());\n+  int scan_step = itableOffsetEntry::size() * wordSize;\n+  int vte_size = vtableEntry::size_in_bytes();\n+  int ioffset = in_bytes(itableOffsetEntry::interface_offset());\n+  int ooffset = in_bytes(itableOffsetEntry::offset_offset());\n+  Address::ScaleFactor times_vte_scale = Address::times_ptr;\n+  assert(vte_size == wordSize, \"adjust times_vte_scale\");\n+\n+  Label L_loop_scan_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  \/\/ temp_itbl_klass = recv_klass.itable[0]\n+  \/\/ scan_temp = &recv_klass.itable[0] + step\n+  movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  movptr(temp_itbl_klass, Address(recv_klass, scan_temp, times_vte_scale, vtable_base + ioffset));\n+  lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base + ioffset + scan_step));\n+  xorptr(temp_reg, temp_reg);\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  cmpptr(holder_klass, resolved_klass);\n+  jccb(Assembler::notEqual, L_loop_scan_resolved_entry);\n+  testptr(temp_itbl_klass, temp_itbl_klass);\n+  jccb(Assembler::zero, L_no_such_interface);\n+  cmpptr(holder_klass, temp_itbl_klass);\n+  jccb(Assembler::equal, L_holder_found);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     tmp = itable[index];\n+  \/\/     index += step;\n+  \/\/     if (tmp == holder_klass) {\n+  \/\/       goto L_holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (tmp != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  Label L_scan_holder;\n+  bind(L_scan_holder);\n+    movptr(temp_itbl_klass, Address(scan_temp, 0));\n+    addptr(scan_temp, scan_step);\n+    cmpptr(holder_klass, temp_itbl_klass);\n+    jccb(Assembler::equal, L_holder_found);\n+    testptr(temp_itbl_klass, temp_itbl_klass);\n+    jccb(Assembler::notZero, L_scan_holder);\n+\n+  jmpb(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   do {\n+  \/\/     tmp = itable[index];\n+  \/\/     index += step;\n+  \/\/     if (tmp == holder_klass) {\n+  \/\/        \/\/ Also check if we have met a holder klass\n+  \/\/        holder_tmp = itable[index-step-ioffset];\n+  \/\/     }\n+  \/\/     if (tmp == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (tmp != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  \/\/\n+  Label L_loop_scan_resolved;\n+  bind(L_loop_scan_resolved);\n+    movptr(temp_itbl_klass, Address(scan_temp, 0));\n+    addptr(scan_temp, scan_step);\n+    bind(L_loop_scan_resolved_entry);\n+    cmpptr(holder_klass, temp_itbl_klass);\n+    cmovl(Assembler::equal, temp_reg, Address(scan_temp, ooffset - ioffset - scan_step));\n+    cmpptr(resolved_klass, temp_itbl_klass);\n+    jccb(Assembler::equal, L_resolved_found);\n+    testptr(temp_itbl_klass, temp_itbl_klass);\n+    jccb(Assembler::notZero, L_loop_scan_resolved);\n+\n+  jmpb(L_no_such_interface);\n+\n+  Label L_ready;\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  testptr(temp_reg, temp_reg);\n+  jccb(Assembler::zero, L_scan_holder);\n+  jmpb(L_ready);\n+\n+  bind(L_holder_found);\n+  movl(temp_reg, Address(scan_temp, ooffset - ioffset - scan_step));\n+\n+  \/\/ Finally, temp_reg contains holder_klass vtable offset\n+  bind(L_ready);\n+  assert(itableMethodEntry::size() * wordSize == wordSize, \"adjust the scaling in the code below\");\n+  if (temp_reg2 == noreg) { \/\/ recv_klass register is clobbered for 32-bit x86 impl\n+    load_klass(scan_temp, receiver, noreg);\n+    movptr(method_result, Address(scan_temp, temp_reg, Address::times_1, itable_index * wordSize + itentry_off));\n+  } else {\n+    movptr(method_result, Address(recv_klass, temp_reg, Address::times_1, itable_index * wordSize + itentry_off));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -665,0 +665,10 @@\n+  void lookup_interface_method_stub(Register recv_klass,\n+                                    Register holder_klass,\n+                                    Register resolved_klass,\n+                                    Register method_result,\n+                                    Register scan_temp,\n+                                    Register temp_reg2,\n+                                    Register receiver,\n+                                    int itable_index,\n+                                    Label& L_no_such_interface);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4354,1 +4354,1 @@\n-  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InlineKlassKind);\n+  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), Klass::InlineKlassKind);\n@@ -4403,1 +4403,1 @@\n-  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InlineKlassKind);\n+  __ cmpb(Address(rcx, InstanceKlass::kind_offset()), Klass::InlineKlassKind);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  const Register resolved_klass_reg = rbx; \/\/ resolved interface klass (REFC)\n+  const Register resolved_klass_reg = r14; \/\/ resolved interface klass (REFC)\n@@ -182,0 +182,3 @@\n+  const Register temp_reg2          = r13;\n+  const Register method             = rbx;\n+  const Register icholder_reg       = rax;\n@@ -183,1 +186,0 @@\n-  const Register icholder_reg = rax;\n@@ -197,18 +199,9 @@\n-  \/\/ Destroys recv_klass_reg value.\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             recv_klass_reg, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t  typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n-  const Register method = rbx;\n-  __ load_klass(recv_klass_reg, j_rarg0, temp_reg);   \/\/ restore recv_klass_reg\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             method, temp_reg,\n-                             L_no_such_interface);\n+  __ lookup_interface_method_stub(recv_klass_reg, \/\/ input\n+                                  holder_klass_reg, \/\/ input\n+                                  resolved_klass_reg, \/\/ input\n+                                  method, \/\/ output\n+                                  temp_reg,\n+                                  temp_reg2,\n+                                  noreg,\n+                                  itable_index,\n+                                  L_no_such_interface);\n@@ -223,1 +216,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize + index_dependent_slop;\n+  const ptrdiff_t codesize = lookupSize + index_dependent_slop;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1507,6 +1507,0 @@\n-    case Op_CMoveVF:\n-    case Op_CMoveVD:\n-      if (UseAVX < 1) { \/\/ enabled for AVX only\n-        return false;\n-      }\n-      break;\n@@ -1743,5 +1737,0 @@\n-    case Op_CMoveVF:\n-      if (vlen != 8) {\n-        return false; \/\/ implementation limitation (only vcmov8F_reg is present)\n-      }\n-      break;\n@@ -1775,5 +1764,0 @@\n-    case Op_CMoveVD:\n-      if (vlen != 4) {\n-        return false; \/\/ implementation limitation (only vcmov4D_reg is present)\n-      }\n-      break;\n@@ -2825,1 +2809,1 @@\n-            __ set_byte_if_not_zero(toReg);\n+            __ setb(Assembler::notZero, toReg);\n@@ -2986,23 +2970,0 @@\n-\/\/ Comparison Code for FP conditional move\n-operand cmpOp_vcmppd() %{\n-  match(Bool);\n-\n-  predicate(n->as_Bool()->_test._test != BoolTest::overflow &&\n-            n->as_Bool()->_test._test != BoolTest::no_overflow);\n-  format %{ \"\" %}\n-  interface(COND_INTER) %{\n-    equal        (0x0, \"eq\");\n-    less         (0x1, \"lt\");\n-    less_equal   (0x2, \"le\");\n-    not_equal    (0xC, \"ne\");\n-    greater_equal(0xD, \"ge\");\n-    greater      (0xE, \"gt\");\n-    \/\/TODO cannot compile (adlc breaks) without two next lines with error:\n-    \/\/ x86_64.ad(13987) Syntax Error: :In operand cmpOp_vcmppd: Do not support this encode constant: ' %{\n-    \/\/ equal' for overflow.\n-    overflow     (0x20, \"o\");  \/\/ not really supported by the instruction\n-    no_overflow  (0x21, \"no\"); \/\/ not really supported by the instruction\n-  %}\n-%}\n-\n-\n@@ -6022,36 +5983,0 @@\n-instruct vcmov8F_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{\n-  predicate(Matcher::vector_length(n) == 8);\n-  match(Set dst (CMoveVF (Binary copnd cop) (Binary src1 src2)));\n-  effect(TEMP dst, USE src1, USE src2);\n-  format %{ \"cmpps.$copnd  $dst, $src1, $src2  ! vcmovevf, cond=$cop\\n\\t\"\n-            \"blendvps $dst,$src1,$src2,$dst ! vcmovevf\\n\\t\"\n-         %}\n-  ins_encode %{\n-    assert(UseAVX > 0, \"required\");\n-\n-    int vlen_enc = Assembler::AVX_256bit;\n-    int cond = (Assembler::Condition)($copnd$$cmpcode);\n-    __ vcmpps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vlen_enc);\n-    __ vblendvps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vcmov4D_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{\n-  predicate(Matcher::vector_length(n) == 4);\n-  match(Set dst (CMoveVD (Binary copnd cop) (Binary src1 src2)));\n-  effect(TEMP dst, USE src1, USE src2);\n-  format %{ \"cmppd.$copnd  $dst, $src1, $src2  ! vcmovevd, cond=$cop\\n\\t\"\n-            \"vblendvpd $dst,$src1,$src2,$dst ! vcmovevd\\n\\t\"\n-         %}\n-  ins_encode %{\n-    assert(UseAVX > 0, \"required\");\n-\n-    int vlen_enc = Assembler::AVX_256bit;\n-    int cond = (Assembler::Condition)($copnd$$cmpcode);\n-    __ vcmppd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vlen_enc);\n-    __ vblendvpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":76,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -8130,1 +8130,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8153,1 +8153,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8175,1 +8175,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8197,1 +8197,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8219,1 +8219,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -8240,1 +8240,1 @@\n-    __ sete($res$$Register);\n+    __ setb(Assembler::equal, $res$$Register);\n@@ -10663,34 +10663,0 @@\n-\/\/ Convert Int to Boolean\n-instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{ \"testl   $src, $src\\t# ci2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testl($src$$Register, $src$$Register);\n-    __ set_byte_if_not_zero($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Convert Pointer to Boolean\n-instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)\n-%{\n-  match(Set dst (Conv2B src));\n-  effect(KILL cr);\n-\n-  format %{ \"testq   $src, $src\\t# cp2b\\n\\t\"\n-            \"setnz   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $src$$Register);\n-    __ set_byte_if_not_zero($dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n@@ -10709,1 +10675,1 @@\n-    __ setl($dst$$Register);\n+    __ setb(Assembler::less, $dst$$Register);\n@@ -13077,1 +13043,1 @@\n-    __ setne($dst$$Register);\n+    __ setb(Assembler::notZero, $dst$$Register);\n@@ -13103,1 +13069,1 @@\n-    __ setne($dst$$Register);\n+    __ setb(Assembler::notZero, $dst$$Register);\n@@ -13129,1 +13095,1 @@\n-    __ setne($dst$$Register);\n+    __ setb(Assembler::notZero, $dst$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":10,"deletions":44,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -42,3 +42,3 @@\n-      _matrule              = NULL;\n-      _insencode            = NULL;\n-      _constant             = NULL;\n+      _matrule              = nullptr;\n+      _insencode            = nullptr;\n+      _constant             = nullptr;\n@@ -46,10 +46,10 @@\n-      _opcode               = NULL;\n-      _size                 = NULL;\n-      _attribs              = NULL;\n-      _predicate            = NULL;\n-      _exprule              = NULL;\n-      _rewrule              = NULL;\n-      _format               = NULL;\n-      _peephole             = NULL;\n-      _ins_pipe             = NULL;\n-      _uniq_idx             = NULL;\n+      _opcode               = nullptr;\n+      _size                 = nullptr;\n+      _attribs              = nullptr;\n+      _predicate            = nullptr;\n+      _exprule              = nullptr;\n+      _rewrule              = nullptr;\n+      _format               = nullptr;\n+      _peephole             = nullptr;\n+      _ins_pipe             = nullptr;\n+      _uniq_idx             = nullptr;\n@@ -58,2 +58,2 @@\n-      _cisc_spill_alternate = NULL;            \/\/ possible cisc replacement\n-      _cisc_reg_mask_name   = NULL;\n+      _cisc_spill_alternate = nullptr;            \/\/ possible cisc replacement\n+      _cisc_reg_mask_name   = nullptr;\n@@ -62,1 +62,1 @@\n-      _short_branch_form    = NULL;\n+      _short_branch_form    = nullptr;\n@@ -92,2 +92,2 @@\n-      _cisc_spill_alternate  = NULL;               \/\/ possible cisc replacement\n-      _cisc_reg_mask_name    = NULL;\n+      _cisc_spill_alternate  = nullptr;               \/\/ possible cisc replacement\n+      _cisc_reg_mask_name    = nullptr;\n@@ -96,1 +96,1 @@\n-      _short_branch_form     = NULL;\n+      _short_branch_form     = nullptr;\n@@ -101,1 +101,1 @@\n-     for (; (name = instr->_parameters.iter()) != NULL;)\n+     for (; (name = instr->_parameters.iter()) != nullptr;)\n@@ -117,1 +117,1 @@\n-  return (_matrule != NULL && _matrule->sets_result());\n+  return (_matrule != nullptr && _matrule->sets_result());\n@@ -122,1 +122,1 @@\n-  for( Component *comp; (comp = _components.iter()) != NULL; ) {\n+  for( Component *comp; (comp = _components.iter()) != nullptr; ) {\n@@ -136,1 +136,1 @@\n-    Component *comp = NULL;\n+    Component *comp = nullptr;\n@@ -138,1 +138,1 @@\n-    while ((comp = _components.iter()) != NULL) {\n+    while ((comp = _components.iter()) != nullptr) {\n@@ -152,1 +152,1 @@\n-  for( Component *comp; (comp = _components.iter()) != NULL; ) {\n+  for( Component *comp; (comp = _components.iter()) != nullptr; ) {\n@@ -163,1 +163,1 @@\n-  return ( _exprule != NULL );\n+  return ( _exprule != nullptr );\n@@ -178,1 +178,1 @@\n-  if( _peephole == NULL ) {\n+  if( _peephole == nullptr ) {\n@@ -268,1 +268,1 @@\n-  if (_matrule == NULL)  return 0;\n+  if (_matrule == nullptr)  return 0;\n@@ -276,1 +276,1 @@\n-  if (_insencode != NULL) {\n+  if (_insencode != nullptr) {\n@@ -278,1 +278,1 @@\n-    if (_insencode->encode_class_iter() == NULL) {\n+    if (_insencode->encode_class_iter() == nullptr) {\n@@ -282,1 +282,1 @@\n-  if (_size != NULL && strcmp(_size, \"0\") == 0) {\n+  if (_size != nullptr && strcmp(_size, \"0\") == 0) {\n@@ -289,1 +289,1 @@\n-  if (_ident != NULL &&\n+  if (_ident != nullptr &&\n@@ -295,1 +295,1 @@\n-  if (_matrule != NULL && _insencode != NULL) {\n+  if (_matrule != nullptr && _insencode != nullptr) {\n@@ -301,1 +301,1 @@\n-              (_ident == NULL ? \"NULL\" : _ident));\n+              (_ident == nullptr ? \"nullptr\" : _ident));\n@@ -312,1 +312,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -319,1 +319,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -326,1 +326,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -333,1 +333,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -340,1 +340,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -347,1 +347,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -354,1 +354,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -361,1 +361,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -369,1 +369,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -406,1 +406,1 @@\n-  if( _matrule == NULL ) return Form::invalid_type;\n+  if( _matrule == nullptr ) return Form::invalid_type;\n@@ -432,1 +432,1 @@\n-  if( _matrule == NULL ) return Form::none;\n+  if( _matrule == nullptr ) return Form::none;\n@@ -439,1 +439,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -446,1 +446,1 @@\n-  if( _matrule == NULL ) return Form::none;\n+  if( _matrule == nullptr ) return Form::none;\n@@ -453,1 +453,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -474,1 +474,1 @@\n-      if( op->constrained_reg_class() != NULL &&\n+      if( op->constrained_reg_class() != nullptr &&\n@@ -483,1 +483,1 @@\n-        } while( (comp = _components.iter()) != NULL);\n+        } while( (comp = _components.iter()) != nullptr);\n@@ -494,2 +494,2 @@\n-  const char *dummy  = NULL;\n-  const char *dummy2 = NULL;\n+  const char *dummy  = nullptr;\n+  const char *dummy2 = nullptr;\n@@ -500,1 +500,1 @@\n-  const char *result = NULL;\n+  const char *result = nullptr;\n@@ -513,3 +513,3 @@\n-  const char  *result   = NULL;\n-  const char  *name     = NULL;\n-  const char  *opType   = NULL;\n+  const char  *result   = nullptr;\n+  const char  *name     = nullptr;\n+  const char  *opType   = nullptr;\n@@ -536,1 +536,1 @@\n-      && _matrule->_rChild->_lChild == NULL\n+      && _matrule->_rChild->_lChild == nullptr\n@@ -586,1 +586,1 @@\n-          if( (type != NULL) && !strcmp(type, \"RegFlags\") )\n+          if( (type != nullptr) && !strcmp(type, \"RegFlags\") )\n@@ -623,1 +623,1 @@\n-  Component     *comp = NULL;\n+  Component     *comp = nullptr;\n@@ -627,1 +627,1 @@\n-  while( (comp = components.iter()) != NULL ) {\n+  while( (comp = components.iter()) != nullptr ) {\n@@ -654,4 +654,4 @@\n-  const char*    last_memory_DEF = NULL; \/\/ to test DEF\/USE pairing in asserts\n-  const char*    last_memory_USE = NULL;\n-  Component     *unique          = NULL;\n-  Component     *comp            = NULL;\n+  const char*    last_memory_DEF = nullptr; \/\/ to test DEF\/USE pairing in asserts\n+  const char*    last_memory_USE = nullptr;\n+  Component     *unique          = nullptr;\n+  Component     *comp            = nullptr;\n@@ -661,1 +661,1 @@\n-  while( (comp = components.iter()) != NULL ) {\n+  while( (comp = components.iter()) != nullptr ) {\n@@ -673,1 +673,1 @@\n-        if( last_memory_DEF != NULL ) {\n+        if( last_memory_DEF != nullptr ) {\n@@ -675,1 +675,1 @@\n-          last_memory_DEF = NULL;\n+          last_memory_DEF = nullptr;\n@@ -678,1 +678,1 @@\n-        if (last_memory_USE != NULL) {\n+        if (last_memory_USE != nullptr) {\n@@ -690,1 +690,1 @@\n-        assert(last_memory_DEF == NULL, \"unpaired memory DEF\");\n+        assert(last_memory_DEF == nullptr, \"unpaired memory DEF\");\n@@ -694,1 +694,1 @@\n-  assert(last_memory_DEF == NULL, \"unpaired memory DEF\");\n+  assert(last_memory_DEF == nullptr, \"unpaired memory DEF\");\n@@ -708,1 +708,1 @@\n-      assert(unique != NULL, \"\");\n+      assert(unique != nullptr, \"\");\n@@ -714,1 +714,1 @@\n-        \/\/ unique = NULL;\n+        \/\/ unique = nullptr;\n@@ -718,1 +718,1 @@\n-        unique = NULL;\n+        unique = nullptr;\n@@ -723,1 +723,1 @@\n-      unique = NULL;\n+      unique = nullptr;\n@@ -726,1 +726,1 @@\n-      assert(unique != NULL, \"\");\n+      assert(unique != nullptr, \"\");\n@@ -729,1 +729,1 @@\n-      unique = NULL;\n+      unique = nullptr;\n@@ -734,1 +734,1 @@\n-    if( unique == NULL ) {\n+    if( unique == nullptr ) {\n@@ -809,1 +809,1 @@\n-\/\/ Access instr_cost attribute or return NULL.\n+\/\/ Access instr_cost attribute or return null.\n@@ -811,1 +811,1 @@\n-  for (Attribute* cur = _attribs; cur != NULL; cur = (Attribute*)cur->_next) {\n+  for (Attribute* cur = _attribs; cur != nullptr; cur = (Attribute*)cur->_next) {\n@@ -816,1 +816,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -846,1 +846,1 @@\n-  return (_components.at(i) != NULL) ? _components.at(i)->_name : \"\";\n+  return (_components.at(i) != nullptr) ? _components.at(i)->_name : \"\";\n@@ -879,1 +879,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -940,2 +940,2 @@\n-  const char *kill_name = NULL;\n-  for (_parameters.reset(); (name = _parameters.iter()) != NULL;) {\n+  const char *kill_name = nullptr;\n+  for (_parameters.reset(); (name = _parameters.iter()) != nullptr;) {\n@@ -943,1 +943,1 @@\n-    assert(opForm != NULL, \"sanity\");\n+    assert(opForm != nullptr, \"sanity\");\n@@ -945,1 +945,1 @@\n-    Effect* e = NULL;\n+    Effect* e = nullptr;\n@@ -948,1 +948,1 @@\n-      e = form ? form->is_effect() : NULL;\n+      e = form ? form->is_effect() : nullptr;\n@@ -951,1 +951,1 @@\n-    if (e != NULL) {\n+    if (e != nullptr) {\n@@ -958,1 +958,1 @@\n-      if (kill_name != NULL &&\n+      if (kill_name != nullptr &&\n@@ -961,1 +961,1 @@\n-        assert(kill != NULL, \"sanity\");\n+        assert(kill != nullptr, \"sanity\");\n@@ -970,1 +970,1 @@\n-    if ( component  == NULL ) {\n+    if ( component  == nullptr ) {\n@@ -985,1 +985,1 @@\n-        \/\/ if (_matrule != NULL && !expands()) {\n+        \/\/ if (_matrule != nullptr && !expands()) {\n@@ -1020,1 +1020,1 @@\n-  if (_matrule == NULL && has_temp) {\n+  if (_matrule == nullptr && has_temp) {\n@@ -1056,1 +1056,1 @@\n-  if ( _matrule != NULL ) {\n+  if ( _matrule != nullptr ) {\n@@ -1058,3 +1058,3 @@\n-    const char  *result   = NULL;\n-    const char  *name     = NULL;\n-    const char  *opType   = NULL;\n+    const char  *result   = nullptr;\n+    const char  *name     = nullptr;\n+    const char  *opType   = nullptr;\n@@ -1075,1 +1075,1 @@\n-  while ( (comp = _components.iter()) != NULL ) {\n+  while ( (comp = _components.iter()) != nullptr ) {\n@@ -1080,1 +1080,1 @@\n-    if ( opc && (oper == NULL) ) {\n+    if ( opc && (oper == nullptr) ) {\n@@ -1111,1 +1111,1 @@\n-  if (comp != NULL && comp->isa(Component::DEF)) {\n+  if (comp != nullptr && comp->isa(Component::DEF)) {\n@@ -1122,1 +1122,1 @@\n-\/\/ Return NULL if there is no right hand side\n+\/\/ Return null if there is no right hand side\n@@ -1124,1 +1124,1 @@\n-  if( _matrule == NULL ) return NULL;\n+  if( _matrule == nullptr ) return nullptr;\n@@ -1130,1 +1130,1 @@\n-  if( _matrule == NULL ) return NULL;\n+  if( _matrule == nullptr ) return nullptr;\n@@ -1185,1 +1185,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1192,1 +1192,1 @@\n-  if( pred1 == NULL && pred2 == NULL ) {\n+  if( pred1 == nullptr && pred2 == nullptr ) {\n@@ -1196,1 +1196,1 @@\n-  if( pred1 != NULL && pred2 != NULL ) {\n+  if( pred1 != nullptr && pred2 != nullptr ) {\n@@ -1208,1 +1208,1 @@\n-  assert( _matrule != NULL && instr->_matrule != NULL, \"must have match rules\");\n+  assert( _matrule != nullptr && instr->_matrule != nullptr, \"must have match rules\");\n@@ -1213,4 +1213,4 @@\n-  char       *result             = NULL;\n-  char       *result2            = NULL;\n-  const char *op_name            = NULL;\n-  const char *reg_type           = NULL;\n+  char       *result             = nullptr;\n+  char       *result2            = nullptr;\n+  const char *op_name            = nullptr;\n+  const char *reg_type           = nullptr;\n@@ -1219,1 +1219,1 @@\n-  if( (cisc_spill_operand != Not_cisc_spillable) && (op_name != NULL) && equivalent_predicates(this, instr) ) {\n+  if( (cisc_spill_operand != Not_cisc_spillable) && (op_name != nullptr) && equivalent_predicates(this, instr) ) {\n@@ -1234,1 +1234,1 @@\n-      assert( oper != NULL, \"cisc-spilling non operand\");\n+      assert( oper != nullptr, \"cisc-spilling non operand\");\n@@ -1254,1 +1254,1 @@\n-  if (_matrule != NULL &&\n+  if (_matrule != nullptr &&\n@@ -1257,2 +1257,2 @@\n-      reduce_result() != NULL &&\n-      strstr(_ident, \"restoreMask\") == NULL && \/\/ Don't match side effects\n+      reduce_result() != nullptr &&\n+      strstr(_ident, \"restoreMask\") == nullptr && \/\/ Don't match side effects\n@@ -1275,1 +1275,1 @@\n-      while ((comp = _components.iter()) != NULL) {\n+      while ((comp = _components.iter()) != nullptr) {\n@@ -1277,1 +1277,1 @@\n-        if (short_comp == NULL ||\n+        if (short_comp == nullptr ||\n@@ -1284,1 +1284,1 @@\n-      if (short_branch->_components.iter() != NULL)\n+      if (short_branch->_components.iter() != nullptr)\n@@ -1321,1 +1321,1 @@\n-  if (form == NULL) {\n+  if (form == nullptr) {\n@@ -1341,1 +1341,1 @@\n-    if (oper != NULL && oper->is_bound_register()) {\n+    if (oper != nullptr && oper->is_bound_register()) {\n@@ -1359,1 +1359,1 @@\n-  uint* uniq_idx = NULL;\n+  uint* uniq_idx = nullptr;\n@@ -1377,1 +1377,1 @@\n-  if (nopnds > 0 && _matrule != NULL && _exprule == NULL) {\n+  if (nopnds > 0 && _matrule != nullptr && _exprule == nullptr) {\n@@ -1383,1 +1383,1 @@\n-    while ((name = _parameters.iter()) != NULL) {\n+    while ((name = _parameters.iter()) != nullptr) {\n@@ -1388,1 +1388,1 @@\n-      Component *comp = NULL;\n+      Component *comp = nullptr;\n@@ -1394,1 +1394,1 @@\n-      for (; (comp = _components.iter()) != NULL; ++position) {\n+      for (; (comp = _components.iter()) != nullptr; ++position) {\n@@ -1518,1 +1518,1 @@\n-  if (mnode != NULL) mnode->count_instr_names(names);\n+  if (mnode != nullptr) mnode->count_instr_names(names);\n@@ -1551,1 +1551,1 @@\n-  if( s == buf ) s = NULL;\n+  if( s == buf ) s = nullptr;\n@@ -1577,1 +1577,1 @@\n-  assert( className != NULL, \"Must provide a defined encoding name\");\n+  assert( className != nullptr, \"Must provide a defined encoding name\");\n@@ -1585,1 +1585,1 @@\n-  if( className == NULL ) return NULL;\n+  if( className == nullptr ) return nullptr;\n@@ -1588,1 +1588,1 @@\n-  assert( encClass != NULL, \"Encode Class is missing.\");\n+  assert( encClass != nullptr, \"Encode Class is missing.\");\n@@ -1591,1 +1591,1 @@\n-  assert( code != NULL, \"Found an empty encode class body.\");\n+  assert( code != nullptr, \"Found an empty encode class body.\");\n@@ -1598,1 +1598,1 @@\n-  assert( className != NULL, \"Encode class name must be non NULL.\");\n+  assert( className != nullptr, \"Encode class name must be non null.\");\n@@ -1611,1 +1611,1 @@\n-  for (_eclasses.reset(); (name = _eclasses.iter()) != NULL;) {\n+  for (_eclasses.reset(); (name = _eclasses.iter()) != nullptr;) {\n@@ -1649,1 +1649,1 @@\n-  const char *name     = NULL;\n+  const char *name     = nullptr;\n@@ -1652,1 +1652,1 @@\n-  while ( (name = _parameter_name.iter()) != NULL ) {\n+  while ( (name = _parameter_name.iter()) != nullptr ) {\n@@ -1683,1 +1683,1 @@\n-  for ( ; (type != NULL) && (name != NULL);\n+  for ( ; (type != nullptr) && (name != nullptr);\n@@ -1693,1 +1693,1 @@\n-  while ( (code = _code.iter()) != NULL ) {\n+  while ( (code = _code.iter()) != nullptr ) {\n@@ -1729,2 +1729,2 @@\n-  const char *description = NULL;\n-  const char *value       = NULL;\n+  const char *description = nullptr;\n+  const char *value       = nullptr;\n@@ -1736,1 +1736,1 @@\n-    if( _primary   != NULL)  { value = _primary;     }\n+    if( _primary   != nullptr)  { value = _primary;     }\n@@ -1740,1 +1740,1 @@\n-    if( _secondary != NULL ) { value = _secondary;   }\n+    if( _secondary != nullptr ) { value = _secondary;   }\n@@ -1744,1 +1744,1 @@\n-    if( _tertiary  != NULL ) { value = _tertiary;    }\n+    if( _tertiary  != nullptr ) { value = _tertiary;    }\n@@ -1751,1 +1751,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -1754,1 +1754,1 @@\n-  return value != NULL;\n+  return value != nullptr;\n@@ -1763,3 +1763,3 @@\n-  if (_primary   != NULL) fprintf(fp,\"Primary   opcode: %s\\n\", _primary);\n-  if (_secondary != NULL) fprintf(fp,\"Secondary opcode: %s\\n\", _secondary);\n-  if (_tertiary  != NULL) fprintf(fp,\"Tertiary  opcode: %s\\n\", _tertiary);\n+  if (_primary   != nullptr) fprintf(fp,\"Primary   opcode: %s\\n\", _primary);\n+  if (_secondary != nullptr) fprintf(fp,\"Secondary opcode: %s\\n\", _secondary);\n+  if (_tertiary  != nullptr) fprintf(fp,\"Tertiary  opcode: %s\\n\", _tertiary);\n@@ -1776,1 +1776,1 @@\n-  assert( encoding != NULL, \"Must provide name for encoding\");\n+  assert( encoding != nullptr, \"Must provide name for encoding\");\n@@ -1792,1 +1792,1 @@\n-  return  ( encode_class != NULL ? encode_class->name() : NULL );\n+  return  ( encode_class != nullptr ? encode_class->name() : nullptr );\n@@ -1797,1 +1797,1 @@\n-  assert( params != NULL, \"Internal Error\");\n+  assert( params != nullptr, \"Internal Error\");\n@@ -1801,1 +1801,1 @@\n-  return ( param != NULL && *param == '$') ? (param+1) : param;\n+  return ( param != nullptr && *param == '$') ? (param+1) : param;\n@@ -1810,2 +1810,2 @@\n-  NameAndList *encoding  = NULL;\n-  const char  *parameter = NULL;\n+  NameAndList *encoding  = nullptr;\n+  const char  *parameter = nullptr;\n@@ -1924,2 +1924,2 @@\n-  NameAndList *expand_instr = NULL;\n-  const char *opid = NULL;\n+  NameAndList *expand_instr = nullptr;\n+  const char *opid = nullptr;\n@@ -1930,1 +1930,1 @@\n-  for(reset_instructions(); (expand_instr = iter_instructions()) != NULL; ) {\n+  for(reset_instructions(); (expand_instr = iter_instructions()) != nullptr; ) {\n@@ -1934,1 +1934,1 @@\n-    for( expand_instr->reset(); (opid = expand_instr->iter()) != NULL; ) {\n+    for( expand_instr->reset(); (opid = expand_instr->iter()) != nullptr; ) {\n@@ -1995,1 +1995,1 @@\n-  while( (op_name = op_list.iter()) != NULL ) {\n+  while( (op_name = op_list.iter()) != nullptr ) {\n@@ -2015,1 +2015,1 @@\n-  while( (op_name = op_list.iter()) != NULL ) {\n+  while( (op_name = op_list.iter()) != nullptr ) {\n@@ -2033,1 +2033,1 @@\n-  for(_oplst.reset(); (name = _oplst.iter()) != NULL;) {\n+  for(_oplst.reset(); (name = _oplst.iter()) != nullptr;) {\n@@ -2047,7 +2047,7 @@\n-      _matrule   = NULL;\n-      _interface = NULL;\n-      _attribs   = NULL;\n-      _predicate = NULL;\n-      _constraint= NULL;\n-      _construct = NULL;\n-      _format    = NULL;\n+      _matrule   = nullptr;\n+      _interface = nullptr;\n+      _attribs   = nullptr;\n+      _predicate = nullptr;\n+      _constraint= nullptr;\n+      _construct = nullptr;\n+      _format    = nullptr;\n@@ -2060,7 +2060,7 @@\n-      _matrule   = NULL;\n-      _interface = NULL;\n-      _attribs   = NULL;\n-      _predicate = NULL;\n-      _constraint= NULL;\n-      _construct = NULL;\n-      _format    = NULL;\n+      _matrule   = nullptr;\n+      _interface = nullptr;\n+      _attribs   = nullptr;\n+      _predicate = nullptr;\n+      _constraint= nullptr;\n+      _construct = nullptr;\n+      _format    = nullptr;\n@@ -2081,1 +2081,1 @@\n-  if( _interface == NULL )  return Form::no_interface;\n+  if( _interface == nullptr )  return Form::no_interface;\n@@ -2088,1 +2088,1 @@\n-  if( _constraint == NULL )  return false;\n+  if( _constraint == nullptr )  return false;\n@@ -2093,1 +2093,1 @@\n-\/\/ Access op_cost attribute or return NULL.\n+\/\/ Access op_cost attribute or return null.\n@@ -2095,1 +2095,1 @@\n-  for (Attribute* cur = _attribs; cur != NULL; cur = (Attribute*)cur->_next) {\n+  for (Attribute* cur = _attribs; cur != nullptr; cur = (Attribute*)cur->_next) {\n@@ -2100,1 +2100,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2146,1 +2146,1 @@\n-    if( constrained_reg_class() != NULL ) {\n+    if( constrained_reg_class() != nullptr ) {\n@@ -2150,1 +2150,1 @@\n-          && (_matrule->_lChild == NULL) && (_matrule->_rChild == NULL) ) {\n+          && (_matrule->_lChild == nullptr) && (_matrule->_rChild == nullptr) ) {\n@@ -2152,1 +2152,1 @@\n-        OperandForm *oper = form ? form->is_operand() : NULL;\n+        OperandForm *oper = form ? form->is_operand() : nullptr;\n@@ -2179,1 +2179,1 @@\n-  if( _matrule == NULL ) return false;\n+  if( _matrule == nullptr ) return false;\n@@ -2187,1 +2187,1 @@\n-  if( _ident != NULL ) {\n+  if( _ident != nullptr ) {\n@@ -2194,1 +2194,1 @@\n-  assert((data_type == none) || (_matrule == NULL), \"No match-rule for stackSlotX\");\n+  assert((data_type == none) || (_matrule == nullptr), \"No match-rule for stackSlotX\");\n@@ -2202,1 +2202,1 @@\n-  const char *type = NULL;\n+  const char *type = nullptr;\n@@ -2204,1 +2204,1 @@\n-  else if( _matrule == NULL ) {\n+  else if( _matrule == nullptr ) {\n@@ -2208,1 +2208,1 @@\n-    if (rc_name == NULL) return NULL;\n+    if (rc_name == nullptr) return nullptr;\n@@ -2213,1 +2213,1 @@\n-      assert( reg_class != NULL, \"Register class is not defined\");\n+      assert( reg_class != nullptr, \"Register class is not defined\");\n@@ -2218,2 +2218,2 @@\n-      assert( reg_def != NULL, \"No entries in register class\");\n-      assert( reg_def->_idealtype != NULL, \"Did not define ideal type for register\");\n+      assert( reg_def != nullptr, \"No entries in register class\");\n+      assert( reg_def->_idealtype != nullptr, \"Did not define ideal type for register\");\n@@ -2227,1 +2227,1 @@\n-  else if( _matrule->_lChild == NULL && _matrule->_rChild == NULL ) {\n+  else if( _matrule->_lChild == nullptr && _matrule->_rChild == nullptr ) {\n@@ -2245,2 +2245,2 @@\n-  const char  *ideal_type = NULL;\n-  const char  *value      = NULL;\n+  const char  *ideal_type = nullptr;\n+  const char  *value      = nullptr;\n@@ -2261,1 +2261,1 @@\n-  if (_interface && !_interface->is_RegInterface()) return NULL;\n+  if (_interface && !_interface->is_RegInterface()) return nullptr;\n@@ -2268,1 +2268,1 @@\n-  if (reg_class == NULL) {\n+  if (reg_class == nullptr) {\n@@ -2273,1 +2273,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -2306,1 +2306,1 @@\n-  const char *reg_class  = NULL;\n+  const char *reg_class  = nullptr;\n@@ -2321,1 +2321,1 @@\n-  const char *reg_class = NULL; \/\/ \"RegMask::Empty\";\n+  const char *reg_class = nullptr; \/\/ \"RegMask::Empty\";\n@@ -2323,1 +2323,1 @@\n-  if((_matrule == NULL) || (_matrule->is_chain_rule(globals))) {\n+  if((_matrule == nullptr) || (_matrule->is_chain_rule(globals))) {\n@@ -2327,3 +2327,3 @@\n-  const char *result   = NULL;\n-  const char *name     = NULL;\n-  const char *type     = NULL;\n+  const char *result   = nullptr;\n+  const char *name     = nullptr;\n+  const char *type     = nullptr;\n@@ -2336,1 +2336,1 @@\n-    OperandForm *oper = form ? form->is_operand() : NULL;\n+    OperandForm *oper = form ? form->is_operand() : nullptr;\n@@ -2349,1 +2349,1 @@\n-    if( reg_class == NULL)    ++leaf;\n+    if( reg_class == nullptr)    ++leaf;\n@@ -2352,1 +2352,1 @@\n-    \/\/ May iterate through all base operands if reg_class for 'leaf' is NULL\n+    \/\/ May iterate through all base operands if reg_class for 'leaf' is null\n@@ -2365,1 +2365,1 @@\n-  for (_parameters.reset(); (name = _parameters.iter()) != NULL;) {\n+  for (_parameters.reset(); (name = _parameters.iter()) != nullptr;) {\n@@ -2367,1 +2367,1 @@\n-    assert(opForm != NULL, \"sanity\");\n+    assert(opForm != nullptr, \"sanity\");\n@@ -2389,1 +2389,1 @@\n-  while( (comp = _components.iter()) != NULL  && (comp != last) ) {\n+  while( (comp = _components.iter()) != nullptr  && (comp != last) ) {\n@@ -2397,2 +2397,2 @@\n-    assert( form != NULL, \"Component's type not found\");\n-    OperandForm *oper = form ? form->is_operand() : NULL;\n+    assert( form != nullptr, \"Component's type not found\");\n+    OperandForm *oper = form ? form->is_operand() : nullptr;\n@@ -2427,1 +2427,1 @@\n-  while( (comp = _components.iter()) != NULL\n+  while( (comp = _components.iter()) != nullptr\n@@ -2436,2 +2436,2 @@\n-    assert( form != NULL, \"Component's type not found\");\n-    OperandForm *oper = form ? form->is_operand() : NULL;\n+    assert( form != nullptr, \"Component's type not found\");\n+    OperandForm *oper = form ? form->is_operand() : nullptr;\n@@ -2453,1 +2453,1 @@\n-\/\/ Return NULL if there is no right hand side\n+\/\/ Return null if there is no right hand side\n@@ -2455,1 +2455,1 @@\n-  return  ( _matrule ? _matrule->reduce_right(globals) : NULL );\n+  return  ( _matrule ? _matrule->reduce_right(globals) : nullptr );\n@@ -2460,1 +2460,1 @@\n-  return  ( _matrule ? _matrule->reduce_left(globals) : NULL );\n+  return  ( _matrule ? _matrule->reduce_left(globals) : nullptr );\n@@ -2469,1 +2469,1 @@\n-  if ( this->_interface == NULL ) return;\n+  if ( this->_interface == nullptr ) return;\n@@ -2471,1 +2471,1 @@\n-  if ( mem_interface == NULL )    return;\n+  if ( mem_interface == nullptr )    return;\n@@ -2478,1 +2478,1 @@\n-  assert( comp != NULL, \"Replacement variable not found in components\");\n+  assert( comp != nullptr, \"Replacement variable not found in components\");\n@@ -2482,1 +2482,1 @@\n-  assert( form != NULL, \"Replacement variable's type not found\");\n+  assert( form != nullptr, \"Replacement variable's type not found\");\n@@ -2567,1 +2567,1 @@\n-\/\/ Return the operand form corresponding to the given index, else NULL.\n+\/\/ Return the operand form corresponding to the given index, else null.\n@@ -2578,1 +2578,1 @@\n-    if ((comp = _components.iter()) == NULL) {\n+    if ((comp = _components.iter()) == nullptr) {\n@@ -2584,1 +2584,1 @@\n-    } \/\/ end if NULL\n+    } \/\/ end if null\n@@ -2598,1 +2598,1 @@\n-      } while((comp = _components.iter()) != NULL);\n+      } while((comp = _components.iter()) != nullptr);\n@@ -2603,1 +2603,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2615,1 +2615,1 @@\n-  if ( _matrule == NULL )    return Form::none;\n+  if ( _matrule == nullptr )    return Form::none;\n@@ -2681,1 +2681,1 @@\n-  assert((_func != NULL && _arg != NULL),\"missing constraint function or arg\");\n+  assert((_func != nullptr && _arg != nullptr),\"missing constraint function or arg\");\n@@ -2717,1 +2717,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2721,1 +2721,1 @@\n-  if ( strcmp(_name,\"MEMORY_INTER\") != 0 )  return NULL;\n+  if ( strcmp(_name,\"MEMORY_INTER\") != 0 )  return nullptr;\n@@ -2725,1 +2725,1 @@\n-  if ( strcmp(_name,\"CONST_INTER\") != 0 )  return NULL;\n+  if ( strcmp(_name,\"CONST_INTER\") != 0 )  return nullptr;\n@@ -2729,1 +2729,1 @@\n-  if ( strcmp(_name,\"COND_INTER\") != 0 )  return NULL;\n+  if ( strcmp(_name,\"COND_INTER\") != 0 )  return nullptr;\n@@ -2788,4 +2788,4 @@\n-  if ( _base  != NULL ) fprintf(fp,\"  base  == %s\\n\", _base);\n-  if ( _index != NULL ) fprintf(fp,\"  index == %s\\n\", _index);\n-  if ( _scale != NULL ) fprintf(fp,\"  scale == %s\\n\", _scale);\n-  if ( _disp  != NULL ) fprintf(fp,\"  disp  == %s\\n\", _disp);\n+  if ( _base  != nullptr ) fprintf(fp,\"  base  == %s\\n\", _base);\n+  if ( _index != nullptr ) fprintf(fp,\"  index == %s\\n\", _index);\n+  if ( _scale != nullptr ) fprintf(fp,\"  scale == %s\\n\", _scale);\n+  if ( _disp  != nullptr ) fprintf(fp,\"  disp  == %s\\n\", _disp);\n@@ -2825,8 +2825,8 @@\n-  if ( _equal  != NULL )     fprintf(fp,\" equal        == %s\\n\", _equal);\n-  if ( _not_equal  != NULL ) fprintf(fp,\" not_equal    == %s\\n\", _not_equal);\n-  if ( _less  != NULL )      fprintf(fp,\" less         == %s\\n\", _less);\n-  if ( _greater_equal  != NULL ) fprintf(fp,\" greater_equal    == %s\\n\", _greater_equal);\n-  if ( _less_equal  != NULL ) fprintf(fp,\" less_equal   == %s\\n\", _less_equal);\n-  if ( _greater  != NULL )    fprintf(fp,\" greater      == %s\\n\", _greater);\n-  if ( _overflow != NULL )    fprintf(fp,\" overflow     == %s\\n\", _overflow);\n-  if ( _no_overflow != NULL ) fprintf(fp,\" no_overflow  == %s\\n\", _no_overflow);\n+  if ( _equal  != nullptr )     fprintf(fp,\" equal        == %s\\n\", _equal);\n+  if ( _not_equal  != nullptr ) fprintf(fp,\" not_equal    == %s\\n\", _not_equal);\n+  if ( _less  != nullptr )      fprintf(fp,\" less         == %s\\n\", _less);\n+  if ( _greater_equal  != nullptr ) fprintf(fp,\" greater_equal    == %s\\n\", _greater_equal);\n+  if ( _less_equal  != nullptr ) fprintf(fp,\" less_equal   == %s\\n\", _less_equal);\n+  if ( _greater  != nullptr )    fprintf(fp,\" greater      == %s\\n\", _greater);\n+  if ( _overflow != nullptr )    fprintf(fp,\" overflow     == %s\\n\", _overflow);\n+  if ( _no_overflow != nullptr ) fprintf(fp,\" no_overflow  == %s\\n\", _no_overflow);\n@@ -2922,1 +2922,1 @@\n-  if (frm == NULL) return NULL;\n+  if (frm == nullptr) return nullptr;\n@@ -2924,1 +2924,1 @@\n-  if (op == NULL) return NULL;\n+  if (op == nullptr) return nullptr;\n@@ -2948,1 +2948,1 @@\n-  \/\/ for (reset(); (component = iter()) != NULL;) {\n+  \/\/ for (reset(); (component = iter()) != nullptr;) {\n@@ -2966,1 +2966,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2971,1 +2971,1 @@\n-  if ( comp == NULL ) {\n+  if ( comp == nullptr ) {\n@@ -2987,1 +2987,1 @@\n-  if (position >= count()) return NULL;\n+  if (position >= count()) return nullptr;\n@@ -2990,2 +2990,2 @@\n-  Component *component = NULL;\n-  for (reset(); (component = iter()) != NULL;) {\n+  Component *component = nullptr;\n+  for (reset(); (component = iter()) != nullptr;) {\n@@ -2998,1 +2998,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3004,1 +3004,1 @@\n-  for( Component *comp = NULL; ((comp = iter()) != NULL); ) {\n+  for( Component *comp = nullptr; ((comp = iter()) != nullptr); ) {\n@@ -3008,1 +3008,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3019,2 +3019,2 @@\n-  Component *component  = NULL;\n-  for( reset(); (component = iter()) != NULL; ++position ) {\n+  Component *component  = nullptr;\n+  for( reset(); (component = iter()) != nullptr; ++position ) {\n@@ -3037,3 +3037,3 @@\n-  Component* preceding_non_use = NULL;\n-  Component* first_def = NULL;\n-  for (reset(); (component = iter()) != NULL; ++position) {\n+  Component* preceding_non_use = nullptr;\n+  Component* first_def = nullptr;\n+  for (reset(); (component = iter()) != nullptr; ++position) {\n@@ -3083,1 +3083,1 @@\n-      preceding_non_use = NULL;\n+      preceding_non_use = nullptr;\n@@ -3094,1 +3094,1 @@\n-  for (reset(); (component = iter()) != NULL; ++position) {\n+  for (reset(); (component = iter()) != nullptr; ++position) {\n@@ -3124,1 +3124,1 @@\n-  for( Component *comp; (comp = iter()) != NULL; ++position) {\n+  for( Component *comp; (comp = iter()) != nullptr; ++position) {\n@@ -3147,1 +3147,1 @@\n-  for( Component *comp; (comp = iter()) != NULL; ++position) {\n+  for( Component *comp; (comp = iter()) != nullptr; ++position) {\n@@ -3172,1 +3172,1 @@\n-  for (reset(); (component = iter()) != NULL;) {\n+  for (reset(); (component = iter()) != nullptr;) {\n@@ -3203,1 +3203,1 @@\n-    _lChild = NULL;\n+    _lChild = nullptr;\n@@ -3208,1 +3208,1 @@\n-    _rChild = NULL;\n+    _rChild = nullptr;\n@@ -3219,2 +3219,2 @@\n-  if ( (_lChild != NULL) && (_lChild->find_type(type, position)) ) return true;\n-  if ( (_rChild != NULL) && (_rChild->find_type(type, position)) ) return true;\n+  if ( (_lChild != nullptr) && (_lChild->find_type(type, position)) ) return true;\n+  if ( (_rChild != nullptr) && (_rChild->find_type(type, position)) ) return true;\n@@ -3237,1 +3237,1 @@\n-  assert (_name != NULL, \"MatchNode::build_components encountered empty node\\n\");\n+  assert (_name != nullptr, \"MatchNode::build_components encountered empty node\\n\");\n@@ -3239,1 +3239,1 @@\n-  if (_lChild==NULL && _rChild==NULL) {\n+  if (_lChild==nullptr && _rChild==nullptr) {\n@@ -3242,1 +3242,1 @@\n-    if( f != NULL ) {\n+    if( f != nullptr ) {\n@@ -3266,1 +3266,1 @@\n-  assert (_name != NULL, \"MatchNode::base_operand encountered empty node\\n\");\n+  assert (_name != nullptr, \"MatchNode::base_operand encountered empty node\\n\");\n@@ -3268,1 +3268,1 @@\n-  if (_lChild==NULL && _rChild==NULL) {\n+  if (_lChild==nullptr && _rChild==nullptr) {\n@@ -3283,1 +3283,1 @@\n-    MatchNode *matchNode = NULL;\n+    MatchNode *matchNode = nullptr;\n@@ -3373,2 +3373,2 @@\n-  \/\/ If there is no right reduction, return NULL.\n-  const char      *rightStr    = NULL;\n+  \/\/ If there is no right reduction, return null.\n+  const char      *rightStr    = nullptr;\n@@ -3386,1 +3386,1 @@\n-  \/\/ Else, May be simple chain rule: (Set dst operand_form), rightStr=NULL;\n+  \/\/ Else, May be simple chain rule: (Set dst operand_form), rightStr=nullptr;\n@@ -3391,2 +3391,2 @@\n-  \/\/ If there is no left reduction, return NULL.\n-  const char  *leftStr  = NULL;\n+  \/\/ If there is no left reduction, return null.\n+  const char  *leftStr  = nullptr;\n@@ -3484,1 +3484,1 @@\n-  if (iop == NULL) {\n+  if (iop == nullptr) {\n@@ -3643,3 +3643,3 @@\n-    const InstructForm *form2_inst = form2 ? form2->is_instruction() : NULL;\n-    const char *name_left  = mRule2->_lChild ? mRule2->_lChild->_opType : NULL;\n-    const char *name_right = mRule2->_rChild ? mRule2->_rChild->_opType : NULL;\n+    const InstructForm *form2_inst = form2 ? form2->is_instruction() : nullptr;\n+    const char *name_left  = mRule2->_lChild ? mRule2->_lChild->_opType : nullptr;\n+    const char *name_right = mRule2->_rChild ? mRule2->_rChild->_opType : nullptr;\n@@ -3656,2 +3656,2 @@\n-        && (name_left != NULL)       \/\/ NOT (load)\n-        && (name_right == NULL) ) {  \/\/ NOT (load memory foo)\n+        && (name_left != nullptr)       \/\/ NOT (load)\n+        && (name_right == nullptr) ) {  \/\/ NOT (load memory foo)\n@@ -3669,1 +3669,1 @@\n-    else if (form->is_cisc_reg(globals) && form2 != NULL && form2->is_cisc_mem(globals)) {\n+    else if (form->is_cisc_reg(globals) && form2 != nullptr && form2->is_cisc_mem(globals)) {\n@@ -3685,1 +3685,1 @@\n-    if( (_lChild == NULL) && (mRule2->_lChild == NULL) ) {\n+    if( (_lChild == nullptr) && (mRule2->_lChild == nullptr) ) {\n@@ -3687,1 +3687,1 @@\n-    } else  if (_lChild != NULL) {\n+    } else  if (_lChild != nullptr) {\n@@ -3692,1 +3692,1 @@\n-    if( (_rChild == NULL) && (mRule2->_rChild == NULL) ) {\n+    if( (_rChild == nullptr) && (mRule2->_rChild == nullptr) ) {\n@@ -3694,1 +3694,1 @@\n-    } else if (_rChild != NULL) {\n+    } else if (_rChild != nullptr) {\n@@ -3722,1 +3722,1 @@\n-  if( (_lChild == NULL) || (mRule2->_lChild == NULL) ) {\n+  if( (_lChild == nullptr) || (mRule2->_lChild == nullptr) ) {\n@@ -3734,2 +3734,2 @@\n-  if (_rChild == NULL) {\n-    if (mRule2->_rChild == NULL) {\n+  if (_rChild == nullptr) {\n+    if (mRule2->_rChild == nullptr) {\n@@ -3738,1 +3738,1 @@\n-      assert(0, \"_rChild should not be NULL\");\n+      assert(0, \"_rChild should not be null\");\n@@ -3772,1 +3772,1 @@\n-    return false; \/\/ I have NULL left child, mRule2 has non-NULL left child.\n+    return false; \/\/ I have null left child, mRule2 has non-null left child.\n@@ -3779,1 +3779,1 @@\n-    return false; \/\/ I have NULL right child, mRule2 has non-NULL right child.\n+    return false; \/\/ I have null right child, mRule2 has non-null right child.\n@@ -3807,1 +3807,1 @@\n-    return false; \/\/ I have NULL left child, mNode2 has non-NULL left child.\n+    return false; \/\/ I have null left child, mNode2 has non-null left child.\n@@ -3814,1 +3814,1 @@\n-    return false; \/\/ I have NULL right child, mNode2 has non-NULL right child.\n+    return false; \/\/ I have null right child, mNode2 has non-null right child.\n@@ -3844,1 +3844,1 @@\n-    if (_rChild->_lChild == NULL && _rChild->_rChild == NULL) {\n+    if (_rChild->_lChild == nullptr && _rChild->_rChild == nullptr) {\n@@ -3942,2 +3942,2 @@\n-  : MatchNode(ad), _depth(0), _construct(NULL), _numchilds(0) {\n-    _next = NULL;\n+  : MatchNode(ad), _depth(0), _construct(nullptr), _numchilds(0) {\n+    _next = nullptr;\n@@ -3949,1 +3949,1 @@\n-    _next = NULL;\n+    _next = nullptr;\n@@ -3956,3 +3956,3 @@\n-      _next = NULL;\n-      mroot->_lChild = NULL;\n-      mroot->_rChild = NULL;\n+      _next = nullptr;\n+      mroot->_lChild = nullptr;\n+      mroot->_rChild = nullptr;\n@@ -3969,1 +3969,1 @@\n-  assert (_name != NULL, \"MatchNode::build_components encountered empty node\\n\");\n+  assert (_name != nullptr, \"MatchNode::build_components encountered empty node\\n\");\n@@ -3990,3 +3990,3 @@\n-  const char  *result   = NULL;\n-  const char  *name     = NULL;\n-  const char  *opType   = NULL;\n+  const char  *result   = nullptr;\n+  const char  *name     = nullptr;\n+  const char  *opType   = nullptr;\n@@ -4018,3 +4018,3 @@\n-  const char  *result   = NULL;\n-  const char  *name     = NULL;\n-  const char  *opType   = NULL;\n+  const char  *result   = nullptr;\n+  const char  *name     = nullptr;\n+  const char  *opType   = nullptr;\n@@ -4033,1 +4033,1 @@\n-  if ((_lChild == NULL) && (_rChild == NULL) ) {\n+  if ((_lChild == nullptr) && (_rChild == nullptr) ) {\n@@ -4207,1 +4207,0 @@\n-    \"CMoveVD\", \"CMoveVF\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":315,"deletions":316,"binary":false,"changes":631,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-ArchDesc* globalAD = NULL;      \/\/ global reference to Architecture Description object\n+ArchDesc* globalAD = nullptr;      \/\/ global reference to Architecture Description object\n@@ -121,1 +121,1 @@\n-            if (def == NULL)  def = (char*)\"1\";\n+            if (def == nullptr)  def = (char*)\"1\";\n@@ -130,1 +130,1 @@\n-            AD.set_preproc_def(flag, NULL);\n+            AD.set_preproc_def(flag, nullptr);\n@@ -370,1 +370,1 @@\n-      (ADF._fp = fopen(ADF._name, action)) == NULL) {\n+      (ADF._fp = fopen(ADF._name, action)) == nullptr) {\n@@ -381,1 +381,1 @@\n-  if (_ADL_file._name == NULL)\n+  if (_ADL_file._name == nullptr)\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -126,3 +126,3 @@\n-            case Bytecodes::_ladd: set_constant(a + b); return;\n-            case Bytecodes::_lsub: set_constant(a - b); return;\n-            case Bytecodes::_lmul: set_constant(a * b); return;\n+            case Bytecodes::_ladd: set_constant(java_add(a, b)); return;\n+            case Bytecodes::_lsub: set_constant(java_subtract(a, b)); return;\n+            case Bytecodes::_lmul: set_constant(java_multiply(a, b)); return;\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2644,1 +2644,1 @@\n-    int key = x->lo_key();\n+    int low = x->lo_key();\n@@ -2646,2 +2646,3 @@\n-    C1SwitchRange* range = new C1SwitchRange(key, sux);\n-    for (int i = 0; i < len; i++, key++) {\n+    C1SwitchRange* range = new C1SwitchRange(low, sux);\n+    for (int i = 0; i < len; i++) {\n+      int key = low + i;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-  assert(ent != NULL, \"sanity\");\n+  assert(ent != nullptr, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1697,1 +1697,1 @@\n-  out->print_cr(\"version %d\", REPLAY_VERSION);\n+  dump_replay_data_version(out);\n@@ -1765,0 +1765,1 @@\n+          dump_replay_data_version(&replay_data_stream);\n@@ -1776,0 +1777,4 @@\n+\n+void ciEnv::dump_replay_data_version(outputStream* out) {\n+  out->print_cr(\"version %d\", REPLAY_VERSION);\n+}\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -505,0 +505,1 @@\n+  void dump_replay_data_version(outputStream* out);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  int hash() { return ident() * 31; } \/\/ ???\n+  uint hash() { return ident() * 31; } \/\/ ???\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -640,1 +640,1 @@\n-      process_command(THREAD);\n+      process_command(false, THREAD);\n@@ -656,1 +656,1 @@\n-  void process_command(TRAPS) {\n+  void process_command(bool is_replay_inline, TRAPS) {\n@@ -674,10 +674,11 @@\n-    } else if (strcmp(\"ciMethod\", cmd) == 0) {\n-      process_ciMethod(CHECK);\n-    } else if (strcmp(\"ciMethodData\", cmd) == 0) {\n-      process_ciMethodData(CHECK);\n-    } else if (strcmp(\"staticfield\", cmd) == 0) {\n-      process_staticfield(CHECK);\n-    } else if (strcmp(\"ciInstanceKlass\", cmd) == 0) {\n-      process_ciInstanceKlass(CHECK);\n-    } else if (strcmp(\"instanceKlass\", cmd) == 0) {\n-      process_instanceKlass(CHECK);\n+    } else if (!is_replay_inline) {\n+      if (strcmp(\"ciMethod\", cmd) == 0) {\n+        process_ciMethod(CHECK);\n+      } else if (strcmp(\"ciMethodData\", cmd) == 0) {\n+        process_ciMethodData(CHECK);\n+      } else if (strcmp(\"staticfield\", cmd) == 0) {\n+        process_staticfield(CHECK);\n+      } else if (strcmp(\"ciInstanceKlass\", cmd) == 0) {\n+        process_ciInstanceKlass(CHECK);\n+      } else if (strcmp(\"instanceKlass\", cmd) == 0) {\n+        process_instanceKlass(CHECK);\n@@ -685,2 +686,2 @@\n-    } else if (strcmp(\"JvmtiExport\", cmd) == 0) {\n-      process_JvmtiExport(CHECK);\n+      } else if (strcmp(\"JvmtiExport\", cmd) == 0) {\n+        process_JvmtiExport(CHECK);\n@@ -688,0 +689,3 @@\n+      } else {\n+        report_error(\"unknown command\");\n+      }\n@@ -727,6 +731,1 @@\n-      \/\/ Expecting only lines with \"compile\" command in inline replay file.\n-      char* cmd = parse_string();\n-      if (cmd == nullptr || strcmp(\"compile\", cmd) != 0) {\n-        return nullptr;\n-      }\n-      process_compile(CHECK_NULL);\n+      process_command(true, CHECK_NULL);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2834,1 +2834,1 @@\n-  m->compute_from_signature(cp->symbol_at(signature_index));\n+  m->constMethod()->compute_from_signature(cp->symbol_at(signature_index), access_flags.is_static());\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1348,2 +1348,1 @@\n-\n-  ClassLoaderExt::record_result(classpath_index, ik, redefined);\n+  ClassLoaderExt::record_result(checked_cast<s2>(classpath_index), ik, redefined);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  _unloading_next(nullptr),\n@@ -304,0 +305,40 @@\n+void ClassLoaderData::demote_strong_roots() {\n+  \/\/ The oop handle area contains strong roots that the GC traces from. We are about\n+  \/\/ to demote them to strong native oops that the GC does *not* trace from. Conceptually,\n+  \/\/ we are retiring a rather normal strong root, and creating a strong non-root handle,\n+  \/\/ which happens to reuse the same address as the normal strong root had.\n+  \/\/ Unless we invoke the right barriers, the GC might not notice that a strong root\n+  \/\/ has been pulled from the system, and is left unprocessed by the GC. There can be\n+  \/\/ several consequences:\n+  \/\/ 1. A concurrently marking snapshot-at-the-beginning GC might assume that the contents\n+  \/\/    of all strong roots get processed by the GC in order to keep them alive. Without\n+  \/\/    barriers, some objects might not be kept alive.\n+  \/\/ 2. A concurrently relocating GC might assume that after moving an object, a subsequent\n+  \/\/    tracing from all roots can fix all the pointers in the system, which doesn't play\n+  \/\/    well with roots racingly being pulled.\n+  \/\/ 3. A concurrent GC using colored pointers, might assume that tracing the object graph\n+  \/\/    from roots results in all pointers getting some particular color, which also doesn't\n+  \/\/    play well with roots being pulled out from the system concurrently.\n+\n+  class TransitionRootsOopClosure : public OopClosure {\n+  public:\n+    virtual void do_oop(oop* p) {\n+      \/\/ By loading the strong root with the access API, we can use the right barriers to\n+      \/\/ store the oop as a strong non-root handle, that happens to reuse the same memory\n+      \/\/ address as the strong root. The barriered store ensures that:\n+      \/\/ 1. The concurrent SATB marking properties are satisfied as the store will keep\n+      \/\/    the oop alive.\n+      \/\/ 2. The concurrent object movement properties are satisfied as we store the address\n+      \/\/    of the new location of the object, if any.\n+      \/\/ 3. The colors if any will be stored as the new good colors.\n+      oop obj = NativeAccess<>::oop_load(p); \/\/ Load the strong root\n+      NativeAccess<>::oop_store(p, obj); \/\/ Store the strong non-root\n+    }\n+\n+    virtual void do_oop(narrowOop* p) {\n+      ShouldNotReachHere();\n+    }\n+  } cl;\n+  oops_do(&cl, ClassLoaderData::_claim_none, false \/* clear_mod_oops *\/);\n+}\n+\n@@ -319,0 +360,8 @@\n+    if (_keep_alive == 1) {\n+      \/\/ When the keep_alive counter is 1, the oop handle area is a strong root,\n+      \/\/ acting as input to the GC tracing. Such strong roots are part of the\n+      \/\/ snapshot-at-the-beginning, and can not just be pulled out from the\n+      \/\/ system when concurrent GCs are running at the same time, without\n+      \/\/ invoking the right barriers.\n+      demote_strong_roots();\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -156,1 +156,23 @@\n-  ClassLoaderData* _next; \/\/\/ Next loader_datas created\n+  \/\/\n+  \/\/ The ClassLoaderDataGraph maintains two lists to keep track of CLDs.\n+  \/\/\n+  \/\/ The first list [_head, _next] is where new CLDs are registered. The CLDs\n+  \/\/ are only inserted at the _head, and the _next pointers are only rewritten\n+  \/\/ from unlink_next() which unlinks one unloading CLD by setting _next to\n+  \/\/ _next->_next. This allows GCs to concurrently walk the list while the CLDs\n+  \/\/ are being concurrently unlinked.\n+  \/\/\n+  \/\/ The second list [_unloading_head, _unloading_next] is where dead CLDs get\n+  \/\/ moved to during class unloading. See: ClassLoaderDataGraph::do_unloading().\n+  \/\/ This list is never modified while other threads are iterating over it.\n+  \/\/\n+  \/\/ After all dead CLDs have been moved to the unloading list, there's a\n+  \/\/ synchronization point (handshake) to ensure that all threads reading these\n+  \/\/ CLDs finish their work. This ensures that we don't have a use-after-free\n+  \/\/ when we later delete the CLDs.\n+  \/\/\n+  \/\/ And finally, when no threads are using the unloading CLDs anymore, we\n+  \/\/ remove them from the class unloading list and delete them. See:\n+  \/\/ ClassLoaderDataGraph::purge();\n+  ClassLoaderData* _next;\n+  ClassLoaderData* _unloading_next;\n@@ -163,2 +185,6 @@\n-  void set_next(ClassLoaderData* next) { Atomic::store(&_next, next); }\n-  ClassLoaderData* next() const        { return Atomic::load(&_next); }\n+  void set_next(ClassLoaderData* next);\n+  ClassLoaderData* next() const;\n+  void unlink_next();\n+\n+  void set_unloading_next(ClassLoaderData* unloading_next);\n+  ClassLoaderData* unloading_next() const;\n@@ -198,0 +224,2 @@\n+  void demote_strong_roots();\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1262,1 +1262,1 @@\n-    int path_index = ik->shared_classpath_index();\n+    s2 path_index = ik->shared_classpath_index();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+  template(java_lang_ScopedValue,                     \"java\/lang\/ScopedValue\")                    \\\n+  template(java_lang_ScopedValue_Carrier,             \"java\/lang\/ScopedValue$Carrier\")            \\\n@@ -160,2 +162,0 @@\n-  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n-  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    assert(_cached_value != nullptr, \"must be non-nullptr\");\n+    assert(_cached_value != nullptr, \"must be non-null\");\n@@ -342,1 +342,1 @@\n-  \/\/ Returns NULL if CodeBuffer::expand fails\n+  \/\/ Returns null if CodeBuffer::expand fails\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-  \/\/ If _first is nullptr we have no more compile jobs. There are two reasons for\n+  \/\/ If _first is null we have no more compile jobs. There are two reasons for\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                                               PhaseTransform* phase,\n+                                               PhaseValues* phase,\n@@ -306,1 +306,1 @@\n-                                                PhaseTransform* phase, Node* store,\n+                                                PhaseValues* phase, Node* store,\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-                                 PhaseTransform* phase,\n+                                 PhaseValues* phase,\n@@ -64,1 +64,1 @@\n-                                  PhaseTransform* phase, Node* store,\n+                                  PhaseValues* phase, Node* store,\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -184,2 +184,0 @@\n-  virtual void check_for_non_bad_heap_word_value(HeapWord* addr, size_t size)\n-    PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  void check_for_bad_heap_word_value() const;\n@@ -86,1 +85,0 @@\n-      verify_after();\n@@ -153,16 +151,0 @@\n-void MemAllocator::Allocation::verify_after() {\n-  NOT_PRODUCT(check_for_bad_heap_word_value();)\n-}\n-\n-void MemAllocator::Allocation::check_for_bad_heap_word_value() const {\n-  MemRegion obj_range = _allocator.obj_memory_range(obj());\n-  HeapWord* addr = obj_range.start();\n-  size_t size = obj_range.word_size();\n-  if (CheckMemoryInitialization && ZapUnusedHeapArea) {\n-    for (size_t slot = 0; slot < size; slot += 1) {\n-      assert((*(intptr_t*) (addr + slot)) != ((intptr_t) badHeapWordVal),\n-             \"Found badHeapWordValue in post-allocation check\");\n-    }\n-  }\n-}\n-\n@@ -263,1 +245,0 @@\n-  NOT_PRODUCT(Universe::heap()->check_for_non_bad_heap_word_value(mem, _word_size));\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,\n+bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseValues* phase, Node* adr,\n@@ -312,1 +312,1 @@\n-bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseTransform *phase, Node* n) {\n+bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseValues* phase, Node* n) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  bool satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,\n+  bool satb_can_remove_pre_barrier(GraphKit* kit, PhaseValues* phase, Node* adr,\n@@ -97,1 +97,1 @@\n-  static bool is_shenandoah_marking_if(PhaseTransform *phase, Node* n);\n+  static bool is_shenandoah_marking_if(PhaseValues* phase, Node* n);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1173,0 +1173,6 @@\n+\/*\n+ * Return JNI_TRUE if warnings are printed when agents are dynamically loaded.\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+JVM_PrintWarningAtDynamicAgentLoad(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -816,1 +816,1 @@\n-            (klass == nullptr ? \"<nullptr>\" : klass->internal_name()),\n+            (klass == nullptr ? \"<null>\" : klass->internal_name()),\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2411,1 +2411,1 @@\n-      peerEnv->describe_pending_exception(true);\n+      peerEnv->describe_pending_exception(tty);\n@@ -2580,1 +2580,1 @@\n-        peerJVMCIEnv->describe_pending_exception(true);\n+        peerJVMCIEnv->describe_pending_exception(tty);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n@@ -218,0 +219,4 @@\n+  JVMTI_ONLY(nonstatic_field(JavaThread,       _is_in_VTMS_transition,                        bool))                                 \\\n+  JVMTI_ONLY(nonstatic_field(JavaThread,       _is_in_tmp_VTMS_transition,                    bool))                                 \\\n+                                                                                                                                     \\\n+  JVMTI_ONLY(static_field(JvmtiVTMSTransitionDisabler, _VTMS_notify_jvmti_events,             bool))                                 \\\n@@ -369,0 +374,1 @@\n+  static_field(java_lang_Thread,            _jvmti_is_in_VTMS_transition_offset,              int)                                   \\\n@@ -761,0 +767,4 @@\n+  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_start)) \\\n+  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_end))   \\\n+  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_mount)) \\\n+  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_unmount)) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-    FunctionType _function[KLASS_KIND_COUNT];\n+    FunctionType _function[Klass::KLASS_KIND_COUNT];\n@@ -208,1 +208,1 @@\n-    FunctionType _function[KLASS_KIND_COUNT];\n+    FunctionType _function[Klass::KLASS_KIND_COUNT];\n@@ -273,1 +273,1 @@\n-    FunctionType _function[KLASS_KIND_COUNT];\n+    FunctionType _function[Klass::KLASS_KIND_COUNT];\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-          assert(m != nullptr, \"archived mirrors should not be nullptr\");\n+          assert(m != nullptr, \"archived mirrors should not be null\");\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-  int i = reference_map()->find(cp_index);\n+  int i = reference_map()->find(checked_cast<u2>(cp_index));\n@@ -746,1 +746,1 @@\n-int ConstantPool::uncached_name_and_type_ref_index_at(int cp_index)  {\n+u2 ConstantPool::uncached_name_and_type_ref_index_at(int cp_index)  {\n@@ -748,1 +748,1 @@\n-    int pool_index = bootstrap_name_and_type_ref_index_at(cp_index);\n+    u2 pool_index = bootstrap_name_and_type_ref_index_at(cp_index);\n@@ -758,1 +758,1 @@\n-int ConstantPool::name_and_type_ref_index_at(int index, Bytecodes::Code code) {\n+u2 ConstantPool::name_and_type_ref_index_at(int index, Bytecodes::Code code) {\n@@ -770,1 +770,1 @@\n-int ConstantPool::uncached_klass_ref_index_at(int cp_index) {\n+u2 ConstantPool::uncached_klass_ref_index_at(int cp_index) {\n@@ -776,1 +776,1 @@\n-int ConstantPool::klass_ref_index_at(int index, Bytecodes::Code code) {\n+u2 ConstantPool::klass_ref_index_at(int index, Bytecodes::Code code) {\n@@ -803,1 +803,1 @@\n-int ConstantPool::name_ref_index_at(int which_nt) {\n+u2 ConstantPool::name_ref_index_at(int which_nt) {\n@@ -809,1 +809,1 @@\n-int ConstantPool::signature_ref_index_at(int which_nt) {\n+u2 ConstantPool::signature_ref_index_at(int which_nt) {\n@@ -2241,1 +2241,1 @@\n-        idx1 = klass_index_at(idx);\n+        idx1 = checked_cast<u2>(klass_index_at(idx));\n@@ -2248,1 +2248,1 @@\n-        idx1 = string_index_at(idx);\n+        idx1 = checked_cast<u2>(string_index_at(idx));\n@@ -2257,1 +2257,1 @@\n-        idx1 = method_handle_index_at(idx);\n+        idx1 = checked_cast<u2>(method_handle_index_at(idx));\n@@ -2266,1 +2266,1 @@\n-        idx1 = method_type_index_at(idx);\n+        idx1 = checked_cast<u2>(method_type_index_at(idx));\n@@ -2343,1 +2343,1 @@\n-      _flags &= ~_on_stack;\n+      _flags &= (u2)(~_on_stack);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-  int invokedynamic_bootstrap_ref_index_at(int indy_index) const {\n+  u2 invokedynamic_bootstrap_ref_index_at(int indy_index) const {\n@@ -519,1 +519,1 @@\n-  int method_handle_klass_index_at(int which) {\n+  u2 method_handle_klass_index_at(int which) {\n@@ -528,1 +528,1 @@\n-  int bootstrap_name_and_type_ref_index_at(int which) {\n+  u2 bootstrap_name_and_type_ref_index_at(int which) {\n@@ -532,1 +532,1 @@\n-  int bootstrap_methods_attribute_index(int which) {\n+  u2 bootstrap_methods_attribute_index(int which) {\n@@ -680,2 +680,2 @@\n-  int klass_ref_index_at(int which, Bytecodes::Code code);\n-  int name_and_type_ref_index_at(int which, Bytecodes::Code code);\n+  u2 klass_ref_index_at(int which, Bytecodes::Code code);\n+  u2 name_and_type_ref_index_at(int which, Bytecodes::Code code);\n@@ -690,2 +690,2 @@\n-  int name_ref_index_at(int which_nt);            \/\/ ==  low-order jshort of name_and_type_at(which_nt)\n-  int signature_ref_index_at(int which_nt);       \/\/ == high-order jshort of name_and_type_at(which_nt)\n+  u2 name_ref_index_at(int which_nt);            \/\/ ==  low-order jshort of name_and_type_at(which_nt)\n+  u2 signature_ref_index_at(int which_nt);       \/\/ == high-order jshort of name_and_type_at(which_nt)\n@@ -798,2 +798,2 @@\n-  int       uncached_klass_ref_index_at(int cp_index);\n-  int       uncached_name_and_type_ref_index_at(int cp_index);\n+  u2 uncached_klass_ref_index_at(int cp_index);\n+  u2 uncached_name_and_type_ref_index_at(int cp_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-int ConstantPoolCacheEntry::make_flags(TosState state,\n+intx ConstantPoolCacheEntry::make_flags(TosState state,\n@@ -71,1 +71,1 @@\n-  int f = ((int)state << tos_state_shift) | option_bits | field_index_or_method_params;\n+  intx f = ((int)state << tos_state_shift) | option_bits | field_index_or_method_params;\n@@ -894,1 +894,1 @@\n-  LogStream* log_stream = NULL;\n+  LogStream* log_stream = nullptr;\n@@ -912,1 +912,1 @@\n-    assert(resolved_references->obj_at(appendix_index) == NULL, \"init just once\");\n+    assert(resolved_references->obj_at(appendix_index) == nullptr, \"init just once\");\n@@ -920,1 +920,1 @@\n-  if (log_stream != NULL) {\n+  if (log_stream != nullptr) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-  int make_flags(TosState state, int option_bits, int field_index_or_method_params);\n+  intx make_flags(TosState state, int option_bits, int field_index_or_method_params);\n@@ -318,2 +318,2 @@\n-  int indices() const                            { return _indices; }\n-  int indices_ord() const;\n+  intx indices() const                           { return _indices; }\n+  intx indices_ord() const;\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2716,1 +2716,3 @@\n-    int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())\n+    int itable_offset_in_words = (int)(start_of_itable() - (intptr_t*)this);\n+\n+    int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words)\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1017,1 +1017,0 @@\n-  inline int itable_offset_in_words() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-inline int InstanceKlass::itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-    set_super_check_offset((address)super_check_cell - (address) this);\n+    set_super_check_offset(u4((address)super_check_cell - (address) this));\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,15 +40,0 @@\n-\/\/ Klass Kinds for all subclasses of Klass\n-enum KlassKind {\n-  InstanceKlassKind,\n-  InlineKlassKind,\n-  InstanceRefKlassKind,\n-  InstanceMirrorKlassKind,\n-  InstanceClassLoaderKlassKind,\n-  InstanceStackChunkKlassKind,\n-  TypeArrayKlassKind,\n-  FlatArrayKlassKind,\n-  ObjArrayKlassKind\n-};\n-\n-const uint KLASS_KIND_COUNT = ObjArrayKlassKind + 1;\n-\n@@ -84,0 +69,16 @@\n+ public:\n+  \/\/ Klass Kinds for all subclasses of Klass\n+  enum KlassKind {\n+    InstanceKlassKind,\n+    InlineKlassKind,\n+    InstanceRefKlassKind,\n+    InstanceMirrorKlassKind,\n+    InstanceClassLoaderKlassKind,\n+    InstanceStackChunkKlassKind,\n+    TypeArrayKlassKind,\n+    FlatArrayKlassKind,\n+    ObjArrayKlassKind,\n+    UnknownKlassKind\n+  };\n+\n+  static const uint KLASS_KIND_COUNT = ObjArrayKlassKind + 1;\n@@ -85,0 +86,1 @@\n+\n@@ -176,1 +178,1 @@\n-  jshort _shared_class_path_index;\n+  s2 _shared_class_path_index;\n@@ -199,1 +201,1 @@\n-  Klass() : _kind(KlassKind(-1)) { assert(DumpSharedSpaces || UseSharedSpaces, \"only for cds\"); }\n+  Klass() : _kind(UnknownKlassKind) { assert(DumpSharedSpaces || UseSharedSpaces, \"only for cds\"); }\n@@ -309,1 +311,1 @@\n-  int shared_classpath_index() const   {\n+  s2 shared_classpath_index() const   {\n@@ -313,1 +315,1 @@\n-  void set_shared_classpath_index(int index) {\n+  void set_shared_classpath_index(s2 index) {\n@@ -328,1 +330,1 @@\n-    CDS_ONLY(_shared_class_flags &= ~_archived_lambda_proxy_is_available;)\n+    CDS_ONLY(_shared_class_flags &= (u2)(~_archived_lambda_proxy_is_available);)\n@@ -339,1 +341,1 @@\n-    CDS_ONLY(_shared_class_flags &= ~_has_value_based_class_annotation;)\n+    CDS_ONLY(_shared_class_flags &= (u2)(~_has_value_based_class_annotation);)\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1121,3 +1121,3 @@\n-      _table_offset      = (intptr_t*)offset_entry - (intptr_t*)klass;\n-      _size_offset_table = (method_entry - ((intptr_t*)offset_entry)) \/ itableOffsetEntry::size();\n-      _size_method_table = (end - method_entry)                  \/ itableMethodEntry::size();\n+      _table_offset      = int((intptr_t*)offset_entry - (intptr_t*)klass);\n+      _size_offset_table = int((method_entry - ((intptr_t*)offset_entry)) \/ itableOffsetEntry::size());\n+      _size_method_table = int((end - method_entry)                  \/ itableMethodEntry::size());\n@@ -1513,1 +1513,1 @@\n-    int offset = ((address)_method_entry) - _klass_begin;\n+    int offset = int(((address)_method_entry) - _klass_begin);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-    _tableOffset = (address)base - (address)klass; _length = length;\n+    _tableOffset = int((address)base - (address)klass);\n+    _length = length;\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-  return bcp - code_base();\n+  return int(bcp - code_base());\n@@ -361,1 +361,1 @@\n-    bci = bcp - code_base();\n+    bci = int(bcp - code_base());\n@@ -665,13 +665,0 @@\n-\/\/ Derive size of parameters, return type, and fingerprint,\n-\/\/ all in one pass, which is run at load time.\n-\/\/ We need the first two, and might as well grab the third.\n-void Method::compute_from_signature(Symbol* sig) {\n-  \/\/ At this point, since we are scanning the signature,\n-  \/\/ we might as well compute the whole fingerprint.\n-  Fingerprinter fp(sig, is_static());\n-  set_size_of_parameters(fp.size_of_parameters());\n-  set_num_stack_arg_slots(fp.num_stack_arg_slots());\n-  constMethod()->set_result_type(fp.return_type());\n-  constMethod()->set_fingerprint(fp.fingerprint());\n-}\n-\n@@ -1551,1 +1538,1 @@\n-  m->compute_from_signature(signature);\n+  m->constMethod()->compute_from_signature(signature, must_be_static);\n@@ -1835,1 +1822,1 @@\n-      for (int i = 0; i < length; i++) {\n+      for (u2 i = 0; i < length; i++) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  int name_index() const                         { return constMethod()->name_index();         }\n+  u2 name_index() const                          { return constMethod()->name_index();         }\n@@ -154,1 +154,1 @@\n-  int signature_index() const                    { return constMethod()->signature_index();         }\n+  u2 signature_index() const                     { return constMethod()->signature_index();         }\n@@ -159,2 +159,1 @@\n-  int generic_signature_index() const            { return constMethod()->generic_signature_index(); }\n-  void set_generic_signature_index(int index)    { constMethod()->set_generic_signature_index(index); }\n+  u2 generic_signature_index() const             { return constMethod()->generic_signature_index(); }\n@@ -305,6 +304,1 @@\n-  \/\/ Derive stuff from the signature at load time.\n-  void compute_from_signature(Symbol* sig);\n-\n-  \/\/ size of parameters (receiver if any + arguments)\n-  int  size_of_parameters() const                { return constMethod()->size_of_parameters(); }\n-  void set_size_of_parameters(int size)          { constMethod()->set_size_of_parameters(size); }\n+  u2 size_of_parameters() const { return constMethod()->size_of_parameters(); }\n@@ -327,1 +321,1 @@\n-  int exception_table_length() const\n+  u2 exception_table_length() const\n@@ -971,2 +965,0 @@\n-\n-  void set_num_stack_arg_slots(int n) { constMethod()->set_num_stack_arg_slots(n); }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    jubyte value = ((jubyte) bci_delta << 3) | (jubyte) line_delta;\n+    jubyte value = (jubyte)((bci_delta << 3) | line_delta);\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  _length = length;\n+  _length = (u2)length;\n@@ -293,1 +293,1 @@\n-    int ch = ss.raw_char_at(i);\n+    char ch = ss.raw_char_at(i);\n@@ -437,1 +437,1 @@\n-      int hash = extract_hash(old_value);\n+      short hash = extract_hash(old_value);\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-  bool ends_with(int suffix_char) const {\n+  bool ends_with(char suffix_char) const {\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -683,1 +683,1 @@\n-Node* AddPNode::Ideal_base_and_offset(Node* ptr, PhaseTransform* phase,\n+Node* AddPNode::Ideal_base_and_offset(Node* ptr, PhaseValues* phase,\n@@ -901,0 +901,28 @@\n+\n+  \/\/ Propagate xor through constant cmoves. This pattern can occur after expansion of Conv2B nodes.\n+  const TypeInt* in2_type = phase->type(in2)->isa_int();\n+  if (in1->Opcode() == Op_CMoveI && in2_type != nullptr && in2_type->is_con()) {\n+    int in2_val = in2_type->get_con();\n+\n+    \/\/ Get types of both sides of the CMove\n+    const TypeInt* left = phase->type(in1->in(CMoveNode::IfFalse))->isa_int();\n+    const TypeInt* right = phase->type(in1->in(CMoveNode::IfTrue))->isa_int();\n+\n+    \/\/ Ensure that both sides are int constants\n+    if (left != nullptr && right != nullptr && left->is_con() && right->is_con()) {\n+      Node* cond = in1->in(CMoveNode::Condition);\n+\n+      \/\/ Check that the comparison is a bool and that the cmp node type is correct\n+      if (cond->is_Bool()) {\n+        int cmp_op = cond->in(1)->Opcode();\n+\n+        if (cmp_op == Op_CmpI || cmp_op == Op_CmpP) {\n+          int l_val = left->get_con();\n+          int r_val = right->get_con();\n+\n+          return new CMoveINode(cond, phase->intcon(l_val ^ in2_val), phase->intcon(r_val ^ in2_val), TypeInt::INT);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1017,0 +1045,8 @@\n+Node* build_min_max_int(Node* a, Node* b, bool is_max) {\n+  if (is_max) {\n+    return new MaxINode(a, b);\n+  } else {\n+    return new MinINode(a, b);\n+  }\n+}\n+\n@@ -1031,7 +1067,2 @@\n-    if (is_max) {\n-      res =  gvn.transform(new MaxINode(a, b));\n-      assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n-    } else {\n-      Node* res =  gvn.transform(new MinINode(a, b));\n-      assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n-    }\n+    res = gvn.transform(build_min_max_int(a, b, is_max));\n+    assert(gvn.type(res)->is_int()->_lo >= t->is_int()->_lo && gvn.type(res)->is_int()->_hi <= t->is_int()->_hi, \"type doesn't match\");\n@@ -1082,12 +1113,1 @@\n-\/\/=============================================================================\n-\/\/------------------------------add_ring---------------------------------------\n-\/\/ Supplied function returns the sum of the inputs.\n-const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ Otherwise just MAX them bits.\n-  return TypeInt::make( MAX2(r0->_lo,r1->_lo), MAX2(r0->_hi,r1->_hi), MAX2(r0->_widen,r1->_widen) );\n-}\n-\n-\/\/ Check if addition of an integer with type 't' and a constant 'c' can overflow\n+\/\/ Check if addition of an integer with type 't' and a constant 'c' can overflow.\n@@ -1101,14 +1121,16 @@\n-\/\/ Ideal transformations for MaxINode\n-Node* MaxINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  \/\/ Force a right-spline graph\n-  Node* l = in(1);\n-  Node* r = in(2);\n-  \/\/ Transform  MaxI1(MaxI2(a, b), c)  into  MaxI1(a, MaxI2(b, c))\n-  \/\/ to force a right-spline graph for the rest of MaxINode::Ideal().\n-  if (l->Opcode() == Op_MaxI) {\n-    assert(l != l->in(1), \"dead loop in MaxINode::Ideal\");\n-    r = phase->transform(new MaxINode(l->in(2), r));\n-    l = l->in(1);\n-    set_req_X(1, l, phase);\n-    set_req_X(2, r, phase);\n-    return this;\n+\/\/ Let <x, x_off> = x_operands and <y, y_off> = y_operands.\n+\/\/ If x == y and neither add(x, x_off) nor add(y, y_off) overflow, return\n+\/\/ add(x, op(x_off, y_off)). Otherwise, return nullptr.\n+Node* MaxNode::extract_add(PhaseGVN* phase, ConstAddOperands x_operands, ConstAddOperands y_operands) {\n+  Node* x = x_operands.first;\n+  Node* y = y_operands.first;\n+  int opcode = Opcode();\n+  assert(opcode == Op_MaxI || opcode == Op_MinI, \"Unexpected opcode\");\n+  const TypeInt* tx = phase->type(x)->isa_int();\n+  jint x_off = x_operands.second;\n+  jint y_off = y_operands.second;\n+  if (x == y && tx != nullptr &&\n+      !can_overflow(tx, x_off) &&\n+      !can_overflow(tx, y_off)) {\n+    jint c = opcode == Op_MinI ? MIN2(x_off, y_off) : MAX2(x_off, y_off);\n+    return new AddINode(x, phase->intcon(c));\n@@ -1116,0 +1138,2 @@\n+  return nullptr;\n+}\n@@ -1117,9 +1141,7 @@\n-  \/\/ Get left input & constant\n-  Node* x = l;\n-  jint x_off = 0;\n-  if (x->Opcode() == Op_AddI && \/\/ Check for \"x+c0\" and collect constant\n-      x->in(2)->is_Con()) {\n-    const Type* t = x->in(2)->bottom_type();\n-    if (t == Type::TOP) return nullptr;  \/\/ No progress\n-    x_off = t->is_int()->get_con();\n-    x = x->in(1);\n+\/\/ Try to cast n as an integer addition with a constant. Return:\n+\/\/   <x, C>,       if n == add(x, C), where 'C' is a non-TOP constant;\n+\/\/   <nullptr, 0>, if n == add(x, C), where 'C' is a TOP constant; or\n+\/\/   <n, 0>,       otherwise.\n+static ConstAddOperands as_add_with_constant(Node* n) {\n+  if (n->Opcode() != Op_AddI) {\n+    return ConstAddOperands(n, 0);\n@@ -1127,11 +1149,4 @@\n-\n-  \/\/ Scan a right-spline-tree for MAXs\n-  Node* y = r;\n-  jint y_off = 0;\n-  \/\/ Check final part of MAX tree\n-  if (y->Opcode() == Op_AddI && \/\/ Check for \"y+c1\" and collect constant\n-      y->in(2)->is_Con()) {\n-    const Type* t = y->in(2)->bottom_type();\n-    if (t == Type::TOP) return nullptr;  \/\/ No progress\n-    y_off = t->is_int()->get_con();\n-    y = y->in(1);\n+  Node* x = n->in(1);\n+  Node* c = n->in(2);\n+  if (!c->is_Con()) {\n+    return ConstAddOperands(n, 0);\n@@ -1139,3 +1154,3 @@\n-  if (x->_idx > y->_idx && r->Opcode() != Op_MaxI) {\n-    swap_edges(1, 2);\n-    return this;\n+  const Type* c_type = c->bottom_type();\n+  if (c_type == Type::TOP) {\n+    return ConstAddOperands(nullptr, 0);\n@@ -1143,0 +1158,2 @@\n+  return ConstAddOperands(x, c_type->is_int()->get_con());\n+}\n@@ -1144,12 +1161,15 @@\n-  const TypeInt* tx = phase->type(x)->isa_int();\n-\n-  if (r->Opcode() == Op_MaxI) {\n-    assert(r != r->in(2), \"dead loop in MaxINode::Ideal\");\n-    y = r->in(1);\n-    \/\/ Check final part of MAX tree\n-    if (y->Opcode() == Op_AddI &&\/\/ Check for \"y+c1\" and collect constant\n-        y->in(2)->is_Con()) {\n-      const Type* t = y->in(2)->bottom_type();\n-      if (t == Type::TOP) return nullptr;  \/\/ No progress\n-      y_off = t->is_int()->get_con();\n-      y = y->in(1);\n+Node* MaxNode::IdealI(PhaseGVN* phase, bool can_reshape) {\n+  int opcode = Opcode();\n+  assert(opcode == Op_MinI || opcode == Op_MaxI, \"Unexpected opcode\");\n+  \/\/ Try to transform the following pattern, in any of its four possible\n+  \/\/ permutations induced by op's commutativity:\n+  \/\/     op(op(add(inner, inner_off), inner_other), add(outer, outer_off))\n+  \/\/ into\n+  \/\/     op(add(inner, op(inner_off, outer_off)), inner_other),\n+  \/\/ where:\n+  \/\/     op is either MinI or MaxI, and\n+  \/\/     inner == outer, and\n+  \/\/     the additions cannot overflow.\n+  for (uint inner_op_index = 1; inner_op_index <= 2; inner_op_index++) {\n+    if (in(inner_op_index)->Opcode() != opcode) {\n+      continue;\n@@ -1157,10 +1177,4 @@\n-\n-    if (x->_idx > y->_idx)\n-      return new MaxINode(r->in(1), phase->transform(new MaxINode(l, r->in(2))));\n-\n-    \/\/ Transform MAX2(x + c0, MAX2(x + c1, z)) into MAX2(x + MAX2(c0, c1), z)\n-    \/\/ if x == y and the additions can't overflow.\n-    if (x == y && tx != nullptr &&\n-        !can_overflow(tx, x_off) &&\n-        !can_overflow(tx, y_off)) {\n-      return new MaxINode(phase->transform(new AddINode(x, phase->intcon(MAX2(x_off, y_off)))), r->in(2));\n+    Node* outer_add = in(inner_op_index == 1 ? 2 : 1);\n+    ConstAddOperands outer_add_operands = as_add_with_constant(outer_add);\n+    if (outer_add_operands.first == nullptr) {\n+      return nullptr; \/\/ outer_add has a TOP input, no need to continue.\n@@ -1168,7 +1182,17 @@\n-  } else {\n-    \/\/ Transform MAX2(x + c0, y + c1) into x + MAX2(c0, c1)\n-    \/\/ if x == y and the additions can't overflow.\n-    if (x == y && tx != nullptr &&\n-        !can_overflow(tx, x_off) &&\n-        !can_overflow(tx, y_off)) {\n-      return new AddINode(x, phase->intcon(MAX2(x_off, y_off)));\n+    \/\/ One operand is a MinI\/MaxI and the other is an integer addition with\n+    \/\/ constant. Test the operands of the inner MinI\/MaxI.\n+    for (uint inner_add_index = 1; inner_add_index <= 2; inner_add_index++) {\n+      Node* inner_op = in(inner_op_index);\n+      Node* inner_add = inner_op->in(inner_add_index);\n+      ConstAddOperands inner_add_operands = as_add_with_constant(inner_add);\n+      if (inner_add_operands.first == nullptr) {\n+        return nullptr; \/\/ inner_add has a TOP input, no need to continue.\n+      }\n+      \/\/ Try to extract the inner add.\n+      Node* add_extracted = extract_add(phase, inner_add_operands, outer_add_operands);\n+      if (add_extracted == nullptr) {\n+        continue;\n+      }\n+      Node* add_transformed = phase->transform(add_extracted);\n+      Node* inner_other = inner_op->in(inner_add_index == 1 ? 2 : 1);\n+      return build_min_max_int(add_transformed, inner_other, opcode == Op_MaxI);\n@@ -1177,1 +1201,28 @@\n- return nullptr;\n+  \/\/ Try to transform\n+  \/\/     op(add(x, x_off), add(y, y_off))\n+  \/\/ into\n+  \/\/     add(x, op(x_off, y_off)),\n+  \/\/ where:\n+  \/\/     op is either MinI or MaxI, and\n+  \/\/     inner == outer, and\n+  \/\/     the additions cannot overflow.\n+  ConstAddOperands xC = as_add_with_constant(in(1));\n+  ConstAddOperands yC = as_add_with_constant(in(2));\n+  if (xC.first == nullptr || yC.first == nullptr) return nullptr;\n+  return extract_add(phase, xC, yC);\n+}\n+\n+\/\/ Ideal transformations for MaxINode\n+Node* MaxINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return IdealI(phase, can_reshape);\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------add_ring---------------------------------------\n+\/\/ Supplied function returns the sum of the inputs.\n+const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {\n+  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n+  const TypeInt *r1 = t1->is_int();\n+\n+  \/\/ Otherwise just MAX them bits.\n+  return TypeInt::make( MAX2(r0->_lo,r1->_lo), MAX2(r0->_hi,r1->_hi), MAX2(r0->_widen,r1->_widen) );\n@@ -1184,77 +1235,2 @@\n-Node *MinINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  Node *progress = nullptr;\n-  \/\/ Force a right-spline graph\n-  Node *l = in(1);\n-  Node *r = in(2);\n-  \/\/ Transform  MinI1( MinI2(a,b), c)  into  MinI1( a, MinI2(b,c) )\n-  \/\/ to force a right-spline graph for the rest of MinINode::Ideal().\n-  if( l->Opcode() == Op_MinI ) {\n-    assert( l != l->in(1), \"dead loop in MinINode::Ideal\" );\n-    r = phase->transform(new MinINode(l->in(2),r));\n-    l = l->in(1);\n-    set_req_X(1, l, phase);\n-    set_req_X(2, r, phase);\n-    return this;\n-  }\n-\n-  \/\/ Get left input & constant\n-  Node *x = l;\n-  jint x_off = 0;\n-  if( x->Opcode() == Op_AddI && \/\/ Check for \"x+c0\" and collect constant\n-      x->in(2)->is_Con() ) {\n-    const Type *t = x->in(2)->bottom_type();\n-    if( t == Type::TOP ) return nullptr;  \/\/ No progress\n-    x_off = t->is_int()->get_con();\n-    x = x->in(1);\n-  }\n-\n-  \/\/ Scan a right-spline-tree for MINs\n-  Node *y = r;\n-  jint y_off = 0;\n-  \/\/ Check final part of MIN tree\n-  if( y->Opcode() == Op_AddI && \/\/ Check for \"y+c1\" and collect constant\n-      y->in(2)->is_Con() ) {\n-    const Type *t = y->in(2)->bottom_type();\n-    if( t == Type::TOP ) return nullptr;  \/\/ No progress\n-    y_off = t->is_int()->get_con();\n-    y = y->in(1);\n-  }\n-  if( x->_idx > y->_idx && r->Opcode() != Op_MinI ) {\n-    swap_edges(1, 2);\n-    return this;\n-  }\n-\n-  const TypeInt* tx = phase->type(x)->isa_int();\n-\n-  if( r->Opcode() == Op_MinI ) {\n-    assert( r != r->in(2), \"dead loop in MinINode::Ideal\" );\n-    y = r->in(1);\n-    \/\/ Check final part of MIN tree\n-    if( y->Opcode() == Op_AddI &&\/\/ Check for \"y+c1\" and collect constant\n-        y->in(2)->is_Con() ) {\n-      const Type *t = y->in(2)->bottom_type();\n-      if( t == Type::TOP ) return nullptr;  \/\/ No progress\n-      y_off = t->is_int()->get_con();\n-      y = y->in(1);\n-    }\n-\n-    if( x->_idx > y->_idx )\n-      return new MinINode(r->in(1),phase->transform(new MinINode(l,r->in(2))));\n-\n-    \/\/ Transform MIN2(x + c0, MIN2(x + c1, z)) into MIN2(x + MIN2(c0, c1), z)\n-    \/\/ if x == y and the additions can't overflow.\n-    if (x == y && tx != nullptr &&\n-        !can_overflow(tx, x_off) &&\n-        !can_overflow(tx, y_off)) {\n-      return new MinINode(phase->transform(new AddINode(x, phase->intcon(MIN2(x_off, y_off)))), r->in(2));\n-    }\n-  } else {\n-    \/\/ Transform MIN2(x + c0, y + c1) into x + MIN2(c0, c1)\n-    \/\/ if x == y and the additions can't overflow.\n-    if (x == y && tx != nullptr &&\n-        !can_overflow(tx, x_off) &&\n-        !can_overflow(tx, y_off)) {\n-      return new AddINode(x,phase->intcon(MIN2(x_off,y_off)));\n-    }\n-  }\n-  return nullptr;\n+Node* MinINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return IdealI(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":140,"deletions":164,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool ArrayCopyNode::may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) {\n@@ -749,1 +749,1 @@\n-bool ArrayCopyNode::may_modify_helper(const TypeOopPtr *t_oop, Node* n, PhaseTransform *phase, CallNode*& call) {\n+bool ArrayCopyNode::may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, CallNode*& call) {\n@@ -760,2 +760,1 @@\n-bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*& ac) {\n-\n+bool ArrayCopyNode::may_modify(const TypeOopPtr* t_oop, MemBarNode* mb, PhaseValues* phase, ArrayCopyNode*& ac) {\n@@ -802,1 +801,1 @@\n-bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const {\n+bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseValues* phase, bool must_modify) const {\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  static bool may_modify_helper(const TypeOopPtr *t_oop, Node* n, PhaseTransform *phase, CallNode*& call);\n+  static bool may_modify_helper(const TypeOopPtr* t_oop, Node* n, PhaseValues* phase, CallNode*& call);\n@@ -178,1 +178,1 @@\n-  virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase);\n+  virtual bool may_modify(const TypeOopPtr* t_oop, PhaseValues* phase);\n@@ -184,1 +184,1 @@\n-  static bool may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*& ac);\n+  static bool may_modify(const TypeOopPtr* t_oop, MemBarNode* mb, PhaseValues* phase, ArrayCopyNode*& ac);\n@@ -188,1 +188,1 @@\n-  bool modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const;\n+  bool modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseValues* phase, bool must_modify) const;\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -815,1 +815,1 @@\n-bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool CallNode::may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) {\n@@ -1805,1 +1805,1 @@\n-Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {\n+Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseValues* phase, bool allow_new_nodes) {\n@@ -2421,1 +2421,1 @@\n-bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase) {\n+bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-  bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseTransform* phase);\n+  bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr* t_oop, PhaseValues* phase);\n@@ -649,1 +649,1 @@\n-  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseTransform* phase);\n+  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseValues* phase);\n@@ -958,1 +958,1 @@\n-  virtual bool        may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) { return false;}\n+  virtual bool        may_modify(const TypeOopPtr* t_oop, PhaseValues* phase) { return false;}\n@@ -967,1 +967,1 @@\n-  static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase);\n+  static AllocateNode* Ideal_allocation(Node* ptr, PhaseValues* phase);\n@@ -972,1 +972,1 @@\n-  static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase,\n+  static AllocateNode* Ideal_allocation(Node* ptr, PhaseValues* phase,\n@@ -976,1 +976,1 @@\n-  static Node* Ideal_klass(Node* ptr, PhaseTransform* phase) {\n+  static Node* Ideal_klass(Node* ptr, PhaseValues* phase) {\n@@ -1045,1 +1045,1 @@\n-  Node* make_ideal_length(const TypeOopPtr* ary_type, PhaseTransform *phase, bool can_create = true);\n+  Node* make_ideal_length(const TypeOopPtr* ary_type, PhaseValues* phase, bool can_create = true);\n@@ -1049,1 +1049,1 @@\n-  static AllocateArrayNode* Ideal_array_allocation(Node* ptr, PhaseTransform* phase) {\n+  static AllocateArrayNode* Ideal_array_allocation(Node* ptr, PhaseValues* phase) {\n@@ -1119,1 +1119,1 @@\n-  virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase){ return false;}\n+  virtual bool may_modify(const TypeOopPtr* t_oop, PhaseValues* phase){ return false; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1100,3 +1100,2 @@\n-  Arena *a = Thread::current()->resource_area();\n-  Node_Array node_map = new Node_Array(a);\n-  Node_Stack stack(a, C->live_nodes() >> 4);\n+  Node_Array node_map;\n+  Node_Stack stack(C->live_nodes() >> 4);\n@@ -1485,1 +1484,1 @@\n-Node* PhiNode::unique_input(PhaseTransform* phase, bool uncast) {\n+Node* PhiNode::unique_input(PhaseValues* phase, bool uncast) {\n@@ -1550,0 +1549,6 @@\n+\n+  \/\/ If we're late in the optimization process, we may have already expanded Conv2B nodes\n+  if (phase->C->post_loop_opts_phase() && !Matcher::match_rule_supported(Op_Conv2B)) {\n+    return nullptr;\n+  }\n+\n@@ -1592,3 +1597,4 @@\n-  Node *n = new Conv2BNode(cmp->in(1));\n-  if( flipped )\n-    n = new XorINode( phase->transform(n), phase->intcon(1) );\n+  Node* n = new Conv2BNode(cmp->in(1));\n+  if (flipped) {\n+    n = new XorINode(phase->transform(n), phase->intcon(1));\n+  }\n@@ -1823,2 +1829,2 @@\n-      if (PhaseIdealLoop::find_parse_predicate(r->in(i)) != nullptr) {\n-        return nullptr;            \/\/ don't split loop entry path\n+      if (Node::may_be_loop_entry(r->in(i))) {\n+        return nullptr; \/\/ don't split loop entry path\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -221,2 +221,2 @@\n-  Node* unique_input(PhaseTransform *phase, bool uncast);\n-  Node* unique_input(PhaseTransform *phase) {\n+  Node* unique_input(PhaseValues* phase, bool uncast);\n+  Node* unique_input(PhaseValues* phase) {\n@@ -459,0 +459,20 @@\n+\/\/ Special node that denotes a Parse Predicate added during parsing. A Parse Predicate serves as placeholder to later\n+\/\/ create Runtime Predicates above it. They all share the same uncommon trap. The Parse Predicate will follow the\n+\/\/ Runtime Predicates. Together they form a Regular Predicate Block. There are three kinds of Parse Predicates:\n+\/\/ Loop Parse Predicate, Profiled Loop Parse Predicate (both used by Loop Predication), and Loop Limit Check Parse\n+\/\/ Predicate (used for integer overflow checks when creating a counted loop).\n+\/\/ More information about predicates can be found in loopPredicate.cpp.\n+class ParsePredicateNode : public IfNode {\n+  Deoptimization::DeoptReason _deopt_reason;\n+ public:\n+  ParsePredicateNode(Node* control, Node* bol, Deoptimization::DeoptReason deopt_reason);\n+  virtual int Opcode() const;\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+  Deoptimization::DeoptReason deopt_reason() const {\n+    return _deopt_reason;\n+  }\n+\n+  NOT_PRODUCT(void dump_spec(outputStream* st) const;)\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -84,2 +84,0 @@\n-macro(CMoveVD)\n-macro(CMoveVF)\n@@ -288,0 +286,1 @@\n+macro(ParsePredicate)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist) {\n@@ -437,1 +437,2 @@\n-      worklist->push(n->unique_out());\n+      assert(useful.member(n->unique_out()), \"do not push a useless node\");\n+      worklist.push(n->unique_out());\n@@ -440,1 +441,1 @@\n-      worklist->push(n);\n+      worklist.push(n);\n@@ -648,1 +649,3 @@\n-                  _for_igvn(nullptr),\n+                  _igvn_worklist(nullptr),\n+                  _types(nullptr),\n+                  _node_hash(nullptr),\n@@ -695,0 +698,1 @@\n+#endif\n@@ -699,1 +703,0 @@\n-#endif\n@@ -721,3 +724,0 @@\n-  \/\/ Node list that Iterative GVN will start with\n-  Unique_Node_List for_igvn(comp_arena());\n-  set_for_igvn(&for_igvn);\n@@ -728,1 +728,4 @@\n-  PhaseGVN gvn(node_arena(), estimated_size);\n+  _igvn_worklist = new (comp_arena()) Unique_Node_List(comp_arena());\n+  _types = new (comp_arena()) Type_Array(comp_arena());\n+  _node_hash = new (comp_arena()) NodeHash(comp_arena(), estimated_size);\n+  PhaseGVN gvn;\n@@ -816,1 +819,1 @@\n-      PhaseRemoveUseless pru(initial_gvn(), &for_igvn);\n+      PhaseRemoveUseless pru(initial_gvn(), *igvn_worklist());\n@@ -944,1 +947,3 @@\n-    _for_igvn(nullptr),\n+    _igvn_worklist(nullptr),\n+    _types(nullptr),\n+    _node_hash(nullptr),\n@@ -976,0 +981,3 @@\n+  _igvn_worklist = new (comp_arena()) Unique_Node_List(comp_arena());\n+  _types = new (comp_arena()) Type_Array(comp_arena());\n+  _node_hash = new (comp_arena()) NodeHash(comp_arena(), 255);\n@@ -977,4 +985,1 @@\n-    \/\/ The following is a dummy for the sake of GraphKit::gen_stub\n-    Unique_Node_List for_igvn(comp_arena());\n-    set_for_igvn(&for_igvn);  \/\/ not used, but some GraphKit guys push on this\n-    PhaseGVN gvn(Thread::current()->resource_area(),255);\n+    PhaseGVN gvn;\n@@ -2440,1 +2445,1 @@\n-    PhaseRemoveUseless pru(initial_gvn(), for_igvn());\n+    PhaseRemoveUseless pru(initial_gvn(), *igvn_worklist());\n@@ -2471,3 +2476,1 @@\n-    assert( igvn._worklist.size() == 0, \"should be done with igvn\" );\n-    for_igvn()->clear();\n-    gvn->replace_with(&igvn);\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2536,1 +2539,1 @@\n-    PhaseRemoveUseless pru(initial_gvn(), for_igvn());\n+    PhaseRemoveUseless pru(initial_gvn(), *igvn_worklist());\n@@ -2540,1 +2543,1 @@\n-    igvn = PhaseIterGVN(initial_gvn());\n+    igvn.reset_from_gvn(initial_gvn());\n@@ -2583,2 +2586,1 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2601,1 +2603,2 @@\n-  assert( igvn._worklist.size() == 0, \"should be done with igvn\" );\n+\n+  igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2605,2 +2608,0 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n@@ -2631,2 +2632,1 @@\n-    for_igvn()->clear();\n-    initial_gvn()->replace_with(&igvn);\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2766,4 +2766,1 @@\n-    initial_gvn()->replace_with(&igvn);\n-    Unique_Node_List* old_worklist = for_igvn();\n-    old_worklist->clear();\n-    Unique_Node_List new_worklist(C->comp_arena());\n+    igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -2772,1 +2769,1 @@\n-      PhaseRenumberLive prl = PhaseRenumberLive(initial_gvn(), for_igvn(), &new_worklist);\n+      PhaseRenumberLive prl(initial_gvn(), *igvn_worklist());\n@@ -2774,3 +2771,1 @@\n-    Unique_Node_List* save_for_igvn = for_igvn();\n-    set_for_igvn(&new_worklist);\n-    igvn = PhaseIterGVN(initial_gvn());\n+    igvn.reset_from_gvn(initial_gvn());\n@@ -2778,1 +2773,0 @@\n-    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -2880,1 +2874,1 @@\n-    igvn = ccp;\n+    igvn.reset_from_igvn(&ccp);\n@@ -2949,0 +2943,4 @@\n+ \/\/ We will never use the NodeHash table any more. Clear it so that final_graph_reshaping does not have\n+ \/\/ to remove hashes to unlock nodes for modifications.\n+ C->node_hash()->clear();\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":36,"deletions":38,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+class NodeHash;\n@@ -91,0 +92,1 @@\n+class Type_Array;\n@@ -424,1 +426,10 @@\n-  Unique_Node_List*     _for_igvn;              \/\/ Initial work-list for next round of Iterative GVN\n+\n+  \/\/ Shared worklist for all IGVN rounds. Nodes can be pushed to it at any time.\n+  \/\/ If pushed outside IGVN, the Node is processed in the next IGVN round.\n+  Unique_Node_List*     _igvn_worklist;\n+\n+  \/\/ Shared type array for GVN, IGVN and CCP. It maps node idx -> Type*.\n+  Type_Array*           _types;\n+\n+  \/\/ Shared node hash table for GVN, IGVN and CCP.\n+  NodeHash*             _node_hash;\n@@ -683,0 +694,6 @@\n+  void dump_igv(const char* graph_name, int level = 3) {\n+    if (should_print_igv(level)) {\n+      _igv_printer->print_method(graph_name, level);\n+    }\n+  }\n+\n@@ -966,1 +983,12 @@\n-  Unique_Node_List* for_igvn()                  { return _for_igvn; }\n+  Unique_Node_List* igvn_worklist() {\n+    assert(_igvn_worklist != nullptr, \"must be created in Compile::Compile\");\n+    return _igvn_worklist;\n+  }\n+  Type_Array* types() {\n+    assert(_types != nullptr, \"must be created in Compile::Compile\");\n+    return _types;\n+  }\n+  NodeHash* node_hash() {\n+    assert(_node_hash != nullptr, \"must be created in Compile::Compile\");\n+    return _node_hash;\n+  }\n@@ -970,1 +998,0 @@\n-  void          set_for_igvn(Unique_Node_List *for_igvn) { _for_igvn = for_igvn; }\n@@ -979,1 +1006,1 @@\n-  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n+  void              disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/connode.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"opto\/movenode.hpp\"\n@@ -73,0 +75,20 @@\n+  if (!Matcher::match_rule_supported(Op_Conv2B)) {\n+    if (phase->C->post_loop_opts_phase()) {\n+      \/\/ Get type of comparison to make\n+      const Type* t = phase->type(in(1));\n+      Node* cmp = nullptr;\n+      if (t->isa_int()) {\n+        cmp = phase->transform(new CmpINode(in(1), phase->intcon(0)));\n+      } else if (t->isa_ptr()) {\n+        cmp = phase->transform(new CmpPNode(in(1), phase->zerocon(BasicType::T_OBJECT)));\n+      } else {\n+        assert(false, \"Unrecognized comparison for Conv2B: %s\", NodeClassNames[in(1)->Opcode()]);\n+      }\n+\n+      \/\/ Replace Conv2B with the cmove\n+      Node* bol = phase->transform(new BoolNode(cmp, BoolTest::eq));\n+      return new CMoveINode(bol, phase->intcon(1), phase->intcon(0), TypeInt::BOOL);\n+    } else {\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1782,1 +1782,1 @@\n-int ConnectionGraph::find_init_values_null(JavaObjectNode* pta, PhaseTransform* phase) {\n+int ConnectionGraph::find_init_values_null(JavaObjectNode* pta, PhaseValues* phase) {\n@@ -2557,1 +2557,1 @@\n-int ConnectionGraph::address_offset(Node* adr, PhaseTransform *phase) {\n+int ConnectionGraph::address_offset(Node* adr, PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    _worklist_size = _gvn.C->for_igvn()->size();\n+    _worklist_size = _gvn.C->igvn_worklist()->size();\n@@ -3035,0 +3035,1 @@\n+      assert(!(*casted_receiver)->is_top(), \"that path should be unreachable\");\n@@ -3861,3 +3862,3 @@\n-  const TypeKlassPtr* inst_klass = _gvn.type(klass_node)->isa_klassptr();\n-  if (!StressReflectiveCode && inst_klass != nullptr) {\n-    bool xklass = inst_klass->klass_is_exact();\n+  const TypeKlassPtr* klass_t = _gvn.type(klass_node)->isa_klassptr();\n+  if (!StressReflectiveCode && klass_t != nullptr) {\n+    bool xklass = klass_t->klass_is_exact();\n@@ -3865,1 +3866,1 @@\n-    const TypeAryPtr* ary_type = inst_klass->as_instance_type()->isa_aryptr();\n+    const TypeAryPtr* ary_type = klass_t->as_instance_type()->isa_aryptr();\n@@ -3871,1 +3872,1 @@\n-    if (!can_be_flattened && (xklass || inst_klass->isa_aryklassptr())) {\n+    if (!can_be_flattened && (xklass || (klass_t->isa_aryklassptr() && klass_t->is_aryklassptr()->elem() != Type::BOTTOM))) {\n@@ -3873,1 +3874,1 @@\n-      if (inst_klass->is_flat()) {\n+      if (klass_t->is_flat()) {\n@@ -3875,1 +3876,1 @@\n-      } else if (inst_klass->isa_aryklassptr()) {\n+      } else if (klass_t->isa_aryklassptr()) {\n@@ -3882,1 +3883,1 @@\n-        lhelper = inst_klass->is_instklassptr()->exact_klass()->layout_helper();\n+        lhelper = klass_t->is_instklassptr()->exact_klass()->layout_helper();\n@@ -4357,1 +4358,1 @@\n-AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseTransform* phase) {\n+AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseValues* phase) {\n@@ -4384,1 +4385,1 @@\n-AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseTransform* phase,\n+AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseValues* phase,\n@@ -4435,6 +4436,7 @@\n-  Node* cont    = _gvn.intcon(1);\n-  Node* opq     = _gvn.transform(new Opaque1Node(C, cont));\n-  Node* bol     = _gvn.transform(new Conv2BNode(opq));\n-  IfNode* iff   = create_and_map_if(control(), bol, PROB_MAX, COUNT_UNKNOWN);\n-  Node* iffalse = _gvn.transform(new IfFalseNode(iff));\n-  C->add_parse_predicate_opaq(opq);\n+  Node* cont = _gvn.intcon(1);\n+  Node* opaq = _gvn.transform(new Opaque1Node(C, cont));\n+  C->add_parse_predicate_opaq(opaq);\n+  Node* bol = _gvn.transform(new Conv2BNode(opaq));\n+  ParsePredicateNode* parse_predicate = new ParsePredicateNode(control(), bol, reason);\n+  _gvn.set_type(parse_predicate, parse_predicate->Value(&_gvn));\n+  Node* if_false = _gvn.transform(new IfFalseNode(parse_predicate));\n@@ -4443,1 +4445,1 @@\n-    set_control(iffalse);\n+    set_control(if_false);\n@@ -4447,2 +4449,2 @@\n-  Node* iftrue = _gvn.transform(new IfTrueNode(iff));\n-  set_control(iftrue);\n+  Node* if_true = _gvn.transform(new IfTrueNode(parse_predicate));\n+  set_control(if_true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#if 0\n@@ -95,0 +96,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,3 +245,2 @@\n-    Node* proj = PhaseIdealLoop::find_parse_predicate(r->in(ii));\n-    if (proj != nullptr) {\n-      \/\/ Bail out if splitting through a region with a predicate input (could\n+    if (Node::may_be_loop_entry(r->in(ii))) {\n+      \/\/ Bail out if splitting through a region with a Parse Predicate input (could\n@@ -1989,0 +1988,36 @@\n+\n+ParsePredicateNode::ParsePredicateNode(Node* control, Node* bol, Deoptimization::DeoptReason deopt_reason)\n+    : IfNode(control, bol, PROB_MAX, COUNT_UNKNOWN),\n+      _deopt_reason(deopt_reason) {\n+  init_class_id(Class_ParsePredicate);\n+  assert(bol->Opcode() == Op_Conv2B && bol->in(1) != nullptr && bol->in(1)->is_Opaque1(), \"wrong boolean input\");\n+#ifdef ASSERT\n+  switch (deopt_reason) {\n+    case Deoptimization::Reason_predicate:\n+    case Deoptimization::Reason_profile_predicate:\n+    case Deoptimization::Reason_loop_limit_check:\n+      break;\n+    default:\n+      assert(false, \"unsupported deoptimization reason for Parse Predicate\");\n+  }\n+#endif \/\/ ASSERT\n+}\n+\n+#ifndef PRODUCT\n+void ParsePredicateNode::dump_spec(outputStream* st) const {\n+  st->print(\" #\");\n+  switch (_deopt_reason) {\n+    case Deoptimization::DeoptReason::Reason_predicate:\n+      st->print(\"Loop \");\n+      break;\n+    case Deoptimization::DeoptReason::Reason_profile_predicate:\n+      st->print(\"Profiled_Loop \");\n+      break;\n+    case Deoptimization::DeoptReason::Reason_loop_limit_check:\n+      st->print(\"Loop_Limit_Check \");\n+      break;\n+    default:\n+      fatal(\"unknown kind\");\n+  }\n+}\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1297,1 +1297,1 @@\n-    Node_Array inputs = new Node_List();\n+    Node_Array inputs;\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-\n@@ -150,3 +149,1 @@\n-  if (find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check) != nullptr\n-      || (UseProfiledLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate) != nullptr)\n-      || (UseLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_predicate) != nullptr)) {\n+  if (ParsePredicates::is_success_proj(entry)) {\n@@ -190,2 +187,2 @@\n-  Node* parse_predicate = find_parse_predicate(entry);\n-  if (parse_predicate == nullptr) {\n+  ParsePredicates parse_predicates(entry);\n+  if (!parse_predicates.has_any()) {\n@@ -197,16 +194,4 @@\n-    \/\/ There is at least one Parse Predicate. When calling 'skip_related_predicates' on each found Parse Predicate,\n-    \/\/ we should end up at 'proj_true'.\n-    Node* proj_before_first_parse_predicate = skip_related_predicates(entry);\n-    if (UseProfiledLoopPredicate) {\n-      parse_predicate = find_parse_predicate(proj_before_first_parse_predicate);\n-      if (parse_predicate != nullptr) {\n-        proj_before_first_parse_predicate = skip_related_predicates(parse_predicate);\n-      }\n-    }\n-    if (UseLoopPredicate) {\n-      parse_predicate = find_parse_predicate(proj_before_first_parse_predicate);\n-      if (parse_predicate != nullptr) {\n-        proj_before_first_parse_predicate = skip_related_predicates(parse_predicate);\n-      }\n-    }\n-    assert(proj_true == proj_before_first_parse_predicate, \"must hold by construction if at least one predicate\");\n+    \/\/ There is at least one Parse Predicate. When skipping all predicates\/Regular Predicate Blocks, we should end up\n+    \/\/ at 'proj_true'.\n+    assert(proj_true == Predicates::skip_all_predicates(parse_predicates),\n+           \"must hold by construction if at least one Parse Predicate\");\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+class ParsePredicates;\n@@ -147,1 +148,1 @@\n-  bool can_be_counted_loop(PhaseTransform* phase) const {\n+  bool can_be_counted_loop(PhaseValues* phase) const {\n@@ -738,2 +739,2 @@\n-  bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const;\n-  bool is_range_check_if(IfNode* iff, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n+  bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop* phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode* predicate_proj)) const;\n+  bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n@@ -837,0 +838,3 @@\n+  \/\/ Map loop membership for CFG nodes, and ctrl for non-CFG nodes.\n+  Node_List _loop_or_ctrl;\n+\n@@ -898,1 +902,1 @@\n-  bool has_ctrl(const Node* n) const { return ((intptr_t)_nodes[n->_idx]) & 1; }\n+  bool has_ctrl(const Node* n) const { return ((intptr_t)_loop_or_ctrl[n->_idx]) & 1; }\n@@ -903,0 +907,1 @@\n+  Node_List _zero_trip_guard_opaque_nodes;\n@@ -985,1 +990,1 @@\n-    return _nodes[n->_idx] != nullptr;\n+    return _loop_or_ctrl[n->_idx] != nullptr;\n@@ -997,1 +1002,1 @@\n-    _nodes.map( n->_idx, (Node*)((intptr_t)ctrl + 1) );\n+    _loop_or_ctrl.map(n->_idx, (Node*)((intptr_t)ctrl + 1));\n@@ -1017,1 +1022,1 @@\n-    _nodes.map( i->_idx, (Node*)((intptr_t)n + 1) );\n+    _loop_or_ctrl.map(i->_idx, (Node*)((intptr_t)n + 1));\n@@ -1036,1 +1041,1 @@\n-    return (Node*)(((intptr_t)_nodes[i->_idx]) & ~1);\n+    return (Node*)(((intptr_t)_loop_or_ctrl[i->_idx]) & ~1);\n@@ -1060,1 +1065,1 @@\n-    _nodes.map(n->_idx, (Node*)loop);\n+    _loop_or_ctrl.map(n->_idx, (Node*)loop);\n@@ -1070,1 +1075,1 @@\n-    _nodes.map(old_node->_idx, (Node*)((intptr_t)new_node + 1));\n+    _loop_or_ctrl.map(old_node->_idx, (Node*)((intptr_t)new_node + 1));\n@@ -1149,1 +1154,1 @@\n-      n = (Node*)(((intptr_t)_nodes[n->_idx]) & ~1);\n+      n = (Node*)(((intptr_t)_loop_or_ctrl[n->_idx]) & ~1);\n@@ -1245,1 +1250,1 @@\n-    return (IdealLoopTree*)_nodes[n->_idx];\n+    return (IdealLoopTree*)_loop_or_ctrl[n->_idx];\n@@ -1366,45 +1371,2 @@\n-  static Node* skip_all_predicates(Node* entry);\n-  static Node* skip_related_predicates(Node* entry);\n-  static IfProjNode* next_predicate(IfProjNode* predicate_proj);\n-\n-  \/\/ Find a good location to insert a predicate\n-  static ParsePredicateSuccessProj* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);\n-\n-  class ParsePredicates {\n-   private:\n-    ParsePredicateSuccessProj* _loop_predicate = nullptr;\n-    ParsePredicateSuccessProj* _profiled_loop_predicate = nullptr;\n-    ParsePredicateSuccessProj* _loop_limit_check_predicate = nullptr;\n-    Node* _first_predicate = nullptr;\n-   public:\n-    \/\/ given loop entry, find all predicates above loop\n-    ParsePredicates(Node* entry);\n-\n-    \/\/ Proj of Loop Limit Check Parse Predicate.\n-    ParsePredicateSuccessProj* loop_limit_check_predicate() {\n-      return _loop_limit_check_predicate;\n-    }\n-\n-    \/\/ Proj of Profile Loop Parse Predicate.\n-    ParsePredicateSuccessProj* profiled_loop_predicate() {\n-      return _profiled_loop_predicate;\n-    }\n-\n-    \/\/ Proj of Loop Parse Predicate.\n-    ParsePredicateSuccessProj* loop_predicate() {\n-      return _loop_predicate;\n-    }\n-\n-    \/\/ Proj of first Parse Predicate when walking the graph down from root.\n-    Node* get_first_predicate() {\n-      return _first_predicate;\n-    }\n-  };\n-\n-  \/\/ Find a predicate\n-  static Node* find_parse_predicate(Node* entry);\n-  BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,\n-                         int scale, Node* offset,\n-                         Node* init, Node* limit, jint stride,\n-                         Node* range, bool upper, bool &overflow,\n-                         bool negate);\n+  BoolNode* rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init, Node* limit,\n+                         jint stride, Node* range, bool upper, bool& overflow);\n@@ -1415,1 +1377,1 @@\n-  bool loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_proj,\n+  bool loop_predication_impl_helper(IdealLoopTree* loop, IfProjNode* if_success_proj,\n@@ -1431,0 +1393,1 @@\n+  void eliminate_useless_zero_trip_guard();\n@@ -1526,1 +1489,1 @@\n-  void register_node(Node* n, IdealLoopTree *loop, Node* pred, int ddepth);\n+  void register_node(Node* n, IdealLoopTree* loop, Node* pred, uint ddepth);\n@@ -1688,1 +1651,1 @@\n-  static void check_cloned_parse_predicate_for_unswitching(const Node* new_entry) PRODUCT_RETURN;\n+  static void check_cloned_parse_predicate_for_unswitching(const Node* new_entry, bool is_fast_loop) PRODUCT_RETURN;\n@@ -1711,1 +1674,1 @@\n-    return _nodes[n->_idx] ? (IdealLoopTree*)_nodes[n->_idx] : _ltree_root;\n+    return _loop_or_ctrl[n->_idx] ? (IdealLoopTree*)_loop_or_ctrl[n->_idx] : _ltree_root;\n@@ -1726,1 +1689,1 @@\n-  bool verify_nodes(Node* n, const PhaseIdealLoop* phase_verify) const;\n+  bool verify_loop_ctrl(Node* n, const PhaseIdealLoop* phase_verify) const;\n@@ -1960,0 +1923,59 @@\n+\/\/ Utility class to work on predicates.\n+class Predicates {\n+ public:\n+  static Node* skip_all_predicates(Node* node);\n+  static Node* skip_all_predicates(ParsePredicates& parse_predicates);\n+  static Node* skip_predicates_in_block(ParsePredicateSuccessProj* parse_predicate_success_proj);\n+  static IfProjNode* next_predicate_proj_in_block(IfProjNode* proj);\n+  static bool has_profiled_loop_predicates(ParsePredicates& parse_predicates);\n+};\n+\n+\/\/ Class representing the Parse Predicates that are added during parsing with ParsePredicateNodes.\n+class ParsePredicates {\n+ private:\n+  ParsePredicateSuccessProj* _loop_predicate_proj = nullptr;\n+  ParsePredicateSuccessProj* _profiled_loop_predicate_proj = nullptr;\n+  ParsePredicateSuccessProj* _loop_limit_check_predicate_proj = nullptr;\n+  \/\/ The success projection of the Parse Predicate that comes first when starting from root.\n+  ParsePredicateSuccessProj* _top_predicate_proj;\n+  ParsePredicateSuccessProj* _starting_proj;\n+\n+  void find_parse_predicate_projections();\n+  static bool is_uct_proj(Node* node, Deoptimization::DeoptReason deopt_reason);\n+  static ParsePredicateNode* get_parse_predicate_or_null(Node* proj);\n+  bool assign_predicate_proj(ParsePredicateSuccessProj* parse_predicate_proj);\n+ public:\n+  ParsePredicates(Node* starting_proj);\n+\n+  \/\/ Success projection of Loop Parse Predicate.\n+  ParsePredicateSuccessProj* loop_predicate_proj() {\n+    return _loop_predicate_proj;\n+  }\n+\n+  \/\/ Success proj of Profiled Loop Parse Predicate.\n+  ParsePredicateSuccessProj* profiled_loop_predicate_proj() {\n+    return _profiled_loop_predicate_proj;\n+  }\n+\n+  \/\/ Success proj of Loop Limit Check Parse Predicate.\n+  ParsePredicateSuccessProj* loop_limit_check_predicate_proj() {\n+    return _loop_limit_check_predicate_proj;\n+  }\n+\n+  \/\/ Return the success projection of the Parse Predicate that comes first when starting from root.\n+  ParsePredicateSuccessProj* get_top_predicate_proj() {\n+    return _top_predicate_proj;\n+  }\n+\n+  static bool is_success_proj(Node* node);\n+\n+  \/\/ Are there any Parse Predicates?\n+  bool has_any() const {\n+    return _top_predicate_proj != nullptr;\n+  }\n+\n+  static bool is_loop_limit_check_predicate_proj(Node* node) {\n+    ParsePredicateNode* parse_predicate = get_parse_predicate_or_null(node);\n+    return parse_predicate != nullptr && parse_predicate->deopt_reason() == Deoptimization::DeoptReason::Reason_loop_limit_check;\n+  }\n+};\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":84,"deletions":62,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -272,1 +272,2 @@\n-         iff->Opcode() == Op_RangeCheck,\n+         iff->Opcode() == Op_RangeCheck ||\n+         iff->Opcode() == Op_ParsePredicate,\n@@ -2894,1 +2895,1 @@\n-void PhaseIdealLoop::register_node(Node* n, IdealLoopTree *loop, Node* pred, int ddepth) {\n+void PhaseIdealLoop::register_node(Node* n, IdealLoopTree* loop, Node* pred, uint ddepth) {\n@@ -2953,1 +2954,1 @@\n-  int ddepth = dom_depth(proj);\n+  uint ddepth = dom_depth(proj);\n@@ -3014,1 +3015,1 @@\n-  int ddepth = dom_depth(proj);\n+  uint ddepth = dom_depth(proj);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  _new_nodes(C->comp_arena()),\n@@ -2429,14 +2430,0 @@\n-    case Op_CMoveVF:\n-    case Op_CMoveVD: {\n-      \/\/ Restructure into a binary tree for Matching:\n-      \/\/ CMoveVF (Binary bool mask) (Binary src1 src2)\n-      Node* in_cc = n->in(1);\n-      assert(in_cc->is_Con(), \"The condition input of cmove vector node must be a constant.\");\n-      Node* bol = new BoolNode(in_cc, (BoolTest::mask)in_cc->get_int());\n-      Node* pair1 = new BinaryNode(bol, in_cc);\n-      n->set_req(1, pair1);\n-      Node* pair2 = new BinaryNode(n->in(2), n->in(3));\n-      n->set_req(2, pair2);\n-      n->del_req(3);\n-      break;\n-    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -91,0 +91,3 @@\n+  \/\/ Map old nodes to new nodes\n+  Node_List   _new_nodes;\n+\n@@ -150,2 +153,1 @@\n-  \/\/ Accessors for the inherited field PhaseTransform::_nodes:\n-    _nodes.map(idx_limit-1, nullptr);\n+    _new_nodes.map(idx_limit-1, nullptr);\n@@ -155,1 +157,1 @@\n-    return _nodes.at(n->_idx) != nullptr;\n+    return _new_nodes.at(n->_idx) != nullptr;\n@@ -159,1 +161,1 @@\n-    return _nodes.at(n->_idx);\n+    return _new_nodes.at(n->_idx);\n@@ -163,1 +165,1 @@\n-    _nodes.map(n->_idx, nn);\n+    _new_nodes.map(n->_idx, nn);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-Node* LoadNode::find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const {\n+Node* LoadNode::find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const {\n@@ -616,1 +616,1 @@\n-ArrayCopyNode* MemNode::find_array_copy_clone(PhaseTransform* phase, Node* ld_alloc, Node* mem) const {\n+ArrayCopyNode* MemNode::find_array_copy_clone(PhaseValues* phase, Node* ld_alloc, Node* mem) const {\n@@ -660,1 +660,1 @@\n-Node* MemNode::find_previous_store(PhaseTransform* phase) {\n+Node* MemNode::find_previous_store(PhaseValues* phase) {\n@@ -1063,1 +1063,1 @@\n-Node* MemNode::can_see_stored_value(Node* st, PhaseTransform* phase) const {\n+Node* MemNode::can_see_stored_value(Node* st, PhaseValues* phase) const {\n@@ -2441,1 +2441,1 @@\n-  if (tary != nullptr && tary->elem() != Type::BOTTOM &&\n+  if (tary != nullptr &&\n@@ -2930,1 +2930,1 @@\n-bool StoreNode::value_never_loaded( PhaseTransform *phase) const {\n+bool StoreNode::value_never_loaded(PhaseValues* phase) const {\n@@ -3224,1 +3224,1 @@\n-bool ClearArrayNode::step_through(Node** np, uint instance_id, PhaseTransform* phase) {\n+bool ClearArrayNode::step_through(Node** np, uint instance_id, PhaseValues* phase) {\n@@ -3798,1 +3798,1 @@\n-intptr_t InitializeNode::get_store_offset(Node* st, PhaseTransform* phase) {\n+intptr_t InitializeNode::get_store_offset(Node* st, PhaseValues* phase) {\n@@ -3998,1 +3998,1 @@\n-                                                   PhaseTransform* phase) {\n+                                                   PhaseValues* phase) {\n@@ -4052,1 +4052,1 @@\n-                                          PhaseTransform* phase) {\n+                                          PhaseValues* phase) {\n@@ -4068,1 +4068,1 @@\n-                                       PhaseTransform* phase) {\n+                                       PhaseGVN* phase) {\n@@ -4616,1 +4616,1 @@\n-bool InitializeNode::stores_are_sane(PhaseTransform* phase) {\n+bool InitializeNode::stores_are_sane(PhaseValues* phase) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return nullptr; }\n-  ArrayCopyNode* find_array_copy_clone(PhaseTransform* phase, Node* ld_alloc, Node* mem) const;\n+  virtual Node* find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return nullptr; }\n+  ArrayCopyNode* find_array_copy_clone(PhaseValues* phase, Node* ld_alloc, Node* mem) const;\n@@ -153,1 +153,1 @@\n-  Node* find_previous_store(PhaseTransform* phase);\n+  Node* find_previous_store(PhaseValues* phase);\n@@ -157,1 +157,1 @@\n-  Node* can_see_stored_value(Node* st, PhaseTransform* phase) const;\n+  Node* can_see_stored_value(Node* st, PhaseValues* phase) const;\n@@ -215,1 +215,1 @@\n-  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const;\n+  virtual Node* find_previous_arraycopy(PhaseValues* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const;\n@@ -639,1 +639,1 @@\n-  bool value_never_loaded(PhaseTransform *phase) const;\n+  bool value_never_loaded(PhaseValues* phase) const;\n@@ -1131,1 +1131,1 @@\n-  static bool step_through(Node** np, uint instance_id, PhaseTransform* phase);\n+  static bool step_through(Node** np, uint instance_id, PhaseValues* phase);\n@@ -1368,1 +1368,1 @@\n-  bool stores_are_sane(PhaseTransform* phase);\n+  bool stores_are_sane(PhaseValues* phase);\n@@ -1382,1 +1382,1 @@\n-  Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseTransform* phase);\n+  Node* find_captured_store(intptr_t start, int size_in_bytes, PhaseValues* phase);\n@@ -1394,1 +1394,1 @@\n-                                     PhaseTransform* phase);\n+                                     PhaseValues* phase);\n@@ -1396,1 +1396,1 @@\n-  static intptr_t get_store_offset(Node* st, PhaseTransform* phase);\n+  static intptr_t get_store_offset(Node* st, PhaseValues* phase);\n@@ -1398,1 +1398,1 @@\n-  Node* make_raw_address(intptr_t offset, PhaseTransform* phase);\n+  Node* make_raw_address(intptr_t offset, PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+class ParsePredicateNode;\n@@ -675,0 +676,1 @@\n+          DEFINE_CLASS_ID(ParsePredicate,         If, 3)\n@@ -958,0 +960,1 @@\n+  DEFINE_CLASS_QUERY(ParsePredicate)\n@@ -1042,0 +1045,5 @@\n+  \/\/ Is 'n' possibly a loop entry (i.e. a Parse Predicate projection)?\n+  static bool may_be_loop_entry(Node* n) {\n+    return n != nullptr && n->is_IfProj() && n->in(0)->is_ParsePredicate();\n+  }\n+\n@@ -1560,0 +1568,6 @@\n+  Node_Array() : Node_Array(Thread::current()->resource_area()) {}\n+\n+  NONCOPYABLE(Node_Array);\n+  Node_Array& operator=(Node_Array&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Node_Array(Node_Array&&) = default;\n@@ -1561,1 +1575,0 @@\n-  Node_Array(Node_Array* na) : _a(na->_a), _max(na->_max), _nodes(na->_nodes) {}\n@@ -1585,0 +1598,6 @@\n+\n+  NONCOPYABLE(Node_List);\n+  Node_List& operator=(Node_List&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Node_List(Node_List&&) = default;\n+\n@@ -1619,0 +1638,5 @@\n+  NONCOPYABLE(Unique_Node_List);\n+  Unique_Node_List& operator=(Unique_Node_List&&) = delete;\n+  \/\/ Allow move constructor for && (eg. capture return of function)\n+  Unique_Node_List(Unique_Node_List&&) = default;\n+\n@@ -1650,0 +1674,4 @@\n+  void ensure_empty() {\n+    assert(size() == 0, \"must be empty\");\n+    clear(); \/\/ just in case\n+  }\n@@ -1654,0 +1682,21 @@\n+  \/\/ If the idx of the Nodes change, we must recompute the VectorSet\n+  void recompute_idx_set() {\n+    _in_worklist.clear();\n+    for (uint i = 0; i < size(); i++) {\n+      Node* n = at(i);\n+      _in_worklist.set(n->_idx);\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  bool is_subset_of(Unique_Node_List& other) {\n+    for (uint i = 0; i < size(); i++) {\n+      Node* n = at(i);\n+      if (!other.member(n)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+#endif\n+\n@@ -1696,1 +1745,1 @@\n-  _for_igvn->push(n);\n+  _igvn_worklist->push(n);\n@@ -1701,1 +1750,1 @@\n-  _for_igvn->remove(n);\n+  _igvn_worklist->remove(n);\n@@ -1772,0 +1821,2 @@\n+\n+  NONCOPYABLE(Node_Stack);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":54,"deletions":3,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -46,16 +46,0 @@\n-\/\/------------------------------NodeHash---------------------------------------\n-NodeHash::NodeHash(uint est_max_size) :\n-  _a(Thread::current()->resource_area()),\n-  _max( round_up(est_max_size < NODE_HASH_MINIMUM_SIZE ? NODE_HASH_MINIMUM_SIZE : est_max_size) ),\n-  _inserts(0), _insert_limit( insert_limit() ),\n-  _table( NEW_ARENA_ARRAY( _a , Node* , _max ) ) \/\/ (Node**)_a->Amalloc(_max * sizeof(Node*)) ),\n-#ifndef PRODUCT\n-  , _grows(0),_look_probes(0), _lookup_hits(0), _lookup_misses(0),\n-  _insert_probes(0), _delete_probes(0), _delete_hits(0), _delete_misses(0),\n-   _total_inserts(0), _total_insert_probes(0)\n-#endif\n-{\n-  \/\/ _sentinel must be in the current node space\n-  _sentinel = new ProjNode(nullptr, TypeFunc::Control);\n-  memset(_table,0,sizeof(Node*)*_max);\n-}\n@@ -80,15 +64,0 @@\n-\/\/------------------------------NodeHash---------------------------------------\n-NodeHash::NodeHash(NodeHash *nh) {\n-  debug_only(_table = (Node**)badAddress);   \/\/ interact correctly w\/ operator=\n-  \/\/ just copy in all the fields\n-  *this = *nh;\n-  \/\/ nh->_sentinel must be in the current node space\n-}\n-\n-void NodeHash::replace_with(NodeHash *nh) {\n-  debug_only(_table = (Node**)badAddress);   \/\/ interact correctly w\/ operator=\n-  \/\/ just copy in all the fields\n-  *this = *nh;\n-  \/\/ nh->_sentinel must be in the current node space\n-}\n-\n@@ -391,12 +360,0 @@\n-\n-void NodeHash::operator=(const NodeHash& nh) {\n-  \/\/ Unlock all nodes upon replacement of table.\n-  if (&nh == this)  return;\n-  if (_table != (Node**)badAddress)  clear();\n-  memcpy((void*)this, (void*)&nh, sizeof(*this));\n-  \/\/ Do not increment hash_lock counts again.\n-  \/\/ Instead, be sure we never again use the source table.\n-  ((NodeHash*)&nh)->_table = (Node**)badAddress;\n-}\n-\n-\n@@ -409,1 +366,1 @@\n-PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN* gvn, Unique_Node_List* worklist, PhaseNumber phase_num) : Phase(phase_num) {\n+PhaseRemoveUseless::PhaseRemoveUseless(PhaseGVN* gvn, Unique_Node_List& worklist, PhaseNumber phase_num) : Phase(phase_num) {\n@@ -423,1 +380,1 @@\n-  worklist->remove_useless_nodes(_useful.member_set());\n+  worklist.remove_useless_nodes(_useful.member_set());\n@@ -443,8 +400,5 @@\n-\/\/ (1) The worklist is used by the PhaseIterGVN phase to identify nodes that must be\n-\/\/ processed. A new worklist (with the updated node IDs) is returned in 'new_worklist'.\n-\/\/ 'worklist' is cleared upon returning.\n-\/\/ (2) Type information (the field PhaseGVN::_types) maps type information to each\n-\/\/ node ID. The mapping is updated to use the new node IDs as well. Updated type\n-\/\/ information is returned in PhaseGVN::_types.\n-\/\/\n-\/\/ The PhaseRenumberLive phase does not preserve the order of elements in the worklist.\n+\/\/ (1) The \"worklist\" is \"C->igvn_worklist()\", which is to collect which nodes need to\n+\/\/     be processed by IGVN after removal of the useless nodes.\n+\/\/ (2) Type information \"gvn->types()\" (same as \"C->types()\") maps every node ID to\n+\/\/     the node's type. The mapping is updated to use the new node IDs as well. We\n+\/\/     create a new map, and swap it with the old one.\n@@ -453,3 +407,2 @@\n-\/\/ numbering (the field PhaseGVN::_table) is not updated because computing the hash\n-\/\/ values is not based on node IDs. The field PhaseGVN::_nodes is not updated either\n-\/\/ because it is empty wherever PhaseRenumberLive is used.\n+\/\/ numbering (\"C->node_hash()\", referenced by PhaseValue::_table) is not updated because\n+\/\/ computing the hash values is not based on node IDs.\n@@ -457,1 +410,1 @@\n-                                     Unique_Node_List* worklist, Unique_Node_List* new_worklist,\n+                                     Unique_Node_List& worklist,\n@@ -467,3 +420,2 @@\n-  assert(gvn->nodes_size() == 0, \"GVN must not contain any nodes at this point\");\n-\n-  uint worklist_size = worklist->size();\n+  assert(&worklist == C->igvn_worklist(), \"reference still same as the one from Compile\");\n+  assert(&gvn->types() == C->types(), \"reference still same as that from Compile\");\n@@ -480,0 +432,2 @@\n+  assert(worklist.is_subset_of(_useful), \"only useful nodes should still be in the worklist\");\n+\n@@ -484,5 +438,0 @@\n-    bool in_worklist = false;\n-    if (worklist->member(n)) {\n-      in_worklist = true;\n-    }\n-\n@@ -502,4 +451,0 @@\n-    if (in_worklist) {\n-      new_worklist->push(n);\n-    }\n-\n@@ -511,1 +456,3 @@\n-  assert(worklist_size == new_worklist->size(), \"the new worklist must have the same size as the original worklist\");\n+  \/\/ VectorSet in Unique_Node_Set must be recomputed, since IDs have changed.\n+  worklist.recompute_idx_set();\n+\n@@ -523,1 +470,1 @@\n-  gvn->replace_types(_new_type_array);\n+  gvn->types().swap(_new_type_array);\n@@ -530,3 +477,0 @@\n-\n-  \/\/ Clear the original worklist\n-  worklist->clear();\n@@ -584,49 +528,1 @@\n-\/\/=============================================================================\n-\/\/------------------------------PhaseTransform---------------------------------\n-PhaseTransform::PhaseTransform( PhaseNumber pnum ) : Phase(pnum),\n-  _arena(Thread::current()->resource_area()),\n-  _nodes(_arena),\n-  _types(_arena)\n-{\n-  init_con_caches();\n-#ifndef PRODUCT\n-  clear_progress();\n-  clear_transforms();\n-  set_allow_progress(true);\n-#endif\n-  \/\/ Force allocation for currently existing nodes\n-  _types.map(C->unique(), nullptr);\n-}\n-\n-\/\/------------------------------PhaseTransform---------------------------------\n-PhaseTransform::PhaseTransform( Arena *arena, PhaseNumber pnum ) : Phase(pnum),\n-  _arena(arena),\n-  _nodes(arena),\n-  _types(arena)\n-{\n-  init_con_caches();\n-#ifndef PRODUCT\n-  clear_progress();\n-  clear_transforms();\n-  set_allow_progress(true);\n-#endif\n-  \/\/ Force allocation for currently existing nodes\n-  _types.map(C->unique(), nullptr);\n-}\n-\n-\/\/------------------------------PhaseTransform---------------------------------\n-\/\/ Initialize with previously generated type information\n-PhaseTransform::PhaseTransform( PhaseTransform *pt, PhaseNumber pnum ) : Phase(pnum),\n-  _arena(pt->_arena),\n-  _nodes(pt->_nodes),\n-  _types(pt->_types)\n-{\n-  init_con_caches();\n-#ifndef PRODUCT\n-  clear_progress();\n-  clear_transforms();\n-  set_allow_progress(true);\n-#endif\n-}\n-\n-void PhaseTransform::init_con_caches() {\n+void PhaseValues::init_con_caches() {\n@@ -638,2 +534,1 @@\n-\n-const TypeInt* PhaseTransform::find_int_type(Node* n) {\n+const TypeInt* PhaseValues::find_int_type(Node* n) {\n@@ -652,1 +547,1 @@\n-const TypeLong* PhaseTransform::find_long_type(Node* n) {\n+const TypeLong* PhaseValues::find_long_type(Node* n) {\n@@ -660,61 +555,0 @@\n-\n-#ifndef PRODUCT\n-void PhaseTransform::dump_old2new_map() const {\n-  _nodes.dump();\n-}\n-\n-void PhaseTransform::dump_new( uint nidx ) const {\n-  for( uint i=0; i<_nodes.max(); i++ )\n-    if( _nodes[i] && _nodes[i]->_idx == nidx ) {\n-      _nodes[i]->dump();\n-      tty->cr();\n-      tty->print_cr(\"Old index= %d\",i);\n-      return;\n-    }\n-  tty->print_cr(\"Node %d not found in the new indices\", nidx);\n-}\n-\n-\/\/------------------------------dump_types-------------------------------------\n-void PhaseTransform::dump_types( ) const {\n-  _types.dump();\n-}\n-\n-\/\/------------------------------dump_nodes_and_types---------------------------\n-void PhaseTransform::dump_nodes_and_types(const Node* root, uint depth, bool only_ctrl) {\n-  VectorSet visited;\n-  dump_nodes_and_types_recur(root, depth, only_ctrl, visited);\n-}\n-\n-\/\/------------------------------dump_nodes_and_types_recur---------------------\n-void PhaseTransform::dump_nodes_and_types_recur( const Node *n, uint depth, bool only_ctrl, VectorSet &visited) {\n-  if( !n ) return;\n-  if( depth == 0 ) return;\n-  if( visited.test_set(n->_idx) ) return;\n-  for( uint i=0; i<n->len(); i++ ) {\n-    if( only_ctrl && !(n->is_Region()) && i != TypeFunc::Control ) continue;\n-    dump_nodes_and_types_recur( n->in(i), depth-1, only_ctrl, visited );\n-  }\n-  n->dump();\n-  if (type_or_null(n) != nullptr) {\n-    tty->print(\"      \"); type(n)->dump(); tty->cr();\n-  }\n-}\n-\n-#endif\n-\n-\n-\/\/=============================================================================\n-\/\/------------------------------PhaseValues------------------------------------\n-\/\/ Set minimum table size to \"255\"\n-PhaseValues::PhaseValues( Arena *arena, uint est_max_size )\n-  : PhaseTransform(arena, GVN), _table(arena, est_max_size), _iterGVN(false) {\n-  NOT_PRODUCT( clear_new_values(); )\n-}\n-\n-\/\/------------------------------PhaseValues------------------------------------\n-\/\/ Set minimum table size to \"255\"\n-PhaseValues::PhaseValues(PhaseValues* ptv)\n-  : PhaseTransform(ptv, GVN), _table(&ptv->_table), _iterGVN(false) {\n-  NOT_PRODUCT( clear_new_values(); )\n-}\n-\n@@ -724,0 +558,1 @@\n+  \/\/ Statistics for NodeHash\n@@ -725,1 +560,0 @@\n-\n@@ -740,1 +574,1 @@\n-ConNode* PhaseTransform::makecon(const Type *t) {\n+ConNode* PhaseValues::makecon(const Type* t) {\n@@ -777,1 +611,1 @@\n-ConINode* PhaseTransform::intcon(jint i) {\n+ConINode* PhaseValues::intcon(jint i) {\n@@ -793,1 +627,1 @@\n-ConLNode* PhaseTransform::longcon(jlong l) {\n+ConLNode* PhaseValues::longcon(jlong l) {\n@@ -806,1 +640,1 @@\n-ConNode* PhaseTransform::integercon(jlong l, BasicType bt) {\n+ConNode* PhaseValues::integercon(jlong l, BasicType bt) {\n@@ -817,1 +651,1 @@\n-ConNode* PhaseTransform::zerocon(BasicType bt) {\n+ConNode* PhaseValues::zerocon(BasicType bt) {\n@@ -974,4 +808,2 @@\n-PhaseIterGVN::PhaseIterGVN(PhaseIterGVN* igvn) : PhaseGVN(igvn),\n-                                                 _delay_transform(igvn->_delay_transform),\n-                                                 _stack(igvn->_stack ),\n-                                                 _worklist(igvn->_worklist)\n+PhaseIterGVN::PhaseIterGVN(PhaseIterGVN* igvn) : _delay_transform(igvn->_delay_transform),\n+                                                 _worklist(*C->igvn_worklist())\n@@ -980,0 +812,1 @@\n+  assert(&_worklist == &igvn->_worklist, \"sanity\");\n@@ -984,8 +817,2 @@\n-PhaseIterGVN::PhaseIterGVN(PhaseGVN* gvn) : PhaseGVN(gvn),\n-                                            _delay_transform(false),\n-\/\/ TODO: Before incremental inlining it was allocated only once and it was fine. Now that\n-\/\/       the constructor is used in incremental inlining, this consumes too much memory:\n-\/\/                                            _stack(C->live_nodes() >> 1),\n-\/\/       So, as a band-aid, we replace this by:\n-                                            _stack(C->comp_arena(), 32),\n-                                            _worklist(*C->for_igvn())\n+PhaseIterGVN::PhaseIterGVN(PhaseGVN* gvn) : _delay_transform(false),\n+                                            _worklist(*C->igvn_worklist())\n@@ -1471,2 +1298,3 @@\n-  assert(_stack.is_empty(), \"not empty\");\n-  _stack.push(dead, PROCESS_INPUTS);\n+  ResourceMark rm;\n+  Node_Stack stack(32);\n+  stack.push(dead, PROCESS_INPUTS);\n@@ -1474,2 +1302,2 @@\n-  while (_stack.is_nonempty()) {\n-    dead = _stack.node();\n+  while (stack.is_nonempty()) {\n+    dead = stack.node();\n@@ -1479,1 +1307,1 @@\n-    uint progress_state = _stack.index();\n+    uint progress_state = stack.index();\n@@ -1485,1 +1313,1 @@\n-      _stack.set_index(PROCESS_OUTPUTS);\n+      stack.set_index(PROCESS_OUTPUTS);\n@@ -1497,1 +1325,1 @@\n-              _stack.push(in, PROCESS_INPUTS); \/\/ Recursively remove\n+              stack.push(in, PROCESS_INPUTS); \/\/ Recursively remove\n@@ -1544,1 +1372,1 @@\n-      _stack.push(dead->raw_out(0), PROCESS_INPUTS);\n+      stack.push(dead->raw_out(0), PROCESS_INPUTS);\n@@ -1547,1 +1375,1 @@\n-      _stack.pop();\n+      stack.pop();\n@@ -1552,1 +1380,1 @@\n-  } \/\/ while (_stack.is_nonempty())\n+  } \/\/ while (stack.is_nonempty())\n@@ -1956,2 +1784,0 @@\n-  \/\/ Clear out _nodes from IterGVN.  Must be clear to transform call.\n-  _nodes.clear();               \/\/ Clear out from IterGVN\n@@ -2247,4 +2073,0 @@\n-  Node *new_node = _nodes[n->_idx]; \/\/ Check for transformed node\n-  if( new_node != nullptr )\n-    return new_node;                \/\/ Been there, done that, return old answer\n-\n@@ -2254,1 +2076,4 @@\n-  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n+  ResourceMark rm;\n+  \/\/ Map: old node idx -> node after CCP (or nullptr if not yet transformed or useless).\n+  Node_List node_map;\n+  \/\/ Pre-allocate to avoid frequent realloc\n@@ -2256,1 +2081,2 @@\n-  Unique_Node_List useful; \/\/ track all visited nodes, so that we can remove the complement\n+  \/\/ track all visited nodes, so that we can remove the complement\n+  Unique_Node_List useful;\n@@ -2268,1 +2094,1 @@\n-    Node* new_node = _nodes[nn->_idx];\n+    Node* new_node = node_map[nn->_idx];\n@@ -2271,1 +2097,1 @@\n-    _nodes.map(nn->_idx, new_node); \/\/ Flag as having been cloned\n+    node_map.map(nn->_idx, new_node); \/\/ Flag as having been cloned\n@@ -2282,1 +2108,1 @@\n-        Node *new_input = _nodes[input->_idx]; \/\/ Check for cloned input node\n+        Node *new_input = node_map[input->_idx]; \/\/ Check for cloned input node\n@@ -2285,1 +2111,1 @@\n-          _nodes.map( input->_idx, new_input );\/\/ Flag as having been cloned\n+          node_map.map( input->_idx, new_input );\/\/ Flag as having been cloned\n@@ -2308,1 +2134,1 @@\n-  C->disconnect_useless_nodes(useful, &_worklist);\n+  C->disconnect_useless_nodes(useful, _worklist);\n@@ -2310,1 +2136,1 @@\n-  Node* new_root = _nodes[n->_idx];\n+  Node* new_root = node_map[n->_idx];\n@@ -2315,1 +2141,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":55,"deletions":230,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -54,1 +55,1 @@\n-class NodeHash : public StackObj {\n+class NodeHash : public AnyObj {\n@@ -64,2 +65,0 @@\n-  NodeHash(uint est_max_size);\n-  NodeHash(NodeHash *use_this_state);\n@@ -69,1 +68,0 @@\n-  void operator=(const NodeHash&); \/\/ Unlock all nodes upon replacement of table.\n@@ -96,1 +94,0 @@\n-  void   replace_with(NodeHash* nh);\n@@ -115,0 +112,1 @@\n+  NONCOPYABLE(NodeHash);\n@@ -123,2 +121,2 @@\n-\/\/ Despite the general name, this class is customized for use by PhaseTransform.\n-class Type_Array : public StackObj {\n+\/\/ Despite the general name, this class is customized for use by PhaseValues.\n+class Type_Array : public AnyObj {\n@@ -131,1 +129,1 @@\n-  friend class PhaseTransform;\n+  friend class PhaseValues;\n@@ -134,1 +132,0 @@\n-  Type_Array(Type_Array *ta) : _a(ta->_a), _max(ta->_max), _types(ta->_types) { }\n@@ -142,0 +139,8 @@\n+  void swap(Type_Array &other) {\n+    if (this != &other) {\n+      assert(_a == other._a, \"swapping for differing arenas is probably a bad idea\");\n+      ::swap(_max, other._max);\n+      ::swap(_types, other._types);\n+    }\n+  }\n+  NONCOPYABLE(Type_Array);\n@@ -152,1 +157,1 @@\n-  PhaseRemoveUseless(PhaseGVN *gvn, Unique_Node_List *worklist, PhaseNumber phase_num = Remove_Useless);\n+  PhaseRemoveUseless(PhaseGVN* gvn, Unique_Node_List& worklist, PhaseNumber phase_num = Remove_Useless);\n@@ -173,1 +178,1 @@\n-                    Unique_Node_List* worklist, Unique_Node_List* new_worklist,\n+                    Unique_Node_List& worklist,\n@@ -184,0 +189,38 @@\n+public:\n+  PhaseTransform(PhaseNumber pnum) : Phase(pnum) {\n+#ifndef PRODUCT\n+    clear_progress();\n+    clear_transforms();\n+    set_allow_progress(true);\n+#endif\n+  }\n+\n+  \/\/ Return a node which computes the same function as this node, but\n+  \/\/ in a faster or cheaper fashion.\n+  virtual Node *transform( Node *n ) = 0;\n+\n+  \/\/ true if CFG node d dominates CFG node n\n+  virtual bool is_dominator(Node *d, Node *n) { fatal(\"unimplemented for this pass\"); return false; };\n+\n+#ifndef PRODUCT\n+  uint   _count_progress;       \/\/ For profiling, count transforms that make progress\n+  void   set_progress()        { ++_count_progress; assert( allow_progress(),\"No progress allowed during verification\"); }\n+  void   clear_progress()      { _count_progress = 0; }\n+  uint   made_progress() const { return _count_progress; }\n+\n+  uint   _count_transforms;     \/\/ For profiling, count transforms performed\n+  void   set_transforms()      { ++_count_transforms; }\n+  void   clear_transforms()    { _count_transforms = 0; }\n+  uint   made_transforms() const{ return _count_transforms; }\n+\n+  bool   _allow_progress;      \/\/ progress not allowed during verification pass\n+  void   set_allow_progress(bool allow) { _allow_progress = allow; }\n+  bool   allow_progress()               { return _allow_progress; }\n+#endif\n+};\n+\n+\/\/ Phase infrastructure required for Node::Value computations.\n+\/\/ 1) Type array, and accessor methods.\n+\/\/ 2) Constants cache, which requires access to the types.\n+\/\/ 3) NodeHash table, to find identical nodes (and remove\/update the hash of a node on modification).\n+class PhaseValues : public PhaseTransform {\n@@ -185,3 +228,7 @@\n-  Arena*     _arena;\n-  Node_List  _nodes;           \/\/ Map old node indices to new nodes.\n-  Type_Array _types;           \/\/ Map old node indices to Types.\n+  bool      _iterGVN;\n+\n+  \/\/ Hash table for value-numbering. Reference to \"C->node_hash()\",\n+  NodeHash &_table;\n+\n+  \/\/ Type array mapping node idx to Type*. Reference to \"C->types()\".\n+  Type_Array &_types;\n@@ -190,0 +237,2 @@\n+  \/\/ Support both int and long caches because either might be an intptr_t,\n+  \/\/ so they show up frequently in address computations.\n@@ -201,11 +250,7 @@\n-  \/\/ Support both int and long caches because either might be an intptr_t,\n-  \/\/ so they show up frequently in address computations.\n-\n-  PhaseTransform( PhaseNumber pnum );\n-  PhaseTransform( Arena *arena, PhaseNumber pnum );\n-  PhaseTransform( PhaseTransform *phase, PhaseNumber pnum );\n-\n-  Arena*      arena()   { return _arena; }\n-  Type_Array& types()   { return _types; }\n-  void replace_types(Type_Array new_types) {\n-    _types = new_types;\n+  PhaseValues() : PhaseTransform(GVN), _iterGVN(false),\n+                  _table(*C->node_hash()), _types(*C->types())\n+  {\n+    NOT_PRODUCT( clear_new_values(); )\n+    \/\/ Force allocation for currently existing nodes\n+    _types.map(C->unique(), nullptr);\n+    init_con_caches();\n@@ -214,3 +259,18 @@\n-  \/\/ _nodes is used in varying ways by subclasses, which define local accessors\n-  uint nodes_size() {\n-    return _nodes.size();\n+  NOT_PRODUCT(~PhaseValues();)\n+  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : nullptr; }\n+\n+  \/\/ Some Ideal and other transforms delete --> modify --> insert values\n+  bool   hash_delete(Node* n)     { return _table.hash_delete(n); }\n+  void   hash_insert(Node* n)     { _table.hash_insert(n); }\n+  Node*  hash_find_insert(Node* n){ return _table.hash_find_insert(n); }\n+  Node*  hash_find(const Node* n) { return _table.hash_find(n); }\n+\n+  \/\/ Used after parsing to eliminate values that are no longer in program\n+  void   remove_useless_nodes(VectorSet &useful) {\n+    _table.remove_useless_nodes(useful);\n+    \/\/ this may invalidate cached cons so reset the cache\n+    init_con_caches();\n+  }\n+\n+  Type_Array& types() {\n+    return _types;\n@@ -219,1 +279,0 @@\n-public:\n@@ -225,1 +284,0 @@\n-    assert(_pnum != Ideal_Loop, \"should not be used from PhaseIdealLoop\");\n@@ -234,1 +292,0 @@\n-    assert(_pnum != Ideal_Loop, \"should not be used from PhaseIdealLoop\");\n@@ -277,2 +334,1 @@\n-  virtual ConNode* uncached_makecon(const Type* t)  \/\/ override in PhaseValues\n-  { ShouldNotCallThis(); return nullptr; }\n+  ConNode* uncached_makecon(const Type* t);\n@@ -288,4 +344,0 @@\n-  \/\/ Return a node which computes the same function as this node, but\n-  \/\/ in a faster or cheaper fashion.\n-  virtual Node *transform( Node *n ) = 0;\n-\n@@ -340,3 +392,5 @@\n-  virtual const Type* saturate(const Type* new_type, const Type* old_type,\n-                               const Type* limit_type) const\n-  { ShouldNotCallThis(); return nullptr; }\n+  virtual const Type* saturate(const Type* new_type,\n+                               const Type* old_type,\n+                               const Type* limit_type) const {\n+    return new_type;\n+  }\n@@ -347,57 +401,0 @@\n-  \/\/ true if CFG node d dominates CFG node n\n-  virtual bool is_dominator(Node *d, Node *n) { fatal(\"unimplemented for this pass\"); return false; };\n-\n-#ifndef PRODUCT\n-  void dump_old2new_map() const;\n-  void dump_new( uint new_lidx ) const;\n-  void dump_types() const;\n-  void dump_nodes_and_types(const Node *root, uint depth, bool only_ctrl = true);\n-  void dump_nodes_and_types_recur( const Node *n, uint depth, bool only_ctrl, VectorSet &visited);\n-\n-  uint   _count_progress;       \/\/ For profiling, count transforms that make progress\n-  void   set_progress()        { ++_count_progress; assert( allow_progress(),\"No progress allowed during verification\"); }\n-  void   clear_progress()      { _count_progress = 0; }\n-  uint   made_progress() const { return _count_progress; }\n-\n-  uint   _count_transforms;     \/\/ For profiling, count transforms performed\n-  void   set_transforms()      { ++_count_transforms; }\n-  void   clear_transforms()    { _count_transforms = 0; }\n-  uint   made_transforms() const{ return _count_transforms; }\n-\n-  bool   _allow_progress;      \/\/ progress not allowed during verification pass\n-  void   set_allow_progress(bool allow) { _allow_progress = allow; }\n-  bool   allow_progress()               { return _allow_progress; }\n-#endif\n-};\n-\n-\/\/------------------------------PhaseValues------------------------------------\n-\/\/ Phase infrastructure to support values\n-class PhaseValues : public PhaseTransform {\n-protected:\n-  NodeHash  _table;             \/\/ Hash table for value-numbering\n-  bool      _iterGVN;\n-public:\n-  PhaseValues(Arena* arena, uint est_max_size);\n-  PhaseValues(PhaseValues* pt);\n-  NOT_PRODUCT(~PhaseValues();)\n-  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : nullptr; }\n-\n-  \/\/ Some Ideal and other transforms delete --> modify --> insert values\n-  bool   hash_delete(Node* n)     { return _table.hash_delete(n); }\n-  void   hash_insert(Node* n)     { _table.hash_insert(n); }\n-  Node*  hash_find_insert(Node* n){ return _table.hash_find_insert(n); }\n-  Node*  hash_find(const Node* n) { return _table.hash_find(n); }\n-\n-  \/\/ Used after parsing to eliminate values that are no longer in program\n-  void   remove_useless_nodes(VectorSet &useful) {\n-    _table.remove_useless_nodes(useful);\n-    \/\/ this may invalidate cached cons so reset the cache\n-    init_con_caches();\n-  }\n-\n-  virtual ConNode* uncached_makecon(const Type* t);  \/\/ override from PhaseTransform\n-\n-  const Type* saturate(const Type* new_type, const Type* old_type,\n-                       const Type* limit_type) const\n-  { return new_type; }\n-\n@@ -420,3 +417,0 @@\n-  PhaseGVN( Arena *arena, uint est_max_size ) : PhaseValues( arena, est_max_size ) {}\n-  PhaseGVN( PhaseGVN *gvn ) : PhaseValues( gvn ) {}\n-\n@@ -431,5 +425,0 @@\n-  void replace_with(PhaseGVN* gvn) {\n-    _table.replace_with(&gvn->_table);\n-    _types = gvn->_types;\n-  }\n-\n@@ -462,2 +451,0 @@\n-  Node_Stack _stack;      \/\/ Stack used to avoid recursion\n-\n@@ -474,0 +461,1 @@\n+\n@@ -477,0 +465,20 @@\n+  \/\/ Reset IGVN from GVN: call deconstructor, and placement new.\n+  \/\/ Achieves the same as the following (but without move constructors):\n+  \/\/ igvn = PhaseIterGVN(gvn);\n+  void reset_from_gvn(PhaseGVN* gvn) {\n+    if (this != gvn) {\n+      this->~PhaseIterGVN();\n+      ::new (static_cast<void*>(this)) PhaseIterGVN(gvn);\n+    }\n+  }\n+\n+  \/\/ Reset IGVN with another: call deconstructor, and placement new.\n+  \/\/ Achieves the same as the following (but without move constructors):\n+  \/\/ igvn = PhaseIterGVN(other);\n+  void reset_from_igvn(PhaseIterGVN* other) {\n+    if (this != other) {\n+      this->~PhaseIterGVN();\n+      ::new (static_cast<void*>(this)) PhaseIterGVN(other);\n+    }\n+  }\n+\n@@ -481,1 +489,2 @@\n-  Unique_Node_List _worklist;       \/\/ Iterative worklist\n+  \/\/ Iterative worklist. Reference to \"C->igvn_worklist()\".\n+  Unique_Node_List &_worklist;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":117,"deletions":108,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -497,1 +497,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1571,4 +1571,0 @@\n-\n-  \/\/ Enable WXWrite: the function called directly by compiled code.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-        if (_nodes[m->_idx] == nullptr) {\n+        if (_loop_or_ctrl[m->_idx] == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-const Type* SubNode::Value_common(PhaseTransform *phase) const {\n+const Type* SubNode::Value_common(PhaseValues* phase) const {\n@@ -364,1 +364,1 @@\n-    return new AddLNode(in1, phase->longcon(-i->get_con()));\n+    return new AddLNode(in1, phase->longcon(java_negate(i->get_con())));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  const Type* Value_common( PhaseTransform *phase ) const;\n+  const Type* Value_common(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-  return t->hash();\n+  return (int)t->hash();\n@@ -834,1 +834,1 @@\n-int Type::hash(void) const {\n+uint Type::hash(void) const {\n@@ -1424,2 +1424,2 @@\n-int TypeF::hash(void) const {\n-  return *(int*)(&_f);\n+uint TypeF::hash(void) const {\n+  return *(uint*)(&_f);\n@@ -1534,2 +1534,2 @@\n-int TypeD::hash(void) const {\n-  return *(int*)(&_d);\n+uint TypeD::hash(void) const {\n+  return *(uint*)(&_d);\n@@ -1828,2 +1828,2 @@\n-int TypeInt::hash(void) const {\n-  return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));\n+uint TypeInt::hash(void) const {\n+  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Int;\n@@ -2094,2 +2094,2 @@\n-int TypeLong::hash(void) const {\n-  return (int)(_lo+_hi+_widen+(int)Type::Long);\n+uint TypeLong::hash(void) const {\n+  return (uint)_lo + (uint)_hi + (uint)_widen + (uint)Type::Long;\n@@ -2391,2 +2391,2 @@\n-int TypeTuple::hash(void) const {\n-  intptr_t sum = _cnt;\n+uint TypeTuple::hash(void) const {\n+  uintptr_t sum = _cnt;\n@@ -2394,2 +2394,2 @@\n-    sum += (intptr_t)_fields[i];     \/\/ Hash on pointers directly\n-  return sum;\n+    sum += (uintptr_t)_fields[i];     \/\/ Hash on pointers directly\n+  return (uint)sum;\n@@ -2514,3 +2514,3 @@\n-int TypeAry::hash(void) const {\n-  return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0) +\n-      (_flat ? 44 : 0) + (_not_flat ? 45 : 0) + (_not_null_free ? 46 : 0);\n+uint TypeAry::hash(void) const {\n+  return (uint)(uintptr_t)_elem + (uint)(uintptr_t)_size + (uint)(_stable ? 43 : 0) +\n+      (uint)(_flat ? 44 : 0) + (uint)(_not_flat ? 45 : 0) + (uint)(_not_null_free ? 46 : 0);\n@@ -2716,2 +2716,2 @@\n-int TypeVect::hash(void) const {\n-  return (intptr_t)_elem + (intptr_t)_length;\n+uint TypeVect::hash(void) const {\n+  return (uint)(uintptr_t)_elem + (uint)(uintptr_t)_length;\n@@ -2924,3 +2924,2 @@\n-int TypePtr::hash(void) const {\n-  return java_add(java_add((jint)_ptr, (jint)offset()), java_add((jint)hash_speculative(), (jint)_inline_depth));\n-;\n+uint TypePtr::hash(void) const {\n+  return (uint)_ptr + (uint)offset() + (uint)hash_speculative() + (uint)_inline_depth;\n@@ -3356,2 +3355,2 @@\n-int TypeRawPtr::hash(void) const {\n-  return (intptr_t)_bits + TypePtr::hash();\n+uint TypeRawPtr::hash(void) const {\n+  return (uint)(uintptr_t)_bits + (uint)TypePtr::hash();\n@@ -3446,1 +3445,1 @@\n-int TypePtr::InterfaceSet::hash() const {\n+uint TypePtr::InterfaceSet::hash() const {\n@@ -3452,1 +3451,1 @@\n-  int hash = 0;\n+  uint hash = 0;\n@@ -3455,1 +3454,1 @@\n-    hash += (jint)k->hash();\n+    hash += k->hash();\n@@ -4017,1 +4016,1 @@\n-int TypeOopPtr::hash(void) const {\n+uint TypeOopPtr::hash(void) const {\n@@ -4019,2 +4018,3 @@\n-    java_add(java_add((jint)(const_oop() ? const_oop()->hash() : 0), (jint)_klass_is_exact),\n-             java_add((jint)_instance_id, (jint)TypePtr::hash()));\n+    (uint)(const_oop() ? const_oop()->hash() : 0) +\n+    (uint)_klass_is_exact +\n+    (uint)_instance_id + TypePtr::hash();\n@@ -4672,3 +4672,2 @@\n-int TypeInstPtr::hash(void) const {\n-  int hash = java_add(java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), _interfaces.hash()), (jint)flatten_array());\n-  return hash;\n+uint TypeInstPtr::hash(void) const {\n+  return klass()->hash() + TypeOopPtr::hash() + _interfaces.hash() + (uint)flatten_array();\n@@ -5087,2 +5086,2 @@\n-int TypeAryPtr::hash(void) const {\n-  return (intptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();\n+uint TypeAryPtr::hash(void) const {\n+  return (uint)(uintptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();\n@@ -5593,1 +5592,1 @@\n-int TypeNarrowPtr::hash(void) const {\n+uint TypeNarrowPtr::hash(void) const {\n@@ -5752,1 +5751,1 @@\n-int TypeMetadataPtr::hash(void) const {\n+uint TypeMetadataPtr::hash(void) const {\n@@ -5992,2 +5991,2 @@\n-int TypeKlassPtr::hash(void) const {\n-  return java_add((jint)TypePtr::hash(), _interfaces.hash());\n+uint TypeKlassPtr::hash(void) const {\n+  return TypePtr::hash() + _interfaces.hash();\n@@ -6103,2 +6102,2 @@\n-int TypeInstKlassPtr::hash(void) const {\n-  return java_add(java_add((jint)klass()->hash(), TypeKlassPtr::hash()), (jint)flatten_array());\n+uint TypeInstKlassPtr::hash(void) const {\n+  return klass()->hash() + TypeKlassPtr::hash() + (uint)flatten_array();\n@@ -6502,3 +6501,3 @@\n-int TypeAryKlassPtr::hash(void) const {\n-  return (intptr_t)_elem + TypeKlassPtr::hash() + (_not_flat ? 43 : 0) +\n-      (_not_null_free ? 44 : 0) + (_null_free ? 45 : 0);\n+uint TypeAryKlassPtr::hash(void) const {\n+  return (uint)(uintptr_t)_elem + TypeKlassPtr::hash() + (uint)(_not_flat ? 43 : 0) +\n+      (uint)(_not_null_free ? 44 : 0) + (uint)(_null_free ? 45 : 0);\n@@ -7130,2 +7129,2 @@\n-int TypeFunc::hash(void) const {\n-  return (intptr_t)_domain_sig + (intptr_t)_domain_cc + (intptr_t)_range_sig + (intptr_t)_range_cc;\n+uint TypeFunc::hash(void) const {\n+  return (uint)(intptr_t)_domain_sig + (uint)(intptr_t)_domain_cc + (uint)(intptr_t)_range_sig + (uint)(intptr_t)_range_cc;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":45,"deletions":46,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-  virtual int hash() const;\n+  virtual uint hash() const;\n@@ -523,1 +523,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -554,1 +554,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -613,1 +613,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -679,1 +679,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -738,1 +738,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -788,1 +788,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -837,1 +837,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -923,1 +923,1 @@\n-    int _hash;\n+    uint _hash;\n@@ -938,1 +938,1 @@\n-    int hash() const;\n+    uint hash() const;\n@@ -1055,1 +1055,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1118,1 +1118,1 @@\n-  virtual int  hash() const;     \/\/ Type specific hashing\n+  virtual uint hash() const;    \/\/ Type specific hashing\n@@ -1155,1 +1155,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1328,1 +1328,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1468,1 +1468,1 @@\n-  virtual int hash() const;     \/\/ Type specific hashing\n+  virtual uint hash() const;    \/\/ Type specific hashing\n@@ -1610,1 +1610,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1654,1 +1654,1 @@\n-  virtual int hash() const;\n+  virtual uint hash() const;\n@@ -1780,1 +1780,1 @@\n-  virtual int hash() const;\n+  virtual uint hash() const;\n@@ -1853,1 +1853,1 @@\n-  virtual int hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -1904,1 +1904,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n@@ -2016,1 +2016,1 @@\n-  virtual int  hash() const;             \/\/ Type specific hashing\n+  virtual uint hash() const;             \/\/ Type specific hashing\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n-  C->for_igvn()->clear();\n-  C->initial_gvn()->replace_with(&_igvn);\n+  C->igvn_worklist()->ensure_empty(); \/\/ should be done with igvn\n@@ -67,1 +66,1 @@\n-    PhaseRemoveUseless pru(C->initial_gvn(), C->for_igvn());\n+    PhaseRemoveUseless pru(C->initial_gvn(), *C->igvn_worklist());\n@@ -72,1 +71,1 @@\n-    _igvn = PhaseIterGVN(C->initial_gvn());\n+    _igvn.reset_from_gvn(C->initial_gvn());\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3594,1 +3594,9 @@\n-volatile int vm_created = 0;\n+enum VM_Creation_State {\n+  NOT_CREATED = 0,\n+  IN_PROGRESS,  \/\/ Most JNI operations are permitted during this phase to\n+                \/\/ allow for initialization actions by libraries and agents.\n+  COMPLETE\n+};\n+\n+volatile VM_Creation_State vm_created = NOT_CREATED;\n+\n@@ -3663,1 +3671,1 @@\n-  if (Atomic::xchg(&vm_created, 1) == 1) {\n+  if (Atomic::xchg(&vm_created, IN_PROGRESS) != NOT_CREATED) {\n@@ -3676,2 +3684,0 @@\n-  assert(vm_created == 1, \"vm_created is true during the creation\");\n-\n@@ -3694,1 +3700,1 @@\n-    \/* thread is thread_in_vm here *\/\n+    \/\/ thread is thread_in_vm here\n@@ -3697,0 +3703,2 @@\n+    \/\/ mark creation complete for other JNI ops\n+    Atomic::release_store(&vm_created, COMPLETE);\n@@ -3742,2 +3750,4 @@\n-      JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-      if (HAS_PENDING_EXCEPTION) {\n+      Thread* current = Thread::current_or_null();\n+      if (current != nullptr) {\n+        JavaThread* THREAD = JavaThread::cast(current); \/\/ For exception macros.\n+        assert(HAS_PENDING_EXCEPTION, \"must be - else no current thread exists\");\n@@ -3759,1 +3769,2 @@\n-    Atomic::release_store(&vm_created, 0);\n+    assert(vm_created == IN_PROGRESS, \"must be\");\n+    Atomic::release_store(&vm_created, NOT_CREATED);\n@@ -3788,1 +3799,1 @@\n-  if (vm_created == 1) {\n+  if (vm_created == COMPLETE) {\n@@ -3808,1 +3819,1 @@\n-  if (vm_created == 0) {\n+  if (vm_created == NOT_CREATED) {\n@@ -3839,1 +3850,1 @@\n-  vm_created = 0;\n+  vm_created = NOT_CREATED;\n@@ -3973,1 +3984,2 @@\n-  if (vm_created == 0) {\n+  if (vm_created == NOT_CREATED) {\n+    \/\/ Not sure how we could possibly get here.\n@@ -3986,1 +3998,2 @@\n-  if (vm_created == 0) {\n+  if (vm_created == NOT_CREATED) {\n+    \/\/ Not sure how we could possibly get here.\n@@ -4049,1 +4062,1 @@\n-  if (vm_created == 0) {\n+  if (vm_created == NOT_CREATED) {\n@@ -4100,2 +4113,3 @@\n-  if (vm_created == 0) {\n-  HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);\n+  if (vm_created == NOT_CREATED) {\n+    \/\/ Not sure how we could possibly get here.\n+    HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1403,1 +1403,1 @@\n-    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_incubator_concurrent_ScopedValue_Carrier(), true, THREAD);\n+    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ScopedValue_Carrier(), true, THREAD);\n@@ -1436,1 +1436,1 @@\n-      StackValue* head_sv = locals->at(loc); \/\/ jdk\/incubator\/concurrent\/ScopedValue$Snapshot\n+      StackValue* head_sv = locals->at(loc); \/\/ java\/lang\/ScopedValue$Snapshot\n@@ -4112,0 +4112,7 @@\n+\n+\/*\n+ * Return JNI_TRUE if warnings are printed when agents are dynamically loaded.\n+ *\/\n+JVM_LEAF(jboolean, JVM_PrintWarningAtDynamicAgentLoad(void))\n+  return (EnableDynamicAgentLoading && !FLAG_IS_CMDLINE(EnableDynamicAgentLoading)) ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1783,0 +1783,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -1785,1 +1786,0 @@\n-    JvmtiVTMSTransitionDisabler disabler;\n@@ -1889,1 +1889,1 @@\n-  bool is_virtual = thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass());\n+  bool self = java_thread == current_thread;\n@@ -1891,14 +1891,3 @@\n-  if (is_virtual) {\n-    if (!is_JavaThread_current(java_thread, thread_obj)) {\n-      if (!is_vthread_suspended(thread_obj, java_thread)) {\n-        return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-      }\n-      if (java_thread == nullptr) { \/\/ unmounted virtual thread\n-        return JVMTI_ERROR_OPAQUE_FRAME;\n-      }\n-    }\n-  } else { \/\/ platform thread\n-    if (java_thread != current_thread && !java_thread->is_suspended() &&\n-        !java_thread->is_carrier_thread_suspended()) {\n-      return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-    }\n+  err = check_non_suspended_or_opaque_frame(java_thread, thread_obj, self);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n@@ -1922,2 +1911,2 @@\n-  if (java_thread == current_thread) {\n-    op.doit(java_thread, true \/* self *\/);\n+  if (self) {\n+    op.doit(java_thread, self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3683,1 +3683,1 @@\n-      method->set_generic_signature_index(new_index);\n+      method->constMethod()->set_generic_signature_index(new_index);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1918,1 +1918,1 @@\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64)\n@@ -2899,1 +2899,1 @@\n-    } else if (match_option(option, \"-XX:-EnableJVMCIProduct\")) {\n+    } else if (match_option(option, \"-XX:-EnableJVMCIProduct\") || match_option(option, \"-XX:-UseGraalJIT\")) {\n@@ -2902,1 +2902,1 @@\n-                  \"-XX:-EnableJVMCIProduct cannot come after -XX:+EnableJVMCIProduct\\n\");\n+                  \"-XX:-EnableJVMCIProduct or -XX:-UseGraalJIT cannot come after -XX:+EnableJVMCIProduct or -XX:+UseGraalJIT\\n\");\n@@ -2905,2 +2905,16 @@\n-    } else if (match_option(option, \"-XX:+EnableJVMCIProduct\")) {\n-      \/\/ Just continue, since \"-XX:+EnableJVMCIProduct\" has been specified before\n+    } else if (match_option(option, \"-XX:+EnableJVMCIProduct\") || match_option(option, \"-XX:+UseGraalJIT\")) {\n+      bool use_graal_jit = match_option(option, \"-XX:+UseGraalJIT\");\n+      if (use_graal_jit) {\n+        const char* jvmci_compiler = get_property(\"jvmci.Compiler\");\n+        if (jvmci_compiler != nullptr) {\n+          if (strncmp(jvmci_compiler, \"graal\", strlen(\"graal\")) != 0) {\n+            jio_fprintf(defaultStream::error_stream(),\n+              \"Value of jvmci.Compiler incompatible with +UseGraalJIT: %s\", jvmci_compiler);\n+            return JNI_ERR;\n+          }\n+        } else if (!add_property(\"jvmci.Compiler=graal\")) {\n+            return JNI_ENOMEM;\n+        }\n+      }\n+\n+      \/\/ Just continue, since \"-XX:+EnableJVMCIProduct\" or \"-XX:+UseGraalJIT\" has been specified before\n@@ -2913,1 +2927,1 @@\n-        if (!JVMCIGlobals::enable_jvmci_product_mode(origin)) {\n+        if (!JVMCIGlobals::enable_jvmci_product_mode(origin, use_graal_jit)) {\n@@ -2920,1 +2934,1 @@\n-      else if (!process_argument(\"EnableJVMCIProduct\", args->ignoreUnrecognized, origin)) {\n+      else if (!process_argument(use_graal_jit ? \"UseGraalJIT\" : \"EnableJVMCIProduct\", args->ignoreUnrecognized, origin)) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-        st->print(\"nullptr\");\n+        st->print(\"null\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -550,1 +550,1 @@\n-  product(ccstr, HeapDumpPath, nullptr, MANAGEABLE,                            \\\n+  product(ccstr, HeapDumpPath, nullptr, MANAGEABLE,                         \\\n@@ -604,1 +604,1 @@\n-  product(ccstr, PrintAssemblyOptions, nullptr, DIAGNOSTIC,                    \\\n+  product(ccstr, PrintAssemblyOptions, nullptr, DIAGNOSTIC,                 \\\n@@ -632,1 +632,1 @@\n-          \"Start debugger when an implicit OS (e.g. nullptr) \"                 \\\n+          \"Start debugger when an implicit OS (e.g. null pointer) \"         \\\n@@ -856,1 +856,1 @@\n-  product(ccstr, TraceJVMTI, nullptr,                                          \\\n+  product(ccstr, TraceJVMTI, nullptr,                                       \\\n@@ -908,4 +908,0 @@\n-                                                                            \\\n-  notproduct(bool, CheckMemoryInitialization, false,                        \\\n-          \"Check memory initialization\")                                    \\\n-                                                                            \\\n@@ -1050,1 +1046,1 @@\n-  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                                 \\\n+  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                              \\\n@@ -1054,1 +1050,1 @@\n-  product(ccstr, ErrorFile, nullptr,                                           \\\n+  product(ccstr, ErrorFile, nullptr,                                        \\\n@@ -1091,1 +1087,1 @@\n-  product(ccstr, AbortVMOnException, nullptr, DIAGNOSTIC,                      \\\n+  product(ccstr, AbortVMOnException, nullptr, DIAGNOSTIC,                   \\\n@@ -1095,1 +1091,1 @@\n-  product(ccstr, AbortVMOnExceptionMessage, nullptr, DIAGNOSTIC,               \\\n+  product(ccstr, AbortVMOnExceptionMessage, nullptr, DIAGNOSTIC,            \\\n@@ -1407,1 +1403,1 @@\n-  product(double, MinInlineFrequencyRatio, 0.0085, DIAGNOSTIC,               \\\n+  product(double, MinInlineFrequencyRatio, 0.0085, DIAGNOSTIC,              \\\n@@ -1752,1 +1748,1 @@\n-  product(ccstr, PerfDataSaveFile, nullptr,                                    \\\n+  product(ccstr, PerfDataSaveFile, nullptr,                                 \\\n@@ -1939,1 +1935,1 @@\n-  product(ccstr, AllocateHeapAt, nullptr,                                      \\\n+  product(ccstr, AllocateHeapAt, nullptr,                                   \\\n@@ -1974,1 +1970,1 @@\n-  JFR_ONLY(product(ccstr, FlightRecorderOptions, nullptr,                      \\\n+  JFR_ONLY(product(ccstr, FlightRecorderOptions, nullptr,                   \\\n@@ -1977,1 +1973,1 @@\n-  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                       \\\n+  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                    \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  oop     non_null_obj() const                   { assert(_handle != nullptr, \"resolving nullptr handle\"); return *_handle; }\n+  oop     non_null_obj() const                   { assert(_handle != nullptr, \"resolving null handle\"); return *_handle; }\n@@ -149,1 +149,1 @@\n-    type*        non_null_obj() const            { assert(_value != nullptr, \"resolving nullptr _value\"); return _value; } \\\n+    type*        non_null_obj() const            { assert(_value != nullptr, \"resolving null _value\"); return _value; } \\\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,0 +145,4 @@\n+  return JNI_OK;\n+}\n+\n+jint init_globals2() {\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -421,1 +421,1 @@\n-      assert(block->pop_frame_link() == nullptr, \"pop_frame_link should be nullptr\");\n+      assert(block->pop_frame_link() == nullptr, \"pop_frame_link should be null\");\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  assert(result != nullptr, \"nullptr read from jni handle\");\n+  assert(result != nullptr, \"null read from jni handle\");\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-    assert(cur_tss->get_next() == nullptr, \"Must be nullptr\");\n+    assert(cur_tss->get_next() == nullptr, \"Must be null\");\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -485,0 +485,3 @@\n+  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n+\n@@ -2138,0 +2141,3 @@\n+  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, JavaThread::current()));\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1684,0 +1684,9 @@\n+static size_t delete_monitors(GrowableArray<ObjectMonitor*>* delete_list) {\n+  size_t count = 0;\n+  for (ObjectMonitor* monitor: *delete_list) {\n+    delete monitor;\n+    count++;\n+  }\n+  return count;\n+}\n+\n@@ -1758,9 +1767,9 @@\n-    \/\/ deflated in this cycle.\n-    for (ObjectMonitor* monitor: delete_list) {\n-      delete monitor;\n-      deleted_count++;\n-\n-      if (current->is_Java_thread()) {\n-        \/\/ A JavaThread must check for a safepoint\/handshake and honor it.\n-        chk_for_block_req(JavaThread::cast(current), \"deletion\", \"deleted_count\",\n-                          deleted_count, ls, &timer);\n+    \/\/ deflated and unlinked in this cycle.\n+    if (current->is_Java_thread()) {\n+      if (ls != NULL) {\n+        timer.stop();\n+        ls->print_cr(\"before setting blocked: unlinked_count=\" SIZE_FORMAT\n+                     \", in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\"\n+                     SIZE_FORMAT \", max=\" SIZE_FORMAT,\n+                     unlinked_count, in_use_list_ceiling(),\n+                     _in_use_list.count(), _in_use_list.max());\n@@ -1768,0 +1777,14 @@\n+      \/\/ Mark the calling JavaThread blocked (safepoint safe) while we free\n+      \/\/ the ObjectMonitors so we don't delay safepoints whilst doing that.\n+      ThreadBlockInVM tbivm(JavaThread::cast(current));\n+      if (ls != NULL) {\n+        ls->print_cr(\"after setting blocked: in_use_list stats: ceiling=\"\n+                     SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n+                     in_use_list_ceiling(), _in_use_list.count(), _in_use_list.max());\n+        timer.start();\n+      }\n+      deleted_count = delete_monitors(&delete_list);\n+      \/\/ ThreadBlockInVM is destroyed here\n+    } else {\n+      \/\/ A non-JavaThread can just free the ObjectMonitors:\n+      deleted_count = delete_monitors(&delete_list);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -178,0 +178,2 @@\n+  \/\/ Extra information about what triggered this operation.\n+  virtual const char* cause() const { return nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-        \/\/ add a nullptr snapshot if skipped\n+        \/\/ add a null snapshot if skipped\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1697,1 +1697,0 @@\n-  declare_c2_type(NodeHash, StackObj)                                     \\\n@@ -1776,2 +1775,0 @@\n-  declare_c2_type(CMoveVFNode, VectorNode)                                \\\n-  declare_c2_type(CMoveVDNode, VectorNode)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1194,2 +1194,2 @@\n-inline int extract_low_short_from_int(jint x) {\n-  return x & 0xffff;\n+inline u2 extract_low_short_from_int(u4 x) {\n+  return u2(x & 0xffff);\n@@ -1198,2 +1198,2 @@\n-inline int extract_high_short_from_int(jint x) {\n-  return (x >> 16) & 0xffff;\n+inline u2 extract_high_short_from_int(u4 x) {\n+  return u2((x >> 16) & 0xffff);\n@@ -1202,1 +1202,1 @@\n-inline int build_int_from_shorts( jushort low, jushort high ) {\n+inline int build_int_from_shorts( u2 low, u2 high ) {\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+import jdk.internal.misc.PreviewFeatures;\n@@ -87,0 +88,1 @@\n+\n@@ -132,6 +134,5 @@\n- * <blockquote><pre>\n- *     void printClassName(Object obj) {\n- *         System.out.println(\"The class of \" + obj +\n- *                            \" is \" + obj.getClass().getName());\n- *     }\n- * <\/pre><\/blockquote>\n+ * {@snippet lang=\"java\" :\n+ * void printClassName(Object obj) {\n+ *     System.out.println(\"The class of \" + obj +\n+ *                        \" is \" + obj.getClass().getName());\n+ * }}\n@@ -143,3 +144,3 @@\n- * <blockquote>\n- *     {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}\n- * <\/blockquote>\n+ * {@snippet lang=\"java\" :\n+ * System.out.println(\"The name of class Foo is: \"+Foo.class.getName());\n+ * }\n@@ -164,1 +165,2 @@\n- * <p> A class or interface created by the invocation of\n+ * <h2><a id=hiddenClasses>Hidden Classes<\/a><\/h2>\n+ * A class or interface created by the invocation of\n@@ -192,0 +194,25 @@\n+ * <h2><a id=unnamedClasses>Unnamed Classes<\/a><\/h2>\n+ *\n+ * A {@code class} file representing an {@linkplain #isUnnamedClass unnamed class}\n+ * is generated by a Java compiler from a source file for an unnamed class.\n+ * The {@code Class} object representing an unnamed class is top-level,\n+ * {@linkplain #isSynthetic synthetic}, and {@code final}. While an\n+ * unnamed class does <em>not<\/em> have a name in its Java source\n+ * form, several of the name-related methods of {@code java.lang.Class}\n+ * do return non-null and non-empty results for the {@code Class}\n+ * object representing an unnamed class.\n+ *\n+ * Conventionally, a Java compiler, starting from a source file for an\n+ * unnamed class, say {@code HelloWorld.java}, creates a\n+ * similarly-named {@code class} file, {@code HelloWorld.class}, where\n+ * the class stored in that {@code class} file is named {@code\n+ * \"HelloWorld\"}, matching the base names of the source and {@code\n+ * class} files.\n+ *\n+ * For the {@code Class} object of an unnamed class {@code\n+ * HelloWorld}, the methods to get the {@linkplain #getName name} and\n+ * {@linkplain #getTypeName type name} return results\n+ * equal to {@code \"HelloWorld\"}. The {@linkplain #getSimpleName\n+ * simple name} of such an unnamed class is the empty string and the\n+ * {@linkplain #getCanonicalName canonical name} is {@code null}.\n+ *\n@@ -366,3 +393,3 @@\n-     * <blockquote>\n-     *  {@code Class.forName(className, true, currentLoader)}\n-     * <\/blockquote>\n+     * {@snippet lang=\"java\" :\n+     * Class.forName(className, true, currentLoader)\n+     * }\n@@ -377,3 +404,3 @@\n-     * <blockquote>\n-     *   {@code Class t = Class.forName(\"java.lang.Thread\")}\n-     * <\/blockquote>\n+     * {@snippet lang=\"java\" :\n+     * Class<?> t = Class.forName(\"java.lang.Thread\");\n+     * }\n@@ -440,3 +467,3 @@\n-     * <blockquote>\n-     *  {@code Class.forName(\"Foo\")}\n-     * <\/blockquote>\n+     * {@snippet lang=\"java\" :\n+     * Class.forName(\"Foo\")\n+     * }\n@@ -446,3 +473,3 @@\n-     * <blockquote>\n-     *  {@code Class.forName(\"Foo\", true, this.getClass().getClassLoader())}\n-     * <\/blockquote>\n+     * {@snippet lang=\"java\" :\n+     * Class.forName(\"Foo\", true, this.getClass().getClassLoader())\n+     * }\n@@ -770,1 +797,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -772,1 +799,1 @@\n-     * }<\/pre>\n+     * }\n@@ -776,1 +803,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -778,1 +805,1 @@\n-     * }<\/pre>\n+     * }\n@@ -1890,1 +1917,1 @@\n-     * {@linkplain #isAnonymousClass() anonymous}.\n+     * {@linkplain #isAnonymousClass() anonymous} or {@linkplain #isUnnamedClass() unnamed}.\n@@ -1903,0 +1930,3 @@\n+        if (isUnnamedClass()) {\n+            return \"\";\n+        }\n@@ -1957,0 +1987,1 @@\n+     * <li>an {@linkplain #isUnnamedClass() unnamed class}\n@@ -1976,0 +2007,3 @@\n+        if (isUnnamedClass()) {\n+            return null;\n+        }\n@@ -2010,0 +2044,20 @@\n+    \/**\n+     * {@return {@code true} if and only if the underlying class\n+     * is an unnamed class}\n+     *\n+     * @apiNote\n+     * An unnamed class is not an {@linkplain #isAnonymousClass anonymous class}.\n+     *\n+     * @since 21\n+     *\n+     * @jls 7.3 Compilation Units\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.UNNAMED_CLASSES,\n+                    reflective=true)\n+    public boolean isUnnamedClass() {\n+        return PreviewFeatures.isEnabled() && isSynthetic()\n+                                           && isTopLevelClass()\n+                                           && Modifier.isFinal(getModifiers());\n+    }\n+\n+\n@@ -2016,0 +2070,1 @@\n+     * An anonymous class is not an {@linkplain #isUnnamedClass() unnamed class}.\n@@ -2662,1 +2717,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -2670,1 +2725,1 @@\n-     * }}<\/pre>\n+     * }}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":85,"deletions":30,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -757,1 +757,4 @@\n-     *     <td>Java class format version number<\/td><\/tr>\n+     *     <td>{@linkplain java.lang.reflect.ClassFileFormatVersion#latest() Latest}\n+     *     Java class file format version recognized by the Java runtime as {@code \"MAJOR.MINOR\"}\n+     *     where {@link java.lang.reflect.ClassFileFormatVersion#major() MAJOR} and {@code MINOR}\n+     *     are both formatted as decimal integers<\/td><\/tr>\n@@ -2622,13 +2625,0 @@\n-            public Object findScopedValueBindings() {\n-                return Thread.findScopedValueBindings();\n-            }\n-\n-            public void setScopedValueBindings(Object bindings) {\n-                Thread.setScopedValueBindings(bindings);\n-            }\n-\n-            @ForceInline\n-            public void ensureMaterializedForStackWalk(Object value) {\n-                Thread.ensureMaterializedForStackWalk(value);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.nio.file.Path;\n@@ -98,1 +97,1 @@\n-        lambdaProxyClassFileDumper = ClassFileDumper.getInstance(dumpProxyClassesKey, Path.of(\"DUMP_LAMBDA_PROXY_CLASS_FILES\"));\n+        lambdaProxyClassFileDumper = ClassFileDumper.getInstance(dumpProxyClassesKey, \"DUMP_LAMBDA_PROXY_CLASS_FILES\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-import java.nio.file.Path;\n@@ -2257,1 +2256,1 @@\n-                \"jdk.invoke.MethodHandle.dumpClassFiles\", Path.of(\"DUMP_CLASS_FILES\"));\n+                \"jdk.invoke.MethodHandle.dumpClassFiles\", \"DUMP_CLASS_FILES\");\n@@ -3962,0 +3961,8 @@\n+        private boolean isArrayClone(byte refKind, Class<?> refc, MemberName m) {\n+            return Modifier.isProtected(m.getModifiers()) &&\n+                    refKind == REF_invokeVirtual &&\n+                    m.getDeclaringClass() == Object.class &&\n+                    m.getName().equals(\"clone\") &&\n+                    refc.isArray();\n+        }\n+\n@@ -3970,5 +3977,1 @@\n-            if (Modifier.isProtected(mods) &&\n-                    refKind == REF_invokeVirtual &&\n-                    m.getDeclaringClass() == Object.class &&\n-                    m.getName().equals(\"clone\") &&\n-                    refc.isArray()) {\n+            if (isArrayClone(refKind, refc, m)) {\n@@ -4100,1 +4103,1 @@\n-                !refc.isInterface() &&\n+                !refc.isInterface() && !lookupClass().isInterface() &&\n@@ -4133,1 +4136,6 @@\n-                    (MethodHandleNatives.refKindHasReceiver(refKind) && restrictProtectedReceiver(method))) {\n+                    (MethodHandleNatives.refKindHasReceiver(refKind) &&\n+                            restrictProtectedReceiver(method) &&\n+                            \/\/ All arrays simply inherit the protected Object.clone method.\n+                            \/\/ The leading argument is already restricted to the requested\n+                            \/\/ array type (not the lookup class).\n+                            !isArrayClone(refKind, refc, method))) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-    private transient ConstructorRepository genericInfo;\n+    private transient volatile ConstructorRepository genericInfo;\n@@ -91,0 +91,1 @@\n+        var genericInfo = this.genericInfo;\n@@ -97,0 +98,1 @@\n+            this.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-    private transient FieldRepository genericInfo;\n+    private transient volatile FieldRepository genericInfo;\n@@ -110,0 +110,1 @@\n+        var genericInfo = this.genericInfo;\n@@ -115,0 +116,1 @@\n+            this.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-    private transient MethodRepository genericInfo;\n+    private transient volatile MethodRepository genericInfo;\n@@ -112,0 +112,1 @@\n+        var genericInfo = this.genericInfo;\n@@ -117,0 +118,1 @@\n+            this.genericInfo = genericInfo;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -535,9 +535,0 @@\n-    \/**\n-     * Set the current thread's scoped value bindings.\n-     *\/\n-    void setScopedValueBindings(Object bindings);\n-\n-    Object findScopedValueBindings();\n-\n-    void ensureMaterializedForStackWalk(Object value);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        @JEP(number=430, title=\"String Templates\", status=\"First Preview\")\n+        @JEP(number=430, title=\"String Templates\")\n@@ -77,0 +77,6 @@\n+        @JEP(number=445, title=\"Unnamed Classes and Instance Main Methods\")\n+        UNNAMED_CLASSES,\n+        @JEP(number=446, title=\"Scoped Values\", status=\"Preview\")\n+        SCOPED_VALUES,\n+        @JEP(number=453, title=\"Structured Concurrency\", status=\"Preview\")\n+        STRUCTURED_CONCURRENCY,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -164,1 +164,0 @@\n-        jdk.incubator.concurrent,\n@@ -224,1 +223,0 @@\n-        jdk.incubator.concurrent,\n@@ -258,1 +256,0 @@\n-        jdk.incubator.concurrent,\n@@ -266,1 +263,0 @@\n-        jdk.incubator.concurrent,\n@@ -287,0 +283,1 @@\n+        jdk.jpackage,\n@@ -329,2 +326,1 @@\n-        jdk.crypto.ec,\n-        jdk.incubator.concurrent;\n+        jdk.crypto.ec;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,0 +156,4 @@\n+    \/** Class is a unnamed top level class.\n+     *\/\n+    public static final int UNNAMED_CLASS    = 1<<23;\n+\n@@ -539,0 +543,1 @@\n+        UNNAMED_CLASS(Flags.UNNAMED_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,0 +243,1 @@\n+        UNNAMED_CLASSES(JDK21, Fragments.FeatureUnnamedClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1296,0 +1296,1 @@\n+    @SuppressWarnings(\"preview\") \/\/ isUnnamed()\n@@ -1408,4 +1409,9 @@\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public Name getQualifiedName() {\n-            return fullname;\n-        }\n+         @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+         public Name getQualifiedName() {\n+             return isUnnamed() ? fullname.subName(0, 0) \/* empty name *\/ : fullname;\n+         }\n+\n+         @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+         public Name getSimpleName() {\n+             return name;\n+         }\n@@ -1594,1 +1600,1 @@\n-            if (owner.kind == PCK)\n+            if (owner.kind == PCK) \/\/ Handles unnamed classes as well\n@@ -1686,0 +1692,5 @@\n+\n+        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+        public boolean isUnnamed() {\n+            return (flags_field & Flags.UNNAMED_CLASS) != 0 ;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1676,0 +1676,1 @@\n+            boolean intSwitch = types.isAssignable(seltype, syms.intType);\n@@ -1677,2 +1678,1 @@\n-            if (!enumSwitch && !stringSwitch && !errorEnumSwitch &&\n-                !types.isAssignable(seltype, syms.intType)) {\n+            if (!enumSwitch && !stringSwitch && !errorEnumSwitch && !intSwitch) {\n@@ -1725,0 +1725,4 @@\n+                                    Symbol enumSym = TreeInfo.symbol(expr);\n+                                    if (enumSym == null || !enumSym.isEnum() || enumSym.kind != VAR) {\n+                                        log.error(expr.pos(), Errors.EnumLabelMustBeEnumConstant);\n+                                    }\n@@ -1747,1 +1751,1 @@\n-                                    if (s != null && s.kind == TYP && allowPatternSwitch) {\n+                                    if (s != null && s.kind == TYP) {\n@@ -1750,1 +1754,1 @@\n-                                    } else if ((s != null && !s.isEnum()) || !allowPatternSwitch) {\n+                                    } else if (s == null || !s.isEnum()) {\n@@ -1752,1 +1756,3 @@\n-                                                  (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));\n+                                                  (stringSwitch ? Errors.StringConstReq\n+                                                                : intSwitch ? Errors.ConstExprReq\n+                                                                            : Errors.PatternOrEnumReq));\n@@ -1754,1 +1760,1 @@\n-                                } else if (!stringSwitch && !types.isAssignable(seltype, syms.intType)) {\n+                                } else if (!stringSwitch && !intSwitch) {\n@@ -5616,0 +5622,4 @@\n+\n+                if ((c.flags_field & Flags.UNNAMED_CLASS) != 0) {\n+                    chk.checkHasMain(env.tree.pos(), c);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2446,0 +2446,30 @@\n+    public void checkHasMain(DiagnosticPosition pos, ClassSymbol c) {\n+        boolean found = false;\n+\n+        for (Symbol sym : c.members().getSymbolsByName(names.main)) {\n+            if (sym.kind == MTH && (sym.flags() & PRIVATE) == 0) {\n+                MethodSymbol meth = (MethodSymbol)sym;\n+                if (!types.isSameType(meth.getReturnType(), syms.voidType)) {\n+                    continue;\n+                }\n+                if (meth.params.isEmpty()) {\n+                    found = true;\n+                    break;\n+                }\n+                if (meth.params.size() != 1) {\n+                    continue;\n+                }\n+                if (!types.isSameType(meth.params.head.type, types.makeArrayType(syms.stringType))) {\n+                    continue;\n+                }\n+\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found) {\n+            log.error(pos, Errors.UnnamedClassDoesNotHaveMainMethod);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,2 +315,0 @@\n-\/\/        Assert.checkNonNull(tree.modle, tree.sourcefile.toString());\n-\n@@ -448,0 +446,3 @@\n+            if ((tree.mods.flags & UNNAMED_CLASS) != 0) {\n+                syms.removeClass(env.toplevel.modle, tree.name);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1098,0 +1098,3 @@\n+                if (!it.hasTag(CLASS)) {\n+                    continue;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2486,1 +2486,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2796,0 +2796,8 @@\n+        if (previewClassFile) {\n+            if ((c.flags_field & SYNTHETIC) != 0 &&\n+                    c.owner.kind == PCK &&\n+                    (c.flags_field & AUXILIARY) == 0 &&\n+                    (c.flags_field & FINAL) != 0) {\n+                c.flags_field |= UNNAMED_CLASS;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import javax.lang.model.SourceVersion;\n+\n@@ -40,0 +42,1 @@\n+import com.sun.tools.javac.file.PathFileObject;\n@@ -188,1 +191,1 @@\n-        docComments = newDocCommentTable(keepDocComments, fac);\n+        this.docComments = newDocCommentTable(keepDocComments, fac);\n@@ -191,1 +194,1 @@\n-        endPosTable = newEndPosTable(keepEndPositions);\n+        this.endPosTable = newEndPosTable(keepEndPositions);\n@@ -199,0 +202,25 @@\n+    \/** Construct a parser from an existing parser, with minimal overhead.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected JavacParser(JavacParser parser,\n+                          Lexer S) {\n+        this.S = S;\n+        this.token = parser.token;\n+        this.F = parser.F;\n+        this.log = parser.log;\n+        this.names = parser.names;\n+        this.source = parser.source;\n+        this.preview = parser.preview;\n+        this.allowStringFolding = parser.allowStringFolding;\n+        this.keepDocComments = false;\n+        this.parseModuleInfo = false;\n+        this.docComments = null;\n+        this.errorTree = F.Erroneous();\n+        this.endPosTable = newEndPosTable(false);\n+        this.allowYieldStatement = Feature.SWITCH_EXPRESSION.allowedInSource(source);\n+        this.allowRecords = Feature.RECORDS.allowedInSource(source);\n+        this.allowSealedTypes = Feature.SEALED_CLASSES.allowedInSource(source);\n+        this.allowPrimitiveClasses = parser.allowPrimitiveClasses;\n+        this.allowValueClasses = parser.allowValueClasses;\n+    }\n+\n@@ -656,0 +684,3 @@\n+                if (peekToken(LBRACKET)) {\n+                    log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UseOfUnderscoreNotAllowedWithBrackets);\n+                }\n@@ -921,1 +952,5 @@\n-                JCVariableDecl var = variableDeclaratorRest(varPos, mods, e, identOrUnderscore(), false, null, false, false, true);\n+                Name name = identOrUnderscore();\n+                if (Feature.UNNAMED_VARIABLES.allowedInSource(source) && name == names.underscore) {\n+                    name = names.empty;\n+                }\n+                JCVariableDecl var = toP(F.at(varPos).VarDef(mods, name, e, null));\n@@ -2850,4 +2885,1 @@\n-            if (token.kind == INTERFACE ||\n-                token.kind == CLASS ||\n-                token.kind == ENUM ||\n-                isRecordStart()) {\n+            if (isDeclaration()) {\n@@ -3700,1 +3732,1 @@\n-        JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false, false);\n+        JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);\n@@ -3715,1 +3747,1 @@\n-        return variableDeclaratorRest(token.pos, mods, type, identOrUnderscore(), reqInit, dc, localDecl, true, false);\n+        return variableDeclaratorRest(token.pos, mods, type, identOrUnderscore(), reqInit, dc, localDecl, true);\n@@ -3725,1 +3757,1 @@\n-                                  boolean reqInit, Comment dc, boolean localDecl, boolean compound, boolean isTypePattern) {\n+                                  boolean reqInit, Comment dc, boolean localDecl, boolean compound) {\n@@ -3727,1 +3759,1 @@\n-        type = bracketsOpt(type);\n+        type = bracketsOpt(type);\n@@ -3731,1 +3763,1 @@\n-            if (!localDecl && !isTypePattern) {\n+            if (!localDecl) {\n@@ -3750,23 +3782,20 @@\n-        JCVariableDecl result;\n-        if (!isTypePattern) {\n-            int startPos = Position.NOPOS;\n-            JCTree elemType = TreeInfo.innermostType(type, true);\n-            if (elemType.hasTag(IDENT)) {\n-                Name typeName = ((JCIdent) elemType).name;\n-                if (restrictedTypeNameStartingAtSource(typeName, pos, !compound && localDecl) != null) {\n-                    if (typeName != names.var) {\n-                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedHere(typeName));\n-                    } else if (type.hasTag(TYPEARRAY) && !compound) {\n-                        \/\/error - 'var' and arrays\n-                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n-                    } else {\n-                        declaredUsingVar = true;\n-                        if (compound)\n-                            \/\/error - 'var' in compound local var decl\n-                            reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n-                        startPos = TreeInfo.getStartPos(mods);\n-                        if (startPos == Position.NOPOS)\n-                            startPos = TreeInfo.getStartPos(type);\n-                        \/\/implicit type\n-                        type = null;\n-                    }\n+        int startPos = Position.NOPOS;\n+        JCTree elemType = TreeInfo.innermostType(type, true);\n+        if (elemType.hasTag(IDENT)) {\n+            Name typeName = ((JCIdent) elemType).name;\n+            if (restrictedTypeNameStartingAtSource(typeName, pos, !compound && localDecl) != null) {\n+                if (typeName != names.var) {\n+                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedHere(typeName));\n+                } else if (type.hasTag(TYPEARRAY) && !compound) {\n+                    \/\/error - 'var' and arrays\n+                    reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedArray(typeName));\n+                } else {\n+                    declaredUsingVar = true;\n+                    if (compound)\n+                        \/\/error - 'var' in compound local var decl\n+                        reportSyntaxError(elemType.pos, Errors.RestrictedTypeNotAllowedCompound(typeName));\n+                    startPos = TreeInfo.getStartPos(mods);\n+                    if (startPos == Position.NOPOS)\n+                        startPos = TreeInfo.getStartPos(type);\n+                    \/\/implicit type\n+                    type = null;\n@@ -3775,6 +3804,3 @@\n-            result = toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n-            attach(result, dc);\n-            result.startPos = startPos;\n-        } else {\n-            result = toP(F.at(pos).VarDef(mods, name, type, null));\n-\n+        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n+        attach(result, dc);\n+        result.startPos = startPos;\n@@ -3944,1 +3970,1 @@\n-            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false, false);\n+            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false);\n@@ -3949,1 +3975,1 @@\n-            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false, false);\n+            return variableDeclaratorRest(token.pos, mods, t, identOrUnderscore(), true, null, true, false);\n@@ -3991,0 +4017,1 @@\n+        boolean isUnnamedClass = false;\n@@ -4049,0 +4076,1 @@\n+\n@@ -4050,4 +4078,29 @@\n-                JCTree def = typeDeclaration(mods, docComment);\n-                if (def instanceof JCExpressionStatement statement)\n-                    def = statement.expr;\n-                defs.append(def);\n+                boolean isTopLevelMethodOrField = false;\n+\n+                \/\/ Do to a significant number of existing negative tests\n+                \/\/ this code speculatively tests to see if a top level method\n+                \/\/ or field can parse. If the method or field can parse then\n+                \/\/ it is parsed. Otherwise, parsing continues as though\n+                \/\/ unnamed classes did not exist and error reporting\n+                \/\/ is the same as in the past.\n+                if (Feature.UNNAMED_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                    final JCModifiers finalMods = mods;\n+                    JavacParser speculative = new VirtualParser(this);\n+                    List<JCTree> speculativeResult =\n+                            speculative.topLevelMethodOrFieldDeclaration(finalMods);\n+                    if (speculativeResult.head.hasTag(METHODDEF) ||\n+                        speculativeResult.head.hasTag(VARDEF)) {\n+                        isTopLevelMethodOrField = true;\n+                    }\n+                }\n+\n+                if (isTopLevelMethodOrField) {\n+                    defs.appendList(topLevelMethodOrFieldDeclaration(mods));\n+                    isUnnamedClass = true;\n+                } else {\n+                    JCTree def = typeDeclaration(mods, docComment);\n+                    if (def instanceof JCExpressionStatement statement)\n+                        def = statement.expr;\n+                    defs.append(def);\n+                }\n+\n@@ -4058,1 +4111,2 @@\n-        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());\n+        List<JCTree> topLevelDefs = isUnnamedClass ?  constructUnnamedClass(defs.toList()) : defs.toList();\n+        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(topLevelDefs);\n@@ -4072,0 +4126,37 @@\n+    \/\/ Restructure top level to be an unnamed class.\n+    private List<JCTree> constructUnnamedClass(List<JCTree> origDefs) {\n+        checkSourceLevel(Feature.UNNAMED_CLASSES);\n+\n+        ListBuffer<JCTree> topDefs = new ListBuffer<>();\n+        ListBuffer<JCTree> defs = new ListBuffer<>();\n+\n+        for (JCTree def : origDefs) {\n+            if (def.hasTag(Tag.PACKAGEDEF)) {\n+                log.error(def.pos(), Errors.UnnamedClassShouldNotHavePackageDeclaration);\n+            } else if (def.hasTag(Tag.IMPORT)) {\n+                topDefs.append(def);\n+            } else if (!def.hasTag(Tag.SKIP)) {\n+                defs.append(def);\n+            }\n+        }\n+\n+        int primaryPos = defs.first().pos;\n+        String simplename = PathFileObject.getSimpleName(log.currentSourceFile());\n+\n+        if (simplename.endsWith(\".java\")) {\n+            simplename = simplename.substring(0, simplename.length() - \".java\".length());\n+        }\n+        if (!SourceVersion.isIdentifier(simplename) || SourceVersion.isKeyword(simplename)) {\n+            log.error(primaryPos, Errors.BadFileName(simplename));\n+        }\n+\n+        Name name = names.fromString(simplename);\n+        JCModifiers unnamedMods = F.at(primaryPos)\n+                .Modifiers(Flags.FINAL|Flags.SYNTHETIC|Flags.UNNAMED_CLASS, List.nil());\n+        JCClassDecl unnamed = F.at(primaryPos).ClassDef(\n+                unnamedMods, name, List.nil(), null, List.nil(), List.nil(),\n+                defs.toList());\n+        topDefs.append(unnamed);\n+        return topDefs.toList();\n+    }\n+\n@@ -4232,1 +4323,2 @@\n-            final JCErroneous erroneousTree;\n+\n+            JCDiagnostic.Error error;\n@@ -4234,1 +4326,3 @@\n-                erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);\n+                error = Errors.ExpectedModuleOrOpen;\n+            } else if (allowRecords) {\n+                error = Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\");\n@@ -4236,5 +4330,1 @@\n-                if (allowRecords) {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\"));\n-                } else {\n-                    erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));\n-                }\n+                error = Errors.Expected3(CLASS, INTERFACE, ENUM);\n@@ -4242,1 +4332,2 @@\n-            return toP(F.Exec(erroneousTree));\n+            return toP(F.Exec(syntaxError(pos, errs, error)));\n+\n@@ -4464,1 +4555,1 @@\n-                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,\n+                defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, enumName,\n@@ -4570,1 +4661,1 @@\n-            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));\n+            defs.appendList(classOrInterfaceOrRecordBodyDeclaration(null, className, isInterface, isRecord));\n@@ -4574,1 +4665,1 @@\n-           }\n+            }\n@@ -4609,1 +4700,3 @@\n-    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {\n+    protected List<JCTree> classOrInterfaceOrRecordBodyDeclaration(JCModifiers mods, Name className,\n+                                                                   boolean isInterface,\n+                                                                   boolean isRecord) {\n@@ -4616,5 +4709,2 @@\n-            JCModifiers mods = modifiersOpt();\n-            if (token.kind == CLASS ||\n-                allowRecords && isRecordStart() ||\n-                token.kind == INTERFACE ||\n-                token.kind == ENUM) {\n+            mods = modifiersOpt(mods);\n+            if (isDeclaration()) {\n@@ -4632,9 +4722,4 @@\n-                pos = token.pos;\n-                List<JCTypeParameter> typarams = typeParametersOpt();\n-                \/\/ if there are type parameters but no modifiers, save the start\n-                \/\/ position of the method in the modifiers.\n-                if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n-                    mods.pos = pos;\n-                    storeEnd(mods, pos);\n-                }\n-                List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+                return constructorOrMethodOrFieldDeclaration(mods, className, isInterface, isRecord, dc);\n+            }\n+        }\n+    }\n@@ -4642,5 +4727,13 @@\n-                if (annosAfterParams.nonEmpty()) {\n-                    mods.annotations = mods.annotations.appendList(annosAfterParams);\n-                    if (mods.pos == Position.NOPOS)\n-                        mods.pos = mods.annotations.head.pos;\n-                }\n+    private List<JCTree> constructorOrMethodOrFieldDeclaration(JCModifiers mods, Name className,\n+                                                               boolean isInterface,\n+                                                               boolean isRecord, Comment dc) {\n+        int pos;\n+        pos = token.pos;\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n@@ -4648,71 +4741,30 @@\n-                Token tk = token;\n-                pos = token.pos;\n-                JCExpression type;\n-                boolean isVoid = token.kind == VOID;\n-                if (isVoid) {\n-                    type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n-                    nextToken();\n-                } else {\n-                    \/\/ method returns types are un-annotated types\n-                    type = unannotatedType(false);\n-                }\n-                if ((token.kind == LPAREN && !isInterface ||\n-                        isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n-                    if (isInterface || tk.name() != className)\n-                        log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n-                    else if (annosAfterParams.nonEmpty())\n-                        illegal(annosAfterParams.head.pos);\n-                    if (isRecord && token.kind == LBRACE) {\n-                        mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n-                    }\n-                    return List.of(methodDeclaratorRest(\n-                        pos, mods, null, names.init, typarams,\n-                        isInterface, true, isRecord, dc));\n-                } else if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n-                    \/\/ trying to define a compact constructor with a throws clause\n-                    log.error(DiagnosticFlag.SYNTAX, token.pos,\n-                            Errors.InvalidCanonicalConstructorInRecord(\n-                                    Fragments.Compact,\n-                                    className,\n-                                    Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n-                    skip(false, true, false, false);\n-                    return List.of(methodDeclaratorRest(\n-                            pos, mods, null, names.init, typarams,\n-                            isInterface, true, isRecord, dc));\n-                } else {\n-                    pos = token.pos;\n-                    Name name = ident();\n-                    if (token.kind == LPAREN) {\n-                        return List.of(methodDeclaratorRest(\n-                            pos, mods, type, name, typarams,\n-                            isInterface, isVoid, false, dc));\n-                    } else if (!isVoid && typarams.isEmpty()) {\n-                        if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n-                        List<JCTree> defs =\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                                    new ListBuffer<JCTree>(), false).toList();\n-                        accept(SEMI);\n-                        storeEnd(defs.last(), S.prevToken().endPos);\n-                        return defs;\n-                    } else {\n-                            int errPos = pos;\n-                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n-                                    new ListBuffer<JCTree>(), false).toList();\n-                            accept(SEMI);\n-                            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n-                        }\n-                    } else {\n-                        pos = token.pos;\n-                        List<JCTree> err;\n-                        if (isVoid || typarams.nonEmpty()) {\n-                            JCMethodDecl m =\n-                                    toP(F.at(pos).MethodDef(mods, name, type, typarams,\n-                                                            List.nil(), List.nil(), null, null));\n-                            attach(m, dc);\n-                            err = List.of(m);\n-                        } else {\n-                            err = List.nil();\n-                        }\n-                        return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n-                    }\n-                }\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        Token tk = token;\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            \/\/ method returns types are un-annotated types\n+            type = unannotatedType(false);\n+        }\n+\n+        \/\/ Constructor\n+        if ((token.kind == LPAREN && !isInterface ||\n+                isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {\n+            if (isInterface || tk.name() != className) {\n+                log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+            } else if (annosAfterParams.nonEmpty()) {\n+                illegal(annosAfterParams.head.pos);\n+            }\n+\n+            if (isRecord && token.kind == LBRACE) {\n+                mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;\n@@ -4720,0 +4772,28 @@\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n+        }\n+\n+        \/\/ Record constructor\n+        if (isRecord && type.hasTag(IDENT) && token.kind == THROWS) {\n+            \/\/ trying to define a compact constructor with a throws clause\n+            log.error(DiagnosticFlag.SYNTAX, token.pos,\n+                    Errors.InvalidCanonicalConstructorInRecord(\n+                            Fragments.Compact,\n+                            className,\n+                            Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));\n+            skip(false, true, false, false);\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    isInterface, true, isRecord, dc));\n+        }\n+\n+        pos = token.pos;\n+        Name name = ident();\n+\n+        \/\/ Method\n+        if (token.kind == LPAREN) {\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, type, name, typarams,\n+                    isInterface, isVoid, false, dc));\n@@ -4721,0 +4801,34 @@\n+\n+        \/\/ Field\n+        if (!isVoid && typarams.isEmpty()) {\n+            if (!isRecord || (isRecord && (mods.flags & Flags.STATIC) != 0)) {\n+                List<JCTree> defs =\n+                    variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                                            new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+                return defs;\n+            }\n+\n+            int errPos = pos;\n+            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,\n+                    new ListBuffer<JCTree>(), false).toList();\n+            accept(SEMI);\n+            return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));\n+         }\n+\n+         pos = token.pos;\n+         List<JCTree> err;\n+\n+         \/\/ Error recovery\n+         if (isVoid || typarams.nonEmpty()) {\n+             JCMethodDecl m =\n+                     toP(F.at(pos).MethodDef(mods, name, type, typarams,\n+                                             List.nil(), List.nil(), null, null));\n+             attach(m, dc);\n+             err = List.of(m);\n+         } else {\n+             err = List.nil();\n+         }\n+\n+         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));\n@@ -4723,0 +4837,64 @@\n+    private List<JCTree> topLevelMethodOrFieldDeclaration(JCModifiers mods) throws AssertionError {\n+        int topPos = token.pos;\n+        int pos = token.pos;\n+        Comment dc = token.comment(CommentStyle.JAVADOC);\n+        List<JCTypeParameter> typarams = typeParametersOpt();\n+\n+        \/\/ if there are type parameters but no modifiers, save the start\n+        \/\/ position of the method in the modifiers.\n+        if (typarams.nonEmpty() && mods.pos == Position.NOPOS) {\n+            mods.pos = pos;\n+            storeEnd(mods, pos);\n+        }\n+\n+        List<JCAnnotation> annosAfterParams = annotationsOpt(Tag.ANNOTATION);\n+\n+        if (annosAfterParams.nonEmpty()) {\n+            mods.annotations = mods.annotations.appendList(annosAfterParams);\n+            if (mods.pos == Position.NOPOS)\n+                mods.pos = mods.annotations.head.pos;\n+        }\n+\n+        pos = token.pos;\n+        JCExpression type;\n+        boolean isVoid = token.kind == VOID;\n+\n+        if (isVoid) {\n+            type = to(F.at(pos).TypeIdent(TypeTag.VOID));\n+            nextToken();\n+        } else {\n+            type = unannotatedType(false);\n+        }\n+\n+        if (token.kind == IDENTIFIER) {\n+            pos = token.pos;\n+            Name name = ident();\n+\n+            \/\/ Method\n+            if (token.kind == LPAREN) {\n+                return List.of(methodDeclaratorRest(pos, mods, type, name, typarams,\n+                        false, isVoid, false, dc));\n+            }\n+\n+            \/\/ Field\n+            if (!isVoid && typarams.isEmpty() && (token.kind == EQ || token.kind == SEMI)) {\n+                List<JCTree> defs =\n+                        variableDeclaratorsRest(pos, mods, type, name, false, dc,\n+                                new ListBuffer<JCTree>(), false).toList();\n+                accept(SEMI);\n+                storeEnd(defs.last(), S.prevToken().endPos);\n+\n+                return defs;\n+            }\n+        }\n+\n+        return List.of(F.Erroneous());\n+    }\n+\n+    protected boolean isDeclaration() {\n+        return token.kind == CLASS ||\n+               token.kind == INTERFACE ||\n+               token.kind == ENUM ||\n+               isRecordStart() && allowRecords;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":328,"deletions":150,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -420,0 +420,3 @@\n+compiler.err.pattern.or.enum.req=\\\n+    pattern or enum constant required\n+\n@@ -518,0 +521,10 @@\n+# 0: string\n+compiler.err.bad.file.name=\\\n+    bad file name: {0}\n+\n+compiler.err.unnamed.class.should.not.have.package.declaration=\\\n+    unnamed class should not have package declaration\n+\n+compiler.err.unnamed.class.does.not.have.main.method=\\\n+    unnamed class does not have main method in the form of void main() or void main(String[] args)\n+\n@@ -585,0 +598,3 @@\n+compiler.err.enum.label.must.be.enum.constant=\\\n+    an enum switch constant case label must be an enumeration constant\n+\n@@ -3164,0 +3180,3 @@\n+compiler.misc.feature.unnamed.classes=\\\n+    unnamed classes\n+\n@@ -3174,0 +3193,3 @@\n+compiler.err.use.of.underscore.not.allowed.with.brackets=\\\n+    the underscore keyword ''_'' is not allowed to be followed by brackets\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,2 @@\n+                || node instanceof JCMethodDecl\n+                || node instanceof JCVariableDecl\n@@ -1189,1 +1191,1 @@\n-        return false;\n+        return sym.kind == TYP && (sym.flags_field & Flags.UNNAMED_CLASS) != 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,1 @@\n+    public final Name main;\n@@ -411,0 +412,1 @@\n+        main = fromString(\"main\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,4 @@\n+compiler\/c2\/irTests\/TestVectorConditionalMove.java 8306922 generic-all\n+\n+compiler\/jvmci\/TestUncaughtErrorInCompileMethod.java 8309073 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -307,10 +307,0 @@\n-    public static final String CMOVE_VD = PREFIX + \"CMOVE_VD\" + POSTFIX;\n-    static {\n-        superWordNodes(CMOVE_VD, \"CMoveVD\");\n-    }\n-\n-    public static final String CMOVE_VF = PREFIX + \"CMOVE_VF\" + POSTFIX;\n-    static {\n-        superWordNodes(CMOVE_VF, \"CMoveVF\");\n-    }\n-\n@@ -807,0 +797,10 @@\n+    public static final String MIN_REDUCTION_V = PREFIX + \"MIN_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(MIN_REDUCTION_V, \"MinReductionV\");\n+    }\n+\n+    public static final String MAX_REDUCTION_V = PREFIX + \"MAX_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(MAX_REDUCTION_V, \"MaxReductionV\");\n+    }\n+\n@@ -1281,0 +1281,5 @@\n+    public static final String VECTOR_MASK_CMP = PREFIX + \"VECTOR_MASK_CMP\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_CMP, \"VectorMaskCmp\");\n+    }\n+\n@@ -1471,0 +1476,5 @@\n+    public static final String VSTOREMASK_TRUECOUNT = PREFIX + \"VSTOREMASK_TRUECOUNT\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VSTOREMASK_TRUECOUNT, \"vstoremask_truecount_neon\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -462,0 +462,1 @@\n+sun\/java2d\/DirectX\/OnScreenRenderingResizeTest\/OnScreenRenderingResizeTest.java 8301177 linux-x64\n@@ -489,0 +490,2 @@\n+java\/lang\/ScopedValue\/StressStackOverflow.java                  8303498 linux-s390x\n+\n@@ -627,0 +630,1 @@\n+javax\/sound\/sampled\/Clip\/ClipIsRunningAfterStop.java 8307574 linux-x64\n@@ -744,3 +748,0 @@\n-\n-jdk\/incubator\/concurrent\/ScopedValue\/StressStackOverflow.java   8303498 linux-s390x\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -291,1 +291,0 @@\n-    jdk\/incubator\/concurrent \\\n@@ -331,1 +330,0 @@\n-    jdk\/incubator\/concurrent \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}