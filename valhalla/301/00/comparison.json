{"files":[{"patch":"@@ -647,2 +647,1 @@\n-void Canonicalizer::do_WithField      (WithField*       x) {}\n-void Canonicalizer::do_DefaultValue   (DefaultValue*    x) {}\n+void Canonicalizer::do_Deoptimize     (Deoptimize*      x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,2 +88,1 @@\n-  virtual void do_WithField      (WithField*       x);\n-  virtual void do_DefaultValue   (DefaultValue*    x);\n+  virtual void do_Deoptimize     (Deoptimize*      x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -969,1 +969,0 @@\n-    x->as_NewInlineTypeInstance()->decrement_on_stack_count();\n@@ -998,1 +997,0 @@\n-  x->set_local_index(index);\n@@ -1002,1 +1000,0 @@\n-    x->as_NewInlineTypeInstance()->decrement_on_stack_count();\n@@ -1034,0 +1031,1 @@\n+    bool can_delay_access = false;\n@@ -1038,0 +1036,8 @@\n+      bool will_link;\n+      ciField* next_field = s.get_field(will_link);\n+      bool next_needs_patching = !next_field->holder()->is_loaded() ||\n+                                 !next_field->will_link(method(), Bytecodes::_getfield) ||\n+                                 PatchALot;\n+      can_delay_access = !next_needs_patching;\n+    }\n+    if (can_delay_access) {\n@@ -1090,1 +1096,0 @@\n-  value->set_escaped();\n@@ -1766,3 +1771,1 @@\n-void GraphBuilder::copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off,\n-                                       ValueStack* state_before, bool needs_patching) {\n-  assert(!needs_patching, \"Can't patch flattened inline type field access\");\n+void GraphBuilder::copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off, ValueStack* state_before) {\n@@ -1770,1 +1773,0 @@\n-  src->set_escaped();\n@@ -1775,1 +1777,1 @@\n-    LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);\n+    LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, false);\n@@ -1777,1 +1779,1 @@\n-    StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);\n+    StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, false);\n@@ -1850,1 +1852,0 @@\n-      val->set_escaped();\n@@ -1960,1 +1961,1 @@\n-                                       !next_field->will_link(method(), code) ||\n+                                       !next_field->will_link(method(), Bytecodes::_getfield) ||\n@@ -1998,0 +1999,1 @@\n+              assert(!needs_patching, \"Can't patch flattened inline type field access\");\n@@ -2001,2 +2003,1 @@\n-                                    new_instance, inline_klass->first_field_offset(),\n-                                    state_before, needs_patching);\n+                                    new_instance, inline_klass->first_field_offset(), state_before);\n@@ -2005,2 +2006,1 @@\n-                copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(),\n-                                    state_before, needs_patching);\n+                copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(), state_before);\n@@ -2016,1 +2016,0 @@\n-      val->set_escaped();\n@@ -2035,0 +2034,1 @@\n+        assert(!needs_patching, \"Can't patch flattened inline type field access\");\n@@ -2036,1 +2036,1 @@\n-        copy_inline_content(inline_klass, val, inline_klass->first_field_offset(), obj, offset, state_before, needs_patching);\n+        copy_inline_content(inline_klass, val, inline_klass->first_field_offset(), obj, offset, state_before);\n@@ -2049,0 +2049,4 @@\n+  \/\/ Save the entire state and re-execute on deopt\n+  ValueStack* state_before = copy_state_before();\n+  state_before->set_should_reexecute(true);\n+\n@@ -2054,0 +2058,7 @@\n+  Value val = pop(type);\n+  Value obj = apop();\n+\n+  if (!holder->is_loaded()) {\n+    apush(append_split(new Deoptimize(state_before)));\n+    return;\n+  }\n@@ -2056,3 +2067,4 @@\n-  const bool needs_patching = !holder->is_loaded() ||\n-                              !field_modify->will_link(method(), Bytecodes::_withfield) ||\n-                              PatchALot;\n+  const bool needs_patching = !field_modify->will_link(method(), Bytecodes::_withfield) ||\n+                              (!field_modify->is_flattened() && PatchALot);\n+  const int offset_modify = !needs_patching ? field_modify->offset() : -1;\n+  assert(holder->is_inlinetype(), \"must be an inline klass\");\n@@ -2063,18 +2075,0 @@\n-  const int offset = !needs_patching ? field_modify->offset() : -1;\n-\n-  ValueStack* state_before = copy_state_before();\n-  if (!holder->is_loaded()\n-      || needs_patching \/* FIXME: 8228634 - field_modify->will_link() may incorrectly return false *\/\n-      ) {\n-    Value val = pop(type);\n-    Value obj = apop();\n-    apush(append_split(new WithField(state_before)));\n-    return;\n-  }\n-\n-  Value val = pop(type);\n-  Value obj = apop();\n-\n-  assert(holder->is_inlinetype(), \"must be a value klass\");\n-  \/\/ Save the entire state and re-execute on deopt when executing withfield\n-  state_before->set_should_reexecute(true);\n@@ -2090,0 +2084,1 @@\n+    \/\/ Initialize fields which are not modified\n@@ -2092,3 +2087,3 @@\n-      int off = field->offset();\n-\n-      if (field->offset() != offset) {\n+      int offset = field->offset();\n+      \/\/ Don't use offset_modify here, it might be set to -1 if needs_patching\n+      if (offset != field_modify->offset()) {\n@@ -2098,1 +2093,1 @@\n-            copy_inline_content(vk, obj, off, new_instance, vk->first_field_offset(), state_before, needs_patching);\n+            copy_inline_content(vk, obj, offset, new_instance, vk->first_field_offset(), state_before);\n@@ -2101,2 +2096,1 @@\n-          \/\/ Only load those fields who are not modified\n-          LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);\n+          LoadField* load = new LoadField(obj, offset, field, false, state_before, false);\n@@ -2104,1 +2098,1 @@\n-          StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);\n+          StoreField* store = new StoreField(new_instance, offset, field, replacement, false, state_before, false);\n@@ -2112,1 +2106,1 @@\n-  if (field_modify->type()->basic_type() == T_BOOLEAN) {\n+  if (field_type == T_BOOLEAN) {\n@@ -2117,0 +2111,1 @@\n+    assert(!needs_patching, \"Can't patch flattened inline type field access\");\n@@ -2119,1 +2114,1 @@\n-      copy_inline_content(vk, val, vk->first_field_offset(), new_instance, field_modify->offset(), state_before, needs_patching);\n+      copy_inline_content(vk, val, vk->first_field_offset(), new_instance, offset_modify, state_before);\n@@ -2122,1 +2117,1 @@\n-    StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);\n+    StoreField* store = new StoreField(new_instance, offset_modify, field_modify, val, false, state_before, needs_patching);\n@@ -2466,7 +2461,0 @@\n-  if (recv != NULL) {\n-    recv->set_escaped();\n-  }\n-  for (int i=0; i<args->length(); i++) {\n-    args->at(0)->set_escaped();\n-  }\n-\n@@ -2508,2 +2496,1 @@\n-    ValueStack* state_before = copy_state_before();\n-    apush(append_split(new DefaultValue(state_before)));\n+    apush(append_split(new Deoptimize(copy_state_before())));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":45,"deletions":58,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -303,2 +303,1 @@\n-  void copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off,\n-                           ValueStack* state_before, bool needs_patching);\n+  void copy_inline_content(ciInlineKlass* vk, Value src, int src_off, Value dest, int dest_off, ValueStack* state_before);\n@@ -402,1 +401,1 @@\n-      v->as_NewInlineTypeInstance()->update_larval_state();\n+      v->as_NewInlineTypeInstance()->set_not_larva_anymore();\n@@ -406,2 +405,3 @@\n-    if (v != NULL && v->as_NewInlineTypeInstance() != NULL) {\n-      v->as_NewInlineTypeInstance()->update_stack_count();\n+    if (v != NULL && v->as_NewInlineTypeInstance() != NULL &&\n+        v->as_NewInlineTypeInstance()->in_larval_state()) {\n+      v->as_NewInlineTypeInstance()->decrement_on_stack_count();\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -80,2 +80,1 @@\n-class     WithField;\n-class     DefaultValue;\n+class     Deoptimize;\n@@ -188,2 +187,1 @@\n-  virtual void do_WithField      (WithField*       x) = 0;\n-  virtual void do_DefaultValue   (DefaultValue*    x) = 0;\n+  virtual void do_Deoptimize     (Deoptimize*      x) = 0;\n@@ -478,2 +476,2 @@\n-  void set_null_free(bool f)                    { set_flag(NeverNullFlag, f); }\n-  bool is_null_free() const                     { return check_flag(NeverNullFlag); }\n+  void set_null_free(bool f)                     { set_flag(NeverNullFlag, f); }\n+  bool is_null_free() const                      { return check_flag(NeverNullFlag); }\n@@ -492,6 +490,0 @@\n-  \/\/ withfield optimization\n-  virtual void set_escaped()                     { }\n-  virtual void set_local_index(int index)        { }\n-  virtual bool is_optimizable_for_withfield() const { return false; }\n-\n-\n@@ -597,2 +589,1 @@\n-  virtual WithField*        as_WithField()       { return NULL; }\n-  virtual DefaultValue*     as_DefaultValue()    { return NULL; }\n+  virtual Deoptimize*       as_Deoptimize()      { return NULL; }\n@@ -1420,1 +1411,2 @@\n-  virtual void set_local_index(int index) {\n+  void set_local_index(int index) {\n+    decrement_on_stack_count();\n@@ -1430,2 +1422,2 @@\n-  virtual bool in_larval_state() const { return _in_larval_state; }\n-  virtual void set_not_larva_anymore() { _in_larval_state = false; }\n+  bool in_larval_state() const { return _in_larval_state; }\n+  void set_not_larva_anymore() { _in_larval_state = false; }\n@@ -1433,13 +1425,3 @@\n-  virtual int on_stack_count() { return _on_stack_count; }\n-  virtual void increment_on_stack_count() { _on_stack_count++; }\n-  virtual void decrement_on_stack_count() { _on_stack_count--; }\n-\n-  void update_larval_state() {\n-    set_not_larva_anymore();\n-  }\n-\n-  void update_stack_count() {\n-    if (in_larval_state()) {\n-      decrement_on_stack_count();\n-    }\n-  }\n+  int on_stack_count() const { return _on_stack_count; }\n+  void increment_on_stack_count() { _on_stack_count++; }\n+  void decrement_on_stack_count() { _on_stack_count--; }\n@@ -1540,1 +1522,1 @@\n-LEAF(WithField, StateSplit)\n+LEAF(Deoptimize, StateSplit)\n@@ -1542,9 +1524,1 @@\n-  \/\/ creation\n-  WithField(ValueStack* state_before)\n-  : StateSplit(objectType, state_before) {}\n-};\n-\n-LEAF(DefaultValue, StateSplit)\n- public:\n-  \/\/ creation\n-  DefaultValue(ValueStack* state_before)\n+  Deoptimize(ValueStack* state_before)\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":14,"deletions":40,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -521,3 +521,0 @@\n-  if (x->is_optimizable_for_withfield()) {\n-    output()->print(\"(optimizable) \");\n-  }\n@@ -546,6 +543,2 @@\n-void InstructionPrinter::do_WithField(WithField* x) {\n-  output()->print(\"withfield\");\n-}\n-\n-void InstructionPrinter::do_DefaultValue(DefaultValue* x) {\n-  output()->print(\"defaultvalue\");\n+void InstructionPrinter::do_Deoptimize(Deoptimize* x) {\n+  output()->print(\"deoptimize\");\n@@ -554,1 +547,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -111,2 +111,1 @@\n-  virtual void do_WithField      (WithField*       x);\n-  virtual void do_DefaultValue   (DefaultValue*    x);\n+  virtual void do_Deoptimize     (Deoptimize*      x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+      case Bytecodes::_withfield:\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2349,15 +2349,1 @@\n-void LIRGenerator::do_WithField(WithField* x) {\n-  \/\/ This happens only when a class X uses the withfield bytecode to refer to\n-  \/\/ an inline class V, where V has not yet been loaded. This is not a common\n-  \/\/ case. Let's just deoptimize.\n-  CodeEmitInfo* info = state_for(x, x->state_before());\n-  CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),\n-                                      Deoptimization::Reason_unloaded,\n-                                      Deoptimization::Action_make_not_entrant);\n-  __ jump(stub);\n-  LIR_Opr reg = rlock_result(x, T_OBJECT);\n-  __ move(LIR_OprFact::oopConst(NULL), reg);\n-}\n-\n-void LIRGenerator::do_DefaultValue(DefaultValue* x) {\n-  \/\/ Same as withfield above. Let's deoptimize.\n+void LIRGenerator::do_Deoptimize(Deoptimize* x) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -595,2 +595,1 @@\n-  virtual void do_WithField      (WithField*       x);\n-  virtual void do_DefaultValue   (DefaultValue*    x);\n+  virtual void do_Deoptimize     (Deoptimize*      x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -520,2 +520,1 @@\n-  void do_WithField      (WithField*       x);\n-  void do_DefaultValue   (DefaultValue*    x);\n+  void do_Deoptimize     (Deoptimize*      x);\n@@ -712,2 +711,1 @@\n-void NullCheckVisitor::do_WithField      (WithField*       x) {}\n-void NullCheckVisitor::do_DefaultValue   (DefaultValue*    x) {}\n+void NullCheckVisitor::do_Deoptimize     (Deoptimize*      x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -154,2 +154,1 @@\n-    void do_WithField      (WithField*       x) { \/* nothing to do *\/ };\n-    void do_DefaultValue   (DefaultValue*    x) { \/* nothing to do *\/ };\n+    void do_Deoptimize     (Deoptimize*      x) { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,2 +193,1 @@\n-  void do_WithField      (WithField*       x) { \/* nothing to do *\/ }\n-  void do_DefaultValue   (DefaultValue*    x) { \/* nothing to do *\/ }\n+  void do_Deoptimize     (Deoptimize*      x) { \/* nothing to do *\/ }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -256,0 +256,1 @@\n+  bool is_withfield() const                      { return java_code() == Bytecodes::_withfield; }\n@@ -263,1 +264,2 @@\n-                                                          is_putstatic(); }\n+                                                          is_putstatic()  ||\n+                                                          is_withfield(); }\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1028,16 +1028,15 @@\n-      \/\/ If byte code is a withfield check if they are nestmates.\n-      bool are_nestmates = false;\n-      if (sel_klass->is_instance_klass() &&\n-          InstanceKlass::cast(sel_klass)->is_inline_klass() &&\n-          current_klass->is_instance_klass()) {\n-        are_nestmates = InstanceKlass::cast(link_info.current_klass())->has_nestmate_access_to(\n-                                                        InstanceKlass::cast(sel_klass), THREAD);\n-      }\n-      if (!are_nestmates) {\n-        ResourceMark rm(THREAD);\n-        stringStream ss;\n-        ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n-                 is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n-                  current_klass->external_name());\n-        THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n-      }\n+        \/\/ If byte code is a withfield check if they are nestmates.\n+        bool are_nestmates = false;\n+        if (sel_klass->is_instance_klass() &&\n+            InstanceKlass::cast(sel_klass)->is_inline_klass() &&\n+            current_klass->is_instance_klass()) {\n+          are_nestmates = InstanceKlass::cast(current_klass)->has_nestmate_access_to(InstanceKlass::cast(sel_klass), THREAD);\n+        }\n+        if (!are_nestmates) {\n+          ResourceMark rm(THREAD);\n+          stringStream ss;\n+          ss.print(\"Update to %s final field %s.%s attempted from a different class (%s) than the field's declaring class\",\n+                   is_static ? \"static\" : \"non-static\", resolved_klass->external_name(), fd.name()->as_C_string(),\n+                    current_klass->external_name());\n+          THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());\n+        }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"}]}