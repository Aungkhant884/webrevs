{"files":[{"patch":"@@ -2377,0 +2377,12 @@\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic()) {\n+      \/\/ An inline type is returned as fields in multiple registers.\n+      \/\/ Rax either contains an oop if the inline type is buffered or a pointer\n+      \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero rax\n+      \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+      \/\/ rax &= (rax & 1) - 1\n+      C2_MacroAssembler _masm(&cbuf);\n+      __ movptr(rscratch1, rax);\n+      __ andptr(rscratch1, 0x1);\n+      __ subptr(rscratch1, 0x1);\n+      __ andptr(rax, rscratch1);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1104,1 +1104,0 @@\n-        \/\/ type.\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1900,1 +1900,1 @@\n-    uint base_input = TypeFunc::Parms + 1;\n+    uint base_input = TypeFunc::Parms;\n@@ -2022,1 +2022,4 @@\n-    assert(callprojs->nb_resproj == 1, \"unexpected number of results\");\n+    \/\/ If the inlined code is dead, the result projections for an inline type returned as\n+    \/\/ fields have not been replaced. They will go away once the call is replaced by TOP below.\n+    assert(callprojs->nb_resproj == 1 || (call->tf()->returns_inline_type_as_fields() && stopped()),\n+           \"unexpected number of results\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -711,1 +711,1 @@\n-      if (replace_value && !Compile::current()->inlining_incrementally()) {\n+      if (replace_value && is_Parse()) {\n@@ -714,0 +714,1 @@\n+        assert(!Compile::current()->inlining_incrementally(), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -460,1 +460,4 @@\n-    if (con >= TypeFunc::Parms+1) {\n+    Node* field = NULL;\n+    if (con == TypeFunc::Parms) {\n+      field = get_oop();\n+    } else if (con > TypeFunc::Parms) {\n@@ -471,1 +474,1 @@\n-      Node* field = field_value_by_offset(f->offset(), true);\n+      field = field_value_by_offset(f->offset(), true);\n@@ -476,0 +479,2 @@\n+    }\n+    if (field != NULL) {\n@@ -624,0 +629,5 @@\n+  if (!in) {\n+    \/\/ Keep track of the oop. The returned inline type might already be buffered.\n+    Node* oop = kit->gvn().transform(new ProjNode(multi, base_input++));\n+    vt->set_oop(oop);\n+  }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+      DEBUG_ONLY(uint loop_count = 0);\n@@ -177,0 +178,1 @@\n+        assert(loop_count++ < K, \"infinite loop in ReplacedNodes::apply\");\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2118,2 +2118,1 @@\n-      field_array[pos] = TypePtr::BOTTOM;\n-      pos++;\n+      field_array[pos++] = get_const_type(return_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}