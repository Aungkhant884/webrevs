{"files":[{"patch":"@@ -2377,0 +2377,12 @@\n+    if (tf()->returns_inline_type_as_fields()) {\n+      \/\/ An inline type is returned as fields in multiple registers.\n+      \/\/ Rax either contains an oop if the inline type is buffered or a pointer\n+      \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero rax\n+      \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+      \/\/ rax &= (rax & 1) - 1\n+      C2_MacroAssembler _masm(&cbuf);\n+      __ movptr(rscratch1, rax);\n+      __ andptr(rscratch1, 0x1);\n+      __ subptr(rscratch1, 0x1);\n+      __ andptr(rax, rscratch1);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1104,1 +1104,0 @@\n-        \/\/ type.\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1900,1 +1900,1 @@\n-    uint base_input = TypeFunc::Parms + 1;\n+    uint base_input = TypeFunc::Parms;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,0 +624,5 @@\n+  if (!in) {\n+    \/\/ Keep track of the oop. The returned inline type might already be buffered.\n+    Node* oop = kit->gvn().transform(new ProjNode(multi, base_input++));\n+    vt->set_oop(oop);\n+  }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2118,2 +2118,1 @@\n-      field_array[pos] = TypePtr::BOTTOM;\n-      pos++;\n+      field_array[pos++] = get_const_type(return_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}