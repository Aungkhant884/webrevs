{"files":[{"patch":"@@ -125,0 +125,4 @@\n+int ciInlineKlass::oop_count() const {\n+  GUARDED_VM_ENTRY(return get_InlineKlass()->nonstatic_oop_count();)\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+  int oop_count() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3237,1 +3237,0 @@\n-#ifdef ASSERT\n@@ -3239,2 +3238,8 @@\n-      \/\/ Oop verification for loading object fields from scalarized inline types in the new entry point requires lots of space\n-      size += 5120;\n+      \/\/ Inline type entry points (MachVEPNodes) require lots of space for GC barriers and oop verification\n+      \/\/ when loading object fields from the buffered argument. Increase scratch buffer size accordingly.\n+      int barrier_size = UseZGC ? 200 : (7 DEBUG_ONLY(+ 37));\n+      for (ciSignatureStream str(C->method()->signature()); !str.at_return_type(); str.next()) {\n+        if (str.type()->is_inlinetype() && str.type()->as_inline_klass()->can_be_passed_as_fields()) {\n+          size += str.type()->as_inline_klass()->oop_count() * barrier_size;\n+        }\n+      }\n@@ -3242,1 +3247,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -803,0 +803,101 @@\n+\n+    static inline class LargeValueWithOops {\n+        \/\/ Use all 6 int registers + 50\/2 on stack = 29\n+        Object o1 = null;\n+        Object o2 = null;\n+        Object o3 = null;\n+        Object o4 = null;\n+        Object o5 = null;\n+        Object o6 = null;\n+        Object o7 = null;\n+        Object o8 = null;\n+        Object o9 = null;\n+        Object o10 = null;\n+        Object o11 = null;\n+        Object o12 = null;\n+        Object o13 = null;\n+        Object o14 = null;\n+        Object o15 = null;\n+        Object o16 = null;\n+        Object o17 = null;\n+        Object o18 = null;\n+        Object o19 = null;\n+        Object o20 = null;\n+        Object o21 = null;\n+        Object o22 = null;\n+        Object o23 = null;\n+        Object o24 = null;\n+        Object o25 = null;\n+        Object o26 = null;\n+        Object o27 = null;\n+        Object o28 = null;\n+        Object o29 = null;\n+    }\n+\n+    static inline class LargeValueWithoutOops {\n+        \/\/ Use all 6 int registers + 50\/2 on stack = 29\n+        int i1 = 0;\n+        int i2 = 0;\n+        int i3 = 0;\n+        int i4 = 0;\n+        int i5 = 0;\n+        int i6 = 0;\n+        int i7 = 0;\n+        int i8 = 0;\n+        int i9 = 0;\n+        int i10 = 0;\n+        int i11 = 0;\n+        int i12 = 0;\n+        int i13 = 0;\n+        int i14 = 0;\n+        int i15 = 0;\n+        int i16 = 0;\n+        int i17 = 0;\n+        int i18 = 0;\n+        int i19 = 0;\n+        int i20 = 0;\n+        int i21 = 0;\n+        int i22 = 0;\n+        int i23 = 0;\n+        int i24 = 0;\n+        int i25 = 0;\n+        int i26 = 0;\n+        int i27 = 0;\n+        int i28 = 0;\n+        int i29 = 0;\n+        \/\/ Use all 7 float registers\n+        double d1 = 0;\n+        double d2 = 0;\n+        double d3 = 0;\n+        double d4 = 0;\n+        double d5 = 0;\n+        double d6 = 0;\n+        double d7 = 0;\n+        double d8 = 0;\n+    }\n+\n+    \/\/ Test passing\/returning a large inline type with oop fields\n+    @Test()\n+    public static LargeValueWithOops test39(LargeValueWithOops vt) {\n+        return vt;\n+    }\n+\n+    @DontCompile\n+    public void test39_verifier(boolean warmup) {\n+        LargeValueWithOops vt = new LargeValueWithOops();\n+        LargeValueWithOops res = test39(vt);\n+        Asserts.assertEQ(res, vt);\n+    }\n+\n+    \/\/ Test passing\/returning a large inline type with only int\/float fields\n+    @Test()\n+    public static LargeValueWithoutOops test40(LargeValueWithoutOops vt) {\n+        return vt;\n+    }\n+\n+    @DontCompile\n+    public void test40_verifier(boolean warmup) {\n+        LargeValueWithoutOops vt = new LargeValueWithoutOops();\n+        LargeValueWithoutOops res = test40(vt);\n+        Asserts.assertEQ(res, vt);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"}]}