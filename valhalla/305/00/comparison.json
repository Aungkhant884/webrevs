{"files":[{"patch":"@@ -193,0 +193,1 @@\n+  phase->record_for_igvn(mem);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -533,1 +533,0 @@\n-        assert(!result->isa_InlineType()->is_allocated(&kit.gvn()), \"already allocated\");\n@@ -535,9 +534,12 @@\n-        vt->store(&kit, buffer_oop, buffer_oop, vt->type()->inline_klass());\n-        \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n-        \/\/ store that would make this buffer accessible by other threads.\n-        AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer_oop, &kit.gvn());\n-        assert(alloc != NULL, \"must have an allocation node\");\n-        kit.insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n-        \/\/ Convert to InlineTypePtrNode to keep track of field values\n-        kit.gvn().hash_delete(vt);\n-        vt->set_oop(buffer_oop);\n+        \/\/ Result might still be allocated (for example, if it has been stored to a non-flattened field)\n+        if (!vt->is_allocated(&kit.gvn())) {\n+          vt->store(&kit, buffer_oop, buffer_oop, vt->type()->inline_klass());\n+          \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n+          \/\/ store that would make this buffer accessible by other threads.\n+          AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer_oop, &kit.gvn());\n+          assert(alloc != NULL, \"must have an allocation node\");\n+          kit.insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n+          kit.gvn().hash_delete(vt);\n+          vt->set_oop(buffer_oop);\n+          vt = kit.gvn().transform(vt)->as_InlineType();\n+        }\n@@ -545,1 +547,1 @@\n-        vt = kit.gvn().transform(vt)->as_InlineType();\n+        \/\/ Convert to InlineTypePtrNode to keep track of field values\n@@ -991,0 +993,3 @@\n+  if (t->as_klass()->is_inlinetype()) {\n+    sig_type = sig_type->join_speculative(TypePtr::NOTNULL);\n+  }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -361,2 +361,2 @@\n-  if( in_type != NULL && my_type != NULL ) {\n-    if (my_type->isa_aryptr() && in_type->isa_aryptr()) {\n+  if (in_type != NULL && my_type != NULL) {\n+    if (!StressReflectiveCode && my_type->isa_aryptr() && in_type->isa_aryptr()) {\n@@ -364,0 +364,2 @@\n+      \/\/ Don't do this when StressReflectiveCode is enabled because it might lead to\n+      \/\/ a dying data path while the corresponding flat\/null-free check is not folded.\n@@ -369,1 +371,1 @@\n-    TypePtr::PTR   in_ptr    = in_type->ptr();\n+    TypePtr::PTR in_ptr = in_type->ptr();\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3375,1 +3375,1 @@\n-              op == Op_SubTypeCheck || op == Op_InlineType || op == Op_InlineTypePtr ||\n+              op == Op_SubTypeCheck || op == Op_InlineType || op == Op_InlineTypePtr || op == Op_FlatArrayCheck ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3662,1 +3662,1 @@\n-  if (!from_inline) {\n+  if (!stopped() && !from_inline) {\n@@ -3921,1 +3921,1 @@\n-    bool    xklass = inst_klass->klass_is_exact();\n+    bool xklass = inst_klass->klass_is_exact();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1302,1 +1302,1 @@\n-  assert(!needs_barriers, \"Flat arracopy would require GC barriers\");\n+  assert(!needs_barriers || StressReflectiveCode, \"Flat arracopy would require GC barriers\");\n@@ -1377,1 +1377,1 @@\n-      assert(dest_length != NULL, \"must be tightly coupled\");\n+      assert(dest_length != NULL || StressReflectiveCode, \"must be tightly coupled\");\n@@ -1459,1 +1459,2 @@\n-  assert(!ac->is_arraycopy_validated() || (src_elem == dest_elem && dest_elem != T_VOID), \"validated but different basic types\");\n+  assert(!ac->is_arraycopy_validated() || (src_elem == dest_elem && dest_elem != T_VOID) ||\n+         (src_elem == T_INLINE_TYPE && StressReflectiveCode), \"validated but different basic types\");\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-    } else if (!ary_t->is_not_flat() && tval != TypePtr::NULL_PTR) {\n+    } else if (!ary_t->is_not_flat() && (tval != TypePtr::NULL_PTR || StressReflectiveCode)) {\n@@ -310,1 +310,1 @@\n-        inline_array_null_guard(ary, cast_val, 3);\n+        Node* cast_ary = inline_array_null_guard(ary, cast_val, 3);\n@@ -312,1 +312,1 @@\n-        access_store_at(ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);\n+        access_store_at(cast_ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);\n@@ -2162,1 +2162,1 @@\n- if (UseTypeSpeculation) {\n+  if (UseTypeSpeculation) {\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4751,1 +4751,2 @@\n-      if (above_centerline(ptr) || (tary->_elem->make_ptr() && above_centerline(tary->_elem->make_ptr()->_ptr))) {\n+      if (above_centerline(ptr) || (tary->_elem->make_ptr() && above_centerline(tary->_elem->make_ptr()->_ptr)) ||\n+          tary->_elem->isa_inlinetype()) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -196,0 +196,1 @@\n+    protected static final long PerMethodTrapLimit = (Long)WHITE_BOX.getVMFlag(\"PerMethodTrapLimit\");\n@@ -851,1 +852,1 @@\n-        if (!USE_COMPILER || XCOMP || TEST_C1 ||\n+        if (!USE_COMPILER || XCOMP || TEST_C1 || (PerMethodTrapLimit == 0) ||\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}