{"files":[{"patch":"@@ -2306,1 +2306,1 @@\n-      if (!(UseSVE > 1 && VM_Version::supports_svebitperm())) {\n+      if (!VM_Version::supports_svebitperm()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  void inc_counter_np_(int& counter) {\n+  void inc_counter_np_(uint& counter) {\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4893,1 +4893,1 @@\n-  int* pst_counter = &SharedRuntime::_partial_subtype_ctr;\n+  uint* pst_counter = &SharedRuntime::_partial_subtype_ctr;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-static void inc_counter_np(MacroAssembler* _masm, int& counter, Register rscratch) {\n+static void inc_counter_np(MacroAssembler* _masm, uint& counter, Register rscratch) {\n@@ -64,1 +64,1 @@\n-static int& get_profile_ctr(int shift) {\n+static uint& get_profile_ctr(int shift) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-} TimerName;\n+} TimerId;\n@@ -76,1 +76,1 @@\n-static int totalInstructionNodes = 0;\n+static uint totalInstructionNodes = 0;\n@@ -81,1 +81,2 @@\n-  TimerName _timer;\n+  TimerId _timer_id;\n+  bool _dolog;\n@@ -84,3 +85,3 @@\n-  PhaseTraceTime(TimerName timer)\n-  : TraceTime(\"\", &timers[timer], CITime || CITimeEach, Verbose),\n-    _log(nullptr), _timer(timer)\n+  PhaseTraceTime(TimerId timer_id)\n+  : TraceTime(timer_name[timer_id], &timers[timer_id], CITime, CITimeVerbose),\n+    _log(nullptr), _timer_id(timer_id), _dolog(CITimeVerbose)\n@@ -88,1 +89,2 @@\n-    if (Compilation::current() != nullptr) {\n+    if (_dolog) {\n+      assert(Compilation::current() != nullptr, \"sanity check\");\n@@ -93,1 +95,1 @@\n-      _log->begin_head(\"phase name='%s'\", timer_name[_timer]);\n+      _log->begin_head(\"phase name='%s'\", timer_name[_timer_id]);\n@@ -101,1 +103,1 @@\n-      _log->done(\"phase name='%s'\", timer_name[_timer]);\n+      _log->done(\"phase name='%s'\", timer_name[_timer_id]);\n@@ -591,1 +593,0 @@\n-  PhaseTraceTime timeit(_t_compile);\n@@ -596,0 +597,1 @@\n+  PhaseTraceTime timeit(_t_compile);\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-              const int m = (1 << (BitsPerInt - s0c)) - 1;\n+              const int m = checked_cast<int>(right_n_bits(BitsPerInt - s0c));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,31 +121,31 @@\n-int Runtime1::_generic_arraycopystub_cnt = 0;\n-int Runtime1::_arraycopy_slowcase_cnt = 0;\n-int Runtime1::_arraycopy_checkcast_cnt = 0;\n-int Runtime1::_arraycopy_checkcast_attempt_cnt = 0;\n-int Runtime1::_new_type_array_slowcase_cnt = 0;\n-int Runtime1::_new_object_array_slowcase_cnt = 0;\n-int Runtime1::_new_flat_array_slowcase_cnt = 0;\n-int Runtime1::_new_instance_slowcase_cnt = 0;\n-int Runtime1::_new_multi_array_slowcase_cnt = 0;\n-int Runtime1::_load_flattened_array_slowcase_cnt = 0;\n-int Runtime1::_store_flattened_array_slowcase_cnt = 0;\n-int Runtime1::_substitutability_check_slowcase_cnt = 0;\n-int Runtime1::_buffer_inline_args_slowcase_cnt = 0;\n-int Runtime1::_buffer_inline_args_no_receiver_slowcase_cnt = 0;\n-int Runtime1::_monitorenter_slowcase_cnt = 0;\n-int Runtime1::_monitorexit_slowcase_cnt = 0;\n-int Runtime1::_patch_code_slowcase_cnt = 0;\n-int Runtime1::_throw_range_check_exception_count = 0;\n-int Runtime1::_throw_index_exception_count = 0;\n-int Runtime1::_throw_div0_exception_count = 0;\n-int Runtime1::_throw_null_pointer_exception_count = 0;\n-int Runtime1::_throw_class_cast_exception_count = 0;\n-int Runtime1::_throw_incompatible_class_change_error_count = 0;\n-int Runtime1::_throw_illegal_monitor_state_exception_count = 0;\n-int Runtime1::_throw_count = 0;\n-\n-static int _byte_arraycopy_stub_cnt = 0;\n-static int _short_arraycopy_stub_cnt = 0;\n-static int _int_arraycopy_stub_cnt = 0;\n-static int _long_arraycopy_stub_cnt = 0;\n-static int _oop_arraycopy_stub_cnt = 0;\n+uint Runtime1::_generic_arraycopystub_cnt = 0;\n+uint Runtime1::_arraycopy_slowcase_cnt = 0;\n+uint Runtime1::_arraycopy_checkcast_cnt = 0;\n+uint Runtime1::_arraycopy_checkcast_attempt_cnt = 0;\n+uint Runtime1::_new_type_array_slowcase_cnt = 0;\n+uint Runtime1::_new_object_array_slowcase_cnt = 0;\n+uint Runtime1::_new_flat_array_slowcase_cnt = 0;\n+uint Runtime1::_new_instance_slowcase_cnt = 0;\n+uint Runtime1::_new_multi_array_slowcase_cnt = 0;\n+uint Runtime1::_load_flattened_array_slowcase_cnt = 0;\n+uint Runtime1::_store_flattened_array_slowcase_cnt = 0;\n+uint Runtime1::_substitutability_check_slowcase_cnt = 0;\n+uint Runtime1::_buffer_inline_args_slowcase_cnt = 0;\n+uint Runtime1::_buffer_inline_args_no_receiver_slowcase_cnt = 0;\n+uint Runtime1::_monitorenter_slowcase_cnt = 0;\n+uint Runtime1::_monitorexit_slowcase_cnt = 0;\n+uint Runtime1::_patch_code_slowcase_cnt = 0;\n+uint Runtime1::_throw_range_check_exception_count = 0;\n+uint Runtime1::_throw_index_exception_count = 0;\n+uint Runtime1::_throw_div0_exception_count = 0;\n+uint Runtime1::_throw_null_pointer_exception_count = 0;\n+uint Runtime1::_throw_class_cast_exception_count = 0;\n+uint Runtime1::_throw_incompatible_class_change_error_count = 0;\n+uint Runtime1::_throw_illegal_monitor_state_exception_count = 0;\n+uint Runtime1::_throw_count = 0;\n+\n+static uint _byte_arraycopy_stub_cnt = 0;\n+static uint _short_arraycopy_stub_cnt = 0;\n+static uint _int_arraycopy_stub_cnt = 0;\n+static uint _long_arraycopy_stub_cnt = 0;\n+static uint _oop_arraycopy_stub_cnt = 0;\n@@ -1662,38 +1662,38 @@\n-  tty->print_cr(\" _resolve_invoke_virtual_cnt:     %d\", SharedRuntime::_resolve_virtual_ctr);\n-  tty->print_cr(\" _resolve_invoke_opt_virtual_cnt: %d\", SharedRuntime::_resolve_opt_virtual_ctr);\n-  tty->print_cr(\" _resolve_invoke_static_cnt:      %d\", SharedRuntime::_resolve_static_ctr);\n-  tty->print_cr(\" _handle_wrong_method_cnt:        %d\", SharedRuntime::_wrong_method_ctr);\n-  tty->print_cr(\" _ic_miss_cnt:                    %d\", SharedRuntime::_ic_miss_ctr);\n-  tty->print_cr(\" _generic_arraycopystub_cnt:      %d\", _generic_arraycopystub_cnt);\n-  tty->print_cr(\" _byte_arraycopy_cnt:             %d\", _byte_arraycopy_stub_cnt);\n-  tty->print_cr(\" _short_arraycopy_cnt:            %d\", _short_arraycopy_stub_cnt);\n-  tty->print_cr(\" _int_arraycopy_cnt:              %d\", _int_arraycopy_stub_cnt);\n-  tty->print_cr(\" _long_arraycopy_cnt:             %d\", _long_arraycopy_stub_cnt);\n-  tty->print_cr(\" _oop_arraycopy_cnt:              %d\", _oop_arraycopy_stub_cnt);\n-  tty->print_cr(\" _arraycopy_slowcase_cnt:         %d\", _arraycopy_slowcase_cnt);\n-  tty->print_cr(\" _arraycopy_checkcast_cnt:        %d\", _arraycopy_checkcast_cnt);\n-  tty->print_cr(\" _arraycopy_checkcast_attempt_cnt:%d\", _arraycopy_checkcast_attempt_cnt);\n-\n-  tty->print_cr(\" _new_type_array_slowcase_cnt:    %d\", _new_type_array_slowcase_cnt);\n-  tty->print_cr(\" _new_object_array_slowcase_cnt:  %d\", _new_object_array_slowcase_cnt);\n-  tty->print_cr(\" _new_flat_array_slowcase_cnt:    %d\", _new_flat_array_slowcase_cnt);\n-  tty->print_cr(\" _new_instance_slowcase_cnt:      %d\", _new_instance_slowcase_cnt);\n-  tty->print_cr(\" _new_multi_array_slowcase_cnt:   %d\", _new_multi_array_slowcase_cnt);\n-  tty->print_cr(\" _load_flattened_array_slowcase_cnt:   %d\", _load_flattened_array_slowcase_cnt);\n-  tty->print_cr(\" _store_flattened_array_slowcase_cnt:  %d\", _store_flattened_array_slowcase_cnt);\n-  tty->print_cr(\" _substitutability_check_slowcase_cnt: %d\", _substitutability_check_slowcase_cnt);\n-  tty->print_cr(\" _buffer_inline_args_slowcase_cnt:%d\", _buffer_inline_args_slowcase_cnt);\n-  tty->print_cr(\" _buffer_inline_args_no_receiver_slowcase_cnt:%d\", _buffer_inline_args_no_receiver_slowcase_cnt);\n-\n-  tty->print_cr(\" _monitorenter_slowcase_cnt:      %d\", _monitorenter_slowcase_cnt);\n-  tty->print_cr(\" _monitorexit_slowcase_cnt:       %d\", _monitorexit_slowcase_cnt);\n-  tty->print_cr(\" _patch_code_slowcase_cnt:        %d\", _patch_code_slowcase_cnt);\n-\n-  tty->print_cr(\" _throw_range_check_exception_count:            %d:\", _throw_range_check_exception_count);\n-  tty->print_cr(\" _throw_index_exception_count:                  %d:\", _throw_index_exception_count);\n-  tty->print_cr(\" _throw_div0_exception_count:                   %d:\", _throw_div0_exception_count);\n-  tty->print_cr(\" _throw_null_pointer_exception_count:           %d:\", _throw_null_pointer_exception_count);\n-  tty->print_cr(\" _throw_class_cast_exception_count:             %d:\", _throw_class_cast_exception_count);\n-  tty->print_cr(\" _throw_incompatible_class_change_error_count:  %d:\", _throw_incompatible_class_change_error_count);\n-  tty->print_cr(\" _throw_illegal_monitor_state_exception_count:  %d:\", _throw_illegal_monitor_state_exception_count);\n-  tty->print_cr(\" _throw_count:                                  %d:\", _throw_count);\n+  tty->print_cr(\" _resolve_invoke_virtual_cnt:     %u\", SharedRuntime::_resolve_virtual_ctr);\n+  tty->print_cr(\" _resolve_invoke_opt_virtual_cnt: %u\", SharedRuntime::_resolve_opt_virtual_ctr);\n+  tty->print_cr(\" _resolve_invoke_static_cnt:      %u\", SharedRuntime::_resolve_static_ctr);\n+  tty->print_cr(\" _handle_wrong_method_cnt:        %u\", SharedRuntime::_wrong_method_ctr);\n+  tty->print_cr(\" _ic_miss_cnt:                    %u\", SharedRuntime::_ic_miss_ctr);\n+  tty->print_cr(\" _generic_arraycopystub_cnt:      %u\", _generic_arraycopystub_cnt);\n+  tty->print_cr(\" _byte_arraycopy_cnt:             %u\", _byte_arraycopy_stub_cnt);\n+  tty->print_cr(\" _short_arraycopy_cnt:            %u\", _short_arraycopy_stub_cnt);\n+  tty->print_cr(\" _int_arraycopy_cnt:              %u\", _int_arraycopy_stub_cnt);\n+  tty->print_cr(\" _long_arraycopy_cnt:             %u\", _long_arraycopy_stub_cnt);\n+  tty->print_cr(\" _oop_arraycopy_cnt:              %u\", _oop_arraycopy_stub_cnt);\n+  tty->print_cr(\" _arraycopy_slowcase_cnt:         %u\", _arraycopy_slowcase_cnt);\n+  tty->print_cr(\" _arraycopy_checkcast_cnt:        %u\", _arraycopy_checkcast_cnt);\n+  tty->print_cr(\" _arraycopy_checkcast_attempt_cnt:%u\", _arraycopy_checkcast_attempt_cnt);\n+\n+  tty->print_cr(\" _new_type_array_slowcase_cnt:    %u\", _new_type_array_slowcase_cnt);\n+  tty->print_cr(\" _new_object_array_slowcase_cnt:  %u\", _new_object_array_slowcase_cnt);\n+  tty->print_cr(\" _new_flat_array_slowcase_cnt:    %u\", _new_flat_array_slowcase_cnt);\n+  tty->print_cr(\" _new_instance_slowcase_cnt:      %u\", _new_instance_slowcase_cnt);\n+  tty->print_cr(\" _new_multi_array_slowcase_cnt:   %u\", _new_multi_array_slowcase_cnt);\n+  tty->print_cr(\" _load_flattened_array_slowcase_cnt:   %u\", _load_flattened_array_slowcase_cnt);\n+  tty->print_cr(\" _store_flattened_array_slowcase_cnt:  %u\", _store_flattened_array_slowcase_cnt);\n+  tty->print_cr(\" _substitutability_check_slowcase_cnt: %u\", _substitutability_check_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_slowcase_cnt:%u\", _buffer_inline_args_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_no_receiver_slowcase_cnt:%u\", _buffer_inline_args_no_receiver_slowcase_cnt);\n+\n+  tty->print_cr(\" _monitorenter_slowcase_cnt:      %u\", _monitorenter_slowcase_cnt);\n+  tty->print_cr(\" _monitorexit_slowcase_cnt:       %u\", _monitorexit_slowcase_cnt);\n+  tty->print_cr(\" _patch_code_slowcase_cnt:        %u\", _patch_code_slowcase_cnt);\n+\n+  tty->print_cr(\" _throw_range_check_exception_count:            %u:\", _throw_range_check_exception_count);\n+  tty->print_cr(\" _throw_index_exception_count:                  %u:\", _throw_index_exception_count);\n+  tty->print_cr(\" _throw_div0_exception_count:                   %u:\", _throw_div0_exception_count);\n+  tty->print_cr(\" _throw_null_pointer_exception_count:           %u:\", _throw_null_pointer_exception_count);\n+  tty->print_cr(\" _throw_class_cast_exception_count:             %u:\", _throw_class_cast_exception_count);\n+  tty->print_cr(\" _throw_incompatible_class_change_error_count:  %u:\", _throw_incompatible_class_change_error_count);\n+  tty->print_cr(\" _throw_illegal_monitor_state_exception_count:  %u:\", _throw_illegal_monitor_state_exception_count);\n+  tty->print_cr(\" _throw_count:                                  %u:\", _throw_count);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -105,25 +105,25 @@\n-  static int _generic_arraycopystub_cnt;\n-  static int _arraycopy_slowcase_cnt;\n-  static int _arraycopy_checkcast_cnt;\n-  static int _arraycopy_checkcast_attempt_cnt;\n-  static int _new_type_array_slowcase_cnt;\n-  static int _new_object_array_slowcase_cnt;\n-  static int _new_flat_array_slowcase_cnt;\n-  static int _new_instance_slowcase_cnt;\n-  static int _new_multi_array_slowcase_cnt;\n-  static int _load_flattened_array_slowcase_cnt;\n-  static int _store_flattened_array_slowcase_cnt;\n-  static int _substitutability_check_slowcase_cnt;\n-  static int _buffer_inline_args_slowcase_cnt;\n-  static int _buffer_inline_args_no_receiver_slowcase_cnt;\n-  static int _monitorenter_slowcase_cnt;\n-  static int _monitorexit_slowcase_cnt;\n-  static int _patch_code_slowcase_cnt;\n-  static int _throw_range_check_exception_count;\n-  static int _throw_index_exception_count;\n-  static int _throw_div0_exception_count;\n-  static int _throw_null_pointer_exception_count;\n-  static int _throw_class_cast_exception_count;\n-  static int _throw_incompatible_class_change_error_count;\n-  static int _throw_illegal_monitor_state_exception_count;\n-  static int _throw_count;\n+  static uint _generic_arraycopystub_cnt;\n+  static uint _arraycopy_slowcase_cnt;\n+  static uint _arraycopy_checkcast_cnt;\n+  static uint _arraycopy_checkcast_attempt_cnt;\n+  static uint _new_type_array_slowcase_cnt;\n+  static uint _new_object_array_slowcase_cnt;\n+  static uint _new_flat_array_slowcase_cnt;\n+  static uint _new_instance_slowcase_cnt;\n+  static uint _new_multi_array_slowcase_cnt;\n+  static uint _load_flattened_array_slowcase_cnt;\n+  static uint _store_flattened_array_slowcase_cnt;\n+  static uint _substitutability_check_slowcase_cnt;\n+  static uint _buffer_inline_args_slowcase_cnt;\n+  static uint _buffer_inline_args_no_receiver_slowcase_cnt;\n+  static uint _monitorenter_slowcase_cnt;\n+  static uint _monitorexit_slowcase_cnt;\n+  static uint _patch_code_slowcase_cnt;\n+  static uint _throw_range_check_exception_count;\n+  static uint _throw_index_exception_count;\n+  static uint _throw_div0_exception_count;\n+  static uint _throw_null_pointer_exception_count;\n+  static uint _throw_class_cast_exception_count;\n+  static uint _throw_incompatible_class_change_error_count;\n+  static uint _throw_illegal_monitor_state_exception_count;\n+  static uint _throw_count;\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -67,0 +67,7 @@\n+\n+typedef ResourceHashtable<address, size_t,\n+      127, \/\/ prime number\n+      AnyObj::C_HEAP,\n+      mtClassShared> FillersTable;\n+static FillersTable* _fillers;\n+\n@@ -72,1 +79,1 @@\n-\n+    _fillers = new FillersTable();\n@@ -258,1 +265,1 @@\n-void ArchiveHeapWriter::init_filler_array_at_buffer_top(int array_length, size_t fill_bytes) {\n+HeapWord* ArchiveHeapWriter::init_filler_array_at_buffer_top(int array_length, size_t fill_bytes) {\n@@ -267,0 +274,1 @@\n+  return mem;\n@@ -296,2 +304,1 @@\n-    init_filler_array_at_buffer_top(array_length, fill_bytes);\n-\n+    HeapWord* filler = init_filler_array_at_buffer_top(array_length, fill_bytes);\n@@ -299,0 +306,11 @@\n+    _fillers->put((address)filler, fill_bytes);\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::get_filler_size_at(address buffered_addr) {\n+  size_t* p = _fillers->get(buffered_addr);\n+  if (p != nullptr) {\n+    assert(*p > 0, \"filler must be larger than zero bytes\");\n+    return *p;\n+  } else {\n+    return 0; \/\/ buffered_addr is not a filler\n@@ -517,0 +535,14 @@\n+\/\/ Do we have a jlong\/jint field that's actually a pointer to a MetaspaceObj?\n+bool ArchiveHeapWriter::is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset) {\n+  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n+  assert(p != nullptr, \"must be\");\n+\n+  \/\/ requested_field_addr = the address of this field in the requested space\n+  oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n+  Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n+  assert((Metadata**)_requested_bottom <= requested_field_addr && requested_field_addr < (Metadata**) _requested_top, \"range check\");\n+\n+  BitMap::idx_t idx = requested_field_addr - (Metadata**) _requested_bottom;\n+  return (idx < heap_info->ptrmap()->size()) && (heap_info->ptrmap()->at(idx) == true);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2843,1 +2843,5 @@\n-  Symbol* message = java_lang_Throwable::detail_message(throwable());\n+  const char *message = nullptr;\n+  oop detailed_message = java_lang_Throwable::message(throwable());\n+  if (detailed_message != nullptr) {\n+    message = java_lang_String::as_utf8_string(detailed_message);\n+  }\n@@ -2851,1 +2855,1 @@\n-    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), current->name());\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message, current->name());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1123,1 +1123,1 @@\n-                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,11 +122,11 @@\n-  int nmethod_count;\n-  int total_size;\n-  int relocation_size;\n-  int consts_size;\n-  int insts_size;\n-  int stub_size;\n-  int scopes_data_size;\n-  int scopes_pcs_size;\n-  int dependencies_size;\n-  int handler_table_size;\n-  int nul_chk_table_size;\n+  uint nmethod_count;\n+  uint total_size;\n+  uint relocation_size;\n+  uint consts_size;\n+  uint insts_size;\n+  uint stub_size;\n+  uint scopes_data_size;\n+  uint scopes_pcs_size;\n+  uint dependencies_size;\n+  uint handler_table_size;\n+  uint nul_chk_table_size;\n@@ -134,2 +134,2 @@\n-  int speculations_size;\n-  int jvmci_data_size;\n+  uint speculations_size;\n+  uint jvmci_data_size;\n@@ -137,2 +137,2 @@\n-  int oops_size;\n-  int metadata_size;\n+  uint oops_size;\n+  uint metadata_size;\n@@ -161,2 +161,2 @@\n-    tty->print_cr(\"Statistics for %d bytecoded nmethods for %s:\", nmethod_count, name);\n-    if (total_size != 0)          tty->print_cr(\" total in heap  = %d\", total_size);\n+    tty->print_cr(\"Statistics for %u bytecoded nmethods for %s:\", nmethod_count, name);\n+    if (total_size != 0)          tty->print_cr(\" total in heap  = %u\", total_size);\n@@ -164,11 +164,11 @@\n-    if (relocation_size != 0)     tty->print_cr(\" relocation     = %d\", relocation_size);\n-    if (consts_size != 0)         tty->print_cr(\" constants      = %d\", consts_size);\n-    if (insts_size != 0)          tty->print_cr(\" main code      = %d\", insts_size);\n-    if (stub_size != 0)           tty->print_cr(\" stub code      = %d\", stub_size);\n-    if (oops_size != 0)           tty->print_cr(\" oops           = %d\", oops_size);\n-    if (metadata_size != 0)       tty->print_cr(\" metadata       = %d\", metadata_size);\n-    if (scopes_data_size != 0)    tty->print_cr(\" scopes data    = %d\", scopes_data_size);\n-    if (scopes_pcs_size != 0)     tty->print_cr(\" scopes pcs     = %d\", scopes_pcs_size);\n-    if (dependencies_size != 0)   tty->print_cr(\" dependencies   = %d\", dependencies_size);\n-    if (handler_table_size != 0)  tty->print_cr(\" handler table  = %d\", handler_table_size);\n-    if (nul_chk_table_size != 0)  tty->print_cr(\" nul chk table  = %d\", nul_chk_table_size);\n+    if (relocation_size != 0)     tty->print_cr(\" relocation     = %u\", relocation_size);\n+    if (consts_size != 0)         tty->print_cr(\" constants      = %u\", consts_size);\n+    if (insts_size != 0)          tty->print_cr(\" main code      = %u\", insts_size);\n+    if (stub_size != 0)           tty->print_cr(\" stub code      = %u\", stub_size);\n+    if (oops_size != 0)           tty->print_cr(\" oops           = %u\", oops_size);\n+    if (metadata_size != 0)       tty->print_cr(\" metadata       = %u\", metadata_size);\n+    if (scopes_data_size != 0)    tty->print_cr(\" scopes data    = %u\", scopes_data_size);\n+    if (scopes_pcs_size != 0)     tty->print_cr(\" scopes pcs     = %u\", scopes_pcs_size);\n+    if (dependencies_size != 0)   tty->print_cr(\" dependencies   = %u\", dependencies_size);\n+    if (handler_table_size != 0)  tty->print_cr(\" handler table  = %u\", handler_table_size);\n+    if (nul_chk_table_size != 0)  tty->print_cr(\" nul chk table  = %u\", nul_chk_table_size);\n@@ -176,2 +176,2 @@\n-    if (speculations_size != 0)   tty->print_cr(\" speculations   = %d\", speculations_size);\n-    if (jvmci_data_size != 0)     tty->print_cr(\" JVMCI data     = %d\", jvmci_data_size);\n+    if (speculations_size != 0)   tty->print_cr(\" speculations   = %u\", speculations_size);\n+    if (jvmci_data_size != 0)     tty->print_cr(\" JVMCI data     = %u\", jvmci_data_size);\n@@ -183,6 +183,6 @@\n-  int native_nmethod_count;\n-  int native_total_size;\n-  int native_relocation_size;\n-  int native_insts_size;\n-  int native_oops_size;\n-  int native_metadata_size;\n+  uint native_nmethod_count;\n+  uint native_total_size;\n+  uint native_relocation_size;\n+  uint native_insts_size;\n+  uint native_oops_size;\n+  uint native_metadata_size;\n@@ -199,6 +199,6 @@\n-    tty->print_cr(\"Statistics for %d native nmethods:\", native_nmethod_count);\n-    if (native_total_size != 0)       tty->print_cr(\" N. total size  = %d\", native_total_size);\n-    if (native_relocation_size != 0)  tty->print_cr(\" N. relocation  = %d\", native_relocation_size);\n-    if (native_insts_size != 0)       tty->print_cr(\" N. main code   = %d\", native_insts_size);\n-    if (native_oops_size != 0)        tty->print_cr(\" N. oops        = %d\", native_oops_size);\n-    if (native_metadata_size != 0)    tty->print_cr(\" N. metadata    = %d\", native_metadata_size);\n+    tty->print_cr(\"Statistics for %u native nmethods:\", native_nmethod_count);\n+    if (native_total_size != 0)       tty->print_cr(\" N. total size  = %u\", native_total_size);\n+    if (native_relocation_size != 0)  tty->print_cr(\" N. relocation  = %u\", native_relocation_size);\n+    if (native_insts_size != 0)       tty->print_cr(\" N. main code   = %u\", native_insts_size);\n+    if (native_oops_size != 0)        tty->print_cr(\" N. oops        = %u\", native_oops_size);\n+    if (native_metadata_size != 0)    tty->print_cr(\" N. metadata    = %u\", native_metadata_size);\n@@ -209,8 +209,8 @@\n-  int pc_desc_resets;   \/\/ number of resets (= number of caches)\n-  int pc_desc_queries;  \/\/ queries to nmethod::find_pc_desc\n-  int pc_desc_approx;   \/\/ number of those which have approximate true\n-  int pc_desc_repeats;  \/\/ number of _pc_descs[0] hits\n-  int pc_desc_hits;     \/\/ number of LRU cache hits\n-  int pc_desc_tests;    \/\/ total number of PcDesc examinations\n-  int pc_desc_searches; \/\/ total number of quasi-binary search steps\n-  int pc_desc_adds;     \/\/ number of LUR cache insertions\n+  uint pc_desc_resets;   \/\/ number of resets (= number of caches)\n+  uint pc_desc_queries;  \/\/ queries to nmethod::find_pc_desc\n+  uint pc_desc_approx;   \/\/ number of those which have approximate true\n+  uint pc_desc_repeats;  \/\/ number of _pc_descs[0] hits\n+  uint pc_desc_hits;     \/\/ number of LRU cache hits\n+  uint pc_desc_tests;    \/\/ total number of PcDesc examinations\n+  uint pc_desc_searches; \/\/ total number of quasi-binary search steps\n+  uint pc_desc_adds;     \/\/ number of LUR cache insertions\n@@ -219,1 +219,1 @@\n-    tty->print_cr(\"PcDesc Statistics:  %d queries, %.2f comparisons per query\",\n+    tty->print_cr(\"PcDesc Statistics:  %u queries, %.2f comparisons per query\",\n@@ -223,1 +223,1 @@\n-    tty->print_cr(\"  caches=%d queries=%d\/%d, hits=%d+%d, tests=%d+%d, adds=%d\",\n+    tty->print_cr(\"  caches=%d queries=%u\/%u, hits=%u+%u, tests=%u+%u, adds=%u\",\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -177,12 +177,12 @@\n-int CompileBroker::_total_bailout_count            = 0;\n-int CompileBroker::_total_invalidated_count        = 0;\n-int CompileBroker::_total_compile_count            = 0;\n-int CompileBroker::_total_osr_compile_count        = 0;\n-int CompileBroker::_total_standard_compile_count   = 0;\n-int CompileBroker::_total_compiler_stopped_count   = 0;\n-int CompileBroker::_total_compiler_restarted_count = 0;\n-\n-int CompileBroker::_sum_osr_bytes_compiled         = 0;\n-int CompileBroker::_sum_standard_bytes_compiled    = 0;\n-int CompileBroker::_sum_nmethod_size               = 0;\n-int CompileBroker::_sum_nmethod_code_size          = 0;\n+uint CompileBroker::_total_bailout_count            = 0;\n+uint CompileBroker::_total_invalidated_count        = 0;\n+uint CompileBroker::_total_compile_count            = 0;\n+uint CompileBroker::_total_osr_compile_count        = 0;\n+uint CompileBroker::_total_standard_compile_count   = 0;\n+uint CompileBroker::_total_compiler_stopped_count   = 0;\n+uint CompileBroker::_total_compiler_restarted_count = 0;\n+\n+uint CompileBroker::_sum_osr_bytes_compiled         = 0;\n+uint CompileBroker::_sum_standard_bytes_compiled    = 0;\n+uint CompileBroker::_sum_nmethod_size               = 0;\n+uint CompileBroker::_sum_nmethod_code_size          = 0;\n@@ -2117,0 +2117,9 @@\n+\/\/ Acquires Compilation_lock and waits for it to be notified\n+\/\/ as long as WhiteBox::compilation_locked is true.\n+static void whitebox_lock_compilation() {\n+  MonitorLocker locker(Compilation_lock, Mutex::_no_safepoint_check_flag);\n+  while (WhiteBox::compilation_locked) {\n+    locker.wait();\n+  }\n+}\n+\n@@ -2199,0 +2208,5 @@\n+        if (WhiteBoxAPI && WhiteBox::compilation_locked) {\n+          \/\/ Must switch to native to block\n+          ThreadToNativeFromVM ttn(thread);\n+          whitebox_lock_compilation();\n+        }\n@@ -2260,4 +2274,1 @@\n-        MonitorLocker locker(Compilation_lock, Mutex::_no_safepoint_check_flag);\n-        while (WhiteBox::compilation_locked) {\n-          locker.wait();\n-        }\n+        whitebox_lock_compilation();\n@@ -2602,1 +2613,1 @@\n-  tty->print_cr(\"  %s {speed: %6.3f bytes\/s; standard: %6.3f s, %d bytes, %d methods; osr: %6.3f s, %d bytes, %d methods; nmethods_size: %d bytes; nmethods_code_size: %d bytes}\",\n+  tty->print_cr(\"  %s {speed: %6.3f bytes\/s; standard: %6.3f s, %u bytes, %u methods; osr: %6.3f s, %u bytes, %u methods; nmethods_size: %u bytes; nmethods_code_size: %u bytes}\",\n@@ -2645,2 +2656,2 @@\n-  int standard_bytes_compiled = CompileBroker::_sum_standard_bytes_compiled;\n-  int osr_bytes_compiled = CompileBroker::_sum_osr_bytes_compiled;\n+  uint standard_bytes_compiled = CompileBroker::_sum_standard_bytes_compiled;\n+  uint osr_bytes_compiled = CompileBroker::_sum_osr_bytes_compiled;\n@@ -2648,5 +2659,5 @@\n-  int standard_compile_count = CompileBroker::_total_standard_compile_count;\n-  int osr_compile_count = CompileBroker::_total_osr_compile_count;\n-  int total_compile_count = CompileBroker::_total_compile_count;\n-  int total_bailout_count = CompileBroker::_total_bailout_count;\n-  int total_invalidated_count = CompileBroker::_total_invalidated_count;\n+  uint standard_compile_count = CompileBroker::_total_standard_compile_count;\n+  uint osr_compile_count = CompileBroker::_total_osr_compile_count;\n+  uint total_compile_count = CompileBroker::_total_compile_count;\n+  uint total_bailout_count = CompileBroker::_total_bailout_count;\n+  uint total_invalidated_count = CompileBroker::_total_invalidated_count;\n@@ -2654,2 +2665,2 @@\n-  int nmethods_size = CompileBroker::_sum_nmethod_code_size;\n-  int nmethods_code_size = CompileBroker::_sum_nmethod_size;\n+  uint nmethods_size = CompileBroker::_sum_nmethod_code_size;\n+  uint nmethods_code_size = CompileBroker::_sum_nmethod_size;\n@@ -2697,7 +2708,7 @@\n-  tty->print_cr(\"  Total compiled methods    : %8d methods\", total_compile_count);\n-  tty->print_cr(\"    Standard compilation    : %8d methods\", standard_compile_count);\n-  tty->print_cr(\"    On stack replacement    : %8d methods\", osr_compile_count);\n-  int tcb = osr_bytes_compiled + standard_bytes_compiled;\n-  tty->print_cr(\"  Total compiled bytecodes  : %8d bytes\", tcb);\n-  tty->print_cr(\"    Standard compilation    : %8d bytes\", standard_bytes_compiled);\n-  tty->print_cr(\"    On stack replacement    : %8d bytes\", osr_bytes_compiled);\n+  tty->print_cr(\"  Total compiled methods    : %8u methods\", total_compile_count);\n+  tty->print_cr(\"    Standard compilation    : %8u methods\", standard_compile_count);\n+  tty->print_cr(\"    On stack replacement    : %8u methods\", osr_compile_count);\n+  uint tcb = osr_bytes_compiled + standard_bytes_compiled;\n+  tty->print_cr(\"  Total compiled bytecodes  : %8u bytes\", tcb);\n+  tty->print_cr(\"    Standard compilation    : %8u bytes\", standard_bytes_compiled);\n+  tty->print_cr(\"    On stack replacement    : %8u bytes\", osr_bytes_compiled);\n@@ -2705,2 +2716,2 @@\n-  int bps = tcs == 0.0 ? 0 : (int)(tcb \/ tcs);\n-  tty->print_cr(\"  Average compilation speed : %8d bytes\/s\", bps);\n+  uint bps = tcs == 0.0 ? 0 : (uint)(tcb \/ tcs);\n+  tty->print_cr(\"  Average compilation speed : %8u bytes\/s\", bps);\n@@ -2708,2 +2719,2 @@\n-  tty->print_cr(\"  nmethod code size         : %8d bytes\", nmethods_code_size);\n-  tty->print_cr(\"  nmethod total size        : %8d bytes\", nmethods_size);\n+  tty->print_cr(\"  nmethod code size         : %8u bytes\", nmethods_code_size);\n+  tty->print_cr(\"  nmethod total size        : %8u bytes\", nmethods_size);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":48,"deletions":37,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+  LOG_TAG(trimnative) \/* trim native heap *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -278,2 +278,0 @@\n-#ifndef PRODUCT\n-\n@@ -343,1 +341,4 @@\n-  typeArrayOop ta = typeArrayOop(obj);\n+  oop_print_elements_on(typeArrayOop(obj), st);\n+}\n+\n+void TypeArrayKlass::oop_print_elements_on(typeArrayOop ta, outputStream* st) {\n@@ -362,2 +363,0 @@\n-#endif \/\/ PRODUCT\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-          range(-1, 0)                                                      \\\n+          range(-1, max_intx)                                               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -691,7 +691,0 @@\n-  if (CITimeVerbose) {\n-    tty->print(\" \");\n-    target->holder()->name()->print();\n-    tty->print(\".\");\n-    target->print_short_name();\n-    tty->print(\"  \");\n-  }\n@@ -4868,1 +4861,1 @@\n-    _phase_name(name), _dolog(CITimeVerbose)\n+    _compile(nullptr), _log(nullptr), _phase_name(name), _dolog(CITimeVerbose)\n@@ -4871,5 +4864,2 @@\n-    C = Compile::current();\n-    _log = C->log();\n-  } else {\n-    C = nullptr;\n-    _log = nullptr;\n+    _compile = Compile::current();\n+    _log = _compile->log();\n@@ -4878,1 +4868,1 @@\n-    _log->begin_head(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, C->unique(), C->live_nodes());\n+    _log->begin_head(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, _compile->unique(), _compile->live_nodes());\n@@ -4885,8 +4875,0 @@\n-\n-  C = Compile::current();\n-  if (_dolog) {\n-    _log = C->log();\n-  } else {\n-    _log = nullptr;\n-  }\n-\n@@ -4896,1 +4878,1 @@\n-                  _phase_name, C->unique(), C->live_nodes(), C->count_live_nodes_by_graph_walk());\n+                  _phase_name, _compile->unique(), _compile->live_nodes(), _compile->count_live_nodes_by_graph_walk());\n@@ -4905,1 +4887,1 @@\n-    _log->done(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, C->unique(), C->live_nodes());\n+    _log->done(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, _compile->unique(), _compile->live_nodes());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-    Compile*    C;\n+    Compile*    _compile;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1265,2 +1265,2 @@\n-extern int explicit_null_checks_inserted,\n-           explicit_null_checks_elided;\n+extern uint explicit_null_checks_inserted,\n+            explicit_null_checks_elided;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-extern int explicit_null_checks_elided;\n+extern uint explicit_null_checks_elided;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-  extern int implicit_null_checks;\n+  extern uint implicit_null_checks;\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2591,1 +2591,1 @@\n-        extern int all_null_checks_found;\n+        extern uint all_null_checks_found;\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -911,1 +911,1 @@\n-      return new AndINode(add1->in(1), phase->intcon(-(1 << con)));\n+      return new AndINode(add1->in(1), phase->intcon(java_negate(jint(1 << con))));\n@@ -921,1 +921,1 @@\n-            return new AndINode(lshift, phase->intcon(java_negate((jint)(1 << con))));\n+            return new AndINode(lshift, phase->intcon(java_negate(jint(1 << con))));\n@@ -934,1 +934,1 @@\n-            return new AndINode(rshift, phase->intcon(-(1 << con)));\n+            return new AndINode(rshift, phase->intcon(java_negate(jint(1 << con))));\n@@ -1087,1 +1087,1 @@\n-      return new AndLNode(add1->in(1), phase->longcon(-(CONST64(1) << con)));\n+      return new AndLNode(add1->in(1), phase->longcon(java_negate(jlong(CONST64(1) << con))));\n@@ -1097,1 +1097,1 @@\n-            return new AndLNode(lshift, phase->longcon(-(CONST64(1) << con)));\n+            return new AndLNode(lshift, phase->longcon(java_negate(jlong(CONST64(1) << con))));\n@@ -1110,1 +1110,1 @@\n-            return new AndLNode(rshift, phase->longcon(-(CONST64(1) << con)));\n+            return new AndLNode(rshift, phase->longcon(java_negate(jlong(CONST64(1) << con))));\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-extern int nodes_created;\n+extern uint nodes_created;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,5 +54,5 @@\n-int nodes_created              = 0;\n-int methods_parsed             = 0;\n-int methods_seen               = 0;\n-int blocks_parsed              = 0;\n-int blocks_seen                = 0;\n+uint nodes_created             = 0;\n+uint methods_parsed            = 0;\n+uint methods_seen              = 0;\n+uint blocks_parsed             = 0;\n+uint blocks_seen               = 0;\n@@ -60,4 +60,4 @@\n-int explicit_null_checks_inserted = 0;\n-int explicit_null_checks_elided   = 0;\n-int all_null_checks_found         = 0;\n-int implicit_null_checks          = 0;\n+uint explicit_null_checks_inserted = 0;\n+uint explicit_null_checks_elided   = 0;\n+uint all_null_checks_found         = 0;\n+uint implicit_null_checks          = 0;\n@@ -74,2 +74,2 @@\n-  tty->print(\"Methods seen: %d  Methods parsed: %d\", methods_seen, methods_parsed);\n-  tty->print(\"  Nodes created: %d\", nodes_created);\n+  tty->print(\"Methods seen: %u  Methods parsed: %u\", methods_seen, methods_parsed);\n+  tty->print(\"  Nodes created: %u\", nodes_created);\n@@ -80,1 +80,1 @@\n-  tty->print_cr(\"Blocks parsed: %d  Blocks seen: %d\", blocks_parsed, blocks_seen);\n+  tty->print_cr(\"Blocks parsed: %u  Blocks seen: %u\", blocks_parsed, blocks_seen);\n@@ -83,1 +83,1 @@\n-    tty->print_cr(\"%d original null checks - %d elided (%2d%%); optimizer leaves %d,\",\n+    tty->print_cr(\"%u original null checks - %u elided (%2u%%); optimizer leaves %u,\",\n@@ -89,1 +89,1 @@\n-    tty->print_cr(\"%d made implicit (%2d%%)\", implicit_null_checks,\n+    tty->print_cr(\"%u made implicit (%2u%%)\", implicit_null_checks,\n@@ -93,1 +93,1 @@\n-    tty->print_cr(\"%d implicit null exceptions at runtime\",\n+    tty->print_cr(\"%u implicit null exceptions at runtime\",\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-extern int explicit_null_checks_inserted,\n-           explicit_null_checks_elided;\n+extern uint explicit_null_checks_inserted,\n+            explicit_null_checks_elided;\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -401,2 +401,2 @@\n-  int expand_count = 1;        \/\/ count of allocations in the expansion\n-  int expand_fanout = 1;       \/\/ running total fanout\n+  int64_t expand_count = 1;        \/\/ count of allocations in the expansion\n+  int64_t expand_fanout = 1;       \/\/ running total fanout\n@@ -405,0 +405,3 @@\n+    \/\/ To prevent overflow, we use 64-bit values.  Alternatively,\n+    \/\/ we could clamp dim_con like so:\n+    \/\/ dim_con = MIN2(dim_con, expand_limit);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1042,2 +1042,5 @@\n-  assert(Reflection::is_same_class_package(lookup_k, ik),\n-         \"lookup class and defined class are in different packages\");\n+\n+  if ((!is_hidden || is_nestmate) && !Reflection::is_same_class_package(lookup_k, ik)) {\n+    \/\/ non-hidden class or nestmate class must be in the same package as the Lookup class\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Lookup class and defined class are in different packages\");\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -381,11 +381,0 @@\n-  if (Continuations::enabled()) {\n-    \/\/ Virtual threads support. There is a performance impact when VTMS transitions are enabled.\n-    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {\n-      if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-        ThreadInVMfromNative __tiv(JavaThread::current());\n-        JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n-      }\n-    } else {\n-      JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n-    }\n-  }\n@@ -402,0 +391,8 @@\n+\n+    if (Continuations::enabled()) {\n+      \/\/ Virtual threads support for agents loaded into running VM.\n+      \/\/ There is a performance impact when VTMS transitions are enabled.\n+      if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+        JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n+      }\n+    }\n@@ -408,0 +405,6 @@\n+\n+    if (Continuations::enabled()) {\n+      \/\/ Virtual threads support for agents loaded at startup.\n+      \/\/ There is a performance impact when VTMS transitions are enabled.\n+      JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2680,0 +2680,8 @@\n+WB_ENTRY(void, WB_PreTouchMemory(JNIEnv* env, jobject wb, jlong addr, jlong size))\n+  void* const from = (void*)addr;\n+  void* const to = (void*)(addr + size);\n+  if (from > to) {\n+    os::pretouch_memory(from, to, os::vm_page_size());\n+  }\n+WB_END\n+\n@@ -2968,0 +2976,1 @@\n+  {CC\"preTouchMemory\",  CC\"(JJ)V\",                    (void*)&WB_PreTouchMemory},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-bool   Arguments::_xdebug_mode                  = false;\n@@ -2727,2 +2726,1 @@\n-      \/\/ note this flag has been used, then ignore\n-      set_xdebug_mode(true);\n+      warning(\"Option -Xdebug was deprecated in JDK 22 and will likely be removed in a future release.\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -254,5 +254,0 @@\n-  \/\/ -Xdebug flag\n-  static bool _xdebug_mode;\n-  static void set_xdebug_mode(bool arg) { _xdebug_mode = arg; }\n-  static bool xdebug_mode()             { return _xdebug_mode; }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1313,3 +1313,4 @@\n-  product(intx, SafepointTimeoutDelay, 10000,                               \\\n-          \"Delay in milliseconds for option SafepointTimeout\")              \\\n-          range(0, max_intx LP64_ONLY(\/MICROUNITS))                         \\\n+  product(double, SafepointTimeoutDelay, 10000,                             \\\n+          \"Delay in milliseconds for option SafepointTimeout; \"             \\\n+          \"supports sub-millisecond resolution with fractional values.\")    \\\n+          range(0, max_jlongDouble LP64_ONLY(\/MICROUNITS))                  \\\n@@ -2028,0 +2029,7 @@\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 0, EXPERIMENTAL,                    \\\n+          \"Interval, in ms, at which the JVM will trim the native heap if \" \\\n+          \"the platform supports that. Lower values will reclaim memory \"   \\\n+          \"more eagerly at the cost of higher overhead. A value of 0 \"      \\\n+          \"(default) disables native heap trimming.\")                       \\\n+          range(0, UINT_MAX)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-    safepoint_limit_time = SafepointTracing::start_of_safepoint() + (jlong)SafepointTimeoutDelay * (NANOUNITS \/ MILLIUNITS);\n+    safepoint_limit_time = SafepointTracing::start_of_safepoint() + (jlong)(SafepointTimeoutDelay * NANOSECS_PER_MILLISEC);\n@@ -823,1 +823,1 @@\n-    fatal(\"Safepoint sync time longer than \" INTX_FORMAT \"ms detected when executing %s.\",\n+    fatal(\"Safepoint sync time longer than %.6f ms detected when executing %s.\",\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,7 +143,7 @@\n-int SharedRuntime::_ic_miss_ctr = 0;\n-int SharedRuntime::_wrong_method_ctr = 0;\n-int SharedRuntime::_resolve_static_ctr = 0;\n-int SharedRuntime::_resolve_virtual_ctr = 0;\n-int SharedRuntime::_resolve_opt_virtual_ctr = 0;\n-int SharedRuntime::_implicit_null_throws = 0;\n-int SharedRuntime::_implicit_div0_throws = 0;\n+uint SharedRuntime::_ic_miss_ctr = 0;\n+uint SharedRuntime::_wrong_method_ctr = 0;\n+uint SharedRuntime::_resolve_static_ctr = 0;\n+uint SharedRuntime::_resolve_virtual_ctr = 0;\n+uint SharedRuntime::_resolve_opt_virtual_ctr = 0;\n+uint SharedRuntime::_implicit_null_throws = 0;\n+uint SharedRuntime::_implicit_div0_throws = 0;\n@@ -159,22 +159,22 @@\n-int SharedRuntime::_new_instance_ctr=0;\n-int SharedRuntime::_new_array_ctr=0;\n-int SharedRuntime::_multi2_ctr=0;\n-int SharedRuntime::_multi3_ctr=0;\n-int SharedRuntime::_multi4_ctr=0;\n-int SharedRuntime::_multi5_ctr=0;\n-int SharedRuntime::_mon_enter_stub_ctr=0;\n-int SharedRuntime::_mon_exit_stub_ctr=0;\n-int SharedRuntime::_mon_enter_ctr=0;\n-int SharedRuntime::_mon_exit_ctr=0;\n-int SharedRuntime::_partial_subtype_ctr=0;\n-int SharedRuntime::_jbyte_array_copy_ctr=0;\n-int SharedRuntime::_jshort_array_copy_ctr=0;\n-int SharedRuntime::_jint_array_copy_ctr=0;\n-int SharedRuntime::_jlong_array_copy_ctr=0;\n-int SharedRuntime::_oop_array_copy_ctr=0;\n-int SharedRuntime::_checkcast_array_copy_ctr=0;\n-int SharedRuntime::_unsafe_array_copy_ctr=0;\n-int SharedRuntime::_generic_array_copy_ctr=0;\n-int SharedRuntime::_slow_array_copy_ctr=0;\n-int SharedRuntime::_find_handler_ctr=0;\n-int SharedRuntime::_rethrow_ctr=0;\n+uint SharedRuntime::_new_instance_ctr=0;\n+uint SharedRuntime::_new_array_ctr=0;\n+uint SharedRuntime::_multi2_ctr=0;\n+uint SharedRuntime::_multi3_ctr=0;\n+uint SharedRuntime::_multi4_ctr=0;\n+uint SharedRuntime::_multi5_ctr=0;\n+uint SharedRuntime::_mon_enter_stub_ctr=0;\n+uint SharedRuntime::_mon_exit_stub_ctr=0;\n+uint SharedRuntime::_mon_enter_ctr=0;\n+uint SharedRuntime::_mon_exit_ctr=0;\n+uint SharedRuntime::_partial_subtype_ctr=0;\n+uint SharedRuntime::_jbyte_array_copy_ctr=0;\n+uint SharedRuntime::_jshort_array_copy_ctr=0;\n+uint SharedRuntime::_jint_array_copy_ctr=0;\n+uint SharedRuntime::_jlong_array_copy_ctr=0;\n+uint SharedRuntime::_oop_array_copy_ctr=0;\n+uint SharedRuntime::_checkcast_array_copy_ctr=0;\n+uint SharedRuntime::_unsafe_array_copy_ctr=0;\n+uint SharedRuntime::_generic_array_copy_ctr=0;\n+uint SharedRuntime::_slow_array_copy_ctr=0;\n+uint SharedRuntime::_find_handler_ctr=0;\n+uint SharedRuntime::_rethrow_ctr=0;\n@@ -1472,3 +1472,3 @@\n-  int *addr = (is_optimized) ? (&_resolve_opt_virtual_ctr) :\n-                (is_virtual) ? (&_resolve_virtual_ctr) :\n-                               (&_resolve_static_ctr);\n+  uint *addr = (is_optimized) ? (&_resolve_opt_virtual_ctr) :\n+                 (is_virtual) ? (&_resolve_virtual_ctr) :\n+                                (&_resolve_static_ctr);\n@@ -2353,29 +2353,29 @@\n-  if (_new_instance_ctr) tty->print_cr(\"%5d new instance requires GC\", _new_instance_ctr);\n-  if (_new_array_ctr) tty->print_cr(\"%5d new array requires GC\", _new_array_ctr);\n-  if (_multi2_ctr) tty->print_cr(\"%5d multianewarray 2 dim\", _multi2_ctr);\n-  if (_multi3_ctr) tty->print_cr(\"%5d multianewarray 3 dim\", _multi3_ctr);\n-  if (_multi4_ctr) tty->print_cr(\"%5d multianewarray 4 dim\", _multi4_ctr);\n-  if (_multi5_ctr) tty->print_cr(\"%5d multianewarray 5 dim\", _multi5_ctr);\n-\n-  tty->print_cr(\"%5d inline cache miss in compiled\", _ic_miss_ctr);\n-  tty->print_cr(\"%5d wrong method\", _wrong_method_ctr);\n-  tty->print_cr(\"%5d unresolved static call site\", _resolve_static_ctr);\n-  tty->print_cr(\"%5d unresolved virtual call site\", _resolve_virtual_ctr);\n-  tty->print_cr(\"%5d unresolved opt virtual call site\", _resolve_opt_virtual_ctr);\n-\n-  if (_mon_enter_stub_ctr) tty->print_cr(\"%5d monitor enter stub\", _mon_enter_stub_ctr);\n-  if (_mon_exit_stub_ctr) tty->print_cr(\"%5d monitor exit stub\", _mon_exit_stub_ctr);\n-  if (_mon_enter_ctr) tty->print_cr(\"%5d monitor enter slow\", _mon_enter_ctr);\n-  if (_mon_exit_ctr) tty->print_cr(\"%5d monitor exit slow\", _mon_exit_ctr);\n-  if (_partial_subtype_ctr) tty->print_cr(\"%5d slow partial subtype\", _partial_subtype_ctr);\n-  if (_jbyte_array_copy_ctr) tty->print_cr(\"%5d byte array copies\", _jbyte_array_copy_ctr);\n-  if (_jshort_array_copy_ctr) tty->print_cr(\"%5d short array copies\", _jshort_array_copy_ctr);\n-  if (_jint_array_copy_ctr) tty->print_cr(\"%5d int array copies\", _jint_array_copy_ctr);\n-  if (_jlong_array_copy_ctr) tty->print_cr(\"%5d long array copies\", _jlong_array_copy_ctr);\n-  if (_oop_array_copy_ctr) tty->print_cr(\"%5d oop array copies\", _oop_array_copy_ctr);\n-  if (_checkcast_array_copy_ctr) tty->print_cr(\"%5d checkcast array copies\", _checkcast_array_copy_ctr);\n-  if (_unsafe_array_copy_ctr) tty->print_cr(\"%5d unsafe array copies\", _unsafe_array_copy_ctr);\n-  if (_generic_array_copy_ctr) tty->print_cr(\"%5d generic array copies\", _generic_array_copy_ctr);\n-  if (_slow_array_copy_ctr) tty->print_cr(\"%5d slow array copies\", _slow_array_copy_ctr);\n-  if (_find_handler_ctr) tty->print_cr(\"%5d find exception handler\", _find_handler_ctr);\n-  if (_rethrow_ctr) tty->print_cr(\"%5d rethrow handler\", _rethrow_ctr);\n+  if (_new_instance_ctr) tty->print_cr(\"%5u new instance requires GC\", _new_instance_ctr);\n+  if (_new_array_ctr) tty->print_cr(\"%5u new array requires GC\", _new_array_ctr);\n+  if (_multi2_ctr) tty->print_cr(\"%5u multianewarray 2 dim\", _multi2_ctr);\n+  if (_multi3_ctr) tty->print_cr(\"%5u multianewarray 3 dim\", _multi3_ctr);\n+  if (_multi4_ctr) tty->print_cr(\"%5u multianewarray 4 dim\", _multi4_ctr);\n+  if (_multi5_ctr) tty->print_cr(\"%5u multianewarray 5 dim\", _multi5_ctr);\n+\n+  tty->print_cr(\"%5u inline cache miss in compiled\", _ic_miss_ctr);\n+  tty->print_cr(\"%5u wrong method\", _wrong_method_ctr);\n+  tty->print_cr(\"%5u unresolved static call site\", _resolve_static_ctr);\n+  tty->print_cr(\"%5u unresolved virtual call site\", _resolve_virtual_ctr);\n+  tty->print_cr(\"%5u unresolved opt virtual call site\", _resolve_opt_virtual_ctr);\n+\n+  if (_mon_enter_stub_ctr) tty->print_cr(\"%5u monitor enter stub\", _mon_enter_stub_ctr);\n+  if (_mon_exit_stub_ctr) tty->print_cr(\"%5u monitor exit stub\", _mon_exit_stub_ctr);\n+  if (_mon_enter_ctr) tty->print_cr(\"%5u monitor enter slow\", _mon_enter_ctr);\n+  if (_mon_exit_ctr) tty->print_cr(\"%5u monitor exit slow\", _mon_exit_ctr);\n+  if (_partial_subtype_ctr) tty->print_cr(\"%5u slow partial subtype\", _partial_subtype_ctr);\n+  if (_jbyte_array_copy_ctr) tty->print_cr(\"%5u byte array copies\", _jbyte_array_copy_ctr);\n+  if (_jshort_array_copy_ctr) tty->print_cr(\"%5u short array copies\", _jshort_array_copy_ctr);\n+  if (_jint_array_copy_ctr) tty->print_cr(\"%5u int array copies\", _jint_array_copy_ctr);\n+  if (_jlong_array_copy_ctr) tty->print_cr(\"%5u long array copies\", _jlong_array_copy_ctr);\n+  if (_oop_array_copy_ctr) tty->print_cr(\"%5u oop array copies\", _oop_array_copy_ctr);\n+  if (_checkcast_array_copy_ctr) tty->print_cr(\"%5u checkcast array copies\", _checkcast_array_copy_ctr);\n+  if (_unsafe_array_copy_ctr) tty->print_cr(\"%5u unsafe array copies\", _unsafe_array_copy_ctr);\n+  if (_generic_array_copy_ctr) tty->print_cr(\"%5u generic array copies\", _generic_array_copy_ctr);\n+  if (_slow_array_copy_ctr) tty->print_cr(\"%5u slow array copies\", _slow_array_copy_ctr);\n+  if (_find_handler_ctr) tty->print_cr(\"%5u find exception handler\", _find_handler_ctr);\n+  if (_rethrow_ctr) tty->print_cr(\"%5u rethrow handler\", _rethrow_ctr);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -563,28 +563,28 @@\n-  static int _ic_miss_ctr;                       \/\/ total # of IC misses\n-  static int _wrong_method_ctr;\n-  static int _resolve_static_ctr;\n-  static int _resolve_virtual_ctr;\n-  static int _resolve_opt_virtual_ctr;\n-  static int _implicit_null_throws;\n-  static int _implicit_div0_throws;\n-\n-  static int _jbyte_array_copy_ctr;        \/\/ Slow-path byte array copy\n-  static int _jshort_array_copy_ctr;       \/\/ Slow-path short array copy\n-  static int _jint_array_copy_ctr;         \/\/ Slow-path int array copy\n-  static int _jlong_array_copy_ctr;        \/\/ Slow-path long array copy\n-  static int _oop_array_copy_ctr;          \/\/ Slow-path oop array copy\n-  static int _checkcast_array_copy_ctr;    \/\/ Slow-path oop array copy, with cast\n-  static int _unsafe_array_copy_ctr;       \/\/ Slow-path includes alignment checks\n-  static int _generic_array_copy_ctr;      \/\/ Slow-path includes type decoding\n-  static int _slow_array_copy_ctr;         \/\/ Slow-path failed out to a method call\n-\n-  static int _new_instance_ctr;            \/\/ 'new' object requires GC\n-  static int _new_array_ctr;               \/\/ 'new' array requires GC\n-  static int _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n-  static int _find_handler_ctr;            \/\/ find exception handler\n-  static int _rethrow_ctr;                 \/\/ rethrow exception\n-  static int _mon_enter_stub_ctr;          \/\/ monitor enter stub\n-  static int _mon_exit_stub_ctr;           \/\/ monitor exit stub\n-  static int _mon_enter_ctr;               \/\/ monitor enter slow\n-  static int _mon_exit_ctr;                \/\/ monitor exit slow\n-  static int _partial_subtype_ctr;         \/\/ SubRoutines::partial_subtype_check\n+  static uint _ic_miss_ctr;                      \/\/ total # of IC misses\n+  static uint _wrong_method_ctr;\n+  static uint _resolve_static_ctr;\n+  static uint _resolve_virtual_ctr;\n+  static uint _resolve_opt_virtual_ctr;\n+  static uint _implicit_null_throws;\n+  static uint _implicit_div0_throws;\n+\n+  static uint _jbyte_array_copy_ctr;       \/\/ Slow-path byte array copy\n+  static uint _jshort_array_copy_ctr;      \/\/ Slow-path short array copy\n+  static uint _jint_array_copy_ctr;        \/\/ Slow-path int array copy\n+  static uint _jlong_array_copy_ctr;       \/\/ Slow-path long array copy\n+  static uint _oop_array_copy_ctr;         \/\/ Slow-path oop array copy\n+  static uint _checkcast_array_copy_ctr;   \/\/ Slow-path oop array copy, with cast\n+  static uint _unsafe_array_copy_ctr;      \/\/ Slow-path includes alignment checks\n+  static uint _generic_array_copy_ctr;     \/\/ Slow-path includes type decoding\n+  static uint _slow_array_copy_ctr;        \/\/ Slow-path failed out to a method call\n+\n+  static uint _new_instance_ctr;           \/\/ 'new' object requires GC\n+  static uint _new_array_ctr;              \/\/ 'new' array requires GC\n+  static uint _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n+  static uint _find_handler_ctr;           \/\/ find exception handler\n+  static uint _rethrow_ctr;                \/\/ rethrow exception\n+  static uint _mon_enter_stub_ctr;         \/\/ monitor enter stub\n+  static uint _mon_exit_stub_ctr;          \/\/ monitor exit stub\n+  static uint _mon_enter_ctr;              \/\/ monitor enter slow\n+  static uint _mon_exit_ctr;               \/\/ monitor exit slow\n+  static uint _partial_subtype_ctr;        \/\/ SubRoutines::partial_subtype_check\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -1685,0 +1686,1 @@\n+  NativeHeapTrimmer::SuspendMark sm(\"monitor deletion\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -892,1 +892,1 @@\n-  DirectivesParser::parse_from_file(_filename.value(), output());\n+  DirectivesParser::parse_from_file(_filename.value(), output(), true);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-    assert(0 <= i && i < _len, \"illegal index\");\n+    assert(0 <= i && i < _len, \"illegal index %d for length %d\", i, _len);\n@@ -152,1 +152,1 @@\n-    assert(0 <= i && i < _len, \"illegal index\");\n+    assert(0 <= i && i < _len, \"illegal index %d for length %d\", i, _len);\n@@ -157,1 +157,1 @@\n-    assert(0 <= i && i < _len, \"illegal index\");\n+    assert(0 <= i && i < _len, \"illegal index %d for length %d\", i, _len);\n@@ -189,1 +189,1 @@\n-    assert(0 <= i && i < _len, \"illegal index\");\n+    assert(0 <= i && i < _len, \"illegal index %d for length %d\", i, _len);\n@@ -250,1 +250,1 @@\n-    assert(0 <= index && index < _len, \"illegal index\");\n+    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n@@ -264,2 +264,2 @@\n-    assert(0 <= start, \"illegal index\");\n-    assert(start < end && end <= _len, \"erase called with invalid range\");\n+    assert(0 <= start, \"illegal start index %d\", start);\n+    assert(start < end && end <= _len, \"erase called with invalid range (%d, %d) for length %d\", start, end, _len);\n@@ -275,1 +275,1 @@\n-    assert(0 <= index && index < _len, \"illegal index\");\n+    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n@@ -408,1 +408,1 @@\n-    assert(0 <= i, \"negative index\");\n+    assert(0 <= i, \"negative index %d\", i);\n@@ -419,1 +419,1 @@\n-    assert(0 <= i, \"negative index\");\n+    assert(0 <= i, \"negative index %d\", i);\n@@ -431,1 +431,1 @@\n-    assert(0 <= idx && idx <= this->_len, \"illegal index\");\n+    assert(0 <= idx && idx <= this->_len, \"illegal index %d for length %d\", idx, this->_len);\n@@ -441,1 +441,1 @@\n-    assert(0 <= idx && idx <= this->_len, \"illegal index\");\n+    assert(0 <= idx && idx <= this->_len, \"illegal index %d for length %d\", idx, this->_len);\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,8 @@\n-import java.lang.reflect.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.ref.WeakReference;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.UndeclaredThrowableException;\n@@ -31,0 +38,10 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n@@ -34,3 +51,6 @@\n-import sun.invoke.WrapperInstance;\n-import java.util.ArrayList;\n-\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.misc.ValhallaFeatures;\n+import jdk.internal.module.Modules;\n@@ -39,0 +59,1 @@\n+import jdk.internal.util.ClassFileDumper;\n@@ -40,0 +61,2 @@\n+\n+import static java.lang.constant.ConstantDescs.*;\n@@ -41,0 +64,3 @@\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.lang.module.ModuleDescriptor.Modifier.SYNTHETIC;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -64,1 +90,2 @@\n-     * The interface must be public and not {@linkplain Class#isSealed() sealed}.\n+     * The interface must be public, not {@linkplain Class#isHidden() hidden},\n+     * and not {@linkplain Class#isSealed() sealed}.\n@@ -136,23 +163,1 @@\n-    \/\/ Other notes to implementors:\n-    \/\/ <p>\n-    \/\/ No stable mapping is promised between the single-method interface and\n-    \/\/ the implementation class C.  Over time, several implementation\n-    \/\/ classes might be used for the same type.\n-    \/\/ <p>\n-    \/\/ If the implementation is able\n-    \/\/ to prove that a wrapper of the required type\n-    \/\/ has already been created for a given\n-    \/\/ method handle, or for another method handle with the\n-    \/\/ same behavior, the implementation may return that wrapper in place of\n-    \/\/ a new wrapper.\n-    \/\/ <p>\n-    \/\/ This method is designed to apply to common use cases\n-    \/\/ where a single method handle must interoperate with\n-    \/\/ an interface that implements a function-like\n-    \/\/ API.  Additional variations, such as single-abstract-method classes with\n-    \/\/ private constructors, or interfaces with multiple but related\n-    \/\/ entry points, must be covered by hand-written or automatically\n-    \/\/ generated adapter classes.\n-    \/\/\n-    @SuppressWarnings({\"removal\",\n-                       \"doclint:reference\"}) \/\/ cross-module links\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -165,0 +170,3 @@\n+        if (intfc.isHidden())\n+            throw newIllegalArgumentException(\"a hidden interface\", intfc.getName());\n+        Objects.requireNonNull(target);\n@@ -166,1 +174,3 @@\n-        if (System.getSecurityManager() != null) {\n+        @SuppressWarnings(\"removal\")\n+        var sm = System.getSecurityManager();\n+        if (sm != null) {\n@@ -174,4 +184,27 @@\n-        ClassLoader proxyLoader = intfc.getClassLoader();\n-        if (proxyLoader == null) {\n-            ClassLoader cl = Thread.currentThread().getContextClassLoader(); \/\/ avoid use of BCP\n-            proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();\n+\n+        \/\/ Define one hidden class for each interface.  Create an instance of\n+        \/\/ the hidden class for a given target method handle which will be\n+        \/\/ accessed via getfield.  Multiple instances may be created for a\n+        \/\/ hidden class.  This approach allows the generated hidden classes\n+        \/\/ more shareable.\n+        \/\/\n+        \/\/ The implementation class is weakly referenced; a new class is\n+        \/\/ defined if the last one has been garbage collected.\n+        \/\/\n+        \/\/ An alternative approach is to define one hidden class with the\n+        \/\/ target method handle as class data and the target method handle\n+        \/\/ is loaded via ldc\/condy.  If more than one target method handles\n+        \/\/ are used, the extra classes will pollute the same type profiles.\n+        \/\/ In addition, hidden classes without class data is more friendly\n+        \/\/ for pre-generation (shifting the dynamic class generation from\n+        \/\/ runtime to an earlier phrase).\n+        Class<?> proxyClass = getProxyClass(intfc);  \/\/ throws IllegalArgumentException\n+        Lookup lookup = new Lookup(proxyClass);\n+        Object proxy;\n+        try {\n+            MethodHandle constructor = lookup.findConstructor(proxyClass,\n+                                                              MT_void_Lookup_MethodHandle_MethodHandle)\n+                                             .asType(MT_Object_Lookup_MethodHandle_MethodHandle);\n+            proxy = constructor.invokeExact(lookup, target, mh);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n@@ -179,10 +212,14 @@\n-        final Method[] methods = getSingleNameMethods(intfc);\n-        if (methods == null)\n-            throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n-        final MethodHandle[] vaTargets = new MethodHandle[methods.length];\n-        for (int i = 0; i < methods.length; i++) {\n-            Method sm = methods[i];\n-            MethodType smMT = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());\n-            MethodHandle checkTarget = mh.asType(smMT);  \/\/ make throw WMT\n-            checkTarget = checkTarget.asType(checkTarget.type().changeReturnType(Object.class));\n-            vaTargets[i] = checkTarget.asSpreader(Object[].class, smMT.parameterCount());\n+        assert proxy.getClass().getModule().isNamed() : proxy.getClass() + \" \" + proxy.getClass().getModule();\n+        return intfc.cast(proxy);\n+    }\n+\n+    private record MethodInfo(MethodTypeDesc desc, List<ClassDesc> thrown, String fieldName) {}\n+\n+    private static final ClassFileDumper DUMPER = ClassFileDumper.getInstance(\n+            \"jdk.invoke.MethodHandleProxies.dumpClassFiles\", \"DUMP_MH_PROXY_CLASSFILES\");\n+\n+    private static final Set<Class<?>> WRAPPER_TYPES = Collections.newSetFromMap(new WeakHashMap<>());\n+    private static final ClassValue<WeakReferenceHolder<Class<?>>> PROXIES = new ClassValue<>() {\n+        @Override\n+        protected WeakReferenceHolder<Class<?>> computeValue(Class<?> intfc) {\n+            return new WeakReferenceHolder<>(newProxyClass(intfc));\n@@ -190,36 +227,68 @@\n-        final InvocationHandler ih = new InvocationHandler() {\n-                private Object getArg(String name) {\n-                    if ((Object)name == \"getWrapperInstanceTarget\")  return target;\n-                    if ((Object)name == \"getWrapperInstanceType\")    return intfc;\n-                    throw new AssertionError();\n-                }\n-                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                    for (int i = 0; i < methods.length; i++) {\n-                        if (method.equals(methods[i]))\n-                            return vaTargets[i].invokeExact(args);\n-                    }\n-                    if (method.getDeclaringClass() == WrapperInstance.class)\n-                        return getArg(method.getName());\n-                    if (isObjectMethod(method))\n-                        return callObjectMethod(proxy, method, args);\n-                    if (isDefaultMethod(method)) {\n-                        \/\/ no additional access check is performed\n-                        return JLRA.invokeDefault(proxy, method, args, null);\n-                    }\n-                    throw newInternalError(\"bad proxy method: \"+method);\n-                }\n-            };\n-\n-        final Object proxy;\n-        if (System.getSecurityManager() != null) {\n-            \/\/ sun.invoke.WrapperInstance is a restricted interface not accessible\n-            \/\/ by any non-null class loader.\n-            final ClassLoader loader = proxyLoader;\n-            proxy = AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Object run() {\n-                    return Proxy.newProxyInstance(\n-                            loader,\n-                            new Class<?>[]{ intfc, WrapperInstance.class },\n-                            ih);\n-                }\n-            });\n+    };\n+\n+    private static Class<?> newProxyClass(Class<?> intfc) {\n+        List<MethodInfo> methods = new ArrayList<>();\n+        Set<Class<?>> referencedTypes = new HashSet<>();\n+        referencedTypes.add(intfc);\n+        String uniqueName = null;\n+        int count = 0;\n+        for (Method m : intfc.getMethods()) {\n+            if (!Modifier.isAbstract(m.getModifiers()))\n+                continue;\n+\n+            if (isObjectMethod(m))\n+                continue;\n+\n+            \/\/ ensure it's SAM interface\n+            String methodName = m.getName();\n+            if (uniqueName == null) {\n+                uniqueName = methodName;\n+            } else if (!uniqueName.equals(methodName)) {\n+                \/\/ too many abstract methods\n+                throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n+            }\n+\n+            \/\/ the field name holding the method handle for this method\n+            String fieldName = \"m\" + count++;\n+            var mt = methodType(m.getReturnType(), JLRA.getExecutableSharedParameterTypes(m), true);\n+            var thrown = JLRA.getExecutableSharedExceptionTypes(m);\n+            var exceptionTypeDescs =\n+                    thrown.length == 0 ? DEFAULT_RETHROWS\n+                                       : Stream.concat(DEFAULT_RETHROWS.stream(),\n+                                                       Arrays.stream(thrown).map(MethodHandleProxies::desc))\n+                                               .distinct().toList();\n+            methods.add(new MethodInfo(desc(mt), exceptionTypeDescs, fieldName));\n+\n+            \/\/ find the types referenced by this method\n+            addElementType(referencedTypes, m.getReturnType());\n+            addElementTypes(referencedTypes, JLRA.getExecutableSharedParameterTypes(m));\n+            addElementTypes(referencedTypes, JLRA.getExecutableSharedExceptionTypes(m));\n+        }\n+\n+        if (uniqueName == null)\n+            throw newIllegalArgumentException(\"no method in \", intfc.getName());\n+\n+        \/\/ create a dynamic module for each proxy class, which needs access\n+        \/\/ to the types referenced by the members of the interface including\n+        \/\/ the parameter types, return type and exception types\n+        var loader = intfc.getClassLoader();\n+        Module targetModule = newDynamicModule(loader, referencedTypes);\n+\n+        \/\/ generate a class file in the package of the dynamic module\n+        String packageName = targetModule.getName();\n+        String intfcName = intfc.getName();\n+        int i = intfcName.lastIndexOf('.');\n+        \/\/ jdk.MHProxy#.Interface\n+        String className = packageName + \".\" + (i > 0 ? intfcName.substring(i + 1) : intfcName);\n+        byte[] template = createTemplate(loader, ClassDesc.of(className), desc(intfc), uniqueName, methods);\n+        \/\/ define the dynamic module to the class loader of the interface\n+        var definer = new Lookup(intfc).makeHiddenClassDefiner(className, template, Set.of(), DUMPER);\n+\n+        @SuppressWarnings(\"removal\")\n+        var sm = System.getSecurityManager();\n+        Lookup lookup;\n+        if (sm != null) {\n+            @SuppressWarnings(\"removal\")\n+            var l = AccessController.doPrivileged((PrivilegedAction<Lookup>) () ->\n+                    definer.defineClassAsLookup(true));\n+            lookup = l;\n@@ -227,3 +296,1 @@\n-            proxy = Proxy.newProxyInstance(proxyLoader,\n-                                           new Class<?>[]{ intfc, WrapperInstance.class },\n-                                           ih);\n+            lookup = definer.defineClassAsLookup(true);\n@@ -231,1 +298,178 @@\n-        return intfc.cast(proxy);\n+        \/\/ cache the wrapper type\n+        var ret = lookup.lookupClass();\n+        WRAPPER_TYPES.add(ret);\n+        return ret;\n+    }\n+\n+    private static final class WeakReferenceHolder<T> {\n+        private volatile WeakReference<T> ref;\n+\n+        WeakReferenceHolder(T value) {\n+            set(value);\n+        }\n+\n+        void set(T value) {\n+            ref = new WeakReference<>(value);\n+        }\n+\n+        T get() {\n+            return ref.get();\n+        }\n+    }\n+\n+    private static Class<?> getProxyClass(Class<?> intfc) {\n+        WeakReferenceHolder<Class<?>> r = PROXIES.get(intfc);\n+        Class<?> cl = r.get();\n+        if (cl != null)\n+            return cl;\n+\n+        \/\/ avoid spinning multiple classes in a race\n+        synchronized (r) {\n+            cl = r.get();\n+            if (cl != null)\n+                return cl;\n+\n+            \/\/ If the referent is cleared, create a new value and update cached weak reference.\n+            cl = newProxyClass(intfc);\n+            r.set(cl);\n+            return cl;\n+        }\n+    }\n+\n+    private static final List<ClassDesc> DEFAULT_RETHROWS = List.of(desc(RuntimeException.class), desc(Error.class));\n+    private static final ClassDesc CD_UndeclaredThrowableException = desc(UndeclaredThrowableException.class);\n+    private static final ClassDesc CD_IllegalAccessException = desc(IllegalAccessException.class);\n+    private static final MethodTypeDesc MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable);\n+    private static final MethodType MT_void_Lookup_MethodHandle_MethodHandle =\n+            methodType(void.class, Lookup.class, MethodHandle.class, MethodHandle.class);\n+    private static final MethodType MT_Object_Lookup_MethodHandle_MethodHandle =\n+            MT_void_Lookup_MethodHandle_MethodHandle.changeReturnType(Object.class);\n+    private static final MethodType MT_MethodHandle_Object = methodType(MethodHandle.class, Object.class);\n+    private static final MethodTypeDesc MTD_void_Lookup_MethodHandle_MethodHandle =\n+            desc(MT_void_Lookup_MethodHandle_MethodHandle);\n+    private static final MethodTypeDesc MTD_void_Lookup = MethodTypeDesc.of(CD_void, CD_MethodHandles_Lookup);\n+    private static final MethodTypeDesc MTD_MethodHandle_MethodType = MethodTypeDesc.of(CD_MethodHandle, CD_MethodType);\n+    private static final MethodTypeDesc MTD_Class = MethodTypeDesc.of(CD_Class);\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MTD_String = MethodTypeDesc.of(CD_String);\n+    private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+    private static final String TARGET_NAME = \"target\";\n+    private static final String TYPE_NAME = \"interfaceType\";\n+    private static final String ENSURE_ORIGINAL_LOOKUP = \"ensureOriginalLookup\";\n+\n+    \/**\n+     * Creates an implementation class file for a given interface. One implementation class is\n+     * defined for each interface.\n+     *\n+     * @param ifaceDesc the given interface\n+     * @param methodName the name of the single abstract method\n+     * @param methods the information for implementation methods\n+     * @return the bytes of the implementation classes\n+     *\/\n+    private static byte[] createTemplate(ClassLoader loader, ClassDesc proxyDesc, ClassDesc ifaceDesc,\n+                                         String methodName, List<MethodInfo> methods) {\n+        return Classfile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader)))\n+                        .build(proxyDesc, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags((ValhallaFeatures.isEnabled() ? ACC_IDENTITY : 0) | ACC_FINAL | ACC_SYNTHETIC);\n+            clb.withInterfaceSymbols(ifaceDesc);\n+\n+            \/\/ static and instance fields\n+            clb.withField(TYPE_NAME, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+            clb.withField(TARGET_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            for (var mi : methods) {\n+                clb.withField(mi.fieldName, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            }\n+\n+            \/\/ <clinit>\n+            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                cob.constantInstruction(ifaceDesc);\n+                cob.putstatic(proxyDesc, TYPE_NAME, CD_Class);\n+                cob.return_();\n+            });\n+\n+            \/\/ <init>(Lookup, MethodHandle target, MethodHandle callerBoundTarget)\n+            clb.withMethodBody(INIT_NAME, MTD_void_Lookup_MethodHandle_MethodHandle, 0, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+\n+                \/\/ call ensureOriginalLookup to verify the given Lookup has access\n+                cob.aload(1);\n+                cob.invokestatic(proxyDesc, \"ensureOriginalLookup\", MTD_void_Lookup);\n+\n+                \/\/ this.target = target;\n+                cob.aload(0);\n+                cob.aload(2);\n+                cob.putfield(proxyDesc, TARGET_NAME, CD_MethodHandle);\n+\n+                \/\/ method handles adjusted to the method type of each method\n+                for (var mi : methods) {\n+                    \/\/ this.m<i> = callerBoundTarget.asType(xxType);\n+                    cob.aload(0);\n+                    cob.aload(3);\n+                    cob.constantInstruction(mi.desc);\n+                    cob.invokevirtual(CD_MethodHandle, \"asType\", MTD_MethodHandle_MethodType);\n+                    cob.putfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                }\n+\n+                \/\/ complete\n+                cob.return_();\n+            });\n+\n+            \/\/ private static void ensureOriginalLookup(Lookup) checks if the given Lookup\n+            \/\/ has ORIGINAL access to this class, i.e. the lookup class is this class;\n+            \/\/ otherwise, IllegalAccessException is thrown\n+            clb.withMethodBody(ENSURE_ORIGINAL_LOOKUP, MTD_void_Lookup, ACC_PRIVATE | ACC_STATIC, cob -> {\n+                var failLabel = cob.newLabel();\n+                \/\/ check lookupClass\n+                cob.aload(0);\n+                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class);\n+                cob.constantInstruction(proxyDesc);\n+                cob.if_acmpne(failLabel);\n+                \/\/ check original access\n+                cob.aload(0);\n+                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupModes\", MTD_int);\n+                cob.constantInstruction(Lookup.ORIGINAL);\n+                cob.iand();\n+                cob.ifeq(failLabel);\n+                \/\/ success\n+                cob.return_();\n+                \/\/ throw exception\n+                cob.labelBinding(failLabel);\n+                cob.new_(CD_IllegalAccessException);\n+                cob.dup();\n+                cob.aload(0); \/\/ lookup\n+                cob.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                cob.invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String);\n+                cob.athrow();\n+            });\n+\n+            \/\/ implementation methods\n+            for (MethodInfo mi : methods) {\n+                \/\/ no need to generate thrown exception attribute\n+                clb.withMethodBody(methodName, mi.desc, ACC_PUBLIC, cob -> cob\n+                        .trying(bcb -> {\n+                                    \/\/ return this.handleField.invokeExact(arguments...);\n+                                    bcb.aload(0);\n+                                    bcb.getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                                    for (int j = 0; j < mi.desc.parameterCount(); j++) {\n+                                        bcb.loadInstruction(TypeKind.from(mi.desc.parameterType(j)),\n+                                                bcb.parameterSlot(j));\n+                                    }\n+                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", mi.desc);\n+                                    bcb.returnInstruction(TypeKind.from(mi.desc.returnType()));\n+                                }, ctb -> ctb\n+                                        \/\/ catch (Error | RuntimeException | Declared ex) { throw ex; }\n+                                        .catchingMulti(mi.thrown, CodeBuilder::athrow)\n+                                        \/\/ catch (Throwable ex) { throw new UndeclaredThrowableException(ex); }\n+                                        .catchingAll(cb -> cb\n+                                                .new_(CD_UndeclaredThrowableException)\n+                                                .dup_x1()\n+                                                .swap()\n+                                                .invokespecial(CD_UndeclaredThrowableException,\n+                                                        INIT_NAME, MTD_void_Throwable)\n+                                                .athrow()\n+                                        )\n+                        ));\n+            }\n+        });\n@@ -244,10 +488,1 @@\n-        return x instanceof WrapperInstance;\n-    }\n-\n-    private static WrapperInstance asWrapperInstance(Object x) {\n-        try {\n-            if (x != null)\n-                return (WrapperInstance) x;\n-        } catch (ClassCastException ex) {\n-        }\n-        throw newIllegalArgumentException(\"not a wrapper instance\");\n+        return x != null && WRAPPER_TYPES.contains(x.getClass());\n@@ -266,1 +501,11 @@\n-        return asWrapperInstance(x).getWrapperInstanceTarget();\n+        if (!isWrapperInstance(x))\n+            throw new IllegalArgumentException(\"not a wrapper instance: \" + x);\n+\n+        try {\n+            Class<?> type = x.getClass();\n+            MethodHandle getter = new Lookup(type).findGetter(type, TARGET_NAME, MethodHandle.class)\n+                                                  .asType(MT_MethodHandle_Object);\n+            return (MethodHandle) getter.invokeExact(x);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n@@ -278,1 +523,55 @@\n-        return asWrapperInstance(x).getWrapperInstanceType();\n+        if (!isWrapperInstance(x))\n+            throw new IllegalArgumentException(\"not a wrapper instance: \" + x);\n+\n+        try {\n+            Class<?> type = x.getClass();\n+            MethodHandle originalTypeField = new Lookup(type).findStaticGetter(type, TYPE_NAME, Class.class);\n+            return (Class<?>) originalTypeField.invokeExact();\n+        } catch (Throwable e) {\n+            throw uncaughtException(e);\n+        }\n+    }\n+\n+    private static ClassDesc desc(Class<?> cl) {\n+        return cl.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert class \"\n+                + cl.getName() + \" to a constant\"));\n+    }\n+\n+    private static MethodTypeDesc desc(MethodType mt) {\n+        return mt.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert method type \"\n+                + mt + \" to a constant\"));\n+    }\n+\n+    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n+    private static final AtomicInteger counter = new AtomicInteger();\n+\n+    private static String nextModuleName() {\n+        return \"jdk.MHProxy\" + counter.incrementAndGet();\n+    }\n+\n+    \/**\n+     * Create a dynamic module defined to the given class loader and has\n+     * access to the given types.\n+     * <p>\n+     * The dynamic module contains only one single package named the same as\n+     * the name of the dynamic module.  It's not exported or open.\n+     *\/\n+    private static Module newDynamicModule(ClassLoader ld, Set<Class<?>> types) {\n+        Objects.requireNonNull(types);\n+\n+        \/\/ create a dynamic module and setup module access\n+        String mn = nextModuleName();\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n+                .packages(Set.of(mn))\n+                .build();\n+\n+        Module dynModule = Modules.defineModule(ld, descriptor, null);\n+        Module javaBase = Object.class.getModule();\n+\n+        Modules.addReads(dynModule, javaBase);\n+        Modules.addOpens(dynModule, mn, javaBase);\n+\n+        for (Class<?> c : types) {\n+            ensureAccess(dynModule, c);\n+        }\n+        return dynModule;\n@@ -284,1 +583,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -286,1 +585,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -288,2 +587,2 @@\n-                               && m.getParameterCount() == 1\n-                               && m.getParameterTypes()[0] == Object.class;\n+                    && m.getParameterCount() == 1\n+                    && JLRA.getExecutableSharedParameterTypes(m)[0] == Object.class;\n@@ -294,8 +593,13 @@\n-    private static Object callObjectMethod(Object self, Method m, Object[] args) {\n-        assert(isObjectMethod(m)) : m;\n-        return switch (m.getName()) {\n-            case \"toString\" -> java.util.Objects.toIdentityString(self);\n-            case \"hashCode\" -> System.identityHashCode(self);\n-            case \"equals\"   -> (self == args[0]);\n-            default -> null;\n-        };\n+    \/*\n+     * Ensure the given module can access the given class.\n+     *\/\n+    private static void ensureAccess(Module target, Class<?> c) {\n+        Module m = c.getModule();\n+        \/\/ add read edge and qualified export for the target module to access\n+        if (!target.canRead(m)) {\n+            Modules.addReads(target, m);\n+        }\n+        String pn = c.getPackageName();\n+        if (!m.isExported(pn, target)) {\n+            Modules.addExports(m, pn, target);\n+        }\n@@ -304,12 +608,3 @@\n-    private static Method[] getSingleNameMethods(Class<?> intfc) {\n-        ArrayList<Method> methods = new ArrayList<>();\n-        String uniqueName = null;\n-        for (Method m : intfc.getMethods()) {\n-            if (isObjectMethod(m))  continue;\n-            if (!Modifier.isAbstract(m.getModifiers()))  continue;\n-            String mname = m.getName();\n-            if (uniqueName == null)\n-                uniqueName = mname;\n-            else if (!uniqueName.equals(mname))\n-                return null;  \/\/ too many abstract methods\n-            methods.add(m);\n+    private static void addElementTypes(Set<Class<?>> types, Class<?>... classes) {\n+        for (var cls : classes) {\n+            addElementType(types, cls);\n@@ -317,2 +612,0 @@\n-        if (uniqueName == null)  return null;\n-        return methods.toArray(new Method[methods.size()]);\n@@ -321,3 +614,5 @@\n-    private static boolean isDefaultMethod(Method m) {\n-        return !Modifier.isAbstract(m.getModifiers());\n-    }\n+    private static void addElementType(Set<Class<?>> types, Class<?> cls) {\n+        Class<?> e = cls;\n+        while (e.isArray()) {\n+            e = e.getComponentType();\n+        }\n@@ -325,1 +620,4 @@\n-    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n+        if (!e.isPrimitive()) {\n+            types.add(e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":424,"deletions":126,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -2016,0 +2016,5 @@\n+\n+        private static final @Stable AccessMode[] VALUES = values();\n+        static AccessMode valueFromOrdinal(int mode) {\n+            return VALUES[mode];\n+        }\n@@ -2228,1 +2233,1 @@\n-        MethodType mt = accessModeType(AccessMode.values()[mode]).\n+        MethodType mt = accessModeType(AccessMode.valueFromOrdinal(mode)).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -572,0 +572,1 @@\n+    int ACC_IDENTITY = 0x0020;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+    \/\/ For externalization lint checking\n@@ -243,0 +244,2 @@\n+    public final Type objectInputType;\n+    public final Type objectOutputType;\n@@ -638,0 +641,2 @@\n+        objectInputType  = enterClass(\"java.io.ObjectInput\");\n+        objectOutputType = enterClass(\"java.io.ObjectOutput\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1702,0 +1702,1 @@\n+            boolean errorPrimitiveSwitch = seltype.isPrimitive() && !intSwitch;\n@@ -1703,1 +1704,2 @@\n-            if (!enumSwitch && !stringSwitch && !errorEnumSwitch && !intSwitch) {\n+            if (!enumSwitch && !stringSwitch && !errorEnumSwitch &&\n+                !intSwitch && !errorPrimitiveSwitch) {\n@@ -1707,0 +1709,3 @@\n+                if (errorPrimitiveSwitch) {\n+                    log.error(selector.pos(), Errors.SelectorTypeNotAllowed(seltype));\n+                }\n@@ -1789,1 +1794,1 @@\n-                                } else if (!stringSwitch && !intSwitch) {\n+                                } else if (!stringSwitch && !intSwitch && !errorPrimitiveSwitch) {\n@@ -1812,1 +1817,3 @@\n-                        checkCastablePattern(pat.pos(), seltype, primaryType);\n+                        if (!errorPrimitiveSwitch) {\n+                            checkCastablePattern(pat.pos(), seltype, primaryType);\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -5025,2 +5025,1 @@\n-        }\n-        catch (CompletionFailure e) {\n+        } catch (CompletionFailure e) {\n@@ -5397,0 +5396,19 @@\n+        private void checkWriteExternalRecord(JCClassDecl tree, Element e, MethodSymbol method, boolean isExtern) {\n+            \/\/public void writeExternal(ObjectOutput) throws IOException\n+            checkExternMethodRecord(tree, e, method, syms.objectOutputType, isExtern);\n+        }\n+\n+        private void checkReadExternalRecord(JCClassDecl tree, Element e, MethodSymbol method, boolean isExtern) {\n+            \/\/ public void readExternal(ObjectInput) throws IOException\n+            checkExternMethodRecord(tree, e, method, syms.objectInputType, isExtern);\n+         }\n+\n+        private void checkExternMethodRecord(JCClassDecl tree, Element e, MethodSymbol method, Type argType,\n+                                             boolean isExtern) {\n+            if (isExtern && isExternMethod(tree, e, method, argType)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.IneffectualExternalizableMethodRecord(method.getSimpleName().toString()));\n+            }\n+        }\n+\n@@ -5423,0 +5441,1 @@\n+            boolean isExtern = isExternalizable((Type)e.asType());\n@@ -5443,0 +5462,7 @@\n+\n+                        if (isExtern) {\n+                            switch(name) {\n+                            case \"writeExternal\" -> checkWriteExternalEnum(tree, e, method);\n+                            case \"readExternal\"  -> checkReadExternalEnum(tree, e, method);\n+                            }\n+                        }\n@@ -5444,0 +5470,9 @@\n+\n+                    \/\/ Also perform checks on any class bodies of enum constants, see JLS 8.9.1.\n+                    case ENUM_CONSTANT -> {\n+                        var field = (VarSymbol)enclosed;\n+                        JCVariableDecl decl = (JCVariableDecl) TreeInfo.declarationFor(field, p);\n+                        if (decl.init instanceof JCNewClass nc && nc.def != null) {\n+                            ClassSymbol enumConstantType = nc.def.sym;\n+                            visitTypeAsEnum(enumConstantType, p);\n+                        }\n@@ -5445,1 +5480,2 @@\n-                });\n+\n+                    }});\n@@ -5450,0 +5486,28 @@\n+        private void checkWriteExternalEnum(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/public void writeExternal(ObjectOutput) throws IOException\n+            checkExternMethodEnum(tree, e, method, syms.objectOutputType);\n+        }\n+\n+        private void checkReadExternalEnum(JCClassDecl tree, Element e, MethodSymbol method) {\n+             \/\/ public void readExternal(ObjectInput) throws IOException\n+            checkExternMethodEnum(tree, e, method, syms.objectInputType);\n+         }\n+\n+        private void checkExternMethodEnum(JCClassDecl tree, Element e, MethodSymbol method, Type argType) {\n+            if (isExternMethod(tree, e, method, argType)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.IneffectualExternMethodEnum(method.getSimpleName().toString()));\n+            }\n+        }\n+\n+        private boolean isExternMethod(JCClassDecl tree, Element e, MethodSymbol method, Type argType) {\n+            long flags = method.flags();\n+            Type rtype = method.getReturnType();\n+\n+            \/\/ Not necessary to check throws clause in this context\n+            return (flags & PUBLIC) != 0 && (flags & STATIC) == 0 &&\n+                types.isSameType(syms.voidType, rtype) &&\n+                hasExactlyOneArgWithType(tree, e, method, argType);\n+        }\n+\n@@ -5495,2 +5559,1 @@\n-                    }\n-                    }\n+                    }}\n@@ -5555,0 +5618,1 @@\n+            boolean isExtern = isExternalizable((Type)e.asType());\n@@ -5573,3 +5637,1 @@\n-                        }\n-\n-                        }\n+                        }}\n@@ -5584,0 +5646,3 @@\n+                        case \"writeExternal\" -> checkWriteExternalRecord(tree, e, method, isExtern);\n+                        case \"readExternal\"  -> checkReadExternalRecord(tree, e, method, isExtern);\n+\n@@ -5590,6 +5655,2 @@\n-                        }\n-                        }\n-\n-                    }\n-                    }\n-                });\n+                        }}\n+                    }}});\n@@ -5653,0 +5714,10 @@\n+        private boolean hasExactlyOneArgWithType(JCClassDecl tree,\n+                                                 Element enclosing,\n+                                                 MethodSymbol method,\n+                                                 Type expectedType) {\n+            var parameters = method.getParameters();\n+            return (parameters.size() == 1) &&\n+                types.isSameType(parameters.get(0).asType(), expectedType);\n+        }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":85,"deletions":14,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -1573,2 +1573,9 @@\n-                if (frameStack.head.tree.hasTag(LAMBDA)) {\n-                    lambdaContext.addSymbol(tree.sym, LOCAL_VAR);\n+                for (Frame frame : frameStack) {\n+                    if (frame.tree.hasTag(VARDEF)) {\n+                        \/\/skip variable frames inside a lambda:\n+                        continue;\n+                    } else if (frame.tree.hasTag(LAMBDA)) {\n+                        lambdaContext.addSymbol(tree.sym, LOCAL_VAR);\n+                    } else {\n+                        break;\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -564,0 +564,4 @@\n+# 0: type\n+compiler.err.selector.type.not.allowed=\\\n+    selector type {0} is not allowed\n+\n@@ -2024,0 +2028,4 @@\n+# 0: string\n+compiler.warn.ineffectual.extern.method.enum=\\\n+    externalization-related method {0} is not effective in an enum class\n+\n@@ -2031,0 +2039,4 @@\n+# 0: string\n+compiler.warn.ineffectual.externalizable.method.record=\\\n+    externalization-related method {0} is not effective in a record class\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,0 +106,2 @@\n+runtime\/os\/TestTrimNative.java#trimNative 8312525 linux-all\n+runtime\/os\/TestTrimNative.java#trimNativeLowInterval 8312525 linux-all\n@@ -130,1 +132,0 @@\n-serviceability\/jvmti\/vthread\/VThreadTLSTest\/VThreadTLSTest.java#id1 8300051 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 7099223,8274106 macosx-aarch64,linux-all,windows-all\n+java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 7099223,8274106 macosx-all,linux-all,windows-all\n@@ -481,0 +481,2 @@\n+java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java              8312482 linux-all\n+java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java 8312482 linux-all\n@@ -740,2 +742,0 @@\n-javax\/rmi\/ssl\/SSLSocketParametersTest.sh                        8162906 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.test.lib.util.ForceGC;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.WeakReference;\n+import java.util.Comparator;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandleProxies.*;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.misc.ValhallaFeatures;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 6983726\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.misc\n+ * @summary Tests on implementation hidden classes spinned by MethodHandleProxies\n+ * @build WrapperHiddenClassTest Client jdk.test.lib.util.ForceGC\n+ * @run junit WrapperHiddenClassTest\n+ *\/\n+public class WrapperHiddenClassTest {\n+\n+    \/**\n+     * Tests an adversary \"implementation\" class will not be\n+     * \"recovered\" by the wrapperInstance* APIs\n+     *\/\n+    @Test\n+    public void testWrapperInstance() throws Throwable {\n+        Comparator<Integer> hostile = createHostileInstance();\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertTrue(isWrapperInstance(proxy));\n+        assertFalse(isWrapperInstance(hostile));\n+        assertSame(mh, wrapperInstanceTarget(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(hostile));\n+        assertSame(Comparator.class, wrapperInstanceType(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(hostile));\n+    }\n+\n+    private static final String TYPE = \"interfaceType\";\n+    private static final String TARGET = \"target\";\n+    private static final ClassDesc CD_HostileWrapper = ClassDesc.of(\"HostileWrapper\");\n+    private static final ClassDesc CD_Comparator = ClassDesc.of(\"java.util.Comparator\");\n+    private static final MethodTypeDesc MTD_int_Object_Object = MethodTypeDesc.of(CD_int, CD_Object, CD_Object);\n+    private static final MethodTypeDesc MTD_int_Integer = MethodTypeDesc.of(CD_int, CD_Integer);\n+\n+    \/\/ Update this template when the MHP template is updated\n+    @SuppressWarnings(\"unchecked\")\n+    private Comparator<Integer> createHostileInstance() throws Throwable {\n+        var cf = Classfile.of();\n+        var bytes = cf.build(CD_HostileWrapper, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags((ValhallaFeatures.isEnabled() ? ACC_IDENTITY : 0) | ACC_FINAL | ACC_SYNTHETIC);\n+            clb.withInterfaceSymbols(CD_Comparator);\n+\n+            \/\/ static and instance fields\n+            clb.withField(TYPE, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+            clb.withField(TARGET, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+\n+            \/\/ <clinit>\n+            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                cob.constantInstruction(CD_Comparator);\n+                cob.putstatic(CD_HostileWrapper, TYPE, CD_Class);\n+                cob.return_();\n+            });\n+\n+            \/\/ <init>\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+\n+            \/\/ implementation\n+            clb.withMethodBody(\"compare\", MTD_int_Object_Object, ACC_PUBLIC, cob -> {\n+                cob.aload(1);\n+                cob.checkcast(CD_Integer);\n+                cob.aload(2);\n+                cob.checkcast(CD_Integer);\n+                cob.invokestatic(CD_Integer, \"compareTo\", MTD_int_Integer);\n+                cob.ireturn();\n+            });\n+        });\n+        var l = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        return (Comparator<Integer>) l.findConstructor(l.lookupClass(), MethodType.methodType(void.class)).invoke();\n+    }\n+\n+    \/**\n+     * Ensures a user interface cannot access a Proxy implementing it.\n+     *\/\n+    @Test\n+    public void testNoAccess() {\n+        var instance = asInterfaceInstance(Client.class, MethodHandles.zero(void.class));\n+        var instanceClass = instance.getClass();\n+        var interfaceLookup = Client.lookup();\n+        assertEquals(MethodHandles.Lookup.ORIGINAL, interfaceLookup.lookupModes() & MethodHandles.Lookup.ORIGINAL,\n+                \"Missing original flag on interface's lookup\");\n+        assertThrows(IllegalAccessException.class, () -> MethodHandles.privateLookupIn(instanceClass,\n+                interfaceLookup));\n+    }\n+\n+    \/**\n+     * Tests the Proxy module properties for Proxies implementing system and\n+     * user interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Client.class, Runnable.class})\n+    public void testModule(Class<?> ifaceClass) {\n+        var mh = MethodHandles.zero(void.class);\n+\n+        var inst = asInterfaceInstance(ifaceClass, mh);\n+        Module ifaceModule = ifaceClass.getModule();\n+        Class<?> implClass = inst.getClass();\n+        Module implModule = implClass.getModule();\n+\n+        String implPackage = implClass.getPackageName();\n+        assertFalse(implModule.isExported(implPackage),\n+                \"implementation should not be exported\");\n+        assertTrue(ifaceModule.isExported(ifaceClass.getPackageName(), implModule),\n+                \"interface package should be exported to implementation\");\n+        assertTrue(implModule.isOpen(implPackage, MethodHandleProxies.class.getModule()),\n+                \"implementation class is not reflectively open to MHP class\");\n+        assertTrue(implModule.isNamed(), \"dynamic module must be named\");\n+        assertTrue(implModule.getName().startsWith(\"jdk.MHProxy\"),\n+                () -> \"incorrect dynamic module name: \" + implModule.getName());\n+\n+        assertSame(ifaceClass.getClassLoader(), implClass.getClassLoader(),\n+                \"wrapper class should use the interface's loader \");\n+        assertSame(implClass.getClassLoader(), implModule.getClassLoader(),\n+                \"module class loader should be wrapper class's loader\");\n+    }\n+\n+    \/**\n+     * Tests the access control of Proxies implementing system and user\n+     * interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Client.class, Runnable.class})\n+    public void testNoInstantiation(Class<?> ifaceClass) throws ReflectiveOperationException {\n+        var mh = MethodHandles.zero(void.class);\n+        var instanceClass = asInterfaceInstance(ifaceClass, mh).getClass();\n+        var ctor = instanceClass.getDeclaredConstructor(MethodHandles.Lookup.class, MethodHandle.class, MethodHandle.class);\n+\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(Client.lookup(), mh, mh));\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.lookup(), mh, mh));\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.publicLookup(), mh, mh));\n+    }\n+\n+    \/**\n+     * Tests the caching and weak reference of implementation classes for\n+     * system and user interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Runnable.class, Client.class})\n+    public void testWeakImplClass(Class<?> ifaceClass) {\n+        var mh = MethodHandles.zero(void.class);\n+\n+        var wrapper1 = asInterfaceInstance(ifaceClass, mh);\n+        var implClass = wrapper1.getClass();\n+\n+        System.gc(); \/\/ helps debug if incorrect items are weakly referenced\n+        var wrapper2 = asInterfaceInstance(ifaceClass, mh);\n+        assertSame(implClass, wrapper2.getClass(),\n+                \"MHP should reuse old implementation class when available\");\n+\n+        var implClassRef = new WeakReference<>(implClass);\n+        \/\/ clear strong references\n+        implClass = null;\n+        wrapper1 = null;\n+        wrapper2 = null;\n+\n+        if (!ForceGC.wait(() -> implClassRef.refersTo(null))) {\n+            fail(\"MHP impl class cannot be cleared by GC\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -784,0 +784,2 @@\n+\n+  public native void preTouchMemory(long addr, long size);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}