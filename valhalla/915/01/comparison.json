{"files":[{"patch":"@@ -807,1 +807,5 @@\n-      UTIL_REQUIRE_TOOLCHAIN_PROGS(CXXFILT, c++filt)\n+      if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n+        UTIL_REQUIRE_TOOLCHAIN_PROGS(CXXFILT, ibm-llvm-cxxfilt)\n+      else\n+        UTIL_REQUIRE_TOOLCHAIN_PROGS(CXXFILT, c++filt)\n+      fi\n","filename":"make\/autoconf\/toolchain.m4","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-                    value=\"-Xdebug -Xrunjdwp:transport=dt_socket,address=${jpda.address}\"\n+                    value=\"-Xrunjdwp:transport=dt_socket,address=${jpda.address}\"\n","filename":"make\/ide\/netbeans\/langtools\/build.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-       unused-result array-bounds\n+       unused-result array-bounds parentheses\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2306,1 +2306,1 @@\n-      if (!(UseSVE > 1 && VM_Version::supports_svebitperm())) {\n+      if (!VM_Version::supports_svebitperm()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) {\n+        if (vlen > 64 || !VM_Version::supports_svebitperm()) {\n@@ -225,1 +225,1 @@\n-        if (UseSVE < 2 || !VM_Version::supports_svebitperm()) {\n+        if (!VM_Version::supports_svebitperm()) {\n@@ -4590,0 +4590,49 @@\n+\n+\/\/ BOOLEAN\n+\n+instruct extractUB_ireg(iRegINoSp dst, vReg src, iRegI idx, vReg tmp) %{\n+  match(Set dst (ExtractUB src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractUB_ireg $dst, $src, $idx\\t# variable index. KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/ \"idx\" is expected to be in range.\n+\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ mov($tmp$$FloatRegister, __ B, 0, $idx$$Register);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ tbl($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, 1, $tmp$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, $tmp$$FloatRegister);\n+    }\n+    __ smov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractUB_index_lt16(iRegINoSp dst, vReg src, immI idx) %{\n+  predicate(n->in(2)->get_int() < 16);\n+  match(Set dst (ExtractUB src idx));\n+  format %{ \"extractUB_index_lt16 $dst, $src, $idx\\t# index < 16\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ B, (int)($idx$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractUB_index_ge16(iRegINoSp dst, vReg src, immI idx, vReg tmp) %{\n+  predicate(n->in(2)->get_int() >= 16);\n+  match(Set dst (ExtractUB src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractUB_index_ge16 $dst, $src, $idx\\t# index >=16. KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_extract_integral($dst$$Register, T_BYTE, $src$$FloatRegister,\n+                            (int)($idx$$constant), $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-        if (UseSVE < 2 || vlen > 64 || !VM_Version::supports_svebitperm()) {\n+        if (vlen > 64 || !VM_Version::supports_svebitperm()) {\n@@ -215,1 +215,1 @@\n-        if (UseSVE < 2 || !VM_Version::supports_svebitperm()) {\n+        if (!VM_Version::supports_svebitperm()) {\n@@ -3121,0 +3121,28 @@\n+\n+\/\/ BOOLEAN\n+\n+instruct extractUB_ireg(iRegINoSp dst, vReg src, iRegI idx, vReg tmp) %{\n+  match(Set dst (ExtractUB src idx));\n+  effect(TEMP tmp);\n+  format %{ \"extractUB_ireg $dst, $src, $idx\\t# variable index. KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    \/\/ \"idx\" is expected to be in range.\n+\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+    __ mov($tmp$$FloatRegister, __ B, 0, $idx$$Register);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ tbl($tmp$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n+             $src$$FloatRegister, 1, $tmp$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, $tmp$$FloatRegister);\n+    }\n+    __ smov($dst$$Register, $tmp$$FloatRegister, __ B, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+EXTRACT_INT_SMALL(UB, 16, iRegINoSp, smov, B)\n+EXTRACT_INT_LARGE(UB, 16, iRegINoSp, T_BYTE)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-    target |= val;\n+    target |= (unsigned)val;\n@@ -232,1 +232,1 @@\n-    unsigned uval = val;\n+    uint64_t uval = val;\n@@ -239,1 +239,1 @@\n-    target |= uval;\n+    target |= (unsigned)uval;\n@@ -265,1 +265,1 @@\n-    unsigned uval = val;\n+    uint64_t uval = val;\n@@ -268,1 +268,1 @@\n-    f(uval, lsb + nbits - 1, lsb);\n+    f((unsigned)uval, lsb + nbits - 1, lsb);\n@@ -556,1 +556,1 @@\n-          i->f(offset() >> size, 21, 10);\n+          i->f(checked_cast<unsigned>(offset() >> size), 21, 10);\n@@ -656,2 +656,3 @@\n-      int sve_offset = offset \/ vl;\n-      if (((-(1 << (shift - 1))) <= sve_offset) && (sve_offset < (1 << (shift - 1)))) {\n+      int64_t sve_offset = offset \/ vl;\n+      int32_t range = 1 << (shift - 1);\n+      if ((-range <= sve_offset) && (sve_offset < range)) {\n@@ -2415,1 +2416,1 @@\n-      ld_st(Vt, T, a.base(), a.offset(), op1, op2, regs);\n+      ld_st(Vt, T, a.base(), checked_cast<int>(a.offset()), op1, op2, regs);\n@@ -3525,1 +3526,1 @@\n-      sve_ld_st1(Zt, a.base(), a.offset(), Pg, T, op1, type, imm_op2);\n+      sve_ld_st1(Zt, a.base(), checked_cast<int>(a.offset()), Pg, T, op1, type, imm_op2);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  void inc_counter_np_(int& counter) {\n+  void inc_counter_np_(uint& counter) {\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  if (AllocatePrefetchDistance !=-1 && (AllocatePrefetchDistance & 7)) {\n+  if (AllocatePrefetchDistance != -1 && (AllocatePrefetchDistance & 7)) {\n@@ -190,1 +190,1 @@\n-  if (_cpu == CPU_ARM && (_model == 0xd03 || _model2 == 0xd03)) {\n+  if (_cpu == CPU_ARM && model_is(0xd03)) {\n@@ -198,1 +198,1 @@\n-  if (_cpu == CPU_ARM && (_model == 0xd09 || _model2 == 0xd09)) {\n+  if (_cpu == CPU_ARM && model_is(0xd09)) {\n@@ -209,3 +209,1 @@\n-  if (_cpu == CPU_ARM && ((_model == 0xd0c || _model2 == 0xd0c)\n-                          || (_model == 0xd49 || _model2 == 0xd49)\n-                          || (_model == 0xd40 || _model2 == 0xd40))) {\n+  if (_cpu == CPU_ARM && (model_is(0xd0c) || model_is(0xd49) || model_is(0xd40))) {\n@@ -231,9 +229,0 @@\n-  char buf[512];\n-  int buf_used_len = os::snprintf_checked(buf, sizeof(buf), \"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n-  if (_model2) os::snprintf_checked(buf + buf_used_len, sizeof(buf) - buf_used_len, \"(0x%03x)\", _model2);\n-#define ADD_FEATURE_IF_SUPPORTED(id, name, bit) if (VM_Version::supports_##name()) strcat(buf, \", \" #name);\n-  CPU_FEATURE_FLAGS(ADD_FEATURE_IF_SUPPORTED)\n-#undef ADD_FEATURE_IF_SUPPORTED\n-\n-  _features_string = os::strdup(buf);\n-\n@@ -250,1 +239,1 @@\n-  if (_cpu == CPU_ARM && (_model == 0xd40 || _model2 == 0xd40)) {\n+  if (_cpu == CPU_ARM && model_is(0xd40)) {\n@@ -393,3 +382,3 @@\n-      if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n-          UseChaCha20Intrinsics = true;\n-      }\n+    if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      UseChaCha20Intrinsics = true;\n+    }\n@@ -397,4 +386,4 @@\n-      if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n-          warning(\"ChaCha20 intrinsic requires ASIMD instructions\");\n-      }\n-      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n+    if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      warning(\"ChaCha20 intrinsic requires ASIMD instructions\");\n+    }\n+    FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n@@ -577,0 +566,24 @@\n+\n+  \/\/ Sync SVE related CPU features with flags\n+  if (UseSVE < 2) {\n+    _features &= ~CPU_SVE2;\n+    _features &= ~CPU_SVEBITPERM;\n+  }\n+  if (UseSVE < 1) {\n+    _features &= ~CPU_SVE;\n+  }\n+\n+  \/\/ Construct the \"features\" string\n+  char buf[512];\n+  int buf_used_len = os::snprintf_checked(buf, sizeof(buf), \"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n+  if (_model2) {\n+    os::snprintf_checked(buf + buf_used_len, sizeof(buf) - buf_used_len, \"(0x%03x)\", _model2);\n+  }\n+#define ADD_FEATURE_IF_SUPPORTED(id, name, bit)                 \\\n+  do {                                                          \\\n+    if (VM_Version::supports_##name()) strcat(buf, \", \" #name); \\\n+  } while(0);\n+  CPU_FEATURE_FLAGS(ADD_FEATURE_IF_SUPPORTED)\n+#undef ADD_FEATURE_IF_SUPPORTED\n+\n+  _features_string = os::strdup(buf);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":36,"deletions":23,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -154,0 +154,4 @@\n+  static bool model_is(int cpu_model) {\n+    return _model == cpu_model || _model2 == cpu_model;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1038,1 +1038,1 @@\n-  void inc_counter(int* counter_addr, Register tmpreg1, Register tmpreg2) {\n+  void inc_counter(uint* counter_addr, Register tmpreg1, Register tmpreg2) {\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1965,1 +1965,1 @@\n-  int * get_arraycopy_counter(int bytes_per_count) {\n+  uint * get_arraycopy_counter(int bytes_per_count) {\n@@ -2386,1 +2386,1 @@\n-    int* pst_counter = &SharedRuntime::_partial_subtype_ctr;\n+    uint* pst_counter = &SharedRuntime::_partial_subtype_ctr;\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  void inc_counter_np_(int& counter) {\n+  void inc_counter_np_(uint& counter) {\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/collectedHeap.inline.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -2437,1 +2437,1 @@\n-    intptr_t offs = (intptr_t)dst - (intptr_t)pc();\n+    int offs = checked_cast<int>((intptr_t)dst - (intptr_t)pc());\n@@ -2464,2 +2464,2 @@\n-    intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);\n-    intptr_t delta = short_branch_delta();\n+    int dist = checked_cast<int>((intptr_t)entry - (intptr_t)(pc() + short_size));\n+    int delta = short_branch_delta();\n@@ -2469,1 +2469,1 @@\n-    assert(is8bit(dist), \"Dispacement too large for a short jmp at %s:%d\", file, line);\n+    assert(is8bit(dist), \"Displacement too large for a short jmp at %s:%d\", file, line);\n@@ -2471,1 +2471,1 @@\n-    intptr_t offs = (intptr_t)entry - (intptr_t)pc();\n+    int offs = checked_cast<int>((intptr_t)entry - (intptr_t)pc());\n@@ -2495,1 +2495,1 @@\n-    intptr_t offs = entry - pc();\n+    int offs = checked_cast<int>(entry - pc());\n@@ -2534,2 +2534,2 @@\n-    intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);\n-    intptr_t delta = short_branch_delta();\n+    int dist = checked_cast<int>((intptr_t)entry - (intptr_t)(pc() + short_size));\n+    int delta = short_branch_delta();\n@@ -2539,1 +2539,1 @@\n-    assert(is8bit(dist), \"Dispacement too large for a short jmp at %s:%d\", file, line);\n+    assert(is8bit(dist), \"Displacement too large for a short jmp at %s:%d\", file, line);\n@@ -6390,1 +6390,1 @@\n-    intptr_t offset = entry - pc();\n+    int offset = checked_cast<int>(entry - pc());\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4893,1 +4893,1 @@\n-  int* pst_counter = &SharedRuntime::_partial_subtype_ctr;\n+  uint* pst_counter = &SharedRuntime::_partial_subtype_ctr;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  void inc_counter_np_(int& counter) {\n+  void inc_counter_np_(uint& counter) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-static void inc_counter_np(MacroAssembler* _masm, int& counter, Register rscratch) {\n+static void inc_counter_np(MacroAssembler* _masm, uint& counter, Register rscratch) {\n@@ -64,1 +64,1 @@\n-static int& get_profile_ctr(int shift) {\n+static uint& get_profile_ctr(int shift) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-\/\/ stubbed-out trim-native support\n+\/\/ Trim-native support, stubbed out for now, may be enabled later\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-\/\/ stubbed-out trim-native support\n+\/\/ Trim-native support, stubbed out for now, may be enabled later\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,0 +92,9 @@\n+  product(bool, DisableTHPStackMitigation, false, DIAGNOSTIC,           \\\n+          \"If THPs are unconditionally enabled on the system (mode \"    \\\n+          \"\\\"always\\\"), the JVM will prevent THP from forming in \"      \\\n+          \"thread stacks. This switch disables that mitigation and \"    \\\n+          \"allows THPs to form in thread stacks.\")                      \\\n+                                                                        \\\n+  develop(bool, DelayThreadStartALot, false,                            \\\n+          \"Artificially delay thread starts randomly for testing.\")     \\\n+                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -114,11 +114,13 @@\n-  DIR *dir = opendir(sys_hugepages);\n-\n-  struct dirent *entry;\n-  size_t pagesize;\n-  while ((entry = readdir(dir)) != nullptr) {\n-    if (entry->d_type == DT_DIR &&\n-        sscanf(entry->d_name, \"hugepages-%zukB\", &pagesize) == 1) {\n-      \/\/ The kernel is using kB, hotspot uses bytes\n-      \/\/ Add each found Large Page Size to page_sizes\n-      pagesize *= K;\n-      pagesizes.add(pagesize);\n+  DIR* dir = opendir(sys_hugepages);\n+\n+  if (dir != nullptr) {\n+    struct dirent *entry;\n+    size_t pagesize;\n+    while ((entry = readdir(dir)) != nullptr) {\n+      if (entry->d_type == DT_DIR &&\n+          sscanf(entry->d_name, \"hugepages-%zukB\", &pagesize) == 1) {\n+        \/\/ The kernel is using kB, hotspot uses bytes\n+        \/\/ Add each found Large Page Size to page_sizes\n+        pagesize *= K;\n+        pagesizes.add(pagesize);\n+      }\n@@ -126,0 +128,1 @@\n+    closedir(dir);\n@@ -127,1 +130,0 @@\n-  closedir(dir);\n@@ -145,1 +147,0 @@\n-  _pagesizes = scan_hugepages();\n@@ -147,3 +148,6 @@\n-  assert(_pagesizes.contains(_default_hugepage_size),\n-         \"Unexpected configuration: default pagesize (\" SIZE_FORMAT \") \"\n-         \"has no associated directory in \/sys\/kernel\/mm\/hugepages..\", _default_hugepage_size);\n+  if (_default_hugepage_size > 0) {\n+    _pagesizes = scan_hugepages();\n+    assert(_pagesizes.contains(_default_hugepage_size),\n+           \"Unexpected configuration: default pagesize (\" SIZE_FORMAT \") \"\n+           \"has no associated directory in \/sys\/kernel\/mm\/hugepages..\", _default_hugepage_size);\n+  }\n","filename":"src\/hotspot\/os\/linux\/hugepages.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -778,0 +778,4 @@\n+  if (DelayThreadStartALot) {\n+    os::naked_short_sleep(100);\n+  }\n+\n@@ -914,0 +918,1 @@\n+\n@@ -934,7 +939,10 @@\n-  \/\/ Add an additional page to the stack size to reduce its chances of getting large page aligned\n-  \/\/ so that the stack does not get backed by a transparent huge page.\n-  size_t default_large_page_size = HugePages::default_static_hugepage_size();\n-  if (default_large_page_size != 0 &&\n-      stack_size >= default_large_page_size &&\n-      is_aligned(stack_size, default_large_page_size)) {\n-    stack_size += os::vm_page_size();\n+  if (!DisableTHPStackMitigation) {\n+    \/\/ In addition to the glibc guard page that prevents inter-thread-stack hugepage\n+    \/\/ coalescing (see comment in os::Linux::default_guard_size()), we also make\n+    \/\/ sure the stack size itself is not huge-page-size aligned; that makes it much\n+    \/\/ more likely for thread stack boundaries to be unaligned as well and hence\n+    \/\/ protects thread stacks from being targeted by khugepaged.\n+    if (HugePages::thp_pagesize() > 0 &&\n+        is_aligned(stack_size, HugePages::thp_pagesize())) {\n+      stack_size += os::vm_page_size();\n+    }\n@@ -3080,0 +3088,21 @@\n+\n+  if (!DisableTHPStackMitigation) {\n+    \/\/ If THPs are unconditionally enabled, the following scenario can lead to huge RSS\n+    \/\/ - parent thread spawns, in quick succession, multiple child threads\n+    \/\/ - child threads are slow to start\n+    \/\/ - thread stacks of future child threads are adjacent and get merged into one large VMA\n+    \/\/   by the kernel, and subsequently transformed into huge pages by khugepaged\n+    \/\/ - child threads come up, place JVM guard pages, thus splinter the large VMA, splinter\n+    \/\/   the huge pages into many (still paged-in) small pages.\n+    \/\/ The result of that sequence are thread stacks that are fully paged-in even though the\n+    \/\/ threads did not even start yet.\n+    \/\/ We prevent that by letting the glibc allocate a guard page, which causes a VMA with different\n+    \/\/ permission bits to separate two ajacent thread stacks and therefore prevent merging stacks\n+    \/\/ into one VMA.\n+    \/\/\n+    \/\/ Yes, this means we have two guard sections - the glibc and the JVM one - per thread. But the\n+    \/\/ cost for that one extra protected page is dwarfed from a large win in performance and memory\n+    \/\/ that avoiding interference by khugepaged buys us.\n+    return os::vm_page_size();\n+  }\n+\n@@ -3743,0 +3772,15 @@\n+  \/\/ If THPs are unconditionally enabled (THP mode \"always\"), khugepaged may attempt to\n+  \/\/ coalesce small pages in thread stacks to huge pages. That costs a lot of memory and\n+  \/\/ is usually unwanted for thread stacks. Therefore we attempt to prevent THP formation in\n+  \/\/ thread stacks unless the user explicitly allowed THP formation by manually disabling\n+  \/\/ -XX:+DisableTHPStackMitigation.\n+  if (HugePages::thp_mode() == THPMode::always) {\n+    if (DisableTHPStackMitigation) {\n+      log_info(pagesize)(\"JVM will *not* prevent THPs in thread stacks. This may cause high RSS.\");\n+    } else {\n+      log_info(pagesize)(\"JVM will attempt to prevent THPs in thread stacks.\");\n+    }\n+  } else {\n+    FLAG_SET_ERGO(DisableTHPStackMitigation, true); \/\/ Mitigation not needed\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":51,"deletions":7,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-\/\/ stubbed-out trim-native support\n+\/\/ Trim-native support, stubbed out for now, may be enabled later\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -293,0 +293,14 @@\n+  \/\/ sign-extended tolerant cast needed by callers of emit_int8 and emit_int16\n+  \/\/ Some callers pass signed types that need to fit into the unsigned type so check\n+  \/\/ that the range is correct.\n+  template <typename T>\n+  constexpr T narrow_cast(int x) const {\n+    if (x < 0) {\n+      using stype = std::make_signed_t<T>;\n+      assert(x >= std::numeric_limits<stype>::min(), \"too negative\"); \/\/ >= -128 for 8 bits\n+      return static_cast<T>(x);  \/\/ cut off sign bits\n+    } else {\n+      return checked_cast<T>(x);\n+    }\n+  }\n+\n@@ -301,1 +315,3 @@\n-  void emit_int8(   uint8_t x1)                                     { code_section()->emit_int8(x1); }\n+  void emit_int8(       int x1)                                     { code_section()->emit_int8(narrow_cast<uint8_t>(x1)); }\n+\n+  void emit_int16(       int x)                                     { code_section()->emit_int16(narrow_cast<uint16_t>(x)); }\n@@ -303,2 +319,2 @@\n-  void emit_int16(  uint16_t x)                                     { code_section()->emit_int16(x); }\n-  void emit_int16(  uint8_t x1, uint8_t x2)                         { code_section()->emit_int16(x1, x2); }\n+  void emit_int16(      int x1,     int x2)                         { code_section()->emit_int16(narrow_cast<uint8_t>(x1),\n+                                                                                                 narrow_cast<uint8_t>(x2)); }\n@@ -306,1 +322,3 @@\n-  void emit_int24(  uint8_t x1, uint8_t x2, uint8_t x3)             { code_section()->emit_int24(x1, x2, x3); }\n+  void emit_int24(      int x1,     int x2,     int x3)             { code_section()->emit_int24(narrow_cast<uint8_t>(x1),\n+                                                                                                 narrow_cast<uint8_t>(x2),\n+                                                                                                 narrow_cast<uint8_t>(x3)); }\n@@ -309,1 +327,4 @@\n-  void emit_int32(  uint8_t x1, uint8_t x2, uint8_t x3, uint8_t x4) { code_section()->emit_int32(x1, x2, x3, x4); }\n+  void emit_int32(      int x1,     int x2,     int x3,     int x4) { code_section()->emit_int32(narrow_cast<uint8_t>(x1),\n+                                                                                                 narrow_cast<uint8_t>(x2),\n+                                                                                                 narrow_cast<uint8_t>(x3),\n+                                                                                                 narrow_cast<uint8_t>(x4)); }\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-} TimerName;\n+} TimerId;\n@@ -76,1 +76,1 @@\n-static int totalInstructionNodes = 0;\n+static uint totalInstructionNodes = 0;\n@@ -81,1 +81,2 @@\n-  TimerName _timer;\n+  TimerId _timer_id;\n+  bool _dolog;\n@@ -84,3 +85,3 @@\n-  PhaseTraceTime(TimerName timer)\n-  : TraceTime(\"\", &timers[timer], CITime || CITimeEach, Verbose),\n-    _log(nullptr), _timer(timer)\n+  PhaseTraceTime(TimerId timer_id)\n+  : TraceTime(timer_name[timer_id], &timers[timer_id], CITime, CITimeVerbose),\n+    _log(nullptr), _timer_id(timer_id), _dolog(CITimeVerbose)\n@@ -88,1 +89,2 @@\n-    if (Compilation::current() != nullptr) {\n+    if (_dolog) {\n+      assert(Compilation::current() != nullptr, \"sanity check\");\n@@ -93,1 +95,1 @@\n-      _log->begin_head(\"phase name='%s'\", timer_name[_timer]);\n+      _log->begin_head(\"phase name='%s'\", timer_name[_timer_id]);\n@@ -101,1 +103,1 @@\n-      _log->done(\"phase name='%s'\", timer_name[_timer]);\n+      _log->done(\"phase name='%s'\", timer_name[_timer_id]);\n@@ -591,1 +593,0 @@\n-  PhaseTraceTime timeit(_t_compile);\n@@ -596,0 +597,1 @@\n+  PhaseTraceTime timeit(_t_compile);\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-              const int m = (1 << (BitsPerInt - s0c)) - 1;\n+              const int m = checked_cast<int>(right_n_bits(BitsPerInt - s0c));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,31 +121,31 @@\n-int Runtime1::_generic_arraycopystub_cnt = 0;\n-int Runtime1::_arraycopy_slowcase_cnt = 0;\n-int Runtime1::_arraycopy_checkcast_cnt = 0;\n-int Runtime1::_arraycopy_checkcast_attempt_cnt = 0;\n-int Runtime1::_new_type_array_slowcase_cnt = 0;\n-int Runtime1::_new_object_array_slowcase_cnt = 0;\n-int Runtime1::_new_flat_array_slowcase_cnt = 0;\n-int Runtime1::_new_instance_slowcase_cnt = 0;\n-int Runtime1::_new_multi_array_slowcase_cnt = 0;\n-int Runtime1::_load_flattened_array_slowcase_cnt = 0;\n-int Runtime1::_store_flattened_array_slowcase_cnt = 0;\n-int Runtime1::_substitutability_check_slowcase_cnt = 0;\n-int Runtime1::_buffer_inline_args_slowcase_cnt = 0;\n-int Runtime1::_buffer_inline_args_no_receiver_slowcase_cnt = 0;\n-int Runtime1::_monitorenter_slowcase_cnt = 0;\n-int Runtime1::_monitorexit_slowcase_cnt = 0;\n-int Runtime1::_patch_code_slowcase_cnt = 0;\n-int Runtime1::_throw_range_check_exception_count = 0;\n-int Runtime1::_throw_index_exception_count = 0;\n-int Runtime1::_throw_div0_exception_count = 0;\n-int Runtime1::_throw_null_pointer_exception_count = 0;\n-int Runtime1::_throw_class_cast_exception_count = 0;\n-int Runtime1::_throw_incompatible_class_change_error_count = 0;\n-int Runtime1::_throw_illegal_monitor_state_exception_count = 0;\n-int Runtime1::_throw_count = 0;\n-\n-static int _byte_arraycopy_stub_cnt = 0;\n-static int _short_arraycopy_stub_cnt = 0;\n-static int _int_arraycopy_stub_cnt = 0;\n-static int _long_arraycopy_stub_cnt = 0;\n-static int _oop_arraycopy_stub_cnt = 0;\n+uint Runtime1::_generic_arraycopystub_cnt = 0;\n+uint Runtime1::_arraycopy_slowcase_cnt = 0;\n+uint Runtime1::_arraycopy_checkcast_cnt = 0;\n+uint Runtime1::_arraycopy_checkcast_attempt_cnt = 0;\n+uint Runtime1::_new_type_array_slowcase_cnt = 0;\n+uint Runtime1::_new_object_array_slowcase_cnt = 0;\n+uint Runtime1::_new_flat_array_slowcase_cnt = 0;\n+uint Runtime1::_new_instance_slowcase_cnt = 0;\n+uint Runtime1::_new_multi_array_slowcase_cnt = 0;\n+uint Runtime1::_load_flattened_array_slowcase_cnt = 0;\n+uint Runtime1::_store_flattened_array_slowcase_cnt = 0;\n+uint Runtime1::_substitutability_check_slowcase_cnt = 0;\n+uint Runtime1::_buffer_inline_args_slowcase_cnt = 0;\n+uint Runtime1::_buffer_inline_args_no_receiver_slowcase_cnt = 0;\n+uint Runtime1::_monitorenter_slowcase_cnt = 0;\n+uint Runtime1::_monitorexit_slowcase_cnt = 0;\n+uint Runtime1::_patch_code_slowcase_cnt = 0;\n+uint Runtime1::_throw_range_check_exception_count = 0;\n+uint Runtime1::_throw_index_exception_count = 0;\n+uint Runtime1::_throw_div0_exception_count = 0;\n+uint Runtime1::_throw_null_pointer_exception_count = 0;\n+uint Runtime1::_throw_class_cast_exception_count = 0;\n+uint Runtime1::_throw_incompatible_class_change_error_count = 0;\n+uint Runtime1::_throw_illegal_monitor_state_exception_count = 0;\n+uint Runtime1::_throw_count = 0;\n+\n+static uint _byte_arraycopy_stub_cnt = 0;\n+static uint _short_arraycopy_stub_cnt = 0;\n+static uint _int_arraycopy_stub_cnt = 0;\n+static uint _long_arraycopy_stub_cnt = 0;\n+static uint _oop_arraycopy_stub_cnt = 0;\n@@ -1662,38 +1662,38 @@\n-  tty->print_cr(\" _resolve_invoke_virtual_cnt:     %d\", SharedRuntime::_resolve_virtual_ctr);\n-  tty->print_cr(\" _resolve_invoke_opt_virtual_cnt: %d\", SharedRuntime::_resolve_opt_virtual_ctr);\n-  tty->print_cr(\" _resolve_invoke_static_cnt:      %d\", SharedRuntime::_resolve_static_ctr);\n-  tty->print_cr(\" _handle_wrong_method_cnt:        %d\", SharedRuntime::_wrong_method_ctr);\n-  tty->print_cr(\" _ic_miss_cnt:                    %d\", SharedRuntime::_ic_miss_ctr);\n-  tty->print_cr(\" _generic_arraycopystub_cnt:      %d\", _generic_arraycopystub_cnt);\n-  tty->print_cr(\" _byte_arraycopy_cnt:             %d\", _byte_arraycopy_stub_cnt);\n-  tty->print_cr(\" _short_arraycopy_cnt:            %d\", _short_arraycopy_stub_cnt);\n-  tty->print_cr(\" _int_arraycopy_cnt:              %d\", _int_arraycopy_stub_cnt);\n-  tty->print_cr(\" _long_arraycopy_cnt:             %d\", _long_arraycopy_stub_cnt);\n-  tty->print_cr(\" _oop_arraycopy_cnt:              %d\", _oop_arraycopy_stub_cnt);\n-  tty->print_cr(\" _arraycopy_slowcase_cnt:         %d\", _arraycopy_slowcase_cnt);\n-  tty->print_cr(\" _arraycopy_checkcast_cnt:        %d\", _arraycopy_checkcast_cnt);\n-  tty->print_cr(\" _arraycopy_checkcast_attempt_cnt:%d\", _arraycopy_checkcast_attempt_cnt);\n-\n-  tty->print_cr(\" _new_type_array_slowcase_cnt:    %d\", _new_type_array_slowcase_cnt);\n-  tty->print_cr(\" _new_object_array_slowcase_cnt:  %d\", _new_object_array_slowcase_cnt);\n-  tty->print_cr(\" _new_flat_array_slowcase_cnt:    %d\", _new_flat_array_slowcase_cnt);\n-  tty->print_cr(\" _new_instance_slowcase_cnt:      %d\", _new_instance_slowcase_cnt);\n-  tty->print_cr(\" _new_multi_array_slowcase_cnt:   %d\", _new_multi_array_slowcase_cnt);\n-  tty->print_cr(\" _load_flattened_array_slowcase_cnt:   %d\", _load_flattened_array_slowcase_cnt);\n-  tty->print_cr(\" _store_flattened_array_slowcase_cnt:  %d\", _store_flattened_array_slowcase_cnt);\n-  tty->print_cr(\" _substitutability_check_slowcase_cnt: %d\", _substitutability_check_slowcase_cnt);\n-  tty->print_cr(\" _buffer_inline_args_slowcase_cnt:%d\", _buffer_inline_args_slowcase_cnt);\n-  tty->print_cr(\" _buffer_inline_args_no_receiver_slowcase_cnt:%d\", _buffer_inline_args_no_receiver_slowcase_cnt);\n-\n-  tty->print_cr(\" _monitorenter_slowcase_cnt:      %d\", _monitorenter_slowcase_cnt);\n-  tty->print_cr(\" _monitorexit_slowcase_cnt:       %d\", _monitorexit_slowcase_cnt);\n-  tty->print_cr(\" _patch_code_slowcase_cnt:        %d\", _patch_code_slowcase_cnt);\n-\n-  tty->print_cr(\" _throw_range_check_exception_count:            %d:\", _throw_range_check_exception_count);\n-  tty->print_cr(\" _throw_index_exception_count:                  %d:\", _throw_index_exception_count);\n-  tty->print_cr(\" _throw_div0_exception_count:                   %d:\", _throw_div0_exception_count);\n-  tty->print_cr(\" _throw_null_pointer_exception_count:           %d:\", _throw_null_pointer_exception_count);\n-  tty->print_cr(\" _throw_class_cast_exception_count:             %d:\", _throw_class_cast_exception_count);\n-  tty->print_cr(\" _throw_incompatible_class_change_error_count:  %d:\", _throw_incompatible_class_change_error_count);\n-  tty->print_cr(\" _throw_illegal_monitor_state_exception_count:  %d:\", _throw_illegal_monitor_state_exception_count);\n-  tty->print_cr(\" _throw_count:                                  %d:\", _throw_count);\n+  tty->print_cr(\" _resolve_invoke_virtual_cnt:     %u\", SharedRuntime::_resolve_virtual_ctr);\n+  tty->print_cr(\" _resolve_invoke_opt_virtual_cnt: %u\", SharedRuntime::_resolve_opt_virtual_ctr);\n+  tty->print_cr(\" _resolve_invoke_static_cnt:      %u\", SharedRuntime::_resolve_static_ctr);\n+  tty->print_cr(\" _handle_wrong_method_cnt:        %u\", SharedRuntime::_wrong_method_ctr);\n+  tty->print_cr(\" _ic_miss_cnt:                    %u\", SharedRuntime::_ic_miss_ctr);\n+  tty->print_cr(\" _generic_arraycopystub_cnt:      %u\", _generic_arraycopystub_cnt);\n+  tty->print_cr(\" _byte_arraycopy_cnt:             %u\", _byte_arraycopy_stub_cnt);\n+  tty->print_cr(\" _short_arraycopy_cnt:            %u\", _short_arraycopy_stub_cnt);\n+  tty->print_cr(\" _int_arraycopy_cnt:              %u\", _int_arraycopy_stub_cnt);\n+  tty->print_cr(\" _long_arraycopy_cnt:             %u\", _long_arraycopy_stub_cnt);\n+  tty->print_cr(\" _oop_arraycopy_cnt:              %u\", _oop_arraycopy_stub_cnt);\n+  tty->print_cr(\" _arraycopy_slowcase_cnt:         %u\", _arraycopy_slowcase_cnt);\n+  tty->print_cr(\" _arraycopy_checkcast_cnt:        %u\", _arraycopy_checkcast_cnt);\n+  tty->print_cr(\" _arraycopy_checkcast_attempt_cnt:%u\", _arraycopy_checkcast_attempt_cnt);\n+\n+  tty->print_cr(\" _new_type_array_slowcase_cnt:    %u\", _new_type_array_slowcase_cnt);\n+  tty->print_cr(\" _new_object_array_slowcase_cnt:  %u\", _new_object_array_slowcase_cnt);\n+  tty->print_cr(\" _new_flat_array_slowcase_cnt:    %u\", _new_flat_array_slowcase_cnt);\n+  tty->print_cr(\" _new_instance_slowcase_cnt:      %u\", _new_instance_slowcase_cnt);\n+  tty->print_cr(\" _new_multi_array_slowcase_cnt:   %u\", _new_multi_array_slowcase_cnt);\n+  tty->print_cr(\" _load_flattened_array_slowcase_cnt:   %u\", _load_flattened_array_slowcase_cnt);\n+  tty->print_cr(\" _store_flattened_array_slowcase_cnt:  %u\", _store_flattened_array_slowcase_cnt);\n+  tty->print_cr(\" _substitutability_check_slowcase_cnt: %u\", _substitutability_check_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_slowcase_cnt:%u\", _buffer_inline_args_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_no_receiver_slowcase_cnt:%u\", _buffer_inline_args_no_receiver_slowcase_cnt);\n+\n+  tty->print_cr(\" _monitorenter_slowcase_cnt:      %u\", _monitorenter_slowcase_cnt);\n+  tty->print_cr(\" _monitorexit_slowcase_cnt:       %u\", _monitorexit_slowcase_cnt);\n+  tty->print_cr(\" _patch_code_slowcase_cnt:        %u\", _patch_code_slowcase_cnt);\n+\n+  tty->print_cr(\" _throw_range_check_exception_count:            %u:\", _throw_range_check_exception_count);\n+  tty->print_cr(\" _throw_index_exception_count:                  %u:\", _throw_index_exception_count);\n+  tty->print_cr(\" _throw_div0_exception_count:                   %u:\", _throw_div0_exception_count);\n+  tty->print_cr(\" _throw_null_pointer_exception_count:           %u:\", _throw_null_pointer_exception_count);\n+  tty->print_cr(\" _throw_class_cast_exception_count:             %u:\", _throw_class_cast_exception_count);\n+  tty->print_cr(\" _throw_incompatible_class_change_error_count:  %u:\", _throw_incompatible_class_change_error_count);\n+  tty->print_cr(\" _throw_illegal_monitor_state_exception_count:  %u:\", _throw_illegal_monitor_state_exception_count);\n+  tty->print_cr(\" _throw_count:                                  %u:\", _throw_count);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -105,25 +105,25 @@\n-  static int _generic_arraycopystub_cnt;\n-  static int _arraycopy_slowcase_cnt;\n-  static int _arraycopy_checkcast_cnt;\n-  static int _arraycopy_checkcast_attempt_cnt;\n-  static int _new_type_array_slowcase_cnt;\n-  static int _new_object_array_slowcase_cnt;\n-  static int _new_flat_array_slowcase_cnt;\n-  static int _new_instance_slowcase_cnt;\n-  static int _new_multi_array_slowcase_cnt;\n-  static int _load_flattened_array_slowcase_cnt;\n-  static int _store_flattened_array_slowcase_cnt;\n-  static int _substitutability_check_slowcase_cnt;\n-  static int _buffer_inline_args_slowcase_cnt;\n-  static int _buffer_inline_args_no_receiver_slowcase_cnt;\n-  static int _monitorenter_slowcase_cnt;\n-  static int _monitorexit_slowcase_cnt;\n-  static int _patch_code_slowcase_cnt;\n-  static int _throw_range_check_exception_count;\n-  static int _throw_index_exception_count;\n-  static int _throw_div0_exception_count;\n-  static int _throw_null_pointer_exception_count;\n-  static int _throw_class_cast_exception_count;\n-  static int _throw_incompatible_class_change_error_count;\n-  static int _throw_illegal_monitor_state_exception_count;\n-  static int _throw_count;\n+  static uint _generic_arraycopystub_cnt;\n+  static uint _arraycopy_slowcase_cnt;\n+  static uint _arraycopy_checkcast_cnt;\n+  static uint _arraycopy_checkcast_attempt_cnt;\n+  static uint _new_type_array_slowcase_cnt;\n+  static uint _new_object_array_slowcase_cnt;\n+  static uint _new_flat_array_slowcase_cnt;\n+  static uint _new_instance_slowcase_cnt;\n+  static uint _new_multi_array_slowcase_cnt;\n+  static uint _load_flattened_array_slowcase_cnt;\n+  static uint _store_flattened_array_slowcase_cnt;\n+  static uint _substitutability_check_slowcase_cnt;\n+  static uint _buffer_inline_args_slowcase_cnt;\n+  static uint _buffer_inline_args_no_receiver_slowcase_cnt;\n+  static uint _monitorenter_slowcase_cnt;\n+  static uint _monitorexit_slowcase_cnt;\n+  static uint _patch_code_slowcase_cnt;\n+  static uint _throw_range_check_exception_count;\n+  static uint _throw_index_exception_count;\n+  static uint _throw_div0_exception_count;\n+  static uint _throw_null_pointer_exception_count;\n+  static uint _throw_class_cast_exception_count;\n+  static uint _throw_incompatible_class_change_error_count;\n+  static uint _throw_illegal_monitor_state_exception_count;\n+  static uint _throw_count;\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -50,0 +51,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -968,1 +970,1 @@\n-      log_data(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n+      log_as_hex(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n@@ -1010,1 +1012,1 @@\n-    log_data(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n+    log_as_hex(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n@@ -1015,1 +1017,1 @@\n-      log_data(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n+      log_as_hex(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n@@ -1041,1 +1043,3 @@\n-    log_region(\"heap\", start, end, to_requested(start));\n+    log_region(\"heap\", start, end, ArchiveHeapWriter::buffered_addr_to_requested_addr(start));\n+\n+    LogStreamHandle(Info, cds, map) st;\n@@ -1045,6 +1049,8 @@\n-      oop original_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-      if (original_oop != nullptr) {\n-        ResourceMark rm;\n-        log_info(cds, map)(PTR_FORMAT \": @@ Object %s\",\n-                           p2i(to_requested(start)), original_oop->klass()->external_name());\n-        byte_size = original_oop->size() * BytesPerWord;\n+      oop source_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n+      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n+      st.print(PTR_FORMAT \": @@ Object \", p2i(requested_start));\n+\n+      if (source_oop != nullptr) {\n+        \/\/ This is a regular oop that got archived.\n+        print_oop_with_requested_addr_cr(&st, source_oop, false);\n+        byte_size = source_oop->size() * BytesPerWord;\n@@ -1052,4 +1058,4 @@\n-        \/\/ HeapShared::roots() is copied specially so it doesn't exist in\n-        \/\/ HeapShared::OriginalObjectTable. See HeapShared::copy_roots().\n-        log_info(cds, map)(PTR_FORMAT \": @@ Object HeapShared::roots (ObjArray)\",\n-                           p2i(to_requested(start)));\n+        \/\/ HeapShared::roots() is copied specially, so it doesn't exist in\n+        \/\/ ArchiveHeapWriter::BufferOffsetToSourceObjectTable.\n+        \/\/ See ArchiveHeapWriter::copy_roots_to_buffer().\n+        st.print_cr(\"HeapShared::roots[%d]\", HeapShared::pending_roots()->length());\n@@ -1057,0 +1063,3 @@\n+      } else if ((byte_size = ArchiveHeapWriter::get_filler_size_at(start)) > 0) {\n+        \/\/ We have a filler oop, which also does not exist in BufferOffsetToSourceObjectTable.\n+        st.print_cr(\"filler \" SIZE_FORMAT \" bytes\", byte_size);\n@@ -1058,6 +1067,1 @@\n-        \/\/ We have reached the end of the region, but have some unused space\n-        \/\/ at the end.\n-        log_info(cds, map)(PTR_FORMAT \": @@ Unused heap space \" SIZE_FORMAT \" bytes\",\n-                           p2i(to_requested(start)), size_t(end - start));\n-        log_data(start, end, to_requested(start), \/*is_heap=*\/true);\n-        break;\n+        ShouldNotReachHere();\n@@ -1065,0 +1069,1 @@\n+\n@@ -1066,1 +1071,7 @@\n-      log_data(start, oop_end, to_requested(start), \/*is_heap=*\/true);\n+      log_as_hex(start, oop_end, requested_start, \/*is_heap=*\/true);\n+\n+      if (source_oop != nullptr) {\n+        log_oop_details(heap_info, source_oop);\n+      } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n+        log_heap_roots();\n+      }\n@@ -1071,2 +1082,91 @@\n-  static address to_requested(address p) {\n-    return ArchiveHeapWriter::buffered_addr_to_requested_addr(p);\n+  \/\/ ArchivedFieldPrinter is used to print the fields of archived objects. We can't\n+  \/\/ use _source_obj->print_on(), because we want to print the oop fields\n+  \/\/ in _source_obj with their requested addresses using print_oop_with_requested_addr_cr().\n+  class ArchivedFieldPrinter : public FieldClosure {\n+    ArchiveHeapInfo* _heap_info;\n+    outputStream* _st;\n+    oop _source_obj;\n+  public:\n+    ArchivedFieldPrinter(ArchiveHeapInfo* heap_info, outputStream* st, oop src_obj) :\n+      _heap_info(heap_info), _st(st), _source_obj(src_obj) {}\n+\n+    void do_field(fieldDescriptor* fd) {\n+      _st->print(\" - \");\n+      BasicType ft = fd->field_type();\n+      switch (ft) {\n+      case T_ARRAY:\n+      case T_OBJECT:\n+        fd->print_on(_st); \/\/ print just the name and offset\n+        print_oop_with_requested_addr_cr(_st, _source_obj->obj_field(fd->offset()));\n+        break;\n+      default:\n+        if (ArchiveHeapWriter::is_marked_as_native_pointer(_heap_info, _source_obj, fd->offset())) {\n+          print_as_native_pointer(fd);\n+        } else {\n+          fd->print_on_for(_st, _source_obj); \/\/ name, offset, value\n+          _st->cr();\n+        }\n+      }\n+    }\n+\n+    void print_as_native_pointer(fieldDescriptor* fd) {\n+      LP64_ONLY(assert(fd->field_type() == T_LONG, \"must be\"));\n+      NOT_LP64 (assert(fd->field_type() == T_INT,  \"must be\"));\n+\n+      \/\/ We have a field that looks like an integer, but it's actually a pointer to a MetaspaceObj.\n+      address source_native_ptr = (address)\n+          LP64_ONLY(_source_obj->long_field(fd->offset()))\n+          NOT_LP64( _source_obj->int_field (fd->offset()));\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+\n+      \/\/ The value of the native pointer at runtime.\n+      address requested_native_ptr = builder->to_requested(builder->get_buffered_addr(source_native_ptr));\n+\n+      \/\/ The address of _source_obj at runtime\n+      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(_source_obj);\n+      \/\/ The address of this field in the requested space\n+      address requested_field_addr = cast_from_oop<address>(requested_obj) + fd->offset();\n+\n+      fd->print_on(_st);\n+      _st->print_cr(PTR_FORMAT \" (marked metadata pointer @\" PTR_FORMAT \" )\",\n+                    p2i(requested_native_ptr), p2i(requested_field_addr));\n+    }\n+  };\n+\n+  \/\/ Print the fields of instanceOops, or the elements of arrayOops\n+  static void log_oop_details(ArchiveHeapInfo* heap_info, oop source_oop) {\n+    LogStreamHandle(Trace, cds, map, oops) st;\n+    if (st.is_enabled()) {\n+      Klass* source_klass = source_oop->klass();\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      Klass* requested_klass = builder->to_requested(builder->get_buffered_addr(source_klass));\n+\n+      st.print(\" - klass: \");\n+      source_klass->print_value_on(&st);\n+      st.print(\" \" PTR_FORMAT, p2i(requested_klass));\n+      st.cr();\n+\n+      if (source_oop->is_typeArray()) {\n+        TypeArrayKlass::cast(source_klass)->oop_print_elements_on(typeArrayOop(source_oop), &st);\n+      } else if (source_oop->is_objArray()) {\n+        objArrayOop source_obj_array = objArrayOop(source_oop);\n+        for (int i = 0; i < source_obj_array->length(); i++) {\n+          st.print(\" -%4d: \", i);\n+          print_oop_with_requested_addr_cr(&st, source_obj_array->obj_at(i));\n+        }\n+      } else {\n+        st.print_cr(\" - fields (\" SIZE_FORMAT \" words):\", source_oop->size());\n+        ArchivedFieldPrinter print_field(heap_info, &st, source_oop);\n+        InstanceKlass::cast(source_klass)->print_nonstatic_fields(&print_field);\n+      }\n+    }\n+  }\n+\n+  static void log_heap_roots() {\n+    LogStreamHandle(Trace, cds, map, oops) st;\n+    if (st.is_enabled()) {\n+      for (int i = 0; i < HeapShared::pending_roots()->length(); i++) {\n+        st.print(\"roots[%4d]: \", i);\n+        print_oop_with_requested_addr_cr(&st, HeapShared::pending_roots()->at(i));\n+      }\n+    }\n@@ -1074,1 +1174,26 @@\n-#endif\n+\n+  \/\/ The output looks like this. The first number is the requested address. The second number is\n+  \/\/ the narrowOop version of the requested address.\n+  \/\/     0x00000007ffc7e840 (0xfff8fd08) java.lang.Class\n+  \/\/     0x00000007ffc000f8 (0xfff8001f) [B length: 11\n+  static void print_oop_with_requested_addr_cr(outputStream* st, oop source_oop, bool print_addr = true) {\n+    if (source_oop == nullptr) {\n+      st->print_cr(\"null\");\n+    } else {\n+      ResourceMark rm;\n+      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(source_oop);\n+      if (print_addr) {\n+        st->print(PTR_FORMAT \" \", p2i(requested_obj));\n+      }\n+      if (UseCompressedOops) {\n+        st->print(\"(0x%08x) \", CompressedOops::narrow_oop_value(requested_obj));\n+      }\n+      if (source_oop->is_array()) {\n+        int array_len = arrayOop(source_oop)->length();\n+        st->print_cr(\"%s length: %d\", source_oop->klass()->external_name(), array_len);\n+      } else {\n+        st->print_cr(\"%s\", source_oop->klass()->external_name());\n+      }\n+    }\n+  }\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n@@ -1078,1 +1203,1 @@\n-  static void log_data(address base, address top, address requested_base, bool is_heap = false) {\n+  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false) {\n@@ -1110,1 +1235,1 @@\n-    log_data(header, header_end, 0);\n+    log_as_hex(header, header_end, 0);\n@@ -1120,1 +1245,1 @@\n-    log_data((address)bitmap, bitmap_end, 0);\n+    log_as_hex((address)bitmap, bitmap_end, 0);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":152,"deletions":27,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -67,0 +67,7 @@\n+\n+typedef ResourceHashtable<address, size_t,\n+      127, \/\/ prime number\n+      AnyObj::C_HEAP,\n+      mtClassShared> FillersTable;\n+static FillersTable* _fillers;\n+\n@@ -72,1 +79,1 @@\n-\n+    _fillers = new FillersTable();\n@@ -258,1 +265,1 @@\n-void ArchiveHeapWriter::init_filler_array_at_buffer_top(int array_length, size_t fill_bytes) {\n+HeapWord* ArchiveHeapWriter::init_filler_array_at_buffer_top(int array_length, size_t fill_bytes) {\n@@ -267,0 +274,1 @@\n+  return mem;\n@@ -296,2 +304,1 @@\n-    init_filler_array_at_buffer_top(array_length, fill_bytes);\n-\n+    HeapWord* filler = init_filler_array_at_buffer_top(array_length, fill_bytes);\n@@ -299,0 +306,11 @@\n+    _fillers->put((address)filler, fill_bytes);\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::get_filler_size_at(address buffered_addr) {\n+  size_t* p = _fillers->get(buffered_addr);\n+  if (p != nullptr) {\n+    assert(*p > 0, \"filler must be larger than zero bytes\");\n+    return *p;\n+  } else {\n+    return 0; \/\/ buffered_addr is not a filler\n@@ -517,0 +535,14 @@\n+\/\/ Do we have a jlong\/jint field that's actually a pointer to a MetaspaceObj?\n+bool ArchiveHeapWriter::is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset) {\n+  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n+  assert(p != nullptr, \"must be\");\n+\n+  \/\/ requested_field_addr = the address of this field in the requested space\n+  oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n+  Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n+  assert((Metadata**)_requested_bottom <= requested_field_addr && requested_field_addr < (Metadata**) _requested_top, \"range check\");\n+\n+  BitMap::idx_t idx = requested_field_addr - (Metadata**) _requested_bottom;\n+  return (idx < heap_info->ptrmap()->size()) && (heap_info->ptrmap()->at(idx) == true);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  static void init_filler_array_at_buffer_top(int array_length, size_t fill_bytes);\n+  static HeapWord* init_filler_array_at_buffer_top(int array_length, size_t fill_bytes);\n@@ -228,0 +228,1 @@\n+  static size_t get_filler_size_at(address buffered_addr);\n@@ -230,0 +231,1 @@\n+  static bool is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -384,0 +384,1 @@\n+  static GrowableArrayCHeap<oop, mtClassShared>* pending_roots() { return _pending_roots; }\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2843,1 +2843,0 @@\n-  Symbol* message = java_lang_Throwable::detail_message(throwable());\n@@ -2845,0 +2844,5 @@\n+  const char *message = nullptr;\n+  oop detailed_message = java_lang_Throwable::message(throwable());\n+  if (detailed_message != nullptr) {\n+    message = java_lang_String::as_utf8_string(detailed_message);\n+  }\n@@ -2851,1 +2855,1 @@\n-    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), current->name());\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message, current->name());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -459,0 +460,1 @@\n+  NativeHeapTrimmer::SuspendMark sm(\"stringtable\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -340,0 +341,1 @@\n+  assert(len <= Symbol::max_length(), \"sanity\");\n@@ -355,0 +357,1 @@\n+  assert(len <= Symbol::max_length(), \"sanity\");\n@@ -740,0 +743,1 @@\n+  NativeHeapTrimmer::SuspendMark sm(\"symboltable\");\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1123,1 +1123,1 @@\n-                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                           \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-static int find_sid_calls, find_sid_probes;\n+static uint find_sid_calls, find_sid_probes;\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,11 +122,11 @@\n-  int nmethod_count;\n-  int total_size;\n-  int relocation_size;\n-  int consts_size;\n-  int insts_size;\n-  int stub_size;\n-  int scopes_data_size;\n-  int scopes_pcs_size;\n-  int dependencies_size;\n-  int handler_table_size;\n-  int nul_chk_table_size;\n+  uint nmethod_count;\n+  uint total_size;\n+  uint relocation_size;\n+  uint consts_size;\n+  uint insts_size;\n+  uint stub_size;\n+  uint scopes_data_size;\n+  uint scopes_pcs_size;\n+  uint dependencies_size;\n+  uint handler_table_size;\n+  uint nul_chk_table_size;\n@@ -134,2 +134,2 @@\n-  int speculations_size;\n-  int jvmci_data_size;\n+  uint speculations_size;\n+  uint jvmci_data_size;\n@@ -137,2 +137,2 @@\n-  int oops_size;\n-  int metadata_size;\n+  uint oops_size;\n+  uint metadata_size;\n@@ -161,2 +161,2 @@\n-    tty->print_cr(\"Statistics for %d bytecoded nmethods for %s:\", nmethod_count, name);\n-    if (total_size != 0)          tty->print_cr(\" total in heap  = %d\", total_size);\n+    tty->print_cr(\"Statistics for %u bytecoded nmethods for %s:\", nmethod_count, name);\n+    if (total_size != 0)          tty->print_cr(\" total in heap  = %u\", total_size);\n@@ -164,11 +164,11 @@\n-    if (relocation_size != 0)     tty->print_cr(\" relocation     = %d\", relocation_size);\n-    if (consts_size != 0)         tty->print_cr(\" constants      = %d\", consts_size);\n-    if (insts_size != 0)          tty->print_cr(\" main code      = %d\", insts_size);\n-    if (stub_size != 0)           tty->print_cr(\" stub code      = %d\", stub_size);\n-    if (oops_size != 0)           tty->print_cr(\" oops           = %d\", oops_size);\n-    if (metadata_size != 0)       tty->print_cr(\" metadata       = %d\", metadata_size);\n-    if (scopes_data_size != 0)    tty->print_cr(\" scopes data    = %d\", scopes_data_size);\n-    if (scopes_pcs_size != 0)     tty->print_cr(\" scopes pcs     = %d\", scopes_pcs_size);\n-    if (dependencies_size != 0)   tty->print_cr(\" dependencies   = %d\", dependencies_size);\n-    if (handler_table_size != 0)  tty->print_cr(\" handler table  = %d\", handler_table_size);\n-    if (nul_chk_table_size != 0)  tty->print_cr(\" nul chk table  = %d\", nul_chk_table_size);\n+    if (relocation_size != 0)     tty->print_cr(\" relocation     = %u\", relocation_size);\n+    if (consts_size != 0)         tty->print_cr(\" constants      = %u\", consts_size);\n+    if (insts_size != 0)          tty->print_cr(\" main code      = %u\", insts_size);\n+    if (stub_size != 0)           tty->print_cr(\" stub code      = %u\", stub_size);\n+    if (oops_size != 0)           tty->print_cr(\" oops           = %u\", oops_size);\n+    if (metadata_size != 0)       tty->print_cr(\" metadata       = %u\", metadata_size);\n+    if (scopes_data_size != 0)    tty->print_cr(\" scopes data    = %u\", scopes_data_size);\n+    if (scopes_pcs_size != 0)     tty->print_cr(\" scopes pcs     = %u\", scopes_pcs_size);\n+    if (dependencies_size != 0)   tty->print_cr(\" dependencies   = %u\", dependencies_size);\n+    if (handler_table_size != 0)  tty->print_cr(\" handler table  = %u\", handler_table_size);\n+    if (nul_chk_table_size != 0)  tty->print_cr(\" nul chk table  = %u\", nul_chk_table_size);\n@@ -176,2 +176,2 @@\n-    if (speculations_size != 0)   tty->print_cr(\" speculations   = %d\", speculations_size);\n-    if (jvmci_data_size != 0)     tty->print_cr(\" JVMCI data     = %d\", jvmci_data_size);\n+    if (speculations_size != 0)   tty->print_cr(\" speculations   = %u\", speculations_size);\n+    if (jvmci_data_size != 0)     tty->print_cr(\" JVMCI data     = %u\", jvmci_data_size);\n@@ -183,6 +183,6 @@\n-  int native_nmethod_count;\n-  int native_total_size;\n-  int native_relocation_size;\n-  int native_insts_size;\n-  int native_oops_size;\n-  int native_metadata_size;\n+  uint native_nmethod_count;\n+  uint native_total_size;\n+  uint native_relocation_size;\n+  uint native_insts_size;\n+  uint native_oops_size;\n+  uint native_metadata_size;\n@@ -199,6 +199,6 @@\n-    tty->print_cr(\"Statistics for %d native nmethods:\", native_nmethod_count);\n-    if (native_total_size != 0)       tty->print_cr(\" N. total size  = %d\", native_total_size);\n-    if (native_relocation_size != 0)  tty->print_cr(\" N. relocation  = %d\", native_relocation_size);\n-    if (native_insts_size != 0)       tty->print_cr(\" N. main code   = %d\", native_insts_size);\n-    if (native_oops_size != 0)        tty->print_cr(\" N. oops        = %d\", native_oops_size);\n-    if (native_metadata_size != 0)    tty->print_cr(\" N. metadata    = %d\", native_metadata_size);\n+    tty->print_cr(\"Statistics for %u native nmethods:\", native_nmethod_count);\n+    if (native_total_size != 0)       tty->print_cr(\" N. total size  = %u\", native_total_size);\n+    if (native_relocation_size != 0)  tty->print_cr(\" N. relocation  = %u\", native_relocation_size);\n+    if (native_insts_size != 0)       tty->print_cr(\" N. main code   = %u\", native_insts_size);\n+    if (native_oops_size != 0)        tty->print_cr(\" N. oops        = %u\", native_oops_size);\n+    if (native_metadata_size != 0)    tty->print_cr(\" N. metadata    = %u\", native_metadata_size);\n@@ -209,8 +209,8 @@\n-  int pc_desc_resets;   \/\/ number of resets (= number of caches)\n-  int pc_desc_queries;  \/\/ queries to nmethod::find_pc_desc\n-  int pc_desc_approx;   \/\/ number of those which have approximate true\n-  int pc_desc_repeats;  \/\/ number of _pc_descs[0] hits\n-  int pc_desc_hits;     \/\/ number of LRU cache hits\n-  int pc_desc_tests;    \/\/ total number of PcDesc examinations\n-  int pc_desc_searches; \/\/ total number of quasi-binary search steps\n-  int pc_desc_adds;     \/\/ number of LUR cache insertions\n+  uint pc_desc_resets;   \/\/ number of resets (= number of caches)\n+  uint pc_desc_queries;  \/\/ queries to nmethod::find_pc_desc\n+  uint pc_desc_approx;   \/\/ number of those which have approximate true\n+  uint pc_desc_repeats;  \/\/ number of _pc_descs[0] hits\n+  uint pc_desc_hits;     \/\/ number of LRU cache hits\n+  uint pc_desc_tests;    \/\/ total number of PcDesc examinations\n+  uint pc_desc_searches; \/\/ total number of quasi-binary search steps\n+  uint pc_desc_adds;     \/\/ number of LUR cache insertions\n@@ -219,1 +219,1 @@\n-    tty->print_cr(\"PcDesc Statistics:  %d queries, %.2f comparisons per query\",\n+    tty->print_cr(\"PcDesc Statistics:  %u queries, %.2f comparisons per query\",\n@@ -223,1 +223,1 @@\n-    tty->print_cr(\"  caches=%d queries=%d\/%d, hits=%d+%d, tests=%d+%d, adds=%d\",\n+    tty->print_cr(\"  caches=%d queries=%u\/%u, hits=%u+%u, tests=%u+%u, adds=%u\",\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    int _bytes;          \/\/ number of bytecodes compiled, including inlined bytecodes\n-    int _count;          \/\/ number of compilations\n+    uint _bytes;         \/\/ number of bytecodes compiled, including inlined bytecodes\n+    uint _count;         \/\/ number of compilations\n@@ -58,2 +58,2 @@\n-  int _nmethods_size; \/\/\n-  int _nmethods_code_size;\n+  uint _nmethods_size; \/\/\n+  uint _nmethods_code_size;\n@@ -64,1 +64,1 @@\n-    int bytes = _standard._bytes + _osr._bytes;\n+    uint bytes = _standard._bytes + _osr._bytes;\n","filename":"src\/hotspot\/share\/compiler\/abstractCompiler.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,2 +78,2 @@\n-    const int blob_len = end - begin;\n-    const int offset   = here - begin;\n+    const int blob_len = pointer_delta_as_int(end, begin);\n+    const int offset   = pointer_delta_as_int(here, begin);\n","filename":"src\/hotspot\/share\/compiler\/abstractDisassembler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,12 +177,12 @@\n-int CompileBroker::_total_bailout_count            = 0;\n-int CompileBroker::_total_invalidated_count        = 0;\n-int CompileBroker::_total_compile_count            = 0;\n-int CompileBroker::_total_osr_compile_count        = 0;\n-int CompileBroker::_total_standard_compile_count   = 0;\n-int CompileBroker::_total_compiler_stopped_count   = 0;\n-int CompileBroker::_total_compiler_restarted_count = 0;\n-\n-int CompileBroker::_sum_osr_bytes_compiled         = 0;\n-int CompileBroker::_sum_standard_bytes_compiled    = 0;\n-int CompileBroker::_sum_nmethod_size               = 0;\n-int CompileBroker::_sum_nmethod_code_size          = 0;\n+uint CompileBroker::_total_bailout_count            = 0;\n+uint CompileBroker::_total_invalidated_count        = 0;\n+uint CompileBroker::_total_compile_count            = 0;\n+uint CompileBroker::_total_osr_compile_count        = 0;\n+uint CompileBroker::_total_standard_compile_count   = 0;\n+uint CompileBroker::_total_compiler_stopped_count   = 0;\n+uint CompileBroker::_total_compiler_restarted_count = 0;\n+\n+uint CompileBroker::_sum_osr_bytes_compiled         = 0;\n+uint CompileBroker::_sum_standard_bytes_compiled    = 0;\n+uint CompileBroker::_sum_nmethod_size               = 0;\n+uint CompileBroker::_sum_nmethod_code_size          = 0;\n@@ -2117,0 +2117,9 @@\n+\/\/ Acquires Compilation_lock and waits for it to be notified\n+\/\/ as long as WhiteBox::compilation_locked is true.\n+static void whitebox_lock_compilation() {\n+  MonitorLocker locker(Compilation_lock, Mutex::_no_safepoint_check_flag);\n+  while (WhiteBox::compilation_locked) {\n+    locker.wait();\n+  }\n+}\n+\n@@ -2199,0 +2208,5 @@\n+        if (WhiteBoxAPI && WhiteBox::compilation_locked) {\n+          \/\/ Must switch to native to block\n+          ThreadToNativeFromVM ttn(thread);\n+          whitebox_lock_compilation();\n+        }\n@@ -2260,4 +2274,1 @@\n-        MonitorLocker locker(Compilation_lock, Mutex::_no_safepoint_check_flag);\n-        while (WhiteBox::compilation_locked) {\n-          locker.wait();\n-        }\n+        whitebox_lock_compilation();\n@@ -2602,1 +2613,1 @@\n-  tty->print_cr(\"  %s {speed: %6.3f bytes\/s; standard: %6.3f s, %d bytes, %d methods; osr: %6.3f s, %d bytes, %d methods; nmethods_size: %d bytes; nmethods_code_size: %d bytes}\",\n+  tty->print_cr(\"  %s {speed: %6.3f bytes\/s; standard: %6.3f s, %u bytes, %u methods; osr: %6.3f s, %u bytes, %u methods; nmethods_size: %u bytes; nmethods_code_size: %u bytes}\",\n@@ -2645,2 +2656,2 @@\n-  int standard_bytes_compiled = CompileBroker::_sum_standard_bytes_compiled;\n-  int osr_bytes_compiled = CompileBroker::_sum_osr_bytes_compiled;\n+  uint standard_bytes_compiled = CompileBroker::_sum_standard_bytes_compiled;\n+  uint osr_bytes_compiled = CompileBroker::_sum_osr_bytes_compiled;\n@@ -2648,5 +2659,5 @@\n-  int standard_compile_count = CompileBroker::_total_standard_compile_count;\n-  int osr_compile_count = CompileBroker::_total_osr_compile_count;\n-  int total_compile_count = CompileBroker::_total_compile_count;\n-  int total_bailout_count = CompileBroker::_total_bailout_count;\n-  int total_invalidated_count = CompileBroker::_total_invalidated_count;\n+  uint standard_compile_count = CompileBroker::_total_standard_compile_count;\n+  uint osr_compile_count = CompileBroker::_total_osr_compile_count;\n+  uint total_compile_count = CompileBroker::_total_compile_count;\n+  uint total_bailout_count = CompileBroker::_total_bailout_count;\n+  uint total_invalidated_count = CompileBroker::_total_invalidated_count;\n@@ -2654,2 +2665,2 @@\n-  int nmethods_size = CompileBroker::_sum_nmethod_code_size;\n-  int nmethods_code_size = CompileBroker::_sum_nmethod_size;\n+  uint nmethods_size = CompileBroker::_sum_nmethod_code_size;\n+  uint nmethods_code_size = CompileBroker::_sum_nmethod_size;\n@@ -2697,7 +2708,7 @@\n-  tty->print_cr(\"  Total compiled methods    : %8d methods\", total_compile_count);\n-  tty->print_cr(\"    Standard compilation    : %8d methods\", standard_compile_count);\n-  tty->print_cr(\"    On stack replacement    : %8d methods\", osr_compile_count);\n-  int tcb = osr_bytes_compiled + standard_bytes_compiled;\n-  tty->print_cr(\"  Total compiled bytecodes  : %8d bytes\", tcb);\n-  tty->print_cr(\"    Standard compilation    : %8d bytes\", standard_bytes_compiled);\n-  tty->print_cr(\"    On stack replacement    : %8d bytes\", osr_bytes_compiled);\n+  tty->print_cr(\"  Total compiled methods    : %8u methods\", total_compile_count);\n+  tty->print_cr(\"    Standard compilation    : %8u methods\", standard_compile_count);\n+  tty->print_cr(\"    On stack replacement    : %8u methods\", osr_compile_count);\n+  uint tcb = osr_bytes_compiled + standard_bytes_compiled;\n+  tty->print_cr(\"  Total compiled bytecodes  : %8u bytes\", tcb);\n+  tty->print_cr(\"    Standard compilation    : %8u bytes\", standard_bytes_compiled);\n+  tty->print_cr(\"    On stack replacement    : %8u bytes\", osr_bytes_compiled);\n@@ -2705,2 +2716,2 @@\n-  int bps = tcs == 0.0 ? 0 : (int)(tcb \/ tcs);\n-  tty->print_cr(\"  Average compilation speed : %8d bytes\/s\", bps);\n+  uint bps = tcs == 0.0 ? 0 : (uint)(tcb \/ tcs);\n+  tty->print_cr(\"  Average compilation speed : %8u bytes\/s\", bps);\n@@ -2708,2 +2719,2 @@\n-  tty->print_cr(\"  nmethod code size         : %8d bytes\", nmethods_code_size);\n-  tty->print_cr(\"  nmethod total size        : %8d bytes\", nmethods_size);\n+  tty->print_cr(\"  nmethod code size         : %8u bytes\", nmethods_code_size);\n+  tty->print_cr(\"  nmethod total size        : %8u bytes\", nmethods_size);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":48,"deletions":37,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -212,12 +212,12 @@\n-  static int _total_compile_count;\n-  static int _total_bailout_count;\n-  static int _total_invalidated_count;\n-  static int _total_native_compile_count;\n-  static int _total_osr_compile_count;\n-  static int _total_standard_compile_count;\n-  static int _total_compiler_stopped_count;\n-  static int _total_compiler_restarted_count;\n-  static int _sum_osr_bytes_compiled;\n-  static int _sum_standard_bytes_compiled;\n-  static int _sum_nmethod_size;\n-  static int _sum_nmethod_code_size;\n+  static uint _total_compile_count;\n+  static uint _total_bailout_count;\n+  static uint _total_invalidated_count;\n+  static uint _total_native_compile_count;\n+  static uint _total_osr_compile_count;\n+  static uint _total_standard_compile_count;\n+  static uint _total_compiler_stopped_count;\n+  static uint _total_compiler_restarted_count;\n+  static uint _sum_osr_bytes_compiled;\n+  static uint _sum_standard_bytes_compiled;\n+  static uint _sum_nmethod_size;\n+  static uint _sum_nmethod_code_size;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-int DirectivesParser::parse_string(const char* text, outputStream* st) {\n-  DirectivesParser cd(text, st, false);\n+int DirectivesParser::parse_string(const char* text, outputStream* st, bool silent) {\n+  DirectivesParser cd(text, st, silent);\n@@ -80,1 +80,1 @@\n-bool DirectivesParser::parse_from_file(const char* filename, outputStream* st) {\n+bool DirectivesParser::parse_from_file(const char* filename, outputStream* st, bool silent) {\n@@ -82,1 +82,1 @@\n-  if (!parse_from_file_inner(filename, st)) {\n+  if (!parse_from_file_inner(filename, st, silent)) {\n@@ -89,1 +89,1 @@\n-bool DirectivesParser::parse_from_file_inner(const char* filename, outputStream* stream) {\n+bool DirectivesParser::parse_from_file_inner(const char* filename, outputStream* stream, bool silent) {\n@@ -102,1 +102,1 @@\n-        return parse_string(buffer, stream) > 0;\n+        return parse_string(buffer, stream, silent) > 0;\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-  static bool parse_from_file(const char* filename, outputStream* st);\n-  static int  parse_string(const char* string, outputStream* st);\n+  static bool parse_from_file(const char* filename, outputStream* st, bool silent = false);\n+  static int  parse_string(const char* string, outputStream* st, bool silent = false);\n@@ -67,1 +67,1 @@\n-  static bool parse_from_file_inner(const char* filename, outputStream* st);\n+  static bool parse_from_file_inner(const char* filename, outputStream* st, bool silent = false);\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics() :\n-  ShenandoahHeuristics(),\n+ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics(ShenandoahSpaceInfo* space_info) :\n+  ShenandoahHeuristics(space_info),\n@@ -87,1 +87,1 @@\n-  size_t capacity    = ShenandoahHeap::heap()->soft_max_capacity();\n+  size_t capacity    = _space_info->soft_max_capacity();\n@@ -131,1 +131,1 @@\n-  size_t available = ShenandoahHeap::heap()->free_set()->available();\n+  size_t available = _space_info->available();\n@@ -199,5 +199,4 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n-  size_t allocated = heap->bytes_allocated_since_gc_start();\n+  size_t max_capacity = _space_info->max_capacity();\n+  size_t capacity = _space_info->soft_max_capacity();\n+  size_t available = _space_info->available();\n+  size_t allocated = _space_info->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -54,0 +55,11 @@\n+\/*\n+ * The adaptive heuristic tracks the allocation behavior and average cycle\n+ * time of the application. It attempts to start a cycle with enough time\n+ * to complete before the available memory is exhausted. It errors on the\n+ * side of starting cycles early to avoid allocation failures (degenerated\n+ * cycles).\n+ *\n+ * This heuristic limits the number of regions for evacuation such that the\n+ * evacuation reserve is respected. This helps it avoid allocation failures\n+ * during evacuation. It preferentially selects regions with the most garbage.\n+ *\/\n@@ -56,1 +68,1 @@\n-  ShenandoahAdaptiveHeuristics();\n+  ShenandoahAdaptiveHeuristics(ShenandoahSpaceInfo* space_info);\n@@ -102,0 +114,1 @@\n+protected:\n@@ -106,1 +119,1 @@\n-  \/\/ tend to over estimate the rate at which mutators will deplete the\n+  \/\/ tend to overestimate the rate at which mutators will deplete the\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics() : ShenandoahHeuristics() {\n+ShenandoahAggressiveHeuristics::ShenandoahAggressiveHeuristics(ShenandoahSpaceInfo* space_info) :\n+  ShenandoahHeuristics(space_info) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+\/*\n+ * This is a diagnostic heuristic that continuously runs collections\n+ * cycles and adds every region with any garbage to the collection set.\n+ *\/\n@@ -32,1 +36,1 @@\n-  ShenandoahAggressiveHeuristics();\n+  ShenandoahAggressiveHeuristics(ShenandoahSpaceInfo* space_info);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-ShenandoahCompactHeuristics::ShenandoahCompactHeuristics() : ShenandoahHeuristics() {\n+ShenandoahCompactHeuristics::ShenandoahCompactHeuristics(ShenandoahSpaceInfo* space_info) :\n+  ShenandoahHeuristics(space_info) {\n@@ -48,5 +49,3 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n+  size_t max_capacity = _space_info->max_capacity();\n+  size_t capacity = _space_info->soft_max_capacity();\n+  size_t available = _space_info->available();\n@@ -68,1 +67,1 @@\n-  size_t bytes_allocated = heap->bytes_allocated_since_gc_start();\n+  size_t bytes_allocated = _space_info->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+\/*\n+ * This heuristic has simpler triggers than the adaptive heuristic. The\n+ * size of the collection set is limited to 3\/4 of available memory.\n+ *\/\n@@ -32,1 +36,1 @@\n-  ShenandoahCompactHeuristics();\n+  ShenandoahCompactHeuristics(ShenandoahSpaceInfo* space_info);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-ShenandoahHeuristics::ShenandoahHeuristics() :\n+ShenandoahHeuristics::ShenandoahHeuristics(ShenandoahSpaceInfo* space_info) :\n+  _space_info(space_info),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -61,0 +62,5 @@\n+\/*\n+ * Shenandoah heuristics are primarily responsible for deciding when to start\n+ * a collection cycle and choosing which regions will be evacuated during the\n+ * cycle.\n+ *\/\n@@ -72,0 +78,3 @@\n+  \/\/ Source of information about the memory space managed by this heuristic\n+  ShenandoahSpaceInfo* _space_info;\n+\n@@ -96,1 +105,1 @@\n-  ShenandoahHeuristics();\n+  ShenandoahHeuristics(ShenandoahSpaceInfo* space_info);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+ShenandoahPassiveHeuristics::ShenandoahPassiveHeuristics(ShenandoahSpaceInfo* space_info) :\n+  ShenandoahHeuristics(space_info) {}\n+\n@@ -56,1 +59,1 @@\n-  size_t max_capacity = ShenandoahHeap::heap()->max_capacity();\n+  size_t max_capacity = _space_info->max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,9 @@\n+\/*\n+ * The passive heuristic is for use only with the passive mode. In\n+ * the passive mode, Shenandoah only performs STW (i.e., degenerated)\n+ * collections. All the barriers are disabled and there are no concurrent\n+ * activities. Therefore, this heuristic _never_ triggers a cycle. It\n+ * will select regions for evacuation based on ShenandoahEvacReserve,\n+ * ShenandoahEvacWaste and ShenandoahGarbageThreshold. Note that it does\n+ * not attempt to evacuate regions with more garbage.\n+ *\/\n@@ -32,0 +41,2 @@\n+  ShenandoahPassiveHeuristics(ShenandoahSpaceInfo* space_info);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSPACEINFO_HPP\n+#define SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSPACEINFO_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/*\n+ * The purpose of this interface is to decouple the heuristics from a\n+ * direct dependency on the ShenandoahHeap singleton instance. This is\n+ * done to facilitate future unit testing of the heuristics and to support\n+ * future operational modes of Shenandoah in which the heap may be split\n+ * into generations.\n+ *\/\n+class ShenandoahSpaceInfo {\n+public:\n+  virtual size_t soft_max_capacity() const = 0;\n+  virtual size_t max_capacity() const = 0;\n+  virtual size_t available() const = 0;\n+  virtual size_t bytes_allocated_since_gc_start() const = 0;\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_HEURISTICS_SHENANDOAHSPACEINFO_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -35,1 +35,2 @@\n-ShenandoahStaticHeuristics::ShenandoahStaticHeuristics() : ShenandoahHeuristics() {\n+ShenandoahStaticHeuristics::ShenandoahStaticHeuristics(ShenandoahSpaceInfo* space_info) :\n+  ShenandoahHeuristics(space_info) {\n@@ -43,5 +44,3 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  size_t max_capacity = heap->max_capacity();\n-  size_t capacity = heap->soft_max_capacity();\n-  size_t available = heap->free_set()->available();\n+  size_t max_capacity = _space_info->max_capacity();\n+  size_t capacity = _space_info->soft_max_capacity();\n+  size_t available = _space_info->available();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,5 @@\n+\/*\n+ * The static heuristic will trigger cycles if the available memory falls\n+ * below ShenandoahMinFreeThreshold percentage of total capacity. This\n+ * heuristic will attempt to evacuation any region with any garbage.\n+ *\/\n@@ -32,1 +37,1 @@\n-  ShenandoahStaticHeuristics();\n+  ShenandoahStaticHeuristics(ShenandoahSpaceInfo* space_info);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -70,0 +71,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -71,1 +73,1 @@\n-    return new ShenandoahAggressiveHeuristics();\n+    return new ShenandoahAggressiveHeuristics(heap);\n@@ -73,1 +75,1 @@\n-    return new ShenandoahStaticHeuristics();\n+    return new ShenandoahStaticHeuristics(heap);\n@@ -75,1 +77,1 @@\n-    return new ShenandoahAdaptiveHeuristics();\n+    return new ShenandoahAdaptiveHeuristics(heap);\n@@ -77,1 +79,1 @@\n-    return new ShenandoahCompactHeuristics();\n+    return new ShenandoahCompactHeuristics(heap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahIUMode.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -62,1 +63,1 @@\n-  return new ShenandoahPassiveHeuristics();\n+  return new ShenandoahPassiveHeuristics(ShenandoahHeap::heap());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -58,0 +59,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -59,1 +61,1 @@\n-    return new ShenandoahAggressiveHeuristics();\n+    return new ShenandoahAggressiveHeuristics(heap);\n@@ -61,1 +63,1 @@\n-    return new ShenandoahStaticHeuristics();\n+    return new ShenandoahStaticHeuristics(heap);\n@@ -63,1 +65,1 @@\n-    return new ShenandoahAdaptiveHeuristics();\n+    return new ShenandoahAdaptiveHeuristics(heap);\n@@ -65,1 +67,1 @@\n-    return new ShenandoahCompactHeuristics();\n+    return new ShenandoahCompactHeuristics(heap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahSATBMode.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -665,0 +665,4 @@\n+size_t ShenandoahHeap::available() const {\n+  return free_set()->available();\n+}\n+\n@@ -1902,1 +1906,1 @@\n-size_t ShenandoahHeap::bytes_allocated_since_gc_start() {\n+size_t ShenandoahHeap::bytes_allocated_since_gc_start() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -119,1 +120,1 @@\n-class ShenandoahHeap : public CollectedHeap {\n+class ShenandoahHeap : public CollectedHeap, public ShenandoahSpaceInfo {\n@@ -194,1 +195,1 @@\n-  size_t bytes_allocated_since_gc_start();\n+  size_t bytes_allocated_since_gc_start() const override;\n@@ -199,1 +200,1 @@\n-  size_t soft_max_capacity() const;\n+  size_t soft_max_capacity() const override;\n@@ -204,0 +205,1 @@\n+  size_t available()         const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -290,1 +290,0 @@\n-  CodeEmitInfo* _info;\n@@ -298,1 +297,1 @@\n-    : LIR_Op(lir_none, new_zpointer, nullptr \/* info *\/),\n+    : LIR_Op(lir_none, new_zpointer, info),\n@@ -302,2 +301,1 @@\n-      _stub(stub),\n-      _info(info) {}\n+      _stub(stub) {}\n","filename":"src\/hotspot\/share\/gc\/z\/c1\/zBarrierSetC1.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -557,1 +557,3 @@\n-    if ((next_j - sleep_to_next) <= 0) {\n+    \/\/ Note, this code used to check (next_j - sleep_to_next) <= 0,\n+    \/\/ but that can overflow (UB) and cause a spurious sample.\n+    if (next_j <= sleep_to_next) {\n@@ -561,1 +563,1 @@\n-    if ((next_n - sleep_to_next) <= 0) {\n+    if (next_n <= sleep_to_next) {\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-void JfrIntrinsicSupport::return_lease(JavaThread* jt) {\n+void* JfrIntrinsicSupport::return_lease(JavaThread* jt) {\n@@ -82,0 +82,1 @@\n+  return nullptr;\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  static void return_lease(JavaThread* jt);\n+  static void* return_lease(JavaThread* jt);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+  LOG_TAG(trimnative) \/* trim native heap *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -95,0 +96,1 @@\n+    NativeHeapTrimmer::SuspendMark sm(\"chunk pool cleaner\");\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,2 +278,0 @@\n-#ifndef PRODUCT\n-\n@@ -343,1 +341,4 @@\n-  typeArrayOop ta = typeArrayOop(obj);\n+  oop_print_elements_on(typeArrayOop(obj), st);\n+}\n+\n+void TypeArrayKlass::oop_print_elements_on(typeArrayOop ta, outputStream* st) {\n@@ -362,2 +363,0 @@\n-#endif \/\/ PRODUCT\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-#ifndef PRODUCT\n@@ -128,2 +127,1 @@\n-#endif\n-\n+  void oop_print_elements_on(typeArrayOop ta, outputStream* st);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-          range(-1, 0)                                                      \\\n+          range(-1, max_intx)                                               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -691,7 +691,0 @@\n-  if (CITimeVerbose) {\n-    tty->print(\" \");\n-    target->holder()->name()->print();\n-    tty->print(\".\");\n-    target->print_short_name();\n-    tty->print(\"  \");\n-  }\n@@ -4868,1 +4861,1 @@\n-    _phase_name(name), _dolog(CITimeVerbose)\n+    _compile(nullptr), _log(nullptr), _phase_name(name), _dolog(CITimeVerbose)\n@@ -4871,5 +4864,2 @@\n-    C = Compile::current();\n-    _log = C->log();\n-  } else {\n-    C = nullptr;\n-    _log = nullptr;\n+    _compile = Compile::current();\n+    _log = _compile->log();\n@@ -4878,1 +4868,1 @@\n-    _log->begin_head(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, C->unique(), C->live_nodes());\n+    _log->begin_head(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, _compile->unique(), _compile->live_nodes());\n@@ -4885,8 +4875,0 @@\n-\n-  C = Compile::current();\n-  if (_dolog) {\n-    _log = C->log();\n-  } else {\n-    _log = nullptr;\n-  }\n-\n@@ -4896,1 +4878,1 @@\n-                  _phase_name, C->unique(), C->live_nodes(), C->count_live_nodes_by_graph_walk());\n+                  _phase_name, _compile->unique(), _compile->live_nodes(), _compile->count_live_nodes_by_graph_walk());\n@@ -4905,1 +4887,1 @@\n-    _log->done(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, C->unique(), C->live_nodes());\n+    _log->done(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, _compile->unique(), _compile->live_nodes());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-    Compile*    C;\n+    Compile*    _compile;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1265,2 +1265,2 @@\n-extern int explicit_null_checks_inserted,\n-           explicit_null_checks_elided;\n+extern uint explicit_null_checks_inserted,\n+            explicit_null_checks_elided;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-extern int explicit_null_checks_elided;\n+extern uint explicit_null_checks_elided;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-int IndexSet::_serial_count = 1;\n+uint IndexSet::_serial_count = 1;\n","filename":"src\/hotspot\/share\/opto\/indexSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -347,2 +347,2 @@\n-  static int _serial_count;\n-  int        _serial_number;\n+  static uint _serial_count;\n+  uint        _serial_number;\n@@ -354,2 +354,2 @@\n-      if (IndexSetWatch == -1 || _serial_number == IndexSetWatch) {\n-        tty->print_cr(\"IndexSet %d : %s ( %d )\", _serial_number, operation, operand);\n+      if (IndexSetWatch == -1 || (uintx)_serial_number == (uintx)IndexSetWatch) {\n+        tty->print_cr(\"IndexSet %u : %s ( %d )\", _serial_number, operation, operand);\n@@ -361,2 +361,2 @@\n-      if (IndexSetWatch == -1 || _serial_number == IndexSetWatch) {\n-        tty->print_cr(\"IndexSet %d : %s\", _serial_number, operation);\n+      if (IndexSetWatch == -1 || (uintx)_serial_number == (uintx)IndexSetWatch) {\n+        tty->print_cr(\"IndexSet %u : %s\", _serial_number, operation);\n","filename":"src\/hotspot\/share\/opto\/indexSet.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-  extern int implicit_null_checks;\n+  extern uint implicit_null_checks;\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2591,1 +2591,1 @@\n-        extern int all_null_checks_found;\n+        extern uint all_null_checks_found;\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -911,1 +911,1 @@\n-      return new AndINode(add1->in(1), phase->intcon(-(1 << con)));\n+      return new AndINode(add1->in(1), phase->intcon(java_negate(jint(1 << con))));\n@@ -921,1 +921,1 @@\n-            return new AndINode(lshift, phase->intcon(java_negate((jint)(1 << con))));\n+            return new AndINode(lshift, phase->intcon(java_negate(jint(1 << con))));\n@@ -934,1 +934,1 @@\n-            return new AndINode(rshift, phase->intcon(-(1 << con)));\n+            return new AndINode(rshift, phase->intcon(java_negate(jint(1 << con))));\n@@ -1087,1 +1087,1 @@\n-      return new AndLNode(add1->in(1), phase->longcon(-(CONST64(1) << con)));\n+      return new AndLNode(add1->in(1), phase->longcon(java_negate(jlong(CONST64(1) << con))));\n@@ -1097,1 +1097,1 @@\n-            return new AndLNode(lshift, phase->longcon(-(CONST64(1) << con)));\n+            return new AndLNode(lshift, phase->longcon(java_negate(jlong(CONST64(1) << con))));\n@@ -1110,1 +1110,1 @@\n-            return new AndLNode(rshift, phase->longcon(-(CONST64(1) << con)));\n+            return new AndLNode(rshift, phase->longcon(java_negate(jlong(CONST64(1) << con))));\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-extern int nodes_created;\n+extern uint nodes_created;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,5 +54,5 @@\n-int nodes_created              = 0;\n-int methods_parsed             = 0;\n-int methods_seen               = 0;\n-int blocks_parsed              = 0;\n-int blocks_seen                = 0;\n+uint nodes_created             = 0;\n+uint methods_parsed            = 0;\n+uint methods_seen              = 0;\n+uint blocks_parsed             = 0;\n+uint blocks_seen               = 0;\n@@ -60,4 +60,4 @@\n-int explicit_null_checks_inserted = 0;\n-int explicit_null_checks_elided   = 0;\n-int all_null_checks_found         = 0;\n-int implicit_null_checks          = 0;\n+uint explicit_null_checks_inserted = 0;\n+uint explicit_null_checks_elided   = 0;\n+uint all_null_checks_found         = 0;\n+uint implicit_null_checks          = 0;\n@@ -74,2 +74,2 @@\n-  tty->print(\"Methods seen: %d  Methods parsed: %d\", methods_seen, methods_parsed);\n-  tty->print(\"  Nodes created: %d\", nodes_created);\n+  tty->print(\"Methods seen: %u  Methods parsed: %u\", methods_seen, methods_parsed);\n+  tty->print(\"  Nodes created: %u\", nodes_created);\n@@ -80,1 +80,1 @@\n-  tty->print_cr(\"Blocks parsed: %d  Blocks seen: %d\", blocks_parsed, blocks_seen);\n+  tty->print_cr(\"Blocks parsed: %u  Blocks seen: %u\", blocks_parsed, blocks_seen);\n@@ -83,1 +83,1 @@\n-    tty->print_cr(\"%d original null checks - %d elided (%2d%%); optimizer leaves %d,\",\n+    tty->print_cr(\"%u original null checks - %u elided (%2u%%); optimizer leaves %u,\",\n@@ -89,1 +89,1 @@\n-    tty->print_cr(\"%d made implicit (%2d%%)\", implicit_null_checks,\n+    tty->print_cr(\"%u made implicit (%2u%%)\", implicit_null_checks,\n@@ -93,1 +93,1 @@\n-    tty->print_cr(\"%d implicit null exceptions at runtime\",\n+    tty->print_cr(\"%u implicit null exceptions at runtime\",\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-extern int explicit_null_checks_inserted,\n-           explicit_null_checks_elided;\n+extern uint explicit_null_checks_inserted,\n+            explicit_null_checks_elided;\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -401,2 +401,2 @@\n-  int expand_count = 1;        \/\/ count of allocations in the expansion\n-  int expand_fanout = 1;       \/\/ running total fanout\n+  int64_t expand_count = 1;        \/\/ count of allocations in the expansion\n+  int64_t expand_fanout = 1;       \/\/ running total fanout\n@@ -405,0 +405,3 @@\n+    \/\/ To prevent overflow, we use 64-bit values.  Alternatively,\n+    \/\/ we could clamp dim_con like so:\n+    \/\/ dim_con = MIN2(dim_con, expand_limit);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2690,1 +2690,1 @@\n-\/\/  <V extends Vector<E>,\n+\/\/  <VM extends VectorPayload,\n@@ -2692,3 +2692,4 @@\n-\/\/  long extract(Class<? extends V> vectorClass, Class<E> elementType, int vlen,\n-\/\/               V vec, int ix,\n-\/\/               VecExtractOp<V> defaultImpl)\n+\/\/  long extract(Class<? extends VM> vClass, Class<E> eClass,\n+\/\/               int length,\n+\/\/               VM vm, int i,\n+\/\/               VecExtractOp<VM> defaultImpl)\n@@ -2704,1 +2705,1 @@\n-  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() || !idx->is_con()) {\n+  if (vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con()) {\n@@ -2706,1 +2707,1 @@\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s idx=%s\",\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n@@ -2709,2 +2710,1 @@\n-                    NodeClassNames[argument(2)->Opcode()],\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()]);\n@@ -2729,8 +2729,0 @@\n-  int vopc = ExtractNode::opcode(elem_bt);\n-  if (!arch_supports_vector(vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n-                    num_elem, type2name(elem_bt));\n-    }\n-    return false; \/\/ not supported\n-  }\n@@ -2741,4 +2733,1 @@\n-  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n-  if (opd == nullptr) {\n-    return false;\n-  }\n+  Node* opd = nullptr;\n@@ -2746,2 +2735,2 @@\n-  ConINode* idx_con = gvn().intcon(idx->get_con())->as_ConI();\n-  Node* operation = gvn().transform(ExtractNode::make(opd, idx_con, elem_bt));\n+  if (is_vector_mask(vbox_klass)) {\n+    \/\/ vbox_klass is mask. This is used for VectorMask.laneIsSet(int).\n@@ -2749,7 +2738,28 @@\n-  Node* bits = nullptr;\n-  switch (elem_bt) {\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT: {\n-      bits = gvn().transform(new ConvI2LNode(operation));\n-      break;\n+    Node* pos = argument(4); \/\/ can be variable\n+    if (arch_supports_vector(Op_ExtractUB, num_elem, elem_bt, VecMaskUseAll)) {\n+      \/\/ Transform mask to vector with type of boolean and utilize ExtractUB node.\n+      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      if (opd == nullptr) {\n+        return false;\n+      }\n+      opd = gvn().transform(VectorStoreMaskNode::make(gvn(), opd, elem_bt, num_elem));\n+      opd = gvn().transform(new ExtractUBNode(opd, pos));\n+      opd = gvn().transform(new ConvI2LNode(opd));\n+    } else if (arch_supports_vector(Op_VectorMaskToLong, num_elem, elem_bt, VecMaskUseLoad)) {\n+      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      if (opd == nullptr) {\n+        return false;\n+      }\n+      \/\/ VectorMaskToLongNode requires the input is either a mask or a vector with BOOLEAN type.\n+      if (opd->bottom_type()->isa_vectmask() == nullptr) {\n+        opd = gvn().transform(VectorStoreMaskNode::make(gvn(), opd, elem_bt, num_elem));\n+      }\n+      \/\/ ((toLong() >>> pos) & 1L\n+      opd = gvn().transform(new VectorMaskToLongNode(opd, TypeLong::LONG));\n+      opd = gvn().transform(new URShiftLNode(opd, pos));\n+      opd = gvn().transform(new AndLNode(opd, gvn().makecon(TypeLong::ONE)));\n+    } else {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** Rejected mask extraction because architecture does not support it\");\n+      }\n+      return false; \/\/ not supported\n@@ -2757,4 +2767,7 @@\n-    case T_FLOAT: {\n-      bits = gvn().transform(new MoveF2INode(operation));\n-      bits = gvn().transform(new ConvI2LNode(bits));\n-      break;\n+  } else {\n+    \/\/ vbox_klass is vector. This is used for Vector.lane(int).\n+    if (!idx->is_con()) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** missing constant: idx=%s\", NodeClassNames[argument(4)->Opcode()]);\n+      }\n+      return false; \/\/ not enough info for intrinsification\n@@ -2762,3 +2775,8 @@\n-    case T_DOUBLE: {\n-      bits = gvn().transform(new MoveD2LNode(operation));\n-      break;\n+\n+    int vopc = ExtractNode::opcode(elem_bt);\n+    if (!arch_supports_vector(vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=1 op=extract vlen=%d etype=%s ismask=no\",\n+                      num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n@@ -2766,3 +2784,4 @@\n-    case T_LONG: {\n-      bits = operation; \/\/ no conversion needed\n-      break;\n+\n+    opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+    if (opd == nullptr) {\n+      return false;\n@@ -2770,2 +2789,1 @@\n-    default: fatal(\"%s\", type2name(elem_bt));\n-  }\n+    ConINode* idx_con = gvn().intcon(idx->get_con())->as_ConI();\n@@ -2773,1 +2791,25 @@\n-  set_result(bits);\n+    opd = gvn().transform(ExtractNode::make(opd, idx_con, elem_bt));\n+    switch (elem_bt) {\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_INT: {\n+        opd = gvn().transform(new ConvI2LNode(opd));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        opd = gvn().transform(new MoveF2INode(opd));\n+        opd = gvn().transform(new ConvI2LNode(opd));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        opd = gvn().transform(new MoveD2LNode(opd));\n+        break;\n+      }\n+      case T_LONG: {\n+        \/\/ no conversion needed\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n+    }\n+  }\n+  set_result(opd);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":84,"deletions":42,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -1205,1 +1205,1 @@\n-\/\/ Extract a scalar element of vector.\n+\/\/ Extract a scalar element of vector by constant position.\n@@ -1207,1 +1207,2 @@\n-  assert(pos->get_int() < Matcher::max_vector_size(bt), \"pos in range\");\n+  assert(pos->get_int() >= 0 &&\n+         pos->get_int() < Matcher::max_vector_size(bt), \"pos in range\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1283,3 +1283,1 @@\n-  ExtractNode(Node* src, ConINode* pos) : Node(nullptr, src, (Node*)pos) {\n-    assert(in(2)->get_int() >= 0, \"positive constants\");\n-  }\n+  ExtractNode(Node* src, Node* pos) : Node(nullptr, src, pos) {}\n@@ -1287,2 +1285,0 @@\n-  uint  pos() const { return in(2)->get_int(); }\n-\n@@ -1297,1 +1293,1 @@\n-  ExtractBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractBNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1307,1 +1303,1 @@\n-  ExtractUBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractUBNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1309,1 +1305,1 @@\n-  virtual const Type* bottom_type() const { return TypeInt::UBYTE; }\n+  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n@@ -1317,1 +1313,1 @@\n-  ExtractCNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractCNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1327,1 +1323,1 @@\n-  ExtractSNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractSNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1337,1 +1333,1 @@\n-  ExtractINode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractINode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1347,1 +1343,1 @@\n-  ExtractLNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractLNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1357,1 +1353,1 @@\n-  ExtractFNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractFNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n@@ -1367,1 +1363,1 @@\n-  ExtractDNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}\n+  ExtractDNode(Node* src, Node* pos) : ExtractNode(src, pos) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1042,2 +1042,5 @@\n-  assert(Reflection::is_same_class_package(lookup_k, ik),\n-         \"lookup class and defined class are in different packages\");\n+\n+  if ((!is_hidden || is_nestmate) && !Reflection::is_same_class_package(lookup_k, ik)) {\n+    \/\/ non-hidden class or nestmate class must be in the same package as the Lookup class\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Lookup class and defined class are in different packages\");\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -381,11 +381,0 @@\n-  if (Continuations::enabled()) {\n-    \/\/ Virtual threads support. There is a performance impact when VTMS transitions are enabled.\n-    if (JvmtiEnv::get_phase() == JVMTI_PHASE_LIVE) {\n-      if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-        ThreadInVMfromNative __tiv(JavaThread::current());\n-        JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n-      }\n-    } else {\n-      JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n-    }\n-  }\n@@ -402,0 +391,8 @@\n+\n+    if (Continuations::enabled()) {\n+      \/\/ Virtual threads support for agents loaded into running VM.\n+      \/\/ There is a performance impact when VTMS transitions are enabled.\n+      if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+        JvmtiEnvBase::enable_virtual_threads_notify_jvmti();\n+      }\n+    }\n@@ -408,0 +405,6 @@\n+\n+    if (Continuations::enabled()) {\n+      \/\/ Virtual threads support for agents loaded at startup.\n+      \/\/ There is a performance impact when VTMS transitions are enabled.\n+      JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2680,0 +2680,8 @@\n+WB_ENTRY(void, WB_PreTouchMemory(JNIEnv* env, jobject wb, jlong addr, jlong size))\n+  void* const from = (void*)addr;\n+  void* const to = (void*)(addr + size);\n+  if (from > to) {\n+    os::pretouch_memory(from, to, os::vm_page_size());\n+  }\n+WB_END\n+\n@@ -2968,0 +2976,1 @@\n+  {CC\"preTouchMemory\",  CC\"(JJ)V\",                    (void*)&WB_PreTouchMemory},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-bool   Arguments::_xdebug_mode                  = false;\n@@ -2727,2 +2726,1 @@\n-      \/\/ note this flag has been used, then ignore\n-      set_xdebug_mode(true);\n+      warning(\"Option -Xdebug was deprecated in JDK 22 and will likely be removed in a future release.\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -254,5 +254,0 @@\n-  \/\/ -Xdebug flag\n-  static bool _xdebug_mode;\n-  static void set_xdebug_mode(bool arg) { _xdebug_mode = arg; }\n-  static bool xdebug_mode()             { return _xdebug_mode; }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1313,3 +1313,4 @@\n-  product(intx, SafepointTimeoutDelay, 10000,                               \\\n-          \"Delay in milliseconds for option SafepointTimeout\")              \\\n-          range(0, max_intx LP64_ONLY(\/MICROUNITS))                         \\\n+  product(double, SafepointTimeoutDelay, 10000,                             \\\n+          \"Delay in milliseconds for option SafepointTimeout; \"             \\\n+          \"supports sub-millisecond resolution with fractional values.\")    \\\n+          range(0, max_jlongDouble LP64_ONLY(\/MICROUNITS))                  \\\n@@ -2028,0 +2029,7 @@\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 0, EXPERIMENTAL,                    \\\n+          \"Interval, in ms, at which the JVM will trim the native heap if \" \\\n+          \"the platform supports that. Lower values will reclaim memory \"   \\\n+          \"more eagerly at the cost of higher overhead. A value of 0 \"      \\\n+          \"(default) disables native heap trimming.\")                       \\\n+          range(0, UINT_MAX)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -480,0 +481,2 @@\n+  NativeHeapTrimmer::cleanup();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -227,2 +227,0 @@\n-\n-    MUTEX_DEFN(MonitoringSupport_lock        , PaddedMutex  , service-1);      \/\/ used for serviceability monitoring support\n@@ -230,0 +228,2 @@\n+  MUTEX_DEFN(MonitoringSupport_lock          , PaddedMutex  , service-1);        \/\/ used for serviceability monitoring support\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-    safepoint_limit_time = SafepointTracing::start_of_safepoint() + (jlong)SafepointTimeoutDelay * (NANOUNITS \/ MILLIUNITS);\n+    safepoint_limit_time = SafepointTracing::start_of_safepoint() + (jlong)(SafepointTimeoutDelay * NANOSECS_PER_MILLISEC);\n@@ -823,1 +823,1 @@\n-    fatal(\"Safepoint sync time longer than \" INTX_FORMAT \"ms detected when executing %s.\",\n+    fatal(\"Safepoint sync time longer than %.6f ms detected when executing %s.\",\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,7 +143,7 @@\n-int SharedRuntime::_ic_miss_ctr = 0;\n-int SharedRuntime::_wrong_method_ctr = 0;\n-int SharedRuntime::_resolve_static_ctr = 0;\n-int SharedRuntime::_resolve_virtual_ctr = 0;\n-int SharedRuntime::_resolve_opt_virtual_ctr = 0;\n-int SharedRuntime::_implicit_null_throws = 0;\n-int SharedRuntime::_implicit_div0_throws = 0;\n+uint SharedRuntime::_ic_miss_ctr = 0;\n+uint SharedRuntime::_wrong_method_ctr = 0;\n+uint SharedRuntime::_resolve_static_ctr = 0;\n+uint SharedRuntime::_resolve_virtual_ctr = 0;\n+uint SharedRuntime::_resolve_opt_virtual_ctr = 0;\n+uint SharedRuntime::_implicit_null_throws = 0;\n+uint SharedRuntime::_implicit_div0_throws = 0;\n@@ -159,22 +159,22 @@\n-int SharedRuntime::_new_instance_ctr=0;\n-int SharedRuntime::_new_array_ctr=0;\n-int SharedRuntime::_multi2_ctr=0;\n-int SharedRuntime::_multi3_ctr=0;\n-int SharedRuntime::_multi4_ctr=0;\n-int SharedRuntime::_multi5_ctr=0;\n-int SharedRuntime::_mon_enter_stub_ctr=0;\n-int SharedRuntime::_mon_exit_stub_ctr=0;\n-int SharedRuntime::_mon_enter_ctr=0;\n-int SharedRuntime::_mon_exit_ctr=0;\n-int SharedRuntime::_partial_subtype_ctr=0;\n-int SharedRuntime::_jbyte_array_copy_ctr=0;\n-int SharedRuntime::_jshort_array_copy_ctr=0;\n-int SharedRuntime::_jint_array_copy_ctr=0;\n-int SharedRuntime::_jlong_array_copy_ctr=0;\n-int SharedRuntime::_oop_array_copy_ctr=0;\n-int SharedRuntime::_checkcast_array_copy_ctr=0;\n-int SharedRuntime::_unsafe_array_copy_ctr=0;\n-int SharedRuntime::_generic_array_copy_ctr=0;\n-int SharedRuntime::_slow_array_copy_ctr=0;\n-int SharedRuntime::_find_handler_ctr=0;\n-int SharedRuntime::_rethrow_ctr=0;\n+uint SharedRuntime::_new_instance_ctr=0;\n+uint SharedRuntime::_new_array_ctr=0;\n+uint SharedRuntime::_multi2_ctr=0;\n+uint SharedRuntime::_multi3_ctr=0;\n+uint SharedRuntime::_multi4_ctr=0;\n+uint SharedRuntime::_multi5_ctr=0;\n+uint SharedRuntime::_mon_enter_stub_ctr=0;\n+uint SharedRuntime::_mon_exit_stub_ctr=0;\n+uint SharedRuntime::_mon_enter_ctr=0;\n+uint SharedRuntime::_mon_exit_ctr=0;\n+uint SharedRuntime::_partial_subtype_ctr=0;\n+uint SharedRuntime::_jbyte_array_copy_ctr=0;\n+uint SharedRuntime::_jshort_array_copy_ctr=0;\n+uint SharedRuntime::_jint_array_copy_ctr=0;\n+uint SharedRuntime::_jlong_array_copy_ctr=0;\n+uint SharedRuntime::_oop_array_copy_ctr=0;\n+uint SharedRuntime::_checkcast_array_copy_ctr=0;\n+uint SharedRuntime::_unsafe_array_copy_ctr=0;\n+uint SharedRuntime::_generic_array_copy_ctr=0;\n+uint SharedRuntime::_slow_array_copy_ctr=0;\n+uint SharedRuntime::_find_handler_ctr=0;\n+uint SharedRuntime::_rethrow_ctr=0;\n@@ -1472,3 +1472,3 @@\n-  int *addr = (is_optimized) ? (&_resolve_opt_virtual_ctr) :\n-                (is_virtual) ? (&_resolve_virtual_ctr) :\n-                               (&_resolve_static_ctr);\n+  uint *addr = (is_optimized) ? (&_resolve_opt_virtual_ctr) :\n+                 (is_virtual) ? (&_resolve_virtual_ctr) :\n+                                (&_resolve_static_ctr);\n@@ -2353,29 +2353,29 @@\n-  if (_new_instance_ctr) tty->print_cr(\"%5d new instance requires GC\", _new_instance_ctr);\n-  if (_new_array_ctr) tty->print_cr(\"%5d new array requires GC\", _new_array_ctr);\n-  if (_multi2_ctr) tty->print_cr(\"%5d multianewarray 2 dim\", _multi2_ctr);\n-  if (_multi3_ctr) tty->print_cr(\"%5d multianewarray 3 dim\", _multi3_ctr);\n-  if (_multi4_ctr) tty->print_cr(\"%5d multianewarray 4 dim\", _multi4_ctr);\n-  if (_multi5_ctr) tty->print_cr(\"%5d multianewarray 5 dim\", _multi5_ctr);\n-\n-  tty->print_cr(\"%5d inline cache miss in compiled\", _ic_miss_ctr);\n-  tty->print_cr(\"%5d wrong method\", _wrong_method_ctr);\n-  tty->print_cr(\"%5d unresolved static call site\", _resolve_static_ctr);\n-  tty->print_cr(\"%5d unresolved virtual call site\", _resolve_virtual_ctr);\n-  tty->print_cr(\"%5d unresolved opt virtual call site\", _resolve_opt_virtual_ctr);\n-\n-  if (_mon_enter_stub_ctr) tty->print_cr(\"%5d monitor enter stub\", _mon_enter_stub_ctr);\n-  if (_mon_exit_stub_ctr) tty->print_cr(\"%5d monitor exit stub\", _mon_exit_stub_ctr);\n-  if (_mon_enter_ctr) tty->print_cr(\"%5d monitor enter slow\", _mon_enter_ctr);\n-  if (_mon_exit_ctr) tty->print_cr(\"%5d monitor exit slow\", _mon_exit_ctr);\n-  if (_partial_subtype_ctr) tty->print_cr(\"%5d slow partial subtype\", _partial_subtype_ctr);\n-  if (_jbyte_array_copy_ctr) tty->print_cr(\"%5d byte array copies\", _jbyte_array_copy_ctr);\n-  if (_jshort_array_copy_ctr) tty->print_cr(\"%5d short array copies\", _jshort_array_copy_ctr);\n-  if (_jint_array_copy_ctr) tty->print_cr(\"%5d int array copies\", _jint_array_copy_ctr);\n-  if (_jlong_array_copy_ctr) tty->print_cr(\"%5d long array copies\", _jlong_array_copy_ctr);\n-  if (_oop_array_copy_ctr) tty->print_cr(\"%5d oop array copies\", _oop_array_copy_ctr);\n-  if (_checkcast_array_copy_ctr) tty->print_cr(\"%5d checkcast array copies\", _checkcast_array_copy_ctr);\n-  if (_unsafe_array_copy_ctr) tty->print_cr(\"%5d unsafe array copies\", _unsafe_array_copy_ctr);\n-  if (_generic_array_copy_ctr) tty->print_cr(\"%5d generic array copies\", _generic_array_copy_ctr);\n-  if (_slow_array_copy_ctr) tty->print_cr(\"%5d slow array copies\", _slow_array_copy_ctr);\n-  if (_find_handler_ctr) tty->print_cr(\"%5d find exception handler\", _find_handler_ctr);\n-  if (_rethrow_ctr) tty->print_cr(\"%5d rethrow handler\", _rethrow_ctr);\n+  if (_new_instance_ctr) tty->print_cr(\"%5u new instance requires GC\", _new_instance_ctr);\n+  if (_new_array_ctr) tty->print_cr(\"%5u new array requires GC\", _new_array_ctr);\n+  if (_multi2_ctr) tty->print_cr(\"%5u multianewarray 2 dim\", _multi2_ctr);\n+  if (_multi3_ctr) tty->print_cr(\"%5u multianewarray 3 dim\", _multi3_ctr);\n+  if (_multi4_ctr) tty->print_cr(\"%5u multianewarray 4 dim\", _multi4_ctr);\n+  if (_multi5_ctr) tty->print_cr(\"%5u multianewarray 5 dim\", _multi5_ctr);\n+\n+  tty->print_cr(\"%5u inline cache miss in compiled\", _ic_miss_ctr);\n+  tty->print_cr(\"%5u wrong method\", _wrong_method_ctr);\n+  tty->print_cr(\"%5u unresolved static call site\", _resolve_static_ctr);\n+  tty->print_cr(\"%5u unresolved virtual call site\", _resolve_virtual_ctr);\n+  tty->print_cr(\"%5u unresolved opt virtual call site\", _resolve_opt_virtual_ctr);\n+\n+  if (_mon_enter_stub_ctr) tty->print_cr(\"%5u monitor enter stub\", _mon_enter_stub_ctr);\n+  if (_mon_exit_stub_ctr) tty->print_cr(\"%5u monitor exit stub\", _mon_exit_stub_ctr);\n+  if (_mon_enter_ctr) tty->print_cr(\"%5u monitor enter slow\", _mon_enter_ctr);\n+  if (_mon_exit_ctr) tty->print_cr(\"%5u monitor exit slow\", _mon_exit_ctr);\n+  if (_partial_subtype_ctr) tty->print_cr(\"%5u slow partial subtype\", _partial_subtype_ctr);\n+  if (_jbyte_array_copy_ctr) tty->print_cr(\"%5u byte array copies\", _jbyte_array_copy_ctr);\n+  if (_jshort_array_copy_ctr) tty->print_cr(\"%5u short array copies\", _jshort_array_copy_ctr);\n+  if (_jint_array_copy_ctr) tty->print_cr(\"%5u int array copies\", _jint_array_copy_ctr);\n+  if (_jlong_array_copy_ctr) tty->print_cr(\"%5u long array copies\", _jlong_array_copy_ctr);\n+  if (_oop_array_copy_ctr) tty->print_cr(\"%5u oop array copies\", _oop_array_copy_ctr);\n+  if (_checkcast_array_copy_ctr) tty->print_cr(\"%5u checkcast array copies\", _checkcast_array_copy_ctr);\n+  if (_unsafe_array_copy_ctr) tty->print_cr(\"%5u unsafe array copies\", _unsafe_array_copy_ctr);\n+  if (_generic_array_copy_ctr) tty->print_cr(\"%5u generic array copies\", _generic_array_copy_ctr);\n+  if (_slow_array_copy_ctr) tty->print_cr(\"%5u slow array copies\", _slow_array_copy_ctr);\n+  if (_find_handler_ctr) tty->print_cr(\"%5u find exception handler\", _find_handler_ctr);\n+  if (_rethrow_ctr) tty->print_cr(\"%5u rethrow handler\", _rethrow_ctr);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -563,28 +563,28 @@\n-  static int _ic_miss_ctr;                       \/\/ total # of IC misses\n-  static int _wrong_method_ctr;\n-  static int _resolve_static_ctr;\n-  static int _resolve_virtual_ctr;\n-  static int _resolve_opt_virtual_ctr;\n-  static int _implicit_null_throws;\n-  static int _implicit_div0_throws;\n-\n-  static int _jbyte_array_copy_ctr;        \/\/ Slow-path byte array copy\n-  static int _jshort_array_copy_ctr;       \/\/ Slow-path short array copy\n-  static int _jint_array_copy_ctr;         \/\/ Slow-path int array copy\n-  static int _jlong_array_copy_ctr;        \/\/ Slow-path long array copy\n-  static int _oop_array_copy_ctr;          \/\/ Slow-path oop array copy\n-  static int _checkcast_array_copy_ctr;    \/\/ Slow-path oop array copy, with cast\n-  static int _unsafe_array_copy_ctr;       \/\/ Slow-path includes alignment checks\n-  static int _generic_array_copy_ctr;      \/\/ Slow-path includes type decoding\n-  static int _slow_array_copy_ctr;         \/\/ Slow-path failed out to a method call\n-\n-  static int _new_instance_ctr;            \/\/ 'new' object requires GC\n-  static int _new_array_ctr;               \/\/ 'new' array requires GC\n-  static int _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n-  static int _find_handler_ctr;            \/\/ find exception handler\n-  static int _rethrow_ctr;                 \/\/ rethrow exception\n-  static int _mon_enter_stub_ctr;          \/\/ monitor enter stub\n-  static int _mon_exit_stub_ctr;           \/\/ monitor exit stub\n-  static int _mon_enter_ctr;               \/\/ monitor enter slow\n-  static int _mon_exit_ctr;                \/\/ monitor exit slow\n-  static int _partial_subtype_ctr;         \/\/ SubRoutines::partial_subtype_check\n+  static uint _ic_miss_ctr;                      \/\/ total # of IC misses\n+  static uint _wrong_method_ctr;\n+  static uint _resolve_static_ctr;\n+  static uint _resolve_virtual_ctr;\n+  static uint _resolve_opt_virtual_ctr;\n+  static uint _implicit_null_throws;\n+  static uint _implicit_div0_throws;\n+\n+  static uint _jbyte_array_copy_ctr;       \/\/ Slow-path byte array copy\n+  static uint _jshort_array_copy_ctr;      \/\/ Slow-path short array copy\n+  static uint _jint_array_copy_ctr;        \/\/ Slow-path int array copy\n+  static uint _jlong_array_copy_ctr;       \/\/ Slow-path long array copy\n+  static uint _oop_array_copy_ctr;         \/\/ Slow-path oop array copy\n+  static uint _checkcast_array_copy_ctr;   \/\/ Slow-path oop array copy, with cast\n+  static uint _unsafe_array_copy_ctr;      \/\/ Slow-path includes alignment checks\n+  static uint _generic_array_copy_ctr;     \/\/ Slow-path includes type decoding\n+  static uint _slow_array_copy_ctr;        \/\/ Slow-path failed out to a method call\n+\n+  static uint _new_instance_ctr;           \/\/ 'new' object requires GC\n+  static uint _new_array_ctr;              \/\/ 'new' array requires GC\n+  static uint _multi2_ctr, _multi3_ctr, _multi4_ctr, _multi5_ctr;\n+  static uint _find_handler_ctr;           \/\/ find exception handler\n+  static uint _rethrow_ctr;                \/\/ rethrow exception\n+  static uint _mon_enter_stub_ctr;         \/\/ monitor enter stub\n+  static uint _mon_exit_stub_ctr;          \/\/ monitor exit stub\n+  static uint _mon_enter_ctr;              \/\/ monitor enter slow\n+  static uint _mon_exit_ctr;               \/\/ monitor exit slow\n+  static uint _partial_subtype_ctr;        \/\/ SubRoutines::partial_subtype_check\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -1685,0 +1686,1 @@\n+  NativeHeapTrimmer::SuspendMark sm(\"monitor deletion\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -762,0 +763,4 @@\n+  if (NativeHeapTrimmer::enabled()) {\n+    NativeHeapTrimmer::initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+class NativeHeapTrimmerThread : public NamedThread {\n+\n+  \/\/ Upper limit for the backoff during pending\/in-progress safepoint.\n+  \/\/ Chosen as reasonable value to balance the overheads of waking up\n+  \/\/ during the safepoint, which might have undesired effects on latencies,\n+  \/\/ and the accuracy in tracking the trimming interval.\n+  static constexpr int64_t safepoint_poll_ms = 250;\n+\n+  Monitor* const _lock;\n+  bool _stop;\n+  uint16_t _suspend_count;\n+\n+  \/\/ Statistics\n+  uint64_t _num_trims_performed;\n+\n+  bool is_suspended() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _suspend_count > 0;\n+  }\n+\n+  uint16_t inc_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count < UINT16_MAX, \"Sanity\");\n+    return ++_suspend_count;\n+  }\n+\n+  uint16_t dec_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count != 0, \"Sanity\");\n+    return --_suspend_count;\n+  }\n+\n+  bool is_stopped() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _stop;\n+  }\n+\n+  bool at_or_nearing_safepoint() const {\n+    return SafepointSynchronize::is_at_safepoint() ||\n+           SafepointSynchronize::is_synchronizing();\n+  }\n+\n+  \/\/ in seconds\n+  static double now() { return os::elapsedTime(); }\n+  static double to_ms(double seconds) { return seconds * 1000.0; }\n+\n+  struct LogStartStopMark {\n+    void log(const char* s) { log_info(trimnative)(\"Native heap trimmer %s\", s); }\n+    LogStartStopMark()  { log(\"start\"); }\n+    ~LogStartStopMark() { log(\"stop\"); }\n+  };\n+\n+  void run() override {\n+    assert(NativeHeapTrimmer::enabled(), \"Only call if enabled\");\n+\n+    LogStartStopMark lssm;\n+\n+    const double interval_secs = (double)TrimNativeHeapInterval \/ 1000;\n+\n+    while (true) {\n+      double tnow = now();\n+      double next_trim_time = tnow + interval_secs;\n+\n+      unsigned times_suspended = 0;\n+      unsigned times_waited = 0;\n+      unsigned times_safepoint = 0;\n+\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        if (_stop) return;\n+\n+        while (at_or_nearing_safepoint() || is_suspended() || next_trim_time > tnow) {\n+          if (is_suspended()) {\n+            times_suspended ++;\n+            ml.wait(0); \/\/ infinite\n+          } else if (next_trim_time > tnow) {\n+            times_waited ++;\n+            const int64_t wait_ms = MAX2(1.0, to_ms(next_trim_time - tnow));\n+            ml.wait(wait_ms);\n+          } else if (at_or_nearing_safepoint()) {\n+            times_safepoint ++;\n+            const int64_t wait_ms = MIN2<int64_t>(TrimNativeHeapInterval, safepoint_poll_ms);\n+            ml.wait(wait_ms);\n+          }\n+\n+          if (_stop) return;\n+\n+          tnow = now();\n+        }\n+      }\n+\n+      log_trace(trimnative)(\"Times: %u suspended, %u timed, %u safepoint\",\n+                            times_suspended, times_waited, times_safepoint);\n+\n+      execute_trim_and_log(tnow);\n+    }\n+  }\n+\n+  \/\/ Execute the native trim, log results.\n+  void execute_trim_and_log(double t1) {\n+    assert(os::can_trim_native_heap(), \"Unexpected\");\n+\n+    os::size_change_t sc = { 0, 0 };\n+    LogTarget(Info, trimnative) lt;\n+    const bool logging_enabled = lt.is_enabled();\n+\n+    \/\/ We only collect size change information if we are logging; save the access to procfs otherwise.\n+    if (os::trim_native_heap(logging_enabled ? &sc : nullptr)) {\n+      _num_trims_performed++;\n+      if (logging_enabled) {\n+        double t2 = now();\n+        if (sc.after != SIZE_MAX) {\n+          const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+          const char sign = sc.after < sc.before ? '-' : '+';\n+          log_info(trimnative)(\"Periodic Trim (\" UINT64_FORMAT \"): \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \") %.3fms\",\n+                               _num_trims_performed,\n+                               PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                               to_ms(t2 - t1));\n+        } else {\n+          log_info(trimnative)(\"Periodic Trim (\" UINT64_FORMAT \"): complete (no details) %.3fms\",\n+                               _num_trims_performed,\n+                               to_ms(t2 - t1));\n+        }\n+      }\n+    }\n+  }\n+\n+public:\n+\n+  NativeHeapTrimmerThread() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeHeapTrimmer_lock\")),\n+    _stop(false),\n+    _suspend_count(0),\n+    _num_trims_performed(0)\n+  {\n+    set_name(\"Native Heap Trimmer\");\n+    if (os::create_thread(this, os::vm_thread)) {\n+      os::start_thread(this);\n+    }\n+  }\n+\n+  void suspend(const char* reason) {\n+    assert(NativeHeapTrimmer::enabled(), \"Only call if enabled\");\n+    uint16_t n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = inc_suspend_count();\n+      \/\/ No need to wakeup trimmer\n+    }\n+    log_debug(trimnative)(\"Trim suspended for %s (%u suspend requests)\", reason, n);\n+  }\n+\n+  void resume(const char* reason) {\n+    assert(NativeHeapTrimmer::enabled(), \"Only call if enabled\");\n+    uint16_t n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = dec_suspend_count();\n+      if (n == 0) {\n+        ml.notify_all(); \/\/ pause end\n+      }\n+    }\n+    if (n == 0) {\n+      log_debug(trimnative)(\"Trim resumed after %s\", reason);\n+    } else {\n+      log_debug(trimnative)(\"Trim still suspended after %s (%u suspend requests)\", reason, n);\n+    }\n+  }\n+\n+  void stop() {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    _stop = true;\n+    ml.notify_all();\n+  }\n+\n+  void print_state(outputStream* st) const {\n+    \/\/ Don't pull lock during error reporting\n+    Mutex* const lock = VMError::is_error_reported() ? nullptr : _lock;\n+    int64_t num_trims = 0;\n+    bool stopped = false;\n+    uint16_t suspenders = 0;\n+    {\n+      MutexLocker ml(lock, Mutex::_no_safepoint_check_flag);\n+      num_trims = _num_trims_performed;\n+      stopped = _stop;\n+      suspenders = _suspend_count;\n+    }\n+    st->print_cr(\"Trims performed: \" UINT64_FORMAT \", current suspend count: %d, stopped: %d\",\n+                 num_trims, suspenders, stopped);\n+  }\n+\n+}; \/\/ NativeHeapTrimmer\n+\n+static NativeHeapTrimmerThread* g_trimmer_thread = nullptr;\n+\n+void NativeHeapTrimmer::initialize() {\n+  assert(g_trimmer_thread == nullptr, \"Only once\");\n+  if (TrimNativeHeapInterval > 0) {\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(TrimNativeHeapInterval, 0);\n+      log_warning(trimnative)(\"Native heap trim is not supported on this platform\");\n+      return;\n+    }\n+    g_trimmer_thread = new NativeHeapTrimmerThread();\n+    log_info(trimnative)(\"Periodic native trim enabled (interval: %u ms)\", TrimNativeHeapInterval);\n+  }\n+}\n+\n+void NativeHeapTrimmer::cleanup() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->stop();\n+  }\n+}\n+\n+void NativeHeapTrimmer::suspend_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->suspend(reason);\n+  }\n+}\n+\n+void NativeHeapTrimmer::resume_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->resume(reason);\n+  }\n+}\n+\n+void NativeHeapTrimmer::print_state(outputStream* st) {\n+  if (g_trimmer_thread != nullptr) {\n+    st->print_cr(\"Periodic native trim enabled (interval: %u ms)\", TrimNativeHeapInterval);\n+    g_trimmer_thread->print_state(st);\n+  } else {\n+    st->print_cr(\"Periodic native trim disabled\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.cpp","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n+#define SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+class outputStream;\n+\n+class NativeHeapTrimmer : public AllStatic {\n+\n+  \/\/ Pause periodic trim (if enabled).\n+  static void suspend_periodic_trim(const char* reason);\n+\n+  \/\/ Unpause periodic trim (if enabled).\n+  static void resume_periodic_trim(const char* reason);\n+\n+public:\n+\n+  static void initialize();\n+  static void cleanup();\n+\n+  static inline bool enabled() { return TrimNativeHeapInterval > 0; }\n+\n+  static void print_state(outputStream* st);\n+\n+  \/\/ Pause periodic trimming while in scope; when leaving scope,\n+  \/\/ resume periodic trimming.\n+  struct SuspendMark {\n+    const char* const _reason;\n+    SuspendMark(const char* reason = \"unknown\") : _reason(reason) {\n+      if (NativeHeapTrimmer::enabled()) {\n+        suspend_periodic_trim(_reason);\n+      }\n+    }\n+    ~SuspendMark()  {\n+      if (NativeHeapTrimmer::enabled()) {\n+        resume_periodic_trim(_reason);\n+      }\n+    }\n+  };\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -892,1 +892,1 @@\n-  DirectivesParser::parse_from_file(_filename.value(), output());\n+  DirectivesParser::parse_from_file(_filename.value(), output(), true);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2119,0 +2119,1 @@\n+      assert(MonitoringSupport_lock != nullptr, \"Must be\");\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-    assert(0 <= i && i < _len, \"illegal index\");\n+    assert(0 <= i && i < _len, \"illegal index %d for length %d\", i, _len);\n@@ -152,1 +152,1 @@\n-    assert(0 <= i && i < _len, \"illegal index\");\n+    assert(0 <= i && i < _len, \"illegal index %d for length %d\", i, _len);\n@@ -157,1 +157,1 @@\n-    assert(0 <= i && i < _len, \"illegal index\");\n+    assert(0 <= i && i < _len, \"illegal index %d for length %d\", i, _len);\n@@ -189,1 +189,1 @@\n-    assert(0 <= i && i < _len, \"illegal index\");\n+    assert(0 <= i && i < _len, \"illegal index %d for length %d\", i, _len);\n@@ -250,1 +250,1 @@\n-    assert(0 <= index && index < _len, \"illegal index\");\n+    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n@@ -264,2 +264,2 @@\n-    assert(0 <= start, \"illegal index\");\n-    assert(start < end && end <= _len, \"erase called with invalid range\");\n+    assert(0 <= start, \"illegal start index %d\", start);\n+    assert(start < end && end <= _len, \"erase called with invalid range (%d, %d) for length %d\", start, end, _len);\n@@ -275,1 +275,1 @@\n-    assert(0 <= index && index < _len, \"illegal index\");\n+    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n@@ -408,1 +408,1 @@\n-    assert(0 <= i, \"negative index\");\n+    assert(0 <= i, \"negative index %d\", i);\n@@ -419,1 +419,1 @@\n-    assert(0 <= i, \"negative index\");\n+    assert(0 <= i, \"negative index %d\", i);\n@@ -431,1 +431,1 @@\n-    assert(0 <= idx && idx <= this->_len, \"illegal index\");\n+    assert(0 <= idx && idx <= this->_len, \"illegal index %d for length %d\", idx, this->_len);\n@@ -441,1 +441,1 @@\n-    assert(0 <= idx && idx <= this->_len, \"illegal index\");\n+    assert(0 <= idx && idx <= this->_len, \"illegal index %d for length %d\", idx, this->_len);\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -1292,0 +1293,1 @@\n+    st->cr();\n@@ -1293,1 +1295,2 @@\n-  STEP_IF(\"printing system\", _verbose)\n+  STEP_IF(\"printing periodic trim state\", _verbose)\n+    NativeHeapTrimmer::print_state(st);\n@@ -1295,0 +1298,2 @@\n+\n+  STEP_IF(\"printing system\", _verbose)\n@@ -1461,0 +1466,1 @@\n+  st->cr();\n@@ -1462,2 +1468,2 @@\n-  \/\/ STEP(\"printing system\")\n-\n+  \/\/ STEP(\"printing periodic trim state\")\n+  NativeHeapTrimmer::print_state(st);\n@@ -1465,0 +1471,3 @@\n+\n+\n+  \/\/ STEP(\"printing system\")\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-    int n = os::snprintf(buffer, sizeof(buffer), \"%.*s_done\", (int)kind_len, kind);\n+    int n = os::snprintf(buffer, sizeof(buffer), \"%.*s_done%s\", (int)kind_len, kind, kind + kind_len);\n@@ -364,1 +364,1 @@\n-    int n = os::snprintf(buffer, sizeof(buffer), \"%s_done%s\", kind, kind + kind_len);\n+    int n = os::snprintf(buffer, sizeof(buffer), \"%s_done\", kind);\n","filename":"src\/hotspot\/share\/utilities\/xmlstream.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -347,0 +347,17 @@\n+    \/**\n+     * {@return {@code true} if the {@code Console} instance is a terminal}\n+     * <p>\n+     * This method returns {@code true} if the console device, associated with the current\n+     * Java virtual machine, is a terminal, typically an interactive command line\n+     * connected to a keyboard and display.\n+     *\n+     * @implNote The default implementation returns the value equivalent to calling\n+     * {@code isatty(stdin\/stdout)} on POSIX platforms, or whether standard in\/out file\n+     * descriptors are character devices or not on Windows.\n+     *\n+     * @since 22\n+     *\/\n+    public boolean isTerminal() {\n+        return istty;\n+    }\n+\n@@ -353,0 +370,1 @@\n+    private static final boolean istty = istty();\n@@ -356,1 +374,0 @@\n-        boolean istty = istty();\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+        var sink = this.sink;\n","filename":"src\/java.base\/share\/classes\/java\/io\/PipedOutputStream.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,4 @@\n-    private final Object readLock;\n-    private final Object writeLock;\n-    private final Reader reader;\n-    private final PrintWriter printWriter;\n+    private final Object readLock = new Object();\n+    private final Object writeLock = new Object();\n+    private volatile Reader reader;\n+    private volatile PrintWriter printWriter;\n@@ -44,4 +44,0 @@\n-        readLock = new Object();\n-        writeLock = new Object();\n-        reader = new WrappingReader(delegate.reader(), readLock);\n-        printWriter = new WrappingWriter(delegate.writer(), writeLock);\n@@ -55,0 +51,10 @@\n+        PrintWriter printWriter = this.printWriter;\n+        if (printWriter == null) {\n+            synchronized (this) {\n+                printWriter = this.printWriter;\n+                if (printWriter == null) {\n+                    printWriter = new WrappingWriter(delegate.writer(), writeLock);\n+                    this.printWriter = printWriter;\n+                }\n+            }\n+        }\n@@ -63,0 +69,10 @@\n+        Reader reader = this.reader;\n+        if (reader == null) {\n+            synchronized (this) {\n+                reader = this.reader;\n+                if (reader == null) {\n+                    reader = new WrappingReader(delegate.reader(), readLock);\n+                    this.reader = reader;\n+                }\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ProxyingConsole.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-        return handleFactory.apply(AccessMode.values()[mode], targetHandle);\n+        return handleFactory.apply(AccessMode.valueFromOrdinal(mode), targetHandle);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/IndirectVarHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,8 @@\n-import java.lang.reflect.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.ref.WeakReference;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.UndeclaredThrowableException;\n@@ -31,0 +38,10 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n@@ -34,3 +51,6 @@\n-import sun.invoke.WrapperInstance;\n-import java.util.ArrayList;\n-\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.misc.ValhallaFeatures;\n+import jdk.internal.module.Modules;\n@@ -39,0 +59,1 @@\n+import jdk.internal.util.ClassFileDumper;\n@@ -40,0 +61,2 @@\n+\n+import static java.lang.constant.ConstantDescs.*;\n@@ -41,0 +64,3 @@\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.lang.module.ModuleDescriptor.Modifier.SYNTHETIC;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -64,1 +90,2 @@\n-     * The interface must be public and not {@linkplain Class#isSealed() sealed}.\n+     * The interface must be public, not {@linkplain Class#isHidden() hidden},\n+     * and not {@linkplain Class#isSealed() sealed}.\n@@ -136,23 +163,1 @@\n-    \/\/ Other notes to implementors:\n-    \/\/ <p>\n-    \/\/ No stable mapping is promised between the single-method interface and\n-    \/\/ the implementation class C.  Over time, several implementation\n-    \/\/ classes might be used for the same type.\n-    \/\/ <p>\n-    \/\/ If the implementation is able\n-    \/\/ to prove that a wrapper of the required type\n-    \/\/ has already been created for a given\n-    \/\/ method handle, or for another method handle with the\n-    \/\/ same behavior, the implementation may return that wrapper in place of\n-    \/\/ a new wrapper.\n-    \/\/ <p>\n-    \/\/ This method is designed to apply to common use cases\n-    \/\/ where a single method handle must interoperate with\n-    \/\/ an interface that implements a function-like\n-    \/\/ API.  Additional variations, such as single-abstract-method classes with\n-    \/\/ private constructors, or interfaces with multiple but related\n-    \/\/ entry points, must be covered by hand-written or automatically\n-    \/\/ generated adapter classes.\n-    \/\/\n-    @SuppressWarnings({\"removal\",\n-                       \"doclint:reference\"}) \/\/ cross-module links\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -165,0 +170,3 @@\n+        if (intfc.isHidden())\n+            throw newIllegalArgumentException(\"a hidden interface\", intfc.getName());\n+        Objects.requireNonNull(target);\n@@ -166,1 +174,3 @@\n-        if (System.getSecurityManager() != null) {\n+        @SuppressWarnings(\"removal\")\n+        var sm = System.getSecurityManager();\n+        if (sm != null) {\n@@ -174,4 +184,27 @@\n-        ClassLoader proxyLoader = intfc.getClassLoader();\n-        if (proxyLoader == null) {\n-            ClassLoader cl = Thread.currentThread().getContextClassLoader(); \/\/ avoid use of BCP\n-            proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();\n+\n+        \/\/ Define one hidden class for each interface.  Create an instance of\n+        \/\/ the hidden class for a given target method handle which will be\n+        \/\/ accessed via getfield.  Multiple instances may be created for a\n+        \/\/ hidden class.  This approach allows the generated hidden classes\n+        \/\/ more shareable.\n+        \/\/\n+        \/\/ The implementation class is weakly referenced; a new class is\n+        \/\/ defined if the last one has been garbage collected.\n+        \/\/\n+        \/\/ An alternative approach is to define one hidden class with the\n+        \/\/ target method handle as class data and the target method handle\n+        \/\/ is loaded via ldc\/condy.  If more than one target method handles\n+        \/\/ are used, the extra classes will pollute the same type profiles.\n+        \/\/ In addition, hidden classes without class data is more friendly\n+        \/\/ for pre-generation (shifting the dynamic class generation from\n+        \/\/ runtime to an earlier phrase).\n+        Class<?> proxyClass = getProxyClass(intfc);  \/\/ throws IllegalArgumentException\n+        Lookup lookup = new Lookup(proxyClass);\n+        Object proxy;\n+        try {\n+            MethodHandle constructor = lookup.findConstructor(proxyClass,\n+                                                              MT_void_Lookup_MethodHandle_MethodHandle)\n+                                             .asType(MT_Object_Lookup_MethodHandle_MethodHandle);\n+            proxy = constructor.invokeExact(lookup, target, mh);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n@@ -179,10 +212,14 @@\n-        final Method[] methods = getSingleNameMethods(intfc);\n-        if (methods == null)\n-            throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n-        final MethodHandle[] vaTargets = new MethodHandle[methods.length];\n-        for (int i = 0; i < methods.length; i++) {\n-            Method sm = methods[i];\n-            MethodType smMT = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());\n-            MethodHandle checkTarget = mh.asType(smMT);  \/\/ make throw WMT\n-            checkTarget = checkTarget.asType(checkTarget.type().changeReturnType(Object.class));\n-            vaTargets[i] = checkTarget.asSpreader(Object[].class, smMT.parameterCount());\n+        assert proxy.getClass().getModule().isNamed() : proxy.getClass() + \" \" + proxy.getClass().getModule();\n+        return intfc.cast(proxy);\n+    }\n+\n+    private record MethodInfo(MethodTypeDesc desc, List<ClassDesc> thrown, String fieldName) {}\n+\n+    private static final ClassFileDumper DUMPER = ClassFileDumper.getInstance(\n+            \"jdk.invoke.MethodHandleProxies.dumpClassFiles\", \"DUMP_MH_PROXY_CLASSFILES\");\n+\n+    private static final Set<Class<?>> WRAPPER_TYPES = Collections.newSetFromMap(new WeakHashMap<>());\n+    private static final ClassValue<WeakReferenceHolder<Class<?>>> PROXIES = new ClassValue<>() {\n+        @Override\n+        protected WeakReferenceHolder<Class<?>> computeValue(Class<?> intfc) {\n+            return new WeakReferenceHolder<>(newProxyClass(intfc));\n@@ -190,36 +227,68 @@\n-        final InvocationHandler ih = new InvocationHandler() {\n-                private Object getArg(String name) {\n-                    if ((Object)name == \"getWrapperInstanceTarget\")  return target;\n-                    if ((Object)name == \"getWrapperInstanceType\")    return intfc;\n-                    throw new AssertionError();\n-                }\n-                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                    for (int i = 0; i < methods.length; i++) {\n-                        if (method.equals(methods[i]))\n-                            return vaTargets[i].invokeExact(args);\n-                    }\n-                    if (method.getDeclaringClass() == WrapperInstance.class)\n-                        return getArg(method.getName());\n-                    if (isObjectMethod(method))\n-                        return callObjectMethod(proxy, method, args);\n-                    if (isDefaultMethod(method)) {\n-                        \/\/ no additional access check is performed\n-                        return JLRA.invokeDefault(proxy, method, args, null);\n-                    }\n-                    throw newInternalError(\"bad proxy method: \"+method);\n-                }\n-            };\n-\n-        final Object proxy;\n-        if (System.getSecurityManager() != null) {\n-            \/\/ sun.invoke.WrapperInstance is a restricted interface not accessible\n-            \/\/ by any non-null class loader.\n-            final ClassLoader loader = proxyLoader;\n-            proxy = AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Object run() {\n-                    return Proxy.newProxyInstance(\n-                            loader,\n-                            new Class<?>[]{ intfc, WrapperInstance.class },\n-                            ih);\n-                }\n-            });\n+    };\n+\n+    private static Class<?> newProxyClass(Class<?> intfc) {\n+        List<MethodInfo> methods = new ArrayList<>();\n+        Set<Class<?>> referencedTypes = new HashSet<>();\n+        referencedTypes.add(intfc);\n+        String uniqueName = null;\n+        int count = 0;\n+        for (Method m : intfc.getMethods()) {\n+            if (!Modifier.isAbstract(m.getModifiers()))\n+                continue;\n+\n+            if (isObjectMethod(m))\n+                continue;\n+\n+            \/\/ ensure it's SAM interface\n+            String methodName = m.getName();\n+            if (uniqueName == null) {\n+                uniqueName = methodName;\n+            } else if (!uniqueName.equals(methodName)) {\n+                \/\/ too many abstract methods\n+                throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n+            }\n+\n+            \/\/ the field name holding the method handle for this method\n+            String fieldName = \"m\" + count++;\n+            var mt = methodType(m.getReturnType(), JLRA.getExecutableSharedParameterTypes(m), true);\n+            var thrown = JLRA.getExecutableSharedExceptionTypes(m);\n+            var exceptionTypeDescs =\n+                    thrown.length == 0 ? DEFAULT_RETHROWS\n+                                       : Stream.concat(DEFAULT_RETHROWS.stream(),\n+                                                       Arrays.stream(thrown).map(MethodHandleProxies::desc))\n+                                               .distinct().toList();\n+            methods.add(new MethodInfo(desc(mt), exceptionTypeDescs, fieldName));\n+\n+            \/\/ find the types referenced by this method\n+            addElementType(referencedTypes, m.getReturnType());\n+            addElementTypes(referencedTypes, JLRA.getExecutableSharedParameterTypes(m));\n+            addElementTypes(referencedTypes, JLRA.getExecutableSharedExceptionTypes(m));\n+        }\n+\n+        if (uniqueName == null)\n+            throw newIllegalArgumentException(\"no method in \", intfc.getName());\n+\n+        \/\/ create a dynamic module for each proxy class, which needs access\n+        \/\/ to the types referenced by the members of the interface including\n+        \/\/ the parameter types, return type and exception types\n+        var loader = intfc.getClassLoader();\n+        Module targetModule = newDynamicModule(loader, referencedTypes);\n+\n+        \/\/ generate a class file in the package of the dynamic module\n+        String packageName = targetModule.getName();\n+        String intfcName = intfc.getName();\n+        int i = intfcName.lastIndexOf('.');\n+        \/\/ jdk.MHProxy#.Interface\n+        String className = packageName + \".\" + (i > 0 ? intfcName.substring(i + 1) : intfcName);\n+        byte[] template = createTemplate(loader, ClassDesc.of(className), desc(intfc), uniqueName, methods);\n+        \/\/ define the dynamic module to the class loader of the interface\n+        var definer = new Lookup(intfc).makeHiddenClassDefiner(className, template, Set.of(), DUMPER);\n+\n+        @SuppressWarnings(\"removal\")\n+        var sm = System.getSecurityManager();\n+        Lookup lookup;\n+        if (sm != null) {\n+            @SuppressWarnings(\"removal\")\n+            var l = AccessController.doPrivileged((PrivilegedAction<Lookup>) () ->\n+                    definer.defineClassAsLookup(true));\n+            lookup = l;\n@@ -227,3 +296,1 @@\n-            proxy = Proxy.newProxyInstance(proxyLoader,\n-                                           new Class<?>[]{ intfc, WrapperInstance.class },\n-                                           ih);\n+            lookup = definer.defineClassAsLookup(true);\n@@ -231,1 +298,178 @@\n-        return intfc.cast(proxy);\n+        \/\/ cache the wrapper type\n+        var ret = lookup.lookupClass();\n+        WRAPPER_TYPES.add(ret);\n+        return ret;\n+    }\n+\n+    private static final class WeakReferenceHolder<T> {\n+        private volatile WeakReference<T> ref;\n+\n+        WeakReferenceHolder(T value) {\n+            set(value);\n+        }\n+\n+        void set(T value) {\n+            ref = new WeakReference<>(value);\n+        }\n+\n+        T get() {\n+            return ref.get();\n+        }\n+    }\n+\n+    private static Class<?> getProxyClass(Class<?> intfc) {\n+        WeakReferenceHolder<Class<?>> r = PROXIES.get(intfc);\n+        Class<?> cl = r.get();\n+        if (cl != null)\n+            return cl;\n+\n+        \/\/ avoid spinning multiple classes in a race\n+        synchronized (r) {\n+            cl = r.get();\n+            if (cl != null)\n+                return cl;\n+\n+            \/\/ If the referent is cleared, create a new value and update cached weak reference.\n+            cl = newProxyClass(intfc);\n+            r.set(cl);\n+            return cl;\n+        }\n+    }\n+\n+    private static final List<ClassDesc> DEFAULT_RETHROWS = List.of(desc(RuntimeException.class), desc(Error.class));\n+    private static final ClassDesc CD_UndeclaredThrowableException = desc(UndeclaredThrowableException.class);\n+    private static final ClassDesc CD_IllegalAccessException = desc(IllegalAccessException.class);\n+    private static final MethodTypeDesc MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable);\n+    private static final MethodType MT_void_Lookup_MethodHandle_MethodHandle =\n+            methodType(void.class, Lookup.class, MethodHandle.class, MethodHandle.class);\n+    private static final MethodType MT_Object_Lookup_MethodHandle_MethodHandle =\n+            MT_void_Lookup_MethodHandle_MethodHandle.changeReturnType(Object.class);\n+    private static final MethodType MT_MethodHandle_Object = methodType(MethodHandle.class, Object.class);\n+    private static final MethodTypeDesc MTD_void_Lookup_MethodHandle_MethodHandle =\n+            desc(MT_void_Lookup_MethodHandle_MethodHandle);\n+    private static final MethodTypeDesc MTD_void_Lookup = MethodTypeDesc.of(CD_void, CD_MethodHandles_Lookup);\n+    private static final MethodTypeDesc MTD_MethodHandle_MethodType = MethodTypeDesc.of(CD_MethodHandle, CD_MethodType);\n+    private static final MethodTypeDesc MTD_Class = MethodTypeDesc.of(CD_Class);\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MTD_String = MethodTypeDesc.of(CD_String);\n+    private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+    private static final String TARGET_NAME = \"target\";\n+    private static final String TYPE_NAME = \"interfaceType\";\n+    private static final String ENSURE_ORIGINAL_LOOKUP = \"ensureOriginalLookup\";\n+\n+    \/**\n+     * Creates an implementation class file for a given interface. One implementation class is\n+     * defined for each interface.\n+     *\n+     * @param ifaceDesc the given interface\n+     * @param methodName the name of the single abstract method\n+     * @param methods the information for implementation methods\n+     * @return the bytes of the implementation classes\n+     *\/\n+    private static byte[] createTemplate(ClassLoader loader, ClassDesc proxyDesc, ClassDesc ifaceDesc,\n+                                         String methodName, List<MethodInfo> methods) {\n+        return Classfile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader)))\n+                        .build(proxyDesc, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags((ValhallaFeatures.isEnabled() ? ACC_IDENTITY : 0) | ACC_FINAL | ACC_SYNTHETIC);\n+            clb.withInterfaceSymbols(ifaceDesc);\n+\n+            \/\/ static and instance fields\n+            clb.withField(TYPE_NAME, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+            clb.withField(TARGET_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            for (var mi : methods) {\n+                clb.withField(mi.fieldName, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            }\n+\n+            \/\/ <clinit>\n+            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                cob.constantInstruction(ifaceDesc);\n+                cob.putstatic(proxyDesc, TYPE_NAME, CD_Class);\n+                cob.return_();\n+            });\n+\n+            \/\/ <init>(Lookup, MethodHandle target, MethodHandle callerBoundTarget)\n+            clb.withMethodBody(INIT_NAME, MTD_void_Lookup_MethodHandle_MethodHandle, 0, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+\n+                \/\/ call ensureOriginalLookup to verify the given Lookup has access\n+                cob.aload(1);\n+                cob.invokestatic(proxyDesc, \"ensureOriginalLookup\", MTD_void_Lookup);\n+\n+                \/\/ this.target = target;\n+                cob.aload(0);\n+                cob.aload(2);\n+                cob.putfield(proxyDesc, TARGET_NAME, CD_MethodHandle);\n+\n+                \/\/ method handles adjusted to the method type of each method\n+                for (var mi : methods) {\n+                    \/\/ this.m<i> = callerBoundTarget.asType(xxType);\n+                    cob.aload(0);\n+                    cob.aload(3);\n+                    cob.constantInstruction(mi.desc);\n+                    cob.invokevirtual(CD_MethodHandle, \"asType\", MTD_MethodHandle_MethodType);\n+                    cob.putfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                }\n+\n+                \/\/ complete\n+                cob.return_();\n+            });\n+\n+            \/\/ private static void ensureOriginalLookup(Lookup) checks if the given Lookup\n+            \/\/ has ORIGINAL access to this class, i.e. the lookup class is this class;\n+            \/\/ otherwise, IllegalAccessException is thrown\n+            clb.withMethodBody(ENSURE_ORIGINAL_LOOKUP, MTD_void_Lookup, ACC_PRIVATE | ACC_STATIC, cob -> {\n+                var failLabel = cob.newLabel();\n+                \/\/ check lookupClass\n+                cob.aload(0);\n+                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class);\n+                cob.constantInstruction(proxyDesc);\n+                cob.if_acmpne(failLabel);\n+                \/\/ check original access\n+                cob.aload(0);\n+                cob.invokevirtual(CD_MethodHandles_Lookup, \"lookupModes\", MTD_int);\n+                cob.constantInstruction(Lookup.ORIGINAL);\n+                cob.iand();\n+                cob.ifeq(failLabel);\n+                \/\/ success\n+                cob.return_();\n+                \/\/ throw exception\n+                cob.labelBinding(failLabel);\n+                cob.new_(CD_IllegalAccessException);\n+                cob.dup();\n+                cob.aload(0); \/\/ lookup\n+                cob.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                cob.invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String);\n+                cob.athrow();\n+            });\n+\n+            \/\/ implementation methods\n+            for (MethodInfo mi : methods) {\n+                \/\/ no need to generate thrown exception attribute\n+                clb.withMethodBody(methodName, mi.desc, ACC_PUBLIC, cob -> cob\n+                        .trying(bcb -> {\n+                                    \/\/ return this.handleField.invokeExact(arguments...);\n+                                    bcb.aload(0);\n+                                    bcb.getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                                    for (int j = 0; j < mi.desc.parameterCount(); j++) {\n+                                        bcb.loadInstruction(TypeKind.from(mi.desc.parameterType(j)),\n+                                                bcb.parameterSlot(j));\n+                                    }\n+                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", mi.desc);\n+                                    bcb.returnInstruction(TypeKind.from(mi.desc.returnType()));\n+                                }, ctb -> ctb\n+                                        \/\/ catch (Error | RuntimeException | Declared ex) { throw ex; }\n+                                        .catchingMulti(mi.thrown, CodeBuilder::athrow)\n+                                        \/\/ catch (Throwable ex) { throw new UndeclaredThrowableException(ex); }\n+                                        .catchingAll(cb -> cb\n+                                                .new_(CD_UndeclaredThrowableException)\n+                                                .dup_x1()\n+                                                .swap()\n+                                                .invokespecial(CD_UndeclaredThrowableException,\n+                                                        INIT_NAME, MTD_void_Throwable)\n+                                                .athrow()\n+                                        )\n+                        ));\n+            }\n+        });\n@@ -244,10 +488,1 @@\n-        return x instanceof WrapperInstance;\n-    }\n-\n-    private static WrapperInstance asWrapperInstance(Object x) {\n-        try {\n-            if (x != null)\n-                return (WrapperInstance) x;\n-        } catch (ClassCastException ex) {\n-        }\n-        throw newIllegalArgumentException(\"not a wrapper instance\");\n+        return x != null && WRAPPER_TYPES.contains(x.getClass());\n@@ -266,1 +501,11 @@\n-        return asWrapperInstance(x).getWrapperInstanceTarget();\n+        if (!isWrapperInstance(x))\n+            throw new IllegalArgumentException(\"not a wrapper instance: \" + x);\n+\n+        try {\n+            Class<?> type = x.getClass();\n+            MethodHandle getter = new Lookup(type).findGetter(type, TARGET_NAME, MethodHandle.class)\n+                                                  .asType(MT_MethodHandle_Object);\n+            return (MethodHandle) getter.invokeExact(x);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n@@ -278,1 +523,55 @@\n-        return asWrapperInstance(x).getWrapperInstanceType();\n+        if (!isWrapperInstance(x))\n+            throw new IllegalArgumentException(\"not a wrapper instance: \" + x);\n+\n+        try {\n+            Class<?> type = x.getClass();\n+            MethodHandle originalTypeField = new Lookup(type).findStaticGetter(type, TYPE_NAME, Class.class);\n+            return (Class<?>) originalTypeField.invokeExact();\n+        } catch (Throwable e) {\n+            throw uncaughtException(e);\n+        }\n+    }\n+\n+    private static ClassDesc desc(Class<?> cl) {\n+        return cl.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert class \"\n+                + cl.getName() + \" to a constant\"));\n+    }\n+\n+    private static MethodTypeDesc desc(MethodType mt) {\n+        return mt.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert method type \"\n+                + mt + \" to a constant\"));\n+    }\n+\n+    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n+    private static final AtomicInteger counter = new AtomicInteger();\n+\n+    private static String nextModuleName() {\n+        return \"jdk.MHProxy\" + counter.incrementAndGet();\n+    }\n+\n+    \/**\n+     * Create a dynamic module defined to the given class loader and has\n+     * access to the given types.\n+     * <p>\n+     * The dynamic module contains only one single package named the same as\n+     * the name of the dynamic module.  It's not exported or open.\n+     *\/\n+    private static Module newDynamicModule(ClassLoader ld, Set<Class<?>> types) {\n+        Objects.requireNonNull(types);\n+\n+        \/\/ create a dynamic module and setup module access\n+        String mn = nextModuleName();\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n+                .packages(Set.of(mn))\n+                .build();\n+\n+        Module dynModule = Modules.defineModule(ld, descriptor, null);\n+        Module javaBase = Object.class.getModule();\n+\n+        Modules.addReads(dynModule, javaBase);\n+        Modules.addOpens(dynModule, mn, javaBase);\n+\n+        for (Class<?> c : types) {\n+            ensureAccess(dynModule, c);\n+        }\n+        return dynModule;\n@@ -284,1 +583,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -286,1 +585,1 @@\n-                               && m.getParameterCount() == 0;\n+                    && m.getParameterCount() == 0;\n@@ -288,2 +587,2 @@\n-                               && m.getParameterCount() == 1\n-                               && m.getParameterTypes()[0] == Object.class;\n+                    && m.getParameterCount() == 1\n+                    && JLRA.getExecutableSharedParameterTypes(m)[0] == Object.class;\n@@ -294,8 +593,13 @@\n-    private static Object callObjectMethod(Object self, Method m, Object[] args) {\n-        assert(isObjectMethod(m)) : m;\n-        return switch (m.getName()) {\n-            case \"toString\" -> java.util.Objects.toIdentityString(self);\n-            case \"hashCode\" -> System.identityHashCode(self);\n-            case \"equals\"   -> (self == args[0]);\n-            default -> null;\n-        };\n+    \/*\n+     * Ensure the given module can access the given class.\n+     *\/\n+    private static void ensureAccess(Module target, Class<?> c) {\n+        Module m = c.getModule();\n+        \/\/ add read edge and qualified export for the target module to access\n+        if (!target.canRead(m)) {\n+            Modules.addReads(target, m);\n+        }\n+        String pn = c.getPackageName();\n+        if (!m.isExported(pn, target)) {\n+            Modules.addExports(m, pn, target);\n+        }\n@@ -304,12 +608,3 @@\n-    private static Method[] getSingleNameMethods(Class<?> intfc) {\n-        ArrayList<Method> methods = new ArrayList<>();\n-        String uniqueName = null;\n-        for (Method m : intfc.getMethods()) {\n-            if (isObjectMethod(m))  continue;\n-            if (!Modifier.isAbstract(m.getModifiers()))  continue;\n-            String mname = m.getName();\n-            if (uniqueName == null)\n-                uniqueName = mname;\n-            else if (!uniqueName.equals(mname))\n-                return null;  \/\/ too many abstract methods\n-            methods.add(m);\n+    private static void addElementTypes(Set<Class<?>> types, Class<?>... classes) {\n+        for (var cls : classes) {\n+            addElementType(types, cls);\n@@ -317,2 +612,0 @@\n-        if (uniqueName == null)  return null;\n-        return methods.toArray(new Method[methods.size()]);\n@@ -321,3 +614,5 @@\n-    private static boolean isDefaultMethod(Method m) {\n-        return !Modifier.isAbstract(m.getModifiers());\n-    }\n+    private static void addElementType(Set<Class<?>> types, Class<?> cls) {\n+        Class<?> e = cls;\n+        while (e.isArray()) {\n+            e = e.getComponentType();\n+        }\n@@ -325,1 +620,4 @@\n-    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n+        if (!e.isPrimitive()) {\n+            types.add(e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":424,"deletions":126,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.Hidden;\n@@ -111,0 +112,1 @@\n+    @Hidden\n@@ -118,1 +120,1 @@\n-                throw new UnsupportedOperationException();\n+                throw new UnsupportedOperationException(AccessMode.valueFromOrdinal(mode).methodName());\n@@ -135,1 +137,1 @@\n-        AccessMode value = AccessMode.values()[mode];\n+        AccessMode value = AccessMode.valueFromOrdinal(mode);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarForm.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2016,0 +2016,5 @@\n+\n+        private static final @Stable AccessMode[] VALUES = values();\n+        static AccessMode valueFromOrdinal(int mode) {\n+            return VALUES[mode];\n+        }\n@@ -2228,1 +2233,1 @@\n-        MethodType mt = accessModeType(AccessMode.values()[mode]).\n+        MethodType mt = accessModeType(AccessMode.valueFromOrdinal(mode)).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,4 @@\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex) {\n+        return ex.getSharedExceptionTypes();\n+    }\n+\n@@ -130,5 +134,0 @@\n-\n-    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n-            throws Throwable {\n-        return Proxy.invokeDefault(proxy, method, args, caller);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -263,2 +263,4 @@\n-     * its I\/O operations to the given stream.  Closing the channel will in\n-     * turn cause the stream to be closed.  <\/p>\n+     * its I\/O operations to the given stream. Reading from the resulting\n+     * channel will read from the input stream and thus block until input is\n+     * available or end of file is reached. Closing the channel will in turn\n+     * cause the stream to be closed.  <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -519,0 +519,84 @@\n+    \/**\n+     * Resolves a path against this path, and then iteratively resolves any\n+     * additional paths.\n+     *\n+     * <p> This method resolves {@code first} against this {@code Path} as if\n+     * by calling {@link #resolve(Path)}. If {@code more} has one or more\n+     * elements then it resolves the first element against the result, then\n+     * iteratively resolves all subsequent elements. This method returns the\n+     * result from the final resolve.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent to the result obtained with:\n+     * {@snippet lang=java :\n+     *     Path result = resolve(first);\n+     *     for (Path p : more) {\n+     *         result = result.resolve(p);\n+     *     }\n+     * }\n+     *\n+     * @param   first\n+     *          the first path to resolve against this path\n+     * @param   more\n+     *          additional paths to iteratively resolve\n+     *\n+     * @return  the resulting path\n+     *\n+     * @see #resolve(Path)\n+     * @since 22\n+     *\/\n+    default Path resolve(Path first, Path... more) {\n+        Path result = resolve(first);\n+        for (Path p : more) {\n+            result = result.resolve(p);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Converts a path string to a path, resolves that path against this path,\n+     * and then iteratively performs the same procedure for any additional\n+     * path strings.\n+     *\n+     * <p> This method converts {@code first} to a {@code Path} and resolves\n+     * that {@code Path} against this {@code Path} as if by calling\n+     * {@link #resolve(String)}. If {@code more} has one or more elements\n+     * then it converts the first element to a path, resolves that path against\n+     * the result, then iteratively converts and resolves all subsequent\n+     * elements. This method returns the result from the final resolve.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent to the result obtained with:\n+     * {@snippet lang=java :\n+     * Path result = resolve(first);\n+     * for (String s : more) {\n+     *     result = result.resolve(s);\n+     * }\n+     * }\n+     *\n+     * @param   first\n+     *          the first path string to convert to a path and\n+     *          resolve against this path\n+     *\n+     * @param   more\n+     *          additional path strings to be iteratively converted to\n+     *          paths and resolved\n+     *\n+     * @return  the resulting path\n+     *\n+     * @throws  InvalidPathException\n+     *          if a path string cannot be converted to a Path.\n+     *\n+     * @see #resolve(Path,Path...)\n+     * @see #resolve(String)\n+     *\n+     * @since 22\n+     *\/\n+    default Path resolve(String first, String... more) {\n+        Path result = resolve(first);\n+        for (String s : more) {\n+            result = result.resolve(s);\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -394,0 +394,7 @@\n+     * @implSpec The default implementation throws a\n+     * {@code NullPointerException} if {@code locale} is {@code null}\n+     * either during the creation of the {@code MessageFormat} object or later\n+     * when {@code format()} is called by a {@code MessageFormat}\n+     * instance with a null locale and the implementation utilizes a\n+     * locale-dependent subformat.\n+     *\n@@ -398,1 +405,2 @@\n-     *            {@code null}\n+     *            {@code null} or {@code locale} is {@code null} and the\n+     *            implementation uses a locale-dependent subformat.\n@@ -847,1 +855,4 @@\n-     * @throws    NullPointerException if {@code result} is {@code null}\n+     * @throws    NullPointerException if {@code result} is {@code null} or\n+     *            if the {@code MessageFormat} instance that calls this method\n+     *            has locale set to null, and the implementation\n+     *            uses a locale-dependent subformat.\n@@ -893,1 +904,4 @@\n-     * @throws    NullPointerException if {@code result} is {@code null}\n+     * @throws    NullPointerException if {@code result} is {@code null} or\n+     *            if the {@code MessageFormat} instance that calls this method\n+     *            has locale set to null, and the implementation\n+     *            uses a locale-dependent subformat.\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import jdk.internal.util.ArraysSupport;\n+\n@@ -1018,2 +1020,4 @@\n-     * Returns the hash code value for this bit set. The hash code depends\n-     * only on which bits are set within this {@code BitSet}.\n+     * {@return the hash code value for this bit set}\n+     *\n+     * The hash code depends only on which bits are set within this\n+     * {@code BitSet}.\n@@ -1032,2 +1036,0 @@\n-     *\n-     * @return the hash code value for this bit set\n@@ -1035,0 +1037,1 @@\n+    @Override\n@@ -1055,1 +1058,1 @@\n-     * Compares this object against the specified object.\n+     * Compares this bit set against the specified object.\n@@ -1068,0 +1071,1 @@\n+    @Override\n@@ -1069,2 +1073,0 @@\n-        if (!(obj instanceof BitSet set))\n-            return false;\n@@ -1073,0 +1075,2 @@\n+        if (!(obj instanceof BitSet set))\n+            return false;\n@@ -1081,5 +1085,1 @@\n-        for (int i = 0; i < wordsInUse; i++)\n-            if (words[i] != set.words[i])\n-                return false;\n-\n-        return true;\n+        return ArraysSupport.mismatch(words, 0, set.words, 0, wordsInUse) == -1;\n","filename":"src\/java.base\/share\/classes\/java\/util\/BitSet.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -425,4 +425,1 @@\n-    private static JavaLangAccess LANG_ACCESS;\n-    static {\n-        LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n-    }\n+    private static final JavaLangAccess LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n","filename":"src\/java.base\/share\/classes\/java\/util\/ServiceLoader.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.concurrent.ForkJoinWorkerThread;\n@@ -110,1 +111,5 @@\n-     * dictated by callers.\n+     * dictated by callers. All enqueue\/dequeue operations can be\n+     * handled by a single method (here, \"xfer\") with parameters\n+     * indicating whether to act as some form of offer, put, poll,\n+     * take, or transfer (each possibly with timeout), as described\n+     * below.\n@@ -129,7 +134,4 @@\n-     * tail pointers. This has led to the development of\n-     * contention-reducing variants such as elimination arrays (see\n-     * Moir et al http:\/\/portal.acm.org\/citation.cfm?id=1074013) and\n-     * optimistic back pointers (see Ladan-Mozes & Shavit\n-     * http:\/\/people.csail.mit.edu\/edya\/publications\/OptimisticFIFOQueue-journal.pdf).\n-     * However, the nature of dual queues enables a simpler tactic for\n-     * improving M&S-style implementations when dual-ness is needed.\n+     * tail pointers. To address these, dual queues with slack differ\n+     * from plain M&S dual queues by virtue of only sometimes updating\n+     * head or tail pointers when matching, appending, or even\n+     * traversing nodes.\n@@ -138,29 +140,21 @@\n-     * status. While there are other possible variants, we implement\n-     * this here as: for a data-mode node, matching entails CASing an\n-     * \"item\" field from a non-null data value to null upon match, and\n-     * vice-versa for request nodes, CASing from null to a data\n-     * value. (Note that the linearization properties of this style of\n-     * queue are easy to verify -- elements are made available by\n-     * linking, and unavailable by matching.) Compared to plain M&S\n-     * queues, this property of dual queues requires one additional\n-     * successful atomic operation per enq\/deq pair. But it also\n-     * enables lower cost variants of queue maintenance mechanics. (A\n-     * variation of this idea applies even for non-dual queues that\n-     * support deletion of interior elements, such as\n-     * j.u.c.ConcurrentLinkedQueue.)\n-     *\n-     * Once a node is matched, its match status can never again\n-     * change.  We may thus arrange that the linked list of them\n-     * contain a prefix of zero or more matched nodes, followed by a\n-     * suffix of zero or more unmatched nodes. (Note that we allow\n-     * both the prefix and suffix to be zero length, which in turn\n-     * means that we do not use a dummy header.)  If we were not\n-     * concerned with either time or space efficiency, we could\n-     * correctly perform enqueue and dequeue operations by traversing\n-     * from a pointer to the initial node; CASing the item of the\n-     * first unmatched node on match and CASing the next field of the\n-     * trailing node on appends.  While this would be a terrible idea\n-     * in itself, it does have the benefit of not requiring ANY atomic\n-     * updates on head\/tail fields.\n-     *\n-     * We introduce here an approach that lies between the extremes of\n+     * status. Matching entails CASing an \"item\" field from a non-null\n+     * data value to null upon match, and vice-versa for request\n+     * nodes, CASing from null to a data value.  (To reduce the need\n+     * for re-reads, we use the compareAndExchange forms of CAS for\n+     * pointer updates, that provide the current value to continue\n+     * with on failure.)  Note that the linearization properties of\n+     * this style of queue are easy to verify -- elements are made\n+     * available by linking, and unavailable by matching. Compared to\n+     * plain M&S queues, this property of dual queues requires one\n+     * additional successful atomic operation per enq\/deq pair. But it\n+     * also enables lower cost variants of queue maintenance\n+     * mechanics.\n+     *\n+     * Once a node is matched, it is no longer live -- its match\n+     * status can never again change.  We may thus arrange that the\n+     * linked list of them contain a prefix of zero or more dead\n+     * nodes, followed by a suffix of zero or more live nodes. Note\n+     * that we allow both the prefix and suffix to be zero length,\n+     * which in turn means that we do not require a dummy header.\n+     *\n+     * We use here an approach that lies between the extremes of\n@@ -181,34 +175,13 @@\n-     * similarly for \"tail\") is an empirical matter. We have found\n-     * that using very small constants in the range of 1-3 work best\n-     * over a range of platforms. Larger values introduce increasing\n-     * costs of cache misses and risks of long traversal chains, while\n-     * smaller values increase CAS contention and overhead.\n-     *\n-     * Dual queues with slack differ from plain M&S dual queues by\n-     * virtue of only sometimes updating head or tail pointers when\n-     * matching, appending, or even traversing nodes; in order to\n-     * maintain a targeted slack.  The idea of \"sometimes\" may be\n-     * operationalized in several ways. The simplest is to use a\n-     * per-operation counter incremented on each traversal step, and\n-     * to try (via CAS) to update the associated queue pointer\n-     * whenever the count exceeds a threshold. Another, that requires\n-     * more overhead, is to use random number generators to update\n-     * with a given probability per traversal step.\n-     *\n-     * In any strategy along these lines, because CASes updating\n-     * fields may fail, the actual slack may exceed targeted slack.\n-     * However, they may be retried at any time to maintain targets.\n-     * Even when using very small slack values, this approach works\n-     * well for dual queues because it allows all operations up to the\n-     * point of matching or appending an item (hence potentially\n-     * allowing progress by another thread) to be read-only, thus not\n-     * introducing any further contention.  As described below, we\n-     * implement this by performing slack maintenance retries only\n-     * after these points.\n-     *\n-     * As an accompaniment to such techniques, traversal overhead can\n-     * be further reduced without increasing contention of head\n-     * pointer updates: Threads may sometimes shortcut the \"next\" link\n-     * path from the current \"head\" node to be closer to the currently\n-     * known first unmatched node, and similarly for tail. Again, this\n-     * may be triggered with using thresholds or randomization.\n+     * similarly for \"tail\") is an empirical matter. Larger values\n+     * introduce increasing costs of cache misses and risks of long\n+     * traversal chains and out-of-order updates, while smaller values\n+     * increase CAS contention and overhead. Using the smallest\n+     * non-zero value of one is both simple and empirically a good\n+     * choice in most applicatkions.  The slack value is hard-wired: a\n+     * path greater than one is usually implemented by checking\n+     * equality of traversal pointers.  Because CASes updating fields\n+     * attempting to do so may stall, the writes may appear out of\n+     * order (an older CAS from the same head or tail may execute\n+     * after a newer one), the actual slack may exceed targeted\n+     * slack. To reduce impact, other threads may help update by\n+     * unsplicing dead nodes while traversing.\n@@ -220,2 +193,2 @@\n-     * (http:\/\/portal.acm.org\/citation.cfm?doid=503272.503282), if a GC\n-     * delays noticing that any arbitrarily old node has become\n+     * (http:\/\/portal.acm.org\/citation.cfm?doid=503272.503282), if a\n+     * GC delays noticing that any arbitrarily old node has become\n@@ -224,94 +197,15 @@\n-     * this in our implementation, upon CASing to advance the head\n-     * pointer, we set the \"next\" link of the previous head to point\n-     * only to itself; thus limiting the length of chains of dead nodes.\n-     * (We also take similar care to wipe out possibly garbage\n-     * retaining values held in other Node fields.)  However, doing so\n-     * adds some further complexity to traversal: If any \"next\"\n-     * pointer links to itself, it indicates that the current thread\n-     * has lagged behind a head-update, and so the traversal must\n-     * continue from the \"head\".  Traversals trying to find the\n-     * current tail starting from \"tail\" may also encounter\n-     * self-links, in which case they also continue at \"head\".\n-     *\n-     * It is tempting in slack-based scheme to not even use CAS for\n-     * updates (similarly to Ladan-Mozes & Shavit). However, this\n-     * cannot be done for head updates under the above link-forgetting\n-     * mechanics because an update may leave head at a detached node.\n-     * And while direct writes are possible for tail updates, they\n-     * increase the risk of long retraversals, and hence long garbage\n-     * chains, which can be much more costly than is worthwhile\n-     * considering that the cost difference of performing a CAS vs\n-     * write is smaller when they are not triggered on each operation\n-     * (especially considering that writes and CASes equally require\n-     * additional GC bookkeeping (\"write barriers\") that are sometimes\n-     * more costly than the writes themselves because of contention).\n-     *\n-     * *** Overview of implementation ***\n-     *\n-     * We use a threshold-based approach to updates, with a slack\n-     * threshold of two -- that is, we update head\/tail when the\n-     * current pointer appears to be two or more steps away from the\n-     * first\/last node. The slack value is hard-wired: a path greater\n-     * than one is naturally implemented by checking equality of\n-     * traversal pointers except when the list has only one element,\n-     * in which case we keep slack threshold at one. Avoiding tracking\n-     * explicit counts across method calls slightly simplifies an\n-     * already-messy implementation. Using randomization would\n-     * probably work better if there were a low-quality dirt-cheap\n-     * per-thread one available, but even ThreadLocalRandom is too\n-     * heavy for these purposes.\n-     *\n-     * With such a small slack threshold value, it is not worthwhile\n-     * to augment this with path short-circuiting (i.e., unsplicing\n-     * interior nodes) except in the case of cancellation\/removal (see\n-     * below).\n-     *\n-     * All enqueue\/dequeue operations are handled by the single method\n-     * \"xfer\" with parameters indicating whether to act as some form\n-     * of offer, put, poll, take, or transfer (each possibly with\n-     * timeout). The relative complexity of using one monolithic\n-     * method outweighs the code bulk and maintenance problems of\n-     * using separate methods for each case.\n-     *\n-     * Operation consists of up to two phases. The first is implemented\n-     * in method xfer, the second in method awaitMatch.\n-     *\n-     * 1. Traverse until matching or appending (method xfer)\n-     *\n-     *    Conceptually, we simply traverse all nodes starting from head.\n-     *    If we encounter an unmatched node of opposite mode, we match\n-     *    it and return, also updating head (by at least 2 hops) to\n-     *    one past the matched node (or the node itself if it's the\n-     *    pinned trailing node).  Traversals also check for the\n-     *    possibility of falling off-list, in which case they restart.\n-     *\n-     *    If the trailing node of the list is reached, a match is not\n-     *    possible.  If this call was untimed poll or tryTransfer\n-     *    (argument \"how\" is NOW), return empty-handed immediately.\n-     *    Else a new node is CAS-appended.  On successful append, if\n-     *    this call was ASYNC (e.g. offer), an element was\n-     *    successfully added to the end of the queue and we return.\n-     *\n-     *    Of course, this naive traversal is O(n) when no match is\n-     *    possible.  We optimize the traversal by maintaining a tail\n-     *    pointer, which is expected to be \"near\" the end of the list.\n-     *    It is only safe to fast-forward to tail (in the presence of\n-     *    arbitrary concurrent changes) if it is pointing to a node of\n-     *    the same mode, even if it is dead (in this case no preceding\n-     *    node could still be matchable by this traversal).  If we\n-     *    need to restart due to falling off-list, we can again\n-     *    fast-forward to tail, but only if it has changed since the\n-     *    last traversal (else we might loop forever).  If tail cannot\n-     *    be used, traversal starts at head (but in this case we\n-     *    expect to be able to match near head).  As with head, we\n-     *    CAS-advance the tail pointer by at least two hops.\n-     *\n-     * 2. Await match or cancellation (method awaitMatch)\n-     *\n-     *    Wait for another thread to match node; instead cancelling if\n-     *    the current thread was interrupted or the wait timed out. To\n-     *    improve performance in common single-source \/ single-sink\n-     *    usages when there are more tasks that cores, an initial\n-     *    Thread.yield is tried when there is apparently only one\n-     *    waiter.  In other cases, waiters may help with some\n-     *    bookkeeping, then park\/unpark.\n+     * this in our implementation, upon advancing the head pointer, we\n+     * set the \"next\" link of the previous head to point only to\n+     * itself; thus limiting the length of chains of dead nodes.  (We\n+     * also take similar care to wipe out possibly garbage retaining\n+     * values held in other node fields.) This is easy to accommodate\n+     * in the primary xfer method, but adds a lot of complexity to\n+     * Collection operations including traversal; mainly because if\n+     * any \"next\" pointer links to itself, the current thread has\n+     * lagged behind a head-update, and so must restart.\n+     *\n+     * *** Blocking ***\n+     *\n+     * The DualNode class is shared with class SynchronousQueue. It\n+     * houses method await, which is used for all blocking control, as\n+     * described below in DualNode internal documentation.\n@@ -333,9 +227,7 @@\n-     * appended. (2) We cannot necessarily unlink s given a\n-     * predecessor node that is matched (including the case of being\n-     * cancelled): the predecessor may already be unspliced, in which\n-     * case some previous reachable node may still point to s.\n-     * (For further explanation see Herlihy & Shavit \"The Art of\n-     * Multiprocessor Programming\" chapter 9).  Although, in both\n-     * cases, we can rule out the need for further action if either s\n-     * or its predecessor are (or can be made to be) at, or fall off\n-     * from, the head of list.\n+     * appended. (2) Unless we know it is already off-list, we cannot\n+     * necessarily unlink s given a predecessor node that is matched\n+     * (including the case of being cancelled): the predecessor may\n+     * already be unspliced, in which case some previous reachable\n+     * node may still point to s.  (For further explanation see\n+     * Herlihy & Shavit \"The Art of Multiprocessor Programming\"\n+     * chapter 9).\n@@ -353,8 +245,18 @@\n-     * won't help for case (1) anyway), we record the need to sweep the\n-     * next time any thread would otherwise block in awaitMatch. Also,\n-     * because traversal operations on the linked list of nodes are a\n-     * natural opportunity to sweep dead nodes, we generally do so,\n-     * including all the operations that might remove elements as they\n-     * traverse, such as removeIf and Iterator.remove.  This largely\n-     * eliminates long chains of dead interior nodes, except from\n-     * cancelled or timed out blocking operations.\n+     * won't help for case (1) anyway), we record a conservative\n+     * estimate of possible unsplice failures (in \"sweepVotes\").\n+     * We trigger a full sweep when the estimate exceeds a threshold\n+     * (\"SWEEP_THRESHOLD\") indicating the maximum number of estimated\n+     * removal failures to tolerate before sweeping through, unlinking\n+     * cancelled nodes that were not unlinked upon initial removal.\n+     * We perform sweeps by the thread hitting threshold (rather than\n+     * background threads or by spreading work to other threads)\n+     * because in the main contexts in which removal occurs, the\n+     * caller is timed-out or cancelled, which are not time-critical\n+     * enough to warrant the overhead that alternatives would impose\n+     * on other threads.\n+     *\n+     * Because the sweepVotes estimate is conservative, and because\n+     * nodes become unlinked \"naturally\" as they fall off the head of\n+     * the queue, and because we allow votes to accumulate even while\n+     * sweeps are in progress, there are typically significantly fewer\n+     * such nodes than estimated.\n@@ -366,0 +268,18 @@\n+     *\n+     * *** Revision notes ***\n+     *\n+     * This version differs from previous releases as follows:\n+     *\n+     * * Class DualNode replaces Qnode, with fields and methods\n+     *   that apply to any match-based dual data structure, and now\n+     *   usable in other j.u.c classes. in particular, SynchronousQueue.\n+     * * Blocking control (in class DualNode) accommodates\n+     *   VirtualThreads and (perhaps virtualized) uniprocessors.\n+     * * All fields of this class (LinkedTransferQueue) are\n+     *   default-initializable (to null), allowing further extension\n+     *   (in particular, SynchronousQueue.Transferer)\n+     * * Head and tail fields are lazily initialized rather than set\n+     *   to a dummy node, while also reducing retries under heavy\n+     *   contention and misorderings, and relaxing some accesses,\n+     *   requiring accommodation in many places (as well as\n+     *   adjustments in WhiteBox tests).\n@@ -369,19 +289,68 @@\n-     * The number of nanoseconds for which it is faster to spin\n-     * rather than to use timed park. A rough estimate suffices.\n-     * Using a power of two minus one simplifies some comparisons.\n-     *\/\n-    static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1023L;\n-\n-    \/**\n-     * The maximum number of estimated removal failures (sweepVotes)\n-     * to tolerate before sweeping through the queue unlinking\n-     * cancelled nodes that were not unlinked upon initial\n-     * removal. See above for explanation. The value must be at least\n-     * two to avoid useless sweeps when removing trailing nodes.\n-     *\/\n-    static final int SWEEP_THRESHOLD = 32;\n-\n-    \/**\n-     * Queue nodes. Uses Object, not E, for items to allow forgetting\n-     * them after use.  Writes that are intrinsically ordered wrt\n-     * other accesses or CASes use simple relaxed forms.\n+     * Node for linked dual data structures. Uses type Object, not E,\n+     * for items to allow cancellation and forgetting after use. Only\n+     * field \"item\" is declared volatile (with bypasses for\n+     * pre-publication and post-match writes), although field \"next\"\n+     * is also CAS-able. Other accesses are constrained by context\n+     * (including dependent chains of next's headed by a volatile\n+     * read).\n+     *\n+     * This class also arranges blocking while awaiting matches.\n+     * Control of blocking (and thread scheduling in general) for\n+     * possibly-synchronous queues (and channels etc constructed\n+     * from them) must straddle two extremes: If there are too few\n+     * underlying cores for a fulfilling party to continue, then\n+     * the caller must park to cause a context switch. On the\n+     * other hand, if the queue is busy with approximately the\n+     * same number of independent producers and consumers, then\n+     * that context switch may cause an order-of-magnitude\n+     * slowdown. Many cases are somewhere in-between, in which\n+     * case threads should try spinning and then give up and\n+     * block. We deal with this as follows:\n+     *\n+     * 1. Callers to method await indicate eligibility for\n+     * spinning when the node is either the only waiting node, or\n+     * the next matchable node is still spinning.  Otherwise, the\n+     * caller may block (almost) immediately.\n+     *\n+     * 2. Even if eligible to spin, a caller blocks anyway in two\n+     * cases where it is normally best: If the thread isVirtual,\n+     * or the system is a uniprocessor. Uniprocessor status can\n+     * vary over time (due to virtualization at other system\n+     * levels), but checking Runtime availableProcessors can be\n+     * slow and may itself acquire blocking locks, so we only\n+     * occasionally (using ThreadLocalRandom) update when an\n+     * otherwise-eligible spin elapses.\n+     *\n+     * 3. When enabled, spins should be long enough to cover\n+     * bookeeping overhead of almost-immediate fulfillments, but\n+     * much less than the expected time of a (non-virtual)\n+     * park\/unpark context switch.  The optimal value is\n+     * unknowable, in part because the relative costs of\n+     * Thread.onSpinWait versus park\/unpark vary across platforms.\n+     * The current value is an empirical compromise across tested\n+     * platforms.\n+     *\n+     * 4. When using timed waits, callers spin instead of invoking\n+     * timed park if the remaining time is less than the likely cost\n+     * of park\/unpark. This also avoids re-parks when timed park\n+     * returns just barely too soon. As is the case in most j.u.c\n+     * blocking support, untimed waits use ManagedBlockers when\n+     * callers are ForkJoin threads, but timed waits use plain\n+     * parkNanos, under the rationale that known-to-be transient\n+     * blocking doesn't require compensation. (This decision should be\n+     * revisited here and elsewhere to deal with very long timeouts.)\n+     *\n+     * 5. Park\/unpark signalling otherwise relies on a Dekker-like\n+     * scheme in which the caller advertises the need to unpark by\n+     * setting its waiter field, followed by a full fence and recheck\n+     * before actually parking. An explicit fence in used here rather\n+     * than unnecessarily requiring volatile accesses elsewhere. This\n+     * fence also separates accesses to field isUniprocessor.\n+     *\n+     * 6. To make the above work, callers must precheck that\n+     * timeouts are not already elapsed, and that interruptible\n+     * operations were not already interrupted on call to the\n+     * corresponding queue operation.  Cancellation on timeout or\n+     * interrupt otherwise proceeds by trying to fulfill with an\n+     * impossible value (which is one reason that we use Object\n+     * types here rather than typed fields).\n@@ -389,2 +358,1 @@\n-    static final class Node implements ForkJoinPool.ManagedBlocker {\n-        final boolean isData;   \/\/ false if this is a request node\n+    static final class DualNode implements ForkJoinPool.ManagedBlocker {\n@@ -392,2 +360,3 @@\n-        volatile Node next;\n-        volatile Thread waiter; \/\/ null when not waiting for a match\n+        DualNode next;          \/\/ accessed only in chains of volatile ops\n+        Thread waiter;          \/\/ access order constrained by context\n+        final boolean isData;   \/\/ false if this is a request node\n@@ -395,8 +364,3 @@\n-        \/**\n-         * Constructs a data node holding item if item is non-null,\n-         * else a request node.  Uses relaxed write because item can\n-         * only be seen after piggy-backing publication via CAS.\n-         *\/\n-        Node(Object item) {\n-            ITEM.set(this, item);\n-            isData = (item != null);\n+        DualNode(Object item, boolean isData) {\n+            ITEM.set(this, item); \/\/ relaxed write before publication\n+            this.isData = isData;\n@@ -405,3 +369,3 @@\n-        \/** Constructs a (matched data) dummy node. *\/\n-        Node() {\n-            isData = true;\n+        \/\/ Atomic updates\n+        final Object cmpExItem(Object cmp, Object val) { \/\/ try to match\n+            return ITEM.compareAndExchange(this, cmp, val);\n@@ -409,4 +373,2 @@\n-\n-        final boolean casNext(Node cmp, Node val) {\n-            \/\/ assert val != null;\n-            return NEXT.compareAndSet(this, cmp, val);\n+        final DualNode cmpExNext(DualNode cmp, DualNode val) {\n+            return (DualNode)NEXT.compareAndExchange(this, cmp, val);\n@@ -415,5 +377,3 @@\n-        final boolean casItem(Object cmp, Object val) {\n-            \/\/ assert isData == (cmp != null);\n-            \/\/ assert isData == (val == null);\n-            \/\/ assert !(cmp instanceof Node);\n-            return ITEM.compareAndSet(this, cmp, val);\n+        \/** Returns true if this node has been matched or cancelled  *\/\n+        final boolean matched() {\n+            return isData != (item != null);\n@@ -423,2 +383,3 @@\n-         * Links node to itself to avoid garbage retention.  Called\n-         * only after CASing head field, so uses relaxed write.\n+         * Relaxed write to replace reference to user data with\n+         * self-link. Can be used only if not already null after\n+         * match.\n@@ -426,3 +387,2 @@\n-        final void selfLink() {\n-            \/\/ assert isMatched();\n-            NEXT.setRelease(this, this);\n+        final void selfLinkItem() {\n+            ITEM.set(this, this);\n@@ -431,5 +391,2 @@\n-        final void appendRelaxed(Node next) {\n-            \/\/ assert next != null;\n-            \/\/ assert this.next == null;\n-            NEXT.setOpaque(this, next);\n-        }\n+        \/** The number of times to spin when eligible *\/\n+        private static final int SPINS = 1 << 7;\n@@ -438,2 +395,2 @@\n-         * Returns true if this node has been matched, including the\n-         * case of artificial matches due to cancellation.\n+         * The number of nanoseconds for which it is faster to spin\n+         * rather than to use timed park. A rough estimate suffices.\n@@ -441,3 +398,1 @@\n-        final boolean isMatched() {\n-            return isData == (item == null);\n-        }\n+        private static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1L << 10;\n@@ -445,8 +400,5 @@\n-        \/** Tries to CAS-match this node; if successful, wakes waiter. *\/\n-        final boolean tryMatch(Object cmp, Object val) {\n-            if (casItem(cmp, val)) {\n-                LockSupport.unpark(waiter);\n-                return true;\n-            }\n-            return false;\n-        }\n+        \/**\n+         * True if system is a uniprocessor, occasionally rechecked.\n+         *\/\n+        private static boolean isUniprocessor =\n+            (Runtime.getRuntime().availableProcessors() == 1);\n@@ -455,3 +407,4 @@\n-         * Returns true if a node with the given mode cannot be\n-         * appended to this node because this node is unmatched and\n-         * has opposite data mode.\n+         * Refresh rate (probablility) for updating isUniprocessor\n+         * field, to reduce the likeihood that multiple calls to await\n+         * will contend invoking Runtime.availableProcessors.  Must be\n+         * a power of two minus one.\n@@ -459,3 +412,53 @@\n-        final boolean cannotPrecede(boolean haveData) {\n-            boolean d = isData;\n-            return d != haveData && d != (item == null);\n+        private static final int UNIPROCESSOR_REFRESH_RATE = (1 << 5) - 1;\n+\n+        \/**\n+         * Possibly blocks until matched or caller gives up.\n+         *\n+         * @param e the comparison value for checking match\n+         * @param ns timeout, or Long.MAX_VALUE if untimed\n+         * @param blocker the LockSupport.setCurrentBlocker argument\n+         * @param spin true if should spin when enabled\n+         * @return matched item, or e if unmatched on interrupt or timeout\n+         *\/\n+        final Object await(Object e, long ns, Object blocker, boolean spin) {\n+            Object m;                      \/\/ the match or e if none\n+            boolean timed = (ns != Long.MAX_VALUE);\n+            long deadline = (timed) ? System.nanoTime() + ns : 0L;\n+            boolean upc = isUniprocessor;  \/\/ don't spin but later recheck\n+            Thread w = Thread.currentThread();\n+            if (w.isVirtual())             \/\/ don't spin\n+                spin = false;\n+            int spins = (spin & !upc) ? SPINS : 0; \/\/ negative when may park\n+            while ((m = item) == e) {\n+                if (spins >= 0) {\n+                    if (--spins >= 0)\n+                        Thread.onSpinWait();\n+                    else {                 \/\/ prepare to park\n+                        if (spin)          \/\/ occasionally recheck\n+                            checkForUniprocessor(upc);\n+                        LockSupport.setCurrentBlocker(blocker);\n+                        waiter = w;        \/\/ ensure ordering\n+                        VarHandle.fullFence();\n+                    }\n+                } else if (w.isInterrupted() ||\n+                           (timed &&       \/\/ try to cancel with impossible match\n+                            ((ns = deadline - System.nanoTime()) <= 0L))) {\n+                    m = cmpExItem(e, (e == null) ? this : null);\n+                    break;\n+                } else if (timed) {\n+                    if (ns < SPIN_FOR_TIMEOUT_THRESHOLD)\n+                        Thread.onSpinWait();\n+                    else\n+                        LockSupport.parkNanos(ns);\n+                } else if (w instanceof ForkJoinWorkerThread) {\n+                    try {\n+                        ForkJoinPool.managedBlock(this);\n+                    } catch (InterruptedException cannotHappen) { }\n+                } else\n+                    LockSupport.park();\n+            }\n+            if (spins < 0) {\n+                LockSupport.setCurrentBlocker(null);\n+                waiter = null;\n+            }\n+            return m;\n@@ -464,3 +467,8 @@\n-        public final boolean isReleasable() {\n-            return (isData == (item == null)) ||\n-                Thread.currentThread().isInterrupted();\n+        \/** Occasionally updates isUniprocessor field *\/\n+        private void checkForUniprocessor(boolean prev) {\n+            int r = ThreadLocalRandom.nextSecondarySeed();\n+            if ((r & UNIPROCESSOR_REFRESH_RATE) == 0) {\n+                boolean u = (Runtime.getRuntime().availableProcessors() == 1);\n+                if (u != prev)\n+                    isUniprocessor = u;\n+            }\n@@ -469,0 +477,4 @@\n+        \/\/ ManagedBlocker support\n+        public final boolean isReleasable() {\n+            return (matched() || Thread.currentThread().isInterrupted());\n+        }\n@@ -474,1 +486,16 @@\n-        private static final long serialVersionUID = -3375979862319811754L;\n+        \/\/ VarHandle mechanics\n+        static final VarHandle ITEM;\n+        static final VarHandle NEXT;\n+        static {\n+            try {\n+                Class<?> tn = DualNode.class;\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                ITEM = l.findVarHandle(tn, \"item\", Object.class);\n+                NEXT = l.findVarHandle(tn, \"next\", tn);\n+            } catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+            \/\/ Reduce the risk of rare disastrous classloading in first call to\n+            \/\/ LockSupport.park: https:\/\/bugs.openjdk.org\/browse\/JDK-8074773\n+            Class<?> ensureLoaded = LockSupport.class;\n+        }\n@@ -478,2 +505,2 @@\n-     * A node from which the first live (non-matched) node (if any)\n-     * can be reached in O(1) time.\n+     * Unless empty (in which case possibly null), a node from which\n+     * all live nodes are reachable.\n@@ -481,3 +508,1 @@\n-     * - all live nodes are reachable from head via .next\n-     * - head != null\n-     * - (tmp = head).next != tmp || tmp != head\n+     * - head is never self-linked\n@@ -486,2 +511,4 @@\n-     * - it is permitted for tail to lag behind head, that is, for tail\n-     *   to not be reachable from head!\n+     *\n+     * This field is used by subclass SynchronousQueue.Transferer to\n+     * record the top of a Lifo stack, with tail always null, but\n+     * otherwise maintaining the same properties.\n@@ -489,1 +516,1 @@\n-    transient volatile Node head;\n+    transient volatile DualNode head;\n@@ -492,5 +519,3 @@\n-     * A node from which the last node on list (that is, the unique\n-     * node with node.next == null) can be reached in O(1) time.\n-     * Invariants:\n-     * - the last node is always reachable from tail via .next\n-     * - tail != null\n+     * Unless null, a node from which the last node on list (that is,\n+     * the unique node with node.next == null), if one exists, can be\n+     * reached.\n@@ -499,3 +524,3 @@\n-     * - it is permitted for tail to lag behind head, that is, for tail\n-     *   to not be reachable from head!\n-     * - tail.next may or may not be self-linked.\n+     * - tail may be the same as head\n+     * - tail may or may not be self-linked.\n+     * - tail may lag behind head, so need not be reachable from head\n@@ -503,1 +528,1 @@\n-    private transient volatile Node tail;\n+    transient volatile DualNode tail;\n@@ -506,1 +531,1 @@\n-    private transient volatile boolean needSweep;\n+    transient volatile int sweepVotes;\n@@ -508,5 +533,1 @@\n-    private boolean casTail(Node cmp, Node val) {\n-        \/\/ assert cmp != null;\n-        \/\/ assert val != null;\n-        return TAIL.compareAndSet(this, cmp, val);\n-    }\n+    \/\/ Atomic updates\n@@ -514,2 +535,5 @@\n-    private boolean casHead(Node cmp, Node val) {\n-        return HEAD.compareAndSet(this, cmp, val);\n+    final DualNode cmpExTail(DualNode cmp, DualNode val) {\n+        return (DualNode)TAIL.compareAndExchange(this, cmp, val);\n+    }\n+    final DualNode cmpExHead(DualNode cmp, DualNode val) {\n+        return (DualNode)HEAD.compareAndExchange(this, cmp, val);\n@@ -519,2 +543,4 @@\n-     * Tries to CAS pred.next (or head, if pred is null) from c to p.\n-     * Caller must ensure that we're not unlinking the trailing node.\n+     * The maximum number of estimated removal failures (sweepVotes)\n+     * to tolerate before sweeping through the queue unlinking\n+     * dead nodes that were initially pinned.  Must be a power of\n+     * two minus one, at least 3.\n@@ -522,11 +548,8 @@\n-    private boolean tryCasSuccessor(Node pred, Node c, Node p) {\n-        \/\/ assert p != null;\n-        \/\/ assert c.isData != (c.item != null);\n-        \/\/ assert c != p;\n-        if (pred != null)\n-            return pred.casNext(c, p);\n-        if (casHead(c, p)) {\n-            c.selfLink();\n-            return true;\n-        }\n-        return false;\n+    static final int SWEEP_THRESHOLD = (1 << 4) - 1;\n+\n+    \/**\n+     * Adds a sweepVote and returns true if triggered threshold.\n+     *\/\n+    final boolean sweepNow() {\n+        return (SWEEP_THRESHOLD ==\n+                ((int)SWEEPVOTES.getAndAdd(this, 1) & (SWEEP_THRESHOLD)));\n@@ -536,6 +559,14 @@\n-     * Collapses dead (matched) nodes between pred and q.\n-     * @param pred the last known live node, or null if none\n-     * @param c the first dead node\n-     * @param p the last dead node\n-     * @param q p.next: the next live node, or null if at end\n-     * @return pred if pred still alive and CAS succeeded; else p\n+     * Implements all queuing methods. Loops, trying:\n+     *\n+     * * If not initialized, try to add new node (unless immediate) and exit\n+     * * If tail has same mode, start traversing at tail for a likely\n+     *   append, else at head for a likely match\n+     * * Traverse over dead or wrong-mode nodes until finding a spot\n+     *   to match\/append, or falling off the list because of self-links.\n+     * * On success, update head or tail if slacked, and possibly wait,\n+     *   depending on ns argument\n+     *\n+     * @param e the item or null for take\n+     * @param ns timeout or negative if async, 0 if immediate,\n+     *        Long.MAX_VALUE if untimed\n+     * @return an item if matched, else e\n@@ -543,9 +574,36 @@\n-    private Node skipDeadNodes(Node pred, Node c, Node p, Node q) {\n-        \/\/ assert pred != c;\n-        \/\/ assert p != q;\n-        \/\/ assert c.isMatched();\n-        \/\/ assert p.isMatched();\n-        if (q == null) {\n-            \/\/ Never unlink trailing node.\n-            if (c == p) return pred;\n-            q = p;\n+    final Object xfer(Object e, long ns) {\n+        boolean haveData = (e != null);\n+        Object m;                           \/\/ the match or e if none\n+        DualNode s = null, p;               \/\/ enqueued node and its predecessor\n+        restart: for (DualNode prevp = null;;) {\n+            DualNode h, t, q;\n+            if ((h = head) == null &&       \/\/ initialize unless immediate\n+                (ns == 0L ||\n+                 (h = cmpExHead(null, s = new DualNode(e, haveData))) == null)) {\n+                p = null;                   \/\/ no predecessor\n+                break;                      \/\/ else lost init race\n+            }\n+            p = (t = tail) != null && t.isData == haveData && t != prevp ? t : h;\n+            prevp = p;                      \/\/ avoid known self-linked tail path\n+            do {\n+                m = p.item;\n+                q = p.next;\n+                if (p.isData != haveData && haveData != (m != null) &&\n+                    p.cmpExItem(m, e) == m) {\n+                    Thread w = p.waiter;    \/\/ matched complementary node\n+                    if (p != h && h == cmpExHead(h, (q == null) ? p : q))\n+                        h.next = h;         \/\/ advance head; self-link old\n+                    LockSupport.unpark(w);\n+                    return m;\n+                } else if (q == null) {\n+                    if (ns == 0L)           \/\/ try to append unless immediate\n+                        break restart;\n+                    if (s == null)\n+                        s = new DualNode(e, haveData);\n+                    if ((q = p.cmpExNext(null, s)) == null) {\n+                        if (p != t)\n+                            cmpExTail(t, s);\n+                        break restart;\n+                    }\n+                }\n+            } while (p != (p = q));         \/\/ restart if self-linked\n@@ -553,3 +611,9 @@\n-        return (tryCasSuccessor(pred, c, q)\n-                && (pred == null || !pred.isMatched()))\n-            ? pred : p;\n+        if (s == null || ns <= 0L)\n+            m = e;                          \/\/ don't wait\n+        else if ((m = s.await(e, ns, this,  \/\/ spin if at or near head\n+                              p == null || p.waiter == null)) == e)\n+            unsplice(p, s);                 \/\/ cancelled\n+        else if (m != null)\n+            s.selfLinkItem();\n+\n+        return m;\n@@ -558,0 +622,2 @@\n+    \/* --------------  Removals -------------- *\/\n+\n@@ -559,2 +625,6 @@\n-     * Collapses dead (matched) nodes from h (which was once head) to p.\n-     * Caller ensures all nodes from h up to and including p are dead.\n+     * Unlinks (now or later) the given (non-live) node with given\n+     * predecessor. See above for rationale.\n+     *\n+     * @param pred if nonnull, a node that was at one time known to be the\n+     * predecessor of s (else s may have been head)\n+     * @param s the node to be unspliced\n@@ -562,9 +632,29 @@\n-    private void skipDeadNodesNearHead(Node h, Node p) {\n-        \/\/ assert h != null;\n-        \/\/ assert h != p;\n-        \/\/ assert p.isMatched();\n-        for (;;) {\n-            final Node q;\n-            if ((q = p.next) == null) break;\n-            else if (!q.isMatched()) { p = q; break; }\n-            else if (p == (p = q)) return;\n+    private void unsplice(DualNode pred, DualNode s) {\n+        boolean seen = false; \/\/ try removing by collapsing head\n+        for (DualNode h = head, p = h, f; p != null;) {\n+            boolean matched;\n+            if (p == s)\n+                matched = seen = true;\n+            else\n+                matched = p.matched();\n+            if ((f = p.next) == p)\n+                p = h = head;\n+            else if (f != null && matched)\n+                p = f;\n+            else {\n+                if (p != h && cmpExHead(h, p) == h)\n+                    h.next = h; \/\/ self-link\n+                break;\n+            }\n+        }\n+        DualNode sn;      \/\/ try to unsplice if not pinned\n+        if (!seen &&\n+            pred != null && pred.next == s && s != null && (sn = s.next) != s &&\n+            (sn == null || pred.cmpExNext(s, sn) != s || pred.matched()) &&\n+            sweepNow()) { \/\/ occasionally sweep if might not have been removed\n+            for (DualNode p = head, f, n, u;\n+                 p != null && (f = p.next) != null && (n = f.next) != null;) {\n+                p = (f == p                       ? head :  \/\/ stale\n+                     !f.matched()                 ? f :     \/\/ skip\n+                     f == (u = p.cmpExNext(f, n)) ? n : u); \/\/ unspliced\n+            }\n@@ -572,2 +662,0 @@\n-        if (casHead(h, p))\n-            h.selfLink();\n@@ -576,1 +664,12 @@\n-    \/* Possible values for \"how\" argument in xfer method. *\/\n+    \/**\n+     * Tries to CAS pred.next (or head, if pred is null) from c to p.\n+     * Caller must ensure that we're not unlinking the trailing node.\n+     *\/\n+    final boolean tryCasSuccessor(DualNode pred, DualNode c, DualNode p) {\n+        \/\/ assert p != null && c.matched() && c != p;\n+        if (pred != null)\n+            return pred.cmpExNext(c, p) == c;\n+        else if (cmpExHead(c, p) != c)\n+            return false;\n+        if (c != null)\n+            c.next = c;\n@@ -578,4 +677,2 @@\n-    private static final int NOW   = 0; \/\/ for untimed poll, tryTransfer\n-    private static final int ASYNC = 1; \/\/ for offer, put, add\n-    private static final int SYNC  = 2; \/\/ for transfer, take\n-    private static final int TIMED = 3; \/\/ for timed poll, tryTransfer\n+        return true;\n+    }\n@@ -584,8 +681,6 @@\n-     * Implements all queuing methods. See above for explanation.\n-     *\n-     * @param e the item or null for take\n-     * @param haveData true if this is a put, else a take\n-     * @param how NOW, ASYNC, SYNC, or TIMED\n-     * @param nanos timeout in nanosecs, used only if mode is TIMED\n-     * @return an item if matched, else e\n-     * @throws NullPointerException if haveData mode but e is null\n+     * Collapses dead (matched) nodes between pred and q.\n+     * @param pred the last known live node, or null if none\n+     * @param c the first dead node\n+     * @param p the last dead node\n+     * @param q p.next: the next live node, or null if at end\n+     * @return pred if pred still alive and CAS succeeded; else p\n@@ -593,27 +688,7 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private E xfer(E e, boolean haveData, int how, long nanos) {\n-        if (haveData && (e == null))\n-            throw new NullPointerException();\n-\n-        restart: for (Node s = null, t = null, h = null;;) {\n-            for (Node p = (t != (t = tail) && t.isData == haveData) ? t\n-                     : (h = head);; ) {\n-                final Node q; final Object item;\n-                if (p.isData != haveData\n-                    && haveData == ((item = p.item) == null)) {\n-                    if (h == null) h = head;\n-                    if (p.tryMatch(item, e)) {\n-                        if (h != p) skipDeadNodesNearHead(h, p);\n-                        return (E) item;\n-                    }\n-                }\n-                if ((q = p.next) == null) {\n-                    if (how == NOW) return e;\n-                    if (s == null) s = new Node(e);\n-                    if (!p.casNext(null, s)) continue;\n-                    if (p != t) casTail(t, s);\n-                    if (how == ASYNC) return e;\n-                    return awaitMatch(s, p, e, (how == TIMED), nanos);\n-                }\n-                if (p == (p = q)) continue restart;\n-            }\n+    final DualNode skipDeadNodes(DualNode pred, DualNode c,\n+                                 DualNode p, DualNode q) {\n+        \/\/ assert pred != c && p != q; && c.matched() && p.matched();\n+        if (q == null) { \/\/ Never unlink trailing node.\n+            if (c == p)\n+                return pred;\n+            q = p;\n@@ -621,0 +696,2 @@\n+        return (tryCasSuccessor(pred, c, q) && (pred == null || !pred.matched()))\n+            ? pred : p;\n@@ -624,10 +701,2 @@\n-     * Possibly blocks until node s is matched or caller gives up.\n-     *\n-     * @param s the waiting node\n-     * @param pred the predecessor of s, or null if unknown (the null\n-     * case does not occur in any current calls but may in possible\n-     * future extensions)\n-     * @param e the comparison value for checking match\n-     * @param timed if true, wait only until timeout elapses\n-     * @param nanos timeout in nanosecs, used only if timed is true\n-     * @return matched item, or e if unmatched on interrupt or timeout\n+     * Tries to match the given object only if p is a data\n+     * node. Signals waiter on success.\n@@ -635,43 +704,5 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) {\n-        final boolean isData = s.isData;\n-        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n-        final Thread w = Thread.currentThread();\n-        int stat = -1;                   \/\/ -1: may yield, +1: park, else 0\n-        Object item;\n-        while ((item = s.item) == e) {\n-            if (needSweep)               \/\/ help clean\n-                sweep();\n-            else if ((timed && nanos <= 0L) || w.isInterrupted()) {\n-                if (s.casItem(e, (e == null) ? s : null)) {\n-                    unsplice(pred, s);   \/\/ cancelled\n-                    return e;\n-                }\n-            }\n-            else if (stat <= 0) {\n-                if (pred != null && pred.next == s) {\n-                    if (stat < 0 &&\n-                        (pred.isData != isData || pred.isMatched())) {\n-                        stat = 0;        \/\/ yield once if first\n-                        Thread.yield();\n-                    }\n-                    else {\n-                        stat = 1;\n-                        s.waiter = w;    \/\/ enable unpark\n-                    }\n-                }                        \/\/ else signal in progress\n-            }\n-            else if ((item = s.item) != e)\n-                break;                   \/\/ recheck\n-            else if (!timed) {\n-                LockSupport.setCurrentBlocker(this);\n-                try {\n-                    ForkJoinPool.managedBlock(s);\n-                } catch (InterruptedException cannotHappen) { }\n-                LockSupport.setCurrentBlocker(null);\n-            }\n-            else {\n-                nanos = deadline - System.nanoTime();\n-                if (nanos > SPIN_FOR_TIMEOUT_THRESHOLD)\n-                    LockSupport.parkNanos(this, nanos);\n-            }\n+    final boolean tryMatchData(DualNode p, Object x) {\n+        if (p != null && p.isData &&\n+            x != null && p.cmpExItem(x, null) == x) {\n+            LockSupport.unpark(p.waiter);\n+            return true;\n@@ -679,5 +710,1 @@\n-        if (stat == 1)\n-            WAITER.set(s, null);\n-        if (!isData)\n-            ITEM.set(s, s);              \/\/ self-link to avoid garbage\n-        return (E) item;\n+        return false;\n@@ -693,18 +720,19 @@\n-    final Node firstDataNode() {\n-        Node first = null;\n-        restartFromHead: for (;;) {\n-            Node h = head, p = h;\n-            while (p != null) {\n-                if (p.item != null) {\n-                    if (p.isData) {\n-                        first = p;\n-                        break;\n-                    }\n-                }\n-                else if (!p.isData)\n-                    break;\n-                final Node q;\n-                if ((q = p.next) == null)\n-                    break;\n-                if (p == (p = q))\n-                    continue restartFromHead;\n+    final DualNode firstDataNode() {\n+        for (DualNode h = head, p = h, q, u; p != null;) {\n+            boolean isData = p.isData;\n+            Object item = p.item;\n+            if (isData && item != null)       \/\/ is live data\n+                return p;\n+            else if (!isData && item == null) \/\/ is live request\n+                break;\n+            else if ((q = p.next) == null)    \/\/ end of list\n+                break;\n+            else if (p == q)                  \/\/ self-link; restart\n+                p = h = head;\n+            else if (p == h)                  \/\/ traverse past header\n+                p = q;\n+            else if ((u = cmpExHead(h, q)) != h)\n+                p = h = u;                    \/\/ lost update race\n+            else {\n+                h.next = h;                   \/\/ collapse; self-link\n+                p = h = q;\n@@ -712,3 +740,0 @@\n-            if (p != h && casHead(h, p))\n-                h.selfLink();\n-            return first;\n@@ -716,0 +741,1 @@\n+        return null;\n@@ -722,1 +748,1 @@\n-    private int countOfMode(boolean data) {\n+    final int countOfMode(boolean data) {\n@@ -725,2 +751,2 @@\n-            for (Node p = head; p != null;) {\n-                if (!p.isMatched()) {\n+            for (DualNode p = head; p != null;) {\n+                if (!p.matched()) {\n@@ -744,1 +770,1 @@\n-            for (Node p = head; p != null;) {\n+            for (DualNode p = head; p != null;) {\n@@ -773,1 +799,1 @@\n-            for (Node p = head; p != null;) {\n+            for (DualNode p = head; p != null;) {\n@@ -866,4 +892,4 @@\n-        private Node nextNode;   \/\/ next node to return item for\n-        private E nextItem;      \/\/ the corresponding item\n-        private Node lastRet;    \/\/ last returned node, to support remove\n-        private Node ancestor;   \/\/ Helps unlink lastRet on remove()\n+        private DualNode nextNode;   \/\/ next node to return item for\n+        private E nextItem;          \/\/ the corresponding item\n+        private DualNode lastRet;    \/\/ last returned node, to support remove\n+        private DualNode ancestor;   \/\/ Helps unlink lastRet on remove()\n@@ -875,2 +901,2 @@\n-        private void advance(Node pred) {\n-            for (Node p = (pred == null) ? head : pred.next, c = p;\n+        private void advance(DualNode pred) {\n+            for (DualNode p = (pred == null) ? head : pred.next, c = p;\n@@ -878,2 +904,3 @@\n-                final Object item;\n-                if ((item = p.item) != null && p.isData) {\n+                boolean isData = p.isData;\n+                Object item = p.item;\n+                if (isData && item != null) {\n@@ -886,1 +913,1 @@\n-                else if (!p.isData && item == null)\n+                else if (!isData && item == null)\n@@ -910,1 +937,1 @@\n-            final Node p;\n+            DualNode p;\n@@ -919,2 +946,2 @@\n-            Node q = null;\n-            for (Node p; (p = nextNode) != null; advance(q = p))\n+            DualNode q = null;\n+            for (DualNode p; (p = nextNode) != null; advance(q = p))\n@@ -927,1 +954,1 @@\n-            final Node lastRet = this.lastRet;\n+            final DualNode lastRet = this.lastRet;\n@@ -934,2 +961,2 @@\n-            Node pred = ancestor;\n-            for (Node p = (pred == null) ? head : pred.next, c = p, q;\n+            DualNode pred = ancestor;\n+            for (DualNode p = (pred == null) ? head : pred.next, c = p, q;\n@@ -938,3 +965,1 @@\n-                    final Object item;\n-                    if ((item = p.item) != null)\n-                        p.tryMatch(item, null);\n+                    tryMatchData(p, p.item);\n@@ -965,1 +990,1 @@\n-            \/\/ assert lastRet.isMatched();\n+            \/\/ assert lastRet.matched();\n@@ -972,1 +997,1 @@\n-        Node current;       \/\/ current node; null until initialized\n+        DualNode current;   \/\/ current node; null until initialized\n@@ -978,1 +1003,1 @@\n-            Node p, q;\n+            DualNode p, q;\n@@ -1007,1 +1032,1 @@\n-            final Node p;\n+            final DualNode p;\n@@ -1018,1 +1043,1 @@\n-            Node p;\n+            DualNode p;\n@@ -1022,2 +1047,2 @@\n-                    final Object item = p.item;\n-                    final boolean isData = p.isData;\n+                    boolean isData = p.isData;\n+                    Object item = p.item;\n@@ -1044,1 +1069,1 @@\n-        private void setCurrent(Node p) {\n+        private void setCurrent(DualNode p) {\n@@ -1049,2 +1074,2 @@\n-        private Node current() {\n-            Node p;\n+        private DualNode current() {\n+            DualNode p;\n@@ -1085,65 +1110,0 @@\n-    \/* -------------- Removal methods -------------- *\/\n-\n-    \/**\n-     * Unsplices (now or later) the given deleted\/cancelled node with\n-     * the given predecessor.\n-     *\n-     * @param pred a node that was at one time known to be the\n-     * predecessor of s\n-     * @param s the node to be unspliced\n-     *\/\n-    final void unsplice(Node pred, Node s) {\n-        \/\/ assert pred != null;\n-        \/\/ assert pred != s;\n-        \/\/ assert s != null;\n-        \/\/ assert s.isMatched();\n-        \/\/ assert (SWEEP_THRESHOLD & (SWEEP_THRESHOLD - 1)) == 0;\n-        s.waiter = null; \/\/ disable signals\n-        \/*\n-         * See above for rationale. Briefly: if pred still points to\n-         * s, try to unlink s.  If s cannot be unlinked, because it is\n-         * trailing node or pred might be unlinked, and neither pred\n-         * nor s are head or offlist, set needSweep;\n-         *\/\n-        if (pred != null && pred.next == s) {\n-            Node n = s.next;\n-            if (n == null ||\n-                (n != s && pred.casNext(s, n) && pred.isMatched())) {\n-                for (;;) {               \/\/ check if at, or could be, head\n-                    Node h = head;\n-                    if (h == pred || h == s)\n-                        return;          \/\/ at head or list empty\n-                    if (!h.isMatched())\n-                        break;\n-                    Node hn = h.next;\n-                    if (hn == null)\n-                        return;          \/\/ now empty\n-                    if (hn != h && casHead(h, hn))\n-                        h.selfLink();  \/\/ advance head\n-                }\n-                if (pred.next != pred && s.next != s)\n-                    needSweep = true;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Unlinks matched (typically cancelled) nodes encountered in a\n-     * traversal from head.\n-     *\/\n-    private void sweep() {\n-        needSweep = false;\n-        for (Node p = head, s, n; p != null && (s = p.next) != null; ) {\n-            if (!s.isMatched())\n-                \/\/ Unmatched nodes are never self-linked\n-                p = s;\n-            else if ((n = s.next) == null) \/\/ trailing node is pinned\n-                break;\n-            else if (s == n)    \/\/ stale\n-                \/\/ No need to also check for p == s, since that implies s == n\n-                p = head;\n-            else\n-                p.casNext(s, n);\n-        }\n-    }\n-\n@@ -1154,1 +1114,0 @@\n-        head = tail = new Node();\n@@ -1167,1 +1126,1 @@\n-        Node h = null, t = null;\n+        DualNode h = null, t = null;\n@@ -1169,3 +1128,3 @@\n-            Node newNode = new Node(Objects.requireNonNull(e));\n-            if (h == null)\n-                h = t = newNode;\n+            DualNode newNode = new DualNode(Objects.requireNonNull(e), true);\n+            if (t == null)\n+                h = newNode;\n@@ -1173,1 +1132,2 @@\n-                t.appendRelaxed(t = newNode);\n+                t.next = newNode;\n+            t = newNode;\n@@ -1175,2 +1135,0 @@\n-        if (h == null)\n-            h = t = new Node();\n@@ -1188,1 +1146,1 @@\n-        xfer(e, true, ASYNC, 0L);\n+        offer(e);\n@@ -1201,2 +1159,1 @@\n-        xfer(e, true, ASYNC, 0L);\n-        return true;\n+        return offer(e);\n@@ -1213,1 +1170,2 @@\n-        xfer(e, true, ASYNC, 0L);\n+        Objects.requireNonNull(e);\n+        xfer(e, -1L);\n@@ -1226,2 +1184,1 @@\n-        xfer(e, true, ASYNC, 0L);\n-        return true;\n+        return offer(e);\n@@ -1241,1 +1198,2 @@\n-        return xfer(e, true, NOW, 0L) == null;\n+        Objects.requireNonNull(e);\n+        return xfer(e, 0L) == null;\n@@ -1256,1 +1214,4 @@\n-        if (xfer(e, true, SYNC, 0L) != null) {\n+        Objects.requireNonNull(e);\n+        if (!Thread.interrupted()) {\n+            if (xfer(e, Long.MAX_VALUE) == null)\n+                return;\n@@ -1258,1 +1219,0 @@\n-            throw new InterruptedException();\n@@ -1260,0 +1220,1 @@\n+        throw new InterruptedException();\n@@ -1278,1 +1239,3 @@\n-        if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)\n+        Objects.requireNonNull(e);\n+        long nanos = Math.max(unit.toNanos(timeout), 0L);\n+        if (xfer(e, nanos) == null)\n@@ -1285,0 +1248,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -1286,4 +1250,6 @@\n-        E e = xfer(null, false, SYNC, 0L);\n-        if (e != null)\n-            return e;\n-        Thread.interrupted();\n+        Object e;\n+        if (!Thread.interrupted()) {\n+            if ((e = xfer(null, Long.MAX_VALUE)) != null)\n+                return (E) e;\n+            Thread.interrupted();\n+        }\n@@ -1293,0 +1259,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -1294,3 +1261,4 @@\n-        E e = xfer(null, false, TIMED, unit.toNanos(timeout));\n-        if (e != null || !Thread.interrupted())\n-            return e;\n+        Object e;\n+        long nanos = Math.max(unit.toNanos(timeout), 0L);\n+        if ((e = xfer(null, nanos)) != null || !Thread.interrupted())\n+            return (E) e;\n@@ -1300,0 +1268,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -1301,1 +1270,1 @@\n-        return xfer(null, false, NOW, 0L);\n+        return (E) xfer(null, 0L);\n@@ -1347,1 +1316,1 @@\n-            for (Node p = head; p != null;) {\n+            for (DualNode p = head; p != null;) {\n@@ -1375,1 +1344,1 @@\n-            for (Node p = head; p != null;) {\n+            for (DualNode p = head; p != null;) {\n@@ -1424,6 +1393,7 @@\n-            for (Node p = head, pred = null; p != null; ) {\n-                Node q = p.next;\n-                final Object item;\n-                if ((item = p.item) != null) {\n-                    if (p.isData) {\n-                        if (o.equals(item) && p.tryMatch(item, null)) {\n+            for (DualNode p = head, pred = null; p != null; ) {\n+                boolean isData = p.isData;\n+                Object item = p.item;\n+                DualNode q = p.next;\n+                if (item != null) {\n+                    if (isData) {\n+                        if (o.equals(item) && tryMatchData(p, item)) {\n@@ -1436,1 +1406,1 @@\n-                else if (!p.isData)\n+                else if (!isData)\n@@ -1438,2 +1408,2 @@\n-                for (Node c = p;; q = p.next) {\n-                    if (q == null || !q.isMatched()) {\n+                for (DualNode c = p;; q = p.next) {\n+                    if (q == null || !q.matched()) {\n@@ -1460,5 +1430,6 @@\n-            for (Node p = head, pred = null; p != null; ) {\n-                Node q = p.next;\n-                final Object item;\n-                if ((item = p.item) != null) {\n-                    if (p.isData) {\n+            for (DualNode p = head, pred = null; p != null; ) {\n+                boolean isData = p.isData;\n+                Object item = p.item;\n+                DualNode q = p.next;\n+                if (item != null) {\n+                    if (isData) {\n@@ -1470,1 +1441,1 @@\n-                else if (!p.isData)\n+                else if (!isData)\n@@ -1472,2 +1443,2 @@\n-                for (Node c = p;; q = p.next) {\n-                    if (q == null || !q.isMatched()) {\n+                for (DualNode c = p;; q = p.next) {\n+                    if (q == null || !q.matched()) {\n@@ -1522,1 +1493,1 @@\n-        Node h = null, t = null;\n+        DualNode h = null, t = null;\n@@ -1524,3 +1495,3 @@\n-            Node newNode = new Node(item);\n-            if (h == null)\n-                h = t = newNode;\n+            DualNode newNode = new DualNode(item, true);\n+            if (t == null)\n+                h = newNode;\n@@ -1528,1 +1499,2 @@\n-                t.appendRelaxed(t = newNode);\n+                t.next = newNode;\n+            t = newNode;\n@@ -1530,2 +1502,0 @@\n-        if (h == null)\n-            h = t = new Node();\n@@ -1570,0 +1540,1 @@\n+\n@@ -1578,1 +1549,3 @@\n-            for (Node p = head, c = p, pred = null, q; p != null; p = q) {\n+            for (DualNode p = head, c = p, pred = null, q; p != null; p = q) {\n+                boolean isData = p.isData, pAlive;\n+                Object item = p.item;\n@@ -1580,2 +1553,1 @@\n-                final Object item; boolean pAlive;\n-                if (pAlive = ((item = p.item) != null && p.isData)) {\n+                if (pAlive = (item != null && isData)) {\n@@ -1583,1 +1555,1 @@\n-                        if (p.tryMatch(item, null))\n+                        if (tryMatchData(p, item))\n@@ -1588,1 +1560,1 @@\n-                else if (!p.isData && item == null)\n+                else if (!isData && item == null)\n@@ -1594,2 +1566,1 @@\n-                    if ((c != p && !tryCasSuccessor(pred, c, c = p))\n-                        || pAlive) {\n+                    if ((c != p && !tryCasSuccessor(pred, c, c = p)) || pAlive) {\n@@ -1613,6 +1584,7 @@\n-    void forEachFrom(Consumer<? super E> action, Node p) {\n-        for (Node pred = null; p != null; ) {\n-            Node q = p.next;\n-            final Object item;\n-            if ((item = p.item) != null) {\n-                if (p.isData) {\n+    void forEachFrom(Consumer<? super E> action, DualNode p) {\n+        for (DualNode pred = null; p != null; ) {\n+            boolean isData = p.isData;\n+            Object item = p.item;\n+            DualNode q = p.next;\n+            if (item != null) {\n+                if (isData) {\n@@ -1623,1 +1595,1 @@\n-            else if (!p.isData)\n+            else if (!isData)\n@@ -1625,2 +1597,2 @@\n-            for (Node c = p;; q = p.next) {\n-                if (q == null || !q.isMatched()) {\n+            for (DualNode c = p;; q = p.next) {\n+                if (q == null || !q.matched()) {\n@@ -1643,5 +1615,3 @@\n-    private static final VarHandle HEAD;\n-    private static final VarHandle TAIL;\n-    static final VarHandle ITEM;\n-    static final VarHandle NEXT;\n-    static final VarHandle WAITER;\n+    static final VarHandle HEAD;\n+    static final VarHandle TAIL;\n+    static final VarHandle SWEEPVOTES;\n@@ -1650,0 +1620,1 @@\n+            Class<?> ltq = LinkedTransferQueue.class, tn = DualNode.class;\n@@ -1651,7 +1622,3 @@\n-            HEAD = l.findVarHandle(LinkedTransferQueue.class, \"head\",\n-                                   Node.class);\n-            TAIL = l.findVarHandle(LinkedTransferQueue.class, \"tail\",\n-                                   Node.class);\n-            ITEM = l.findVarHandle(Node.class, \"item\", Object.class);\n-            NEXT = l.findVarHandle(Node.class, \"next\", Node.class);\n-            WAITER = l.findVarHandle(Node.class, \"waiter\", Thread.class);\n+            HEAD = l.findVarHandle(ltq, \"head\", tn);\n+            TAIL = l.findVarHandle(ltq, \"tail\", tn);\n+            SWEEPVOTES = l.findVarHandle(ltq, \"sweepVotes\", int.class);\n@@ -1661,4 +1628,0 @@\n-\n-        \/\/ Reduce the risk of rare disastrous classloading in first call to\n-        \/\/ LockSupport.park: https:\/\/bugs.openjdk.org\/browse\/JDK-8074773\n-        Class<?> ensureLoaded = LockSupport.class;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":593,"deletions":630,"binary":false,"changes":1223,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.LinkedTransferQueue;\n+import java.util.concurrent.TransferQueue;\n@@ -101,5 +104,8 @@\n-     * The (Lifo) stack is used for non-fair mode, and the (Fifo)\n-     * queue for fair mode. The performance of the two is generally\n-     * similar. Fifo usually supports higher throughput under\n-     * contention but Lifo maintains higher thread locality in common\n-     * applications.\n+     * The queue is treated as a Lifo stack in non-fair mode, and a\n+     * Fifo queue in fair mode. In most contexts, transfer performance\n+     * is roughly comparable across them. Lifo is usually faster under\n+     * low contention, but slower under high contention.  Performance\n+     * of applications using them also varies. Lifo is generally\n+     * preferable in resource management settings (for example cached\n+     * thread pools) because of better temporal locality, but\n+     * inappropriate for message-passing applications.\n@@ -107,21 +113,10 @@\n-     * A dual queue (and similarly stack) is one that at any given\n-     * time either holds \"data\" -- items provided by put operations,\n-     * or \"requests\" -- slots representing take operations, or is\n-     * empty. A call to \"fulfill\" (i.e., a call requesting an item\n-     * from a queue holding data or vice versa) dequeues a\n-     * complementary node.  The most interesting feature of these\n-     * queues is that any operation can figure out which mode the\n-     * queue is in, and act accordingly without needing locks.\n-     *\n-     * Both the queue and stack extend abstract class Transferer\n-     * defining the single method transfer that does a put or a\n-     * take. These are unified into a single method because in dual\n-     * data structures, the put and take operations are symmetrical,\n-     * so nearly all code can be combined. The resulting transfer\n-     * methods are on the long side, but are easier to follow than\n-     * they would be if broken up into nearly-duplicated parts.\n-     *\n-     * The queue and stack data structures share many conceptual\n-     * similarities but very few concrete details. For simplicity,\n-     * they are kept distinct so that they can later evolve\n-     * separately.\n+     * A dual queue is one that at any given time either holds \"data\"\n+     * -- items provided by put operations, or \"requests\" -- slots\n+     * representing take operations, or is empty. A fulfilling\n+     * operation (i.e., a call requesting an item from a queue holding\n+     * data or vice versa) \"matches\" the item of and then dequeues a\n+     * complementary node.  Any operation can figure out which mode\n+     * the queue is in, and act accordingly without needing locks.  So\n+     * put and take operations are symmetrical, and all transfer\n+     * methods invoke a single \"xfer\" method that does a put or a take\n+     * in either fifo or lifo mode.\n@@ -130,27 +125,1 @@\n-     * in extending them for use in synchronous queues, as well as\n-     * dealing with cancellation. The main differences include:\n-     *\n-     *  1. The original algorithms used bit-marked pointers, but\n-     *     the ones here use mode bits in nodes, leading to a number\n-     *     of further adaptations.\n-     *  2. SynchronousQueues must block threads waiting to become\n-     *     fulfilled.\n-     *  3. Support for cancellation via timeout and interrupts,\n-     *     including cleaning out cancelled nodes\/threads\n-     *     from lists to avoid garbage retention and memory depletion.\n-     *\n-     * Blocking is mainly accomplished using LockSupport park\/unpark,\n-     * except that nodes that appear to be the next ones to become\n-     * fulfilled first spin a bit (on multiprocessors only). On very\n-     * busy synchronous queues, spinning can dramatically improve\n-     * throughput. And on less busy ones, the amount of spinning is\n-     * small enough not to be noticeable.\n-     *\n-     * Cleaning is done in different ways in queues vs stacks.  For\n-     * queues, we can almost always remove a node immediately in O(1)\n-     * time (modulo retries for consistency checks) when it is\n-     * cancelled. But if it may be pinned as the current tail, it must\n-     * wait until some subsequent cancellation. For stacks, we need a\n-     * potentially O(n) traversal to be sure that we can remove the\n-     * node, but this can run concurrently with other threads\n-     * accessing the stack.\n+     * in ways including:\n@@ -158,23 +127,14 @@\n-     * While garbage collection takes care of most node reclamation\n-     * issues that otherwise complicate nonblocking algorithms, care\n-     * is taken to \"forget\" references to data, other nodes, and\n-     * threads that might be held on to long-term by blocked\n-     * threads. In cases where setting to null would otherwise\n-     * conflict with main algorithms, this is done by changing a\n-     * node's link to now point to the node itself. This doesn't arise\n-     * much for Stack nodes (because blocked threads do not hang on to\n-     * old head pointers), but references in Queue nodes must be\n-     * aggressively forgotten to avoid reachability of everything any\n-     * node has ever referred to since arrival.\n-     *\n-     * The above steps improve throughput when many threads produce\n-     * and\/or consume data. But they don't help much with\n-     * single-source \/ single-sink usages in which one side or the\n-     * other is always transiently blocked, and so throughput is\n-     * mainly a function of thread scheduling. This is not usually\n-     * noticeably improved with bounded short spin-waits. Instead both\n-     * forms of transfer try Thread.yield if apparently the sole\n-     * waiter. This works well when there are more tasks that cores,\n-     * which is expected to be the main usage context of this mode. In\n-     * other cases, waiters may help with some bookkeeping, then\n-     * park\/unpark.\n+     *  * The original algorithms used bit-marked pointers, but the\n+     *     ones here use a bit (isData) in nodes, and usually avoid\n+     *     creating nodes when fulfilling. They also use the\n+     *     compareAndExchange form of CAS for pointer updates to\n+     *     reduce memory traffic.\n+     *  * Fifo mode is based on LinkedTransferQueue operations, but\n+     *     Lifo mode support is added in subclass Transferer.\n+     *  * The Fifo version accommodates lazy updates and slack as\n+     *     described in LinkedTransferQueue internal documentation.\n+     *  * Threads may block when waiting to become fulfilled,\n+     *     sometimes preceded by brief spins.\n+     *  * Support for cancellation via timeout and interrupts,\n+     *     including cleaning out cancelled nodes\/threads from lists\n+     *     to avoid garbage retention and memory depletion.\n@@ -184,1 +144,6 @@\n-     * Shared internal API for dual stacks and queues.\n+     * Extension of LinkedTransferQueue to support Lifo (stack) mode.\n+     * Methods use the \"head\" field as head (top) of stack (versus\n+     * queue). Note that popped nodes are not self-linked because they\n+     * are not prone to unbounded garbage chains. Also note that\n+     * \"async\" mode is never used and not supported for synchronous\n+     * transfers.\n@@ -186,1 +151,3 @@\n-    abstract static class Transferer<E> {\n+    @SuppressWarnings(\"serial\") \/\/ never serialized\n+    static final class Transferer<E> extends LinkedTransferQueue<E> {\n+\n@@ -188,1 +155,7 @@\n-         * Performs a put or take.\n+         * Puts or takes an item with lifo ordering. Loops trying:\n+         * * If top (var p) exists and is already matched, pop and continue\n+         * * If top has complementary type, try to fulfill by CASing item,\n+         *    On success pop (which will succeed unless already helped),\n+         *    otherwise restart.\n+         * * If no possible match, unless immediate mode, push a\n+         *    node and wait, later unsplicing if cancelled.\n@@ -190,9 +163,3 @@\n-         * @param e if non-null, the item to be handed to a consumer;\n-         *          if null, requests that transfer return an item\n-         *          offered by producer.\n-         * @param timed if this operation should timeout\n-         * @param nanos the timeout, in nanoseconds\n-         * @return if non-null, the item provided or received; if null,\n-         *         the operation failed due to timeout or interrupt --\n-         *         the caller can distinguish which of these occurred\n-         *         by checking Thread.interrupted.\n+         * @param e the item or null for take\n+         * @param ns timeout or 0 if immediate, Long.MAX_VALUE if untimed\n+         * @return an item if matched, else e\n@@ -200,65 +167,17 @@\n-        abstract E transfer(E e, boolean timed, long nanos);\n-    }\n-\n-    \/**\n-     * The number of nanoseconds for which it is faster to spin\n-     * rather than to use timed park. A rough estimate suffices.\n-     *\/\n-    static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1023L;\n-\n-    \/** Dual stack *\/\n-    static final class TransferStack<E> extends Transferer<E> {\n-        \/*\n-         * This extends Scherer-Scott dual stack algorithm, differing,\n-         * among other ways, by using \"covering\" nodes rather than\n-         * bit-marked pointers: Fulfilling operations push on marker\n-         * nodes (with FULFILLING bit set in mode) to reserve a spot\n-         * to match a waiting node.\n-         *\/\n-\n-        \/* Modes for SNodes, ORed together in node fields *\/\n-        \/** Node represents an unfulfilled consumer *\/\n-        static final int REQUEST    = 0;\n-        \/** Node represents an unfulfilled producer *\/\n-        static final int DATA       = 1;\n-        \/** Node is fulfilling another unfulfilled DATA or REQUEST *\/\n-        static final int FULFILLING = 2;\n-\n-        \/** Returns true if m has fulfilling bit set. *\/\n-        static boolean isFulfilling(int m) { return (m & FULFILLING) != 0; }\n-\n-        \/** Node class for TransferStacks. *\/\n-        static final class SNode implements ForkJoinPool.ManagedBlocker {\n-            volatile SNode next;        \/\/ next node in stack\n-            volatile SNode match;       \/\/ the node matched to this\n-            volatile Thread waiter;     \/\/ to control park\/unpark\n-            Object item;                \/\/ data; or null for REQUESTs\n-            int mode;\n-            \/\/ Note: item and mode fields don't need to be volatile\n-            \/\/ since they are always written before, and read after,\n-            \/\/ other volatile\/atomic operations.\n-\n-            SNode(Object item) {\n-                this.item = item;\n-            }\n-\n-            boolean casNext(SNode cmp, SNode val) {\n-                return cmp == next &&\n-                    SNEXT.compareAndSet(this, cmp, val);\n-            }\n-\n-            \/**\n-             * Tries to match node s to this node, if so, waking up thread.\n-             * Fulfillers call tryMatch to identify their waiters.\n-             * Waiters block until they have been matched.\n-             *\n-             * @param s the node to match\n-             * @return true if successfully matched to s\n-             *\/\n-            boolean tryMatch(SNode s) {\n-                SNode m; Thread w;\n-                if ((m = match) == null) {\n-                    if (SMATCH.compareAndSet(this, null, s)) {\n-                        if ((w = waiter) != null)\n-                            LockSupport.unpark(w);\n-                        return true;\n+        final Object xferLifo(Object e, long ns) {\n+            boolean haveData = (e != null);\n+            Object m;                              \/\/ the match or e if none\n+            outer: for (DualNode s = null, p = head;;) {\n+                while (p != null) {\n+                    boolean isData; DualNode n, u; \/\/ help collapse\n+                    if ((isData = p.isData) != ((m = p.item) != null))\n+                        p = (p == (u = cmpExHead(p, (n = p.next)))) ? n : u;\n+                    else if (isData == haveData)   \/\/ same mode; push below\n+                        break;\n+                    else if (p.cmpExItem(m, e) != m)\n+                        p = head;                  \/\/ missed; restart\n+                    else {                         \/\/ matched complementary node\n+                        Thread w = p.waiter;\n+                        cmpExHead(p, p.next);\n+                        LockSupport.unpark(w);\n+                        break outer;\n@@ -266,42 +185,0 @@\n-                    else\n-                        m = match;\n-                }\n-                return m == s;\n-            }\n-\n-            \/**\n-             * Tries to cancel a wait by matching node to itself.\n-             *\/\n-            boolean tryCancel() {\n-                return SMATCH.compareAndSet(this, null, this);\n-            }\n-\n-            boolean isCancelled() {\n-                return match == this;\n-            }\n-\n-            public final boolean isReleasable() {\n-                return match != null || Thread.currentThread().isInterrupted();\n-            }\n-\n-            public final boolean block() {\n-                while (!isReleasable()) LockSupport.park();\n-                return true;\n-            }\n-\n-            void forgetWaiter() {\n-                SWAITER.setOpaque(this, null);\n-            }\n-\n-            \/\/ VarHandle mechanics\n-            private static final VarHandle SMATCH;\n-            private static final VarHandle SNEXT;\n-            private static final VarHandle SWAITER;\n-            static {\n-                try {\n-                    MethodHandles.Lookup l = MethodHandles.lookup();\n-                    SMATCH = l.findVarHandle(SNode.class, \"match\", SNode.class);\n-                    SNEXT = l.findVarHandle(SNode.class, \"next\", SNode.class);\n-                    SWAITER = l.findVarHandle(SNode.class, \"waiter\", Thread.class);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new ExceptionInInitializerError(e);\n@@ -309,131 +186,3 @@\n-            }\n-        }\n-\n-        \/** The head (top) of the stack *\/\n-        volatile SNode head;\n-\n-        boolean casHead(SNode h, SNode nh) {\n-            return h == head &&\n-                SHEAD.compareAndSet(this, h, nh);\n-        }\n-\n-        \/**\n-         * Creates or resets fields of a node. Called only from transfer\n-         * where the node to push on stack is lazily created and\n-         * reused when possible to help reduce intervals between reads\n-         * and CASes of head and to avoid surges of garbage when CASes\n-         * to push nodes fail due to contention.\n-         *\/\n-        static SNode snode(SNode s, Object e, SNode next, int mode) {\n-            if (s == null) s = new SNode(e);\n-            s.mode = mode;\n-            s.next = next;\n-            return s;\n-        }\n-\n-        \/**\n-         * Puts or takes an item.\n-         *\/\n-        @SuppressWarnings(\"unchecked\")\n-        E transfer(E e, boolean timed, long nanos) {\n-            \/*\n-             * Basic algorithm is to loop trying one of three actions:\n-             *\n-             * 1. If apparently empty or already containing nodes of same\n-             *    mode, try to push node on stack and wait for a match,\n-             *    returning it, or null if cancelled.\n-             *\n-             * 2. If apparently containing node of complementary mode,\n-             *    try to push a fulfilling node on to stack, match\n-             *    with corresponding waiting node, pop both from\n-             *    stack, and return matched item. The matching or\n-             *    unlinking might not actually be necessary because of\n-             *    other threads performing action 3:\n-             *\n-             * 3. If top of stack already holds another fulfilling node,\n-             *    help it out by doing its match and\/or pop\n-             *    operations, and then continue. The code for helping\n-             *    is essentially the same as for fulfilling, except\n-             *    that it doesn't return the item.\n-             *\/\n-\n-            SNode s = null; \/\/ constructed\/reused as needed\n-            int mode = (e == null) ? REQUEST : DATA;\n-\n-            for (;;) {\n-                SNode h = head;\n-                if (h == null || h.mode == mode) {  \/\/ empty or same-mode\n-                    if (timed && nanos <= 0L) {     \/\/ can't wait\n-                        if (h != null && h.isCancelled())\n-                            casHead(h, h.next);     \/\/ pop cancelled node\n-                        else\n-                            return null;\n-                    } else if (casHead(h, s = snode(s, e, h, mode))) {\n-                        long deadline = timed ? System.nanoTime() + nanos : 0L;\n-                        Thread w = Thread.currentThread();\n-                        int stat = -1; \/\/ -1: may yield, +1: park, else 0\n-                        SNode m;                    \/\/ await fulfill or cancel\n-                        while ((m = s.match) == null) {\n-                            if ((timed &&\n-                                 (nanos = deadline - System.nanoTime()) <= 0) ||\n-                                w.isInterrupted()) {\n-                                if (s.tryCancel()) {\n-                                    clean(s);       \/\/ wait cancelled\n-                                    return null;\n-                                }\n-                            } else if ((m = s.match) != null) {\n-                                break;              \/\/ recheck\n-                            } else if (stat <= 0) {\n-                                if (stat < 0 && h == null && head == s) {\n-                                    stat = 0;       \/\/ yield once if was empty\n-                                    Thread.yield();\n-                                } else {\n-                                    stat = 1;\n-                                    s.waiter = w;   \/\/ enable signal\n-                                }\n-                            } else if (!timed) {\n-                                LockSupport.setCurrentBlocker(this);\n-                                try {\n-                                    ForkJoinPool.managedBlock(s);\n-                                } catch (InterruptedException cannotHappen) { }\n-                                LockSupport.setCurrentBlocker(null);\n-                            } else if (nanos > SPIN_FOR_TIMEOUT_THRESHOLD)\n-                                LockSupport.parkNanos(this, nanos);\n-                        }\n-                        if (stat == 1)\n-                            s.forgetWaiter();\n-                        Object result = (mode == REQUEST) ? m.item : s.item;\n-                        if (h != null && h.next == s)\n-                            casHead(h, s.next);     \/\/ help fulfiller\n-                        return (E) result;\n-                    }\n-                } else if (!isFulfilling(h.mode)) { \/\/ try to fulfill\n-                    if (h.isCancelled())            \/\/ already cancelled\n-                        casHead(h, h.next);         \/\/ pop and retry\n-                    else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {\n-                        for (;;) { \/\/ loop until matched or waiters disappear\n-                            SNode m = s.next;       \/\/ m is s's match\n-                            if (m == null) {        \/\/ all waiters are gone\n-                                casHead(s, null);   \/\/ pop fulfill node\n-                                s = null;           \/\/ use new node next time\n-                                break;              \/\/ restart main loop\n-                            }\n-                            SNode mn = m.next;\n-                            if (m.tryMatch(s)) {\n-                                casHead(s, mn);     \/\/ pop both s and m\n-                                return (E) ((mode == REQUEST) ? m.item : s.item);\n-                            } else                  \/\/ lost match\n-                                s.casNext(m, mn);   \/\/ help unlink\n-                        }\n-                    }\n-                } else {                            \/\/ help a fulfiller\n-                    SNode m = h.next;               \/\/ m is h's match\n-                    if (m == null)                  \/\/ waiter is gone\n-                        casHead(h, null);           \/\/ pop fulfilling node\n-                    else {\n-                        SNode mn = m.next;\n-                        if (m.tryMatch(h))          \/\/ help match\n-                            casHead(h, mn);         \/\/ pop both h and m\n-                        else                        \/\/ lost match\n-                            h.casNext(m, mn);       \/\/ help unlink\n-                    }\n+                if (ns == 0L) {                    \/\/ no match, no wait\n+                    m = e;\n+                    break;\n@@ -441,137 +190,8 @@\n-            }\n-        }\n-\n-        \/**\n-         * Unlinks s from the stack.\n-         *\/\n-        void clean(SNode s) {\n-            s.item = null;   \/\/ forget item\n-            s.forgetWaiter();\n-\n-            \/*\n-             * At worst we may need to traverse entire stack to unlink\n-             * s. If there are multiple concurrent calls to clean, we\n-             * might not see s if another thread has already removed\n-             * it. But we can stop when we see any node known to\n-             * follow s. We use s.next unless it too is cancelled, in\n-             * which case we try the node one past. We don't check any\n-             * further because we don't want to doubly traverse just to\n-             * find sentinel.\n-             *\/\n-\n-            SNode past = s.next;\n-            if (past != null && past.isCancelled())\n-                past = past.next;\n-\n-            \/\/ Absorb cancelled nodes at head\n-            SNode p;\n-            while ((p = head) != null && p != past && p.isCancelled())\n-                casHead(p, p.next);\n-\n-            \/\/ Unsplice embedded nodes\n-            while (p != null && p != past) {\n-                SNode n = p.next;\n-                if (n != null && n.isCancelled())\n-                    p.casNext(n, n.next);\n-                else\n-                    p = n;\n-            }\n-        }\n-\n-        \/\/ VarHandle mechanics\n-        private static final VarHandle SHEAD;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                SHEAD = l.findVarHandle(TransferStack.class, \"head\", SNode.class);\n-            } catch (ReflectiveOperationException e) {\n-                throw new ExceptionInInitializerError(e);\n-            }\n-        }\n-    }\n-\n-    \/** Dual Queue *\/\n-    static final class TransferQueue<E> extends Transferer<E> {\n-        \/*\n-         * This extends Scherer-Scott dual queue algorithm, differing,\n-         * among other ways, by using modes within nodes rather than\n-         * marked pointers. The algorithm is a little simpler than\n-         * that for stacks because fulfillers do not need explicit\n-         * nodes, and matching is done by CAS'ing QNode.item field\n-         * from non-null to null (for put) or vice versa (for take).\n-         *\/\n-\n-        \/** Node class for TransferQueue. *\/\n-        static final class QNode implements ForkJoinPool.ManagedBlocker {\n-            volatile QNode next;          \/\/ next node in queue\n-            volatile Object item;         \/\/ CAS'ed to or from null\n-            volatile Thread waiter;       \/\/ to control park\/unpark\n-            final boolean isData;\n-\n-            QNode(Object item, boolean isData) {\n-                this.item = item;\n-                this.isData = isData;\n-            }\n-\n-            boolean casNext(QNode cmp, QNode val) {\n-                return next == cmp &&\n-                    QNEXT.compareAndSet(this, cmp, val);\n-            }\n-\n-            boolean casItem(Object cmp, Object val) {\n-                return item == cmp &&\n-                    QITEM.compareAndSet(this, cmp, val);\n-            }\n-\n-            \/**\n-             * Tries to cancel by CAS'ing ref to this as item.\n-             *\/\n-            boolean tryCancel(Object cmp) {\n-                return QITEM.compareAndSet(this, cmp, this);\n-            }\n-\n-            boolean isCancelled() {\n-                return item == this;\n-            }\n-\n-            \/**\n-             * Returns true if this node is known to be off the queue\n-             * because its next pointer has been forgotten due to\n-             * an advanceHead operation.\n-             *\/\n-            boolean isOffList() {\n-                return next == this;\n-            }\n-\n-            void forgetWaiter() {\n-                QWAITER.setOpaque(this, null);\n-            }\n-\n-            boolean isFulfilled() {\n-                Object x;\n-                return isData == ((x = item) == null) || x == this;\n-            }\n-\n-            public final boolean isReleasable() {\n-                Object x;\n-                return isData == ((x = item) == null) || x == this ||\n-                    Thread.currentThread().isInterrupted();\n-            }\n-\n-            public final boolean block() {\n-                while (!isReleasable()) LockSupport.park();\n-                return true;\n-            }\n-\n-            \/\/ VarHandle mechanics\n-            private static final VarHandle QITEM;\n-            private static final VarHandle QNEXT;\n-            private static final VarHandle QWAITER;\n-            static {\n-                try {\n-                    MethodHandles.Lookup l = MethodHandles.lookup();\n-                    QITEM = l.findVarHandle(QNode.class, \"item\", Object.class);\n-                    QNEXT = l.findVarHandle(QNode.class, \"next\", QNode.class);\n-                    QWAITER = l.findVarHandle(QNode.class, \"waiter\", Thread.class);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new ExceptionInInitializerError(e);\n+                if (s == null)                     \/\/ try to push node and wait\n+                    s = new DualNode(e, haveData);\n+                s.next = p;\n+                if (p == (p = cmpExHead(p, s))) {\n+                    if ((m = s.await(e, ns, this,  \/\/ spin if (nearly) empty\n+                                     p == null || p.waiter == null)) == e)\n+                        unspliceLifo(s);           \/\/ cancelled\n+                    break;\n@@ -580,27 +200,1 @@\n-        }\n-\n-        \/** Head of queue *\/\n-        transient volatile QNode head;\n-        \/** Tail of queue *\/\n-        transient volatile QNode tail;\n-        \/**\n-         * Reference to a cancelled node that might not yet have been\n-         * unlinked from queue because it was the last inserted node\n-         * when it was cancelled.\n-         *\/\n-        transient volatile QNode cleanMe;\n-\n-        TransferQueue() {\n-            QNode h = new QNode(null, false); \/\/ initialize to dummy node.\n-            head = h;\n-            tail = h;\n-        }\n-\n-        \/**\n-         * Tries to cas nh as new head; if successful, unlink\n-         * old head's next node to avoid garbage retention.\n-         *\/\n-        void advanceHead(QNode h, QNode nh) {\n-            if (h == head &&\n-                QHEAD.compareAndSet(this, h, nh))\n-                h.next = h; \/\/ forget old next\n+            return m;\n@@ -610,1 +204,1 @@\n-         * Tries to cas nt as new tail.\n+         * Unlinks node s. Same idea as Fifo version.\n@@ -612,116 +206,7 @@\n-        void advanceTail(QNode t, QNode nt) {\n-            if (tail == t)\n-                QTAIL.compareAndSet(this, t, nt);\n-        }\n-\n-        \/**\n-         * Tries to CAS cleanMe slot.\n-         *\/\n-        boolean casCleanMe(QNode cmp, QNode val) {\n-            return cleanMe == cmp &&\n-                QCLEANME.compareAndSet(this, cmp, val);\n-        }\n-\n-        \/**\n-         * Puts or takes an item.\n-         *\/\n-        @SuppressWarnings(\"unchecked\")\n-        E transfer(E e, boolean timed, long nanos) {\n-            \/* Basic algorithm is to loop trying to take either of\n-             * two actions:\n-             *\n-             * 1. If queue apparently empty or holding same-mode nodes,\n-             *    try to add node to queue of waiters, wait to be\n-             *    fulfilled (or cancelled) and return matching item.\n-             *\n-             * 2. If queue apparently contains waiting items, and this\n-             *    call is of complementary mode, try to fulfill by CAS'ing\n-             *    item field of waiting node and dequeuing it, and then\n-             *    returning matching item.\n-             *\n-             * In each case, along the way, check for and try to help\n-             * advance head and tail on behalf of other stalled\/slow\n-             * threads.\n-             *\n-             * The loop starts off with a null check guarding against\n-             * seeing uninitialized head or tail values. This never\n-             * happens in current SynchronousQueue, but could if\n-             * callers held non-volatile\/final ref to the\n-             * transferer. The check is here anyway because it places\n-             * null checks at top of loop, which is usually faster\n-             * than having them implicitly interspersed.\n-             *\/\n-\n-            QNode s = null;                  \/\/ constructed\/reused as needed\n-            boolean isData = (e != null);\n-            for (;;) {\n-                QNode t = tail, h = head, m, tn;         \/\/ m is node to fulfill\n-                if (t == null || h == null)\n-                    ;                                    \/\/ inconsistent\n-                else if (h == t || t.isData == isData) { \/\/ empty or same-mode\n-                    if (t != tail)                       \/\/ inconsistent\n-                        ;\n-                    else if ((tn = t.next) != null)      \/\/ lagging tail\n-                        advanceTail(t, tn);\n-                    else if (timed && nanos <= 0L)       \/\/ can't wait\n-                        return null;\n-                    else if (t.casNext(null, (s != null) ? s :\n-                                       (s = new QNode(e, isData)))) {\n-                        advanceTail(t, s);\n-                        long deadline = timed ? System.nanoTime() + nanos : 0L;\n-                        Thread w = Thread.currentThread();\n-                        int stat = -1; \/\/ same idea as TransferStack\n-                        Object item;\n-                        while ((item = s.item) == e) {\n-                            if ((timed &&\n-                                 (nanos = deadline - System.nanoTime()) <= 0) ||\n-                                w.isInterrupted()) {\n-                                if (s.tryCancel(e)) {\n-                                    clean(t, s);\n-                                    return null;\n-                                }\n-                            } else if ((item = s.item) != e) {\n-                                break;                   \/\/ recheck\n-                            } else if (stat <= 0) {\n-                                if (t.next == s) {\n-                                    if (stat < 0 && t.isFulfilled()) {\n-                                        stat = 0;        \/\/ yield once if first\n-                                        Thread.yield();\n-                                    }\n-                                    else {\n-                                        stat = 1;\n-                                        s.waiter = w;\n-                                    }\n-                                }\n-                            } else if (!timed) {\n-                                LockSupport.setCurrentBlocker(this);\n-                                try {\n-                                    ForkJoinPool.managedBlock(s);\n-                                } catch (InterruptedException cannotHappen) { }\n-                                LockSupport.setCurrentBlocker(null);\n-                            }\n-                            else if (nanos > SPIN_FOR_TIMEOUT_THRESHOLD)\n-                                LockSupport.parkNanos(this, nanos);\n-                        }\n-                        if (stat == 1)\n-                            s.forgetWaiter();\n-                        if (!s.isOffList()) {            \/\/ not already unlinked\n-                            advanceHead(t, s);           \/\/ unlink if head\n-                            if (item != null)            \/\/ and forget fields\n-                                s.item = s;\n-                        }\n-                        return (item != null) ? (E)item : e;\n-                    }\n-\n-                } else if ((m = h.next) != null && t == tail && h == head) {\n-                    Thread waiter;\n-                    Object x = m.item;\n-                    boolean fulfilled = ((isData == (x == null)) &&\n-                                         x != m && m.casItem(x, e));\n-                    advanceHead(h, m);                    \/\/ (help) dequeue\n-                    if (fulfilled) {\n-                        if ((waiter = m.waiter) != null)\n-                            LockSupport.unpark(waiter);\n-                        return (x != null) ? (E)x : e;\n-                    }\n-                }\n+        private void unspliceLifo(DualNode s) {\n+            boolean seen = false; \/\/ try removing by collapsing head\n+            DualNode p = head;\n+            for (DualNode f, u; p != null && p.matched();) {\n+                if (p == s)\n+                    seen = true;\n+                p = (p == (u = cmpExHead(p, (f = p.next)))) ? f : u;\n@@ -729,21 +214,4 @@\n-        }\n-\n-        \/**\n-         * Gets rid of cancelled node s with original predecessor pred.\n-         *\/\n-        void clean(QNode pred, QNode s) {\n-            s.forgetWaiter();\n-            \/*\n-             * At any given time, exactly one node on list cannot be\n-             * deleted -- the last inserted node. To accommodate this,\n-             * if we cannot delete s, we save its predecessor as\n-             * \"cleanMe\", deleting the previously saved version\n-             * first. At least one of node s or the node previously\n-             * saved can always be deleted, so this always terminates.\n-             *\/\n-            while (pred.next == s) { \/\/ Return early if already unlinked\n-                QNode h = head;\n-                QNode hn = h.next;   \/\/ Absorb cancelled first node as head\n-                if (hn != null && hn.isCancelled()) {\n-                    advanceHead(h, hn);\n-                    continue;\n+            if (p != null && !seen && sweepNow()) { \/\/ occasionally sweep\n+                for (DualNode f, n, u; p != null && (f = p.next) != null; ) {\n+                    p = (!f.matched() ? f :\n+                         f == (u = p.cmpExNext(f, n = f.next)) ? n : u);\n@@ -751,49 +219,0 @@\n-                QNode t = tail;      \/\/ Ensure consistent read for tail\n-                if (t == h)\n-                    return;\n-                QNode tn = t.next;\n-                if (t != tail)\n-                    continue;\n-                if (tn != null) {\n-                    advanceTail(t, tn);\n-                    continue;\n-                }\n-                if (s != t) {        \/\/ If not tail, try to unsplice\n-                    QNode sn = s.next;\n-                    if (sn == s || pred.casNext(s, sn))\n-                        return;\n-                }\n-                QNode dp = cleanMe;\n-                if (dp != null) {    \/\/ Try unlinking previous cancelled node\n-                    QNode d = dp.next;\n-                    QNode dn;\n-                    if (d == null ||               \/\/ d is gone or\n-                        d == dp ||                 \/\/ d is off list or\n-                        !d.isCancelled() ||        \/\/ d not cancelled or\n-                        (d != t &&                 \/\/ d not tail and\n-                         (dn = d.next) != null &&  \/\/   has successor\n-                         dn != d &&                \/\/   that is on list\n-                         dp.casNext(d, dn)))       \/\/ d unspliced\n-                        casCleanMe(dp, null);\n-                    if (dp == pred)\n-                        return;      \/\/ s is already saved node\n-                } else if (casCleanMe(null, pred))\n-                    return;          \/\/ Postpone cleaning s\n-            }\n-        }\n-\n-        \/\/ VarHandle mechanics\n-        private static final VarHandle QHEAD;\n-        private static final VarHandle QTAIL;\n-        private static final VarHandle QCLEANME;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                QHEAD = l.findVarHandle(TransferQueue.class, \"head\",\n-                                        QNode.class);\n-                QTAIL = l.findVarHandle(TransferQueue.class, \"tail\",\n-                                        QNode.class);\n-                QCLEANME = l.findVarHandle(TransferQueue.class, \"cleanMe\",\n-                                           QNode.class);\n-            } catch (ReflectiveOperationException e) {\n-                throw new ExceptionInInitializerError(e);\n@@ -805,5 +224,1 @@\n-     * The transferer. Set only in constructor, but cannot be declared\n-     * as final without further complicating serialization.  Since\n-     * this is accessed only at most once per public method, there\n-     * isn't a noticeable performance penalty for using volatile\n-     * instead of final here.\n+     * The transferer. (See below about serialization.)\n@@ -811,1 +226,9 @@\n-    private transient volatile Transferer<E> transferer;\n+    private final transient Transferer<E> transferer;\n+\n+    private final transient boolean fair;\n+\n+    \/** Invokes fair or lifo transfer *\/\n+    private Object xfer(Object e, long nanos) {\n+        Transferer<E> x = transferer;\n+        return (fair) ? x.xfer(e, nanos) : x.xferLifo(e, nanos);\n+    }\n@@ -827,1 +250,2 @@\n-        transferer = fair ? new TransferQueue<E>() : new TransferStack<E>();\n+        this.fair = fair;\n+        transferer = new Transferer<E>();\n@@ -838,4 +262,5 @@\n-        if (e == null) throw new NullPointerException();\n-        if (transferer.transfer(e, false, 0) == null) {\n-            Thread.interrupted();\n-            throw new InterruptedException();\n+        Objects.requireNonNull(e);\n+        if (!Thread.interrupted()) {\n+            if (xfer(e, Long.MAX_VALUE) == null)\n+                return;\n+            Thread.interrupted(); \/\/ failure possible only due to interrupt\n@@ -843,0 +268,1 @@\n+        throw new InterruptedException();\n@@ -856,2 +282,3 @@\n-        if (e == null) throw new NullPointerException();\n-        if (transferer.transfer(e, true, unit.toNanos(timeout)) != null)\n+        Objects.requireNonNull(e);\n+        long nanos = Math.max(unit.toNanos(timeout), 0L);\n+        if (xfer(e, nanos) == null)\n@@ -874,2 +301,2 @@\n-        if (e == null) throw new NullPointerException();\n-        return transferer.transfer(e, true, 0) != null;\n+        Objects.requireNonNull(e);\n+        return xfer(e, 0L) == null;\n@@ -885,0 +312,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -886,4 +314,6 @@\n-        E e = transferer.transfer(null, false, 0);\n-        if (e != null)\n-            return e;\n-        Thread.interrupted();\n+        Object e;\n+        if (!Thread.interrupted()) {\n+            if ((e = xfer(null, Long.MAX_VALUE)) != null)\n+                return (E) e;\n+            Thread.interrupted();\n+        }\n@@ -902,0 +332,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -903,3 +334,4 @@\n-        E e = transferer.transfer(null, true, unit.toNanos(timeout));\n-        if (e != null || !Thread.interrupted())\n-            return e;\n+        Object e;\n+        long nanos = Math.max(unit.toNanos(timeout), 0L);\n+        if ((e = xfer(null, nanos)) != null || !Thread.interrupted())\n+            return (E) e;\n@@ -916,0 +348,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -917,1 +350,1 @@\n-        return transferer.transfer(null, true, 0);\n+        return (E) xfer(null, 0L);\n@@ -1107,5 +540,7 @@\n-     * To cope with serialization strategy in the 1.5 version of\n-     * SynchronousQueue, we declare some unused classes and fields\n-     * that exist solely to enable serializability across versions.\n-     * These fields are never used, so are initialized only if this\n-     * object is ever serialized or deserialized.\n+     * To cope with serialization across multiple implementation\n+     * overhauls, we declare some unused classes and fields that exist\n+     * solely to enable serializability across versions.  These fields\n+     * are never used, so are initialized only if this object is ever\n+     * serialized. We use readResolve to replace a deserialized queue\n+     * with a fresh one. Note that no queue elements are serialized,\n+     * since any existing ones are only transient.\n@@ -1133,1 +568,0 @@\n-        boolean fair = transferer instanceof TransferQueue;\n@@ -1148,5 +582,2 @@\n-     * Reconstitutes this queue from a stream (that is, deserializes it).\n-     * @param s the stream\n-     * @throws ClassNotFoundException if the class of a serialized object\n-     *         could not be found\n-     * @throws java.io.IOException if an I\/O error occurs\n+     * Replaces a deserialized SynchronousQueue with a fresh one with\n+     * the associated fairness\n@@ -1154,13 +585,2 @@\n-    private void readObject(java.io.ObjectInputStream s)\n-        throws java.io.IOException, ClassNotFoundException {\n-        s.defaultReadObject();\n-        if (waitingProducers instanceof FifoWaitQueue)\n-            transferer = new TransferQueue<E>();\n-        else\n-            transferer = new TransferStack<E>();\n-    }\n-\n-    static {\n-        \/\/ Reduce the risk of rare disastrous classloading in first call to\n-        \/\/ LockSupport.park: https:\/\/bugs.openjdk.org\/browse\/JDK-8074773\n-        Class<?> ensureLoaded = LockSupport.class;\n+    private Object readResolve() {\n+        return new SynchronousQueue<E>(waitingProducers instanceof FifoWaitQueue);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SynchronousQueue.java","additions":144,"deletions":724,"binary":false,"changes":868,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,3 @@\n+    \/** Gets the shared array of exception types of an Executable. *\/\n+    public Class<?>[] getExecutableSharedExceptionTypes(Executable ex);\n+\n@@ -105,7 +108,0 @@\n-\n-    \/** Invokes the given default method if the method's declaring interface is\n-     *  accessible to the given caller.  Otherwise, IllegalAccessException will\n-     *  be thrown.  If the caller is null, no access check is performed.\n-     *\/\n-    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n-        throws Throwable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -572,0 +572,1 @@\n+    int ACC_IDENTITY = 0x0020;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    String DEFAULT_PROVIDER_MODULE_NAME = \"java.base\";\n+    String DEFAULT_PROVIDER_MODULE_NAME = \"jdk.internal.le\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,2 +309,2 @@\n-    public interface VecExtractOp<V extends Vector<?>> {\n-        long apply(V v, int i);\n+    public interface VecExtractOp<VM extends VectorPayload> {\n+        long apply(VM vm, int i);\n@@ -315,1 +315,1 @@\n-    <V extends Vector<E>,\n+    <VM extends VectorPayload,\n@@ -317,1 +317,1 @@\n-    long extract(Class<? extends V> vClass, Class<E> eClass,\n+    long extract(Class<? extends VM> vClass, Class<E> eClass,\n@@ -319,2 +319,2 @@\n-                 V v, int i,\n-                 VecExtractOp<V> defaultImpl) {\n+                 VM vm, int i,\n+                 VecExtractOp<VM> defaultImpl) {\n@@ -322,1 +322,1 @@\n-        return defaultImpl.apply(v, i);\n+        return defaultImpl.apply(vm, i);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.invoke;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Private API used inside of java.lang.invoke.MethodHandles.\n- * Interface implemented by every object which is produced by\n- * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance MethodHandleProxies.asInterfaceInstance}.\n- * The methods of this interface allow a caller to recover the parameters\n- * to {@code asInstance}.\n- * This allows applications to repeatedly convert between method handles\n- * and SAM objects, without the risk of creating unbounded delegation chains.\n- *\/\n-public interface WrapperInstance {\n-    \/** Produce or recover a target method handle which is behaviorally\n-     *  equivalent to the SAM method of this object.\n-     *\/\n-    public MethodHandle getWrapperInstanceTarget();\n-    \/** Recover the SAM type for which this object was created.\n-     *\/\n-    public Class<?> getWrapperInstanceType();\n-}\n-\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/WrapperInstance.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -137,1 +137,1 @@\n-\\    -Xdebug           does nothing. Provided for backward compatibility.\\n\\\n+\\    -Xdebug           does nothing; deprecated for removal in a future release.\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -417,2 +417,2 @@\n-        flushLeftoverChar(null, true);\n-        try {\n+        try (ch; out) {\n+            flushLeftoverChar(null, true);\n@@ -433,9 +433,2 @@\n-            if (ch != null)\n-                ch.close();\n-            else {\n-                try {\n-                    out.flush();\n-                } finally {\n-                    out.close();\n-                }\n-            }\n+            if (out != null)\n+                out.flush();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamEncoder.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Locale;\n@@ -197,1 +198,1 @@\n-        if (rawPropVal.toLowerCase().endsWith(\"ms\")) {\n+        if (rawPropVal.toLowerCase(Locale.ROOT).endsWith(\"ms\")) {\n@@ -200,1 +201,1 @@\n-        } else if (rawPropVal.toLowerCase().endsWith(\"s\")) {\n+        } else if (rawPropVal.toLowerCase(Locale.ROOT).endsWith(\"s\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/GetPropertyAction.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Locale;\n@@ -56,1 +57,1 @@\n-        nameMap.put(name.toLowerCase(), params);\n+        nameMap.put(name.toLowerCase(Locale.ROOT), params);\n@@ -68,1 +69,1 @@\n-        return Optional.ofNullable(nameMap.get(name.toLowerCase()));\n+        return Optional.ofNullable(nameMap.get(name.toLowerCase(Locale.ROOT)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ParametersMap.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-        namedParams.put(name.toLowerCase(), oid, bits, params);\n+        namedParams.put(name, oid, bits, params);\n@@ -173,1 +173,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XECParameters.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1136,1 +1136,2 @@\n-                0xff & tag, buffer, start, end);\n+                0xff & tag, HexFormat.of().withUpperCase().formatHex(buffer),\n+                start, end);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,2 +131,1 @@\n-        String algorithm = parameters.getAlgorithm();\n-        switch (algorithm) {\n+        switch (parameters.getAlgorithm()) {\n@@ -134,2 +133,4 @@\n-                try {\n-                    ECKeySizeParameterSpec ps = parameters.getParameterSpec(\n+                \/\/ ECKeySizeParameterSpec is SunEC internal only\n+                if (parameters.getProvider().getName().equals(\"SunEC\")) {\n+                    try {\n+                        ECKeySizeParameterSpec ps = parameters.getParameterSpec(\n@@ -137,2 +138,5 @@\n-                    if (ps != null) {\n-                        return ps.getKeySize();\n+                        if (ps != null) {\n+                            return ps.getKeySize();\n+                        }\n+                    } catch (InvalidParameterSpecException ipse) {\n+                        \/\/ ignore\n@@ -140,2 +144,0 @@\n-                } catch (InvalidParameterSpecException ipse) {\n-                    \/\/ ignore\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -340,6 +340,0 @@\n-    \/**\n-     * Create the X400Address object from the specified byte array\n-     *\n-     * @param value value of the name as a byte array\n-     *\/\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X400Address.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -841,2 +841,1 @@\n-Does nothing.\n-Provided for backward compatibility.\n+Does nothing; deprecated for removal in a future release.\n","filename":"src\/java.base\/share\/man\/java.1","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1393,1 +1393,1 @@\n-            AddOption(\"-Xdebug\", NULL);\n+            JLI_ReportErrorMessage(ARG_DEPRECATED, \"-debug\");\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -400,0 +400,77 @@\n+   private static final byte[] resolve(byte[] base, byte[]... children) {\n+       \/\/ 'start' is either zero, indicating the base, or indicates which\n+       \/\/ child is that last one which is an absolute path\n+       int start = 0;\n+       int resultLength = base.length;\n+\n+       \/\/ Locate the last child which is an absolute path and calculate\n+       \/\/ the total number of bytes in the resolved path\n+       final int count = children.length;\n+       if (count > 0) {\n+           for (int i = 0; i < count; i++) {\n+               byte[] b = children[i];\n+               if (b.length > 0) {\n+                   if (b[0] == '\/') {\n+                       start = i + 1;\n+                       resultLength = b.length;\n+                   } else {\n+                       if (resultLength > 0)\n+                           resultLength++;\n+                       resultLength += b.length;\n+                   }\n+               }\n+           }\n+       }\n+\n+       \/\/ If the base is not being superseded by a child which is an\n+       \/\/ absolute path, then if at least one child is non-empty and\n+       \/\/ the base consists only of a '\/', then decrement resultLength to\n+       \/\/ account for an extra '\/' added in the resultLength computation.\n+       if (start == 0 && resultLength > base.length && base.length == 1 && base[0] == '\/')\n+           resultLength--;\n+\n+       \/\/ Allocate the result array and return if empty.\n+       byte[] result = new byte[resultLength];\n+       if (result.length == 0)\n+           return result;\n+\n+       \/\/ Prepend the base if it is non-empty and would not later be\n+       \/\/ overwritten by an absolute child\n+       int offset = 0;\n+       if (start == 0 && base.length > 0) {\n+           System.arraycopy(base, 0, result, 0, base.length);\n+           offset += base.length;\n+       }\n+\n+       \/\/ Append children starting with the last one which is an\n+       \/\/ absolute path\n+       if (count > 0) {\n+           int idx = Math.max(0, start - 1);\n+           for (int i = idx; i < count; i++) {\n+               byte[] b = children[i];\n+               if (b.length > 0) {\n+                   if (offset > 0 && result[offset - 1] != '\/')\n+                       result[offset++] = '\/';\n+                   System.arraycopy(b, 0, result, offset, b.length);\n+                   offset += b.length;\n+               }\n+           }\n+       }\n+\n+       return result;\n+   }\n+\n+    @Override\n+    public UnixPath resolve(Path first, Path... more) {\n+        if (more.length == 0)\n+            return resolve(first);\n+\n+        byte[][] children = new byte[1 + more.length][];\n+        children[0] = toUnixPath(first).path;\n+        for (int i = 0; i < more.length; i++)\n+            children[i + 1] = toUnixPath(more[i]).path;\n+\n+        byte[] result = resolve(path, children);\n+        return new UnixPath(getFileSystem(), result);\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1935,0 +1935,2 @@\n+\n+        contextMenu.applyComponentOrientation(getFileChooser().getComponentOrientation());\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/FilePane.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1528,1 +1528,1 @@\n-                debug.log(\"Registering %s for %d (%s)\",\n+                debug.log(\"Registering %s for %s (%s)\",\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -333,3 +333,1 @@\n-        if ((*name)->name != NULL) {\n-            delete[] (*name)->name;\n-        }\n+        delete[] (*name)->name;\n@@ -422,3 +420,1 @@\n-    if (value != NULL) {\n-        delete[] value;\n-    }\n+    delete[] value;\n@@ -1026,3 +1022,1 @@\n-    if (newCred) {\n-        delete newCred;\n-    }\n+    delete newCred;\n@@ -1269,3 +1263,1 @@\n-    if (secBuff[1].pvBuffer) {\n-        free(secBuff[1].pvBuffer);\n-    }\n+    free(secBuff[1].pvBuffer);\n@@ -1345,1 +1337,1 @@\n-                    + context_handle->SecPkgContextSizes.cbBlockSize);;\n+                    + context_handle->SecPkgContextSizes.cbBlockSize);\n@@ -1396,9 +1388,4 @@\n-    if (secBuff[0].pvBuffer) {\n-        free(secBuff[0].pvBuffer);\n-    }\n-    if (secBuff[1].pvBuffer) {\n-        free(secBuff[1].pvBuffer);\n-    }\n-    if (secBuff[2].pvBuffer) {\n-        free(secBuff[2].pvBuffer);\n-    }\n+    free(secBuff[0].pvBuffer);\n+    free(secBuff[1].pvBuffer);\n+    free(secBuff[2].pvBuffer);\n+\n@@ -1471,3 +1458,1 @@\n-    if (secBuff[0].pvBuffer) {\n-        free(secBuff[0].pvBuffer);\n-    }\n+    free(secBuff[0].pvBuffer);\n@@ -1584,3 +1569,1 @@\n-    if (existing) {\n-        delete[] existing;\n-    }\n+    delete[] existing;\n@@ -1673,4 +1656,2 @@\n-    if (buffer->value) {\n-        free(buffer->value);\n-        buffer->value = NULL;\n-    }\n+    free(buffer->value);\n+    buffer->value = NULL;\n","filename":"src\/java.security.jgss\/windows\/native\/libsspi_bridge\/sspi.cpp","additions":13,"deletions":32,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+    \/\/ For externalization lint checking\n@@ -243,0 +244,2 @@\n+    public final Type objectInputType;\n+    public final Type objectOutputType;\n@@ -638,0 +641,2 @@\n+        objectInputType  = enterClass(\"java.io.ObjectInput\");\n+        objectOutputType = enterClass(\"java.io.ObjectOutput\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1702,0 +1702,1 @@\n+            boolean errorPrimitiveSwitch = seltype.isPrimitive() && !intSwitch;\n@@ -1703,1 +1704,2 @@\n-            if (!enumSwitch && !stringSwitch && !errorEnumSwitch && !intSwitch) {\n+            if (!enumSwitch && !stringSwitch && !errorEnumSwitch &&\n+                !intSwitch && !errorPrimitiveSwitch) {\n@@ -1707,0 +1709,3 @@\n+                if (errorPrimitiveSwitch) {\n+                    log.error(selector.pos(), Errors.SelectorTypeNotAllowed(seltype));\n+                }\n@@ -1789,1 +1794,1 @@\n-                                } else if (!stringSwitch && !intSwitch) {\n+                                } else if (!stringSwitch && !intSwitch && !errorPrimitiveSwitch) {\n@@ -1812,1 +1817,3 @@\n-                        checkCastablePattern(pat.pos(), seltype, primaryType);\n+                        if (!errorPrimitiveSwitch) {\n+                            checkCastablePattern(pat.pos(), seltype, primaryType);\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -5025,2 +5025,1 @@\n-        }\n-        catch (CompletionFailure e) {\n+        } catch (CompletionFailure e) {\n@@ -5397,0 +5396,19 @@\n+        private void checkWriteExternalRecord(JCClassDecl tree, Element e, MethodSymbol method, boolean isExtern) {\n+            \/\/public void writeExternal(ObjectOutput) throws IOException\n+            checkExternMethodRecord(tree, e, method, syms.objectOutputType, isExtern);\n+        }\n+\n+        private void checkReadExternalRecord(JCClassDecl tree, Element e, MethodSymbol method, boolean isExtern) {\n+            \/\/ public void readExternal(ObjectInput) throws IOException\n+            checkExternMethodRecord(tree, e, method, syms.objectInputType, isExtern);\n+         }\n+\n+        private void checkExternMethodRecord(JCClassDecl tree, Element e, MethodSymbol method, Type argType,\n+                                             boolean isExtern) {\n+            if (isExtern && isExternMethod(tree, e, method, argType)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.IneffectualExternalizableMethodRecord(method.getSimpleName().toString()));\n+            }\n+        }\n+\n@@ -5423,0 +5441,1 @@\n+            boolean isExtern = isExternalizable((Type)e.asType());\n@@ -5443,0 +5462,7 @@\n+\n+                        if (isExtern) {\n+                            switch(name) {\n+                            case \"writeExternal\" -> checkWriteExternalEnum(tree, e, method);\n+                            case \"readExternal\"  -> checkReadExternalEnum(tree, e, method);\n+                            }\n+                        }\n@@ -5444,0 +5470,9 @@\n+\n+                    \/\/ Also perform checks on any class bodies of enum constants, see JLS 8.9.1.\n+                    case ENUM_CONSTANT -> {\n+                        var field = (VarSymbol)enclosed;\n+                        JCVariableDecl decl = (JCVariableDecl) TreeInfo.declarationFor(field, p);\n+                        if (decl.init instanceof JCNewClass nc && nc.def != null) {\n+                            ClassSymbol enumConstantType = nc.def.sym;\n+                            visitTypeAsEnum(enumConstantType, p);\n+                        }\n@@ -5445,1 +5480,2 @@\n-                });\n+\n+                    }});\n@@ -5450,0 +5486,28 @@\n+        private void checkWriteExternalEnum(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/public void writeExternal(ObjectOutput) throws IOException\n+            checkExternMethodEnum(tree, e, method, syms.objectOutputType);\n+        }\n+\n+        private void checkReadExternalEnum(JCClassDecl tree, Element e, MethodSymbol method) {\n+             \/\/ public void readExternal(ObjectInput) throws IOException\n+            checkExternMethodEnum(tree, e, method, syms.objectInputType);\n+         }\n+\n+        private void checkExternMethodEnum(JCClassDecl tree, Element e, MethodSymbol method, Type argType) {\n+            if (isExternMethod(tree, e, method, argType)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.IneffectualExternMethodEnum(method.getSimpleName().toString()));\n+            }\n+        }\n+\n+        private boolean isExternMethod(JCClassDecl tree, Element e, MethodSymbol method, Type argType) {\n+            long flags = method.flags();\n+            Type rtype = method.getReturnType();\n+\n+            \/\/ Not necessary to check throws clause in this context\n+            return (flags & PUBLIC) != 0 && (flags & STATIC) == 0 &&\n+                types.isSameType(syms.voidType, rtype) &&\n+                hasExactlyOneArgWithType(tree, e, method, argType);\n+        }\n+\n@@ -5495,2 +5559,1 @@\n-                    }\n-                    }\n+                    }}\n@@ -5555,0 +5618,1 @@\n+            boolean isExtern = isExternalizable((Type)e.asType());\n@@ -5573,3 +5637,1 @@\n-                        }\n-\n-                        }\n+                        }}\n@@ -5584,0 +5646,3 @@\n+                        case \"writeExternal\" -> checkWriteExternalRecord(tree, e, method, isExtern);\n+                        case \"readExternal\"  -> checkReadExternalRecord(tree, e, method, isExtern);\n+\n@@ -5590,6 +5655,2 @@\n-                        }\n-                        }\n-\n-                    }\n-                    }\n-                });\n+                        }}\n+                    }}});\n@@ -5653,0 +5714,10 @@\n+        private boolean hasExactlyOneArgWithType(JCClassDecl tree,\n+                                                 Element enclosing,\n+                                                 MethodSymbol method,\n+                                                 Type expectedType) {\n+            var parameters = method.getParameters();\n+            return (parameters.size() == 1) &&\n+                types.isSameType(parameters.get(0).asType(), expectedType);\n+        }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":85,"deletions":14,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -1573,2 +1573,9 @@\n-                if (frameStack.head.tree.hasTag(LAMBDA)) {\n-                    lambdaContext.addSymbol(tree.sym, LOCAL_VAR);\n+                for (Frame frame : frameStack) {\n+                    if (frame.tree.hasTag(VARDEF)) {\n+                        \/\/skip variable frames inside a lambda:\n+                        continue;\n+                    } else if (frame.tree.hasTag(LAMBDA)) {\n+                        lambdaContext.addSymbol(tree.sym, LOCAL_VAR);\n+                    } else {\n+                        break;\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -564,0 +564,4 @@\n+# 0: type\n+compiler.err.selector.type.not.allowed=\\\n+    selector type {0} is not allowed\n+\n@@ -2024,0 +2028,4 @@\n+# 0: string\n+compiler.warn.ineffectual.extern.method.enum=\\\n+    externalization-related method {0} is not effective in an enum class\n+\n@@ -2031,0 +2039,4 @@\n+# 0: string\n+compiler.warn.ineffectual.externalizable.method.record=\\\n+    externalization-related method {0} is not effective in a record class\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,4 @@\n-          goto cleanup;\n+        if (directIn == 0) {\n+          (*env)->ReleasePrimitiveArrayCritical(env, jIn, inBufP, JNI_ABORT);\n+        }\n+        return 0;\n@@ -169,4 +172,1 @@\n-    ckAssertReturnValueOK(env, rv);\n-\n-cleanup:\n-    if (directIn == 0 && inBufP != NULL) {\n+    if (directIn == 0) {\n@@ -175,1 +175,1 @@\n-    if (directOut == 0 && outBufP != NULL) {\n+    if (directOut == 0) {\n@@ -178,0 +178,1 @@\n+    ckAssertReturnValueOK(env, rv);\n@@ -224,1 +225,4 @@\n-          goto cleanup;\n+        if (directIn == 0) {\n+          (*env)->ReleasePrimitiveArrayCritical(env, jIn, inBufP, JNI_ABORT);\n+        }\n+        return 0;\n@@ -235,4 +239,1 @@\n-    ckAssertReturnValueOK(env, rv);\n-\n-cleanup:\n-    if (directIn == 0 && inBufP != NULL) {\n+    if (directIn == 0) {\n@@ -241,1 +242,1 @@\n-    if (directOut == 0 && outBufP != NULL) {\n+    if (directOut == 0) {\n@@ -244,0 +245,1 @@\n+    ckAssertReturnValueOK(env, rv);\n@@ -394,1 +396,4 @@\n-          goto cleanup;\n+        if (directIn == 0) {\n+          (*env)->ReleasePrimitiveArrayCritical(env, jIn, inBufP, JNI_ABORT);\n+        }\n+        return 0;\n@@ -404,4 +409,1 @@\n-    ckAssertReturnValueOK(env, rv);\n-\n-cleanup:\n-    if (directIn == 0 && inBufP != NULL) {\n+    if (directIn == 0) {\n@@ -410,1 +412,1 @@\n-    if (directOut == 0 && outBufP != NULL) {\n+    if (directOut == 0) {\n@@ -413,0 +415,1 @@\n+    ckAssertReturnValueOK(env, rv);\n@@ -459,1 +462,4 @@\n-          goto cleanup;\n+        if (directIn == 0) {\n+          (*env)->ReleasePrimitiveArrayCritical(env, jIn, inBufP, JNI_ABORT);\n+        }\n+        return 0;\n@@ -468,1 +474,0 @@\n-    ckAssertReturnValueOK(env, rv);\n@@ -470,2 +475,1 @@\n-cleanup:\n-    if (directIn == 0 && inBufP != NULL) {\n+    if (directIn == 0) {\n@@ -474,1 +478,1 @@\n-    if (directOut == 0 && outBufP != NULL) {\n+    if (directOut == 0) {\n@@ -477,0 +481,1 @@\n+    ckAssertReturnValueOK(env, rv);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_crypt.c","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1099,1 +1099,3 @@\n-                          if (region.isFree()) {\n+                          if (region == null) {\n+                            \/\/ intentionally skip\n+                          } else if (region.isFree()) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,12 +70,0 @@\n-    @Override\n-    @ForceInline\n-    public boolean laneIsSet(int i) {\n-        int length = length();\n-        Objects.checkIndex(i, length);\n-        if (length <= Long.SIZE) {\n-            return ((toLong() >>> i) & 1L) == 1;\n-        } else {\n-            return getBits()[i];\n-        }\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -771,0 +771,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte128Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -803,0 +803,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte256Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -867,0 +867,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte512Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -755,0 +755,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Byte64Mask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -741,0 +741,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(ByteMaxMask.class, byte.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -732,0 +732,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double128Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -736,0 +736,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double256Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -744,0 +744,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double512Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -730,0 +730,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Double64Mask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -729,0 +729,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(DoubleMaxMask.class, double.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -736,0 +736,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float128Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -744,0 +744,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float256Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -760,0 +760,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float512Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -732,0 +732,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Float64Mask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -729,0 +729,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(FloatMaxMask.class, float.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -747,0 +747,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int128Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -755,0 +755,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int256Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -771,0 +771,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int512Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -743,0 +743,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Int64Mask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -741,0 +741,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(IntMaxMask.class, int.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -733,0 +733,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long128Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -737,0 +737,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long256Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -745,0 +745,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long512Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -731,0 +731,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Long64Mask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -731,0 +731,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(LongMaxMask.class, long.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -755,0 +755,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short128Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -771,0 +771,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short256Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -803,0 +803,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short512Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -747,0 +747,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Short64Mask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -741,0 +741,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(ShortMaxMask.class, short.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1014,0 +1014,10 @@\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract($masktype$.class, $type$.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,0 +94,1 @@\n+                initJLineIfNeeded();\n@@ -108,0 +109,1 @@\n+                initJLineIfNeeded();\n@@ -129,1 +131,0 @@\n-        private final LineReader jline;\n@@ -131,0 +132,1 @@\n+        private volatile LineReader jline;\n@@ -134,1 +136,13 @@\n-            this.jline = LineReaderBuilder.builder().terminal(terminal).build();\n+        }\n+\n+        private void initJLineIfNeeded() {\n+            LineReader jline = this.jline;\n+            if (jline == null) {\n+                synchronized (this) {\n+                    jline = this.jline;\n+                    if (jline == null) {\n+                        jline = LineReaderBuilder.builder().terminal(terminal).build();\n+                        this.jline = jline;\n+                    }\n+                }\n+            }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractExecutableMemberWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,3 +45,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.MemberWriter;\n@@ -50,0 +47,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n@@ -54,1 +52,1 @@\n-public abstract class AbstractMemberWriter implements MemberSummaryWriter, MemberWriter {\n+public abstract class AbstractMemberWriter {\n@@ -83,0 +81,27 @@\n+    \/**\n+     * Returns the member summary header for the given class.\n+     *\n+     * @param typeElement the class the summary belongs to\n+     * @param content     the content to which the member summary will be added\n+     *\n+     * @return the member summary header\n+     *\/\n+    public abstract Content getMemberSummaryHeader(TypeElement typeElement, Content content);\n+    \/**\n+     * Adds the given summary to the list of summaries.\n+     *\n+     * @param summariesList the list of summaries\n+     * @param content       the summary\n+     *\/\n+    public abstract void addSummary(Content summariesList, Content content);\n+\n+    \/**\n+     * Returns a list of visible elements of the specified kind in this\n+     * type element.\n+     * @param kind of members\n+     * @return a list of members\n+     *\/\n+    protected List<Element> getVisibleMembers(VisibleMemberTable.Kind kind) {\n+        return configuration.getVisibleMemberTable(typeElement).getVisibleMembers(kind);\n+    }\n+\n@@ -343,1 +368,7 @@\n-    @Override\n+    \/**\n+     * Adds the member summary for the given class and member.\n+     *\n+     * @param tElement           the class the summary belongs to\n+     * @param member             the member that is documented\n+     * @param firstSentenceTrees the tags for the sentence being documented\n+     *\/\n@@ -347,1 +378,1 @@\n-            throw new IllegalStateException();\n+            throw new IllegalStateException(tElement + \", \" + typeElement);\n@@ -364,1 +395,9 @@\n-    @Override\n+    \/**\n+     * Adds the inherited member summary for the given class and member.\n+     *\n+     * @param tElement the class the inherited member belongs to\n+     * @param member the inherited member that is being documented\n+     * @param isFirst true if this is the first member in the list\n+     * @param isLast true if this is the last member in the list\n+     * @param content the content to which the links will be added\n+     *\/\n@@ -366,1 +405,1 @@\n-            Element nestedClass, boolean isFirst, boolean isLast,\n+            Element member, boolean isFirst, boolean isLast,\n@@ -368,1 +407,1 @@\n-        writer.addInheritedMemberSummary(this, tElement, nestedClass, isFirst, content);\n+        writer.addInheritedMemberSummary(this, tElement, member, isFirst, content);\n@@ -371,1 +410,7 @@\n-    @Override\n+    \/**\n+     * Returns the inherited member summary header for the given class.\n+     *\n+     * @param tElement the class the summary belongs to\n+     *\n+     * @return the inherited member summary header\n+     *\/\n@@ -378,1 +423,5 @@\n-    @Override\n+    \/**\n+     * Returns the inherited summary links.\n+     *\n+     * @return the inherited summary links\n+     *\/\n@@ -383,1 +432,7 @@\n-    @Override\n+    \/**\n+     * Returns the summary table for the given class.\n+     *\n+     * @param tElement the class the summary table belongs to\n+     *\n+     * @return the summary table\n+     *\/\n@@ -391,1 +446,7 @@\n-    @Override\n+    \/**\n+     * Returns the member content.\n+     *\n+     * @param memberContent the content representing the member\n+     *\n+     * @return the member content\n+     *\/\n@@ -396,2 +457,6 @@\n-    @Override\n-    public Content getMemberList() {\n+    \/**\n+     * {@return a list to add member items to}\n+     *\n+     * @see #getMemberListItem(Content)\n+     *\/\n+    protected Content getMemberList() {\n@@ -401,2 +466,7 @@\n-    @Override\n-    public Content getMemberListItem(Content memberContent) {\n+    \/**\n+     * {@return a member item}\n+     *\n+     * @param memberContent the member to represent as an item\n+     * @see #getMemberList()\n+     *\/\n+    protected Content getMemberListItem(Content memberContent) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":87,"deletions":17,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractOverviewIndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractTreeWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -120,1 +119,1 @@\n-                .addTab(contents.classes, e -> utils.isNonThrowableClass(e))\n+                .addTab(contents.classes, utils::isNonThrowableClass)\n@@ -122,2 +121,2 @@\n-                .addTab(contents.records, e -> utils.isRecord(e))\n-                .addTab(contents.exceptionClasses, e -> utils.isThrowable(e))\n+                .addTab(contents.records, utils::isRecord)\n+                .addTab(contents.exceptionClasses, utils::isThrowable)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AllClassesIndexWriter.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AllPackagesIndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.Comment;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\n+\/**\n+ * Writes annotation interface member documentation in HTML format.\n+ *\/\n+public class AnnotationTypeMemberWriter extends AbstractMemberWriter {\n+\n+    \/**\n+     * We generate separate summaries for required and optional annotation interface members,\n+     * so we need dedicated writer instances for each kind. For the details section, a single\n+     * shared list is generated so a special {@code ANY} value is provided for this case.\n+     *\/\n+    enum Kind {\n+        OPTIONAL,\n+        REQUIRED,\n+        ANY\n+    }\n+\n+    private final Kind kind;\n+\n+    \/**\n+     * The index of the current member that is being documented at this point\n+     * in time.\n+     *\/\n+    protected Element currentMember;\n+\n+    \/**\n+     * Constructs a new AnnotationTypeMemberWriterImpl for any kind of member.\n+     *\n+     * @param writer The writer for the class that the member belongs to.\n+     *\/\n+    public AnnotationTypeMemberWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+        this.kind = Kind.ANY;\n+    }\n+\n+    \/**\n+     * Constructs a new AnnotationTypeMemberWriterImpl for a specific kind of member.\n+     *\n+     * @param writer         the writer that will write the output.\n+     * @param annotationType the AnnotationType that holds this member.\n+     * @param kind           the kind of annotation interface members to handle.\n+     *\/\n+    public AnnotationTypeMemberWriter(SubWriterHolderWriter writer,\n+                                      TypeElement annotationType,\n+                                      Kind kind) {\n+        super(writer, annotationType);\n+        this.kind = kind;\n+    }\n+\n+    public void build(Content target) throws DocletException {\n+        buildAnnotationTypeMember(target);\n+    }\n+\n+    \/**\n+     * Build the member documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildAnnotationTypeMember(Content target) {\n+        \/\/ In contrast to the annotation interface member summaries the details generated\n+        \/\/ by this builder share a single list for both required and optional members.\n+        var members = getVisibleMembers(VisibleMemberTable.Kind.ANNOTATION_TYPE_MEMBER);\n+        if (!members.isEmpty()) {\n+            addAnnotationDetailsMarker(target);\n+            Content annotationDetailsHeader = getAnnotationDetailsHeader();\n+            Content memberList = getMemberList();\n+\n+            for (Element member : members) {\n+                currentMember = member;\n+                Content annotationContent = getAnnotationHeaderContent(currentMember);\n+\n+                buildAnnotationTypeMemberChildren(annotationContent);\n+\n+                memberList.add(writer.getMemberListItem(annotationContent));\n+            }\n+            Content annotationDetails = getAnnotationDetails(annotationDetailsHeader, memberList);\n+            target.add(annotationDetails);\n+        }\n+    }\n+\n+    protected void buildAnnotationTypeMemberChildren(Content annotationContent) {\n+        buildSignature(annotationContent);\n+        buildDeprecationInfo(annotationContent);\n+        buildPreviewInfo(annotationContent);\n+        buildMemberComments(annotationContent);\n+        buildTagInfo(annotationContent);\n+        buildDefaultValueInfo(annotationContent);\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content target) {\n+        target.add(getSignature(currentMember));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content annotationContent) {\n+        addDeprecated(currentMember, annotationContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content annotationContent) {\n+        addPreview(currentMember, annotationContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the member.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMemberComments(Content annotationContent) {\n+        if (!options.noComment()) {\n+            addComments(currentMember, annotationContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content annotationContent) {\n+        addTags(currentMember, annotationContent);\n+    }\n+\n+    \/**\n+     * Build the default value for this optional member.\n+     *\n+     * @param annotationContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDefaultValueInfo(Content annotationContent) {\n+        addDefaultValueInfo(currentMember, annotationContent);\n+    }\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement,\n+            Content content) {\n+        switch (kind) {\n+            case OPTIONAL -> content.add(selectComment(\n+                    MarkerComments.START_OF_ANNOTATION_TYPE_OPTIONAL_MEMBER_SUMMARY,\n+                    MarkerComments.START_OF_ANNOTATION_INTERFACE_OPTIONAL_MEMBER_SUMMARY));\n+            case REQUIRED -> content.add(selectComment(\n+                    MarkerComments.START_OF_ANNOTATION_TYPE_REQUIRED_MEMBER_SUMMARY,\n+                    MarkerComments.START_OF_ANNOTATION_INTERFACE_REQUIRED_MEMBER_SUMMARY));\n+            case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+        }\n+        Content c = new ContentBuilder();\n+        writer.addSummaryHeader(this, c);\n+        return c;\n+    }\n+\n+    protected Content getMemberHeader() {\n+        return writer.getMemberHeader();\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.memberSummary,\n+                switch (kind) {\n+                    case REQUIRED -> HtmlIds.ANNOTATION_TYPE_REQUIRED_ELEMENT_SUMMARY;\n+                    case OPTIONAL -> HtmlIds.ANNOTATION_TYPE_OPTIONAL_ELEMENT_SUMMARY;\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                },\n+                summariesList, content);\n+    }\n+\n+    protected void addAnnotationDetailsMarker(Content memberDetails) {\n+        memberDetails.add(selectComment(\n+                MarkerComments.START_OF_ANNOTATION_TYPE_DETAILS,\n+                MarkerComments.START_OF_ANNOTATION_INTERFACE_DETAILS));\n+    }\n+\n+    protected Content getAnnotationDetailsHeader() {\n+        Content memberDetails = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.annotationTypeDetailsLabel);\n+        memberDetails.add(heading);\n+        return memberDetails;\n+    }\n+\n+    protected Content getAnnotationHeaderContent(Element member) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(member)));\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forMember(typeElement, (ExecutableElement) member));\n+    }\n+\n+    protected Content getSignature(Element member) {\n+        return new Signatures.MemberSignature(member, this)\n+                .setType(getType(member))\n+                .setAnnotations(writer.getAnnotationInfo(member, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(Element member, Content target) {\n+        addDeprecatedInfo(member, target);\n+    }\n+\n+    protected void addPreview(Element member, Content content) {\n+        addPreviewInfo(member, content);\n+    }\n+\n+    protected void addComments(Element member, Content annotationContent) {\n+        addComment(member, annotationContent);\n+    }\n+\n+    protected void addTags(Element member, Content annotationContent) {\n+        writer.addTagsInfo(member, annotationContent);\n+    }\n+\n+    protected Content getAnnotationDetails(Content annotationDetailsHeader, Content annotationDetails) {\n+        Content c = new ContentBuilder(annotationDetailsHeader, annotationDetails);\n+        return getMember(HtmlTree.SECTION(HtmlStyle.memberDetails, c));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                switch (kind) {\n+                    case REQUIRED -> contents.annotateTypeRequiredMemberSummaryLabel;\n+                    case OPTIONAL -> contents.annotateTypeOptionalMemberSummaryLabel;\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                });\n+        content.add(label);\n+    }\n+\n+    \/**\n+     * Get the caption for the summary table.\n+     * @return the caption\n+     *\/\n+    protected Content getCaption() {\n+        return contents.getContent(\n+                switch (kind) {\n+                    case REQUIRED -> \"doclet.Annotation_Type_Required_Members\";\n+                    case OPTIONAL -> \"doclet.Annotation_Type_Optional_Members\";\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                });\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.modifierAndTypeLabel,\n+                switch (kind) {\n+                    case REQUIRED -> contents.annotationTypeRequiredMemberLabel;\n+                    case OPTIONAL -> contents.annotationTypeOptionalMemberLabel;\n+                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n+                },\n+                contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setCaption(getCaption())\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+    }\n+\n+    @Override\n+    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n+                                  Content content) {\n+        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n+                name(member), HtmlStyle.memberNameLink);\n+        var code = HtmlTree.CODE(memberLink);\n+        content.add(code);\n+    }\n+\n+    @Override\n+    protected void addInheritedSummaryLink(TypeElement typeElement,\n+            Element member, Content target) {\n+        \/\/Not applicable.\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        addModifiersAndType(member, getType(member), content);\n+    }\n+\n+    @Override\n+    protected Content getSummaryLink(Element member) {\n+        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n+        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n+    }\n+\n+    protected Comment selectComment(Comment c1, Comment c2) {\n+        HtmlConfiguration configuration = writer.configuration;\n+        SourceVersion sv = configuration.docEnv.getSourceVersion();\n+        return sv.compareTo(SourceVersion.RELEASE_16) < 0 ? c1 : c2;\n+    }\n+\n+    private TypeMirror getType(Element member) {\n+        return utils.isExecutableElement(member)\n+                ? utils.getReturnType(typeElement, (ExecutableElement) member)\n+                : member.asType();\n+    }\n+\n+    public void addDefaultValueInfo(Element member, Content annotationContent) {\n+        if (utils.isAnnotationInterface(member.getEnclosingElement())) {\n+            ExecutableElement ee = (ExecutableElement) member;\n+            AnnotationValue value = ee.getDefaultValue();\n+            if (value != null) {\n+                var dl = HtmlTree.DL(HtmlStyle.notes);\n+                dl.add(HtmlTree.DT(contents.default_));\n+                dl.add(HtmlTree.DD(HtmlTree.CODE(Text.of(value.toString()))));\n+                annotationContent.add(dl);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriter.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -1,278 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.AnnotationValue;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.Comment;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-\n-\n-\/**\n- * Writes annotation interface member documentation in HTML format.\n- *\/\n-public class AnnotationTypeMemberWriterImpl extends AbstractMemberWriter\n-    implements AnnotationTypeMemberWriter, MemberSummaryWriter {\n-\n-    \/**\n-     * We generate separate summaries for required and optional annotation interface members,\n-     * so we need dedicated writer instances for each kind. For the details section, a single\n-     * shared list is generated so a special {@code ANY} value is provided for this case.\n-     *\/\n-    enum Kind {\n-        OPTIONAL,\n-        REQUIRED,\n-        ANY\n-    }\n-\n-    private final Kind kind;\n-\n-    \/**\n-     * Constructs a new AnnotationTypeMemberWriterImpl for any kind of member.\n-     *\n-     * @param writer The writer for the class that the member belongs to.\n-     *\/\n-    public AnnotationTypeMemberWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-        this.kind = Kind.ANY;\n-    }\n-\n-    \/**\n-     * Constructs a new AnnotationTypeMemberWriterImpl for a specific kind of member.\n-     *\n-     * @param writer         the writer that will write the output.\n-     * @param annotationType the AnnotationType that holds this member.\n-     * @param kind           the kind of annotation interface members to handle.\n-     *\/\n-    public AnnotationTypeMemberWriterImpl(SubWriterHolderWriter writer,\n-                                          TypeElement annotationType,\n-                                          Kind kind) {\n-        super(writer, annotationType);\n-        this.kind = kind;\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content content) {\n-        switch (kind) {\n-            case OPTIONAL -> content.add(selectComment(\n-                    MarkerComments.START_OF_ANNOTATION_TYPE_OPTIONAL_MEMBER_SUMMARY,\n-                    MarkerComments.START_OF_ANNOTATION_INTERFACE_OPTIONAL_MEMBER_SUMMARY));\n-            case REQUIRED -> content.add(selectComment(\n-                    MarkerComments.START_OF_ANNOTATION_TYPE_REQUIRED_MEMBER_SUMMARY,\n-                    MarkerComments.START_OF_ANNOTATION_INTERFACE_REQUIRED_MEMBER_SUMMARY));\n-            case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-        }\n-        Content c = new ContentBuilder();\n-        writer.addSummaryHeader(this, c);\n-        return c;\n-    }\n-\n-    @Override\n-    public Content getMemberHeader() {\n-        return writer.getMemberHeader();\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.memberSummary,\n-                switch (kind) {\n-                    case REQUIRED -> HtmlIds.ANNOTATION_TYPE_REQUIRED_ELEMENT_SUMMARY;\n-                    case OPTIONAL -> HtmlIds.ANNOTATION_TYPE_OPTIONAL_ELEMENT_SUMMARY;\n-                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-                },\n-                summariesList, content);\n-    }\n-\n-    @Override\n-    public void addAnnotationDetailsMarker(Content memberDetails) {\n-        memberDetails.add(selectComment(\n-                MarkerComments.START_OF_ANNOTATION_TYPE_DETAILS,\n-                MarkerComments.START_OF_ANNOTATION_INTERFACE_DETAILS));\n-    }\n-\n-    @Override\n-    public Content getAnnotationDetailsHeader() {\n-        Content memberDetails = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.annotationTypeDetailsLabel);\n-        memberDetails.add(heading);\n-        return memberDetails;\n-    }\n-\n-    @Override\n-    public Content getAnnotationHeaderContent(Element member) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(member)));\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forMember(typeElement, (ExecutableElement) member));\n-    }\n-\n-    @Override\n-    public Content getSignature(Element member) {\n-        return new Signatures.MemberSignature(member, this)\n-                .setType(getType(member))\n-                .setAnnotations(writer.getAnnotationInfo(member, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(Element member, Content target) {\n-        addDeprecatedInfo(member, target);\n-    }\n-\n-    @Override\n-    public void addPreview(Element member, Content content) {\n-        addPreviewInfo(member, content);\n-    }\n-\n-    @Override\n-    public void addComments(Element member, Content annotationContent) {\n-        addComment(member, annotationContent);\n-    }\n-\n-    @Override\n-    public void addTags(Element member, Content annotationContent) {\n-        writer.addTagsInfo(member, annotationContent);\n-    }\n-\n-    @Override\n-    public Content getAnnotationDetails(Content annotationDetailsHeader, Content annotationDetails) {\n-        Content c = new ContentBuilder(annotationDetailsHeader, annotationDetails);\n-        return getMember(HtmlTree.SECTION(HtmlStyle.memberDetails, c));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                switch (kind) {\n-                    case REQUIRED -> contents.annotateTypeRequiredMemberSummaryLabel;\n-                    case OPTIONAL -> contents.annotateTypeOptionalMemberSummaryLabel;\n-                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-                });\n-        content.add(label);\n-    }\n-\n-    \/**\n-     * Get the caption for the summary table.\n-     * @return the caption\n-     *\/\n-    protected Content getCaption() {\n-        return contents.getContent(\n-                switch (kind) {\n-                    case REQUIRED -> \"doclet.Annotation_Type_Required_Members\";\n-                    case OPTIONAL -> \"doclet.Annotation_Type_Optional_Members\";\n-                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-                });\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.modifierAndTypeLabel,\n-                switch (kind) {\n-                    case REQUIRED -> contents.annotationTypeRequiredMemberLabel;\n-                    case OPTIONAL -> contents.annotationTypeOptionalMemberLabel;\n-                    case ANY -> throw new UnsupportedOperationException(\"unsupported member kind\");\n-                },\n-                contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setCaption(getCaption())\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n-    @Override\n-    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n-                                  Content content) {\n-        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n-                name(member), HtmlStyle.memberNameLink);\n-        var code = HtmlTree.CODE(memberLink);\n-        content.add(code);\n-    }\n-\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement,\n-            Element member, Content target) {\n-        \/\/Not applicable.\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        addModifiersAndType(member, getType(member), content);\n-    }\n-\n-    @Override\n-    protected Content getSummaryLink(Element member) {\n-        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n-        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n-    }\n-\n-    protected Comment selectComment(Comment c1, Comment c2) {\n-        HtmlConfiguration configuration = writer.configuration;\n-        SourceVersion sv = configuration.docEnv.getSourceVersion();\n-        return sv.compareTo(SourceVersion.RELEASE_16) < 0 ? c1 : c2;\n-    }\n-\n-    private TypeMirror getType(Element member) {\n-        return utils.isExecutableElement(member)\n-                ? utils.getReturnType(typeElement, (ExecutableElement) member)\n-                : member.asType();\n-    }\n-\n-    public void addDefaultValueInfo(Element member, Content annotationContent) {\n-        if (utils.isAnnotationInterface(member.getEnclosingElement())) {\n-            ExecutableElement ee = (ExecutableElement) member;\n-            AnnotationValue value = ee.getDefaultValue();\n-            if (value != null) {\n-                var dl = HtmlTree.DL(HtmlStyle.notes);\n-                dl.add(HtmlTree.DT(contents.default_));\n-                dl.add(HtmlTree.DD(HtmlTree.CODE(Text.of(value.toString()))));\n-                annotationContent.add(dl);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriterImpl.java","additions":0,"deletions":278,"binary":false,"changes":278,"status":"deleted"},{"patch":"@@ -46,1 +46,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -84,4 +83,4 @@\n-    final MethodWriterImpl methodSubWriter;\n-    final ConstructorWriterImpl constrSubWriter;\n-    final FieldWriterImpl fieldSubWriter;\n-    final NestedClassWriterImpl classSubWriter;\n+    final MethodWriter methodSubWriter;\n+    final ConstructorWriter constrSubWriter;\n+    final FieldWriter fieldSubWriter;\n+    final NestedClassWriter classSubWriter;\n@@ -135,2 +134,2 @@\n-        methodSubWriter = new MethodWriterImpl(this);\n-        constrSubWriter = new ConstructorWriterImpl(this);\n+        methodSubWriter = new MethodWriter(this);\n+        constrSubWriter = new ConstructorWriter(this);\n@@ -138,2 +137,2 @@\n-        fieldSubWriter = new FieldWriterImpl(this);\n-        classSubWriter = new NestedClassWriterImpl(this);\n+        fieldSubWriter = new FieldWriter(this);\n+        classSubWriter = new NestedClassWriter(this);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassUseWriter.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,1093 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.SimpleElementVisitor8;\n+\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.CommentUtils;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;\n+import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.ANNOTATION_TYPE_MEMBER_REQUIRED;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.CONSTRUCTORS;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.ENUM_CONSTANTS;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.FIELDS;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.METHODS;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.NESTED_CLASSES;\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.PROPERTIES;\n+\n+\/**\n+ * Generate the Class Information Page.\n+ *\n+ * @see javax.lang.model.element.TypeElement\n+ *\/\n+public class ClassWriter extends SubWriterHolderWriter {\n+\n+    private static final Set<String> suppressSubtypesSet\n+            = Set.of(\"java.lang.Object\",\n+                     \"org.omg.CORBA.Object\");\n+\n+    private static final Set<String> suppressImplementingSet\n+            = Set.of(\"java.lang.Cloneable\",\n+                     \"java.lang.constant.Constable\",\n+                     \"java.lang.constant.ConstantDesc\",\n+                     \"java.io.Serializable\");\n+\n+    protected final TypeElement typeElement;\n+    protected final VisibleMemberTable visibleMemberTable;\n+\n+    protected final ClassTree classTree;\n+\n+    private final Comparator<Element> summariesComparator;\n+    private final PropertyUtils.PropertyHelper pHelper;\n+\n+    \/**\n+     * @param configuration the configuration data for the doclet\n+     * @param typeElement the class being documented.\n+     * @param classTree the class tree for the given class.\n+     *\/\n+    public ClassWriter(HtmlConfiguration configuration, TypeElement typeElement,\n+                       ClassTree classTree) {\n+        super(configuration, configuration.docPaths.forClass(typeElement));\n+        this.typeElement = typeElement;\n+        configuration.currentTypeElement = typeElement;\n+        this.classTree = classTree;\n+\n+        visibleMemberTable = configuration.getVisibleMemberTable(typeElement);\n+        summariesComparator = utils.comparators.makeIndexElementComparator();\n+        pHelper = new PropertyUtils.PropertyHelper(configuration, typeElement);\n+\n+        switch (typeElement.getKind()) {\n+            case ENUM   -> setEnumDocumentation(typeElement);\n+            case RECORD -> setRecordDocumentation(typeElement);\n+        }\n+    }\n+\n+    public void build() throws DocletException {\n+        buildClassDoc();\n+    }\n+\n+    \/**\n+     * Handles the {@literal <TypeElement>} tag.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildClassDoc() throws DocletException {\n+        String key = switch (typeElement.getKind()) {\n+            case INTERFACE       -> \"doclet.Interface\";\n+            case ENUM            -> \"doclet.Enum\";\n+            case RECORD          -> \"doclet.RecordClass\";\n+            case ANNOTATION_TYPE -> \"doclet.AnnotationType\";\n+            case CLASS           -> \"doclet.Class\";\n+            default -> throw new IllegalStateException(typeElement.getKind() + \" \" + typeElement);\n+        };\n+        Content content = getHeader(resources.getText(key) + \" \" + utils.getSimpleName(typeElement));\n+        Content classContent = getClassContentHeader();\n+\n+        buildClassTree(classContent);\n+        buildClassInfo(classContent);\n+        buildMemberSummary(classContent);\n+        buildMemberDetails(classContent);\n+\n+        addClassContent(classContent);\n+        addFooter();\n+        printDocument(content);\n+        copyDocFiles();\n+    }\n+\n+    \/**\n+     * Build the class inheritance tree documentation.\n+     *\n+     * @param classContent the content to which the documentation will be added\n+     *\/\n+    protected void buildClassTree(Content classContent) {\n+        addClassTree(classContent);\n+    }\n+\n+    \/**\n+     * Build the class information documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassInfo(Content target) {\n+        Content c = getOutputInstance();\n+        buildParamInfo(c);\n+        buildSuperInterfacesInfo(c);\n+        buildImplementedInterfacesInfo(c);\n+        buildSubClassInfo(c);\n+        buildSubInterfacesInfo(c);\n+        buildInterfaceUsageInfo(c);\n+        buildNestedClassInfo(c);\n+        buildFunctionalInterfaceInfo(c);\n+        buildClassSignature(c);\n+        buildDeprecationInfo(c);\n+        buildClassDescription(c);\n+        buildClassTagInfo(c);\n+\n+        target.add(getClassInfo(c));\n+    }\n+\n+    \/**\n+     * Build the type parameters and state components of this class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildParamInfo(Content target) {\n+        addParamInfo(target);\n+    }\n+\n+    \/**\n+     * If this is an interface, list all superinterfaces.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSuperInterfacesInfo(Content target) {\n+        addSuperInterfacesInfo(target);\n+    }\n+\n+    \/**\n+     * If this is a class, list all interfaces implemented by this class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildImplementedInterfacesInfo(Content target) {\n+        addImplementedInterfacesInfo(target);\n+    }\n+\n+    \/**\n+     * List all the classes that extend this one.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSubClassInfo(Content target) {\n+        addSubClassInfo(target);\n+    }\n+\n+    \/**\n+     * List all the interfaces that extend this one.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSubInterfacesInfo(Content target) {\n+        addSubInterfacesInfo(target);\n+    }\n+\n+    \/**\n+     * If this is an interface, list all classes that implement this interface.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildInterfaceUsageInfo(Content target) {\n+        addInterfaceUsageInfo(target);\n+    }\n+\n+    \/**\n+     * If this is a functional interface, display appropriate message.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildFunctionalInterfaceInfo(Content target) {\n+        addFunctionalInterfaceInfo(target);\n+    }\n+\n+    \/**\n+     * If this class is deprecated, build the appropriate information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content target) {\n+        addClassDeprecationInfo(target);\n+    }\n+\n+    \/**\n+     * If this is an inner class or interface, list the enclosing class or interface.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildNestedClassInfo(Content target) {\n+        addNestedClassInfo(target);\n+    }\n+\n+    \/**\n+     * Copy the doc files.\n+     *\n+     * @throws DocFileIOException if there is a problem while copying the files\n+     *\/\n+    private void copyDocFiles() throws DocletException {\n+        PackageElement containingPackage = utils.containingPackage(typeElement);\n+        var containingPackagesSeen = configuration.getContainingPackagesSeen();\n+        if ((configuration.packages == null ||\n+                !configuration.packages.contains(containingPackage)) &&\n+                !containingPackagesSeen.contains(containingPackage)) {\n+            \/\/Only copy doc files dir if the containing package is not\n+            \/\/documented AND if we have not documented a class from the same\n+            \/\/package already. Otherwise, we are making duplicate copies.\n+            var docFilesHandler = configuration\n+                    .getWriterFactory()\n+                    .getDocFilesHandler(containingPackage);\n+            docFilesHandler.copyDocFiles();\n+            containingPackagesSeen.add(containingPackage);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature of the current class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassSignature(Content target) {\n+        addClassSignature(target);\n+    }\n+\n+    \/**\n+     * Build the class description.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassDescription(Content target) {\n+        addClassDescription(target);\n+    }\n+\n+    \/**\n+     * Build the tag information for the current class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassTagInfo(Content target) {\n+        addClassTagInfo(target);\n+    }\n+\n+    \/**\n+     * Build the member summary contents of the page.\n+     *\n+     * @param classContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMemberSummary(Content classContent) {\n+        Content summariesList = getSummariesList();\n+        buildSummaries(summariesList);\n+        classContent.add(getMemberSummary(summariesList));\n+    }\n+\n+    protected void buildSummaries(Content target) {\n+        buildPropertiesSummary(target);\n+        buildNestedClassesSummary(target);\n+        buildEnumConstantsSummary(target);\n+        buildAnnotationTypeRequiredMemberSummary(target);\n+        buildAnnotationTypeOptionalMemberSummary(target);\n+        buildFieldsSummary(target);\n+        buildConstructorsSummary(target);\n+        buildMethodsSummary(target);\n+    }\n+\n+    \/**\n+     * Builds the summary for any optional members of an annotation type.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildAnnotationTypeOptionalMemberSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_OPTIONAL);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getAnnotationTypeOptionalMemberWriter(this);\n+        addSummary(writer, ANNOTATION_TYPE_MEMBER_OPTIONAL, false, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any required members of an annotation type.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildAnnotationTypeRequiredMemberSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_REQUIRED);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getAnnotationTypeRequiredMemberWriter(this);\n+        addSummary(writer, ANNOTATION_TYPE_MEMBER_REQUIRED, false, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any enum constants of an enum type.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildEnumConstantsSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(ENUM_CONSTANTS);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getEnumConstantWriter(this);\n+        addSummary(writer, ENUM_CONSTANTS, false, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any fields.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildFieldsSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(FIELDS);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getFieldWriter(this);\n+        addSummary(writer, FIELDS, true, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any properties.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildPropertiesSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(PROPERTIES);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getPropertyWriter(this);\n+        addSummary(writer, PROPERTIES, true, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any nested classes.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildNestedClassesSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(NESTED_CLASSES);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = new NestedClassWriter(this, typeElement); \/\/ TODO: surprising omission from WriterFactory\n+        addSummary(writer, NESTED_CLASSES, true, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any methods.\n+     *\n+     * @param summariesList the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodsSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(METHODS);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getMethodWriter(this);\n+        addSummary(writer, METHODS, true, summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for any constructors.\n+     *\n+     * @param summariesList the content to which the documentation will be added\n+     *\/\n+    protected void buildConstructorsSummary(Content summariesList) {\n+\/\/        MemberSummaryWriter writer = memberSummaryWriters.get(CONSTRUCTORS);\n+        var writerFactory = configuration.getWriterFactory();\n+        var writer = writerFactory.getConstructorWriter(this);\n+        addSummary(writer, CONSTRUCTORS, false, summariesList);\n+    }\n+\n+\n+    \/**\n+     * Adds the summary for the documentation.\n+     *\n+     * @param writer               the writer for this member summary\n+     * @param kind                 the kind of members to document\n+     * @param showInheritedSummary true if a summary of any inherited elements should be documented\n+     * @param summariesList        the list of summaries to which the summary will be added\n+     *\/\n+    private void addSummary(AbstractMemberWriter writer,\n+                            VisibleMemberTable.Kind kind,\n+                            boolean showInheritedSummary,\n+                            Content summariesList)\n+    {\n+        \/\/ TODO: could infer the writer from the kind\n+        \/\/ TODO: why LinkedList?\n+        List<Content> summaryTreeList = new LinkedList<>();\n+        buildSummary(writer, kind, summaryTreeList);\n+        if (showInheritedSummary)\n+            buildInheritedSummary(writer, kind, summaryTreeList);\n+        if (!summaryTreeList.isEmpty()) {\n+            Content member = writer.getMemberSummaryHeader(typeElement, summariesList);\n+            summaryTreeList.forEach(member::add);\n+            writer.addSummary(summariesList, member);\n+        }\n+    }\n+\n+    \/**\n+     * Build the member summary for the given members.\n+     *\n+     * @param writer the summary writer to write the output.\n+     * @param kind the kind of  members to summarize.\n+     * @param summaryTreeList the list of contents to which the documentation will be added\n+     *\/\n+    private void buildSummary(AbstractMemberWriter writer,\n+                              VisibleMemberTable.Kind kind, List<Content> summaryTreeList) {\n+        SortedSet<? extends Element> members = asSortedSet(visibleMemberTable.getVisibleMembers(kind));\n+        if (!members.isEmpty()) {\n+            for (Element member : members) {\n+                final Element property = pHelper.getPropertyElement(member);\n+                if (property != null && member instanceof ExecutableElement ee) {\n+                    configuration.cmtUtils.updatePropertyMethodComment(ee, property);\n+                }\n+                if (utils.isMethod(member)) {\n+                    var docFinder = utils.docFinder();\n+                    Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n+                        var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n+                        Optional<List<? extends DocTree>> optional = firstSentenceTrees.isEmpty() ? Optional.empty() : Optional.of(firstSentenceTrees);\n+                        return DocFinder.Result.fromOptional(optional);\n+                    })).toOptional();\n+                    \/\/ The fact that we use `member` for possibly unrelated tags is suspicious\n+                    writer.addMemberSummary(typeElement, member, r.orElse(List.of()));\n+                } else {\n+                    writer.addMemberSummary(typeElement, member, utils.getFirstSentenceTrees(member));\n+                }\n+            }\n+            summaryTreeList.add(writer.getSummaryTable(typeElement));\n+        }\n+    }\n+\n+    \/**\n+     * Build the inherited member summary for the given methods.\n+     *\n+     * @param writer the writer for this member summary.\n+     * @param kind the kind of members to document.\n+     * @param targets the list of contents to which the documentation will be added\n+     *\/\n+    private void buildInheritedSummary(AbstractMemberWriter writer,\n+                                       VisibleMemberTable.Kind kind, List<Content> targets) {\n+        SortedSet<? extends Element> inheritedMembersFromMap = asSortedSet(visibleMemberTable.getAllVisibleMembers(kind));\n+\n+        for (TypeElement inheritedClass : visibleMemberTable.getVisibleTypeElements()) {\n+            if (!(utils.isPublic(inheritedClass) || utils.isLinkable(inheritedClass))) {\n+                continue;\n+            }\n+            if (Objects.equals(inheritedClass, typeElement)) {\n+                continue;\n+            }\n+            if (utils.hasHiddenTag(inheritedClass)) {\n+                continue;\n+            }\n+\n+            List<? extends Element> members = inheritedMembersFromMap.stream()\n+                    .filter(e -> Objects.equals(utils.getEnclosingTypeElement(e), inheritedClass))\n+                    .toList();\n+\n+            if (!members.isEmpty()) {\n+                SortedSet<Element> inheritedMembers = new TreeSet<>(summariesComparator);\n+                inheritedMembers.addAll(members);\n+                Content inheritedHeader = writer.getInheritedSummaryHeader(inheritedClass);\n+                Content links = writer.getInheritedSummaryLinks();\n+                addSummaryFootNote(inheritedClass, inheritedMembers, links, writer);\n+                inheritedHeader.add(links);\n+                targets.add(inheritedHeader);\n+            }\n+        }\n+    }\n+\n+    private void addSummaryFootNote(TypeElement inheritedClass, Iterable<Element> inheritedMembers,\n+                                    Content links, AbstractMemberWriter writer) {\n+        boolean isFirst = true;\n+        for (var iterator = inheritedMembers.iterator(); iterator.hasNext(); ) {\n+            var member = iterator.next();\n+            TypeElement t = utils.isUndocumentedEnclosure(inheritedClass)\n+                    ? typeElement : inheritedClass;\n+            writer.addInheritedMemberSummary(t, member, isFirst, !iterator.hasNext(), links);\n+            isFirst = false;\n+        }\n+    }\n+\n+    private SortedSet<? extends Element> asSortedSet(Collection<? extends Element> members) {\n+        SortedSet<Element> out = new TreeSet<>(summariesComparator);\n+        out.addAll(members);\n+        return out;\n+    }\n+\n+    \/**\n+     * Build the member details contents of the page.\n+     *\n+     * @param classContent the content to which the documentation will be added\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildMemberDetails(Content classContent) throws DocletException {\n+        Content detailsList = getDetailsList();\n+\n+        buildEnumConstantsDetails(detailsList);\n+        buildPropertyDetails(detailsList);\n+        buildFieldDetails(detailsList);\n+        buildConstructorDetails(detailsList);\n+        buildAnnotationTypeMemberDetails(detailsList);\n+        buildMethodDetails(detailsList);\n+\n+        classContent.add(getMemberDetails(detailsList));\n+    }\n+\n+    \/**\n+     * Build the enum constants documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     *\/\n+    protected void buildEnumConstantsDetails(Content detailsList) {\n+        var writerFactory = configuration.getWriterFactory();\n+        var enumConstantWriter = writerFactory.getEnumConstantWriter(this);\n+        enumConstantWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the field documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildFieldDetails(Content detailsList) throws DocletException {\n+        var writerFactory = configuration.getWriterFactory();\n+        var fieldWriter = writerFactory.getFieldWriter(this);\n+        fieldWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the property documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     *\/\n+    public void buildPropertyDetails( Content detailsList) {\n+        var writerFactory = configuration.getWriterFactory();\n+        var propertyWriter = writerFactory.getPropertyWriter(this);\n+        propertyWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the constructor documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildConstructorDetails(Content detailsList) throws DocletException {\n+        var writerFactory = configuration.getWriterFactory();\n+        var constructorWriter = writerFactory.getConstructorWriter(this);\n+        constructorWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the method documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildMethodDetails(Content detailsList) throws DocletException {\n+        var writerFactory = configuration.getWriterFactory();\n+        var methodWriter = writerFactory.getMethodWriter(this);\n+        methodWriter.build(detailsList);\n+    }\n+\n+    \/**\n+     * Build the annotation type optional member documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     * @throws DocletException if there is a problem building the documentation\n+     *\/\n+    protected void buildAnnotationTypeMemberDetails(Content target)\n+            throws DocletException {\n+        var writerFactory = configuration.getWriterFactory();\n+        var annotationTypeMemberWriter = writerFactory.getAnnotationTypeMemberWriter(this);\n+        annotationTypeMemberWriter.build(target);\n+    }\n+\n+    \/**\n+     * The documentation for values() and valueOf() in Enums are set by the\n+     * doclet only iff the user or overridden methods are missing.\n+     * @param elem the enum element\n+     *\/\n+    private void setEnumDocumentation(TypeElement elem) {\n+        CommentUtils cmtUtils = configuration.cmtUtils;\n+        for (ExecutableElement ee : utils.getMethods(elem)) {\n+            if (!utils.getFullBody(ee).isEmpty()) \/\/ ignore if already set\n+                continue;\n+            Name name = ee.getSimpleName();\n+            if (name.contentEquals(\"values\") && ee.getParameters().isEmpty()) {\n+                utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                cmtUtils.setEnumValuesTree(ee);\n+            } else if (name.contentEquals(\"valueOf\") && ee.getParameters().size() == 1) {\n+                \/\/ TODO: check parameter type\n+                utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                cmtUtils.setEnumValueOfTree(ee);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sets the documentation as needed for the mandated parts of a record type.\n+     * This includes the canonical constructor, methods like {@code equals},\n+     * {@code hashCode}, {@code toString}, the accessor methods, and the underlying\n+     * field.\n+     * @param elem the record element\n+     *\/\n+\n+    private void setRecordDocumentation(TypeElement elem) {\n+        CommentUtils cmtUtils = configuration.cmtUtils;\n+        Set<Name> componentNames = elem.getRecordComponents().stream()\n+                .map(Element::getSimpleName)\n+                .collect(Collectors.toSet());\n+\n+        for (ExecutableElement ee : utils.getConstructors(elem)) {\n+            if (utils.isCanonicalRecordConstructor(ee)) {\n+                if (utils.getFullBody(ee).isEmpty()) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordConstructorTree(ee);\n+                }\n+                \/\/ only one canonical constructor; no need to keep looking\n+                break;\n+            }\n+        }\n+\n+        var fields = utils.isSerializable(elem)\n+                ? utils.getFieldsUnfiltered(elem)\n+                : utils.getFields(elem);\n+        for (VariableElement ve : fields) {\n+            \/\/ The fields for the record component cannot be declared by the\n+            \/\/ user and so cannot have any pre-existing comment.\n+            Name name = ve.getSimpleName();\n+            if (componentNames.contains(name)) {\n+                utils.removeCommentHelper(ve); \/\/ purge previous entry\n+                cmtUtils.setRecordFieldTree(ve);\n+            }\n+        }\n+\n+        TypeMirror objectType = utils.getObjectType();\n+\n+        for (ExecutableElement ee : utils.getMethods(elem)) {\n+            if (!utils.getFullBody(ee).isEmpty()) {\n+                continue;\n+            }\n+\n+            Name name = ee.getSimpleName();\n+            List<? extends VariableElement> params = ee.getParameters();\n+            if (name.contentEquals(\"equals\")) {\n+                if (params.size() == 1 && utils.typeUtils.isSameType(params.get(0).asType(), objectType)) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordEqualsTree(ee);\n+                }\n+            } else if (name.contentEquals(\"hashCode\")) {\n+                if (params.isEmpty()) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordHashCodeTree(ee);\n+                }\n+            } else if (name.contentEquals(\"toString\")) {\n+                if (params.isEmpty()) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordToStringTree(ee);\n+                }\n+            } else if (componentNames.contains(name)) {\n+                if (params.isEmpty()) {\n+                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n+                    cmtUtils.setRecordAccessorTree(ee);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ TODO: inline this\n+    public Content getOutputInstance() {\n+        return new ContentBuilder();\n+    }\n+\n+    protected Content getHeader(String header) {\n+        HtmlTree body = getBody(getWindowTitle(utils.getSimpleName(typeElement)));\n+        var div = HtmlTree.DIV(HtmlStyle.header);\n+        if (configuration.showModules) {\n+            ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);\n+            var classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);\n+            var moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);\n+            moduleNameDiv.add(Entity.NO_BREAK_SPACE);\n+            moduleNameDiv.add(getModuleLink(mdle,\n+                    Text.of(mdle.getQualifiedName())));\n+            div.add(moduleNameDiv);\n+        }\n+        PackageElement pkg = utils.containingPackage(typeElement);\n+        if (!pkg.isUnnamed()) {\n+            var classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);\n+            var pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);\n+            pkgNameDiv.add(Entity.NO_BREAK_SPACE);\n+            Content pkgNameContent = getPackageLink(pkg, getLocalizedPackageName(pkg));\n+            pkgNameDiv.add(pkgNameContent);\n+            div.add(pkgNameDiv);\n+        }\n+        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration,\n+                HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement)\n+                .linkToSelf(false);  \/\/ Let's not link to ourselves in the header\n+        var heading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n+                HtmlStyle.title, Text.of(header));\n+        heading.add(getTypeParameterLinks(linkInfo));\n+        div.add(heading);\n+        bodyContents.setHeader(getHeader(PageMode.CLASS, typeElement))\n+                .addMainContent(MarkerComments.START_OF_CLASS_DATA)\n+                .addMainContent(div);\n+        return body;\n+    }\n+\n+    protected Content getClassContentHeader() {\n+        return getContentHeader();\n+    }\n+\n+    @Override\n+    protected Navigation getNavBar(PageMode pageMode, Element element) {\n+        Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(element),\n+                contents.moduleLabel);\n+        return super.getNavBar(pageMode, element)\n+                .setNavLinkModule(linkContent)\n+                .setSubNavLinks(() -> {\n+                    List<Content> list = new ArrayList<>();\n+                    VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n+                    Set<VisibleMemberTable.Kind> summarySet =\n+                            VisibleMemberTable.Kind.forSummariesOf(element.getKind());\n+                    for (VisibleMemberTable.Kind kind : summarySet) {\n+                        list.add(links.createLink(HtmlIds.forMemberSummary(kind),\n+                                contents.getNavLinkLabelContent(kind), vmt.hasVisibleMembers(kind)));\n+                    }\n+                    return list;\n+                });\n+    }\n+\n+    protected void addFooter() {\n+        bodyContents.addMainContent(MarkerComments.END_OF_CLASS_DATA);\n+        bodyContents.setFooter(getFooter());\n+    }\n+\n+    protected void printDocument(Content content) throws DocFileIOException {\n+        String description = getDescription(\"declaration\", typeElement);\n+        PackageElement pkg = utils.containingPackage(typeElement);\n+        List<DocPath> localStylesheets = getLocalStylesheets(pkg);\n+        content.add(bodyContents);\n+        printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),\n+                description, localStylesheets, content);\n+    }\n+\n+    protected Content getClassInfo(Content classInfo) {\n+        return getMember(HtmlIds.CLASS_DESCRIPTION, HtmlStyle.classDescription, classInfo);\n+    }\n+\n+    @Override\n+    public TypeElement getCurrentPageElement() {\n+        return typeElement;\n+    }\n+\n+    protected void addClassSignature(Content classInfo) {\n+        classInfo.add(new HtmlTree(TagName.HR));\n+        classInfo.add(new Signatures.TypeSignature(typeElement, this)\n+                .toContent());\n+    }\n+\n+    protected void addClassDescription(Content classInfo) {\n+        addPreviewInfo(classInfo);\n+        if (!options.noComment()) {\n+            \/\/ generate documentation for the class.\n+            if (!utils.getFullBody(typeElement).isEmpty()) {\n+                addInlineComment(typeElement, classInfo);\n+            }\n+        }\n+    }\n+\n+    private void addPreviewInfo(Content content) {\n+        addPreviewInfo(typeElement, content);\n+    }\n+\n+    protected void addClassTagInfo(Content classInfo) {\n+        if (!options.noComment()) {\n+            \/\/ Print Information about all the tags here\n+            addTagsInfo(typeElement, classInfo);\n+        }\n+    }\n+\n+    \/**\n+     * Get the class inheritance tree for the given class.\n+     *\n+     * @param type the class to get the inheritance tree for\n+     * @return the class inheritance tree\n+     *\/\n+    private Content getClassInheritanceTreeContent(TypeMirror type) {\n+        TypeMirror sup;\n+        HtmlTree classTree = null;\n+        do {\n+            sup = utils.getFirstVisibleSuperClass(type);\n+            var entry = HtmlTree.DIV(HtmlStyle.inheritance, getClassHelperContent(type));\n+            if (classTree != null)\n+                entry.add(classTree);\n+            classTree = entry;\n+            type = sup;\n+        } while (sup != null);\n+        classTree.put(HtmlAttr.TITLE, contents.getContent(\"doclet.Inheritance_Tree\").toString());\n+        return classTree;\n+    }\n+\n+    \/**\n+     * Get the class helper for the given class.\n+     *\n+     * @param type the class to get the helper for\n+     * @return the class helper\n+     *\/\n+    private Content getClassHelperContent(TypeMirror type) {\n+        Content result = new ContentBuilder();\n+        if (utils.typeUtils.isSameType(type, typeElement.asType())) {\n+            Content typeParameters = getTypeParameterLinks(\n+                    new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS,\n+                    typeElement));\n+            if (configuration.shouldExcludeQualifier(utils.containingPackage(typeElement).toString())) {\n+                result.add(utils.asTypeElement(type).getSimpleName());\n+                result.add(typeParameters);\n+            } else {\n+                result.add(utils.asTypeElement(type).getQualifiedName());\n+                result.add(typeParameters);\n+            }\n+        } else {\n+            Content link = getLink(new HtmlLinkInfo(configuration,\n+                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, type)\n+                    .label(configuration.getClassName(utils.asTypeElement(type))));\n+            result.add(link);\n+        }\n+        return result;\n+    }\n+\n+    protected void addClassTree(Content target) {\n+        if (!utils.isClass(typeElement)) {\n+            return;\n+        }\n+        target.add(getClassInheritanceTreeContent(typeElement.asType()));\n+    }\n+\n+    protected void addParamInfo(Content target) {\n+        if (utils.hasBlockTag(typeElement, DocTree.Kind.PARAM)) {\n+            var t = configuration.tagletManager.getTaglet(DocTree.Kind.PARAM);\n+            Content paramInfo = t.getAllBlockTagOutput(typeElement, getTagletWriterInstance(false));\n+            if (!paramInfo.isEmpty()) {\n+                target.add(HtmlTree.DL(HtmlStyle.notes, paramInfo));\n+            }\n+        }\n+    }\n+\n+    protected void addSubClassInfo(Content target) {\n+        if (utils.isClass(typeElement)) {\n+            for (String s : suppressSubtypesSet) {\n+                if (typeElement.getQualifiedName().contentEquals(s)) {\n+                    return;    \/\/ Don't generate the list, too huge\n+                }\n+            }\n+            Set<TypeElement> subclasses = classTree.hierarchy(typeElement).subtypes(typeElement);\n+            if (!subclasses.isEmpty()) {\n+                var dl = HtmlTree.DL(HtmlStyle.notes);\n+                dl.add(HtmlTree.DT(contents.subclassesLabel));\n+                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.PLAIN, subclasses)));\n+                target.add(dl);\n+            }\n+        }\n+    }\n+\n+    protected void addSubInterfacesInfo(Content target) {\n+        if (utils.isPlainInterface(typeElement)) {\n+            Set<TypeElement> subInterfaces = classTree.hierarchy(typeElement).allSubtypes(typeElement);\n+            if (!subInterfaces.isEmpty()) {\n+                var dl = HtmlTree.DL(HtmlStyle.notes);\n+                dl.add(HtmlTree.DT(contents.subinterfacesLabel));\n+                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, subInterfaces)));\n+                target.add(dl);\n+            }\n+        }\n+    }\n+\n+    protected void addInterfaceUsageInfo(Content target) {\n+        if (!utils.isPlainInterface(typeElement)) {\n+            return;\n+        }\n+        for (String s : suppressImplementingSet) {\n+            if (typeElement.getQualifiedName().contentEquals(s)) {\n+                return;    \/\/ Don't generate the list, too huge\n+            }\n+        }\n+        Set<TypeElement> implcl = classTree.implementingClasses(typeElement);\n+        if (!implcl.isEmpty()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(HtmlTree.DT(contents.implementingClassesLabel));\n+            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.PLAIN, implcl)));\n+            target.add(dl);\n+        }\n+    }\n+\n+    protected void addImplementedInterfacesInfo(Content target) {\n+        SortedSet<TypeMirror> interfaces = new TreeSet<>(comparators.makeTypeMirrorClassUseComparator());\n+        interfaces.addAll(utils.getAllInterfaces(typeElement));\n+        if (utils.isClass(typeElement) && !interfaces.isEmpty()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(HtmlTree.DT(contents.allImplementedInterfacesLabel));\n+            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, interfaces)));\n+            target.add(dl);\n+        }\n+    }\n+\n+    protected void addSuperInterfacesInfo(Content target) {\n+        SortedSet<TypeMirror> interfaces =\n+                new TreeSet<>(comparators.makeTypeMirrorIndexUseComparator());\n+        interfaces.addAll(utils.getAllInterfaces(typeElement));\n+\n+        if (utils.isPlainInterface(typeElement) && !interfaces.isEmpty()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(HtmlTree.DT(contents.allSuperinterfacesLabel));\n+            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, interfaces)));\n+            target.add(dl);\n+        }\n+    }\n+\n+    protected void addNestedClassInfo(final Content target) {\n+        Element outerClass = typeElement.getEnclosingElement();\n+        if (outerClass == null)\n+            return;\n+        new SimpleElementVisitor8<Void, Void>() {\n+            @Override\n+            public Void visitType(TypeElement e, Void p) {\n+                var dl = HtmlTree.DL(HtmlStyle.notes);\n+                dl.add(HtmlTree.DT(utils.isPlainInterface(e)\n+                        ? contents.enclosingInterfaceLabel\n+                        : contents.enclosingClassLabel));\n+                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, List.of(e))));\n+                target.add(dl);\n+                return null;\n+            }\n+        }.visit(outerClass);\n+    }\n+\n+    protected void addFunctionalInterfaceInfo (Content target) {\n+        if (isFunctionalInterface()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(HtmlTree.DT(contents.functionalInterface));\n+            var dd = new HtmlTree(TagName.DD);\n+            dd.add(contents.functionalInterfaceMessage);\n+            dl.add(dd);\n+            target.add(dl);\n+        }\n+    }\n+\n+    public boolean isFunctionalInterface() {\n+        List<? extends AnnotationMirror> annotationMirrors = typeElement.getAnnotationMirrors();\n+        for (AnnotationMirror anno : annotationMirrors) {\n+            if (utils.isFunctionalInterface(anno)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+\n+    protected void addClassDeprecationInfo(Content classInfo) {\n+        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(typeElement);\n+        if (utils.isDeprecated(typeElement)) {\n+            var deprLabel = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(typeElement));\n+            var div = HtmlTree.DIV(HtmlStyle.deprecationBlock, deprLabel);\n+            if (!deprs.isEmpty()) {\n+                CommentHelper ch = utils.getCommentHelper(typeElement);\n+                DocTree dt = deprs.get(0);\n+                List<? extends DocTree> commentTags = ch.getBody(dt);\n+                if (!commentTags.isEmpty()) {\n+                    addInlineDeprecatedComment(typeElement, deprs.get(0), div);\n+                }\n+            }\n+            classInfo.add(div);\n+        }\n+    }\n+\n+    \/**\n+     * Get the links to the given classes.\n+     *\n+     * @param context the id of the context where the links will be added\n+     * @param list the classes\n+     * @return the links\n+     *\/\n+    private Content getClassLinks(HtmlLinkInfo.Kind context, Collection<?> list) {\n+        Content content = new ContentBuilder();\n+        boolean isFirst = true;\n+        for (Object type : list) {\n+            if (!isFirst) {\n+                content.add(Text.of(\", \"));\n+            } else {\n+                isFirst = false;\n+            }\n+            \/\/ TODO: should we simply split this method up to avoid instanceof ?\n+            if (type instanceof TypeElement te) {\n+                Content link = getLink(\n+                        new HtmlLinkInfo(configuration, context, te));\n+                content.add(HtmlTree.CODE(link));\n+            } else {\n+                Content link = getLink(\n+                        new HtmlLinkInfo(configuration, context, ((TypeMirror)type)));\n+                content.add(HtmlTree.CODE(link));\n+            }\n+        }\n+        return content;\n+    }\n+\n+    \/**\n+     * Return the TypeElement being documented.\n+     *\n+     * @return the TypeElement being documented.\n+     *\/\n+    public TypeElement getTypeElement() {\n+        return typeElement;\n+    }\n+\n+    protected Content getMemberDetails(Content content) {\n+        var section = HtmlTree.SECTION(HtmlStyle.details, content);\n+        \/\/ The following id is required by the Navigation bar\n+        if (utils.isAnnotationInterface(typeElement)) {\n+            section.setId(HtmlIds.ANNOTATION_TYPE_ELEMENT_DETAIL);\n+        }\n+        return section;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriter.java","additions":1093,"deletions":0,"binary":false,"changes":1093,"status":"added"},{"patch":"@@ -1,470 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-\n-import javax.lang.model.element.AnnotationMirror;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.SimpleElementVisitor8;\n-\n-import com.sun.source.doctree.DeprecatedTree;\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-\/**\n- * Generate the Class Information Page.\n- *\n- * @see javax.lang.model.element.TypeElement\n- *\/\n-public class ClassWriterImpl extends SubWriterHolderWriter implements ClassWriter {\n-\n-    private static final Set<String> suppressSubtypesSet\n-            = Set.of(\"java.lang.Object\",\n-                     \"org.omg.CORBA.Object\");\n-\n-    private static final Set<String> suppressImplementingSet\n-            = Set.of(\"java.lang.Cloneable\",\n-                     \"java.lang.constant.Constable\",\n-                     \"java.lang.constant.ConstantDesc\",\n-                     \"java.io.Serializable\");\n-\n-    protected final TypeElement typeElement;\n-\n-    protected final ClassTree classTree;\n-\n-    \/**\n-     * @param configuration the configuration data for the doclet\n-     * @param typeElement the class being documented.\n-     * @param classTree the class tree for the given class.\n-     *\/\n-    public ClassWriterImpl(HtmlConfiguration configuration, TypeElement typeElement,\n-                           ClassTree classTree) {\n-        super(configuration, configuration.docPaths.forClass(typeElement));\n-        this.typeElement = typeElement;\n-        configuration.currentTypeElement = typeElement;\n-        this.classTree = classTree;\n-    }\n-\n-    @Override\n-    public Content getOutputInstance() {\n-        return new ContentBuilder();\n-    }\n-\n-    @Override\n-    public Content getHeader(String header) {\n-        HtmlTree body = getBody(getWindowTitle(utils.getSimpleName(typeElement)));\n-        var div = HtmlTree.DIV(HtmlStyle.header);\n-        if (configuration.showModules) {\n-            ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);\n-            var classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);\n-            var moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);\n-            moduleNameDiv.add(Entity.NO_BREAK_SPACE);\n-            moduleNameDiv.add(getModuleLink(mdle,\n-                    Text.of(mdle.getQualifiedName())));\n-            div.add(moduleNameDiv);\n-        }\n-        PackageElement pkg = utils.containingPackage(typeElement);\n-        if (!pkg.isUnnamed()) {\n-            var classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);\n-            var pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);\n-            pkgNameDiv.add(Entity.NO_BREAK_SPACE);\n-            Content pkgNameContent = getPackageLink(pkg, getLocalizedPackageName(pkg));\n-            pkgNameDiv.add(pkgNameContent);\n-            div.add(pkgNameDiv);\n-        }\n-        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration,\n-                HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement)\n-                .linkToSelf(false);  \/\/ Let's not link to ourselves in the header\n-        var heading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n-                HtmlStyle.title, Text.of(header));\n-        heading.add(getTypeParameterLinks(linkInfo));\n-        div.add(heading);\n-        bodyContents.setHeader(getHeader(PageMode.CLASS, typeElement))\n-                .addMainContent(MarkerComments.START_OF_CLASS_DATA)\n-                .addMainContent(div);\n-        return body;\n-    }\n-\n-    @Override\n-    public Content getClassContentHeader() {\n-        return getContentHeader();\n-    }\n-\n-    @Override\n-    protected Navigation getNavBar(PageMode pageMode, Element element) {\n-        Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(element),\n-                contents.moduleLabel);\n-        return super.getNavBar(pageMode, element)\n-                .setNavLinkModule(linkContent)\n-                .setSubNavLinks(() -> {\n-                    List<Content> list = new ArrayList<>();\n-                    VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n-                    Set<VisibleMemberTable.Kind> summarySet =\n-                            VisibleMemberTable.Kind.forSummariesOf(element.getKind());\n-                    for (VisibleMemberTable.Kind kind : summarySet) {\n-                        list.add(links.createLink(HtmlIds.forMemberSummary(kind),\n-                                contents.getNavLinkLabelContent(kind), vmt.hasVisibleMembers(kind)));\n-                    }\n-                    return list;\n-                });\n-    }\n-\n-    @Override\n-    public void addFooter() {\n-        bodyContents.addMainContent(MarkerComments.END_OF_CLASS_DATA);\n-        bodyContents.setFooter(getFooter());\n-    }\n-\n-    @Override\n-    public void printDocument(Content content) throws DocFileIOException {\n-        String description = getDescription(\"declaration\", typeElement);\n-        PackageElement pkg = utils.containingPackage(typeElement);\n-        List<DocPath> localStylesheets = getLocalStylesheets(pkg);\n-        content.add(bodyContents);\n-        printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),\n-                description, localStylesheets, content);\n-    }\n-\n-    @Override\n-    public Content getClassInfo(Content classInfo) {\n-        return getMember(HtmlIds.CLASS_DESCRIPTION, HtmlStyle.classDescription, classInfo);\n-    }\n-\n-    @Override\n-    public TypeElement getCurrentPageElement() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public void addClassSignature(Content classInfo) {\n-        classInfo.add(new HtmlTree(TagName.HR));\n-        classInfo.add(new Signatures.TypeSignature(typeElement, this)\n-                .toContent());\n-    }\n-\n-\n-    @Override\n-    public void addClassDescription(Content classInfo) {\n-        addPreviewInfo(classInfo);\n-        if (!options.noComment()) {\n-            \/\/ generate documentation for the class.\n-            if (!utils.getFullBody(typeElement).isEmpty()) {\n-                addInlineComment(typeElement, classInfo);\n-            }\n-        }\n-    }\n-\n-    private void addPreviewInfo(Content content) {\n-        addPreviewInfo(typeElement, content);\n-    }\n-\n-    @Override\n-    public void addClassTagInfo(Content classInfo) {\n-        if (!options.noComment()) {\n-            \/\/ Print Information about all the tags here\n-            addTagsInfo(typeElement, classInfo);\n-        }\n-    }\n-\n-    \/**\n-     * Get the class inheritance tree for the given class.\n-     *\n-     * @param type the class to get the inheritance tree for\n-     * @return the class inheritance tree\n-     *\/\n-    private Content getClassInheritanceTreeContent(TypeMirror type) {\n-        TypeMirror sup;\n-        HtmlTree classTree = null;\n-        do {\n-            sup = utils.getFirstVisibleSuperClass(type);\n-            var entry = HtmlTree.DIV(HtmlStyle.inheritance, getClassHelperContent(type));\n-            if (classTree != null)\n-                entry.add(classTree);\n-            classTree = entry;\n-            type = sup;\n-        } while (sup != null);\n-        classTree.put(HtmlAttr.TITLE, contents.getContent(\"doclet.Inheritance_Tree\").toString());\n-        return classTree;\n-    }\n-\n-    \/**\n-     * Get the class helper for the given class.\n-     *\n-     * @param type the class to get the helper for\n-     * @return the class helper\n-     *\/\n-    private Content getClassHelperContent(TypeMirror type) {\n-        Content result = new ContentBuilder();\n-        if (utils.typeUtils.isSameType(type, typeElement.asType())) {\n-            Content typeParameters = getTypeParameterLinks(\n-                    new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS,\n-                    typeElement));\n-            if (configuration.shouldExcludeQualifier(utils.containingPackage(typeElement).toString())) {\n-                result.add(utils.asTypeElement(type).getSimpleName());\n-                result.add(typeParameters);\n-            } else {\n-                result.add(utils.asTypeElement(type).getQualifiedName());\n-                result.add(typeParameters);\n-            }\n-        } else {\n-            Content link = getLink(new HtmlLinkInfo(configuration,\n-                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, type)\n-                    .label(configuration.getClassName(utils.asTypeElement(type))));\n-            result.add(link);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public void addClassTree(Content target) {\n-        if (!utils.isClass(typeElement)) {\n-            return;\n-        }\n-        target.add(getClassInheritanceTreeContent(typeElement.asType()));\n-    }\n-\n-    @Override\n-    public void addParamInfo(Content target) {\n-        if (utils.hasBlockTag(typeElement, DocTree.Kind.PARAM)) {\n-            var t = configuration.tagletManager.getTaglet(DocTree.Kind.PARAM);\n-            Content paramInfo = t.getAllBlockTagOutput(typeElement, getTagletWriterInstance(false));\n-            if (!paramInfo.isEmpty()) {\n-                target.add(HtmlTree.DL(HtmlStyle.notes, paramInfo));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addSubClassInfo(Content target) {\n-        if (utils.isClass(typeElement)) {\n-            for (String s : suppressSubtypesSet) {\n-                if (typeElement.getQualifiedName().contentEquals(s)) {\n-                    return;    \/\/ Don't generate the list, too huge\n-                }\n-            }\n-            Set<TypeElement> subclasses = classTree.hierarchy(typeElement).subtypes(typeElement);\n-            if (!subclasses.isEmpty()) {\n-                var dl = HtmlTree.DL(HtmlStyle.notes);\n-                dl.add(HtmlTree.DT(contents.subclassesLabel));\n-                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.PLAIN, subclasses)));\n-                target.add(dl);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addSubInterfacesInfo(Content target) {\n-        if (utils.isPlainInterface(typeElement)) {\n-            Set<TypeElement> subInterfaces = classTree.hierarchy(typeElement).allSubtypes(typeElement);\n-            if (!subInterfaces.isEmpty()) {\n-                var dl = HtmlTree.DL(HtmlStyle.notes);\n-                dl.add(HtmlTree.DT(contents.subinterfacesLabel));\n-                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, subInterfaces)));\n-                target.add(dl);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addInterfaceUsageInfo(Content target) {\n-        if (!utils.isPlainInterface(typeElement)) {\n-            return;\n-        }\n-        for (String s : suppressImplementingSet) {\n-            if (typeElement.getQualifiedName().contentEquals(s)) {\n-                return;    \/\/ Don't generate the list, too huge\n-            }\n-        }\n-        Set<TypeElement> implcl = classTree.implementingClasses(typeElement);\n-        if (!implcl.isEmpty()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(HtmlTree.DT(contents.implementingClassesLabel));\n-            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.PLAIN, implcl)));\n-            target.add(dl);\n-        }\n-    }\n-\n-    @Override\n-    public void addImplementedInterfacesInfo(Content target) {\n-        SortedSet<TypeMirror> interfaces = new TreeSet<>(comparators.makeTypeMirrorClassUseComparator());\n-        interfaces.addAll(utils.getAllInterfaces(typeElement));\n-        if (utils.isClass(typeElement) && !interfaces.isEmpty()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(HtmlTree.DT(contents.allImplementedInterfacesLabel));\n-            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, interfaces)));\n-            target.add(dl);\n-        }\n-    }\n-\n-    @Override\n-    public void addSuperInterfacesInfo(Content target) {\n-        SortedSet<TypeMirror> interfaces =\n-                new TreeSet<>(comparators.makeTypeMirrorIndexUseComparator());\n-        interfaces.addAll(utils.getAllInterfaces(typeElement));\n-\n-        if (utils.isPlainInterface(typeElement) && !interfaces.isEmpty()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(HtmlTree.DT(contents.allSuperinterfacesLabel));\n-            dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS, interfaces)));\n-            target.add(dl);\n-        }\n-    }\n-\n-    @Override\n-    public void addNestedClassInfo(final Content target) {\n-        Element outerClass = typeElement.getEnclosingElement();\n-        if (outerClass == null)\n-            return;\n-        new SimpleElementVisitor8<Void, Void>() {\n-            @Override\n-            public Void visitType(TypeElement e, Void p) {\n-                var dl = HtmlTree.DL(HtmlStyle.notes);\n-                dl.add(HtmlTree.DT(utils.isPlainInterface(e)\n-                        ? contents.enclosingInterfaceLabel\n-                        : contents.enclosingClassLabel));\n-                dl.add(HtmlTree.DD(getClassLinks(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, List.of(e))));\n-                target.add(dl);\n-                return null;\n-            }\n-        }.visit(outerClass);\n-    }\n-\n-    @Override\n-    public void addFunctionalInterfaceInfo (Content target) {\n-        if (isFunctionalInterface()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(HtmlTree.DT(contents.functionalInterface));\n-            var dd = new HtmlTree(TagName.DD);\n-            dd.add(contents.functionalInterfaceMessage);\n-            dl.add(dd);\n-            target.add(dl);\n-        }\n-    }\n-\n-    public boolean isFunctionalInterface() {\n-        List<? extends AnnotationMirror> annotationMirrors = typeElement.getAnnotationMirrors();\n-        for (AnnotationMirror anno : annotationMirrors) {\n-            if (utils.isFunctionalInterface(anno)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    @Override\n-    public void addClassDeprecationInfo(Content classInfo) {\n-        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(typeElement);\n-        if (utils.isDeprecated(typeElement)) {\n-            var deprLabel = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(typeElement));\n-            var div = HtmlTree.DIV(HtmlStyle.deprecationBlock, deprLabel);\n-            if (!deprs.isEmpty()) {\n-                CommentHelper ch = utils.getCommentHelper(typeElement);\n-                DocTree dt = deprs.get(0);\n-                List<? extends DocTree> commentTags = ch.getBody(dt);\n-                if (!commentTags.isEmpty()) {\n-                    addInlineDeprecatedComment(typeElement, deprs.get(0), div);\n-                }\n-            }\n-            classInfo.add(div);\n-        }\n-    }\n-\n-    \/**\n-     * Get the links to the given classes.\n-     *\n-     * @param context the id of the context where the links will be added\n-     * @param list the classes\n-     * @return the links\n-     *\/\n-    private Content getClassLinks(HtmlLinkInfo.Kind context, Collection<?> list) {\n-        Content content = new ContentBuilder();\n-        boolean isFirst = true;\n-        for (Object type : list) {\n-            if (!isFirst) {\n-                content.add(Text.of(\", \"));\n-            } else {\n-                isFirst = false;\n-            }\n-            \/\/ TODO: should we simply split this method up to avoid instanceof ?\n-            if (type instanceof TypeElement te) {\n-                Content link = getLink(\n-                        new HtmlLinkInfo(configuration, context, te));\n-                content.add(HtmlTree.CODE(link));\n-            } else {\n-                Content link = getLink(\n-                        new HtmlLinkInfo(configuration, context, ((TypeMirror)type)));\n-                content.add(HtmlTree.CODE(link));\n-            }\n-        }\n-        return content;\n-    }\n-\n-    \/**\n-     * Return the TypeElement being documented.\n-     *\n-     * @return the TypeElement being documented.\n-     *\/\n-    @Override\n-    public TypeElement getTypeElement() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Content getMemberDetails(Content content) {\n-        var section = HtmlTree.SECTION(HtmlStyle.details, content);\n-        \/\/ The following id is required by the Navigation bar\n-        if (utils.isAnnotationInterface(typeElement)) {\n-            section.setId(HtmlIds.ANNOTATION_TYPE_ELEMENT_DETAIL);\n-        }\n-        return section;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":0,"deletions":470,"binary":false,"changes":470,"status":"deleted"},{"patch":"@@ -0,0 +1,488 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\n+\/**\n+ * Write the Constants Summary Page in HTML format.\n+ *\/\n+public class ConstantsSummaryWriter extends HtmlDocletWriter {\n+\n+    \/**\n+     * The maximum number of package directories shown in the headings of\n+     * the constant values contents list and headings.\n+     *\/\n+    private static final int MAX_CONSTANT_VALUE_INDEX_LENGTH = 2;\n+\n+    \/**\n+     * The current class being documented.\n+     *\/\n+    private TypeElement currentTypeElement;\n+\n+    private final TableHeader constantsTableHeader;\n+\n+    \/**\n+     * The HTML tree for constant values summary currently being written.\n+     *\/\n+    private HtmlTree summarySection;\n+\n+    private final BodyContents bodyContents = new BodyContents();\n+\n+    private boolean hasConstants = false;\n+\n+\n+    \/**\n+     * The set of type elements that have constant fields.\n+     *\/\n+    protected final Set<TypeElement> typeElementsWithConstFields;\n+\n+    \/**\n+     * The set of package-group headings.\n+     *\/\n+    protected final Set<String> packageGroupHeadings;\n+\n+    private PackageElement currentPackage;\n+    private TypeElement currentClass; \/\/ FIXME: dup of currentTypeElement\n+\n+\n+    \/**\n+     * Construct a ConstantsSummaryWriter.\n+     * @param configuration the configuration used in this run\n+     *        of the standard doclet.\n+     *\/\n+    public ConstantsSummaryWriter(HtmlConfiguration configuration) {\n+        super(configuration, DocPaths.CONSTANT_VALUES, false);\n+        constantsTableHeader = new TableHeader(\n+                contents.modifierAndTypeLabel, contents.constantFieldLabel, contents.valueLabel);\n+\n+        this.typeElementsWithConstFields = new HashSet<>();\n+        this.packageGroupHeadings = new TreeSet<>(utils::compareStrings);\n+    }\n+\n+    public void build() throws DocletException {\n+        boolean anyConstants = configuration.packages.stream().anyMatch(this::hasConstantField);\n+        if (!anyConstants) {\n+            return;\n+        }\n+\n+        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.CONSTANT_VALUES);\n+        writeGenerating();\n+\n+        buildConstantSummary();\n+    }\n+\n+    \/**\n+     * Builds the constant summary page.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildConstantSummary() throws DocletException {\n+        Content content = getHeader();\n+\n+        buildContents();\n+        buildConstantSummaries();\n+\n+        addFooter();\n+        printDocument(content);\n+    }\n+\n+    \/**\n+     * Builds the list of contents for the groups of packages appearing in the constants summary page.\n+     *\/\n+    protected void buildContents() {\n+        Content contentList = getContentsHeader();\n+        packageGroupHeadings.clear();\n+        for (PackageElement pkg : configuration.packages) {\n+            String abbrevPackageName = getAbbrevPackageName(pkg);\n+            if (hasConstantField(pkg) && !packageGroupHeadings.contains(abbrevPackageName)) {\n+                addLinkToPackageContent(abbrevPackageName, contentList);\n+                packageGroupHeadings.add(abbrevPackageName);\n+            }\n+        }\n+        addContentsList(contentList);\n+    }\n+\n+    \/**\n+     * Builds the summary for each documented package.\n+     *\/\n+    protected void buildConstantSummaries() {\n+        packageGroupHeadings.clear();\n+        Content summaries = getConstantSummaries();\n+        for (PackageElement aPackage : configuration.packages) {\n+            if (hasConstantField(aPackage)) {\n+                currentPackage = aPackage;\n+                \/\/Build the documentation for the current package.\n+                buildPackageHeader(summaries);\n+                buildClassConstantSummary();\n+            }\n+        }\n+        addConstantSummaries(summaries);\n+    }\n+\n+    \/**\n+     * Builds the header for the given package.\n+     *\n+     * @param target the content to which the package header will be added\n+     *\/\n+    protected void buildPackageHeader(Content target) {\n+        String abbrevPkgName = getAbbrevPackageName(currentPackage);\n+        if (!packageGroupHeadings.contains(abbrevPkgName)) {\n+            addPackageGroup(abbrevPkgName, target);\n+            packageGroupHeadings.add(abbrevPkgName);\n+        }\n+    }\n+\n+    \/**\n+     * Builds the summary for the current class.\n+     *\/\n+    protected void buildClassConstantSummary() {\n+        SortedSet<TypeElement> classes = !currentPackage.isUnnamed()\n+                ? utils.getAllClasses(currentPackage)\n+                : configuration.typeElementCatalog.allUnnamedClasses();\n+        Content classConstantHeader = getClassConstantHeader();\n+        for (TypeElement te : classes) {\n+            if (!typeElementsWithConstFields.contains(te) ||\n+                    !utils.isIncluded(te)) {\n+                continue;\n+            }\n+            currentClass = te;\n+            \/\/Build the documentation for the current class.\n+\n+            buildConstantMembers(classConstantHeader);\n+\n+        }\n+        addClassConstant(classConstantHeader);\n+    }\n+\n+    \/**\n+     * Builds the summary of constant members in the class.\n+     *\n+     * @param target the content to which the table of constant members will be added\n+     *\/\n+    protected void buildConstantMembers(Content target) {\n+        new ConstantFieldBuilder(currentClass).buildMembersSummary(target);\n+    }\n+\n+    \/**\n+     * {@return true if the given package has constant fields to document}\n+     *\n+     * @param pkg   the package to be checked\n+     *\/\n+    private boolean hasConstantField(PackageElement pkg) {\n+        SortedSet<TypeElement> classes = !pkg.isUnnamed()\n+                ? utils.getAllClasses(pkg)\n+                : configuration.typeElementCatalog.allUnnamedClasses();\n+        boolean found = false;\n+        for (TypeElement te : classes) {\n+            if (utils.isIncluded(te) && hasConstantField(te)) {\n+                found = true;\n+            }\n+        }\n+        return found;\n+    }\n+\n+    \/**\n+     * {@return true if the given class has constant fields to document}\n+     *\n+     * @param typeElement the class to be checked\n+     *\/\n+    private boolean hasConstantField(TypeElement typeElement) {\n+        VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n+        List<? extends Element> fields = vmt.getVisibleMembers(VisibleMemberTable.Kind.FIELDS);\n+        for (Element f : fields) {\n+            VariableElement field = (VariableElement)f;\n+            if (field.getConstantValue() != null) {\n+                typeElementsWithConstFields.add(typeElement);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * {@return the abbreviated name for a package, containing the leading segments of the name}\n+     *\n+     * @param pkg the package\n+     *\/\n+    public String getAbbrevPackageName(PackageElement pkg) {\n+        if (pkg.isUnnamed()) {\n+            return \"\";\n+        }\n+\n+        String packageName = utils.getPackageName(pkg);\n+        int index = -1;\n+        for (int j = 0; j < MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {\n+            index = packageName.indexOf(\".\", index + 1);\n+        }\n+        return index == -1 ? packageName : packageName.substring(0, index);\n+    }\n+\n+    \/**\n+     * Builder for the table of fields with constant values.\n+     *\/\n+    private class ConstantFieldBuilder {\n+\n+        \/**\n+         * The type element that we are examining constants for.\n+         *\/\n+        protected TypeElement typeElement;\n+\n+        \/**\n+         * Constructs a {@code ConstantFieldBuilder}.\n+         * @param typeElement the type element that we are examining constants for\n+         *\/\n+        public ConstantFieldBuilder(TypeElement typeElement) {\n+            this.typeElement = typeElement;\n+        }\n+\n+        \/**\n+         * Builds the table of constants for a given class.\n+         *\n+         * @param target the content to which the table of class constants will be added\n+         *\/\n+        protected void buildMembersSummary(Content target) {\n+            SortedSet<VariableElement> members = members();\n+            if (!members.isEmpty()) {\n+                addConstantMembers(typeElement, members, target);\n+            }\n+        }\n+\n+        \/**\n+         * {@return a set of visible constant fields for the given type}\n+         *\/\n+        protected SortedSet<VariableElement> members() {\n+            VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n+            List<Element> members = new ArrayList<>();\n+            members.addAll(vmt.getVisibleMembers(VisibleMemberTable.Kind.FIELDS));\n+            members.addAll(vmt.getVisibleMembers(VisibleMemberTable.Kind.ENUM_CONSTANTS));\n+            SortedSet<VariableElement> includes =\n+                    new TreeSet<>(utils.comparators.makeGeneralPurposeComparator());\n+            for (Element element : members) {\n+                VariableElement member = (VariableElement)element;\n+                if (member.getConstantValue() != null) {\n+                    includes.add(member);\n+                }\n+            }\n+            return includes;\n+        }\n+    }\n+\n+     Content getHeader() {\n+        String label = resources.getText(\"doclet.Constants_Summary\");\n+        HtmlTree body = getBody(getWindowTitle(label));\n+        bodyContents.setHeader(getHeader(PageMode.CONSTANT_VALUES));\n+        return body;\n+    }\n+\n+     Content getContentsHeader() {\n+        return HtmlTree.UL(HtmlStyle.contentsList);\n+    }\n+\n+     void addLinkToPackageContent(String abbrevPackageName, Content content) {\n+        \/\/add link to summary\n+        Content link;\n+        if (abbrevPackageName.isEmpty()) {\n+            link = links.createLink(HtmlIds.UNNAMED_PACKAGE_ANCHOR,\n+                    contents.defaultPackageLabel, \"\");\n+        } else {\n+            Content packageNameContent = Text.of(abbrevPackageName + \".*\");\n+            link = links.createLink(DocLink.fragment(abbrevPackageName),\n+                    packageNameContent, \"\");\n+        }\n+        content.add(HtmlTree.LI(link));\n+    }\n+\n+     void addContentsList(Content content) {\n+        Content titleContent = contents.constantsSummaryTitle;\n+        var pHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n+                HtmlStyle.title, titleContent);\n+        var div = HtmlTree.DIV(HtmlStyle.header, pHeading);\n+        bodyContents.addMainContent(div);\n+        Content headingContent = contents.contentsHeading;\n+        var heading = HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING,\n+                headingContent);\n+        var section = HtmlTree.SECTION(HtmlStyle.packages, heading);\n+        section.add(content);\n+        bodyContents.addMainContent(section);\n+    }\n+\n+    \/\/@Override\n+    \/\/ TODO: inline?\n+    public Content getConstantSummaries() {\n+        return new ContentBuilder();\n+    }\n+\n+     void addPackageGroup(String abbrevPackageName, Content toContent) {\n+        Content headingContent;\n+        HtmlId anchorName;\n+        if (abbrevPackageName.isEmpty()) {\n+            anchorName = HtmlIds.UNNAMED_PACKAGE_ANCHOR;\n+            headingContent = contents.defaultPackageLabel;\n+        } else {\n+            anchorName = htmlIds.forPackageName(abbrevPackageName);\n+            headingContent = new ContentBuilder(\n+                    getPackageLabel(abbrevPackageName),\n+                    Text.of(\".*\"));\n+        }\n+        var heading = HtmlTree.HEADING_TITLE(\n+                Headings.ConstantsSummary.PACKAGE_HEADING,\n+                headingContent);\n+        summarySection = HtmlTree.SECTION(HtmlStyle.constantsSummary, heading)\n+                .setId(anchorName);\n+\n+        toContent.add(summarySection);\n+    }\n+\n+     Content getClassConstantHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+     void addClassConstant(Content fromClassConstant) {\n+        summarySection.add(fromClassConstant);\n+        hasConstants = true;\n+    }\n+\n+     void addConstantMembers(TypeElement typeElement, Collection<VariableElement> fields,\n+            Content target) {\n+        currentTypeElement = typeElement;\n+\n+        \/\/generate links backward only to public classes.\n+        Content classLink = (utils.isPublic(typeElement) || utils.isProtected(typeElement)) ?\n+            getLink(new HtmlLinkInfo(configuration,\n+                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_IN_LABEL, typeElement)) :\n+            Text.of(utils.getFullyQualifiedName(typeElement));\n+\n+        PackageElement enclosingPackage  = utils.containingPackage(typeElement);\n+        Content caption = new ContentBuilder();\n+        if (!enclosingPackage.isUnnamed()) {\n+            caption.add(enclosingPackage.getQualifiedName());\n+            caption.add(\".\");\n+        }\n+        caption.add(classLink);\n+\n+        var table = new Table<Void>(HtmlStyle.summaryTable)\n+                .setCaption(caption)\n+                .setHeader(constantsTableHeader)\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n+\n+        for (VariableElement field : fields) {\n+            table.addRow(getTypeColumn(field), getNameColumn(field), getValue(field));\n+        }\n+        target.add(HtmlTree.LI(table));\n+    }\n+\n+    \/**\n+     * Get the type column for the constant summary table row.\n+     *\n+     * @param member the field to be documented.\n+     * @return the type column of the constant table row\n+     *\/\n+    private Content getTypeColumn(VariableElement member) {\n+        Content typeContent = new ContentBuilder();\n+        var code = new HtmlTree(TagName.CODE)\n+                .setId(htmlIds.forMember(currentTypeElement, member));\n+        for (Modifier mod : member.getModifiers()) {\n+            code.add(Text.of(mod.toString()))\n+                    .add(Entity.NO_BREAK_SPACE);\n+        }\n+        Content type = getLink(new HtmlLinkInfo(configuration,\n+                HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, member.asType()));\n+        code.add(type);\n+        typeContent.add(code);\n+        return typeContent;\n+    }\n+\n+    \/**\n+     * Get the name column for the constant summary table row.\n+     *\n+     * @param member the field to be documented.\n+     * @return the name column of the constant table row\n+     *\/\n+    private Content getNameColumn(VariableElement member) {\n+        Content nameContent = getDocLink(HtmlLinkInfo.Kind.PLAIN,\n+                member, member.getSimpleName());\n+        return HtmlTree.CODE(nameContent);\n+    }\n+\n+    \/**\n+     * Get the value column for the constant summary table row.\n+     *\n+     * @param member the field to be documented.\n+     * @return the value column of the constant table row\n+     *\/\n+    private Content getValue(VariableElement member) {\n+        String value = utils.constantValueExpression(member);\n+        return HtmlTree.CODE(Text.of(value));\n+    }\n+\n+     void addConstantSummaries(Content content) {\n+        bodyContents.addMainContent(content);\n+    }\n+\n+     void addFooter() {\n+        bodyContents.setFooter(getFooter());\n+    }\n+\n+     void printDocument(Content content) throws DocFileIOException {\n+        content.add(bodyContents);\n+        printHtmlDocument(null, \"summary of constants\", content);\n+\n+        if (hasConstants && configuration.mainIndex != null) {\n+            configuration.mainIndex.add(IndexItem.of(IndexItem.Category.TAGS,\n+                    resources.getText(\"doclet.Constants_Summary\"), path));\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstantsSummaryWriter.java","additions":488,"deletions":0,"binary":false,"changes":488,"status":"added"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Collection;\n-\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.ConstantsSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-\n-\n-\/**\n- * Write the Constants Summary Page in HTML format.\n- *\/\n-public class ConstantsSummaryWriterImpl extends HtmlDocletWriter implements ConstantsSummaryWriter {\n-\n-    \/**\n-     * The current class being documented.\n-     *\/\n-    private TypeElement currentTypeElement;\n-\n-    private final TableHeader constantsTableHeader;\n-\n-    \/**\n-     * The HTML tree for constant values summary currently being written.\n-     *\/\n-    private HtmlTree summarySection;\n-\n-    private final BodyContents bodyContents = new BodyContents();\n-\n-    private boolean hasConstants = false;\n-\n-    \/**\n-     * Construct a ConstantsSummaryWriter.\n-     * @param configuration the configuration used in this run\n-     *        of the standard doclet.\n-     *\/\n-    public ConstantsSummaryWriterImpl(HtmlConfiguration configuration) {\n-        super(configuration, DocPaths.CONSTANT_VALUES);\n-        constantsTableHeader = new TableHeader(\n-                contents.modifierAndTypeLabel, contents.constantFieldLabel, contents.valueLabel);\n-        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.CONSTANT_VALUES);\n-    }\n-\n-    @Override\n-    public Content getHeader() {\n-        String label = resources.getText(\"doclet.Constants_Summary\");\n-        HtmlTree body = getBody(getWindowTitle(label));\n-        bodyContents.setHeader(getHeader(PageMode.CONSTANT_VALUES));\n-        return body;\n-    }\n-\n-    @Override\n-    public Content getContentsHeader() {\n-        return HtmlTree.UL(HtmlStyle.contentsList);\n-    }\n-\n-    @Override\n-    public void addLinkToPackageContent(String abbrevPackageName, Content content) {\n-        \/\/add link to summary\n-        Content link;\n-        if (abbrevPackageName.isEmpty()) {\n-            link = links.createLink(HtmlIds.UNNAMED_PACKAGE_ANCHOR,\n-                    contents.defaultPackageLabel, \"\");\n-        } else {\n-            Content packageNameContent = Text.of(abbrevPackageName + \".*\");\n-            link = links.createLink(DocLink.fragment(abbrevPackageName),\n-                    packageNameContent, \"\");\n-        }\n-        content.add(HtmlTree.LI(link));\n-    }\n-\n-    @Override\n-    public void addContentsList(Content content) {\n-        Content titleContent = contents.constantsSummaryTitle;\n-        var pHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n-                HtmlStyle.title, titleContent);\n-        var div = HtmlTree.DIV(HtmlStyle.header, pHeading);\n-        bodyContents.addMainContent(div);\n-        Content headingContent = contents.contentsHeading;\n-        var heading = HtmlTree.HEADING_TITLE(Headings.CONTENT_HEADING,\n-                headingContent);\n-        var section = HtmlTree.SECTION(HtmlStyle.packages, heading);\n-        section.add(content);\n-        bodyContents.addMainContent(section);\n-    }\n-\n-    @Override\n-    public Content getConstantSummaries() {\n-        return new ContentBuilder();\n-    }\n-\n-    @Override\n-    public void addPackageGroup(String abbrevPackageName, Content toContent) {\n-        Content headingContent;\n-        HtmlId anchorName;\n-        if (abbrevPackageName.isEmpty()) {\n-            anchorName = HtmlIds.UNNAMED_PACKAGE_ANCHOR;\n-            headingContent = contents.defaultPackageLabel;\n-        } else {\n-            anchorName = htmlIds.forPackageName(abbrevPackageName);\n-            headingContent = new ContentBuilder(\n-                    getPackageLabel(abbrevPackageName),\n-                    Text.of(\".*\"));\n-        }\n-        var heading = HtmlTree.HEADING_TITLE(\n-                Headings.ConstantsSummary.PACKAGE_HEADING,\n-                headingContent);\n-        summarySection = HtmlTree.SECTION(HtmlStyle.constantsSummary, heading)\n-                .setId(anchorName);\n-\n-        toContent.add(summarySection);\n-    }\n-\n-    @Override\n-    public Content getClassConstantHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    @Override\n-    public void addClassConstant(Content fromClassConstant) {\n-        summarySection.add(fromClassConstant);\n-        hasConstants = true;\n-    }\n-\n-    @Override\n-    public void addConstantMembers(TypeElement typeElement, Collection<VariableElement> fields,\n-            Content target) {\n-        currentTypeElement = typeElement;\n-\n-        \/\/generate links backward only to public classes.\n-        Content classLink = (utils.isPublic(typeElement) || utils.isProtected(typeElement)) ?\n-            getLink(new HtmlLinkInfo(configuration,\n-                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_IN_LABEL, typeElement)) :\n-            Text.of(utils.getFullyQualifiedName(typeElement));\n-\n-        PackageElement enclosingPackage  = utils.containingPackage(typeElement);\n-        Content caption = new ContentBuilder();\n-        if (!enclosingPackage.isUnnamed()) {\n-            caption.add(enclosingPackage.getQualifiedName());\n-            caption.add(\".\");\n-        }\n-        caption.add(classLink);\n-\n-        var table = new Table<Void>(HtmlStyle.summaryTable)\n-                .setCaption(caption)\n-                .setHeader(constantsTableHeader)\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n-\n-        for (VariableElement field : fields) {\n-            table.addRow(getTypeColumn(field), getNameColumn(field), getValue(field));\n-        }\n-        target.add(HtmlTree.LI(table));\n-    }\n-\n-    \/**\n-     * Get the type column for the constant summary table row.\n-     *\n-     * @param member the field to be documented.\n-     * @return the type column of the constant table row\n-     *\/\n-    private Content getTypeColumn(VariableElement member) {\n-        Content typeContent = new ContentBuilder();\n-        var code = new HtmlTree(TagName.CODE)\n-                .setId(htmlIds.forMember(currentTypeElement, member));\n-        for (Modifier mod : member.getModifiers()) {\n-            code.add(Text.of(mod.toString()))\n-                    .add(Entity.NO_BREAK_SPACE);\n-        }\n-        Content type = getLink(new HtmlLinkInfo(configuration,\n-                HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, member.asType()));\n-        code.add(type);\n-        typeContent.add(code);\n-        return typeContent;\n-    }\n-\n-    \/**\n-     * Get the name column for the constant summary table row.\n-     *\n-     * @param member the field to be documented.\n-     * @return the name column of the constant table row\n-     *\/\n-    private Content getNameColumn(VariableElement member) {\n-        Content nameContent = getDocLink(HtmlLinkInfo.Kind.PLAIN,\n-                member, member.getSimpleName());\n-        return HtmlTree.CODE(nameContent);\n-    }\n-\n-    \/**\n-     * Get the value column for the constant summary table row.\n-     *\n-     * @param member the field to be documented.\n-     * @return the value column of the constant table row\n-     *\/\n-    private Content getValue(VariableElement member) {\n-        String value = utils.constantValueExpression(member);\n-        return HtmlTree.CODE(Text.of(value));\n-    }\n-\n-    @Override\n-    public void addConstantSummaries(Content content) {\n-        bodyContents.addMainContent(content);\n-    }\n-\n-    @Override\n-    public void addFooter() {\n-        bodyContents.setFooter(getFooter());\n-    }\n-\n-    @Override\n-    public void printDocument(Content content) throws DocFileIOException {\n-        content.add(bodyContents);\n-        printHtmlDocument(null, \"summary of constants\", content);\n-\n-        if (hasConstants && configuration.mainIndex != null) {\n-            configuration.mainIndex.add(IndexItem.of(IndexItem.Category.TAGS,\n-                    resources.getText(\"doclet.Constants_Summary\"), path));\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstantsSummaryWriterImpl.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\n+\/**\n+ * Writes constructor documentation.\n+ *\/\n+public class ConstructorWriter extends AbstractExecutableMemberWriter {\n+\n+    \/**\n+     * The current constructor that is being documented at this point in time.\n+     *\/\n+    private ExecutableElement currentConstructor;\n+\n+    private boolean foundNonPubConstructor = false;\n+\n+    \/**\n+     * Construct a new ConstructorWriterImpl.\n+     *\n+     * @param writer The writer for the class that the constructors belong to.\n+     *\/\n+    public ConstructorWriter(ClassWriter writer) {\n+        super(writer, writer.getTypeElement());\n+\n+        \/\/ the following must be done before the summary table is generated\n+        var constructors = getVisibleMembers(VisibleMemberTable.Kind.CONSTRUCTORS);\n+        for (Element constructor : constructors) {\n+            if (utils.isProtected(constructor) || utils.isPrivate(constructor)) {\n+                setFoundNonPubConstructor(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Construct a new ConstructorWriterImpl.\n+     *\n+     * @param writer The writer for the class that the constructors belong to.\n+     *\/\n+    public ConstructorWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+    }\n+\n+    public void build(Content target) throws DocletException {\n+        buildConstructorDoc(target);\n+    }\n+\n+    \/**\n+     * Build the constructor documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildConstructorDoc(Content target) {\n+        var constructors = getVisibleMembers(VisibleMemberTable.Kind.CONSTRUCTORS);\n+        if (!constructors.isEmpty()) {\n+            for (Element constructor : constructors) {\n+                if (utils.isProtected(constructor) || utils.isPrivate(constructor)) {\n+                    setFoundNonPubConstructor(true);\n+                }\n+            }\n+\n+            Content constructorDetailsHeader = getConstructorDetailsHeader(target);\n+            Content memberList = getMemberList();\n+\n+            for (Element constructor : constructors) {\n+                currentConstructor = (ExecutableElement)constructor;\n+                Content constructorContent = getConstructorHeaderContent(currentConstructor);\n+\n+                buildSignature(constructorContent);\n+                buildDeprecationInfo(constructorContent);\n+                buildPreviewInfo(constructorContent);\n+                buildConstructorComments(constructorContent);\n+                buildTagInfo(constructorContent);\n+\n+                memberList.add(getMemberListItem(constructorContent));\n+            }\n+            Content constructorDetails = getConstructorDetails(constructorDetailsHeader, memberList);\n+            target.add(constructorDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content constructorContent) {\n+        constructorContent.add(getSignature(currentConstructor));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content constructorContent) {\n+        addDeprecated(currentConstructor, constructorContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content constructorContent) {\n+        addPreview(currentConstructor, constructorContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the constructor.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildConstructorComments(Content constructorContent) {\n+        if (!options.noComment()) {\n+            addComments(currentConstructor, constructorContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param constructorContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content constructorContent) {\n+        addTags(currentConstructor, constructorContent);\n+    }\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement,\n+            Content content) {\n+        content.add(MarkerComments.START_OF_CONSTRUCTOR_SUMMARY);\n+        Content c = new ContentBuilder();\n+        writer.addSummaryHeader(this, c);\n+        return c;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.constructorSummary,\n+                HtmlIds.CONSTRUCTOR_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getConstructorDetailsHeader(Content content) {\n+        content.add(MarkerComments.START_OF_CONSTRUCTOR_DETAILS);\n+        Content constructorDetails = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.constructorDetailsLabel);\n+        constructorDetails.add(heading);\n+        return constructorDetails;\n+    }\n+\n+    protected Content getConstructorHeaderContent(ExecutableElement constructor) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(constructor)));\n+        HtmlId erasureAnchor = htmlIds.forErasure(constructor);\n+        if (erasureAnchor != null) {\n+            heading.setId(erasureAnchor);\n+        }\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forMember(constructor));\n+    }\n+\n+    protected Content getSignature(ExecutableElement constructor) {\n+        return new Signatures.MemberSignature(constructor, this)\n+                .setParameters(getParameters(constructor, true))\n+                .setExceptions(getExceptions(constructor))\n+                .setAnnotations(writer.getAnnotationInfo(constructor, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(ExecutableElement constructor, Content constructorContent) {\n+        addDeprecatedInfo(constructor, constructorContent);\n+    }\n+\n+    protected void addPreview(ExecutableElement constructor, Content content) {\n+        addPreviewInfo(constructor, content);\n+    }\n+\n+    protected void addComments(ExecutableElement constructor, Content constructorContent) {\n+        addComment(constructor, constructorContent);\n+    }\n+\n+    protected void addTags(ExecutableElement constructor, Content constructorContent) {\n+        writer.addTagsInfo(constructor, constructorContent);\n+    }\n+\n+    protected Content getConstructorDetails(Content memberDetailsHeader, Content memberDetails) {\n+        return writer.getDetailsListItem(\n+                HtmlTree.SECTION(HtmlStyle.constructorDetails)\n+                        .setId(HtmlIds.CONSTRUCTOR_DETAIL)\n+                        .add(memberDetailsHeader)\n+                        .add(memberDetails));\n+    }\n+\n+    protected void setFoundNonPubConstructor(boolean foundNonPubConstructor) {\n+        this.foundNonPubConstructor = foundNonPubConstructor;\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.constructorSummaryLabel);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        if (foundNonPubConstructor) {\n+            return new TableHeader(contents.modifierLabel, contents.constructorLabel,\n+                    contents.descriptionLabel);\n+        } else {\n+            return new TableHeader(contents.constructorLabel, contents.descriptionLabel);\n+        }\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        List<HtmlStyle> bodyRowStyles;\n+\n+        if (foundNonPubConstructor) {\n+            bodyRowStyles = Arrays.asList(HtmlStyle.colFirst, HtmlStyle.colConstructorName,\n+                    HtmlStyle.colLast);\n+        } else {\n+            bodyRowStyles = Arrays.asList(HtmlStyle.colConstructorName, HtmlStyle.colLast);\n+        }\n+\n+        return new Table<Element>(\n+                HtmlStyle.summaryTable)\n+                .setCaption(contents.constructors)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(bodyRowStyles);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        if (foundNonPubConstructor) {\n+            var code = new HtmlTree(TagName.CODE);\n+            if (utils.isProtected(member)) {\n+                code.add(\"protected \");\n+            } else if (utils.isPrivate(member)) {\n+                code.add(\"private \");\n+            } else if (utils.isPublic(member)) {\n+                code.add(Entity.NO_BREAK_SPACE);\n+            } else {\n+                code.add(\n+                        resources.getText(\"doclet.Package_private\"));\n+            }\n+            content.add(code);\n+        }\n+    }\n+\n+    protected Content getMemberHeader(){\n+        return writer.getMemberHeader();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"},{"patch":"@@ -1,229 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.ConstructorWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.CONSTRUCTORS;\n-\n-\n-\/**\n- * Writes constructor documentation.\n- *\/\n-public class ConstructorWriterImpl extends AbstractExecutableMemberWriter\n-    implements ConstructorWriter, MemberSummaryWriter {\n-\n-    private boolean foundNonPubConstructor = false;\n-\n-    \/**\n-     * Construct a new ConstructorWriterImpl.\n-     *\n-     * @param writer The writer for the class that the constructors belong to.\n-     * @param typeElement the class being documented.\n-     *\/\n-    public ConstructorWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-\n-        VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n-        List<? extends Element> constructors = vmt.getVisibleMembers(CONSTRUCTORS);\n-\n-        for (Element constructor : constructors) {\n-            if (utils.isProtected(constructor) || utils.isPrivate(constructor)) {\n-                setFoundNonPubConstructor(true);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Construct a new ConstructorWriterImpl.\n-     *\n-     * @param writer The writer for the class that the constructors belong to.\n-     *\/\n-    public ConstructorWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content content) {\n-        content.add(MarkerComments.START_OF_CONSTRUCTOR_SUMMARY);\n-        Content c = new ContentBuilder();\n-        writer.addSummaryHeader(this, c);\n-        return c;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.constructorSummary,\n-                HtmlIds.CONSTRUCTOR_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getConstructorDetailsHeader(Content content) {\n-        content.add(MarkerComments.START_OF_CONSTRUCTOR_DETAILS);\n-        Content constructorDetails = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.constructorDetailsLabel);\n-        constructorDetails.add(heading);\n-        return constructorDetails;\n-    }\n-\n-    @Override\n-    public Content getConstructorHeaderContent(ExecutableElement constructor) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(constructor)));\n-        HtmlId erasureAnchor = htmlIds.forErasure(constructor);\n-        if (erasureAnchor != null) {\n-            heading.setId(erasureAnchor);\n-        }\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forMember(constructor));\n-    }\n-\n-    @Override\n-    public Content getSignature(ExecutableElement constructor) {\n-        return new Signatures.MemberSignature(constructor, this)\n-                .setParameters(getParameters(constructor, true))\n-                .setExceptions(getExceptions(constructor))\n-                .setAnnotations(writer.getAnnotationInfo(constructor, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(ExecutableElement constructor, Content constructorContent) {\n-        addDeprecatedInfo(constructor, constructorContent);\n-    }\n-\n-    @Override\n-    public void addPreview(ExecutableElement constructor, Content content) {\n-        addPreviewInfo(constructor, content);\n-    }\n-\n-    @Override\n-    public void addComments(ExecutableElement constructor, Content constructorContent) {\n-        addComment(constructor, constructorContent);\n-    }\n-\n-    @Override\n-    public void addTags(ExecutableElement constructor, Content constructorContent) {\n-        writer.addTagsInfo(constructor, constructorContent);\n-    }\n-\n-    @Override\n-    public Content getConstructorDetails(Content memberDetailsHeader, Content memberDetails) {\n-        return writer.getDetailsListItem(\n-                HtmlTree.SECTION(HtmlStyle.constructorDetails)\n-                        .setId(HtmlIds.CONSTRUCTOR_DETAIL)\n-                        .add(memberDetailsHeader)\n-                        .add(memberDetails));\n-    }\n-\n-    @Override\n-    public void setFoundNonPubConstructor(boolean foundNonPubConstructor) {\n-        this.foundNonPubConstructor = foundNonPubConstructor;\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.constructorSummaryLabel);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        if (foundNonPubConstructor) {\n-            return new TableHeader(contents.modifierLabel, contents.constructorLabel,\n-                    contents.descriptionLabel);\n-        } else {\n-            return new TableHeader(contents.constructorLabel, contents.descriptionLabel);\n-        }\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        List<HtmlStyle> bodyRowStyles;\n-\n-        if (foundNonPubConstructor) {\n-            bodyRowStyles = Arrays.asList(HtmlStyle.colFirst, HtmlStyle.colConstructorName,\n-                    HtmlStyle.colLast);\n-        } else {\n-            bodyRowStyles = Arrays.asList(HtmlStyle.colConstructorName, HtmlStyle.colLast);\n-        }\n-\n-        return new Table<Element>(\n-                HtmlStyle.summaryTable)\n-                .setCaption(contents.constructors)\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(bodyRowStyles);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        if (foundNonPubConstructor) {\n-            var code = new HtmlTree(TagName.CODE);\n-            if (utils.isProtected(member)) {\n-                code.add(\"protected \");\n-            } else if (utils.isPrivate(member)) {\n-                code.add(\"private \");\n-            } else if (utils.isPublic(member)) {\n-                code.add(Entity.NO_BREAK_SPACE);\n-            } else {\n-                code.add(\n-                        resources.getText(\"doclet.Package_private\"));\n-            }\n-            content.add(code);\n-        }\n-    }\n-\n-    @Override\n-    public Content getMemberHeader(){\n-        return writer.getMemberHeader();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriterImpl.java","additions":0,"deletions":229,"binary":false,"changes":229,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit;\n+package jdk.javadoc.internal.doclets.formats.html;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Content.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/Content.java","status":"renamed"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -396,1 +395,1 @@\n-        Pattern p = Pattern.compile(\"\\\\{([012])\\\\}\");\n+        Pattern p = Pattern.compile(\"\\\\{([012])}\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Contents.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DeprecatedListWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -36,1 +35,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n@@ -57,1 +55,1 @@\n-public class DocFilesHandlerImpl implements DocFilesHandler {\n+public class DocFilesHandler {\n@@ -72,1 +70,1 @@\n-    public DocFilesHandlerImpl(HtmlConfiguration configuration, Element element) {\n+    public DocFilesHandler(HtmlConfiguration configuration, Element element) {\n@@ -105,1 +103,0 @@\n-    @Override\n@@ -122,1 +119,0 @@\n-    @Override\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DocFilesHandler.java","additions":2,"deletions":6,"binary":false,"changes":8,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/DocFilesHandlerImpl.java","status":"renamed"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * Writes enum constant documentation in HTML format.\n+ *\/\n+public class EnumConstantWriter extends AbstractMemberWriter {\n+\n+    \/**\n+     * The current enum constant that is being documented.\n+     *\/\n+    private VariableElement currentElement;\n+\n+    public EnumConstantWriter(ClassWriter classWriter) {\n+        super(classWriter, classWriter.typeElement);\n+    }\n+\n+    public EnumConstantWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+    }\n+\n+    public void build(Content target) {\n+        buildEnumConstant(target);\n+    }\n+\n+    \/**\n+     * Build the enum constant documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildEnumConstant(Content target) {\n+        var enumConstants = getVisibleMembers(VisibleMemberTable.Kind.ENUM_CONSTANTS);\n+        if (!enumConstants.isEmpty()) {\n+            Content enumConstantsDetailsHeader = getEnumConstantsDetailsHeader(typeElement,\n+                    target);\n+            Content memberList = getMemberList();\n+\n+            for (Element enumConstant : enumConstants) {\n+                currentElement = (VariableElement)enumConstant;\n+                Content enumConstantContent = getEnumConstantsHeader(currentElement,\n+                        memberList);\n+\n+                buildSignature(enumConstantContent);\n+                buildDeprecationInfo(enumConstantContent);\n+                buildPreviewInfo(enumConstantContent);\n+                buildEnumConstantComments(enumConstantContent);\n+                buildTagInfo(enumConstantContent);\n+\n+                memberList.add(getMemberListItem(enumConstantContent));\n+            }\n+            Content enumConstantDetails = getEnumConstantsDetails(\n+                    enumConstantsDetailsHeader, memberList);\n+            target.add(enumConstantDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content target) {\n+        target.add(getSignature(currentElement));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content target) {\n+        addDeprecated(currentElement, target);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content target) {\n+        addPreview(currentElement, target);\n+    }\n+\n+    \/**\n+     * Build the comments for the enum constant.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildEnumConstantComments(Content target) {\n+        if (!options.noComment()) {\n+            addComments(currentElement, target);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content target) {\n+        addTags(currentElement, target);\n+    }\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement,\n+            Content content) {\n+        content.add(MarkerComments.START_OF_ENUM_CONSTANT_SUMMARY);\n+        Content memberContent = new ContentBuilder();\n+        writer.addSummaryHeader(this, memberContent);\n+        return memberContent;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.constantsSummary,\n+                HtmlIds.ENUM_CONSTANT_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getEnumConstantsDetailsHeader(TypeElement typeElement,\n+                                                 Content memberDetails) {\n+        memberDetails.add(MarkerComments.START_OF_ENUM_CONSTANT_DETAILS);\n+        var enumConstantsDetailsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.enumConstantDetailLabel);\n+        enumConstantsDetailsContent.add(heading);\n+        return enumConstantsDetailsContent;\n+    }\n+\n+    protected Content getEnumConstantsHeader(VariableElement enumConstant,\n+                                          Content enumConstantsDetails) {\n+        Content enumConstantsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(enumConstant)));\n+        enumConstantsContent.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, enumConstantsContent)\n+                .setId(htmlIds.forMember(enumConstant));\n+    }\n+\n+    protected Content getSignature(VariableElement enumConstant) {\n+        return new Signatures.MemberSignature(enumConstant, this)\n+                .setType(enumConstant.asType())\n+                .setAnnotations(writer.getAnnotationInfo(enumConstant, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(VariableElement enumConstant, Content content) {\n+        addDeprecatedInfo(enumConstant, content);\n+    }\n+\n+    protected void addPreview(VariableElement enumConstant, Content content) {\n+        addPreviewInfo(enumConstant, content);\n+    }\n+\n+    protected void addComments(VariableElement enumConstant, Content enumConstants) {\n+        addComment(enumConstant, enumConstants);\n+    }\n+\n+    protected void addTags(VariableElement enumConstant, Content content) {\n+        writer.addTagsInfo(enumConstant, content);\n+    }\n+\n+    protected Content getEnumConstantsDetails(Content memberDetailsHeader,\n+            Content content) {\n+        return writer.getDetailsListItem(\n+                HtmlTree.SECTION(HtmlStyle.constantDetails)\n+                        .setId(HtmlIds.ENUM_CONSTANT_DETAIL)\n+                        .add(memberDetailsHeader)\n+                        .add(content));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.enumConstantSummary);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.enumConstantLabel, contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setCaption(contents.getContent(\"doclet.Enum_Constants\"))\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+    }\n+\n+    @Override\n+    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n+                                  Content content) {\n+        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n+                name(member), HtmlStyle.memberNameLink);\n+        var code = HtmlTree.CODE(memberLink);\n+        content.add(code);\n+    }\n+\n+    @Override\n+    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        \/\/Not applicable.\n+    }\n+\n+    @Override\n+    protected Content getSummaryLink(Element member) {\n+        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n+        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n+    }\n+\n+    protected Content getMemberHeader(){\n+        return writer.getMemberHeader();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/EnumConstantWriter.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -1,182 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.EnumConstantWriter;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-\n-\/**\n- * Writes enum constant documentation in HTML format.\n- *\/\n-public class EnumConstantWriterImpl extends AbstractMemberWriter\n-    implements EnumConstantWriter, MemberSummaryWriter {\n-\n-    public EnumConstantWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    public EnumConstantWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content content) {\n-        content.add(MarkerComments.START_OF_ENUM_CONSTANT_SUMMARY);\n-        Content memberContent = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberContent);\n-        return memberContent;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.constantsSummary,\n-                HtmlIds.ENUM_CONSTANT_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getEnumConstantsDetailsHeader(TypeElement typeElement,\n-                                                 Content memberDetails) {\n-        memberDetails.add(MarkerComments.START_OF_ENUM_CONSTANT_DETAILS);\n-        var enumConstantsDetailsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.enumConstantDetailLabel);\n-        enumConstantsDetailsContent.add(heading);\n-        return enumConstantsDetailsContent;\n-    }\n-\n-    @Override\n-    public Content getEnumConstantsHeader(VariableElement enumConstant,\n-                                          Content enumConstantsDetails) {\n-        Content enumConstantsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(enumConstant)));\n-        enumConstantsContent.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, enumConstantsContent)\n-                .setId(htmlIds.forMember(enumConstant));\n-    }\n-\n-    @Override\n-    public Content getSignature(VariableElement enumConstant) {\n-        return new Signatures.MemberSignature(enumConstant, this)\n-                .setType(enumConstant.asType())\n-                .setAnnotations(writer.getAnnotationInfo(enumConstant, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(VariableElement enumConstant, Content content) {\n-        addDeprecatedInfo(enumConstant, content);\n-    }\n-\n-    @Override\n-    public void addPreview(VariableElement enumConstant, Content content) {\n-        addPreviewInfo(enumConstant, content);\n-    }\n-\n-    @Override\n-    public void addComments(VariableElement enumConstant, Content enumConstants) {\n-        addComment(enumConstant, enumConstants);\n-    }\n-\n-    @Override\n-    public void addTags(VariableElement enumConstant, Content content) {\n-        writer.addTagsInfo(enumConstant, content);\n-    }\n-\n-    @Override\n-    public Content getEnumConstantsDetails(Content memberDetailsHeader,\n-            Content content) {\n-        return writer.getDetailsListItem(\n-                HtmlTree.SECTION(HtmlStyle.constantDetails)\n-                        .setId(HtmlIds.ENUM_CONSTANT_DETAIL)\n-                        .add(memberDetailsHeader)\n-                        .add(content));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.enumConstantSummary);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.enumConstantLabel, contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setCaption(contents.getContent(\"doclet.Enum_Constants\"))\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n-    @Override\n-    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n-                                  Content content) {\n-        Content memberLink = writer.getDocLink(context, utils.getEnclosingTypeElement(member), member,\n-                name(member), HtmlStyle.memberNameLink);\n-        var code = HtmlTree.CODE(memberLink);\n-        content.add(code);\n-    }\n-\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        \/\/Not applicable.\n-    }\n-\n-    @Override\n-    protected Content getSummaryLink(Element member) {\n-        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n-        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n-    }\n-\n-    @Override\n-    public Content getMemberHeader(){\n-        return writer.getMemberHeader();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/EnumConstantWriterImpl.java","additions":0,"deletions":182,"binary":false,"changes":182,"status":"deleted"},{"patch":"@@ -56,1 +56,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -250,25 +249,9 @@\n-        return new Comparator<>() {\n-            @Override\n-            public int compare(String s1, String s2) {\n-                int i1 = 0;\n-                int i2 = 0;\n-                while (i1 < s1.length() && i2 < s2.length()) {\n-                    int j1 = find(s1, i1, Character::isDigit);\n-                    int j2 = find(s2, i2, Character::isDigit);\n-                    int cmp = collator.compare(s1.substring(i1, j1), s2.substring(i2, j2));\n-                    if (cmp != 0) {\n-                        return cmp;\n-                    }\n-                    if (j1 == s1.length() || j2 == s2.length()) {\n-                        i1 = j1;\n-                        i2 = j2;\n-                        break;\n-                    }\n-                    int k1 = find(s1, j1, ch -> !Character.isDigit(ch));\n-                    int k2 = find(s2, j2, ch -> !Character.isDigit(ch));\n-                    cmp = Integer.compare(Integer.parseInt(s1.substring(j1, k1)), Integer.parseInt(s2.substring(j2, k2)));\n-                    if (cmp != 0) {\n-                        return cmp;\n-                    }\n-                    i1 = k1;\n-                    i2 = k2;\n+        return (s1, s2) -> {\n+            int i1 = 0;\n+            int i2 = 0;\n+            while (i1 < s1.length() && i2 < s2.length()) {\n+                int j1 = find(s1, i1, Character::isDigit);\n+                int j2 = find(s2, i2, Character::isDigit);\n+                int cmp = collator.compare(s1.substring(i1, j1), s2.substring(i2, j2));\n+                if (cmp != 0) {\n+                    return cmp;\n@@ -276,1 +259,13 @@\n-                return i1 < s1.length() ? 1 : i2 < s2.length() ? -1 : 0;\n+                if (j1 == s1.length() || j2 == s2.length()) {\n+                    i1 = j1;\n+                    i2 = j2;\n+                    break;\n+                }\n+                int k1 = find(s1, j1, ch -> !Character.isDigit(ch));\n+                int k2 = find(s2, j2, ch -> !Character.isDigit(ch));\n+                cmp = Integer.compare(Integer.parseInt(s1.substring(j1, k1)), Integer.parseInt(s2.substring(j2, k2)));\n+                if (cmp != 0) {\n+                    return cmp;\n+                }\n+                i1 = k1;\n+                i2 = k2;\n@@ -278,0 +273,1 @@\n+            return i1 < s1.length() ? 1 : i2 < s2.length() ? -1 : 0;\n@@ -295,2 +291,1 @@\n-        } else if (element instanceof DocletElement) {\n-            DocletElement e = (DocletElement) element;\n+        } else if (element instanceof DocletElement e) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ExternalSpecsWriter.java","additions":24,"deletions":29,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * Writes field documentation in HTML format.\n+ *\/\n+public class FieldWriter extends AbstractMemberWriter {\n+\n+    \/**\n+     * The index of the current field that is being documented at this point\n+     * in time.\n+     *\/\n+    private VariableElement currentElement;\n+\n+    public FieldWriter(ClassWriter writer) {\n+        super(writer, writer.typeElement);\n+    }\n+\n+    public FieldWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n+        super(writer, typeElement);\n+    }\n+\n+    \/\/ used in ClassUseWriter and SummaryUseWriter\n+    public FieldWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+    }\n+\n+    public void build(Content target) throws DocletException {\n+        buildFieldDoc(target);\n+    }\n+\n+    \/**\n+     * Build the field documentation.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldDoc(Content target) {\n+        var fields = getVisibleMembers(VisibleMemberTable.Kind.FIELDS);\n+        if (!fields.isEmpty()) {\n+            Content fieldDetailsHeader = getFieldDetailsHeader(target);\n+            Content memberList = getMemberList();\n+\n+            for (Element element : fields) {\n+                currentElement = (VariableElement)element;\n+                Content fieldContent = getFieldHeaderContent(currentElement);\n+\n+                buildSignature(fieldContent);\n+                buildDeprecationInfo(fieldContent);\n+                buildPreviewInfo(fieldContent);\n+                buildFieldComments(fieldContent);\n+                buildTagInfo(fieldContent);\n+\n+                memberList.add(getMemberListItem(fieldContent));\n+            }\n+            Content fieldDetails = getFieldDetails(fieldDetailsHeader, memberList);\n+            target.add(fieldDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content fieldContent) {\n+        fieldContent.add(getSignature(currentElement));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content fieldContent) {\n+        addDeprecated(currentElement, fieldContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content fieldContent) {\n+        addPreview(currentElement, fieldContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the field.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldComments(Content fieldContent) {\n+        if (!options.noComment()) {\n+            addComments(currentElement, fieldContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param fieldContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content fieldContent) {\n+        addTags(currentElement, fieldContent);\n+    }\n+\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement,\n+            Content content) {\n+        content.add(MarkerComments.START_OF_FIELD_SUMMARY);\n+        Content memberContent = new ContentBuilder();\n+        writer.addSummaryHeader(this, memberContent);\n+        return memberContent;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.fieldSummary,\n+                HtmlIds.FIELD_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getFieldDetailsHeader(Content content) {\n+        content.add(MarkerComments.START_OF_FIELD_DETAILS);\n+        Content fieldDetailsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.fieldDetailsLabel);\n+        fieldDetailsContent.add(heading);\n+        return fieldDetailsContent;\n+    }\n+\n+    protected Content getFieldHeaderContent(VariableElement field) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(field)));\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forMember(field));\n+    }\n+\n+    protected Content getSignature(VariableElement field) {\n+        return new Signatures.MemberSignature(field, this)\n+                .setType(utils.asInstantiatedFieldType(typeElement, field))\n+                .setAnnotations(writer.getAnnotationInfo(field, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(VariableElement field, Content fieldContent) {\n+        addDeprecatedInfo(field, fieldContent);\n+    }\n+\n+    protected void addPreview(VariableElement field, Content content) {\n+        addPreviewInfo(field, content);\n+    }\n+\n+    protected void addComments(VariableElement field, Content fieldContent) {\n+        if (!utils.getFullBody(field).isEmpty()) {\n+            writer.addInlineComment(field, fieldContent);\n+        }\n+    }\n+\n+    protected void addTags(VariableElement field, Content fieldContent) {\n+        writer.addTagsInfo(field, fieldContent);\n+    }\n+\n+    protected Content getFieldDetails(Content memberDetailsHeaderContent, Content memberContent) {\n+        return writer.getDetailsListItem(\n+                HtmlTree.SECTION(HtmlStyle.fieldDetails)\n+                        .setId(HtmlIds.FIELD_DETAIL)\n+                        .add(memberDetailsHeaderContent)\n+                        .add(memberContent));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.fieldSummaryLabel);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.modifierAndTypeLabel, contents.fieldLabel,\n+                contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        List<HtmlStyle> bodyRowStyles = Arrays.asList(HtmlStyle.colFirst, HtmlStyle.colSecond,\n+                HtmlStyle.colLast);\n+\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setCaption(contents.fields)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(bodyRowStyles);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+        Content classLink = writer.getPreQualifiedClassLink(\n+                HtmlLinkInfo.Kind.PLAIN, typeElement);\n+        Content label;\n+        if (options.summarizeOverriddenMethods()) {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Fields_Declared_In_Class\")\n+                    : resources.getText(\"doclet.Fields_Declared_In_Interface\"));\n+        } else {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Fields_Inherited_From_Class\")\n+                    : resources.getText(\"doclet.Fields_Inherited_From_Interface\"));\n+        }\n+        var labelHeading = HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING,\n+                label);\n+        labelHeading.setId(htmlIds.forInheritedFields(typeElement));\n+        labelHeading.add(Entity.NO_BREAK_SPACE);\n+        labelHeading.add(classLink);\n+        content.add(labelHeading);\n+    }\n+\n+    @Override\n+    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n+                                  Content content) {\n+        Content memberLink = writer.getDocLink(context, typeElement , member, name(member),\n+                HtmlStyle.memberNameLink);\n+        var code = HtmlTree.CODE(memberLink);\n+        content.add(code);\n+    }\n+\n+    @Override\n+    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n+        target.add(\n+                writer.getDocLink(HtmlLinkInfo.Kind.PLAIN, typeElement, member, name(member)));\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        addModifiersAndType(member, utils.asInstantiatedFieldType(typeElement, (VariableElement)member), content);\n+    }\n+\n+    @Override\n+    protected Content getSummaryLink(Element member) {\n+        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n+        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n+    }\n+\n+    protected Content getMemberHeader(){\n+        return writer.getMemberHeader();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/FieldWriter.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.FieldWriter;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-\n-\/**\n- * Writes field documentation in HTML format.\n- *\/\n-public class FieldWriterImpl extends AbstractMemberWriter\n-    implements FieldWriter, MemberSummaryWriter {\n-\n-    public FieldWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    public FieldWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement,\n-            Content content) {\n-        content.add(MarkerComments.START_OF_FIELD_SUMMARY);\n-        Content memberContent = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberContent);\n-        return memberContent;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.fieldSummary,\n-                HtmlIds.FIELD_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getFieldDetailsHeader(Content content) {\n-        content.add(MarkerComments.START_OF_FIELD_DETAILS);\n-        Content fieldDetailsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.fieldDetailsLabel);\n-        fieldDetailsContent.add(heading);\n-        return fieldDetailsContent;\n-    }\n-\n-    @Override\n-    public Content getFieldHeaderContent(VariableElement field) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(field)));\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forMember(field));\n-    }\n-\n-    @Override\n-    public Content getSignature(VariableElement field) {\n-        return new Signatures.MemberSignature(field, this)\n-                .setType(utils.asInstantiatedFieldType(typeElement, field))\n-                .setAnnotations(writer.getAnnotationInfo(field, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(VariableElement field, Content fieldContent) {\n-        addDeprecatedInfo(field, fieldContent);\n-    }\n-\n-    @Override\n-    public void addPreview(VariableElement field, Content content) {\n-        addPreviewInfo(field, content);\n-    }\n-\n-    @Override\n-    public void addComments(VariableElement field, Content fieldContent) {\n-        if (!utils.getFullBody(field).isEmpty()) {\n-            writer.addInlineComment(field, fieldContent);\n-        }\n-    }\n-\n-    @Override\n-    public void addTags(VariableElement field, Content fieldContent) {\n-        writer.addTagsInfo(field, fieldContent);\n-    }\n-\n-    @Override\n-    public Content getFieldDetails(Content memberDetailsHeaderContent, Content memberContent) {\n-        return writer.getDetailsListItem(\n-                HtmlTree.SECTION(HtmlStyle.fieldDetails)\n-                        .setId(HtmlIds.FIELD_DETAIL)\n-                        .add(memberDetailsHeaderContent)\n-                        .add(memberContent));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.fieldSummaryLabel);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.modifierAndTypeLabel, contents.fieldLabel,\n-                contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        List<HtmlStyle> bodyRowStyles = Arrays.asList(HtmlStyle.colFirst, HtmlStyle.colSecond,\n-                HtmlStyle.colLast);\n-\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setCaption(contents.fields)\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(bodyRowStyles);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-        Content classLink = writer.getPreQualifiedClassLink(\n-                HtmlLinkInfo.Kind.PLAIN, typeElement);\n-        Content label;\n-        if (options.summarizeOverriddenMethods()) {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Fields_Declared_In_Class\")\n-                    : resources.getText(\"doclet.Fields_Declared_In_Interface\"));\n-        } else {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Fields_Inherited_From_Class\")\n-                    : resources.getText(\"doclet.Fields_Inherited_From_Interface\"));\n-        }\n-        var labelHeading = HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING,\n-                label);\n-        labelHeading.setId(htmlIds.forInheritedFields(typeElement));\n-        labelHeading.add(Entity.NO_BREAK_SPACE);\n-        labelHeading.add(classLink);\n-        content.add(labelHeading);\n-    }\n-\n-    @Override\n-    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n-                                  Content content) {\n-        Content memberLink = writer.getDocLink(context, typeElement , member, name(member),\n-                HtmlStyle.memberNameLink);\n-        var code = HtmlTree.CODE(memberLink);\n-        content.add(code);\n-    }\n-\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n-        target.add(\n-                writer.getDocLink(HtmlLinkInfo.Kind.PLAIN, typeElement, member, name(member)));\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        addModifiersAndType(member, utils.asInstantiatedFieldType(typeElement, (VariableElement)member), content);\n-    }\n-\n-    @Override\n-    protected Content getSummaryLink(Element member) {\n-        String name = utils.getFullyQualifiedName(member) + \".\" + member.getSimpleName();\n-        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member, name);\n-    }\n-\n-    @Override\n-    public Content getMemberHeader(){\n-        return writer.getMemberHeader();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/FieldWriterImpl.java","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HelpWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.HashSet;\n@@ -64,1 +65,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.WriterFactory;\n@@ -186,0 +186,5 @@\n+    \/**\n+     * The set of packages for which we have copied the doc files.\n+     *\/\n+    private Set<PackageElement> containingPackagesSeen;\n+\n@@ -223,0 +228,1 @@\n+        containingPackagesSeen = new HashSet<>();\n@@ -274,0 +280,9 @@\n+    \/**\n+     * {@return the packages for which we have copied the doc files}\n+     *\n+     * @see {@link ClassWriter#copyDocFiles()}\n+     *\/\n+    public Set<PackageElement> getContainingPackagesSeen() {\n+        return containingPackagesSeen;\n+    }\n+\n@@ -368,1 +383,0 @@\n-    @Override\n@@ -370,1 +384,2 @@\n-        return new WriterFactoryImpl(this);\n+        \/\/ TODO: this is called many times: why not create and use a single instance?\n+        return new WriterFactory(this);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;\n@@ -216,1 +214,5 @@\n-        HtmlOptions options = configuration.getOptions();\n+\n+        new ConstantsSummaryWriter(configuration).build();\n+        new SerializedFormWriter(configuration).build();\n+\n+        var options = configuration.getOptions();\n@@ -326,1 +328,1 @@\n-        if (configuration.tagletManager != null) { \/\/ may be null, if no files generated, perhaps because of errros\n+        if (configuration.tagletManager != null) { \/\/ may be null, if no files generated, perhaps because of errors\n@@ -391,1 +393,0 @@\n-        BuilderFactory f = configuration.getBuilderFactory();\n@@ -397,1 +398,1 @@\n-            f.getClassBuilder(te, classTree).build();\n+            new ClassWriter(configuration, te, classTree).build();\n@@ -406,3 +407,1 @@\n-                AbstractBuilder moduleSummaryBuilder =\n-                        configuration.getBuilderFactory().getModuleSummaryBuilder(mdle);\n-                moduleSummaryBuilder.build();\n+                new ModuleWriter(configuration, mdle).build();\n@@ -423,3 +422,1 @@\n-                AbstractBuilder packageSummaryBuilder =\n-                        configuration.getBuilderFactory().getPackageSummaryBuilder(pkg);\n-                packageSummaryBuilder.build();\n+                new PackageWriter(configuration, pkg).build();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import javax.lang.model.type.ArrayType;\n@@ -93,0 +94,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.TextBuilder;\n@@ -95,1 +97,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -202,0 +203,10 @@\n+        this(configuration, path, true);\n+    }\n+    \/**\n+     * Creates an {@code HtmlDocletWriter}.\n+     *\n+     * @param configuration the configuration for this doclet\n+     * @param path the file to be generated.\n+     * @param generating whether to write a \"Geneterating ...\" message to the console\n+     *\/\n+    public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path, boolean generating) {\n@@ -217,0 +228,9 @@\n+        if (generating) {\n+            writeGenerating();\n+        }\n+    }\n+\n+    \/**\n+     * Writes a \"Generating _file_\" message to the console\n+     *\/\n+    protected final void writeGenerating() {\n@@ -218,1 +238,1 @@\n-            DocFile.createFileForOutput(configuration, path).getPath());\n+                DocFile.createFileForOutput(configuration, path).getPath());\n@@ -303,1 +323,1 @@\n-            MethodWriterImpl.addImplementsInfo(this, method, implementedMethods, dl);\n+            MethodWriter.addImplementsInfo(this, method, implementedMethods, dl);\n@@ -306,1 +326,1 @@\n-            MethodWriterImpl.addOverridden(this,\n+            MethodWriter.addOverridden(this,\n@@ -1479,1 +1499,1 @@\n-            if (this instanceof PackageWriterImpl packageWriter) {\n+            if (this instanceof PackageWriter packageWriter) {\n@@ -1481,1 +1501,1 @@\n-            } else if (this instanceof ModuleWriterImpl moduleWriter) {\n+            } else if (this instanceof ModuleWriter moduleWriter) {\n@@ -1514,1 +1534,1 @@\n-        Element currentPageElement = (this instanceof PackageWriterImpl packageWriter)\n+        Element currentPageElement = (this instanceof PackageWriter packageWriter)\n@@ -1853,1 +1873,1 @@\n-            public Content visitType(TypeMirror t, Void p) {\n+            public Content visitType(TypeMirror type, Void p) {\n@@ -1859,4 +1879,0 @@\n-                        String name = utils.isIncluded(t.asElement())\n-                                ? t.asElement().getSimpleName().toString()\n-                                : utils.getFullyQualifiedName(t.asElement());\n-                        linkInfo.label(name + utils.getDimension(t) + \".class\");\n@@ -1866,2 +1882,7 @@\n-                    protected Content defaultAction(TypeMirror e, Void p) {\n-                        return Text.of(t + utils.getDimension(t) + \".class\");\n+                    public Content visitArray(ArrayType t, Void p) {\n+                        \/\/ render declared base component type as link\n+                        return visit(t.getComponentType()).add(\"[]\");\n+                    }\n+                    @Override\n+                    protected Content defaultAction(TypeMirror t, Void p) {\n+                        return new TextBuilder(t.toString());\n@@ -1869,1 +1890,1 @@\n-                }.visit(t);\n+                }.visit(type).add(\".class\");\n@@ -2021,2 +2042,1 @@\n-            DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration\n-                    .getWriterFactory().getDocFilesHandler(element);\n+            DocFilesHandler docFilesHandler = configuration.getWriterFactory().getDocFilesHandler(element);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":37,"deletions":17,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -80,1 +79,1 @@\n-        LINK_TYPE_PARAMS_AND_BOUNDS;\n+        LINK_TYPE_PARAMS_AND_BOUNDS\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkInfo.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.List;\n-import java.util.SortedSet;\n-\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SerialFieldTree;\n-import com.sun.source.doctree.SerialTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-\n-\/**\n- * Generate serialized form for serializable fields.\n- * Documentation denoted by the tags <code>serial<\/code> and\n- * <code>serialField<\/code> is processed.\n- *\/\n-public class HtmlSerialFieldWriter extends FieldWriterImpl\n-        implements SerializedFormWriter.SerialFieldWriter {\n-\n-    public HtmlSerialFieldWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    public SortedSet<VariableElement> members(TypeElement te) {\n-        return utils.serializableFields(te);\n-    }\n-\n-    @Override\n-    public Content getSerializableFieldsHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    @Override\n-    public Content getFieldsContentHeader(boolean isLastContent) {\n-        return new HtmlTree(TagName.LI).setStyle(HtmlStyle.blockList);\n-    }\n-\n-    @Override\n-    public Content getSerializableFields(String heading, Content source) {\n-        var section = HtmlTree.SECTION(HtmlStyle.detail);\n-        if (!source.isEmpty()) {\n-            Content headingContent = Text.of(heading);\n-            var serialHeading = HtmlTree.HEADING(Headings.SerializedForm.CLASS_SUBHEADING, headingContent);\n-            section.add(serialHeading);\n-            section.add(source);\n-        }\n-        return HtmlTree.LI(section);\n-    }\n-\n-    @Override\n-    public void addMemberHeader(TypeMirror fieldType, String fieldName, Content content) {\n-        Content nameContent = Text.of(fieldName);\n-        var heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, nameContent);\n-        content.add(heading);\n-        var pre = new HtmlTree(TagName.PRE);\n-        Content fieldContent = writer.getLink(new HtmlLinkInfo(\n-                configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, fieldType));\n-        pre.add(fieldContent);\n-        pre.add(\" \");\n-        pre.add(fieldName);\n-        content.add(pre);\n-    }\n-\n-    \/**\n-     * Add the deprecated information for this member.\n-     *\n-     * @param field the field to document.\n-     * @param content the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addMemberDeprecatedInfo(VariableElement field, Content content) {\n-        addDeprecatedInfo(field, content);\n-    }\n-\n-    \/**\n-     * Add the description text for this member.\n-     *\n-     * @param field the field to document.\n-     * @param content the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addMemberDescription(VariableElement field, Content content) {\n-        if (!utils.getFullBody(field).isEmpty()) {\n-            writer.addInlineComment(field, content);\n-        }\n-        List<? extends SerialTree> tags = utils.getSerialTrees(field);\n-        if (!tags.isEmpty() && !tags.get(0).getDescription().isEmpty()) {\n-            writer.addInlineComment(field, tags.get(0), content);\n-        }\n-    }\n-\n-    \/**\n-     * Add the description text for this member represented by the tag.\n-     *\n-     * @param serialFieldTag the field to document (represented by tag)\n-     * @param content the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addMemberDescription(VariableElement field, SerialFieldTree serialFieldTag, Content content) {\n-        List<? extends DocTree> description = serialFieldTag.getDescription();\n-        if (!description.isEmpty()) {\n-            Content serialFieldContent = writer.commentTagsToContent(field,\n-                    description,\n-                    new TagletWriter.Context(false, false));\n-            var div = HtmlTree.DIV(HtmlStyle.block, serialFieldContent);\n-            content.add(div);\n-        }\n-    }\n-\n-    \/**\n-     * Add the tag information for this member.\n-     *\n-     * @param field the field to document.\n-     * @param content the content to which the member tags info will be added\n-     *\/\n-    @Override\n-    public void addMemberTags(VariableElement field, Content content) {\n-        Content tagContent = writer.getBlockTagOutput(field);\n-        if (!tagContent.isEmpty()) {\n-            var dl = HtmlTree.DL(HtmlStyle.notes);\n-            dl.add(tagContent);\n-            content.add(dl);\n-        }\n-    }\n-\n-    \/**\n-     * Check to see if overview details should be printed. If\n-     * nocomment option set or if there is no text to be printed\n-     * for deprecation info, comment or tags, do not print overview details.\n-     *\n-     * @param field the field to check overview details for.\n-     * @return true if overview details need to be printed\n-     *\/\n-    @Override\n-    public boolean shouldPrintOverview(VariableElement field) {\n-        if (!options.noComment()) {\n-            if(!utils.getFullBody(field).isEmpty() ||\n-                    writer.hasSerializationOverviewTags(field))\n-                return true;\n-        }\n-        if (utils.isDeprecated(field))\n-            return true;\n-        return false;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialFieldWriter.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n-\n-\n-\/**\n- * Generate serialized form for Serializable\/Externalizable methods.\n- * Documentation denoted by the <code>serialData<\/code> tag is processed.\n- *\/\n-public class HtmlSerialMethodWriter extends MethodWriterImpl implements\n-        SerializedFormWriter.SerialMethodWriter {\n-\n-    public HtmlSerialMethodWriter(SubWriterHolderWriter writer, TypeElement  typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    @Override\n-    public Content getSerializableMethodsHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    @Override\n-    public Content getMethodsContentHeader(boolean isLastContent) {\n-        return new HtmlTree(TagName.LI);\n-    }\n-\n-    \/**\n-     * Add serializable methods.\n-     *\n-     * @param heading the heading for the section\n-     * @param source the content to be added to the serializable methods\n-     *        content\n-     * @return a content for the serializable methods content\n-     *\/\n-    @Override\n-    public Content getSerializableMethods(String heading, Content source) {\n-        Content headingContent = Text.of(heading);\n-        var serialHeading = HtmlTree.HEADING(Headings.SerializedForm.CLASS_SUBHEADING, headingContent);\n-        var section = HtmlTree.SECTION(HtmlStyle.detail, serialHeading);\n-        section.add(source);\n-        return HtmlTree.LI(section);\n-    }\n-\n-    \/**\n-     * Return the no customization message.\n-     *\n-     * @param msg the message to be displayed\n-     * @return no customization message content\n-     *\/\n-    @Override\n-    public Content getNoCustomizationMsg(String msg) {\n-        return Text.of(msg);\n-    }\n-\n-    \/**\n-     * Add the member header.\n-     *\n-     * @param member the method document to be listed\n-     * @param methodsContent the content to which the member header will be added\n-     *\/\n-    @Override\n-    public void addMemberHeader(ExecutableElement member, Content methodsContent) {\n-        Content memberContent = Text.of(name(member));\n-        var heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, memberContent);\n-        methodsContent.add(heading);\n-        methodsContent.add(getSignature(member));\n-    }\n-\n-    \/**\n-     * Add the deprecated information for this member.\n-     *\n-     * @param member the method to document.\n-     * @param methodsContent the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addDeprecatedMemberInfo(ExecutableElement member, Content methodsContent) {\n-        addDeprecatedInfo(member, methodsContent);\n-    }\n-\n-    \/**\n-     * Add the description text for this member.\n-     *\n-     * @param member the method to document.\n-     * @param methodsContent the content to which the deprecated info will be added\n-     *\/\n-    @Override\n-    public void addMemberDescription(ExecutableElement member, Content methodsContent) {\n-        addComment(member, methodsContent);\n-    }\n-\n-    \/**\n-     * Add the tag information for this member.\n-     *\n-     * @param member the method to document.\n-     * @param methodsContent the content to which the member tags info will be added\n-     *\/\n-    @Override\n-    public void addMemberTags(ExecutableElement member, Content methodsContent) {\n-        TagletManager tagletManager = configuration.tagletManager;\n-        Content tagContent = writer.getBlockTagOutput(member, tagletManager.getSerializedFormTaglets());\n-        var dl = HtmlTree.DL(HtmlStyle.notes);\n-        dl.add(tagContent);\n-        methodsContent.add(dl);\n-        if (name(member).equals(\"writeExternal\")\n-                && utils.getSerialDataTrees(member).isEmpty()) {\n-            serialWarning(member, \"doclet.MissingSerialDataTag\",\n-                utils.getFullyQualifiedName(member.getEnclosingElement()), name(member));\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialMethodWriter.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/IndexRedirectWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/IndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,441 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * Writes method documentation in HTML format.\n+ *\/\n+public class MethodWriter extends AbstractExecutableMemberWriter {\n+\n+    \/**\n+     * The index of the current field that is being documented at this point\n+     * in time.\n+     *\/\n+    private ExecutableElement currentMethod;\n+\n+    \/**\n+     * Construct a new MethodWriterImpl.\n+     *\n+     * @param writer the writer for the class that the methods belong to.\\\n+     *\/\n+    public MethodWriter(ClassWriter writer) {\n+        super(writer, writer.typeElement);\n+    }\n+\n+    \/**\n+     * Construct a new MethodWriterImpl.\n+     *\n+     * @param writer the writer for the class that the methods belong to.\n+     * @param typeElement the class\n+     *\/\n+    public MethodWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n+        super(writer, typeElement);\n+    }\n+\n+    \/**\n+     * Construct a new MethodWriterImpl.\n+     *\n+     * @param writer The writer for the class that the methods belong to.\n+     *\/\n+    \/\/ used in ClassUseWriter and SummaryUseWriter\n+    public MethodWriter(SubWriterHolderWriter writer) {\n+        super(writer);\n+    }\n+\n+    public void build(Content target) throws DocletException {\n+        buildMethodDoc(target);\n+    }\n+\n+    \/**\n+     * Build the method documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodDoc(Content detailsList) {\n+        var methods = getVisibleMembers(VisibleMemberTable.Kind.METHODS);\n+        if (!methods.isEmpty()) {\n+            Content methodDetailsHeader = getMethodDetailsHeader(detailsList);\n+            Content memberList = writer.getMemberList();\n+\n+            for (Element method : methods) {\n+                currentMethod = (ExecutableElement)method;\n+                Content methodContent = getMethodHeader(currentMethod);\n+\n+                buildSignature(methodContent);\n+                buildDeprecationInfo(methodContent);\n+                buildPreviewInfo(methodContent);\n+                buildMethodComments(methodContent);\n+                buildTagInfo(methodContent);\n+\n+                memberList.add(writer.getMemberListItem(methodContent));\n+            }\n+            Content methodDetails = getMethodDetails(methodDetailsHeader, memberList);\n+            detailsList.add(methodDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content methodContent) {\n+        methodContent.add(getSignature(currentMethod));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content methodContent) {\n+        addDeprecated(currentMethod, methodContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content methodContent) {\n+        addPreview(currentMethod, methodContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the method.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodComments(Content methodContent) {\n+        if (!options.noComment()) {\n+            assert utils.isMethod(currentMethod); \/\/ not all executables are methods\n+            var docFinder = utils.docFinder();\n+            Optional<ExecutableElement> r = docFinder.search(currentMethod,\n+                    m -> DocFinder.Result.fromOptional(utils.getFullBody(m).isEmpty() ? Optional.empty() : Optional.of(m))).toOptional();\n+            ExecutableElement method = r.orElse(currentMethod);\n+            TypeMirror containingType = method.getEnclosingElement().asType();\n+            addComments(containingType, method, methodContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param methodContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content methodContent) {\n+        addTags(currentMethod, methodContent);\n+    }\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement, Content target) {\n+        target.add(MarkerComments.START_OF_METHOD_SUMMARY);\n+        Content memberContent = new ContentBuilder();\n+        writer.addSummaryHeader(this, memberContent);\n+        return memberContent;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.methodSummary,\n+                HtmlIds.METHOD_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getMethodDetailsHeader(Content content) {\n+        content.add(MarkerComments.START_OF_METHOD_DETAILS);\n+        Content methodDetailsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.methodDetailLabel);\n+        methodDetailsContent.add(heading);\n+        return methodDetailsContent;\n+    }\n+\n+    protected Content getMethodHeader(ExecutableElement method) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(name(method)));\n+        HtmlId erasureAnchor;\n+        if ((erasureAnchor = htmlIds.forErasure(method)) != null) {\n+            heading.setId(erasureAnchor);\n+        }\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forMember(method));\n+    }\n+\n+    protected Content getSignature(ExecutableElement method) {\n+        return new Signatures.MemberSignature(method, this)\n+                .setTypeParameters(getTypeParameters(method))\n+                .setReturnType(getReturnType(method))\n+                .setParameters(getParameters(method, true))\n+                .setExceptions(getExceptions(method))\n+                .setAnnotations(writer.getAnnotationInfo(method, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(ExecutableElement method, Content methodContent) {\n+        addDeprecatedInfo(method, methodContent);\n+    }\n+\n+    protected void addPreview(ExecutableElement method, Content content) {\n+        addPreviewInfo(method, content);\n+    }\n+\n+    protected void addComments(TypeMirror holderType, ExecutableElement method, Content methodContent) {\n+        TypeElement holder = utils.asTypeElement(holderType);\n+        if (!utils.getFullBody(method).isEmpty()) {\n+            if (holder.equals(typeElement) ||\n+                    !(utils.isPublic(holder) ||\n+                    utils.isLinkable(holder))) {\n+                writer.addInlineComment(method, methodContent);\n+            } else {\n+                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(method)) {\n+                    Content link =\n+                            writer.getDocLink(HtmlLinkInfo.Kind.PLAIN,\n+                                    holder, method,\n+                                    utils.isIncluded(holder)\n+                                            ? utils.getSimpleName(holder)\n+                                            : utils.getFullyQualifiedName(holder));\n+                    var codeLink = HtmlTree.CODE(link);\n+                    var descriptionFromTypeLabel = HtmlTree.SPAN(HtmlStyle.descriptionFromTypeLabel,\n+                            utils.isClass(holder)\n+                                    ? contents.descriptionFromClassLabel\n+                                    : contents.descriptionFromInterfaceLabel);\n+                    descriptionFromTypeLabel.add(Entity.NO_BREAK_SPACE);\n+                    descriptionFromTypeLabel.add(codeLink);\n+                    methodContent.add(HtmlTree.DIV(HtmlStyle.block, descriptionFromTypeLabel));\n+                }\n+                writer.addInlineComment(method, methodContent);\n+            }\n+        }\n+    }\n+\n+    protected void addTags(ExecutableElement method, Content methodContent) {\n+        writer.addTagsInfo(method, methodContent);\n+    }\n+\n+    protected Content getMethodDetails(Content methodDetailsHeader, Content methodDetails) {\n+        Content c = new ContentBuilder(methodDetailsHeader, methodDetails);\n+        return getMember(HtmlTree.SECTION(HtmlStyle.methodDetails, c)\n+                .setId(HtmlIds.METHOD_DETAIL));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.methodSummary);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.modifierAndTypeLabel, contents.methodLabel,\n+                contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast)\n+                .setId(HtmlIds.METHOD_SUMMARY_TABLE)\n+                .setDefaultTab(contents.getContent(\"doclet.All_Methods\"))\n+                .addTab(contents.getContent(\"doclet.Static_Methods\"), utils::isStatic)\n+                .addTab(contents.getContent(\"doclet.Instance_Methods\"), e -> !utils.isStatic(e))\n+                .addTab(contents.getContent(\"doclet.Abstract_Methods\"), utils::isAbstract)\n+                .addTab(contents.getContent(\"doclet.Concrete_Methods\"),\n+                        e -> !utils.isAbstract(e) && !utils.isPlainInterface(e.getEnclosingElement()))\n+                .addTab(contents.getContent(\"doclet.Default_Methods\"), utils::isDefault)\n+                .addTab(contents.getContent(\"doclet.Deprecated_Methods\"),\n+                        e -> utils.isDeprecated(e) || utils.isDeprecated(typeElement));\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+        Content classLink = writer.getPreQualifiedClassLink(\n+                HtmlLinkInfo.Kind.PLAIN, typeElement);\n+        Content label;\n+        if (options.summarizeOverriddenMethods()) {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Methods_Declared_In_Class\")\n+                    : resources.getText(\"doclet.Methods_Declared_In_Interface\"));\n+        } else {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Methods_Inherited_From_Class\")\n+                    : resources.getText(\"doclet.Methods_Inherited_From_Interface\"));\n+        }\n+        var labelHeading = HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING,\n+                label);\n+        labelHeading.setId(htmlIds.forInheritedMethods(typeElement));\n+        labelHeading.add(Entity.NO_BREAK_SPACE);\n+        labelHeading.add(classLink);\n+        content.add(labelHeading);\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        ExecutableElement meth = (ExecutableElement)member;\n+        addModifiersAndType(meth, utils.getReturnType(typeElement, meth), content);\n+    }\n+\n+    \/**\n+     * Adds \"overrides\" or \"specified by\" information about a method (if appropriate)\n+     * into a definition list.\n+     *\n+     * @param writer         the writer for the element\n+     * @param overriddenType the superclass\n+     * @param method         the method\n+     * @param dl             the list in which to add the information.\n+     *\/\n+    protected static void addOverridden(HtmlDocletWriter writer,\n+                                        TypeMirror overriddenType,\n+                                        ExecutableElement method,\n+                                        Content dl) {\n+        if (writer.options.noComment()) {\n+            return;\n+        }\n+        Utils utils = writer.utils;\n+        TypeElement holder = utils.getEnclosingTypeElement(method);\n+        if (!(utils.isPublic(holder) || utils.isLinkable(holder))) {\n+            \/\/This is an implementation detail that should not be documented.\n+            return;\n+        }\n+        if (utils.isIncluded(holder) && !utils.isIncluded(method)) {\n+            \/\/The class is included but the method is not.  That means that it\n+            \/\/is not visible so don't document this.\n+            return;\n+        }\n+        if (utils.hasHiddenTag(holder) || utils.hasHiddenTag(method)) {\n+            return;\n+        }\n+\n+        Contents contents = writer.contents;\n+        Content label;\n+        HtmlLinkInfo.Kind context;\n+        \/\/ Abstract method is implemented from abstract class, not overridden\n+        label = utils.isAbstract(holder) && utils.isAbstract(method) ? contents.specifiedByLabel : contents.overridesLabel;\n+        context = HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS;\n+        dl.add(HtmlTree.DT(label));\n+        Content overriddenTypeLink =\n+                writer.getLink(new HtmlLinkInfo(writer.configuration, context, overriddenType));\n+        var codeOverriddenTypeLink = HtmlTree.CODE(overriddenTypeLink);\n+        Content methlink = writer.getLink(\n+                new HtmlLinkInfo(writer.configuration, HtmlLinkInfo.Kind.PLAIN, holder)\n+                        .fragment(writer.htmlIds.forMember(method).name())\n+                        .label(method.getSimpleName()));\n+        var codeMethLink = HtmlTree.CODE(methlink);\n+        var dd = HtmlTree.DD(codeMethLink);\n+        dd.add(Entity.NO_BREAK_SPACE);\n+        dd.add(contents.inClass);\n+        dd.add(Entity.NO_BREAK_SPACE);\n+        dd.add(codeOverriddenTypeLink);\n+        dl.add(dd);\n+    }\n+\n+    \/**\n+     * Adds \"implements\" information for a method (if appropriate)\n+     * into a definition list.\n+     *\n+     * @param writer  the writer for the method\n+     * @param method  the method\n+     * @param methods implemented methods\n+     * @param dl      the definition list\n+     *\/\n+    protected static void addImplementsInfo(HtmlDocletWriter writer,\n+                                            ExecutableElement method,\n+                                            Collection<ExecutableElement> methods,\n+                                            Content dl) {\n+        Utils utils = writer.utils;\n+        if (writer.options.noComment()) {\n+            return;\n+        }\n+        Contents contents = writer.contents;\n+        var enclosing = (TypeElement) method.getEnclosingElement();\n+        VisibleMemberTable vmt = writer.configuration.getVisibleMemberTable(enclosing);\n+        SortedSet<ExecutableElement> implementedMethods =\n+                new TreeSet<>(utils.comparators.makeOverrideUseComparator());\n+        implementedMethods.addAll(methods);\n+        for (ExecutableElement implementedMeth : implementedMethods) {\n+            TypeMirror intfac = vmt.getImplementedMethodHolder(method, implementedMeth);\n+            intfac = utils.getDeclaredType(enclosing, intfac);\n+            Content intfaclink = writer.getLink(new HtmlLinkInfo(\n+                    writer.configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, intfac));\n+            var codeIntfacLink = HtmlTree.CODE(intfaclink);\n+            dl.add(HtmlTree.DT(contents.specifiedByLabel));\n+            Content methlink = writer.getDocLink(\n+                    HtmlLinkInfo.Kind.PLAIN, implementedMeth,\n+                    implementedMeth.getSimpleName());\n+            var codeMethLink = HtmlTree.CODE(methlink);\n+            var dd = HtmlTree.DD(codeMethLink);\n+            dd.add(Entity.NO_BREAK_SPACE);\n+            dd.add(contents.inInterface);\n+            dd.add(Entity.NO_BREAK_SPACE);\n+            dd.add(codeIntfacLink);\n+            dl.add(dd);\n+        }\n+    }\n+\n+    \/**\n+     * Get the return type for the given method.\n+     *\n+     * @param method the method being documented.\n+     * @return the return type\n+     *\/\n+    protected Content getReturnType(ExecutableElement method) {\n+        TypeMirror type = utils.getReturnType(typeElement, method);\n+        if (type != null) {\n+            return writer.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS, type));\n+        }\n+        return new ContentBuilder();\n+    }\n+\n+    protected Content getMemberHeader(){\n+        return writer.getMemberHeader();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriter.java","additions":441,"deletions":0,"binary":false,"changes":441,"status":"added"},{"patch":"@@ -1,354 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Collection;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.MethodWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-\/**\n- * Writes method documentation in HTML format.\n- *\/\n-public class MethodWriterImpl extends AbstractExecutableMemberWriter\n-        implements MethodWriter, MemberSummaryWriter {\n-\n-    \/**\n-     * Construct a new MethodWriterImpl.\n-     *\n-     * @param writer the writer for the class that the methods belong to.\n-     * @param typeElement the class being documented.\n-     *\/\n-    public MethodWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    \/**\n-     * Construct a new MethodWriterImpl.\n-     *\n-     * @param writer The writer for the class that the methods belong to.\n-     *\/\n-    public MethodWriterImpl(SubWriterHolderWriter writer) {\n-        super(writer);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement, Content target) {\n-        target.add(MarkerComments.START_OF_METHOD_SUMMARY);\n-        Content memberContent = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberContent);\n-        return memberContent;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.methodSummary,\n-                HtmlIds.METHOD_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getMethodDetailsHeader(Content content) {\n-        content.add(MarkerComments.START_OF_METHOD_DETAILS);\n-        Content methodDetailsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.methodDetailLabel);\n-        methodDetailsContent.add(heading);\n-        return methodDetailsContent;\n-    }\n-\n-    @Override\n-    public Content getMethodHeader(ExecutableElement method) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(name(method)));\n-        HtmlId erasureAnchor;\n-        if ((erasureAnchor = htmlIds.forErasure(method)) != null) {\n-            heading.setId(erasureAnchor);\n-        }\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forMember(method));\n-    }\n-\n-    @Override\n-    public Content getSignature(ExecutableElement method) {\n-        return new Signatures.MemberSignature(method, this)\n-                .setTypeParameters(getTypeParameters(method))\n-                .setReturnType(getReturnType(method))\n-                .setParameters(getParameters(method, true))\n-                .setExceptions(getExceptions(method))\n-                .setAnnotations(writer.getAnnotationInfo(method, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(ExecutableElement method, Content methodContent) {\n-        addDeprecatedInfo(method, methodContent);\n-    }\n-\n-    @Override\n-    public void addPreview(ExecutableElement method, Content content) {\n-        addPreviewInfo(method, content);\n-    }\n-\n-    @Override\n-    public void addComments(TypeMirror holderType, ExecutableElement method, Content methodContent) {\n-        TypeElement holder = utils.asTypeElement(holderType);\n-        if (!utils.getFullBody(method).isEmpty()) {\n-            if (holder.equals(typeElement) ||\n-                    !(utils.isPublic(holder) ||\n-                    utils.isLinkable(holder))) {\n-                writer.addInlineComment(method, methodContent);\n-            } else {\n-                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(method)) {\n-                    Content link =\n-                            writer.getDocLink(HtmlLinkInfo.Kind.PLAIN,\n-                                    holder, method,\n-                                    utils.isIncluded(holder)\n-                                            ? utils.getSimpleName(holder)\n-                                            : utils.getFullyQualifiedName(holder));\n-                    var codeLink = HtmlTree.CODE(link);\n-                    var descriptionFromTypeLabel = HtmlTree.SPAN(HtmlStyle.descriptionFromTypeLabel,\n-                            utils.isClass(holder)\n-                                    ? contents.descriptionFromClassLabel\n-                                    : contents.descriptionFromInterfaceLabel);\n-                    descriptionFromTypeLabel.add(Entity.NO_BREAK_SPACE);\n-                    descriptionFromTypeLabel.add(codeLink);\n-                    methodContent.add(HtmlTree.DIV(HtmlStyle.block, descriptionFromTypeLabel));\n-                }\n-                writer.addInlineComment(method, methodContent);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addTags(ExecutableElement method, Content methodContent) {\n-        writer.addTagsInfo(method, methodContent);\n-    }\n-\n-    @Override\n-    public Content getMethodDetails(Content methodDetailsHeader, Content methodDetails) {\n-        Content c = new ContentBuilder(methodDetailsHeader, methodDetails);\n-        return getMember(HtmlTree.SECTION(HtmlStyle.methodDetails, c)\n-                .setId(HtmlIds.METHOD_DETAIL));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.methodSummary);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.modifierAndTypeLabel, contents.methodLabel,\n-                contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast)\n-                .setId(HtmlIds.METHOD_SUMMARY_TABLE)\n-                .setDefaultTab(contents.getContent(\"doclet.All_Methods\"))\n-                .addTab(contents.getContent(\"doclet.Static_Methods\"), utils::isStatic)\n-                .addTab(contents.getContent(\"doclet.Instance_Methods\"), e -> !utils.isStatic(e))\n-                .addTab(contents.getContent(\"doclet.Abstract_Methods\"), utils::isAbstract)\n-                .addTab(contents.getContent(\"doclet.Concrete_Methods\"),\n-                        e -> !utils.isAbstract(e) && !utils.isPlainInterface(e.getEnclosingElement()))\n-                .addTab(contents.getContent(\"doclet.Default_Methods\"), utils::isDefault)\n-                .addTab(contents.getContent(\"doclet.Deprecated_Methods\"),\n-                        e -> utils.isDeprecated(e) || utils.isDeprecated(typeElement));\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-        Content classLink = writer.getPreQualifiedClassLink(\n-                HtmlLinkInfo.Kind.PLAIN, typeElement);\n-        Content label;\n-        if (options.summarizeOverriddenMethods()) {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Methods_Declared_In_Class\")\n-                    : resources.getText(\"doclet.Methods_Declared_In_Interface\"));\n-        } else {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Methods_Inherited_From_Class\")\n-                    : resources.getText(\"doclet.Methods_Inherited_From_Interface\"));\n-        }\n-        var labelHeading = HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING,\n-                label);\n-        labelHeading.setId(htmlIds.forInheritedMethods(typeElement));\n-        labelHeading.add(Entity.NO_BREAK_SPACE);\n-        labelHeading.add(classLink);\n-        content.add(labelHeading);\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        ExecutableElement meth = (ExecutableElement)member;\n-        addModifiersAndType(meth, utils.getReturnType(typeElement, meth), content);\n-    }\n-\n-    \/**\n-     * Adds \"overrides\" or \"specified by\" information about a method (if appropriate)\n-     * into a definition list.\n-     *\n-     * @param writer         the writer for the element\n-     * @param overriddenType the superclass\n-     * @param method         the method\n-     * @param dl             the list in which to add the information.\n-     *\/\n-    protected static void addOverridden(HtmlDocletWriter writer,\n-                                        TypeMirror overriddenType,\n-                                        ExecutableElement method,\n-                                        Content dl) {\n-        if (writer.options.noComment()) {\n-            return;\n-        }\n-        Utils utils = writer.utils;\n-        TypeElement holder = utils.getEnclosingTypeElement(method);\n-        if (!(utils.isPublic(holder) || utils.isLinkable(holder))) {\n-            \/\/This is an implementation detail that should not be documented.\n-            return;\n-        }\n-        if (utils.isIncluded(holder) && !utils.isIncluded(method)) {\n-            \/\/The class is included but the method is not.  That means that it\n-            \/\/is not visible so don't document this.\n-            return;\n-        }\n-        if (utils.hasHiddenTag(holder) || utils.hasHiddenTag(method)) {\n-            return;\n-        }\n-\n-        Contents contents = writer.contents;\n-        Content label;\n-        HtmlLinkInfo.Kind context;\n-        if (utils.isAbstract(holder) && utils.isAbstract(method)) {\n-            \/\/Abstract method is implemented from abstract class,\n-            \/\/not overridden\n-            label = contents.specifiedByLabel;\n-            context = HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS;\n-        } else {\n-            label = contents.overridesLabel;\n-            context = HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS;\n-        }\n-        dl.add(HtmlTree.DT(label));\n-        Content overriddenTypeLink =\n-                writer.getLink(new HtmlLinkInfo(writer.configuration, context, overriddenType));\n-        var codeOverriddenTypeLink = HtmlTree.CODE(overriddenTypeLink);\n-        Content methlink = writer.getLink(\n-                new HtmlLinkInfo(writer.configuration, HtmlLinkInfo.Kind.PLAIN, holder)\n-                        .fragment(writer.htmlIds.forMember(method).name())\n-                        .label(method.getSimpleName()));\n-        var codeMethLink = HtmlTree.CODE(methlink);\n-        var dd = HtmlTree.DD(codeMethLink);\n-        dd.add(Entity.NO_BREAK_SPACE);\n-        dd.add(contents.inClass);\n-        dd.add(Entity.NO_BREAK_SPACE);\n-        dd.add(codeOverriddenTypeLink);\n-        dl.add(dd);\n-    }\n-\n-    \/**\n-     * Adds \"implements\" information for a method (if appropriate)\n-     * into a definition list.\n-     *\n-     * @param writer  the writer for the method\n-     * @param method  the method\n-     * @param methods implemented methods\n-     * @param dl      the definition list\n-     *\/\n-    protected static void addImplementsInfo(HtmlDocletWriter writer,\n-                                            ExecutableElement method,\n-                                            Collection<ExecutableElement> methods,\n-                                            Content dl) {\n-        Utils utils = writer.utils;\n-        if (writer.options.noComment()) {\n-            return;\n-        }\n-        Contents contents = writer.contents;\n-        var enclosing = (TypeElement) method.getEnclosingElement();\n-        VisibleMemberTable vmt = writer.configuration.getVisibleMemberTable(enclosing);\n-        SortedSet<ExecutableElement> implementedMethods =\n-                new TreeSet<>(utils.comparators.makeOverrideUseComparator());\n-        implementedMethods.addAll(methods);\n-        for (ExecutableElement implementedMeth : implementedMethods) {\n-            TypeMirror intfac = vmt.getImplementedMethodHolder(method, implementedMeth);\n-            intfac = utils.getDeclaredType(enclosing, intfac);\n-            Content intfaclink = writer.getLink(new HtmlLinkInfo(\n-                    writer.configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, intfac));\n-            var codeIntfacLink = HtmlTree.CODE(intfaclink);\n-            dl.add(HtmlTree.DT(contents.specifiedByLabel));\n-            Content methlink = writer.getDocLink(\n-                    HtmlLinkInfo.Kind.PLAIN, implementedMeth,\n-                    implementedMeth.getSimpleName());\n-            var codeMethLink = HtmlTree.CODE(methlink);\n-            var dd = HtmlTree.DD(codeMethLink);\n-            dd.add(Entity.NO_BREAK_SPACE);\n-            dd.add(contents.inInterface);\n-            dd.add(Entity.NO_BREAK_SPACE);\n-            dd.add(codeIntfacLink);\n-            dl.add(dd);\n-        }\n-    }\n-\n-    \/**\n-     * Get the return type for the given method.\n-     *\n-     * @param method the method being documented.\n-     * @return the return type\n-     *\/\n-    protected Content getReturnType(ExecutableElement method) {\n-        TypeMirror type = utils.getReturnType(typeElement, method);\n-        if (type != null) {\n-            return writer.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS, type));\n-        }\n-        return new ContentBuilder();\n-    }\n-\n-    @Override\n-    public Content getMemberHeader(){\n-        return writer.getMemberHeader();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java","additions":0,"deletions":354,"binary":false,"changes":354,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleIndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n@@ -63,1 +62,1 @@\n-public class ModuleWriterImpl extends HtmlDocletWriter implements ModuleSummaryWriter {\n+public class ModuleWriter extends HtmlDocletWriter {\n@@ -94,1 +93,1 @@\n-    class PackageEntry {\n+    static class PackageEntry {\n@@ -162,1 +161,1 @@\n-    public ModuleWriterImpl(HtmlConfiguration configuration, ModuleElement mdle) {\n+    public ModuleWriter(HtmlConfiguration configuration, ModuleElement mdle) {\n@@ -169,2 +168,94 @@\n-    @Override\n-    public Content getModuleHeader(String heading) {\n+    \/**\n+     * Build the module summary.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    public void build() throws DocletException {\n+        buildModuleDoc();\n+    }\n+\n+    \/**\n+     * Build the module documentation.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildModuleDoc() throws DocletException {\n+        Content content = getModuleHeader(mdle.getQualifiedName().toString());\n+\n+        buildContent();\n+\n+        addModuleFooter();\n+        printDocument(content);\n+        var docFilesHandler = configuration.getWriterFactory().getDocFilesHandler(mdle);\n+        docFilesHandler.copyDocFiles();\n+    }\n+\n+    \/**\n+     * Build the content for the module doc.\n+     *\/\n+    protected void buildContent() {\n+        Content moduleContent = getContentHeader();\n+\n+        addModuleSignature(moduleContent);\n+        buildModuleDescription(moduleContent);\n+        buildSummary(moduleContent);\n+\n+        addModuleContent(moduleContent);\n+    }\n+\n+    \/**\n+     * Builds the list of summary sections for this module.\n+     *\n+     * @param target the module content to which the summaries will\n+     *               be added\n+     *\/\n+    protected void buildSummary(Content target) {\n+        Content summariesList = getSummariesList();\n+\n+        buildPackagesSummary(summariesList);\n+        buildModulesSummary(summariesList);\n+        buildServicesSummary(summariesList);\n+\n+        target.add(getSummary(summariesList));\n+    }\n+\n+    \/**\n+     * Builds the summary of the module dependencies of this module.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildModulesSummary(Content summariesList) {\n+        addModulesSummary(summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary of the packages exported or opened by this module.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildPackagesSummary(Content summariesList) {\n+        addPackagesSummary(summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary of the services used or provided by this module.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildServicesSummary(Content summariesList) {\n+        addServicesSummary(summariesList);\n+    }\n+\n+    \/**\n+     * Builds the description for this module.\n+     *\n+     * @param moduleContent the content to which the module description will\n+     *                      be added\n+     *\/\n+    protected void buildModuleDescription(Content moduleContent) {\n+        if (!options.noComment()) {\n+            addModuleDescription(moduleContent);\n+        }\n+    }\n+\n+    protected Content getModuleHeader(String heading) {\n@@ -200,2 +291,1 @@\n-    @Override\n-    public Content getContentHeader() {\n+    protected Content getContentHeader() {\n@@ -205,2 +295,1 @@\n-    @Override\n-    public Content getSummariesList() {\n+    protected Content getSummariesList() {\n@@ -210,2 +299,1 @@\n-    @Override\n-    public Content getSummary(Content source) {\n+    protected Content getSummary(Content source) {\n@@ -451,2 +539,1 @@\n-    @Override\n-    public void addModulesSummary(Content summariesList) {\n+    protected void addModulesSummary(Content summariesList) {\n@@ -495,2 +582,1 @@\n-    @Override\n-    public void addPackagesSummary(Content summariesList) {\n+    protected void addPackagesSummary(Content summariesList) {\n@@ -662,2 +748,1 @@\n-    @Override\n-    public void addServicesSummary(Content summariesList) {\n+    protected void addServicesSummary(Content summariesList) {\n@@ -789,2 +874,1 @@\n-    @Override\n-    public void addModuleDescription(Content moduleContent) {\n+    protected void addModuleDescription(Content moduleContent) {\n@@ -803,2 +887,1 @@\n-    @Override\n-    public void addModuleSignature(Content moduleContent) {\n+    protected void addModuleSignature(Content moduleContent) {\n@@ -809,2 +892,1 @@\n-    @Override\n-    public void addModuleContent(Content source) {\n+    protected void addModuleContent(Content source) {\n@@ -814,2 +896,1 @@\n-    @Override\n-    public void addModuleFooter() {\n+    protected void addModuleFooter() {\n@@ -819,2 +900,1 @@\n-    @Override\n-    public void printDocument(Content content) throws DocFileIOException {\n+    protected void printDocument(Content content) throws DocFileIOException {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleWriter.java","additions":109,"deletions":29,"binary":false,"changes":138,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleWriterImpl.java","status":"renamed"},{"patch":"@@ -45,1 +45,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -52,2 +51,0 @@\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n@@ -101,1 +98,1 @@\n-        USE;\n+        USE\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n@@ -45,2 +43,1 @@\n-public class NestedClassWriterImpl extends AbstractMemberWriter\n-    implements MemberSummaryWriter {\n+public class NestedClassWriter extends AbstractMemberWriter {\n@@ -48,1 +45,1 @@\n-    public NestedClassWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n+    public NestedClassWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n@@ -52,1 +49,1 @@\n-    public NestedClassWriterImpl(SubWriterHolderWriter writer) {\n+    public NestedClassWriter(SubWriterHolderWriter writer) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NestedClassWriter.java","additions":3,"deletions":6,"binary":false,"changes":9,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NestedClassWriterImpl.java","status":"renamed"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NewAPIListWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageIndexWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageTreeWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageUseWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,465 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.SortedSet;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+\n+\/**\n+ * Class to generate file for each package contents in the right-hand\n+ * frame. This will list all the Class Kinds in the package. A click on any\n+ * class-kind will update the frame with the clicked class-kind page.\n+ *\/\n+public class PackageWriter extends HtmlDocletWriter {\n+\n+    \/**\n+     * The package being documented.\n+     *\/\n+    protected PackageElement packageElement;\n+\n+    private List<PackageElement> relatedPackages;\n+    private SortedSet<TypeElement> allClasses;\n+\n+    \/**\n+     * The HTML element for the section tag being written.\n+     *\/\n+    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription, new ContentBuilder());\n+\n+    private final BodyContents bodyContents = new BodyContents();\n+\n+    \/\/ Maximum number of subpackages and sibling packages to list in related packages table\n+    private static final int MAX_SUBPACKAGES = 20;\n+    private static final int MAX_SIBLING_PACKAGES = 5;\n+\n+\n+    \/**\n+     * Constructor to construct PackageWriter object and to generate\n+     * \"package-summary.html\" file in the respective package directory.\n+     * For example for package \"java.lang\" this will generate file\n+     * \"package-summary.html\" file in the \"java\/lang\" directory. It will also\n+     * create \"java\/lang\" directory in the current or the destination directory\n+     * if it doesn't exist.\n+     *\n+     * @param configuration the configuration of the doclet.\n+     * @param packageElement    PackageElement under consideration.\n+     *\/\n+    public PackageWriter(HtmlConfiguration configuration, PackageElement packageElement) {\n+        super(configuration,\n+                configuration.docPaths.forPackage(packageElement)\n+                .resolve(DocPaths.PACKAGE_SUMMARY));\n+        this.packageElement = packageElement;\n+        computePackageData();\n+    }\n+\n+    \/**\n+     * Build the package summary.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    public void build() throws DocletException {\n+        buildPackageDoc();\n+    }\n+\n+    \/**\n+     * Build the package documentation.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildPackageDoc() throws DocletException {\n+        Content content = getPackageHeader();\n+\n+        buildContent();\n+\n+        addPackageFooter();\n+        printDocument(content);\n+        var docFilesHandler = configuration\n+                .getWriterFactory()\n+                .getDocFilesHandler(packageElement);\n+        docFilesHandler.copyDocFiles();\n+    }\n+\n+    \/**\n+     * Build the content for the package.\n+     *\/\n+    protected void buildContent() {\n+        Content packageContent = getContentHeader();\n+\n+        addPackageSignature(packageContent);\n+        buildPackageDescription(packageContent);\n+        buildPackageTags(packageContent);\n+        buildSummary(packageContent);\n+\n+        addPackageContent(packageContent);\n+    }\n+\n+    \/**\n+     * Builds the list of summaries for the different kinds of types in this package.\n+     *\n+     * @param packageContent the package content to which the summaries will\n+     *                       be added\n+     *\/\n+    protected void buildSummary(Content packageContent) {\n+        Content summariesList = getSummariesList();\n+\n+        buildRelatedPackagesSummary(summariesList);\n+        buildAllClassesAndInterfacesSummary(summariesList);\n+\n+        packageContent.add(getPackageSummary(summariesList));\n+    }\n+\n+    \/**\n+     * Builds a list of \"nearby\" packages (subpackages, superpackages, and sibling packages).\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildRelatedPackagesSummary(Content summariesList) {\n+        addRelatedPackagesSummary(summariesList);\n+    }\n+\n+    \/**\n+     * Builds the summary for all classes and interfaces in this package.\n+     *\n+     * @param summariesList the list of summaries to which the summary will be added\n+     *\/\n+    protected void buildAllClassesAndInterfacesSummary(Content summariesList) {\n+        addAllClassesAndInterfacesSummary(summariesList);\n+    }\n+\n+\n+    \/**\n+     * Build the description of the summary.\n+     *\n+     * @param packageContent the content to which the package description will\n+     *                       be added\n+     *\/\n+    protected void buildPackageDescription(Content packageContent) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+        addPackageDescription(packageContent);\n+    }\n+\n+    \/**\n+     * Build the tags of the summary.\n+     *\n+     * @param packageContent the content to which the package tags will be added\n+     *\/\n+    protected void buildPackageTags(Content packageContent) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+        addPackageTags(packageContent);\n+    }\n+\n+    protected Content getPackageHeader() {\n+        String packageName = getLocalizedPackageName(packageElement).toString();\n+        HtmlTree body = getBody(getWindowTitle(packageName));\n+        var div = HtmlTree.DIV(HtmlStyle.header);\n+        if (configuration.showModules) {\n+            ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(packageElement);\n+            var classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInPackage, contents.moduleLabel);\n+            var moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);\n+            moduleNameDiv.add(Entity.NO_BREAK_SPACE);\n+            moduleNameDiv.add(getModuleLink(mdle,\n+                    Text.of(mdle.getQualifiedName().toString())));\n+            div.add(moduleNameDiv);\n+        }\n+        Content packageHead = new ContentBuilder();\n+        if (!packageElement.isUnnamed()) {\n+            packageHead.add(contents.packageLabel).add(\" \");\n+        }\n+        packageHead.add(packageName);\n+        var tHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n+                HtmlStyle.title, packageHead);\n+        div.add(tHeading);\n+        bodyContents.setHeader(getHeader(PageMode.PACKAGE, packageElement))\n+                .addMainContent(div);\n+        return body;\n+    }\n+\n+    protected Content getContentHeader() {\n+        return new ContentBuilder();\n+    }\n+\n+    private void computePackageData() {\n+        relatedPackages = findRelatedPackages();\n+        boolean isSpecified = utils.isSpecified(packageElement);\n+        allClasses = filterClasses(isSpecified\n+                ? utils.getAllClasses(packageElement)\n+                : configuration.typeElementCatalog.allClasses(packageElement));\n+    }\n+\n+    private SortedSet<TypeElement> filterClasses(SortedSet<TypeElement> types) {\n+        List<TypeElement> typeList = types\n+                .stream()\n+                .filter(te -> utils.isCoreClass(te) && configuration.isGeneratedDoc(te))\n+                .collect(Collectors.toList());\n+        return utils.filterOutPrivateClasses(typeList, options.javafx());\n+    }\n+\n+    private List<PackageElement> findRelatedPackages() {\n+        String pkgName = packageElement.getQualifiedName().toString();\n+\n+        \/\/ always add superpackage\n+        int lastdot = pkgName.lastIndexOf('.');\n+        String pkgPrefix = lastdot > 0 ? pkgName.substring(0, lastdot) : null;\n+        List<PackageElement> packages = new ArrayList<>(\n+                filterPackages(p -> p.getQualifiedName().toString().equals(pkgPrefix)));\n+        boolean hasSuperPackage = !packages.isEmpty();\n+\n+        \/\/ add subpackages unless there are very many of them\n+        Pattern subPattern = Pattern.compile(pkgName.replace(\".\", \"\\\\.\") + \"\\\\.\\\\w+\");\n+        List<PackageElement> subpackages = filterPackages(\n+                p -> subPattern.matcher(p.getQualifiedName().toString()).matches());\n+        if (subpackages.size() <= MAX_SUBPACKAGES) {\n+            packages.addAll(subpackages);\n+        }\n+\n+        \/\/ only add sibling packages if there is a non-empty superpackage, we are beneath threshold,\n+        \/\/ and number of siblings is beneath threshold as well\n+        if (hasSuperPackage && pkgPrefix != null && packages.size() <= MAX_SIBLING_PACKAGES) {\n+            Pattern siblingPattern = Pattern.compile(pkgPrefix.replace(\".\", \"\\\\.\") + \"\\\\.\\\\w+\");\n+\n+            List<PackageElement> siblings = filterPackages(\n+                    p -> siblingPattern.matcher(p.getQualifiedName().toString()).matches());\n+            if (siblings.size() <= MAX_SIBLING_PACKAGES) {\n+                packages.addAll(siblings);\n+            }\n+        }\n+        return packages;\n+    }\n+\n+    @Override\n+    protected Navigation getNavBar(PageMode pageMode, Element element) {\n+        Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(packageElement),\n+                contents.moduleLabel);\n+        return super.getNavBar(pageMode, element)\n+                .setNavLinkModule(linkContent)\n+                .setSubNavLinks(() -> List.of(\n+                        links.createLink(HtmlIds.PACKAGE_DESCRIPTION, contents.navDescription,\n+                                !utils.getFullBody(packageElement).isEmpty() && !options.noComment()),\n+                        links.createLink(HtmlIds.RELATED_PACKAGE_SUMMARY, contents.relatedPackages,\n+                                relatedPackages != null && !relatedPackages.isEmpty()),\n+                        links.createLink(HtmlIds.CLASS_SUMMARY, contents.navClassesAndInterfaces,\n+                                allClasses != null && !allClasses.isEmpty())));\n+    }\n+\n+    \/**\n+     * Add the package deprecation information to the documentation tree.\n+     *\n+     * @param div the content to which the deprecation information will be added\n+     *\/\n+    public void addDeprecationInfo(Content div) {\n+        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(packageElement);\n+        if (utils.isDeprecated(packageElement)) {\n+            CommentHelper ch = utils.getCommentHelper(packageElement);\n+            var deprDiv = HtmlTree.DIV(HtmlStyle.deprecationBlock);\n+            var deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(packageElement));\n+            deprDiv.add(deprPhrase);\n+            if (!deprs.isEmpty()) {\n+                List<? extends DocTree> commentTags = ch.getDescription(deprs.get(0));\n+                if (!commentTags.isEmpty()) {\n+                    addInlineDeprecatedComment(packageElement, deprs.get(0), deprDiv);\n+                }\n+            }\n+            div.add(deprDiv);\n+        }\n+    }\n+\n+    protected Content getSummariesList() {\n+        return HtmlTree.UL(HtmlStyle.summaryList);\n+    }\n+\n+    protected void addRelatedPackagesSummary(Content summaryContent) {\n+        boolean showModules = configuration.showModules && hasRelatedPackagesInOtherModules(relatedPackages);\n+        TableHeader tableHeader= showModules\n+                ? new TableHeader(contents.moduleLabel, contents.packageLabel, contents.descriptionLabel)\n+                : new TableHeader(contents.packageLabel, contents.descriptionLabel);\n+        addPackageSummary(relatedPackages, contents.relatedPackages, tableHeader,\n+                summaryContent, showModules);\n+    }\n+\n+\n+    \/**\n+     * Add all types to the content.\n+     *\n+     * @param target the content to which the links will be added\n+     *\/\n+    public void addAllClassesAndInterfacesSummary(Content target) {\n+        var table = new Table<TypeElement>(HtmlStyle.summaryTable)\n+                .setHeader(new TableHeader(contents.classLabel, contents.descriptionLabel))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast)\n+                .setId(HtmlIds.CLASS_SUMMARY)\n+                .setDefaultTab(contents.allClassesAndInterfacesLabel)\n+                .addTab(contents.interfaces, utils::isPlainInterface)\n+                .addTab(contents.classes, utils::isNonThrowableClass)\n+                .addTab(contents.enums, utils::isEnum)\n+                .addTab(contents.records, utils::isRecord)\n+                .addTab(contents.exceptionClasses, utils::isThrowable)\n+                .addTab(contents.annotationTypes, utils::isAnnotationInterface);\n+        for (TypeElement typeElement : allClasses) {\n+            if (typeElement != null && utils.isCoreClass(typeElement)) {\n+                Content classLink = getLink(new HtmlLinkInfo(\n+                        configuration, HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement));\n+                ContentBuilder description = new ContentBuilder();\n+                addPreviewSummary(typeElement, description);\n+                if (utils.isDeprecated(typeElement)) {\n+                    description.add(getDeprecatedPhrase(typeElement));\n+                    List<? extends DeprecatedTree> tags = utils.getDeprecatedTrees(typeElement);\n+                    if (!tags.isEmpty()) {\n+                        addSummaryDeprecatedComment(typeElement, tags.get(0), description);\n+                    }\n+                } else {\n+                    addSummaryComment(typeElement, description);\n+                }\n+                table.addRow(typeElement, Arrays.asList(classLink, description));\n+            }\n+        }\n+        if (!table.isEmpty()) {\n+            target.add(HtmlTree.LI(table));\n+        }\n+    }\n+\n+    public void addPackageSummary(List<PackageElement> packages, Content label,\n+                                  TableHeader tableHeader, Content summaryContent,\n+                                  boolean showModules) {\n+        if (!packages.isEmpty()) {\n+            var table = new Table<Void>(HtmlStyle.summaryTable)\n+                    .setId(HtmlIds.RELATED_PACKAGE_SUMMARY)\n+                    .setCaption(label)\n+                    .setHeader(tableHeader);\n+            if (showModules) {\n+                table.setColumnStyles(HtmlStyle.colPlain, HtmlStyle.colFirst, HtmlStyle.colLast);\n+            } else {\n+                table.setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);\n+            }\n+\n+            for (PackageElement pkg : packages) {\n+                Content packageLink = getPackageLink(pkg, Text.of(pkg.getQualifiedName()));\n+                Content moduleLink = Text.EMPTY;\n+                if (showModules) {\n+                    ModuleElement module = (ModuleElement) pkg.getEnclosingElement();\n+                    if (module != null && !module.isUnnamed()) {\n+                        moduleLink = getModuleLink(module, Text.of(module.getQualifiedName()));\n+                    }\n+                }\n+                ContentBuilder description = new ContentBuilder();\n+                addPreviewSummary(pkg, description);\n+                if (utils.isDeprecated(pkg)) {\n+                    description.add(getDeprecatedPhrase(pkg));\n+                    List<? extends DeprecatedTree> tags = utils.getDeprecatedTrees(pkg);\n+                    if (!tags.isEmpty()) {\n+                        addSummaryDeprecatedComment(pkg, tags.get(0), description);\n+                    }\n+                } else {\n+                    addSummaryComment(pkg, description);\n+                }\n+                if (showModules) {\n+                    table.addRow(moduleLink, packageLink, description);\n+                } else {\n+                    table.addRow(packageLink, description);\n+                }\n+            }\n+            summaryContent.add(HtmlTree.LI(table));\n+        }\n+    }\n+\n+    protected void addPackageDescription(Content packageContent) {\n+        addPreviewInfo(packageElement, packageContent);\n+        if (!utils.getBody(packageElement).isEmpty()) {\n+            section.setId(HtmlIds.PACKAGE_DESCRIPTION);\n+            addDeprecationInfo(section);\n+            addInlineComment(packageElement, section);\n+        }\n+    }\n+\n+    protected void addPackageTags(Content packageContent) {\n+        addTagsInfo(packageElement, section);\n+        packageContent.add(section);\n+    }\n+\n+    protected void addPackageSignature(Content packageContent) {\n+        packageContent.add(new HtmlTree(TagName.HR));\n+        packageContent.add(Signatures.getPackageSignature(packageElement, this));\n+    }\n+\n+    protected void addPackageContent(Content packageContent) {\n+        bodyContents.addMainContent(packageContent);\n+    }\n+\n+    protected void addPackageFooter() {\n+        bodyContents.setFooter(getFooter());\n+    }\n+\n+    protected void printDocument(Content content) throws DocFileIOException {\n+        String description = getDescription(\"declaration\", packageElement);\n+        List<DocPath> localStylesheets = getLocalStylesheets(packageElement);\n+        content.add(bodyContents);\n+        printHtmlDocument(configuration.metakeywords.getMetaKeywords(packageElement),\n+                description, localStylesheets, content);\n+    }\n+\n+    protected Content getPackageSummary(Content summaryContent) {\n+        return HtmlTree.SECTION(HtmlStyle.summary, summaryContent);\n+    }\n+\n+    private boolean hasRelatedPackagesInOtherModules(List<PackageElement> relatedPackages) {\n+        final ModuleElement module = (ModuleElement) packageElement.getEnclosingElement();\n+        return relatedPackages.stream().anyMatch(pkg -> module != pkg.getEnclosingElement());\n+    }\n+\n+    private List<PackageElement> filterPackages(Predicate<? super PackageElement> filter) {\n+        return configuration.packages.stream()\n+                .filter(p -> p != packageElement && filter.test(p))\n+                .collect(Collectors.toList());\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageWriter.java","additions":465,"deletions":0,"binary":false,"changes":465,"status":"added"},{"patch":"@@ -1,378 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.SortedSet;\n-import java.util.function.Predicate;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DeprecatedTree;\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-\n-\/**\n- * Class to generate file for each package contents in the right-hand\n- * frame. This will list all the Class Kinds in the package. A click on any\n- * class-kind will update the frame with the clicked class-kind page.\n- *\/\n-public class PackageWriterImpl extends HtmlDocletWriter\n-    implements PackageSummaryWriter {\n-\n-    \/**\n-     * The package being documented.\n-     *\/\n-    protected PackageElement packageElement;\n-\n-    private List<PackageElement> relatedPackages;\n-    private SortedSet<TypeElement> allClasses;\n-\n-    \/**\n-     * The HTML element for the section tag being written.\n-     *\/\n-    private final HtmlTree section = HtmlTree.SECTION(HtmlStyle.packageDescription, new ContentBuilder());\n-\n-    private final BodyContents bodyContents = new BodyContents();\n-\n-    \/\/ Maximum number of subpackages and sibling packages to list in related packages table\n-    private static final int MAX_SUBPACKAGES = 20;\n-    private static final int MAX_SIBLING_PACKAGES = 5;\n-\n-\n-    \/**\n-     * Constructor to construct PackageWriter object and to generate\n-     * \"package-summary.html\" file in the respective package directory.\n-     * For example for package \"java.lang\" this will generate file\n-     * \"package-summary.html\" file in the \"java\/lang\" directory. It will also\n-     * create \"java\/lang\" directory in the current or the destination directory\n-     * if it doesn't exist.\n-     *\n-     * @param configuration the configuration of the doclet.\n-     * @param packageElement    PackageElement under consideration.\n-     *\/\n-    public PackageWriterImpl(HtmlConfiguration configuration, PackageElement packageElement) {\n-        super(configuration,\n-                configuration.docPaths.forPackage(packageElement)\n-                .resolve(DocPaths.PACKAGE_SUMMARY));\n-        this.packageElement = packageElement;\n-        computePackageData();\n-    }\n-\n-    @Override\n-    public Content getPackageHeader() {\n-        String packageName = getLocalizedPackageName(packageElement).toString();\n-        HtmlTree body = getBody(getWindowTitle(packageName));\n-        var div = HtmlTree.DIV(HtmlStyle.header);\n-        if (configuration.showModules) {\n-            ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(packageElement);\n-            var classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInPackage, contents.moduleLabel);\n-            var moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);\n-            moduleNameDiv.add(Entity.NO_BREAK_SPACE);\n-            moduleNameDiv.add(getModuleLink(mdle,\n-                    Text.of(mdle.getQualifiedName().toString())));\n-            div.add(moduleNameDiv);\n-        }\n-        Content packageHead = new ContentBuilder();\n-        if (!packageElement.isUnnamed()) {\n-            packageHead.add(contents.packageLabel).add(\" \");\n-        }\n-        packageHead.add(packageName);\n-        var tHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n-                HtmlStyle.title, packageHead);\n-        div.add(tHeading);\n-        bodyContents.setHeader(getHeader(PageMode.PACKAGE, packageElement))\n-                .addMainContent(div);\n-        return body;\n-    }\n-\n-    @Override\n-    public Content getContentHeader() {\n-        return new ContentBuilder();\n-    }\n-\n-    private void computePackageData() {\n-        relatedPackages = findRelatedPackages();\n-        boolean isSpecified = utils.isSpecified(packageElement);\n-        allClasses = filterClasses(isSpecified\n-                ? utils.getAllClasses(packageElement)\n-                : configuration.typeElementCatalog.allClasses(packageElement));\n-    }\n-\n-    private SortedSet<TypeElement> filterClasses(SortedSet<TypeElement> types) {\n-        List<TypeElement> typeList = types\n-                .stream()\n-                .filter(te -> utils.isCoreClass(te) && configuration.isGeneratedDoc(te))\n-                .collect(Collectors.toList());\n-        return utils.filterOutPrivateClasses(typeList, options.javafx());\n-    }\n-\n-    private List<PackageElement> findRelatedPackages() {\n-        String pkgName = packageElement.getQualifiedName().toString();\n-\n-        \/\/ always add superpackage\n-        int lastdot = pkgName.lastIndexOf('.');\n-        String pkgPrefix = lastdot > 0 ? pkgName.substring(0, lastdot) : null;\n-        List<PackageElement> packages = new ArrayList<>(\n-                filterPackages(p -> p.getQualifiedName().toString().equals(pkgPrefix)));\n-        boolean hasSuperPackage = !packages.isEmpty();\n-\n-        \/\/ add subpackages unless there are very many of them\n-        Pattern subPattern = Pattern.compile(pkgName.replace(\".\", \"\\\\.\") + \"\\\\.\\\\w+\");\n-        List<PackageElement> subpackages = filterPackages(\n-                p -> subPattern.matcher(p.getQualifiedName().toString()).matches());\n-        if (subpackages.size() <= MAX_SUBPACKAGES) {\n-            packages.addAll(subpackages);\n-        }\n-\n-        \/\/ only add sibling packages if there is a non-empty superpackage, we are beneath threshold,\n-        \/\/ and number of siblings is beneath threshold as well\n-        if (hasSuperPackage && pkgPrefix != null && packages.size() <= MAX_SIBLING_PACKAGES) {\n-            Pattern siblingPattern = Pattern.compile(pkgPrefix.replace(\".\", \"\\\\.\") + \"\\\\.\\\\w+\");\n-\n-            List<PackageElement> siblings = filterPackages(\n-                    p -> siblingPattern.matcher(p.getQualifiedName().toString()).matches());\n-            if (siblings.size() <= MAX_SIBLING_PACKAGES) {\n-                packages.addAll(siblings);\n-            }\n-        }\n-        return packages;\n-    }\n-\n-    @Override\n-    protected Navigation getNavBar(PageMode pageMode, Element element) {\n-        Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(packageElement),\n-                contents.moduleLabel);\n-        return super.getNavBar(pageMode, element)\n-                .setNavLinkModule(linkContent)\n-                .setSubNavLinks(() -> List.of(\n-                        links.createLink(HtmlIds.PACKAGE_DESCRIPTION, contents.navDescription,\n-                                !utils.getFullBody(packageElement).isEmpty() && !options.noComment()),\n-                        links.createLink(HtmlIds.RELATED_PACKAGE_SUMMARY, contents.relatedPackages,\n-                                relatedPackages != null && !relatedPackages.isEmpty()),\n-                        links.createLink(HtmlIds.CLASS_SUMMARY, contents.navClassesAndInterfaces,\n-                                allClasses != null && !allClasses.isEmpty())));\n-    }\n-\n-    \/**\n-     * Add the package deprecation information to the documentation tree.\n-     *\n-     * @param div the content to which the deprecation information will be added\n-     *\/\n-    public void addDeprecationInfo(Content div) {\n-        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(packageElement);\n-        if (utils.isDeprecated(packageElement)) {\n-            CommentHelper ch = utils.getCommentHelper(packageElement);\n-            var deprDiv = HtmlTree.DIV(HtmlStyle.deprecationBlock);\n-            var deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(packageElement));\n-            deprDiv.add(deprPhrase);\n-            if (!deprs.isEmpty()) {\n-                List<? extends DocTree> commentTags = ch.getDescription(deprs.get(0));\n-                if (!commentTags.isEmpty()) {\n-                    addInlineDeprecatedComment(packageElement, deprs.get(0), deprDiv);\n-                }\n-            }\n-            div.add(deprDiv);\n-        }\n-    }\n-\n-    @Override\n-    public Content getSummariesList() {\n-        return HtmlTree.UL(HtmlStyle.summaryList);\n-    }\n-\n-    @Override\n-    public void addRelatedPackagesSummary(Content summaryContent) {\n-        boolean showModules = configuration.showModules && hasRelatedPackagesInOtherModules(relatedPackages);\n-        TableHeader tableHeader= showModules\n-                ? new TableHeader(contents.moduleLabel, contents.packageLabel, contents.descriptionLabel)\n-                : new TableHeader(contents.packageLabel, contents.descriptionLabel);\n-        addPackageSummary(relatedPackages, contents.relatedPackages, tableHeader,\n-                summaryContent, showModules);\n-    }\n-\n-\n-    \/**\n-     * Add all types to the content.\n-     *\n-     * @param target the content to which the links will be added\n-     *\/\n-    public void addAllClassesAndInterfacesSummary(Content target) {\n-        var table = new Table<TypeElement>(HtmlStyle.summaryTable)\n-                .setHeader(new TableHeader(contents.classLabel, contents.descriptionLabel))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast)\n-                .setId(HtmlIds.CLASS_SUMMARY)\n-                .setDefaultTab(contents.allClassesAndInterfacesLabel)\n-                .addTab(contents.interfaces, utils::isPlainInterface)\n-                .addTab(contents.classes, e -> utils.isNonThrowableClass(e))\n-                .addTab(contents.enums, utils::isEnum)\n-                .addTab(contents.records, e -> utils.isRecord(e))\n-                .addTab(contents.exceptionClasses, e -> utils.isThrowable(e))\n-                .addTab(contents.annotationTypes, utils::isAnnotationInterface);\n-        for (TypeElement typeElement : allClasses) {\n-            if (typeElement != null && utils.isCoreClass(typeElement)) {\n-                Content classLink = getLink(new HtmlLinkInfo(\n-                        configuration, HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement));\n-                ContentBuilder description = new ContentBuilder();\n-                addPreviewSummary(typeElement, description);\n-                if (utils.isDeprecated(typeElement)) {\n-                    description.add(getDeprecatedPhrase(typeElement));\n-                    List<? extends DeprecatedTree> tags = utils.getDeprecatedTrees(typeElement);\n-                    if (!tags.isEmpty()) {\n-                        addSummaryDeprecatedComment(typeElement, tags.get(0), description);\n-                    }\n-                } else {\n-                    addSummaryComment(typeElement, description);\n-                }\n-                table.addRow(typeElement, Arrays.asList(classLink, description));\n-            }\n-        }\n-        if (!table.isEmpty()) {\n-            target.add(HtmlTree.LI(table));\n-        }\n-    }\n-\n-    public void addPackageSummary(List<PackageElement> packages, Content label,\n-                                  TableHeader tableHeader, Content summaryContent,\n-                                  boolean showModules) {\n-        if (!packages.isEmpty()) {\n-            var table = new Table<Void>(HtmlStyle.summaryTable)\n-                    .setId(HtmlIds.RELATED_PACKAGE_SUMMARY)\n-                    .setCaption(label)\n-                    .setHeader(tableHeader);\n-            if (showModules) {\n-                table.setColumnStyles(HtmlStyle.colPlain, HtmlStyle.colFirst, HtmlStyle.colLast);\n-            } else {\n-                table.setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);\n-            }\n-\n-            for (PackageElement pkg : packages) {\n-                Content packageLink = getPackageLink(pkg, Text.of(pkg.getQualifiedName()));\n-                Content moduleLink = Text.EMPTY;\n-                if (showModules) {\n-                    ModuleElement module = (ModuleElement) pkg.getEnclosingElement();\n-                    if (module != null && !module.isUnnamed()) {\n-                        moduleLink = getModuleLink(module, Text.of(module.getQualifiedName()));\n-                    }\n-                }\n-                ContentBuilder description = new ContentBuilder();\n-                addPreviewSummary(pkg, description);\n-                if (utils.isDeprecated(pkg)) {\n-                    description.add(getDeprecatedPhrase(pkg));\n-                    List<? extends DeprecatedTree> tags = utils.getDeprecatedTrees(pkg);\n-                    if (!tags.isEmpty()) {\n-                        addSummaryDeprecatedComment(pkg, tags.get(0), description);\n-                    }\n-                } else {\n-                    addSummaryComment(pkg, description);\n-                }\n-                if (showModules) {\n-                    table.addRow(moduleLink, packageLink, description);\n-                } else {\n-                    table.addRow(packageLink, description);\n-                }\n-            }\n-            summaryContent.add(HtmlTree.LI(table));\n-        }\n-    }\n-\n-    @Override\n-    public void addPackageDescription(Content packageContent) {\n-        addPreviewInfo(packageElement, packageContent);\n-        if (!utils.getBody(packageElement).isEmpty()) {\n-            section.setId(HtmlIds.PACKAGE_DESCRIPTION);\n-            addDeprecationInfo(section);\n-            addInlineComment(packageElement, section);\n-        }\n-    }\n-\n-    @Override\n-    public void addPackageTags(Content packageContent) {\n-        addTagsInfo(packageElement, section);\n-        packageContent.add(section);\n-    }\n-\n-    @Override\n-    public void addPackageSignature(Content packageContent) {\n-        packageContent.add(new HtmlTree(TagName.HR));\n-        packageContent.add(Signatures.getPackageSignature(packageElement, this));\n-    }\n-\n-    @Override\n-    public void addPackageContent(Content packageContent) {\n-        bodyContents.addMainContent(packageContent);\n-    }\n-\n-    @Override\n-    public void addPackageFooter() {\n-        bodyContents.setFooter(getFooter());\n-    }\n-\n-    @Override\n-    public void printDocument(Content content) throws DocFileIOException {\n-        String description = getDescription(\"declaration\", packageElement);\n-        List<DocPath> localStylesheets = getLocalStylesheets(packageElement);\n-        content.add(bodyContents);\n-        printHtmlDocument(configuration.metakeywords.getMetaKeywords(packageElement),\n-                description, localStylesheets, content);\n-    }\n-\n-    @Override\n-    public Content getPackageSummary(Content summaryContent) {\n-        return HtmlTree.SECTION(HtmlStyle.summary, summaryContent);\n-    }\n-\n-    private boolean hasRelatedPackagesInOtherModules(List<PackageElement> relatedPackages) {\n-        final ModuleElement module = (ModuleElement) packageElement.getEnclosingElement();\n-        return relatedPackages.stream().anyMatch(pkg -> module != pkg.getEnclosingElement());\n-    }\n-\n-    private List<PackageElement> filterPackages(Predicate<? super PackageElement> filter) {\n-        return configuration.packages.stream()\n-                .filter(p -> p != packageElement && filter.test(p))\n-                .collect(Collectors.toList());\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageWriterImpl.java","additions":0,"deletions":378,"binary":false,"changes":378,"status":"deleted"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PreviewListWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.ArrayList;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n+import jdk.javadoc.internal.doclets.toolkit.CommentUtils;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * Writes property documentation in HTML format.\n+ *\/\n+public class PropertyWriter extends AbstractMemberWriter {\n+\n+    \/**\n+     * The index of the current property that is being documented at this point\n+     * in time.\n+     *\/\n+    private ExecutableElement currentProperty;\n+\n+    public PropertyWriter(ClassWriter writer) {\n+        super(writer, writer.typeElement);\n+    }\n+\n+    public void build(Content target) {\n+        buildPropertyDoc(target);\n+    }\n+\n+    \/**\n+     * Build the property documentation.\n+     *\n+     * @param detailsList the content to which the documentation will be added\n+     *\/\n+    protected void buildPropertyDoc(Content detailsList) {\n+        var properties  = getVisibleMembers(VisibleMemberTable.Kind.PROPERTIES);\n+        if (!properties.isEmpty()) {\n+            Content propertyDetailsHeader = getPropertyDetailsHeader(detailsList);\n+            Content memberList = getMemberList();\n+\n+            for (Element property : properties) {\n+                currentProperty = (ExecutableElement)property;\n+                Content propertyContent = getPropertyHeaderContent(currentProperty);\n+\n+                buildSignature(propertyContent);\n+                buildPropertyComments(propertyContent);\n+                buildTagInfo(propertyContent);\n+\n+                memberList.add(getMemberListItem(propertyContent));\n+            }\n+            Content propertyDetails = getPropertyDetails(propertyDetailsHeader, memberList);\n+            detailsList.add(propertyDetails);\n+        }\n+    }\n+\n+    \/**\n+     * Build the signature.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildSignature(Content propertyContent) {\n+        propertyContent.add(getSignature(currentProperty));\n+    }\n+\n+    \/**\n+     * Build the deprecation information.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecationInfo(Content propertyContent) {\n+        addDeprecated(currentProperty, propertyContent);\n+    }\n+\n+    \/**\n+     * Build the preview information.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPreviewInfo(Content propertyContent) {\n+        addPreview(currentProperty, propertyContent);\n+    }\n+\n+    \/**\n+     * Build the comments for the property.  Do nothing if\n+     * {@link BaseOptions#noComment()} is set to true.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildPropertyComments(Content propertyContent) {\n+        if (!options.noComment()) {\n+            addComments(currentProperty, propertyContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the tag information.\n+     *\n+     * @param propertyContent the content to which the documentation will be added\n+     *\/\n+    protected void buildTagInfo(Content propertyContent) {\n+        CommentUtils cmtUtils = configuration.cmtUtils;\n+        DocCommentTree dct = utils.getDocCommentTree(currentProperty);\n+        var fullBody = dct.getFullBody();\n+        ArrayList<DocTree> blockTags = dct.getBlockTags().stream()\n+                .filter(t -> t.getKind() != DocTree.Kind.RETURN)\n+                .collect(Collectors.toCollection(ArrayList::new));\n+        String sig = \"#\" + currentProperty.getSimpleName() + \"()\";\n+        blockTags.add(cmtUtils.makeSeeTree(sig, currentProperty));\n+        \/\/ The property method is used as a proxy for the property\n+        \/\/ (which does not have an explicit element of its own.)\n+        \/\/ Temporarily override the doc comment for the property method\n+        \/\/ by removing the `@return` tag, which should not be displayed for\n+        \/\/ the property.\n+        CommentUtils.DocCommentInfo prev = cmtUtils.setDocCommentTree(currentProperty, fullBody, blockTags);\n+        try {\n+            addTags(currentProperty, propertyContent);\n+        } finally {\n+            cmtUtils.setDocCommentInfo(currentProperty, prev);\n+        }\n+    }\n+\n+\n+    @Override\n+    public Content getMemberSummaryHeader(TypeElement typeElement, Content content) {\n+        content.add(MarkerComments.START_OF_PROPERTY_SUMMARY);\n+        Content memberContent = new ContentBuilder();\n+        writer.addSummaryHeader(this, memberContent);\n+        return memberContent;\n+    }\n+\n+    @Override\n+    public void addSummary(Content summariesList, Content content) {\n+        writer.addSummary(HtmlStyle.propertySummary,\n+                HtmlIds.PROPERTY_SUMMARY, summariesList, content);\n+    }\n+\n+    protected Content getPropertyDetailsHeader(Content memberDetails) {\n+        memberDetails.add(MarkerComments.START_OF_PROPERTY_DETAILS);\n+        Content propertyDetailsContent = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n+                contents.propertyDetailsLabel);\n+        propertyDetailsContent.add(heading);\n+        return propertyDetailsContent;\n+    }\n+\n+    protected Content getPropertyHeaderContent(ExecutableElement property) {\n+        Content content = new ContentBuilder();\n+        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n+                Text.of(utils.getPropertyLabel(name(property))));\n+        content.add(heading);\n+        return HtmlTree.SECTION(HtmlStyle.detail, content)\n+                .setId(htmlIds.forProperty(property));\n+    }\n+\n+    protected Content getSignature(ExecutableElement property) {\n+        return new Signatures.MemberSignature(property, this)\n+                .setType(utils.getReturnType(typeElement, property))\n+                .setAnnotations(writer.getAnnotationInfo(property, true))\n+                .toContent();\n+    }\n+\n+    protected void addDeprecated(ExecutableElement property, Content propertyContent) {\n+    }\n+\n+    protected void addPreview(ExecutableElement property, Content content) {\n+    }\n+\n+    protected void addComments(ExecutableElement property, Content propertyContent) {\n+        TypeElement holder = (TypeElement)property.getEnclosingElement();\n+        if (!utils.getFullBody(property).isEmpty()) {\n+            if (holder.equals(typeElement) ||\n+                    (!utils.isPublic(holder) || utils.isLinkable(holder))) {\n+                writer.addInlineComment(property, propertyContent);\n+            } else {\n+                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(property)) {\n+                    Content link =\n+                            writer.getDocLink(HtmlLinkInfo.Kind.PLAIN,\n+                                    holder, property,\n+                                    utils.isIncluded(holder)\n+                                            ? holder.getSimpleName() : holder.getQualifiedName());\n+                    var codeLink = HtmlTree.CODE(link);\n+                    var descriptionFromLabel = HtmlTree.SPAN(HtmlStyle.descriptionFromTypeLabel,\n+                            utils.isClass(holder)\n+                                    ? contents.descriptionFromClassLabel\n+                                    : contents.descriptionFromInterfaceLabel);\n+                    descriptionFromLabel.add(Entity.NO_BREAK_SPACE);\n+                    descriptionFromLabel.add(codeLink);\n+                    propertyContent.add(HtmlTree.DIV(HtmlStyle.block, descriptionFromLabel));\n+                }\n+                writer.addInlineComment(property, propertyContent);\n+            }\n+        }\n+    }\n+\n+    protected void addTags(ExecutableElement property, Content propertyContent) {\n+        writer.addTagsInfo(property, propertyContent);\n+    }\n+\n+    protected Content getPropertyDetails(Content memberDetailsHeader, Content memberDetails) {\n+        return writer.getDetailsListItem(\n+                HtmlTree.SECTION(HtmlStyle.propertyDetails)\n+                        .setId(HtmlIds.PROPERTY_DETAIL)\n+                        .add(memberDetailsHeader)\n+                        .add(memberDetails));\n+    }\n+\n+    @Override\n+    public void addSummaryLabel(Content content) {\n+        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n+                contents.propertySummaryLabel);\n+        content.add(label);\n+    }\n+\n+    @Override\n+    public TableHeader getSummaryTableHeader(Element member) {\n+        return new TableHeader(contents.typeLabel, contents.propertyLabel,\n+                contents.descriptionLabel);\n+    }\n+\n+    @Override\n+    protected Table<Element> createSummaryTable() {\n+        return new Table<Element>(HtmlStyle.summaryTable)\n+                .setCaption(contents.properties)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n+    }\n+\n+    @Override\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+        Content classLink = writer.getPreQualifiedClassLink(\n+                HtmlLinkInfo.Kind.PLAIN, typeElement);\n+        Content label;\n+        if (options.summarizeOverriddenMethods()) {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Properties_Declared_In_Class\")\n+                    : resources.getText(\"doclet.Properties_Declared_In_Interface\"));\n+        } else {\n+            label = Text.of(utils.isClass(typeElement)\n+                    ? resources.getText(\"doclet.Properties_Inherited_From_Class\")\n+                    : resources.getText(\"doclet.Properties_Inherited_From_Interface\"));\n+        }\n+        var labelHeading =\n+                HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING, label)\n+                        .setId(htmlIds.forInheritedProperties(typeElement))\n+                        .add(Entity.NO_BREAK_SPACE)\n+                        .add(classLink);\n+        content.add(labelHeading);\n+    }\n+\n+    @Override\n+    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n+                                  Content content) {\n+        Content memberLink = writer.getDocLink(context, typeElement,\n+                member,\n+                Text.of(utils.getPropertyLabel(name(member))),\n+                HtmlStyle.memberNameLink,\n+                true);\n+\n+        var code = HtmlTree.CODE(memberLink);\n+        content.add(code);\n+    }\n+\n+    @Override\n+    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n+        String mname = name(member);\n+        Content content = writer.getDocLink(HtmlLinkInfo.Kind.PLAIN, typeElement, member,\n+                utils.isProperty(mname) ? utils.getPropertyName(mname) : mname, true);\n+        target.add(content);\n+    }\n+\n+    @Override\n+    protected void addSummaryType(Element member, Content content) {\n+        addModifiersAndType(member, utils.getReturnType(typeElement, (ExecutableElement)member), content);\n+    }\n+\n+    @Override\n+    protected Content getSummaryLink(Element member) {\n+        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member,\n+                utils.getFullyQualifiedName(member));\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriter.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.PropertyWriter;\n-\n-\/**\n- * Writes property documentation in HTML format.\n- *\/\n-public class PropertyWriterImpl extends AbstractMemberWriter\n-    implements PropertyWriter, MemberSummaryWriter {\n-\n-    public PropertyWriterImpl(SubWriterHolderWriter writer, TypeElement typeElement) {\n-        super(writer, typeElement);\n-    }\n-\n-    @Override\n-    public Content getMemberSummaryHeader(TypeElement typeElement, Content content) {\n-        content.add(MarkerComments.START_OF_PROPERTY_SUMMARY);\n-        Content memberContent = new ContentBuilder();\n-        writer.addSummaryHeader(this, memberContent);\n-        return memberContent;\n-    }\n-\n-    @Override\n-    public void addSummary(Content summariesList, Content content) {\n-        writer.addSummary(HtmlStyle.propertySummary,\n-                HtmlIds.PROPERTY_SUMMARY, summariesList, content);\n-    }\n-\n-    @Override\n-    public Content getPropertyDetailsHeader(Content memberDetails) {\n-        memberDetails.add(MarkerComments.START_OF_PROPERTY_DETAILS);\n-        Content propertyDetailsContent = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.DETAILS_HEADING,\n-                contents.propertyDetailsLabel);\n-        propertyDetailsContent.add(heading);\n-        return propertyDetailsContent;\n-    }\n-\n-    @Override\n-    public Content getPropertyHeaderContent(ExecutableElement property) {\n-        Content content = new ContentBuilder();\n-        var heading = HtmlTree.HEADING(Headings.TypeDeclaration.MEMBER_HEADING,\n-                Text.of(utils.getPropertyLabel(name(property))));\n-        content.add(heading);\n-        return HtmlTree.SECTION(HtmlStyle.detail, content)\n-                .setId(htmlIds.forProperty(property));\n-    }\n-\n-    @Override\n-    public Content getSignature(ExecutableElement property) {\n-        return new Signatures.MemberSignature(property, this)\n-                .setType(utils.getReturnType(typeElement, property))\n-                .setAnnotations(writer.getAnnotationInfo(property, true))\n-                .toContent();\n-    }\n-\n-    @Override\n-    public void addDeprecated(ExecutableElement property, Content propertyContent) {\n-    }\n-\n-    @Override\n-    public void addPreview(ExecutableElement property, Content content) {\n-    }\n-\n-    @Override\n-    public void addComments(ExecutableElement property, Content propertyContent) {\n-        TypeElement holder = (TypeElement)property.getEnclosingElement();\n-        if (!utils.getFullBody(property).isEmpty()) {\n-            if (holder.equals(typeElement) ||\n-                    (!utils.isPublic(holder) || utils.isLinkable(holder))) {\n-                writer.addInlineComment(property, propertyContent);\n-            } else {\n-                if (!utils.hasHiddenTag(holder) && !utils.hasHiddenTag(property)) {\n-                    Content link =\n-                            writer.getDocLink(HtmlLinkInfo.Kind.PLAIN,\n-                                    holder, property,\n-                                    utils.isIncluded(holder)\n-                                            ? holder.getSimpleName() : holder.getQualifiedName());\n-                    var codeLink = HtmlTree.CODE(link);\n-                    var descriptionFromLabel = HtmlTree.SPAN(HtmlStyle.descriptionFromTypeLabel,\n-                            utils.isClass(holder)\n-                                    ? contents.descriptionFromClassLabel\n-                                    : contents.descriptionFromInterfaceLabel);\n-                    descriptionFromLabel.add(Entity.NO_BREAK_SPACE);\n-                    descriptionFromLabel.add(codeLink);\n-                    propertyContent.add(HtmlTree.DIV(HtmlStyle.block, descriptionFromLabel));\n-                }\n-                writer.addInlineComment(property, propertyContent);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void addTags(ExecutableElement property, Content propertyContent) {\n-        writer.addTagsInfo(property, propertyContent);\n-    }\n-\n-    @Override\n-    public Content getPropertyDetails(Content memberDetailsHeader, Content memberDetails) {\n-        return writer.getDetailsListItem(\n-                HtmlTree.SECTION(HtmlStyle.propertyDetails)\n-                        .setId(HtmlIds.PROPERTY_DETAIL)\n-                        .add(memberDetailsHeader)\n-                        .add(memberDetails));\n-    }\n-\n-    @Override\n-    public void addSummaryLabel(Content content) {\n-        var label = HtmlTree.HEADING(Headings.TypeDeclaration.SUMMARY_HEADING,\n-                contents.propertySummaryLabel);\n-        content.add(label);\n-    }\n-\n-    @Override\n-    public TableHeader getSummaryTableHeader(Element member) {\n-        return new TableHeader(contents.typeLabel, contents.propertyLabel,\n-                contents.descriptionLabel);\n-    }\n-\n-    @Override\n-    protected Table<Element> createSummaryTable() {\n-        return new Table<Element>(HtmlStyle.summaryTable)\n-                .setCaption(contents.properties)\n-                .setHeader(getSummaryTableHeader(typeElement))\n-                .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);\n-    }\n-\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-        Content classLink = writer.getPreQualifiedClassLink(\n-                HtmlLinkInfo.Kind.PLAIN, typeElement);\n-        Content label;\n-        if (options.summarizeOverriddenMethods()) {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Properties_Declared_In_Class\")\n-                    : resources.getText(\"doclet.Properties_Declared_In_Interface\"));\n-        } else {\n-            label = Text.of(utils.isClass(typeElement)\n-                    ? resources.getText(\"doclet.Properties_Inherited_From_Class\")\n-                    : resources.getText(\"doclet.Properties_Inherited_From_Interface\"));\n-        }\n-        var labelHeading =\n-                HtmlTree.HEADING(Headings.TypeDeclaration.INHERITED_SUMMARY_HEADING, label)\n-                        .setId(htmlIds.forInheritedProperties(typeElement))\n-                        .add(Entity.NO_BREAK_SPACE)\n-                        .add(classLink);\n-        content.add(labelHeading);\n-    }\n-\n-    @Override\n-    protected void addSummaryLink(HtmlLinkInfo.Kind context, TypeElement typeElement, Element member,\n-                                  Content content) {\n-        Content memberLink = writer.getDocLink(context, typeElement,\n-                member,\n-                Text.of(utils.getPropertyLabel(name(member))),\n-                HtmlStyle.memberNameLink,\n-                true);\n-\n-        var code = HtmlTree.CODE(memberLink);\n-        content.add(code);\n-    }\n-\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n-        String mname = name(member);\n-        Content content = writer.getDocLink(HtmlLinkInfo.Kind.PLAIN, typeElement, member,\n-                utils.isProperty(mname) ? utils.getPropertyName(mname) : mname, true);\n-        target.add(content);\n-    }\n-\n-    @Override\n-    protected void addSummaryType(Element member, Content content) {\n-        addModifiersAndType(member, utils.getReturnType(typeElement, (ExecutableElement)member), content);\n-    }\n-\n-    @Override\n-    protected Content getSummaryLink(Element member) {\n-        return writer.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, member,\n-                utils.getFullyQualifiedName(member));\n-    }\n-\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriterImpl.java","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SearchWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.List;\n+import java.util.SortedSet;\n+\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SerialFieldTree;\n+import com.sun.source.doctree.SerialTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n+\n+\/**\n+ * Generate serialized form for serializable fields.\n+ * Documentation denoted by the tags <code>serial<\/code> and\n+ * <code>serialField<\/code> is processed.\n+ *\/\n+public class SerialFieldWriter extends FieldWriter {\n+\n+    public SerialFieldWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n+        super(writer, typeElement);\n+    }\n+\n+    public SortedSet<VariableElement> members(TypeElement te) {\n+        return utils.serializableFields(te);\n+    }\n+\n+    protected Content getSerializableFieldsHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    protected Content getFieldsContentHeader(boolean isLastContent) {\n+        return new HtmlTree(TagName.LI).setStyle(HtmlStyle.blockList);\n+    }\n+\n+    protected Content getSerializableFields(String heading, Content source) {\n+        var section = HtmlTree.SECTION(HtmlStyle.detail);\n+        if (!source.isEmpty()) {\n+            Content headingContent = Text.of(heading);\n+            var serialHeading = HtmlTree.HEADING(Headings.SerializedForm.CLASS_SUBHEADING, headingContent);\n+            section.add(serialHeading);\n+            section.add(source);\n+        }\n+        return HtmlTree.LI(section);\n+    }\n+\n+    protected void addMemberHeader(TypeMirror fieldType, String fieldName, Content content) {\n+        Content nameContent = Text.of(fieldName);\n+        var heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, nameContent);\n+        content.add(heading);\n+        var pre = new HtmlTree(TagName.PRE);\n+        Content fieldContent = writer.getLink(new HtmlLinkInfo(\n+                configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, fieldType));\n+        pre.add(fieldContent);\n+        pre.add(\" \");\n+        pre.add(fieldName);\n+        content.add(pre);\n+    }\n+\n+    \/**\n+     * Add the deprecated information for this member.\n+     *\n+     * @param field the field to document.\n+     * @param content the content to which the deprecated info will be added\n+     *\/\n+    protected void addMemberDeprecatedInfo(VariableElement field, Content content) {\n+        addDeprecatedInfo(field, content);\n+    }\n+\n+    \/**\n+     * Add the description text for this member.\n+     *\n+     * @param field the field to document.\n+     * @param content the content to which the deprecated info will be added\n+     *\/\n+    protected void addMemberDescription(VariableElement field, Content content) {\n+        if (!utils.getFullBody(field).isEmpty()) {\n+            writer.addInlineComment(field, content);\n+        }\n+        List<? extends SerialTree> tags = utils.getSerialTrees(field);\n+        if (!tags.isEmpty() && !tags.get(0).getDescription().isEmpty()) {\n+            writer.addInlineComment(field, tags.get(0), content);\n+        }\n+    }\n+\n+    \/**\n+     * Add the description text for this member represented by the tag.\n+     *\n+     * @param serialFieldTag the field to document (represented by tag)\n+     * @param content the content to which the deprecated info will be added\n+     *\/\n+    protected void addMemberDescription(VariableElement field, SerialFieldTree serialFieldTag, Content content) {\n+        List<? extends DocTree> description = serialFieldTag.getDescription();\n+        if (!description.isEmpty()) {\n+            Content serialFieldContent = writer.commentTagsToContent(field,\n+                    description,\n+                    new TagletWriter.Context(false, false));\n+            var div = HtmlTree.DIV(HtmlStyle.block, serialFieldContent);\n+            content.add(div);\n+        }\n+    }\n+\n+    \/**\n+     * Add the tag information for this member.\n+     *\n+     * @param field the field to document.\n+     * @param content the content to which the member tags info will be added\n+     *\/\n+    protected void addMemberTags(VariableElement field, Content content) {\n+        Content tagContent = writer.getBlockTagOutput(field);\n+        if (!tagContent.isEmpty()) {\n+            var dl = HtmlTree.DL(HtmlStyle.notes);\n+            dl.add(tagContent);\n+            content.add(dl);\n+        }\n+    }\n+\n+    \/**\n+     * Check to see if overview details should be printed. If\n+     * nocomment option set or if there is no text to be printed\n+     * for deprecation info, comment or tags, do not print overview details.\n+     *\n+     * @param field the field to check overview details for.\n+     * @return true if overview details need to be printed\n+     *\/\n+    protected boolean shouldPrintOverview(VariableElement field) {\n+        if (!options.noComment()) {\n+            if(!utils.getFullBody(field).isEmpty() ||\n+                    writer.hasSerializationOverviewTags(field))\n+                return true;\n+        }\n+        if (utils.isDeprecated(field))\n+            return true;\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerialFieldWriter.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n+\n+\n+\/**\n+ * Generate serialized form for Serializable\/Externalizable methods.\n+ * Documentation denoted by the <code>serialData<\/code> tag is processed.\n+ *\/\n+public class SerialMethodWriter extends MethodWriter {\n+\n+    public SerialMethodWriter(SubWriterHolderWriter writer, TypeElement typeElement) {\n+        super(writer, typeElement);\n+    }\n+\n+    protected Content getSerializableMethodsHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    protected Content getMethodsContentHeader(boolean isLastContent) {\n+        return new HtmlTree(TagName.LI);\n+    }\n+\n+    \/**\n+     * Add serializable methods.\n+     *\n+     * @param heading the heading for the section\n+     * @param source the content to be added to the serializable methods\n+     *        content\n+     * @return a content for the serializable methods content\n+     *\/\n+    protected Content getSerializableMethods(String heading, Content source) {\n+        Content headingContent = Text.of(heading);\n+        var serialHeading = HtmlTree.HEADING(Headings.SerializedForm.CLASS_SUBHEADING, headingContent);\n+        var section = HtmlTree.SECTION(HtmlStyle.detail, serialHeading);\n+        section.add(source);\n+        return HtmlTree.LI(section);\n+    }\n+\n+    \/**\n+     * Return the no customization message.\n+     *\n+     * @param msg the message to be displayed\n+     * @return no customization message content\n+     *\/\n+    protected Content getNoCustomizationMsg(String msg) {\n+        return Text.of(msg);\n+    }\n+\n+    \/**\n+     * Add the member header.\n+     *\n+     * @param member the method document to be listed\n+     * @param methodsContent the content to which the member header will be added\n+     *\/\n+    protected void addMemberHeader(ExecutableElement member, Content methodsContent) {\n+        Content memberContent = Text.of(name(member));\n+        var heading = HtmlTree.HEADING(Headings.SerializedForm.MEMBER_HEADING, memberContent);\n+        methodsContent.add(heading);\n+        methodsContent.add(getSignature(member));\n+    }\n+\n+    \/**\n+     * Add the deprecated information for this member.\n+     *\n+     * @param member the method to document.\n+     * @param methodsContent the content to which the deprecated info will be added\n+     *\/\n+    protected void addDeprecatedMemberInfo(ExecutableElement member, Content methodsContent) {\n+        addDeprecatedInfo(member, methodsContent);\n+    }\n+\n+    \/**\n+     * Add the description text for this member.\n+     *\n+     * @param member the method to document.\n+     * @param methodsContent the content to which the deprecated info will be added\n+     *\/\n+    protected void addMemberDescription(ExecutableElement member, Content methodsContent) {\n+        addComment(member, methodsContent);\n+    }\n+\n+    \/**\n+     * Add the tag information for this member.\n+     *\n+     * @param member the method to document.\n+     * @param methodsContent the content to which the member tags info will be added\n+     *\/\n+    protected void addMemberTags(ExecutableElement member, Content methodsContent) {\n+        TagletManager tagletManager = configuration.tagletManager;\n+        Content tagContent = writer.getBlockTagOutput(member, tagletManager.getSerializedFormTaglets());\n+        var dl = HtmlTree.DL(HtmlStyle.notes);\n+        dl.add(tagContent);\n+        methodsContent.add(dl);\n+        if (name(member).equals(\"writeExternal\")\n+                && utils.getSerialDataTrees(member).isEmpty()) {\n+            serialWarning(member, \"doclet.MissingSerialDataTag\",\n+                utils.getFullyQualifiedName(member.getEnclosingElement()), name(member));\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerialMethodWriter.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,726 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.SerialFieldTree;\n+import com.sun.source.doctree.SerialTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.DocletException;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * Generates the Serialized Form Information Page, <i>serialized-form.html<\/i>.\n+ *\/\n+public class SerializedFormWriter extends SubWriterHolderWriter {\n+\n+    \/**\n+     * The writer for serializable fields.\n+     *\/\n+    private SerialFieldWriter fieldWriter;\n+\n+    \/**\n+     * The writer for serializable method documentation.\n+     *\/\n+    private SerialMethodWriter methodWriter;\n+\n+    \/**\n+     * The header for the serial version UID.  Save the string\n+     * here instead of the properties file because we do not want\n+     * this string to be localized.\n+     *\/\n+    private static final String SERIAL_VERSION_UID = \"serialVersionUID\";\n+    private static final String SERIAL_VERSION_UID_HEADER = SERIAL_VERSION_UID + \":\";\n+\n+    \/**\n+     * The current package being documented.\n+     *\/\n+    private PackageElement currentPackage;\n+\n+    \/**\n+     * The current class being documented.\n+     *\/\n+    private TypeElement currentTypeElement;\n+\n+    \/**\n+     * The current member being documented.\n+     *\/\n+    protected Element currentMember;\n+\n+    Set<TypeElement> visibleClasses;\n+\n+    \/**\n+     * @param configuration the configuration data for the doclet\n+     *\/\n+    public SerializedFormWriter(HtmlConfiguration configuration) {\n+        super(configuration, DocPaths.SERIALIZED_FORM, false);\n+        visibleClasses = configuration.getIncludedTypeElements();\n+        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.SERIALIZED_FORM);\n+    }\n+\n+    \/**\n+     * Build the serialized form.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+     void build() throws DocletException {\n+        SortedSet<TypeElement> rootclasses = new TreeSet<>(utils.comparators.makeGeneralPurposeComparator());\n+        rootclasses.addAll(configuration.getIncludedTypeElements());\n+        if (!serialClassFoundToDocument(rootclasses)) {\n+            \/\/Nothing to document.\n+            return;\n+        }\n+\n+        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.SERIALIZED_FORM);\n+        writeGenerating();\n+\n+        buildSerializedForm();\n+    }\n+\n+    \/**\n+     * Build the serialized form.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildSerializedForm() throws DocletException {\n+        Content content = getHeader(resources.getText(\n+                \"doclet.Serialized_Form\"));\n+\n+        buildSerializedFormSummaries();\n+\n+        addFooter();\n+        printDocument(content);\n+    }\n+\n+    \/**\n+     * Build the serialized form summaries.\n+     *\/\n+    protected void buildSerializedFormSummaries() {\n+        Content c = getSerializedSummariesHeader();\n+        for (PackageElement pkg : configuration.packages) {\n+            currentPackage = pkg;\n+\n+            buildPackageSerializedForm(c);\n+        }\n+        addSerializedContent(c);\n+    }\n+\n+    \/**\n+     * Build the package serialized form for the current package being processed.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildPackageSerializedForm(Content target) {\n+        Content packageSerializedHeader = getPackageSerializedHeader();\n+        SortedSet<TypeElement> classes = utils.getAllClassesUnfiltered(currentPackage);\n+        if (classes.isEmpty()) {\n+            return;\n+        }\n+        if (!serialInclude(utils, currentPackage)) {\n+            return;\n+        }\n+        if (!serialClassFoundToDocument(classes)) {\n+            return;\n+        }\n+\n+        buildPackageHeader(packageSerializedHeader);\n+        buildClassSerializedForm(packageSerializedHeader);\n+\n+        addPackageSerialized(target, packageSerializedHeader);\n+    }\n+\n+    \/**\n+     * Build the package header.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildPackageHeader(Content target) {\n+        target.add(getPackageHeader(currentPackage));\n+    }\n+\n+    \/**\n+     * Build the class serialized form.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassSerializedForm(Content target) {\n+        Content classSerializedHeader = getClassSerializedHeader();\n+        SortedSet<TypeElement> typeElements = utils.getAllClassesUnfiltered(currentPackage);\n+        for (TypeElement typeElement : typeElements) {\n+            currentTypeElement = typeElement;\n+            fieldWriter = getSerialFieldWriter(currentTypeElement);\n+            methodWriter = getSerialMethodWriter(currentTypeElement);\n+            if (utils.isClass(currentTypeElement) && utils.isSerializable(currentTypeElement)) {\n+                if (!serialClassInclude(utils, currentTypeElement)) {\n+                    continue;\n+                }\n+                Content classHeader = getClassHeader(currentTypeElement);\n+\n+                buildSerialUIDInfo(classHeader);\n+                buildClassContent(classHeader);\n+\n+                classSerializedHeader.add(getMember(classHeader));\n+            }\n+        }\n+        target.add(classSerializedHeader);\n+    }\n+\n+    \/**\n+     * Build the serial UID information for the given class.\n+     *\n+     * @param target the content to which the serial UID information will be added\n+     *\/\n+    protected void buildSerialUIDInfo(Content target) {\n+        Content serialUIDHeader = getSerialUIDInfoHeader();\n+        for (VariableElement field : utils.getFieldsUnfiltered(currentTypeElement)) {\n+            if (field.getSimpleName().toString().compareTo(SERIAL_VERSION_UID) == 0 &&\n+                    field.getConstantValue() != null) {\n+                addSerialUIDInfo(SERIAL_VERSION_UID_HEADER,\n+                        utils.constantValueExpression(field), serialUIDHeader);\n+                break;\n+            }\n+        }\n+        target.add(serialUIDHeader);\n+    }\n+\n+    \/**\n+     * Build the summaries for the methods and fields.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildClassContent(Content target) {\n+        Content classContent = getClassContentHeader();\n+\n+        buildSerializableMethods(classContent);\n+        buildFieldHeader(classContent);\n+        buildSerializableFields(classContent);\n+\n+        target.add(classContent);\n+    }\n+\n+    \/**\n+     * Build the summaries for the methods that belong to the given class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSerializableMethods(Content target) {\n+        Content serializableMethodsHeader = methodWriter.getSerializableMethodsHeader();\n+        for (var i = utils.serializationMethods(currentTypeElement).iterator(); i.hasNext(); ) {\n+            currentMember = i.next();\n+            Content methodsContent = methodWriter.getMethodsContentHeader(!i.hasNext());\n+\n+            buildMethodSubHeader(methodsContent);\n+            buildDeprecatedMethodInfo(methodsContent);\n+            buildMethodInfo(methodsContent);\n+\n+            serializableMethodsHeader.add(methodsContent);\n+        }\n+        if (!utils.serializationMethods(currentTypeElement).isEmpty()) {\n+            target.add(methodWriter.getSerializableMethods(\n+                    resources.getText(\"doclet.Serialized_Form_methods\"),\n+                    serializableMethodsHeader));\n+            if (utils.isSerializable(currentTypeElement) && !utils.isExternalizable(currentTypeElement)) {\n+                if (utils.serializationMethods(currentTypeElement).isEmpty()) {\n+                    Content noCustomizationMsg = methodWriter.getNoCustomizationMsg(\n+                            resources.getText(\"doclet.Serializable_no_customization\"));\n+                    target.add(methodWriter.getSerializableMethods(\n+                            resources.getText(\"doclet.Serialized_Form_methods\"),\n+                            noCustomizationMsg));\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Build the method sub header.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodSubHeader(Content methodsContent)  {\n+        methodWriter.addMemberHeader((ExecutableElement)currentMember, methodsContent);\n+    }\n+\n+    \/**\n+     * Build the deprecated method description.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildDeprecatedMethodInfo(Content methodsContent) {\n+        methodWriter.addDeprecatedMemberInfo((ExecutableElement)currentMember, methodsContent);\n+    }\n+\n+    \/**\n+     * Build the information for the method.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodInfo(Content methodsContent) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+\n+        buildMethodDescription(methodsContent);\n+        buildMethodTags(methodsContent);\n+    }\n+\n+    \/**\n+     * Build method description.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodDescription(Content methodsContent) {\n+        methodWriter.addMemberDescription((ExecutableElement)currentMember, methodsContent);\n+    }\n+\n+    \/**\n+     * Build the method tags.\n+     *\n+     * @param methodsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildMethodTags(Content methodsContent) {\n+        methodWriter.addMemberTags((ExecutableElement)currentMember, methodsContent);\n+        ExecutableElement method = (ExecutableElement)currentMember;\n+        if (method.getSimpleName().toString().compareTo(\"writeExternal\") == 0\n+                && utils.getSerialDataTrees(method).isEmpty()) {\n+            if (options.serialWarn()) {\n+                TypeElement encl  = (TypeElement) method.getEnclosingElement();\n+                messages.warning(currentMember,\n+                        \"doclet.MissingSerialDataTag\", encl.getQualifiedName().toString(),\n+                        method.getSimpleName().toString());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Build the field header.\n+     *\n+     * @param classContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldHeader(Content classContent) {\n+        if (!utils.serializableFields(currentTypeElement).isEmpty()) {\n+            buildFieldSerializationOverview(currentTypeElement, classContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the serialization overview for the given class.\n+     *\n+     * @param typeElement the class to print the overview for.\n+     * @param classContent the content to which the documentation will be added\n+     *\/\n+    public void buildFieldSerializationOverview(TypeElement typeElement, Content classContent) {\n+        if (utils.definesSerializableFields(typeElement)) {\n+            VariableElement ve = utils.serializableFields(typeElement).first();\n+            \/\/ Check to see if there are inline comments, tags or deprecation\n+            \/\/ information to be printed.\n+            if (fieldWriter.shouldPrintOverview(ve)) {\n+                Content serializableFieldsHeader = fieldWriter.getSerializableFieldsHeader();\n+                Content fieldsOverviewContent = fieldWriter.getFieldsContentHeader(true);\n+                fieldWriter.addMemberDeprecatedInfo(ve, fieldsOverviewContent);\n+                if (!options.noComment()) {\n+                    fieldWriter.addMemberDescription(ve, fieldsOverviewContent);\n+                    fieldWriter.addMemberTags(ve, fieldsOverviewContent);\n+                }\n+                serializableFieldsHeader.add(fieldsOverviewContent);\n+                classContent.add(fieldWriter.getSerializableFields(\n+                        resources.getText(\"doclet.Serialized_Form_class\"),\n+                        serializableFieldsHeader));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Build the summaries for the fields that belong to the given class.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSerializableFields(Content target) {\n+        Collection<VariableElement> members = utils.serializableFields(currentTypeElement);\n+        if (!members.isEmpty()) {\n+            Content serializableFieldsHeader = fieldWriter.getSerializableFieldsHeader();\n+            for (var i = members.iterator(); i.hasNext();) {\n+                currentMember = i.next();\n+                if (!utils.definesSerializableFields(currentTypeElement)) {\n+                    Content fieldsContent = fieldWriter.getFieldsContentHeader(!i.hasNext());\n+\n+                    buildFieldSubHeader(fieldsContent);\n+                    buildFieldDeprecationInfo(fieldsContent);\n+                    buildFieldInfo(fieldsContent);\n+\n+                    serializableFieldsHeader.add(fieldsContent);\n+                } else {\n+                    buildSerialFieldTagsInfo(serializableFieldsHeader);\n+                }\n+            }\n+            target.add(fieldWriter.getSerializableFields(\n+                    resources.getText(\"doclet.Serialized_Form_fields\"),\n+                    serializableFieldsHeader));\n+        }\n+    }\n+\n+    \/**\n+     * Build the field sub header.\n+     *\n+     * @param fieldsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldSubHeader(Content fieldsContent) {\n+        if (!utils.definesSerializableFields(currentTypeElement)) {\n+            VariableElement field = (VariableElement) currentMember;\n+            fieldWriter.addMemberHeader(field.asType(),\n+                    utils.getSimpleName(field),\n+                    fieldsContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the field deprecation information.\n+     *\n+     * @param fieldsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldDeprecationInfo(Content fieldsContent) {\n+        if (!utils.definesSerializableFields(currentTypeElement)) {\n+            fieldWriter.addMemberDeprecatedInfo((VariableElement)currentMember,\n+                    fieldsContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the serial field tags information.\n+     *\n+     * @param target the content to which the documentation will be added\n+     *\/\n+    protected void buildSerialFieldTagsInfo(Content target) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+        VariableElement field = (VariableElement)currentMember;\n+        \/\/ Process Serializable Fields specified as array of\n+        \/\/ ObjectStreamFields. Print a member for each serialField tag.\n+        \/\/ (There should be one serialField tag per ObjectStreamField\n+        \/\/ element.)\n+        SortedSet<SerialFieldTree> tags = new TreeSet<>(utils.comparators.makeSerialFieldTreeComparator());\n+        \/\/ sort the elements\n+        tags.addAll(utils.getSerialFieldTrees(field));\n+\n+        CommentHelper ch = utils.getCommentHelper(field);\n+        for (SerialFieldTree tag : tags) {\n+            if (tag.getName() == null || tag.getType() == null)  \/\/ ignore malformed @serialField tags\n+                continue;\n+            Content fieldsContent = fieldWriter.getFieldsContentHeader(tag.equals(tags.last()));\n+            TypeMirror type = ch.getReferencedType(tag);\n+            fieldWriter.addMemberHeader(type, tag.getName().getName().toString(), fieldsContent);\n+            fieldWriter.addMemberDescription(field, tag, fieldsContent);\n+            target.add(fieldsContent);\n+        }\n+    }\n+\n+    \/**\n+     * Build the field information.\n+     *\n+     * @param fieldsContent the content to which the documentation will be added\n+     *\/\n+    protected void buildFieldInfo(Content fieldsContent) {\n+        if (options.noComment()) {\n+            return;\n+        }\n+        VariableElement field = (VariableElement)currentMember;\n+        TypeElement te = utils.getEnclosingTypeElement(currentMember);\n+        \/\/ Process default Serializable field.\n+        if ((utils.getSerialTrees(field).isEmpty()) \/*&& !field.isSynthetic()*\/\n+                && options.serialWarn()) {\n+            messages.warning(field,\n+                    \"doclet.MissingSerialTag\", utils.getFullyQualifiedName(te),\n+                    utils.getSimpleName(field));\n+        }\n+        fieldWriter.addMemberDescription(field, fieldsContent);\n+        fieldWriter.addMemberTags(field, fieldsContent);\n+    }\n+\n+    \/**\n+     * Returns true if the given Element should be included\n+     * in the serialized form.\n+     *\n+     * @param utils the utils object\n+     * @param element the Element object to check for serializability\n+     * @return true if the element should be included in the serial form\n+     *\/\n+    public static boolean serialInclude(Utils utils, Element element) {\n+        if (element == null) {\n+            return false;\n+        }\n+        return utils.isClass(element)\n+                ? serialClassInclude(utils, (TypeElement)element)\n+                : serialDocInclude(utils, element);\n+    }\n+\n+    \/**\n+     * Returns true if the given TypeElement should be included\n+     * in the serialized form.\n+     *\n+     * @param te the TypeElement object to check for serializability.\n+     *\/\n+    private static boolean serialClassInclude(Utils utils, TypeElement te) {\n+        if (utils.isEnum(te)) {\n+            return false;\n+        }\n+        if (utils.isSerializable(te)) {\n+            if (utils.hasDocCommentTree(te) && !utils.getSerialTrees(te).isEmpty()) {\n+                return serialDocInclude(utils, te);\n+            } else {\n+                return utils.isPublic(te) || utils.isProtected(te);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Return true if the given Element should be included\n+     * in the serialized form.\n+     *\n+     * @param element the Element to check for serializability.\n+     *\/\n+    private static boolean serialDocInclude(Utils utils, Element element) {\n+        if (utils.isEnum(element)) {\n+            return false;\n+        }\n+        List<? extends SerialTree> serial = utils.getSerialTrees(element);\n+        if (!serial.isEmpty()) {\n+            \/\/ look for `@serial include|exclude`\n+            String serialtext = Utils.toLowerCase(serial.get(0).toString());\n+            if (serialtext.contains(\"exclude\")) {\n+                return false;\n+            } else if (serialtext.contains(\"include\")) {\n+                return true;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Return true if any of the given typeElements have a {@code @serial include} tag.\n+     *\n+     * @param classes the typeElements to check.\n+     * @return true if any of the given typeElements have a {@code @serial include} tag.\n+     *\/\n+    private boolean serialClassFoundToDocument(SortedSet<TypeElement> classes) {\n+        for (TypeElement aClass : classes) {\n+            if (serialClassInclude(utils, aClass)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Get the given header.\n+     *\n+     * @param header the header to write\n+     * @return the body content\n+     *\/\n+     Content getHeader(String header) {\n+        HtmlTree body = getBody(getWindowTitle(header));\n+        Content h1Content = Text.of(header);\n+        var heading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n+                HtmlStyle.title, h1Content);\n+        var div = HtmlTree.DIV(HtmlStyle.header, heading);\n+        bodyContents.setHeader(getHeader(PageMode.SERIALIZED_FORM))\n+                .addMainContent(div);\n+        return body;\n+    }\n+\n+    \/**\n+     * Get the serialized form summaries header.\n+     *\n+     * @return the serialized form summaries header\n+     *\/\n+     Content getSerializedSummariesHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    \/**\n+     * Get the package serialized form header.\n+     *\n+     * @return the package serialized form header tree\n+     *\/\n+     Content getPackageSerializedHeader() {\n+        return HtmlTree.SECTION(HtmlStyle.serializedPackageContainer);\n+    }\n+\n+     Content getPackageHeader(PackageElement packageElement) {\n+        var heading = HtmlTree.HEADING_TITLE(Headings.SerializedForm.PACKAGE_HEADING,\n+                contents.packageLabel);\n+        heading.add(Entity.NO_BREAK_SPACE);\n+        heading.add(getPackageLink(packageElement, Text.of(utils.getPackageName(packageElement))));\n+        return heading;\n+    }\n+\n+     Content getClassSerializedHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    \/**\n+     * Checks if a class is generated and is visible.\n+     *\n+     * @param typeElement the class being processed.\n+     * @return true if the class, that is being processed, is generated and is visible.\n+     *\/\n+    public boolean isVisibleClass(TypeElement typeElement) {\n+        return visibleClasses.contains(typeElement) && configuration.isGeneratedDoc(typeElement)\n+                && !utils.hasHiddenTag(typeElement);\n+    }\n+\n+     Content getClassHeader(TypeElement typeElement) {\n+        Content classLink = (isVisibleClass(typeElement))\n+                ? getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, typeElement)\n+                        .label(configuration.getClassName(typeElement)))\n+                : Text.of(utils.getFullyQualifiedName(typeElement));\n+        var section = HtmlTree.SECTION(HtmlStyle.serializedClassDetails)\n+                .setId(htmlIds.forClass(typeElement));\n+        Content superClassLink = typeElement.getSuperclass() != null\n+                ? getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS,\n+                        typeElement.getSuperclass()))\n+                : null;\n+        Content interfaceLink = getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS,\n+                utils.isExternalizable(typeElement)\n+                        ? utils.getExternalizableType()\n+                        : utils.getSerializableType()));\n+\n+        \/\/ Print the heading.\n+        Content className = new ContentBuilder();\n+        className.add(utils.getTypeElementKindName(typeElement, false));\n+        className.add(Entity.NO_BREAK_SPACE);\n+        className.add(classLink);\n+        section.add(HtmlTree.HEADING(Headings.SerializedForm.CLASS_HEADING, className));\n+        \/\/ Print a simplified signature.\n+        Content signature = new ContentBuilder();\n+        signature.add(\"class \");\n+        signature.add(typeElement.getSimpleName());\n+        signature.add(\" extends \");\n+        signature.add(superClassLink);\n+        signature.add(\" implements \");\n+        signature.add(interfaceLink);\n+        section.add(HtmlTree.DIV(HtmlStyle.typeSignature, signature));\n+        return section;\n+    }\n+\n+     Content getSerialUIDInfoHeader() {\n+        return HtmlTree.DL(HtmlStyle.nameValue);\n+    }\n+\n+    \/**\n+     * Adds the serial UID info.\n+     *\n+     * @param header the header that will show up before the UID.\n+     * @param serialUID the serial UID to print.\n+     * @param target the serial UID content to which the serial UID\n+     *               content will be added\n+     *\/\n+     void addSerialUIDInfo(String header,\n+                                 String serialUID,\n+                                 Content target)\n+    {\n+        Content headerContent = Text.of(header);\n+        target.add(HtmlTree.DT(headerContent));\n+        Content serialContent = Text.of(serialUID);\n+        target.add(HtmlTree.DD(serialContent));\n+    }\n+\n+     Content getClassContentHeader() {\n+        return HtmlTree.UL(HtmlStyle.blockList);\n+    }\n+\n+    \/**\n+     * Add the serialized content section.\n+     *\n+     * @param source the serialized content to be added\n+     *\/\n+     void addSerializedContent(Content source) {\n+        bodyContents.addMainContent(source);\n+    }\n+\n+     void addPackageSerialized(Content serializedSummaries,\n+                                     Content packageSerialized)\n+    {\n+        serializedSummaries.add(HtmlTree.LI(packageSerialized));\n+    }\n+\n+    \/**\n+     * Add the footer.\n+     *\/\n+     void addFooter() {\n+        bodyContents.setFooter(getFooter());\n+    }\n+\n+     void printDocument(Content source) throws DocFileIOException {\n+        source.add(bodyContents);\n+        printHtmlDocument(null, \"serialized forms\", source);\n+\n+        if (configuration.mainIndex != null) {\n+            configuration.mainIndex.add(IndexItem.of(IndexItem.Category.TAGS,\n+                    resources.getText(\"doclet.Serialized_Form\"), path));\n+        }\n+    }\n+\n+    \/**\n+     * Return an instance of a SerialFieldWriter.\n+     *\n+     * @return an instance of a SerialFieldWriter.\n+     *\/\n+     SerialFieldWriter getSerialFieldWriter(TypeElement typeElement) {\n+        return new SerialFieldWriter(this, typeElement);\n+    }\n+\n+    \/**\n+     * Return an instance of a SerialMethodWriter.\n+     *\n+     * @return an instance of a SerialMethodWriter.\n+     *\/\n+     SerialMethodWriter getSerialMethodWriter(TypeElement typeElement) {\n+        return new SerialMethodWriter(this, typeElement);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerializedFormWriter.java","additions":726,"deletions":0,"binary":false,"changes":726,"status":"added"},{"patch":"@@ -1,244 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Set;\n-\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-\n-\/**\n- * Generates the Serialized Form Information Page, <i>serialized-form.html<\/i>.\n- *\/\n-public class SerializedFormWriterImpl extends SubWriterHolderWriter\n-    implements SerializedFormWriter {\n-\n-    Set<TypeElement> visibleClasses;\n-\n-    \/**\n-     * @param configuration the configuration data for the doclet\n-     *\/\n-    public SerializedFormWriterImpl(HtmlConfiguration configuration) {\n-        super(configuration, DocPaths.SERIALIZED_FORM);\n-        visibleClasses = configuration.getIncludedTypeElements();\n-        configuration.conditionalPages.add(HtmlConfiguration.ConditionalPage.SERIALIZED_FORM);\n-    }\n-\n-    \/**\n-     * Get the given header.\n-     *\n-     * @param header the header to write\n-     * @return the body content\n-     *\/\n-    @Override\n-    public Content getHeader(String header) {\n-        HtmlTree body = getBody(getWindowTitle(header));\n-        Content h1Content = Text.of(header);\n-        var heading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,\n-                HtmlStyle.title, h1Content);\n-        var div = HtmlTree.DIV(HtmlStyle.header, heading);\n-        bodyContents.setHeader(getHeader(PageMode.SERIALIZED_FORM))\n-                .addMainContent(div);\n-        return body;\n-    }\n-\n-    \/**\n-     * Get the serialized form summaries header.\n-     *\n-     * @return the serialized form summaries header\n-     *\/\n-    @Override\n-    public Content getSerializedSummariesHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    \/**\n-     * Get the package serialized form header.\n-     *\n-     * @return the package serialized form header tree\n-     *\/\n-    @Override\n-    public Content getPackageSerializedHeader() {\n-        return HtmlTree.SECTION(HtmlStyle.serializedPackageContainer);\n-    }\n-\n-    @Override\n-    public Content getPackageHeader(PackageElement packageElement) {\n-        var heading = HtmlTree.HEADING_TITLE(Headings.SerializedForm.PACKAGE_HEADING,\n-                contents.packageLabel);\n-        heading.add(Entity.NO_BREAK_SPACE);\n-        heading.add(getPackageLink(packageElement, Text.of(utils.getPackageName(packageElement))));\n-        return heading;\n-    }\n-\n-    @Override\n-    public Content getClassSerializedHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    \/**\n-     * Checks if a class is generated and is visible.\n-     *\n-     * @param typeElement the class being processed.\n-     * @return true if the class, that is being processed, is generated and is visible.\n-     *\/\n-    public boolean isVisibleClass(TypeElement typeElement) {\n-        return visibleClasses.contains(typeElement) && configuration.isGeneratedDoc(typeElement)\n-                && !utils.hasHiddenTag(typeElement);\n-    }\n-\n-    @Override\n-    public Content getClassHeader(TypeElement typeElement) {\n-        Content classLink = (isVisibleClass(typeElement))\n-                ? getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, typeElement)\n-                        .label(configuration.getClassName(typeElement)))\n-                : Text.of(utils.getFullyQualifiedName(typeElement));\n-        var section = HtmlTree.SECTION(HtmlStyle.serializedClassDetails)\n-                .setId(htmlIds.forClass(typeElement));\n-        Content superClassLink = typeElement.getSuperclass() != null\n-                ? getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS,\n-                        typeElement.getSuperclass()))\n-                : null;\n-        Content interfaceLink = getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS,\n-                utils.isExternalizable(typeElement)\n-                        ? utils.getExternalizableType()\n-                        : utils.getSerializableType()));\n-\n-        \/\/ Print the heading.\n-        Content className = new ContentBuilder();\n-        className.add(utils.getTypeElementKindName(typeElement, false));\n-        className.add(Entity.NO_BREAK_SPACE);\n-        className.add(classLink);\n-        section.add(HtmlTree.HEADING(Headings.SerializedForm.CLASS_HEADING, className));\n-        \/\/ Print a simplified signature.\n-        Content signature = new ContentBuilder();\n-        signature.add(\"class \");\n-        signature.add(typeElement.getSimpleName());\n-        signature.add(\" extends \");\n-        signature.add(superClassLink);\n-        signature.add(\" implements \");\n-        signature.add(interfaceLink);\n-        section.add(HtmlTree.DIV(HtmlStyle.typeSignature, signature));\n-        return section;\n-    }\n-\n-    @Override\n-    public Content getSerialUIDInfoHeader() {\n-        return HtmlTree.DL(HtmlStyle.nameValue);\n-    }\n-\n-    \/**\n-     * Adds the serial UID info.\n-     *\n-     * @param header the header that will show up before the UID.\n-     * @param serialUID the serial UID to print.\n-     * @param target the serial UID content to which the serial UID\n-     *               content will be added\n-     *\/\n-    @Override\n-    public void addSerialUIDInfo(String header,\n-                                 String serialUID,\n-                                 Content target)\n-    {\n-        Content headerContent = Text.of(header);\n-        target.add(HtmlTree.DT(headerContent));\n-        Content serialContent = Text.of(serialUID);\n-        target.add(HtmlTree.DD(serialContent));\n-    }\n-\n-    @Override\n-    public Content getClassContentHeader() {\n-        return HtmlTree.UL(HtmlStyle.blockList);\n-    }\n-\n-    \/**\n-     * Add the serialized content section.\n-     *\n-     * @param source the serialized content to be added\n-     *\/\n-    @Override\n-    public void addSerializedContent(Content source) {\n-        bodyContents.addMainContent(source);\n-    }\n-\n-    @Override\n-    public void addPackageSerialized(Content serializedSummaries,\n-                                     Content packageSerialized)\n-    {\n-        serializedSummaries.add(HtmlTree.LI(packageSerialized));\n-    }\n-\n-    \/**\n-     * Add the footer.\n-     *\/\n-    @Override\n-    public void addFooter() {\n-        bodyContents.setFooter(getFooter());\n-    }\n-\n-    @Override\n-    public void printDocument(Content source) throws DocFileIOException {\n-        source.add(bodyContents);\n-        printHtmlDocument(null, \"serialized forms\", source);\n-\n-        if (configuration.mainIndex != null) {\n-            configuration.mainIndex.add(IndexItem.of(IndexItem.Category.TAGS,\n-                    resources.getText(\"doclet.Serialized_Form\"), path));\n-        }\n-    }\n-\n-    \/**\n-     * Return an instance of a SerialFieldWriter.\n-     *\n-     * @return an instance of a SerialFieldWriter.\n-     *\/\n-    @Override\n-    public SerialFieldWriter getSerialFieldWriter(TypeElement typeElement) {\n-        return new HtmlSerialFieldWriter(this, typeElement);\n-    }\n-\n-    \/**\n-     * Return an instance of a SerialMethodWriter.\n-     *\n-     * @return an instance of a SerialMethodWriter.\n-     *\/\n-    @Override\n-    public SerialMethodWriter getSerialMethodWriter(TypeElement typeElement) {\n-        return new HtmlSerialMethodWriter(this, typeElement);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerializedFormWriterImpl.java","additions":0,"deletions":244,"binary":false,"changes":244,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -66,1 +65,1 @@\n-    public static Content getModuleSignature(ModuleElement mdle, ModuleWriterImpl moduleWriter) {\n+    public static Content getModuleSignature(ModuleElement mdle, ModuleWriter moduleWriter) {\n@@ -83,1 +82,1 @@\n-    public static Content getPackageSignature(PackageElement pkg, PackageWriterImpl pkgWriter) {\n+    public static Content getPackageSignature(PackageElement pkg, PackageWriter pkgWriter) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SourceToHTMLConverter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -52,1 +51,1 @@\n- * @see ClassWriterImpl\n+ * @see ClassWriter\n@@ -65,0 +64,4 @@\n+    public SubWriterHolderWriter(HtmlConfiguration configuration, DocPath filename, boolean generating) {\n+        super(configuration, filename, generating);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SubWriterHolderWriter.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n@@ -254,0 +253,2 @@\n+        \/\/ TODO: notable that these do not go through the writerFactory\n+        \/\/       also maybe notable that annotation type members are not handled as such\n@@ -256,5 +257,5 @@\n-                 ANNOTATION_TYPE, RECORD -> new NestedClassWriterImpl(this);\n-            case FIELD -> new FieldWriterImpl(this);\n-            case METHOD -> new MethodWriterImpl(this);\n-            case CONSTRUCTOR -> new ConstructorWriterImpl(this);\n-            case ENUM_CONSTANT -> new EnumConstantWriterImpl(this);\n+                 ANNOTATION_TYPE, RECORD -> new NestedClassWriter(this);\n+            case FIELD -> new FieldWriter(this);\n+            case METHOD -> new MethodWriter(this);\n+            case CONSTRUCTOR -> new ConstructorWriter(this);\n+            case ENUM_CONSTANT -> new EnumConstantWriter(this);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SummaryListWriter.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SystemPropertiesWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Table.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TableHeader.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TreeWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+\/**\n+ * The factory that returns HTML writers.\n+ *\/\n+\/\/ TODO: be more consistent about using this factory\n+public class WriterFactory {\n+\n+    private final HtmlConfiguration configuration;\n+    public WriterFactory(HtmlConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public ConstantsSummaryWriter getConstantsSummaryWriter() {\n+        return new ConstantsSummaryWriter(configuration);\n+    }\n+\n+    public PackageWriter getPackageSummaryWriter(PackageElement packageElement) {\n+        return new PackageWriter(configuration, packageElement);\n+    }\n+\n+    public ModuleWriter getModuleSummaryWriter(ModuleElement mdle) {\n+        return new ModuleWriter(configuration, mdle);\n+    }\n+\n+    public ClassWriter getClassWriter(TypeElement typeElement, ClassTree classTree) {\n+        return new ClassWriter(configuration, typeElement, classTree);\n+    }\n+\n+    public AnnotationTypeMemberWriter getAnnotationTypeMemberWriter(\n+            ClassWriter classWriter) {\n+        TypeElement te = classWriter.getTypeElement();\n+        return new AnnotationTypeMemberWriter(classWriter, te, AnnotationTypeMemberWriter.Kind.ANY);\n+    }\n+\n+    public AnnotationTypeMemberWriter getAnnotationTypeOptionalMemberWriter(\n+            ClassWriter classWriter) {\n+        TypeElement te = classWriter.getTypeElement();\n+        return new AnnotationTypeMemberWriter(classWriter, te, AnnotationTypeMemberWriter.Kind.OPTIONAL);\n+    }\n+\n+    public AnnotationTypeMemberWriter getAnnotationTypeRequiredMemberWriter(\n+            ClassWriter classWriter) {\n+        TypeElement te = classWriter.getTypeElement();\n+        return new AnnotationTypeMemberWriter(classWriter, te, AnnotationTypeMemberWriter.Kind.REQUIRED);\n+    }\n+\n+    public EnumConstantWriter getEnumConstantWriter(ClassWriter classWriter) {\n+        return new EnumConstantWriter(classWriter);\n+    }\n+\n+    public FieldWriter getFieldWriter(ClassWriter classWriter) {\n+        return new FieldWriter(classWriter);\n+    }\n+\n+    public PropertyWriter getPropertyWriter(ClassWriter classWriter) {\n+        return new PropertyWriter(classWriter);\n+    }\n+\n+    public MethodWriter getMethodWriter(ClassWriter classWriter) {\n+        return new MethodWriter(classWriter);\n+    }\n+\n+    public ConstructorWriter getConstructorWriter(ClassWriter classWriter) {\n+        return new ConstructorWriter(classWriter);\n+    }\n+\n+    public AbstractMemberWriter getMemberSummaryWriter(ClassWriter classWriter,\n+                                                       VisibleMemberTable.Kind memberType) {\n+        switch (memberType) {\n+            case CONSTRUCTORS:\n+                return getConstructorWriter(classWriter);\n+            case ENUM_CONSTANTS:\n+                return getEnumConstantWriter(classWriter);\n+            case ANNOTATION_TYPE_MEMBER_OPTIONAL:\n+                return getAnnotationTypeOptionalMemberWriter(classWriter);\n+            case ANNOTATION_TYPE_MEMBER_REQUIRED:\n+                return getAnnotationTypeRequiredMemberWriter(classWriter);\n+            case FIELDS:\n+                return getFieldWriter(classWriter);\n+            case PROPERTIES:\n+                return getPropertyWriter(classWriter);\n+            case NESTED_CLASSES:\n+                return new NestedClassWriter(classWriter, classWriter.getTypeElement());\n+            case METHODS:\n+                return getMethodWriter(classWriter);\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    public SerializedFormWriter getSerializedFormWriter() {\n+        return new SerializedFormWriter(configuration);\n+    }\n+\n+    public DocFilesHandler getDocFilesHandler(Element element) {\n+        return new DocFilesHandler(configuration, element);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/WriterFactory.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.ConstantsSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-import jdk.javadoc.internal.doclets.toolkit.WriterFactory;\n-import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-\/**\n- * The factory that returns HTML writers.\n- *\/\n-public class WriterFactoryImpl implements WriterFactory {\n-\n-    private final HtmlConfiguration configuration;\n-    public WriterFactoryImpl(HtmlConfiguration configuration) {\n-        this.configuration = configuration;\n-    }\n-\n-    @Override\n-    public ConstantsSummaryWriter getConstantsSummaryWriter() {\n-        return new ConstantsSummaryWriterImpl(configuration);\n-    }\n-\n-    @Override\n-    public PackageSummaryWriter getPackageSummaryWriter(PackageElement packageElement) {\n-        return new PackageWriterImpl(configuration, packageElement);\n-    }\n-\n-    @Override\n-    public ModuleSummaryWriter getModuleSummaryWriter(ModuleElement mdle) {\n-        return new ModuleWriterImpl(configuration, mdle);\n-    }\n-\n-    @Override\n-    public ClassWriter getClassWriter(TypeElement typeElement, ClassTree classTree) {\n-        return new ClassWriterImpl(configuration, typeElement, classTree);\n-    }\n-\n-    @Override\n-    public AnnotationTypeMemberWriterImpl getAnnotationTypeMemberWriter(\n-            ClassWriter classWriter) {\n-        TypeElement te = classWriter.getTypeElement();\n-        return new AnnotationTypeMemberWriterImpl(\n-                (ClassWriterImpl) classWriter, te, AnnotationTypeMemberWriterImpl.Kind.ANY);\n-    }\n-\n-    @Override\n-    public AnnotationTypeMemberWriterImpl getAnnotationTypeOptionalMemberWriter(\n-            ClassWriter classWriter) {\n-        TypeElement te = classWriter.getTypeElement();\n-        return new AnnotationTypeMemberWriterImpl(\n-                (ClassWriterImpl) classWriter, te, AnnotationTypeMemberWriterImpl.Kind.OPTIONAL);\n-    }\n-\n-    @Override\n-    public AnnotationTypeMemberWriterImpl getAnnotationTypeRequiredMemberWriter(\n-            ClassWriter classWriter) {\n-        TypeElement te = classWriter.getTypeElement();\n-        return new AnnotationTypeMemberWriterImpl(\n-            (ClassWriterImpl) classWriter, te, AnnotationTypeMemberWriterImpl.Kind.REQUIRED);\n-    }\n-\n-    @Override\n-    public EnumConstantWriterImpl getEnumConstantWriter(ClassWriter classWriter) {\n-        return new EnumConstantWriterImpl((ClassWriterImpl) classWriter,\n-                classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public FieldWriterImpl getFieldWriter(ClassWriter classWriter) {\n-        return new FieldWriterImpl((ClassWriterImpl) classWriter, classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public PropertyWriterImpl getPropertyWriter(ClassWriter classWriter) {\n-        return new PropertyWriterImpl((ClassWriterImpl) classWriter,\n-                classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public MethodWriterImpl getMethodWriter(ClassWriter classWriter) {\n-        return new MethodWriterImpl((ClassWriterImpl) classWriter, classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public ConstructorWriterImpl getConstructorWriter(ClassWriter classWriter) {\n-        return new ConstructorWriterImpl((ClassWriterImpl) classWriter,\n-                classWriter.getTypeElement());\n-    }\n-\n-    @Override\n-    public MemberSummaryWriter getMemberSummaryWriter(ClassWriter classWriter,\n-            VisibleMemberTable.Kind memberType) {\n-        switch (memberType) {\n-            case CONSTRUCTORS:\n-                return getConstructorWriter(classWriter);\n-            case ENUM_CONSTANTS:\n-                return getEnumConstantWriter(classWriter);\n-            case ANNOTATION_TYPE_MEMBER_OPTIONAL:\n-                return getAnnotationTypeOptionalMemberWriter(classWriter);\n-            case ANNOTATION_TYPE_MEMBER_REQUIRED:\n-                return getAnnotationTypeRequiredMemberWriter(classWriter);\n-            case FIELDS:\n-                return getFieldWriter(classWriter);\n-            case PROPERTIES:\n-                return getPropertyWriter(classWriter);\n-            case NESTED_CLASSES:\n-                return new NestedClassWriterImpl((SubWriterHolderWriter)\n-                    classWriter, classWriter.getTypeElement());\n-            case METHODS:\n-                return getMethodWriter(classWriter);\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    @Override\n-    public SerializedFormWriter getSerializedFormWriter() {\n-        return new SerializedFormWriterImpl(configuration);\n-    }\n-\n-    @Override\n-    public DocFilesHandler getDocFilesHandler(Element element) {\n-        return new DocFilesHandlerImpl(configuration, element);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/WriterFactoryImpl.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/BodyContents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Comment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/ContentBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Entity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Head.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlDocument.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Links.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/RawHtml.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n@@ -168,1 +167,1 @@\n-                    sb.append(\"\\\\\\'\");\n+                    sb.append(\"\\\\'\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Script.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Text.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/TextBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/BaseTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DeprecatedTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DocRootTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/IndexTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/InheritDocTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriter;\n@@ -51,1 +51,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n@@ -240,1 +240,1 @@\n-                if (htmlWriter instanceof ClassWriterImpl cw) {\n+                if (htmlWriter instanceof ClassWriter cw) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LiteralTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ParamTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ReturnTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriter;\n@@ -46,0 +46,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.SerializedFormWriter;\n@@ -49,2 +50,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n@@ -110,1 +110,1 @@\n-                htmlWriter instanceof ClassWriterImpl classWriter) {\n+                htmlWriter instanceof ClassWriter classWriter) {\n@@ -123,2 +123,2 @@\n-            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n-                    SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n+            if (SerializedFormWriter.serialInclude(utils, holder) &&\n+                    SerializedFormWriter.serialInclude(utils, utils.containingPackage(holder))) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SeeTaglet.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.source.doctree.UnknownBlockTagTree;\n@@ -46,1 +45,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n@@ -187,1 +186,1 @@\n-        return simpleBlockTagOutput(holder, tags, header, tagletWriter);\n+        return simpleBlockTagOutput(holder, tags, header);\n@@ -201,2 +200,1 @@\n-                                        String header,\n-                                        TagletWriter writer) {\n+                                        String header) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SimpleTaglet.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SnippetTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SpecTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SummaryTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SystemPropertyTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/Taglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ThrowsTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/UserTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.Content;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ValueTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;\n@@ -196,7 +194,1 @@\n-    protected void generateOtherFiles(ClassTree classTree) throws DocletException {\n-        BuilderFactory builderFactory = configuration.getBuilderFactory();\n-        AbstractBuilder constantsSummaryBuilder = builderFactory.getConstantsSummaryBuilder();\n-        constantsSummaryBuilder.build();\n-        AbstractBuilder serializedFormBuilder = builderFactory.getSerializedFormBuilder();\n-        serializedFormBuilder.build();\n-    }\n+    protected void generateOtherFiles(ClassTree classTree) throws DocletException { }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AbstractDoclet.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.Element;\n-\n-\/**\n- * The interface for writing annotation type required member output.\n- *\/\n-public interface AnnotationTypeMemberWriter extends MemberWriter {\n-\n-    \/**\n-     * Adds the annotation type member header.\n-     *\n-     * @return the content for the member header\n-     *\/\n-    Content getMemberHeader();\n-\n-    \/**\n-     * Adds the annotation type details marker.\n-     *\n-     * @param memberDetails the content representing details marker\n-     *\/\n-    void addAnnotationDetailsMarker(Content memberDetails);\n-\n-    \/**\n-     * Adds the annotation type details header.\n-     *\n-     * @return the content for the annotation details header\n-     *\/\n-    Content getAnnotationDetailsHeader();\n-\n-    \/**\n-     * Gets the annotation type documentation header.\n-     *\n-     * @param member the annotation type being documented\n-     * @return the content for the annotation type documentation header\n-     *\/\n-    Content getAnnotationHeaderContent(Element member);\n-\n-    \/**\n-     * Gets the annotation type details.\n-     *\n-     * @param annotationDetailsHeader the content representing annotation type details header\n-     * @param annotationDetails the content representing annotation type details\n-     * @return the annotation type details\n-     *\/\n-    Content getAnnotationDetails(Content annotationDetailsHeader, Content annotationDetails);\n-\n-    \/**\n-     * {@return the signature for the specified member}\n-     *\n-     * @param member the member being documented\n-     *\/\n-    Content getSignature(Element member);\n-\n-    \/**\n-     * Adds the deprecated output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param target the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(Element member, Content target);\n-\n-    \/**\n-     * Adds the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(Element member, Content content);\n-\n-    \/**\n-     * Adds the comments for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param annotationContent the content to which the comments will be added\n-     *\/\n-    void addComments(Element member, Content annotationContent);\n-\n-    \/**\n-     * Adds the tags for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param annotationContent the content to which the tags will be added\n-     *\/\n-    void addTags(Element member, Content annotationContent);\n-\n-    \/**\n-     * Adds the default value documentation if the member has one.\n-     *\n-     * @param member the member being documented\n-     * @param annotationContent the content to which the default value will be added\n-     *\/\n-    void addDefaultValueInfo(Element member, Content annotationContent);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AnnotationTypeMemberWriter.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -63,1 +63,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;\n@@ -90,5 +89,0 @@\n-    \/**\n-     * The factory for builders.\n-     *\/\n-    protected BuilderFactory builderFactory;\n-\n@@ -252,12 +246,0 @@\n-    \/**\n-     * Return the builder factory for this doclet.\n-     *\n-     * @return the builder factory for this doclet.\n-     *\/\n-    public BuilderFactory getBuilderFactory() {\n-        if (builderFactory == null) {\n-            builderFactory = new BuilderFactory(this);\n-        }\n-        return builderFactory;\n-    }\n-\n@@ -485,7 +467,0 @@\n-    \/**\n-     * Return the doclet specific instance of a writer factory.\n-     *\n-     * @return the {@link WriterFactory} for the doclet.\n-     *\/\n-    public abstract WriterFactory getWriterFactory();\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing class output.\n- *\/\n-public interface ClassWriter {\n-    \/**\n-     * Returns an instance of an output object.\n-     *\n-     * @return an instance of an output object\n-     *\/\n-    Content getOutputInstance();\n-\n-    \/**\n-     * Get the header of the page.\n-     *\n-     * @param header the header string to write\n-     * @return header content that needs to be added to the documentation\n-     *\/\n-    Content getHeader(String header);\n-\n-    \/**\n-     * Get the class content header.\n-     *\n-     * @return class content header that needs to be added to the documentation\n-     *\/\n-    Content getClassContentHeader();\n-\n-    \/**\n-     * Add the class inheritance tree documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addClassTree(Content target);\n-\n-    \/**\n-     * Add the type parameter and state component information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addParamInfo(Content target);\n-\n-    \/**\n-     * Add all superinterfaces if this is an interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addSuperInterfacesInfo(Content target);\n-\n-    \/**\n-     * Add all implemented interfaces if this is a class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addImplementedInterfacesInfo(Content target);\n-\n-    \/**\n-     * Add all the classes that extend this one.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addSubClassInfo(Content target);\n-\n-    \/**\n-     * Add all the interfaces that extend this one.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addSubInterfacesInfo(Content target);\n-\n-    \/**\n-     * If this is an interface, add all classes that implement this\n-     * interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addInterfaceUsageInfo(Content target);\n-\n-    \/**\n-     * If this is an functional interface, display appropriate message.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addFunctionalInterfaceInfo(Content target);\n-\n-    \/**\n-     * If this is an inner class or interface, add the enclosing class or\n-     * interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    void addNestedClassInfo(Content target);\n-\n-    \/**\n-     * {@return the class information}\n-     *\n-     * @param classInfo the class information\n-     *\/\n-    Content getClassInfo(Content classInfo);\n-\n-    \/**\n-     * If this class is deprecated, add the appropriate information.\n-     *\n-     * @param classInfo the content to which the documentation will be added\n-     *\/\n-    void addClassDeprecationInfo(Content classInfo);\n-\n-    \/**\n-     * Add the signature of the current class content.\n-     *\n-     * @param classInfo the class content to which the signature will be added\n-     *\/\n-    void addClassSignature(Content classInfo);\n-\n-    \/**\n-     * Build the class description.\n-     *\n-     * @param classInfo the content to which the documentation will be added\n-     *\/\n-    void addClassDescription(Content classInfo);\n-\n-    \/**\n-     * Add the tag information for the current class.\n-     *\n-     * @param classInfo the content to which the tag information will be added\n-     *\/\n-    void addClassTagInfo(Content classInfo);\n-\n-    \/**\n-     * Returns a list to be used for the list of summaries for members of a given kind.\n-     *\n-     * @return a list to be used for the list of summaries for members of a given kind\n-     *\/\n-    Content getSummariesList();\n-\n-    \/**\n-     * Returns an item for the list of summaries for members of a given kind.\n-     *\n-     * @param content content for the item\n-     * @return an item for the list of summaries for members of a given kind\n-     *\/\n-    Content getSummariesListItem(Content content);\n-\n-    \/**\n-     * Returns a list to be used for the list of details for members of a given kind.\n-     *\n-     * @return a list to be used for the list of details for members of a given kind\n-     *\/\n-    Content getDetailsList();\n-\n-    \/**\n-     * Returns an item for the list of details for members of a given kind.\n-     *\n-     * @param content content for the item\n-     * @return an item for the list of details for members of a given kind\n-     *\/\n-    Content getDetailsListItem(Content content);\n-\n-    \/**\n-     * Add the class content.\n-     *\n-     * @param classContent the class content which will be added to the content\n-     *\/\n-    void addClassContent(Content classContent);\n-\n-    \/**\n-     * Add the footer of the page.\n-     *\/\n-    void addFooter();\n-\n-    \/**\n-     * Print the document.\n-     *\n-     * @param content the content that will be printed as a document\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content content) throws DocFileIOException;\n-\n-    \/**\n-     * Return the TypeElement being documented.\n-     *\n-     * @return the TypeElement being documented.\n-     *\/\n-    TypeElement getTypeElement();\n-\n-    \/**\n-     * {@return the member summary}\n-     *\n-     * @param memberContent the content used to build the summary\n-     *\/\n-    Content getMemberSummary(Content memberContent);\n-\n-    \/**\n-     * {@return the member details}\n-     *\n-     * @param memberContent the content used to generate the member details\n-     *\/\n-    Content getMemberDetails(Content memberContent);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ClassWriter.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing constants summary output.\n- *\/\n-public interface ConstantsSummaryWriter {\n-\n-    \/**\n-     * Get the header for the constant summary documentation.\n-     *\n-     * @return header that needs to be added to the documentation\n-     *\/\n-    Content getHeader();\n-\n-    \/**\n-     * Get the header for the constant content list.\n-     *\n-     * @return content header that needs to be added to the documentation\n-     *\/\n-    Content getContentsHeader();\n-\n-    \/**\n-     * Adds the given package name link to the constant content list.\n-     *\n-     * @param abbrevPackageName the abbreviated package name\n-     * @param content       the content to which the link will be added\n-     *\/\n-    void addLinkToPackageContent(String abbrevPackageName, Content content);\n-\n-    \/**\n-     * Add the content list to the documentation.\n-     *\n-     * @param content the content that will be added to the list\n-     *\/\n-    void addContentsList(Content content);\n-\n-    \/**\n-     * Get the constant summaries for the document.\n-     *\n-     * @return constant summaries header to be added to the documentation\n-     *\/\n-    Content getConstantSummaries();\n-\n-    \/**\n-     * Adds a header for the given abbreviated package name.\n-     *\n-     * @param abbrevPackageName  the abbreviated package name\n-     * @param toContent the summaries documentation\n-     *\/\n-    void addPackageGroup(String abbrevPackageName, Content toContent);\n-\n-    \/**\n-     * Get the class summary header for the constants summary.\n-     *\n-     * @return the header content for the class constants summary\n-     *\/\n-    Content getClassConstantHeader();\n-\n-    \/**\n-     * Add the content list to the documentation summaries.\n-     *\n-     * @param fromClassConstant the class constant content that will be added to the list\n-     *\/\n-    void addClassConstant(Content fromClassConstant);\n-\n-    \/**\n-     * Adds the constant member table to the documentation.\n-     *\n-     * @param typeElement the class whose constants are being documented.\n-     * @param fields the constants being documented.\n-     * @param target the content to which the constant member\n-     *               table content will be added\n-     *\/\n-    void addConstantMembers(TypeElement typeElement, Collection<VariableElement> fields,\n-                            Content target);\n-\n-    \/**\n-     * Add the summaries list to the content.\n-     *\n-     * @param content the summaries content that will be added to the list\n-     *\/\n-    void addConstantSummaries(Content content);\n-\n-    \/**\n-     * Adds the footer for the summary documentation.\n-     *\/\n-    void addFooter();\n-\n-    \/**\n-     * Print the constants summary document.\n-     *\n-     * @param content the content which should be printed\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content content) throws DocFileIOException;\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ConstantsSummaryWriter.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.ExecutableElement;\n-\n-\/**\n- * The interface for writing constructor output.\n- *\/\n-public interface ConstructorWriter extends MemberWriter {\n-\n-    \/**\n-     * {@return the constructor details header}\n-     *\n-     * @param content the content representing member details\n-     *\/\n-    Content getConstructorDetailsHeader(Content content);\n-\n-    \/**\n-     * {@return the constructor documentation header}\n-     *\n-     * @param constructor the constructor being documented\n-     *\/\n-    Content getConstructorHeaderContent(ExecutableElement constructor);\n-\n-    \/**\n-     * {@return the signature for the given constructor}\n-     *\n-     * @param constructor the constructor being documented\n-     *\/\n-    Content getSignature(ExecutableElement constructor);\n-\n-    \/**\n-     * Add the deprecated output for the given constructor.\n-     *\n-     * @param constructor the constructor being documented\n-     * @param constructorContent the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(ExecutableElement constructor, Content constructorContent);\n-\n-    \/**\n-     * Add the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(ExecutableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given constructor.\n-     *\n-     * @param constructor the constructor being documented\n-     * @param constructorContent the content to which the comments will be added\n-     *\/\n-    void addComments(ExecutableElement constructor, Content constructorContent);\n-\n-    \/**\n-     * Add the tags for the given constructor.\n-     *\n-     * @param constructor the constructor being documented\n-     * @param constructorContent the content to which the tags will be added\n-     *\/\n-    void addTags(ExecutableElement constructor, Content constructorContent);\n-\n-    \/**\n-     * {@return the constructor details}\n-     *\n-     * @param memberDetailsHeader the content representing member details header\n-     * @param memberDetails the content representing member details\n-     *\/\n-    Content getConstructorDetails(Content memberDetailsHeader, Content memberDetails);\n-\n-    \/**\n-     * Let the writer know whether a non public constructor was found.\n-     *\n-     * @param foundNonPubConstructor true if we found a non public constructor.\n-     *\/\n-    void setFoundNonPubConstructor(boolean foundNonPubConstructor);\n-\n-    \/**\n-     * @return the member header}\n-     *\/\n-    Content getMemberHeader();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ConstructorWriter.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import java.util.List;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-\n-\/**\n- * The interface for copying doc-files to the output.\n- *\/\n-public interface DocFilesHandler {\n-    void copyDocFiles() throws DocletException;\n-    List<DocPath> getStylesheets() throws DocletException;\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/DocFilesHandler.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-\/**\n- * The interface for writing enum constant output.\n- *\/\n-public interface EnumConstantWriter extends MemberWriter {\n-\n-    \/**\n-     * Get the enum constants details header.\n-     *\n-     * @param typeElement the class being documented\n-     * @param memberDetails the content representing member details\n-     * @return a content for the enum constants details header\n-     *\/\n-    Content getEnumConstantsDetailsHeader(TypeElement typeElement,\n-                                          Content memberDetails);\n-\n-    \/**\n-     * Get the enum constants documentation header.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @param enumConstantsDetails the content representing enum constant details\n-     * @return the enum constant documentation header\n-     *\/\n-    Content getEnumConstantsHeader(VariableElement enumConstant,\n-                                   Content enumConstantsDetails);\n-\n-    \/**\n-     * Get the signature for the given enum constant.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @return the enum constant signature\n-     *\/\n-    Content getSignature(VariableElement enumConstant);\n-\n-    \/**\n-     * Add the deprecated output for the given enum constant.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @param content the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(VariableElement enumConstant, Content content);\n-\n-    \/**\n-     * Add the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(VariableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given enum constant.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @param enumConstants the content to which the comments will be added\n-     *\/\n-    void addComments(VariableElement enumConstant, Content enumConstants);\n-\n-    \/**\n-     * Add the tags for the given enum constant.\n-     *\n-     * @param enumConstant the enum constant being documented\n-     * @param content the content to which the tags will be added\n-     *\/\n-    void addTags(VariableElement enumConstant, Content content);\n-\n-    \/**\n-     * Get the enum constants details.\n-     *\n-     * @param memberDetailsHeader member details header\n-     * @param content the content representing member details\n-     * @return the enum constant details\n-     *\/\n-    Content getEnumConstantsDetails(Content memberDetailsHeader, Content content);\n-\n-    \/**\n-     * Gets the member header.\n-     *\n-     * @return the member header\n-     *\/\n-    Content getMemberHeader();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/EnumConstantWriter.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.VariableElement;\n-\n-\/**\n- * The interface for writing field output.\n- *\/\n-public interface FieldWriter extends MemberWriter {\n-\n-    \/**\n-     * Get the field details header.\n-     *\n-     * @param content the content representing member details\n-     * @return the field details header\n-     *\/\n-    Content getFieldDetailsHeader(Content content);\n-\n-    \/**\n-     * Get the field documentation header.\n-     *\n-     * @param field the constructor being documented\n-     * @return the field documentation header\n-     *\/\n-    Content getFieldHeaderContent(VariableElement field);\n-\n-    \/**\n-     * Get the signature for the given field.\n-     *\n-     * @param field the field being documented\n-     * @return the field signature\n-     *\/\n-    Content getSignature(VariableElement field);\n-\n-    \/**\n-     * Add the deprecated output for the given field.\n-     *\n-     * @param field the field being documented\n-     * @param fieldContent the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(VariableElement field, Content fieldContent);\n-\n-    \/**\n-     * Adds the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(VariableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given field.\n-     *\n-     * @param field the field being documented\n-     * @param fieldContent the content to which the comments will be added\n-     *\/\n-    void addComments(VariableElement field, Content fieldContent);\n-\n-    \/**\n-     * Add the tags for the given field.\n-     *\n-     * @param field the field being documented\n-     * @param fieldContent the content to which the tags will be added\n-     *\/\n-    void addTags(VariableElement field, Content fieldContent);\n-\n-    \/**\n-     * Get the field details.\n-     *\n-     * @param memberDetailsHeaderContent the content representing member details header\n-     * @param memberContent the content representing member details\n-     * @return the field details\n-     *\/\n-    Content getFieldDetails(Content memberDetailsHeaderContent, Content memberContent);\n-\n-    \/**\n-     * Gets the member header.\n-     *\n-     * @return the member header\n-     *\/\n-    Content getMemberHeader();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/FieldWriter.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-\/**\n- * The interface for writing member summary output.\n- *\/\n-public interface MemberSummaryWriter {\n-\n-    \/**\n-     * Returns the member summary header for the given class.\n-     *\n-     * @param typeElement the class the summary belongs to\n-     * @param content     the content to which the member summary will be added\n-     *\n-     * @return the member summary header\n-     *\/\n-    Content getMemberSummaryHeader(TypeElement typeElement, Content content);\n-\n-    \/**\n-     * Returns the summary table for the given class.\n-     *\n-     * @param typeElement the class the summary table belongs to\n-     *\n-     * @return the summary table\n-     *\/\n-    Content getSummaryTable(TypeElement typeElement);\n-\n-    \/**\n-     * Adds the member summary for the given class and member.\n-     *\n-     * @param typeElement        the class the summary belongs to\n-     * @param member             the member that is documented\n-     * @param firstSentenceTrees the tags for the sentence being documented\n-     *\/\n-    void addMemberSummary(TypeElement typeElement, Element member,\n-                          List<? extends DocTree> firstSentenceTrees);\n-\n-    \/**\n-     * Returns the inherited member summary header for the given class.\n-     *\n-     * @param typeElement the class the summary belongs to\n-     *\n-     * @return the inherited member summary header\n-     *\/\n-    Content getInheritedSummaryHeader(TypeElement typeElement);\n-\n-    \/**\n-     * Adds the inherited member summary for the given class and member.\n-     *\n-     * @param typeElement the class the inherited member belongs to\n-     * @param member the inherited member that is being documented\n-     * @param isFirst true if this is the first member in the list\n-     * @param isLast true if this is the last member in the list\n-     * @param content the content to which the links will be added\n-     *\/\n-    void addInheritedMemberSummary(TypeElement typeElement,\n-                                   Element member, boolean isFirst, boolean isLast,\n-                                   Content content);\n-\n-    \/**\n-     * Returns the inherited summary links.\n-     *\n-     * @return the inherited summary links\n-     *\/\n-    Content getInheritedSummaryLinks();\n-\n-    \/**\n-     * Adds the given summary to the list of summaries.\n-     *\n-     * @param summariesList the list of summaries\n-     * @param content       the summary\n-     *\/\n-    void addSummary(Content summariesList, Content content);\n-\n-    \/**\n-     * Returns the member content.\n-     *\n-     * @param memberContent the content representing the member\n-     *\n-     * @return the member content\n-     *\/\n-    Content getMember(Content memberContent);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/MemberSummaryWriter.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-\/**\n- * Common behavior for writing members of a type.\n- *\/\n-public interface MemberWriter {\n-\n-    \/**\n-     * {@return a list to add member items to}\n-     *\n-     * @see #getMemberListItem(Content)\n-     *\/\n-    Content getMemberList();\n-\n-    \/**\n-     * {@return a member item}\n-     *\n-     * @param member the member to represent as an item\n-     * @see #getMemberList()\n-     *\/\n-    Content getMemberListItem(Content member);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/MemberWriter.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-\/**\n- * The interface for writing method output.\n- *\/\n-public interface MethodWriter extends MemberWriter {\n-\n-    \/**\n-     * Get the method details header.\n-     *\n-     * @param content the content representing member details\n-     * @return the method details header\n-     *\/\n-    Content getMethodDetailsHeader(Content content);\n-\n-    \/**\n-     * Get the method documentation header.\n-     *\n-     * @param method the method being documented\n-     * @return the method documentation header\n-     *\/\n-    Content getMethodHeader(ExecutableElement method);\n-\n-    \/**\n-     * Get the signature for the given method.\n-     *\n-     * @param method the method being documented\n-     * @return the method signature\n-     *\/\n-    Content getSignature(ExecutableElement method);\n-\n-    \/**\n-     * Add the deprecated output for the given method.\n-     *\n-     * @param method the method being documented\n-     * @param methodContent the content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(ExecutableElement method, Content methodContent);\n-\n-    \/**\n-     * Adds the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(ExecutableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given method.\n-     *\n-     * @param holder the holder type (not erasure) of the method\n-     * @param method the method being documented\n-     * @param methodContent the content to which the comments will be added\n-     *\/\n-    void addComments(TypeMirror holder, ExecutableElement method, Content methodContent);\n-\n-    \/**\n-     * Add the tags for the given method.\n-     *\n-     * @param method the method being documented\n-     * @param methodContent the content to which the tags will be added\n-     *\/\n-    void addTags(ExecutableElement method, Content methodContent);\n-\n-    \/**\n-     * Get the method details.\n-     *\n-     * @param methodDetailsHeader the content representing method details header\n-     * @param methodDetails the content representing method details\n-     * @return the method details\n-     *\/\n-    Content getMethodDetails(Content methodDetailsHeader, Content methodDetails);\n-\n-    \/**\n-     * Gets the member header.\n-     *\n-     * @return the member header\n-     *\/\n-    Content getMemberHeader();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/MethodWriter.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing module summary output.\n- *\/\n-public interface ModuleSummaryWriter {\n-\n-    \/**\n-     * Get the header for the summary.\n-     *\n-     * @param heading module name.\n-     * @return the header to be added to the content\n-     *\/\n-    Content getModuleHeader(String heading);\n-\n-    \/**\n-     * Get the header for the module content.\n-     *\n-     * @return the module content header\n-     *\/\n-    Content getContentHeader();\n-\n-    \/**\n-     * Get the header for the summary header.\n-     *\n-     * @return the summary header\n-     *\/\n-    Content getSummariesList();\n-\n-    \/**\n-     * Wrap the content into summary section.\n-     *\n-     * @param source the content to wrap into the summary section\n-     * @return the summary\n-     *\/\n-    Content getSummary(Content source);\n-\n-    \/**\n-     * Adds the module description.\n-     *\n-     * @param moduleContent the content to which the module description\n-     *                      will be added\n-     *\/\n-    void addModuleDescription(Content moduleContent);\n-\n-    \/**\n-     * Adds the module signature.\n-     *\n-     * @param moduleContent the content to which the module signature\n-     *                      will be added\n-     *\/\n-    void addModuleSignature(Content moduleContent);\n-\n-    \/**\n-     * Adds the summary of modules to the list of summaries.\n-     *\n-     * @param summariesList the list of summaries\n-     *\/\n-    void addModulesSummary(Content summariesList);\n-\n-    \/**\n-     * Adds the summary of packages to the list of summaries.\n-     *\n-     * @param summariesList the list of summaries\n-     *\/\n-    void addPackagesSummary(Content summariesList);\n-\n-    \/**\n-     * Adds the summary of services to the list of summaries.\n-     *\n-     * @param summariesList the list of summaries\n-     *\/\n-    void addServicesSummary(Content summariesList);\n-\n-    \/**\n-     * Adds the module content to the documentation.\n-     *\n-     * @param source the content that will be added\n-     *\/\n-    void addModuleContent(Content source);\n-\n-    \/**\n-     * Adds the footer to the documentation.\n-     *\/\n-    void addModuleFooter();\n-\n-    \/**\n-     * Print the module summary document.\n-     *\n-     * @param content the content that will be printed\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content content) throws DocFileIOException;\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ModuleSummaryWriter.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-\/**\n- * The interface for writing class output.\n- *\/\n-public interface NestedClassWriter {\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/NestedClassWriter.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import java.util.List;\n-import java.util.SortedSet;\n-\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing package summary output.\n- *\/\n-public interface PackageSummaryWriter {\n-\n-    \/**\n-     * Get the header for the summary.\n-     *\n-     * @return the header to be added to the content\n-     *\/\n-    Content getPackageHeader();\n-\n-    \/**\n-     * Get the header for the package content.\n-     *\n-     * @return the package content header\n-     *\/\n-    Content getContentHeader();\n-\n-    \/**\n-     * Get the header for the package summary.\n-     *\n-     * @return the package summary header\n-     *\/\n-    Content getSummariesList();\n-\n-    \/**\n-     * Adds the table of related packages to the documentation.\n-     *\n-     * @param summaryContent the content to which the summaries will be added\n-     *\/\n-    void addRelatedPackagesSummary(Content summaryContent);\n-\n-    \/**\n-     * Adds the table of all classes and interfaces to the documentation.\n-     *\n-     * @param summaryContent the content to which the summaries will be added\n-     *\/\n-    void addAllClassesAndInterfacesSummary(Content summaryContent);\n-\n-    \/**\n-     * Adds the package description from the \"packages.html\" file to the documentation.\n-     *\n-     * @param packageContent the content to which the package description\n-     *                       will be added\n-     *\/\n-    void addPackageDescription(Content packageContent);\n-\n-    \/**\n-     * Adds the tag information from the \"packages.html\" file to the documentation.\n-     *\n-     * @param packageContent the content to which the package tags will\n-     *                       be added\n-     *\/\n-    void addPackageTags(Content packageContent);\n-\n-    \/**\n-     * Adds the package signature.\n-     *\n-     * @param packageContent the content to which the package signature\n-     *                       will be added\n-     *\/\n-    void addPackageSignature(Content packageContent);\n-\n-    \/**\n-     * Adds the tag information from the \"packages.html\" or \"package-info.java\" file to the\n-     * documentation.\n-     *\n-     * @param packageContent the package content to be added\n-     *\/\n-    void addPackageContent(Content packageContent);\n-\n-    \/**\n-     * Adds the footer to the documentation.\n-     *\/\n-    void addPackageFooter();\n-\n-    \/**\n-     * Print the package summary document.\n-     *\n-     * @param content the content that will be printed\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content content) throws DocFileIOException;\n-\n-    \/**\n-     * Gets the package summary.\n-     * @param summaryContent the content representing the package summary\n-     * @return the package summary\n-     *\/\n-    Content getPackageSummary(Content summaryContent);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/PackageSummaryWriter.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -28,0 +28,4 @@\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n@@ -29,0 +33,2 @@\n+\n+import javax.lang.model.element.Element;\n@@ -30,0 +36,2 @@\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n@@ -32,0 +40,1 @@\n+import javax.lang.model.util.ElementFilter;\n@@ -33,0 +42,8 @@\n+import javax.tools.Diagnostic;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.PROPERTIES;\n@@ -172,0 +189,88 @@\n+\n+\n+    \/**\n+     * A utility class to manage the property-related methods that should be\n+     * synthesized or updated.\n+     *\n+     * A property may comprise a field (that is typically private, if present),\n+     * a {@code fooProperty()} method (which is the defining characteristic for\n+     * a property), a {@code getFoo()} method and\/or a {@code setFoo(Foo foo)} method.\n+     *\n+     * Either the field (if present) or the {@code fooProperty()} method should have a\n+     * comment. If there is no field, or no comment on the field, the description for\n+     * the property will be derived from the description of the {@code fooProperty()}\n+     * method. If any method does not have a comment, one will be provided.\n+     *\/\n+    public static class PropertyHelper {\n+        private final BaseConfiguration configuration;\n+        private final Utils utils;\n+        private final TypeElement typeElement;\n+\n+        private final Map<Element, Element> classPropertiesMap = new HashMap<>();\n+\n+        public PropertyHelper(BaseConfiguration configuration, TypeElement typeElement) {\n+            this.configuration = configuration;\n+            this.utils = configuration.utils;\n+            this.typeElement = typeElement;\n+            computeProperties();\n+        }\n+\n+        private void computeProperties() {\n+            VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n+            List<ExecutableElement> props = ElementFilter.methodsIn(vmt.getVisibleMembers(PROPERTIES));\n+            for (ExecutableElement propertyMethod : props) {\n+                ExecutableElement getter = vmt.getPropertyGetter(propertyMethod);\n+                ExecutableElement setter = vmt.getPropertySetter(propertyMethod);\n+                VariableElement field = vmt.getPropertyField(propertyMethod);\n+\n+                addToPropertiesMap(propertyMethod, field, getter, setter);\n+            }\n+        }\n+\n+        private void addToPropertiesMap(ExecutableElement propertyMethod,\n+                                        VariableElement field,\n+                                        ExecutableElement getter,\n+                                        ExecutableElement setter) {\n+            \/\/ determine the preferred element from which to derive the property description\n+            Element e = field == null || !utils.hasDocCommentTree(field)\n+                    ? propertyMethod : field;\n+\n+            if (e == field && utils.hasDocCommentTree(propertyMethod)) {\n+                configuration.getReporter().print(Diagnostic.Kind.WARNING,\n+                        propertyMethod, configuration.getDocResources().getText(\"doclet.duplicate.comment.for.property\"));\n+            }\n+\n+            addToPropertiesMap(propertyMethod, e);\n+            addToPropertiesMap(getter, e);\n+            addToPropertiesMap(setter, e);\n+        }\n+\n+        private void addToPropertiesMap(Element propertyMethod,\n+                                        Element commentSource) {\n+            Objects.requireNonNull(commentSource);\n+            if (propertyMethod == null) {\n+                return;\n+            }\n+\n+            DocCommentTree docTree = utils.hasDocCommentTree(propertyMethod)\n+                    ? utils.getDocCommentTree(propertyMethod)\n+                    : null;\n+\n+            \/* The second condition is required for the property buckets. In\n+             * this case the comment is at the property method (not at the field)\n+             * and it needs to be listed in the map.\n+             *\/\n+            if ((docTree == null) || propertyMethod.equals(commentSource)) {\n+                classPropertiesMap.put(propertyMethod, commentSource);\n+            }\n+        }\n+\n+        \/**\n+         * Returns the element for the property documentation belonging to the given member.\n+         * @param element the member for which the property documentation is needed.\n+         * @return the element for the property documentation, null if there is none.\n+         *\/\n+        public Element getPropertyElement(Element element) {\n+            return classPropertiesMap.get(element);\n+        }\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/PropertyUtils.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.ExecutableElement;\n-\n-\/**\n- * The interface for writing property output.\n- *\/\n-public interface PropertyWriter extends MemberWriter {\n-\n-    \/**\n-     * Get the property details header.\n-     *\n-     * @param memberDetails the content representing member details\n-     * @return the property details header\n-     *\/\n-    Content getPropertyDetailsHeader(Content memberDetails);\n-\n-    \/**\n-     * Get the property documentation header.\n-     *\n-     * @param property the property being documented\n-     * @return the property documentation header\n-     *\/\n-    Content getPropertyHeaderContent(ExecutableElement property);\n-\n-    \/**\n-     * Get the signature for the given property.\n-     *\n-     * @param property the property being documented\n-     * @return the property signature\n-     *\/\n-    Content getSignature(ExecutableElement property);\n-\n-    \/**\n-     * Add the deprecated output for the given property.\n-     *\n-     * @param property the property being documented\n-     * @param propertyContent content to which the deprecated information will be added\n-     *\/\n-    void addDeprecated(ExecutableElement property, Content propertyContent);\n-\n-    \/**\n-     * Add the preview output for the given member.\n-     *\n-     * @param member the member being documented\n-     * @param content the content to which the preview information will be added\n-     *\/\n-    void addPreview(ExecutableElement member, Content content);\n-\n-    \/**\n-     * Add the comments for the given property.\n-     *\n-     * @param property the property being documented\n-     * @param propertyContent the content to which the comments will be added\n-     *\/\n-    void addComments(ExecutableElement property, Content propertyContent);\n-\n-    \/**\n-     * Add the tags for the given property.\n-     *\n-     * @param property the property being documented\n-     * @param propertyContent the content to which the tags will be added\n-     *\/\n-    void addTags(ExecutableElement property, Content propertyContent);\n-\n-    \/**\n-     * Get the property details.\n-     *\n-     * @param memberDetailsHeader the content representing member details header\n-     * @param memberDetails the content representing member details\n-     * @return the property details\n-     *\/\n-    Content getPropertyDetails(Content memberDetailsHeader, Content memberDetails);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/PropertyWriter.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,303 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.SerialFieldTree;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-\n-\/**\n- * The interface for writing serialized form output.\n- *\/\n-public interface SerializedFormWriter {\n-\n-    \/**\n-     * Get the header.\n-     *\n-     * @param header the header to write.\n-     * @return the header content\n-     *\/\n-    Content getHeader(String header);\n-\n-    \/**\n-     * Get the serialized form summaries header.\n-     *\n-     * @return the serialized form summary header\n-     *\/\n-    Content getSerializedSummariesHeader();\n-\n-    \/**\n-     * Get the package serialized form header.\n-     *\n-     * @return the package serialized form header\n-     *\/\n-    Content getPackageSerializedHeader();\n-\n-    \/**\n-     * Add the serialized package to the serialized summaries.\n-     *\n-     * @param serializedSummaries the serialized content to which the package serialized content will be added\n-     * @param packageSerialized the serialized content per package that needs to be added\n-     *\/\n-    void addPackageSerialized(Content serializedSummaries, Content packageSerialized);\n-\n-    \/**\n-     * {@return a header for the given package}\n-     *\n-     * @param packageElement the package element to write\n-     *\/\n-    Content getPackageHeader(PackageElement packageElement);\n-\n-    \/**\n-     * {@return the serialized class header}\n-     *\/\n-    Content getClassSerializedHeader();\n-\n-    \/**\n-     * {@return the heading for the serializable class}\n-     *\n-     * @param typeElement the class being processed\n-     *\/\n-    Content getClassHeader(TypeElement typeElement);\n-\n-    \/**\n-     * {@return the serial UID info header}\n-     *\/\n-    Content getSerialUIDInfoHeader();\n-\n-    \/**\n-     * Adds the serial UID info.\n-     *\n-     * @param header the header that will show up before the UID.\n-     * @param serialUID the serial UID to print.\n-     * @param target the serial UID to which the content will be added.\n-     *\/\n-    void addSerialUIDInfo(String header, String serialUID, Content target);\n-\n-    \/**\n-     * {@return the serialized class header}\n-     *\/\n-    Content getClassContentHeader();\n-\n-    \/**\n-     * Return an instance of a SerialFieldWriter for a class.\n-     *\n-     * @param typeElement the class\n-     * @return an instance of a SerialFieldWriter.\n-     *\/\n-    SerialFieldWriter getSerialFieldWriter(TypeElement typeElement);\n-\n-    \/**\n-     * Return an instance of a SerialMethodWriter for a class.\n-     *\n-     * @param typeElement the class\n-     * @return an instance of a SerialMethodWriter.\n-     *\/\n-    SerialMethodWriter getSerialMethodWriter(TypeElement typeElement);\n-\n-    \/**\n-     * Add the serialized content to the body content.\n-     *\n-     * @param source content for serialized data\n-     *\/\n-    void addSerializedContent(Content source);\n-\n-    \/**\n-     * Add the footer.\n-     *\/\n-    void addFooter();\n-\n-    \/**\n-     * Print the serialized form document.\n-     *\n-     * @param source the content that will be printed\n-     * @throws DocFileIOException if there is a problem while writing the document\n-     *\/\n-    void printDocument(Content source) throws DocFileIOException;\n-\n-    \/**\n-     * Gets the member.\n-     *\n-     * @param content the content used to generate the complete member\n-     * @return the member\n-     *\/\n-    Content getMember(Content content);\n-\n-    \/**\n-     * A writer for the serialized form for a given field.\n-     *\/\n-    interface SerialFieldWriter {\n-\n-        \/**\n-         * {@return the serializable field header}\n-         *\/\n-        Content getSerializableFieldsHeader();\n-\n-        \/**\n-         * {@return the field content header}\n-         *\n-         * @param isLastContent true if this is the last content to be documented\n-         *\/\n-        Content getFieldsContentHeader(boolean isLastContent);\n-\n-        \/**\n-         * {@return the fields}\n-         *\n-         * @param heading the heading to write.\n-         * @param content the content to be added\n-         * @return serializable fields content\n-         *\/\n-        Content getSerializableFields(String heading, Content content);\n-\n-        \/**\n-         * Adds the deprecated information for this member.\n-         *\n-         * @param field the field to document.\n-         * @param content the content to which the deprecated information will be added\n-         *\/\n-        void addMemberDeprecatedInfo(VariableElement field, Content content);\n-\n-        \/**\n-         * Adds the description text for this member.\n-         *\n-         * @param field the field to document\n-         * @param content the content to which the member description will be added\n-         *\/\n-        void addMemberDescription(VariableElement field, Content content);\n-\n-        \/**\n-         * Adds the description text for this member represented by the tag.\n-         *\n-         * @param field the field to document\n-         * @param serialFieldTag the field to document (represented by tag)\n-         * @param content the content to which the member description will be added\n-         *\/\n-        void addMemberDescription(VariableElement field, SerialFieldTree serialFieldTag, Content content);\n-\n-        \/**\n-         * Adds the tag information for this member.\n-         *\n-         * @param field the field to document\n-         * @param content the content to which the member tags will be added\n-         *\/\n-        void addMemberTags(VariableElement field, Content content);\n-\n-        \/**\n-         * Adds the member header.\n-         *\n-         * @param fieldType the type of the field\n-         * @param fieldName the name of the field\n-         * @param content the content to which the member header will be added\n-         *\/\n-        void addMemberHeader(TypeMirror fieldType, String fieldName, Content content);\n-\n-        \/**\n-         * Check to see if overview details should be printed. If\n-         * nocomment option set or if there is no text to be printed\n-         * for deprecation info, inline comment or tags,\n-         * do not print overview details.\n-         *\n-         * @param field the field to check overview details for\n-         * @return true if overview details need to be printed\n-         *\/\n-        boolean shouldPrintOverview(VariableElement field);\n-    }\n-\n-    \/**\n-     * Write the serialized form for a given field.\n-     *\/\n-    interface SerialMethodWriter {\n-\n-        \/**\n-         * {@return the header for serializable methods section}\n-         *\/\n-        Content getSerializableMethodsHeader();\n-\n-        \/**\n-         * {@return the header for serializable methods content section}\n-         *\n-         * @param isLastContent true if the content being documented is the last content\n-         *\/\n-        Content getMethodsContentHeader(boolean isLastContent);\n-\n-        \/**\n-         * Gets the given heading.\n-         *\n-         * @param heading the heading to write\n-         * @param source the content which will be added\n-         * @return a serializable methods content\n-         *\/\n-        Content getSerializableMethods(String heading, Content source);\n-\n-        \/**\n-         * Gets a warning that no serializable methods exist.\n-         *\n-         * @param msg the warning to print\n-         * @return a no customization message\n-         *\/\n-        Content getNoCustomizationMsg(String msg);\n-\n-        \/**\n-         * Adds the header.\n-         *\n-         * @param member the member to write the header for\n-         * @param methodsContent the content to which the header will be added\n-         *\/\n-        void addMemberHeader(ExecutableElement member, Content methodsContent);\n-\n-        \/**\n-         * Adds the deprecated information for this member.\n-         *\n-         * @param member the member to write the deprecated information for\n-         * @param methodsContent the content to which the deprecated\n-         * information will be added\n-         *\/\n-        void addDeprecatedMemberInfo(ExecutableElement member, Content methodsContent);\n-\n-        \/**\n-         * Adds the description for this member.\n-         *\n-         * @param member the member to write the information for\n-         * @param methodsContent the content to which the member\n-         * information will be added\n-         *\/\n-        void addMemberDescription(ExecutableElement member, Content methodsContent);\n-\n-        \/**\n-         * Adds the tag information for this member.\n-         *\n-         * @param member the member to write the tags information for\n-         * @param methodsContent the content to which the tags\n-         * information will be added\n-         *\/\n-        void addMemberTags(ExecutableElement member, Content methodsContent);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/SerializedFormWriter.java","additions":0,"deletions":303,"binary":false,"changes":303,"status":"deleted"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-\/**\n- * The interface for a factory creates writers.\n- *\/\n-public interface WriterFactory {\n-\n-    \/**\n-     * Return the writer for the constant summary.\n-     *\n-     * @return the writer for the constant summary.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    ConstantsSummaryWriter getConstantsSummaryWriter();\n-\n-    \/**\n-     * Return the writer for the package summary.\n-     *\n-     * @param packageElement the package being documented\n-     * @return the writer for the package summary.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    PackageSummaryWriter getPackageSummaryWriter(PackageElement packageElement);\n-\n-    \/**\n-     * Return the writer for the module summary.\n-     *\n-     * @param mdle the module being documented\n-     * @return the writer for the module summary.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    ModuleSummaryWriter getModuleSummaryWriter(ModuleElement mdle);\n-\n-    \/**\n-     * Returns the writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param typeElement the class being documented\n-     * @param classTree   the class tree\n-     * @return the writer\n-     *\/\n-    ClassWriter getClassWriter(TypeElement typeElement, ClassTree classTree);\n-\n-    \/**\n-     * Return the method writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the class being documented\n-     * @return the method writer\n-     *\/\n-    MethodWriter getMethodWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the annotation type member writer for a given annotation\n-     * type, or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the annotation type being documented\n-     * @return the member writer\n-     *\/\n-    AnnotationTypeMemberWriter getAnnotationTypeMemberWriter(\n-            ClassWriter classWriter);\n-\n-    \/**\n-     * Return the annotation type optional member writer for a given annotation\n-     * type, or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the annotation type being documented\n-     * @return the member writer\n-     *\/\n-    AnnotationTypeMemberWriter getAnnotationTypeOptionalMemberWriter(\n-            ClassWriter classWriter);\n-\n-    \/**\n-     * Return the annotation type required member writer for a given annotation\n-     * type, or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the annotation type being documented\n-     * @return the member writer\n-     *\/\n-    AnnotationTypeMemberWriter getAnnotationTypeRequiredMemberWriter(\n-            ClassWriter classWriter);\n-\n-    \/**\n-     * Return the enum constant writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the type element being documented\n-     * @return the enum constant writer\n-     *\/\n-    EnumConstantWriter getEnumConstantWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the field writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the class being documented\n-     * @return the field writer for the given class.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    FieldWriter getFieldWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the property writer for a given class,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the type element being documented\n-     * @return the property writer\n-     *\/\n-    PropertyWriter getPropertyWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the constructor writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the type element being documented\n-     * @return the constructor writer\n-     *\/\n-    ConstructorWriter getConstructorWriter(ClassWriter classWriter);\n-\n-    \/**\n-     * Return the specified member summary writer for a given type element,\n-     * or null if this writer is not supported by the doclet.\n-     *\n-     * @param classWriter the writer for the class being documented\n-     * @param memberType  the {@link VisibleMemberTable} member type indicating\n-     *                    the type of member summary that should be returned\n-     * @return the summary writer\n-     *\n-     * @see VisibleMemberTable\n-     *\/\n-    MemberSummaryWriter getMemberSummaryWriter(ClassWriter classWriter,\n-                                               VisibleMemberTable.Kind memberType);\n-\n-    \/**\n-     * Return the writer for the serialized form.\n-     *\n-     * @return the writer for the serialized form\n-     *\/\n-    SerializedFormWriter getSerializedFormWriter();\n-\n-    \/**\n-     * Return the handler for doc files.\n-     *\n-     * @return the handler for the doc files\n-     *\/\n-    DocFilesHandler getDocFilesHandler(Element pkg);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WriterFactory.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.PackageElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\n-\/**\n- * The superclass for all builders.  A builder is a class that provides\n- * the structure and content of API documentation.  A builder is completely\n- * doclet independent which means that any doclet can use builders to\n- * construct documentation, as long as it implements the appropriate\n- * writer interfaces.  For example, if a doclet wanted to use\n- * {@link ConstantsSummaryBuilder} to build a constant summary, all it has to\n- * do is implement the ConstantsSummaryWriter interface and pass it to the\n- * builder using a WriterFactory.\n- *\/\n-public abstract class AbstractBuilder {\n-    public static class Context {\n-        \/**\n-         * The configuration used in this run of the doclet.\n-         *\/\n-        final BaseConfiguration configuration;\n-\n-        \/**\n-         * Keep track of which packages we have seen for\n-         * efficiency purposes.  We don't want to copy the\n-         * doc files multiple times for a single package.\n-         *\/\n-        final Set<PackageElement> containingPackagesSeen;\n-\n-        Context(BaseConfiguration configuration, Set<PackageElement> containingPackagesSeen) {\n-            this.configuration = configuration;\n-            this.containingPackagesSeen = containingPackagesSeen;\n-        }\n-    }\n-\n-    \/**\n-     * The configuration used in this run of the doclet.\n-     *\/\n-    protected final BaseConfiguration configuration;\n-    protected final BaseOptions options;\n-\n-    protected final BuilderFactory builderFactory;\n-    protected final Messages messages;\n-    protected final Resources resources;\n-    protected final Utils utils;\n-\n-    \/**\n-     * Keep track of which packages we have seen for\n-     * efficiency purposes.  We don't want to copy the\n-     * doc files multiple times for a single package.\n-     *\/\n-    protected final Set<PackageElement> containingPackagesSeen;\n-\n-    \/**\n-     * Construct a Builder.\n-     * @param c a context providing information used in this run of the doclet\n-     *\/\n-    public AbstractBuilder(Context c) {\n-        this.configuration = c.configuration;\n-        this.options = configuration.getOptions();\n-        this.builderFactory = configuration.getBuilderFactory();\n-        this.messages = configuration.getMessages();\n-        this.resources = configuration.getDocResources();\n-        this.utils = configuration.utils;\n-        this.containingPackagesSeen = c.containingPackagesSeen;\n-    }\n-\n-    \/**\n-     * Build the documentation.\n-     *\n-     * @throws DocletException if there is a problem building the documentation\n-     *\/\n-    public abstract void build() throws DocletException;\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AbstractBuilder.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.List;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind;\n-\n-\/**\n- * The superclass for all member builders.  Member builders are only executed\n- * within Class Builders.  They essentially build subcomponents.  For example,\n- * method documentation is a subcomponent of class documentation.\n- *\/\n-public abstract class AbstractMemberBuilder extends AbstractBuilder {\n-\n-    protected final TypeElement typeElement;\n-\n-    protected final VisibleMemberTable visibleMemberTable;\n-\n-    \/**\n-     * Construct a SubBuilder.\n-     * @param context a context object, providing information used in this run\n-     *        of the doclet.\n-     *\/\n-    public AbstractMemberBuilder(Context context, TypeElement typeElement) {\n-        super(context);\n-        this.typeElement = typeElement;\n-        visibleMemberTable = configuration.getVisibleMemberTable(typeElement);\n-    }\n-\n-    \/**\n-     * This method is not supported by subbuilders.\n-     *\n-     * @throws AssertionError always\n-     *\/\n-    @Override\n-    public void build() {\n-        \/\/ You may not call the build method in a subbuilder.\n-        throw new AssertionError();\n-    }\n-\n-    \/**\n-     * Build the documentation.\n-     *\n-     * @param target the content into which to add the documentation\n-     * @throws DocletException if there is a problem building the documentation\n-     *\/\n-    public abstract void build(Content target) throws DocletException;\n-\n-    \/**\n-     * Returns true if this subbuilder has anything to document.\n-     *\n-     * @return true if this subbuilder has anything to document\n-     *\/\n-    public abstract boolean hasMembersToDocument();\n-\n-    \/**\n-     * Returns a list of visible elements of the specified kind in this\n-     * type element.\n-     * @param kind of members\n-     * @return a list of members\n-     *\/\n-    protected List<Element> getVisibleMembers(Kind kind) {\n-        return visibleMemberTable.getVisibleMembers(kind);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AbstractMemberBuilder.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,209 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeMemberWriter;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for required annotation type members.\n- *\/\n-public class AnnotationTypeMemberBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The writer to output the member documentation.\n-     *\/\n-    protected AnnotationTypeMemberWriter writer;\n-\n-    \/**\n-     * The list of members being documented.\n-     *\/\n-    protected List<Element> members;\n-\n-    \/**\n-     * The index of the current member that is being documented at this point\n-     * in time.\n-     *\/\n-    protected Element currentMember;\n-\n-    \/**\n-     * Construct a new AnnotationTypeRequiredMemberBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    protected AnnotationTypeMemberBuilder(Context context,\n-                                          TypeElement typeElement,\n-                                          AnnotationTypeMemberWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        \/\/ In contrast to the annotation interface member summaries the details generated\n-        \/\/ by this builder share a single list for both required and optional members.\n-        this.members = getVisibleMembers(ANNOTATION_TYPE_MEMBER);\n-    }\n-\n-\n-    \/**\n-     * Construct a new AnnotationTypeMemberBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return an instance of this object\n-     *\/\n-    public static AnnotationTypeMemberBuilder getInstance(\n-            Context context, TypeElement typeElement,\n-            AnnotationTypeMemberWriter writer) {\n-        return new AnnotationTypeMemberBuilder(context, typeElement,\n-                writer);\n-    }\n-\n-    \/**\n-     * Returns whether or not there are members to document.\n-     * @return whether or not there are members to document\n-     *\/\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !members.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildAnnotationTypeMember(target);\n-    }\n-\n-    \/**\n-     * Build the member documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if an error occurs\n-     *\/\n-    protected void buildAnnotationTypeMember(Content target)\n-            throws DocletException {\n-        if (hasMembersToDocument()) {\n-            writer.addAnnotationDetailsMarker(target);\n-            Content annotationDetailsHeader = writer.getAnnotationDetailsHeader();\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element member : members) {\n-                currentMember = member;\n-                Content annotationContent = writer.getAnnotationHeaderContent(currentMember);\n-\n-                buildAnnotationTypeMemberChildren(annotationContent);\n-\n-                memberList.add(writer.getMemberListItem(annotationContent));\n-            }\n-            Content annotationDetails = writer.getAnnotationDetails(annotationDetailsHeader, memberList);\n-            target.add(annotationDetails);\n-        }\n-    }\n-\n-    protected void buildAnnotationTypeMemberChildren(Content annotationContent) {\n-        buildSignature(annotationContent);\n-        buildDeprecationInfo(annotationContent);\n-        buildPreviewInfo(annotationContent);\n-        buildMemberComments(annotationContent);\n-        buildTagInfo(annotationContent);\n-        buildDefaultValueInfo(annotationContent);\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content target) {\n-        target.add(writer.getSignature(currentMember));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content annotationContent) {\n-        writer.addDeprecated(currentMember, annotationContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content annotationContent) {\n-        writer.addPreview(currentMember, annotationContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the member.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMemberComments(Content annotationContent) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentMember, annotationContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content annotationContent) {\n-        writer.addTags(currentMember, annotationContent);\n-    }\n-\n-    \/**\n-     * Build the default value for this optional member.\n-     *\n-     * @param annotationContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDefaultValueInfo(Content annotationContent) {\n-        writer.addDefaultValueInfo(currentMember, annotationContent);\n-    }\n-\n-    \/**\n-     * Return the annotation type required member writer for this builder.\n-     *\n-     * @return the annotation type required member constant writer for this\n-     * builder.\n-     *\/\n-    public AnnotationTypeMemberWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/AnnotationTypeMemberBuilder.java","additions":0,"deletions":209,"binary":false,"changes":209,"status":"deleted"},{"patch":"@@ -1,199 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.PropertyWriter;\n-import jdk.javadoc.internal.doclets.toolkit.WriterFactory;\n-import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;\n-\n-\/**\n- * The factory for constructing builders.\n- *\/\n-public class BuilderFactory {\n-\n-    \/**\n-     * The factory to retrieve the required writers from.\n-     *\/\n-    private final WriterFactory writerFactory;\n-\n-    private final AbstractBuilder.Context context;\n-\n-    \/**\n-     * Construct a builder factory using the given configuration.\n-     * @param configuration the configuration for the current doclet\n-     * being executed.\n-     *\/\n-    public BuilderFactory (BaseConfiguration configuration) {\n-        this.writerFactory = configuration.getWriterFactory();\n-\n-        Set<PackageElement> containingPackagesSeen = new HashSet<>();\n-        context = new AbstractBuilder.Context(configuration, containingPackagesSeen);\n-    }\n-\n-    \/**\n-     * Return the builder that builds the constant summary.\n-     * @return the builder that builds the constant summary.\n-     *\/\n-    public AbstractBuilder getConstantsSummaryBuilder() {\n-        return ConstantsSummaryBuilder.getInstance(context);\n-    }\n-\n-    \/**\n-     * Return the builder that builds the package summary.\n-     *\n-     * @param pkg the package being documented.\n-     * @return the builder that builds the package summary.\n-     *\/\n-    public AbstractBuilder getPackageSummaryBuilder(PackageElement pkg) {\n-        return PackageSummaryBuilder.getInstance(context, pkg,\n-            writerFactory.getPackageSummaryWriter(pkg));\n-    }\n-\n-    \/**\n-     * Return the builder that builds the module summary.\n-     *\n-     * @param mdle the module being documented.\n-     * @return the builder that builds the module summary.\n-     *\/\n-    public AbstractBuilder getModuleSummaryBuilder(ModuleElement mdle) {\n-        return ModuleSummaryBuilder.getInstance(context, mdle,\n-            writerFactory.getModuleSummaryWriter(mdle));\n-    }\n-\n-    \/**\n-     * Return the builder for the class.\n-     *\n-     * @param typeElement the class being documented.\n-     * @param classTree the class tree.\n-     * @return the writer for the class.  Return null if this\n-     * writer is not supported by the doclet.\n-     *\/\n-    public AbstractBuilder getClassBuilder(TypeElement typeElement, ClassTree classTree) {\n-        return ClassBuilder.getInstance(context, typeElement,\n-            writerFactory.getClassWriter(typeElement, classTree));\n-    }\n-\n-    \/**\n-     * Return an instance of the method builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the method builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getMethodBuilder(ClassWriter classWriter) {\n-        return MethodBuilder.getInstance(context, classWriter.getTypeElement(),\n-            writerFactory.getMethodWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the annotation type member builder for the given\n-     * class.\n-     *\n-     * @param classWriter the writer for the enclosing annotation type\n-     * @return an instance of the annotation type member builder for the given\n-     *         annotation type.\n-     *\/\n-    public AbstractMemberBuilder getAnnotationTypeMemberBuilder(\n-            ClassWriter classWriter) {\n-        return AnnotationTypeMemberBuilder.getInstance(context,\n-            classWriter.getTypeElement(),\n-            writerFactory.getAnnotationTypeMemberWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the enum constants builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the enum constants builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getEnumConstantsBuilder(ClassWriter classWriter) {\n-        return EnumConstantBuilder.getInstance(context, classWriter.getTypeElement(),\n-                writerFactory.getEnumConstantWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the field builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the field builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getFieldBuilder(ClassWriter classWriter) {\n-        return FieldBuilder.getInstance(context, classWriter.getTypeElement(),\n-            writerFactory.getFieldWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the property builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the field builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getPropertyBuilder(ClassWriter classWriter) {\n-        final PropertyWriter propertyWriter =\n-                writerFactory.getPropertyWriter(classWriter);\n-        return PropertyBuilder.getInstance(context,\n-                                           classWriter.getTypeElement(),\n-                                           propertyWriter);\n-    }\n-\n-    \/**\n-     * Return an instance of the constructor builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the constructor builder for the given class.\n-     *\/\n-    public AbstractMemberBuilder getConstructorBuilder(ClassWriter classWriter) {\n-        return ConstructorBuilder.getInstance(context, classWriter.getTypeElement(),\n-            writerFactory.getConstructorWriter(classWriter));\n-    }\n-\n-    \/**\n-     * Return an instance of the member summary builder for the given class.\n-     *\n-     * @param classWriter the writer for the enclosing class\n-     * @return an instance of the member summary builder for the given class.\n-     *\/\n-    public MemberSummaryBuilder getMemberSummaryBuilder(ClassWriter classWriter) {\n-        return MemberSummaryBuilder.getInstance(classWriter, context);\n-    }\n-\n-    \/**\n-     * Return the builder that builds the serialized form.\n-     *\n-     * @return the builder that builds the serialized form.\n-     *\/\n-    public AbstractBuilder getSerializedFormBuilder() {\n-        return SerializedFormBuilder.getInstance(context);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/BuilderFactory.java","additions":0,"deletions":199,"binary":false,"changes":199,"status":"deleted"},{"patch":"@@ -1,476 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.Name;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.CommentUtils;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * Builds the summary for a given class.\n- *\/\n-public class ClassBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The class being documented.\n-     *\/\n-    private final TypeElement typeElement;\n-\n-    \/**\n-     * The doclet specific writer.\n-     *\/\n-    private final ClassWriter writer;\n-\n-    private final Utils utils;\n-\n-    \/**\n-     * Construct a new ClassBuilder.\n-     *\n-     * @param context  the build context\n-     * @param typeElement the class being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private ClassBuilder(Context context, TypeElement typeElement, ClassWriter writer) {\n-        super(context);\n-        this.typeElement = typeElement;\n-        this.writer = writer;\n-        this.utils = configuration.utils;\n-        switch (typeElement.getKind()) {\n-            case ENUM   -> setEnumDocumentation(typeElement);\n-            case RECORD -> setRecordDocumentation(typeElement);\n-        }\n-    }\n-\n-    \/**\n-     * Constructs a new ClassBuilder.\n-     *\n-     * @param context  the build context\n-     * @param typeElement the class being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new ClassBuilder\n-     *\/\n-    public static ClassBuilder getInstance(Context context, TypeElement typeElement, ClassWriter writer) {\n-        return new ClassBuilder(context, typeElement, writer);\n-    }\n-\n-    @Override\n-    public void build() throws DocletException {\n-        buildClassDoc();\n-    }\n-\n-    \/**\n-     * Handles the {@literal <TypeElement>} tag.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassDoc() throws DocletException {\n-        String key = switch (typeElement.getKind()) {\n-            case INTERFACE       -> \"doclet.Interface\";\n-            case ENUM            -> \"doclet.Enum\";\n-            case RECORD          -> \"doclet.RecordClass\";\n-            case ANNOTATION_TYPE -> \"doclet.AnnotationType\";\n-            case CLASS           -> \"doclet.Class\";\n-            default -> throw new IllegalStateException(typeElement.getKind() + \" \" + typeElement);\n-        };\n-        Content content = writer.getHeader(resources.getText(key) + \" \"\n-                + utils.getSimpleName(typeElement));\n-        Content classContent = writer.getClassContentHeader();\n-\n-        buildClassTree(classContent);\n-        buildClassInfo(classContent);\n-        buildMemberSummary(classContent);\n-        buildMemberDetails(classContent);\n-\n-        writer.addClassContent(classContent);\n-        writer.addFooter();\n-        writer.printDocument(content);\n-        copyDocFiles();\n-    }\n-\n-    \/**\n-     * Build the class inheritance tree documentation.\n-     *\n-     * @param classContent the content to which the documentation will be added\n-     *\/\n-    protected void buildClassTree(Content classContent) {\n-        writer.addClassTree(classContent);\n-    }\n-\n-    \/**\n-     * Build the class information documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassInfo(Content target) throws DocletException {\n-        Content c = writer.getOutputInstance();\n-        buildParamInfo(c);\n-        buildSuperInterfacesInfo(c);\n-        buildImplementedInterfacesInfo(c);\n-        buildSubClassInfo(c);\n-        buildSubInterfacesInfo(c);\n-        buildInterfaceUsageInfo(c);\n-        buildNestedClassInfo(c);\n-        buildFunctionalInterfaceInfo(c);\n-        buildClassSignature(c);\n-        buildDeprecationInfo(c);\n-        buildClassDescription(c);\n-        buildClassTagInfo(c);\n-\n-        target.add(writer.getClassInfo(c));\n-    }\n-\n-    \/**\n-     * Build the type parameters and state components of this class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildParamInfo(Content target) {\n-        writer.addParamInfo(target);\n-    }\n-\n-    \/**\n-     * If this is an interface, list all superinterfaces.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSuperInterfacesInfo(Content target) {\n-        writer.addSuperInterfacesInfo(target);\n-    }\n-\n-    \/**\n-     * If this is a class, list all interfaces implemented by this class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildImplementedInterfacesInfo(Content target) {\n-        writer.addImplementedInterfacesInfo(target);\n-    }\n-\n-    \/**\n-     * List all the classes that extend this one.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSubClassInfo(Content target) {\n-        writer.addSubClassInfo(target);\n-    }\n-\n-    \/**\n-     * List all the interfaces that extend this one.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSubInterfacesInfo(Content target) {\n-        writer.addSubInterfacesInfo(target);\n-    }\n-\n-    \/**\n-     * If this is an interface, list all classes that implement this interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildInterfaceUsageInfo(Content target) {\n-        writer.addInterfaceUsageInfo(target);\n-    }\n-\n-    \/**\n-     * If this is an functional interface, display appropriate message.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildFunctionalInterfaceInfo(Content target) {\n-        writer.addFunctionalInterfaceInfo(target);\n-    }\n-\n-    \/**\n-     * If this class is deprecated, build the appropriate information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content target) {\n-        writer.addClassDeprecationInfo(target);\n-    }\n-\n-    \/**\n-     * If this is an inner class or interface, list the enclosing class or interface.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildNestedClassInfo(Content target) {\n-        writer.addNestedClassInfo(target);\n-    }\n-\n-    \/**\n-     * Copy the doc files.\n-     *\n-     * @throws DocFileIOException if there is a problem while copying the files\n-     *\/\n-    private void copyDocFiles() throws DocletException {\n-        PackageElement containingPackage = utils.containingPackage(typeElement);\n-        if ((configuration.packages == null ||\n-            !configuration.packages.contains(containingPackage)) &&\n-            !containingPackagesSeen.contains(containingPackage)) {\n-            \/\/Only copy doc files dir if the containing package is not\n-            \/\/documented AND if we have not documented a class from the same\n-            \/\/package already. Otherwise, we are making duplicate copies.\n-            DocFilesHandler docFilesHandler = configuration\n-                    .getWriterFactory()\n-                    .getDocFilesHandler(containingPackage);\n-            docFilesHandler.copyDocFiles();\n-            containingPackagesSeen.add(containingPackage);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature of the current class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildClassSignature(Content target) {\n-        writer.addClassSignature(target);\n-    }\n-\n-    \/**\n-     * Build the class description.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildClassDescription(Content target) {\n-        writer.addClassDescription(target);\n-    }\n-\n-    \/**\n-     * Build the tag information for the current class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildClassTagInfo(Content target) {\n-        writer.addClassTagInfo(target);\n-    }\n-\n-    \/**\n-     * Build the member summary contents of the page.\n-     *\n-     * @param classContent the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMemberSummary(Content classContent) throws DocletException {\n-        Content summariesList = writer.getSummariesList();\n-        builderFactory.getMemberSummaryBuilder(writer).build(summariesList);\n-        classContent.add(writer.getMemberSummary(summariesList));\n-    }\n-\n-    \/**\n-     * Build the member details contents of the page.\n-     *\n-     * @param classContent the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMemberDetails(Content classContent) throws DocletException {\n-        Content detailsList = writer.getDetailsList();\n-\n-        buildEnumConstantsDetails(detailsList);\n-        buildPropertyDetails(detailsList);\n-        buildFieldDetails(detailsList);\n-        buildConstructorDetails(detailsList);\n-        buildAnnotationTypeMemberDetails(detailsList);\n-        buildMethodDetails(detailsList);\n-\n-        classContent.add(writer.getMemberDetails(detailsList));\n-    }\n-\n-    \/**\n-     * Build the enum constants documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildEnumConstantsDetails(Content detailsList) throws DocletException {\n-        builderFactory.getEnumConstantsBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the field documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildFieldDetails(Content detailsList) throws DocletException {\n-        builderFactory.getFieldBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the property documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    public void buildPropertyDetails( Content detailsList) throws DocletException {\n-        builderFactory.getPropertyBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the constructor documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildConstructorDetails(Content detailsList) throws DocletException {\n-        builderFactory.getConstructorBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the method documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMethodDetails(Content detailsList) throws DocletException {\n-        builderFactory.getMethodBuilder(writer).build(detailsList);\n-    }\n-\n-    \/**\n-     * Build the annotation type optional member documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem building the documentation\n-     *\/\n-    protected void buildAnnotationTypeMemberDetails(Content target)\n-            throws DocletException {\n-        builderFactory.getAnnotationTypeMemberBuilder(writer).build(target);\n-    }\n-\n-    \/**\n-     * The documentation for values() and valueOf() in Enums are set by the\n-     * doclet only iff the user or overridden methods are missing.\n-     * @param elem the enum element\n-     *\/\n-    private void setEnumDocumentation(TypeElement elem) {\n-        CommentUtils cmtUtils = configuration.cmtUtils;\n-        for (ExecutableElement ee : utils.getMethods(elem)) {\n-            if (!utils.getFullBody(ee).isEmpty()) \/\/ ignore if already set\n-                continue;\n-            Name name = ee.getSimpleName();\n-            if (name.contentEquals(\"values\") && ee.getParameters().isEmpty()) {\n-                utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                cmtUtils.setEnumValuesTree(ee);\n-            } else if (name.contentEquals(\"valueOf\") && ee.getParameters().size() == 1) {\n-                \/\/ TODO: check parameter type\n-                utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                cmtUtils.setEnumValueOfTree(ee);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sets the documentation as needed for the mandated parts of a record type.\n-     * This includes the canonical constructor, methods like {@code equals},\n-     * {@code hashCode}, {@code toString}, the accessor methods, and the underlying\n-     * field.\n-     * @param elem the record element\n-     *\/\n-\n-    private void setRecordDocumentation(TypeElement elem) {\n-        CommentUtils cmtUtils = configuration.cmtUtils;\n-        Set<Name> componentNames = elem.getRecordComponents().stream()\n-                .map(Element::getSimpleName)\n-                .collect(Collectors.toSet());\n-\n-        for (ExecutableElement ee : utils.getConstructors(elem)) {\n-            if (utils.isCanonicalRecordConstructor(ee)) {\n-                if (utils.getFullBody(ee).isEmpty()) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordConstructorTree(ee);\n-                }\n-                \/\/ only one canonical constructor; no need to keep looking\n-                break;\n-            }\n-        }\n-\n-        var fields = utils.isSerializable(elem)\n-                ? utils.getFieldsUnfiltered(elem)\n-                : utils.getFields(elem);\n-        for (VariableElement ve : fields) {\n-            \/\/ The fields for the record component cannot be declared by the\n-            \/\/ user and so cannot have any pre-existing comment.\n-            Name name = ve.getSimpleName();\n-            if (componentNames.contains(name)) {\n-                utils.removeCommentHelper(ve); \/\/ purge previous entry\n-                cmtUtils.setRecordFieldTree(ve);\n-            }\n-        }\n-\n-        TypeMirror objectType = utils.getObjectType();\n-\n-        for (ExecutableElement ee : utils.getMethods(elem)) {\n-            if (!utils.getFullBody(ee).isEmpty()) {\n-                continue;\n-            }\n-\n-            Name name = ee.getSimpleName();\n-            List<? extends VariableElement> params = ee.getParameters();\n-            if (name.contentEquals(\"equals\")) {\n-                if (params.size() == 1 && utils.typeUtils.isSameType(params.get(0).asType(), objectType)) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordEqualsTree(ee);\n-                }\n-            } else if (name.contentEquals(\"hashCode\")) {\n-                if (params.isEmpty()) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordHashCodeTree(ee);\n-                }\n-            } else if (name.contentEquals(\"toString\")) {\n-                if (params.isEmpty()) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordToStringTree(ee);\n-                }\n-            } else if (componentNames.contains(name)) {\n-                if (params.isEmpty()) {\n-                    utils.removeCommentHelper(ee); \/\/ purge previous entry\n-                    cmtUtils.setRecordAccessorTree(ee);\n-                }\n-            }\n-        }\n-\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java","additions":0,"deletions":476,"binary":false,"changes":476,"status":"deleted"},{"patch":"@@ -1,314 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.ConstantsSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds the Constants Summary Page.\n- *\/\n-public class ConstantsSummaryBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The maximum number of package directories shown in the headings of\n-     * the constant values contents list and headings.\n-     *\/\n-    private static final int MAX_CONSTANT_VALUE_INDEX_LENGTH = 2;\n-\n-    \/**\n-     * The writer used to write the results.\n-     *\/\n-    protected ConstantsSummaryWriter writer;\n-\n-    \/**\n-     * The set of type elements that have constant fields.\n-     *\/\n-    protected final Set<TypeElement> typeElementsWithConstFields;\n-\n-    \/**\n-     * The set of package-group headings.\n-     *\/\n-    protected final Set<String> packageGroupHeadings;\n-\n-    \/**\n-     * The current package being documented.\n-     *\/\n-    private PackageElement currentPackage;\n-\n-    \/**\n-     * The current class being documented.\n-     *\/\n-    private TypeElement currentClass;\n-\n-    \/**\n-     * Constructs a new {@code ConstantsSummaryBuilder}.\n-     *\n-     * @param context       the build context\n-     *\/\n-    private ConstantsSummaryBuilder(Context context) {\n-        super(context);\n-        this.typeElementsWithConstFields = new HashSet<>();\n-        this.packageGroupHeadings = new TreeSet<>(utils::compareStrings);\n-    }\n-\n-    \/**\n-     * Constructs a {@code ConstantsSummaryBuilder}.\n-     *\n-     * @param context       the build context\n-     * @return the new ConstantsSummaryBuilder\n-     *\/\n-    public static ConstantsSummaryBuilder getInstance(Context context) {\n-        return new ConstantsSummaryBuilder(context);\n-    }\n-\n-    @Override\n-    public void build() throws DocletException {\n-        boolean anyConstants = configuration.packages.stream().anyMatch(this::hasConstantField);\n-        if (!anyConstants) {\n-            return;\n-        }\n-\n-        writer = configuration.getWriterFactory().getConstantsSummaryWriter();\n-        if (writer == null) {\n-            \/\/Doclet does not support this output.\n-            return;\n-        }\n-        buildConstantSummary();\n-    }\n-\n-    \/**\n-     * Builds the constant summary page.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildConstantSummary() throws DocletException {\n-        Content content = writer.getHeader();\n-\n-        buildContents();\n-        buildConstantSummaries();\n-\n-        writer.addFooter();\n-        writer.printDocument(content);\n-    }\n-\n-    \/**\n-     * Builds the list of contents for the groups of packages appearing in the constants summary page.\n-     *\/\n-    protected void buildContents() {\n-        Content contentList = writer.getContentsHeader();\n-        packageGroupHeadings.clear();\n-        for (PackageElement pkg : configuration.packages) {\n-            String abbrevPackageName = getAbbrevPackageName(pkg);\n-            if (hasConstantField(pkg) && !packageGroupHeadings.contains(abbrevPackageName)) {\n-                writer.addLinkToPackageContent(abbrevPackageName, contentList);\n-                packageGroupHeadings.add(abbrevPackageName);\n-            }\n-        }\n-        writer.addContentsList(contentList);\n-    }\n-\n-    \/**\n-     * Builds the summary for each documented package.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildConstantSummaries() throws DocletException {\n-        packageGroupHeadings.clear();\n-        Content summaries = writer.getConstantSummaries();\n-        for (PackageElement aPackage : configuration.packages) {\n-            if (hasConstantField(aPackage)) {\n-                currentPackage = aPackage;\n-                \/\/Build the documentation for the current package.\n-                buildPackageHeader(summaries);\n-                buildClassConstantSummary();\n-            }\n-        }\n-        writer.addConstantSummaries(summaries);\n-    }\n-\n-    \/**\n-     * Builds the header for the given package.\n-     *\n-     * @param target the content to which the package header will be added\n-     *\/\n-    protected void buildPackageHeader(Content target) {\n-        String abbrevPkgName = getAbbrevPackageName(currentPackage);\n-        if (!packageGroupHeadings.contains(abbrevPkgName)) {\n-            writer.addPackageGroup(abbrevPkgName, target);\n-            packageGroupHeadings.add(abbrevPkgName);\n-        }\n-    }\n-\n-    \/**\n-     * Builds the summary for the current class.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassConstantSummary()\n-            throws DocletException {\n-        SortedSet<TypeElement> classes = !currentPackage.isUnnamed()\n-                ? utils.getAllClasses(currentPackage)\n-                : configuration.typeElementCatalog.allUnnamedClasses();\n-        Content classConstantHeader = writer.getClassConstantHeader();\n-        for (TypeElement te : classes) {\n-            if (!typeElementsWithConstFields.contains(te) ||\n-                !utils.isIncluded(te)) {\n-                continue;\n-            }\n-            currentClass = te;\n-            \/\/Build the documentation for the current class.\n-\n-            buildConstantMembers(classConstantHeader);\n-\n-        }\n-        writer.addClassConstant(classConstantHeader);\n-    }\n-\n-    \/**\n-     * Builds the summary of constant members in the class.\n-     *\n-     * @param target the content to which the table of constant members will be added\n-     *\/\n-    protected void buildConstantMembers(Content target) {\n-        new ConstantFieldBuilder(currentClass).buildMembersSummary(target);\n-    }\n-\n-    \/**\n-     * {@return true if the given package has constant fields to document}\n-     *\n-     * @param pkg   the package to be checked\n-     *\/\n-    private boolean hasConstantField(PackageElement pkg) {\n-        SortedSet<TypeElement> classes = !pkg.isUnnamed()\n-                  ? utils.getAllClasses(pkg)\n-                  : configuration.typeElementCatalog.allUnnamedClasses();\n-        boolean found = false;\n-        for (TypeElement te : classes) {\n-            if (utils.isIncluded(te) && hasConstantField(te)) {\n-                found = true;\n-            }\n-        }\n-        return found;\n-    }\n-\n-    \/**\n-     * {@return true if the given class has constant fields to document}\n-     *\n-     * @param typeElement the class to be checked\n-     *\/\n-    private boolean hasConstantField (TypeElement typeElement) {\n-        VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n-        List<? extends Element> fields = vmt.getVisibleMembers(FIELDS);\n-        for (Element f : fields) {\n-            VariableElement field = (VariableElement)f;\n-            if (field.getConstantValue() != null) {\n-                typeElementsWithConstFields.add(typeElement);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * {@return the abbreviated name for a package, containing the leading segments of the name}\n-     *\n-     * @param pkg the package\n-     *\/\n-    public String getAbbrevPackageName(PackageElement pkg) {\n-        if (pkg.isUnnamed()) {\n-            return \"\";\n-        }\n-\n-        String packageName = utils.getPackageName(pkg);\n-        int index = -1;\n-        for (int j = 0; j < MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {\n-            index = packageName.indexOf(\".\", index + 1);\n-        }\n-        return index == -1 ? packageName : packageName.substring(0, index);\n-    }\n-\n-    \/**\n-     * Builder for the table of fields with constant values.\n-     *\/\n-    private class ConstantFieldBuilder {\n-\n-        \/**\n-         * The type element that we are examining constants for.\n-         *\/\n-        protected TypeElement typeElement;\n-\n-        \/**\n-         * Constructs a {@code ConstantFieldBuilder}.\n-         * @param typeElement the type element that we are examining constants for\n-         *\/\n-        public ConstantFieldBuilder(TypeElement typeElement) {\n-            this.typeElement = typeElement;\n-        }\n-\n-        \/**\n-         * Builds the table of constants for a given class.\n-         *\n-         * @param target the content to which the table of class constants will be added\n-         *\/\n-        protected void buildMembersSummary(Content target) {\n-            SortedSet<VariableElement> members = members();\n-            if (!members.isEmpty()) {\n-                writer.addConstantMembers(typeElement, members, target);\n-            }\n-        }\n-\n-        \/**\n-         * {@return a set of visible constant fields for the given type}\n-         *\/\n-        protected SortedSet<VariableElement> members() {\n-            VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);\n-            List<Element> members = new ArrayList<>();\n-            members.addAll(vmt.getVisibleMembers(FIELDS));\n-            members.addAll(vmt.getVisibleMembers(ENUM_CONSTANTS));\n-            SortedSet<VariableElement> includes =\n-                    new TreeSet<>(utils.comparators.makeGeneralPurposeComparator());\n-            for (Element element : members) {\n-                VariableElement member = (VariableElement)element;\n-                if (member.getConstantValue() != null) {\n-                    includes.add(member);\n-                }\n-            }\n-            return includes;\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ConstantsSummaryBuilder.java","additions":0,"deletions":314,"binary":false,"changes":314,"status":"deleted"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.ConstructorWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for a constructor.\n- *\/\n-public class ConstructorBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The current constructor that is being documented at this point in time.\n-     *\/\n-    private ExecutableElement currentConstructor;\n-\n-    \/**\n-     * The writer to output the constructor documentation.\n-     *\/\n-    private final ConstructorWriter writer;\n-\n-    \/**\n-     * The constructors being documented.\n-     *\/\n-    private final List<? extends Element> constructors;\n-\n-    \/**\n-     * Construct a new ConstructorBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private ConstructorBuilder(Context context,\n-            TypeElement typeElement,\n-            ConstructorWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        constructors = getVisibleMembers(CONSTRUCTORS);\n-        for (Element ctor : constructors) {\n-            if (utils.isProtected(ctor) || utils.isPrivate(ctor)) {\n-                writer.setFoundNonPubConstructor(true);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Construct a new ConstructorBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new ConstructorBuilder\n-     *\/\n-    public static ConstructorBuilder getInstance(Context context,\n-            TypeElement typeElement, ConstructorWriter writer) {\n-        return new ConstructorBuilder(context, typeElement, writer);\n-    }\n-\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !constructors.isEmpty();\n-    }\n-\n-    \/**\n-     * Return the constructor writer for this builder.\n-     *\n-     * @return the constructor writer for this builder.\n-     *\/\n-    public ConstructorWriter getWriter() {\n-        return writer;\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildConstructorDoc(target);\n-    }\n-\n-    \/**\n-     * Build the constructor documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildConstructorDoc(Content target) throws DocletException {\n-        if (hasMembersToDocument()) {\n-            Content constructorDetailsHeader = writer.getConstructorDetailsHeader(target);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element constructor : constructors) {\n-                currentConstructor = (ExecutableElement)constructor;\n-                Content constructorContent = writer.getConstructorHeaderContent(currentConstructor);\n-\n-                buildSignature(constructorContent);\n-                buildDeprecationInfo(constructorContent);\n-                buildPreviewInfo(constructorContent);\n-                buildConstructorComments(constructorContent);\n-                buildTagInfo(constructorContent);\n-\n-                memberList.add(writer.getMemberListItem(constructorContent));\n-            }\n-            Content constructorDetails = writer.getConstructorDetails(constructorDetailsHeader, memberList);\n-            target.add(constructorDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content constructorContent) {\n-        constructorContent.add(writer.getSignature(currentConstructor));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content constructorContent) {\n-        writer.addDeprecated(currentConstructor, constructorContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content constructorContent) {\n-        writer.addPreview(currentConstructor, constructorContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the constructor.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildConstructorComments(Content constructorContent) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentConstructor, constructorContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param constructorContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content constructorContent) {\n-        writer.addTags(currentConstructor, constructorContent);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ConstructorBuilder.java","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -1,191 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.EnumConstantWriter;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for a enum constants.\n- *\/\n-public class EnumConstantBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The writer to output the enum constants documentation.\n-     *\/\n-    private final EnumConstantWriter writer;\n-\n-    \/**\n-     * The set of enum constants being documented.\n-     *\/\n-    private final List<? extends Element> enumConstants;\n-\n-    \/**\n-     * The current enum constant that is being documented at this point\n-     * in time.\n-     *\/\n-    private VariableElement currentElement;\n-\n-    \/**\n-     * Construct a new EnumConstantsBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private EnumConstantBuilder(Context context,\n-            TypeElement typeElement, EnumConstantWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        enumConstants = getVisibleMembers(ENUM_CONSTANTS);\n-    }\n-\n-    \/**\n-     * Construct a new EnumConstantsBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new EnumConstantsBuilder\n-     *\/\n-    public static EnumConstantBuilder getInstance(Context context,\n-            TypeElement typeElement, EnumConstantWriter writer) {\n-        return new EnumConstantBuilder(context, typeElement, writer);\n-    }\n-\n-    \/**\n-     * Returns whether or not there are members to document.\n-     *\n-     * @return whether or not there are members to document\n-     *\/\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !enumConstants.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildEnumConstant(target);\n-    }\n-\n-    \/**\n-     * Build the enum constant documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException is there is a problem while building the documentation\n-     *\/\n-    protected void buildEnumConstant(Content target) throws DocletException {\n-        if (hasMembersToDocument()) {\n-            Content enumConstantsDetailsHeader = writer.getEnumConstantsDetailsHeader(typeElement,\n-                    target);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element enumConstant : enumConstants) {\n-                currentElement = (VariableElement)enumConstant;\n-                Content enumConstants = writer.getEnumConstantsHeader(currentElement,\n-                        memberList);\n-\n-                buildSignature(enumConstants);\n-                buildDeprecationInfo(enumConstants);\n-                buildPreviewInfo(enumConstants);\n-                buildEnumConstantComments(enumConstants);\n-                buildTagInfo(enumConstants);\n-\n-                memberList.add(writer.getMemberListItem(enumConstants));\n-            }\n-            Content enumConstantDetails = writer.getEnumConstantsDetails(\n-                    enumConstantsDetailsHeader, memberList);\n-            target.add(enumConstantDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content target) {\n-        target.add(writer.getSignature(currentElement));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content target) {\n-        writer.addDeprecated(currentElement, target);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content target) {\n-        writer.addPreview(currentElement, target);\n-    }\n-\n-    \/**\n-     * Build the comments for the enum constant.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildEnumConstantComments(Content target) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentElement, target);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content target) {\n-        writer.addTags(currentElement, target);\n-    }\n-\n-    \/**\n-     * Return the enum constant writer for this builder.\n-     *\n-     * @return the enum constant writer for this builder.\n-     *\/\n-    public EnumConstantWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/EnumConstantBuilder.java","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.FieldWriter;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for a field.\n- *\/\n-public class FieldBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The writer to output the field documentation.\n-     *\/\n-    private final FieldWriter writer;\n-\n-    \/**\n-     * The list of fields being documented.\n-     *\/\n-    private final List<? extends Element> fields;\n-\n-    \/**\n-     * The index of the current field that is being documented at this point\n-     * in time.\n-     *\/\n-    private VariableElement currentElement;\n-\n-    \/**\n-     * Construct a new FieldBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private FieldBuilder(Context context,\n-                         TypeElement typeElement,\n-                         FieldWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        fields = getVisibleMembers(FIELDS);\n-    }\n-\n-    \/**\n-     * Construct a new FieldBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new FieldBuilder\n-     *\/\n-    public static FieldBuilder getInstance(Context context,\n-            TypeElement typeElement,\n-            FieldWriter writer) {\n-        return new FieldBuilder(context, typeElement, writer);\n-    }\n-\n-    \/**\n-     * Returns whether or not there are members to document.\n-     *\n-     * @return whether or not there are members to document\n-     *\/\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !fields.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildFieldDoc(target);\n-    }\n-\n-    \/**\n-     * Build the field documentation.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildFieldDoc(Content target) throws DocletException {\n-        if (!fields.isEmpty()) {\n-            Content fieldDetailsHeader = writer.getFieldDetailsHeader(target);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element element : fields) {\n-                currentElement = (VariableElement)element;\n-                Content fieldContent = writer.getFieldHeaderContent(currentElement);\n-\n-                buildSignature(fieldContent);\n-                buildDeprecationInfo(fieldContent);\n-                buildPreviewInfo(fieldContent);\n-                buildFieldComments(fieldContent);\n-                buildTagInfo(fieldContent);\n-\n-                memberList.add(writer.getMemberListItem(fieldContent));\n-            }\n-            Content fieldDetails = writer.getFieldDetails(fieldDetailsHeader, memberList);\n-            target.add(fieldDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content fieldContent) {\n-        fieldContent.add(writer.getSignature(currentElement));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content fieldContent) {\n-        writer.addDeprecated(currentElement, fieldContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content fieldContent) {\n-        writer.addPreview(currentElement, fieldContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the field.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldComments(Content fieldContent) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentElement, fieldContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param fieldContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content fieldContent) {\n-        writer.addTags(currentElement, fieldContent);\n-    }\n-\n-    \/**\n-     * Return the field writer for this builder.\n-     *\n-     * @return the field writer for this builder.\n-     *\/\n-    public FieldWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/FieldBuilder.java","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -1,448 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.Collection;\n-import java.util.Comparator;\n-import java.util.EnumMap;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.util.ElementFilter;\n-import javax.tools.Diagnostic;\n-\n-import com.sun.source.doctree.DocCommentTree;\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.ClassWriter;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;\n-import jdk.javadoc.internal.doclets.toolkit.WriterFactory;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds the member summary.\n- * There are two anonymous subtype variants of this builder, created\n- * in the {@link #getInstance} methods. One is for general types;\n- * the other is for annotation types.\n- *\/\n-public abstract class MemberSummaryBuilder extends AbstractMemberBuilder {\n-\n-    \/*\n-     * Comparator used to sort the members in the summary.\n-     *\/\n-    private final Comparator<Element> comparator;\n-\n-    \/**\n-     * The member summary writers for the given class.\n-     *\/\n-    private final EnumMap<VisibleMemberTable.Kind, MemberSummaryWriter> memberSummaryWriters;\n-\n-    final PropertyHelper pHelper;\n-\n-    \/**\n-     * Construct a new MemberSummaryBuilder.\n-     *\n-     * @param context       the build context.\n-     * @param typeElement   the type element.\n-     *\/\n-    private MemberSummaryBuilder(Context context, TypeElement typeElement) {\n-        super(context, typeElement);\n-        memberSummaryWriters = new EnumMap<>(VisibleMemberTable.Kind.class);\n-        comparator = utils.comparators.makeIndexElementComparator();\n-        pHelper = new PropertyHelper(this);\n-    }\n-\n-    \/**\n-     * Construct a new MemberSummaryBuilder for a general type.\n-     *\n-     * @param classWriter   the writer for the class whose members are being\n-     *                      summarized.\n-     * @param context       the build context.\n-     * @return              the instance\n-     *\/\n-    public static MemberSummaryBuilder getInstance(\n-            ClassWriter classWriter, Context context) {\n-        MemberSummaryBuilder builder = new MemberSummaryBuilder(context, classWriter.getTypeElement()) {\n-            @Override\n-            public void build(Content target) {\n-                buildPropertiesSummary(target);\n-                buildNestedClassesSummary(target);\n-                buildEnumConstantsSummary(target);\n-                buildAnnotationTypeRequiredMemberSummary(target);\n-                buildAnnotationTypeOptionalMemberSummary(target);\n-                buildFieldsSummary(target);\n-                buildConstructorsSummary(target);\n-                buildMethodsSummary(target);\n-            }\n-\n-            @Override\n-            public boolean hasMembersToDocument() {\n-                return visibleMemberTable.hasVisibleMembers();\n-            }\n-        };\n-        WriterFactory wf = context.configuration.getWriterFactory();\n-        for (VisibleMemberTable.Kind kind : VisibleMemberTable.Kind.values()) {\n-            MemberSummaryWriter msw = builder.getVisibleMemberTable().hasVisibleMembers(kind)\n-                    ? wf.getMemberSummaryWriter(classWriter, kind)\n-                    : null;\n-            builder.memberSummaryWriters.put(kind, msw);\n-        }\n-        return builder;\n-    }\n-\n-    \/**\n-     * Return the specified visible member map.\n-     *\n-     * @return the specified visible member map.\n-     * @throws ArrayIndexOutOfBoundsException when the type is invalid.\n-     * @see VisibleMemberTable\n-     *\/\n-    public VisibleMemberTable getVisibleMemberTable() {\n-        return visibleMemberTable;\n-    }\n-\n-    \/**.\n-     * Return the specified member summary writer.\n-     *\n-     * @param kind the kind of member summary writer to return.\n-     * @return the specified member summary writer.\n-     * @throws ArrayIndexOutOfBoundsException when the type is invalid.\n-     * @see VisibleMemberTable\n-     *\/\n-    public MemberSummaryWriter getMemberSummaryWriter(VisibleMemberTable.Kind kind) {\n-        return memberSummaryWriters.get(kind);\n-    }\n-\n-    \/**\n-     * Returns a list of methods that will be documented for the given class.\n-     * This information can be used for doclet specific documentation\n-     * generation.\n-     *\n-     * @param kind the kind of elements to return.\n-     * @return a list of methods that will be documented.\n-     * @see VisibleMemberTable\n-     *\/\n-    public SortedSet<Element> members(VisibleMemberTable.Kind kind) {\n-        TreeSet<Element> out = new TreeSet<>(comparator);\n-        out.addAll(getVisibleMembers(kind));\n-        return out;\n-    }\n-\n-    \/**\n-     * Builds the summary for any optional members of an annotation type.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildAnnotationTypeOptionalMemberSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_OPTIONAL);\n-        addSummary(writer, ANNOTATION_TYPE_MEMBER_OPTIONAL, false, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any required members of an annotation type.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildAnnotationTypeRequiredMemberSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(ANNOTATION_TYPE_MEMBER_REQUIRED);\n-        addSummary(writer, ANNOTATION_TYPE_MEMBER_REQUIRED, false, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any enum constants of an enum type.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildEnumConstantsSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(ENUM_CONSTANTS);\n-        addSummary(writer, ENUM_CONSTANTS, false, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any fields.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildFieldsSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(FIELDS);\n-        addSummary(writer, FIELDS, true, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any properties.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildPropertiesSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(PROPERTIES);\n-        addSummary(writer, PROPERTIES, true, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any nested classes.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildNestedClassesSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(NESTED_CLASSES);\n-        addSummary(writer, NESTED_CLASSES, true, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any methods.\n-     *\n-     * @param summariesList the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodsSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(METHODS);\n-        addSummary(writer, METHODS, true, summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for any constructors.\n-     *\n-     * @param summariesList the content to which the documentation will be added\n-     *\/\n-    protected void buildConstructorsSummary(Content summariesList) {\n-        MemberSummaryWriter writer = memberSummaryWriters.get(CONSTRUCTORS);\n-        addSummary(writer, CONSTRUCTORS, false, summariesList);\n-    }\n-\n-    \/**\n-     * Build the member summary for the given members.\n-     *\n-     * @param writer the summary writer to write the output.\n-     * @param kind the kind of  members to summarize.\n-     * @param summaryTreeList the list of contents to which the documentation will be added\n-     *\/\n-    private void buildSummary(MemberSummaryWriter writer,\n-            VisibleMemberTable.Kind kind, LinkedList<Content> summaryTreeList) {\n-        SortedSet<? extends Element> members = asSortedSet(getVisibleMembers(kind));\n-        if (!members.isEmpty()) {\n-            for (Element member : members) {\n-                final Element property = pHelper.getPropertyElement(member);\n-                if (property != null && member instanceof ExecutableElement ee) {\n-                    configuration.cmtUtils.updatePropertyMethodComment(ee, property);\n-                }\n-                if (utils.isMethod(member)) {\n-                    var docFinder = utils.docFinder();\n-                    Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n-                        var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n-                        Optional<List<? extends DocTree>> optional = firstSentenceTrees.isEmpty() ? Optional.empty() : Optional.of(firstSentenceTrees);\n-                        return Result.fromOptional(optional);\n-                    })).toOptional();\n-                    \/\/ The fact that we use `member` for possibly unrelated tags is suspicious\n-                    writer.addMemberSummary(typeElement, member, r.orElse(List.of()));\n-                } else {\n-                    writer.addMemberSummary(typeElement, member, utils.getFirstSentenceTrees(member));\n-                }\n-            }\n-            summaryTreeList.add(writer.getSummaryTable(typeElement));\n-        }\n-    }\n-\n-    \/**\n-     * Build the inherited member summary for the given methods.\n-     *\n-     * @param writer the writer for this member summary.\n-     * @param kind the kind of members to document.\n-     * @param targets the list of contents to which the documentation will be added\n-     *\/\n-    private void buildInheritedSummary(MemberSummaryWriter writer,\n-            VisibleMemberTable.Kind kind, LinkedList<Content> targets) {\n-        VisibleMemberTable visibleMemberTable = getVisibleMemberTable();\n-        SortedSet<? extends Element> inheritedMembersFromMap = asSortedSet(visibleMemberTable.getAllVisibleMembers(kind));\n-\n-        for (TypeElement inheritedClass : visibleMemberTable.getVisibleTypeElements()) {\n-            if (!(utils.isPublic(inheritedClass) || utils.isLinkable(inheritedClass))) {\n-                continue;\n-            }\n-            if (Objects.equals(inheritedClass, typeElement)) {\n-                continue;\n-            }\n-            if (utils.hasHiddenTag(inheritedClass)) {\n-                continue;\n-            }\n-\n-            List<? extends Element> members = inheritedMembersFromMap.stream()\n-                    .filter(e -> Objects.equals(utils.getEnclosingTypeElement(e), inheritedClass))\n-                    .toList();\n-\n-            if (!members.isEmpty()) {\n-                SortedSet<Element> inheritedMembers = new TreeSet<>(comparator);\n-                inheritedMembers.addAll(members);\n-                Content inheritedHeader = writer.getInheritedSummaryHeader(inheritedClass);\n-                Content links = writer.getInheritedSummaryLinks();\n-                addSummaryFootNote(inheritedClass, inheritedMembers, links, writer);\n-                inheritedHeader.add(links);\n-                targets.add(inheritedHeader);\n-            }\n-        }\n-    }\n-\n-    private void addSummaryFootNote(TypeElement inheritedClass, Iterable<Element> inheritedMembers,\n-                                    Content links, MemberSummaryWriter writer) {\n-        boolean isFirst = true;\n-        for (var iterator = inheritedMembers.iterator(); iterator.hasNext(); ) {\n-            var member = iterator.next();\n-            TypeElement t = utils.isUndocumentedEnclosure(inheritedClass)\n-                    ? typeElement : inheritedClass;\n-            writer.addInheritedMemberSummary(t, member, isFirst, !iterator.hasNext(), links);\n-            isFirst = false;\n-        }\n-    }\n-\n-    \/**\n-     * Adds the summary for the documentation.\n-     *\n-     * @param writer               the writer for this member summary\n-     * @param kind                 the kind of members to document\n-     * @param showInheritedSummary true if a summary of any inherited elements should be documented\n-     * @param summariesList        the list of summaries to which the summary will be added\n-     *\/\n-    private void addSummary(MemberSummaryWriter writer,\n-                            VisibleMemberTable.Kind kind,\n-                            boolean showInheritedSummary,\n-                            Content summariesList)\n-    {\n-        LinkedList<Content> summaryTreeList = new LinkedList<>();\n-        buildSummary(writer, kind, summaryTreeList);\n-        if (showInheritedSummary)\n-            buildInheritedSummary(writer, kind, summaryTreeList);\n-        if (!summaryTreeList.isEmpty()) {\n-            Content member = writer.getMemberSummaryHeader(typeElement, summariesList);\n-            summaryTreeList.forEach(member::add);\n-            writer.addSummary(summariesList, member);\n-        }\n-    }\n-\n-    private SortedSet<? extends Element> asSortedSet(Collection<? extends Element> members) {\n-        SortedSet<Element> out = new TreeSet<>(comparator);\n-        out.addAll(members);\n-        return out;\n-    }\n-\n-    \/**\n-     * A utility class to manage the property-related methods that should be\n-     * synthesized or updated.\n-     *\n-     * A property may comprise a field (that is typically private, if present),\n-     * a {@code fooProperty()} method (which is the defining characteristic for\n-     * a property), a {@code getFoo()} method and\/or a {@code setFoo(Foo foo)} method.\n-     *\n-     * Either the field (if present) or the {@code fooProperty()} method should have a\n-     * comment. If there is no field, or no comment on the field, the description for\n-     * the property will be derived from the description of the {@code fooProperty()}\n-     * method. If any method does not have a comment, one will be provided.\n-     *\/\n-    static class PropertyHelper {\n-\n-        private final Map<Element, Element> classPropertiesMap = new HashMap<>();\n-\n-        private final MemberSummaryBuilder  builder;\n-\n-        PropertyHelper(MemberSummaryBuilder builder) {\n-            this.builder = builder;\n-            computeProperties();\n-        }\n-\n-        private void computeProperties() {\n-            VisibleMemberTable vmt = builder.getVisibleMemberTable();\n-            List<ExecutableElement> props = ElementFilter.methodsIn(vmt.getVisibleMembers(PROPERTIES));\n-            for (ExecutableElement propertyMethod : props) {\n-                ExecutableElement getter = vmt.getPropertyGetter(propertyMethod);\n-                ExecutableElement setter = vmt.getPropertySetter(propertyMethod);\n-                VariableElement field = vmt.getPropertyField(propertyMethod);\n-\n-                addToPropertiesMap(propertyMethod, field, getter, setter);\n-            }\n-        }\n-\n-        private void addToPropertiesMap(ExecutableElement propertyMethod,\n-                                        VariableElement field,\n-                                        ExecutableElement getter,\n-                                        ExecutableElement setter) {\n-            \/\/ determine the preferred element from which to derive the property description\n-            Element e = field == null || !builder.utils.hasDocCommentTree(field)\n-                    ? propertyMethod : field;\n-\n-            if (e == field && builder.utils.hasDocCommentTree(propertyMethod)) {\n-                BaseConfiguration configuration = builder.configuration;\n-                configuration.getReporter().print(Diagnostic.Kind.WARNING,\n-                        propertyMethod, configuration.getDocResources().getText(\"doclet.duplicate.comment.for.property\"));\n-            }\n-\n-            addToPropertiesMap(propertyMethod, e);\n-            addToPropertiesMap(getter, e);\n-            addToPropertiesMap(setter, e);\n-        }\n-\n-        private void addToPropertiesMap(Element propertyMethod,\n-                                        Element commentSource) {\n-            Objects.requireNonNull(commentSource);\n-            if (propertyMethod == null) {\n-                return;\n-            }\n-\n-            Utils utils = builder.utils;\n-            DocCommentTree docTree = utils.hasDocCommentTree(propertyMethod)\n-                    ? utils.getDocCommentTree(propertyMethod)\n-                    : null;\n-\n-            \/* The second condition is required for the property buckets. In\n-             * this case the comment is at the property method (not at the field)\n-             * and it needs to be listed in the map.\n-             *\/\n-            if ((docTree == null) || propertyMethod.equals(commentSource)) {\n-                classPropertiesMap.put(propertyMethod, commentSource);\n-            }\n-        }\n-\n-        \/**\n-         * Returns the element for the property documentation belonging to the given member.\n-         * @param element the member for which the property documentation is needed.\n-         * @return the element for the property documentation, null if there is none.\n-         *\/\n-        public Element getPropertyElement(Element element) {\n-            return classPropertiesMap.get(element);\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MemberSummaryBuilder.java","additions":0,"deletions":448,"binary":false,"changes":448,"status":"deleted"},{"patch":"@@ -1,196 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.MethodWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;\n-\n-\/**\n- * Builds documentation for a method.\n- *\/\n-public class MethodBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The index of the current field that is being documented at this point\n-     * in time.\n-     *\/\n-    private ExecutableElement currentMethod;\n-\n-    \/**\n-     * The writer to output the method documentation.\n-     *\/\n-    private final MethodWriter writer;\n-\n-    \/**\n-     * The methods being documented.\n-     *\/\n-    private final List<? extends Element> methods;\n-\n-\n-    \/**\n-     * Construct a new MethodBuilder.\n-     *\n-     * @param context       the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private MethodBuilder(Context context,\n-            TypeElement typeElement,\n-            MethodWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        methods = getVisibleMembers(METHODS);\n-    }\n-\n-    \/**\n-     * Construct a new MethodBuilder.\n-     *\n-     * @param context       the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\n-     * @return an instance of a MethodBuilder.\n-     *\/\n-    public static MethodBuilder getInstance(Context context,\n-            TypeElement typeElement, MethodWriter writer) {\n-        return new MethodBuilder(context, typeElement, writer);\n-    }\n-\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !methods.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildMethodDoc(target);\n-    }\n-\n-    \/**\n-     * Build the method documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMethodDoc(Content detailsList) throws DocletException {\n-        if (hasMembersToDocument()) {\n-            Content methodDetailsHeader = writer.getMethodDetailsHeader(detailsList);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element method : methods) {\n-                currentMethod = (ExecutableElement)method;\n-                Content methodContent = writer.getMethodHeader(currentMethod);\n-\n-                buildSignature(methodContent);\n-                buildDeprecationInfo(methodContent);\n-                buildPreviewInfo(methodContent);\n-                buildMethodComments(methodContent);\n-                buildTagInfo(methodContent);\n-\n-                memberList.add(writer.getMemberListItem(methodContent));\n-            }\n-            Content methodDetails = writer.getMethodDetails(methodDetailsHeader, memberList);\n-            detailsList.add(methodDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content methodContent) {\n-        methodContent.add(writer.getSignature(currentMethod));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content methodContent) {\n-        writer.addDeprecated(currentMethod, methodContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content methodContent) {\n-        writer.addPreview(currentMethod, methodContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the method.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodComments(Content methodContent) {\n-        if (!options.noComment()) {\n-            assert utils.isMethod(currentMethod); \/\/ not all executables are methods\n-            var docFinder = utils.docFinder();\n-            Optional<ExecutableElement> r = docFinder.search(currentMethod,\n-                    m -> Result.fromOptional(utils.getFullBody(m).isEmpty() ? Optional.empty() : Optional.of(m))).toOptional();\n-            ExecutableElement method = r.orElse(currentMethod);\n-            TypeMirror containingType = method.getEnclosingElement().asType();\n-            writer.addComments(containingType, method, methodContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param methodContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content methodContent) {\n-        writer.addTags(currentMethod, methodContent);\n-    }\n-\n-    \/**\n-     * Return the method writer for this builder.\n-     *\n-     * @return the method writer for this builder.\n-     *\/\n-    public MethodWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/MethodBuilder.java","additions":0,"deletions":196,"binary":false,"changes":196,"status":"deleted"},{"patch":"@@ -1,181 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import javax.lang.model.element.ModuleElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;\n-\n-\n-\/**\n- * Builds the summary for a given module.\n- *\/\n-public class ModuleSummaryBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The module being documented.\n-     *\/\n-    private final ModuleElement mdle;\n-\n-    \/**\n-     * The doclet specific writer that will output the result.\n-     *\/\n-    private final ModuleSummaryWriter moduleWriter;\n-\n-    \/**\n-     * Construct a new ModuleSummaryBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param mdle the module being documented.\n-     * @param moduleWriter the doclet specific writer that will output the\n-     *        result.\n-     *\/\n-    private ModuleSummaryBuilder(Context context,\n-            ModuleElement mdle, ModuleSummaryWriter moduleWriter) {\n-        super(context);\n-        this.mdle = mdle;\n-        this.moduleWriter = moduleWriter;\n-    }\n-\n-    \/**\n-     * Construct a new ModuleSummaryBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param mdle the module being documented.\n-     * @param moduleWriter the doclet specific writer that will output the\n-     *        result.\n-     *\n-     * @return an instance of a ModuleSummaryBuilder.\n-     *\/\n-    public static ModuleSummaryBuilder getInstance(Context context,\n-            ModuleElement mdle, ModuleSummaryWriter moduleWriter) {\n-        return new ModuleSummaryBuilder(context, mdle, moduleWriter);\n-    }\n-\n-    \/**\n-     * Build the module summary.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    @Override\n-    public void build() throws DocletException {\n-        if (moduleWriter == null) {\n-            \/\/Doclet does not support this output.\n-            return;\n-        }\n-        buildModuleDoc();\n-    }\n-\n-    \/**\n-     * Build the module documentation.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildModuleDoc() throws DocletException {\n-        Content content = moduleWriter.getModuleHeader(mdle.getQualifiedName().toString());\n-\n-        buildContent();\n-\n-        moduleWriter.addModuleFooter();\n-        moduleWriter.printDocument(content);\n-        DocFilesHandler docFilesHandler = configuration.getWriterFactory().getDocFilesHandler(mdle);\n-        docFilesHandler.copyDocFiles();\n-    }\n-\n-    \/**\n-     * Build the content for the module doc.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildContent() throws DocletException {\n-        Content moduleContent = moduleWriter.getContentHeader();\n-\n-        moduleWriter.addModuleSignature(moduleContent);\n-        buildModuleDescription(moduleContent);\n-        buildSummary(moduleContent);\n-\n-        moduleWriter.addModuleContent(moduleContent);\n-    }\n-\n-    \/**\n-     * Builds the list of summary sections for this module.\n-     *\n-     * @param target the module content to which the summaries will\n-     *               be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSummary(Content target) throws DocletException {\n-        Content summariesList = moduleWriter.getSummariesList();\n-\n-        buildPackagesSummary(summariesList);\n-        buildModulesSummary(summariesList);\n-        buildServicesSummary(summariesList);\n-\n-        target.add(moduleWriter.getSummary(summariesList));\n-    }\n-\n-    \/**\n-     * Builds the summary of the module dependencies of this module.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildModulesSummary(Content summariesList) {\n-        moduleWriter.addModulesSummary(summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary of the packages exported or opened by this module.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildPackagesSummary(Content summariesList) {\n-        moduleWriter.addPackagesSummary(summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary of the services used or provided by this module.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildServicesSummary(Content summariesList) {\n-        moduleWriter.addServicesSummary(summariesList);\n-    }\n-\n-    \/**\n-     * Builds the description for this module.\n-     *\n-     * @param moduleContent the content to which the module description will\n-     *                      be added\n-     *\/\n-    protected void buildModuleDescription(Content moduleContent) {\n-        if (!options.noComment()) {\n-            moduleWriter.addModuleDescription(moduleContent);\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ModuleSummaryBuilder.java","additions":0,"deletions":181,"binary":false,"changes":181,"status":"deleted"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import javax.lang.model.element.PackageElement;\n-\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;\n-\n-\n-\/**\n- * Builds the summary for a given package.\n- *\/\n-public class PackageSummaryBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The package being documented.\n-     *\/\n-    private final PackageElement packageElement;\n-\n-    \/**\n-     * The doclet specific writer that will output the result.\n-     *\/\n-    private final PackageSummaryWriter packageWriter;\n-\n-    \/**\n-     * Construct a new PackageSummaryBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param pkg the package being documented.\n-     * @param packageWriter the doclet specific writer that will output the\n-     *        result.\n-     *\/\n-    private PackageSummaryBuilder(Context context,\n-            PackageElement pkg,\n-            PackageSummaryWriter packageWriter) {\n-        super(context);\n-        this.packageElement = pkg;\n-        this.packageWriter = packageWriter;\n-    }\n-\n-    \/**\n-     * Construct a new PackageSummaryBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param pkg the package being documented.\n-     * @param packageWriter the doclet specific writer that will output the\n-     *        result.\n-     *\n-     * @return an instance of a PackageSummaryBuilder.\n-     *\/\n-    public static PackageSummaryBuilder getInstance(Context context,\n-            PackageElement pkg, PackageSummaryWriter packageWriter) {\n-        return new PackageSummaryBuilder(context, pkg, packageWriter);\n-    }\n-\n-    \/**\n-     * Build the package summary.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    @Override\n-    public void build() throws DocletException {\n-        if (packageWriter == null) {\n-            \/\/Doclet does not support this output.\n-            return;\n-        }\n-        buildPackageDoc();\n-    }\n-\n-    \/**\n-     * Build the package documentation.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildPackageDoc() throws DocletException {\n-        Content content = packageWriter.getPackageHeader();\n-\n-        buildContent();\n-\n-        packageWriter.addPackageFooter();\n-        packageWriter.printDocument(content);\n-        DocFilesHandler docFilesHandler = configuration\n-                .getWriterFactory()\n-                .getDocFilesHandler(packageElement);\n-        docFilesHandler.copyDocFiles();\n-    }\n-\n-    \/**\n-     * Build the content for the package.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildContent() throws DocletException {\n-        Content packageContent = packageWriter.getContentHeader();\n-\n-        packageWriter.addPackageSignature(packageContent);\n-        buildPackageDescription(packageContent);\n-        buildPackageTags(packageContent);\n-        buildSummary(packageContent);\n-\n-        packageWriter.addPackageContent(packageContent);\n-    }\n-\n-    \/**\n-     * Builds the list of summaries for the different kinds of types in this package.\n-     *\n-     * @param packageContent the package content to which the summaries will\n-     *                       be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSummary(Content packageContent) throws DocletException {\n-        Content summariesList = packageWriter.getSummariesList();\n-\n-        buildRelatedPackagesSummary(summariesList);\n-        buildAllClassesAndInterfacesSummary(summariesList);\n-\n-        packageContent.add(packageWriter.getPackageSummary(summariesList));\n-    }\n-\n-    \/**\n-     * Builds a list of \"nearby\" packages (subpackages, superpackages, and sibling packages).\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildRelatedPackagesSummary(Content summariesList) {\n-        packageWriter.addRelatedPackagesSummary(summariesList);\n-    }\n-\n-    \/**\n-     * Builds the summary for all classes and interfaces in this package.\n-     *\n-     * @param summariesList the list of summaries to which the summary will be added\n-     *\/\n-    protected void buildAllClassesAndInterfacesSummary(Content summariesList) {\n-        packageWriter.addAllClassesAndInterfacesSummary(summariesList);\n-    }\n-\n-\n-    \/**\n-     * Build the description of the summary.\n-     *\n-     * @param packageContent the content to which the package description will\n-     *                       be added\n-     *\/\n-    protected void buildPackageDescription(Content packageContent) {\n-        if (options.noComment()) {\n-            return;\n-        }\n-        packageWriter.addPackageDescription(packageContent);\n-    }\n-\n-    \/**\n-     * Build the tags of the summary.\n-     *\n-     * @param packageContent the content to which the package tags will be added\n-     *\/\n-    protected void buildPackageTags(Content packageContent) {\n-        if (options.noComment()) {\n-            return;\n-        }\n-        packageWriter.addPackageTags(packageContent);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/PackageSummaryBuilder.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.stream.Collectors;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DocCommentTree;\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.CommentUtils;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.PropertyWriter;\n-\n-import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.PROPERTIES;\n-\n-\/**\n- * Builds documentation for a property.\n- *\/\n-public class PropertyBuilder extends AbstractMemberBuilder {\n-\n-    \/**\n-     * The writer to output the property documentation.\n-     *\/\n-    private final PropertyWriter writer;\n-\n-    \/**\n-     * The list of properties being documented.\n-     *\/\n-    private final List<? extends Element> properties;\n-\n-    \/**\n-     * The index of the current property that is being documented at this point\n-     * in time.\n-     *\/\n-    private ExecutableElement currentProperty;\n-\n-    \/**\n-     * Construct a new PropertyBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     *\/\n-    private PropertyBuilder(Context context,\n-            TypeElement typeElement,\n-            PropertyWriter writer) {\n-        super(context, typeElement);\n-        this.writer = Objects.requireNonNull(writer);\n-        properties = getVisibleMembers(PROPERTIES);\n-    }\n-\n-    \/**\n-     * Construct a new PropertyBuilder.\n-     *\n-     * @param context  the build context.\n-     * @param typeElement the class whose members are being documented.\n-     * @param writer the doclet specific writer.\n-     * @return the new PropertyBuilder\n-     *\/\n-    public static PropertyBuilder getInstance(Context context,\n-            TypeElement typeElement,\n-            PropertyWriter writer) {\n-        return new PropertyBuilder(context, typeElement, writer);\n-    }\n-\n-    \/**\n-     * Returns whether or not there are members to document.\n-     *\n-     * @return whether or not there are members to document\n-     *\/\n-    @Override\n-    public boolean hasMembersToDocument() {\n-        return !properties.isEmpty();\n-    }\n-\n-    @Override\n-    public void build(Content target) throws DocletException {\n-        buildPropertyDoc(target);\n-    }\n-\n-    \/**\n-     * Build the property documentation.\n-     *\n-     * @param detailsList the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildPropertyDoc(Content detailsList) throws DocletException {\n-        if (hasMembersToDocument()) {\n-            Content propertyDetailsHeader = writer.getPropertyDetailsHeader(detailsList);\n-            Content memberList = writer.getMemberList();\n-\n-            for (Element property : properties) {\n-                currentProperty = (ExecutableElement)property;\n-                Content propertyContent = writer.getPropertyHeaderContent(currentProperty);\n-\n-                buildSignature(propertyContent);\n-                buildPropertyComments(propertyContent);\n-                buildTagInfo(propertyContent);\n-\n-                memberList.add(writer.getMemberListItem(propertyContent));\n-            }\n-            Content propertyDetails = writer.getPropertyDetails(propertyDetailsHeader, memberList);\n-            detailsList.add(propertyDetails);\n-        }\n-    }\n-\n-    \/**\n-     * Build the signature.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildSignature(Content propertyContent) {\n-        propertyContent.add(writer.getSignature(currentProperty));\n-    }\n-\n-    \/**\n-     * Build the deprecation information.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecationInfo(Content propertyContent) {\n-        writer.addDeprecated(currentProperty, propertyContent);\n-    }\n-\n-    \/**\n-     * Build the preview information.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPreviewInfo(Content propertyContent) {\n-        writer.addPreview(currentProperty, propertyContent);\n-    }\n-\n-    \/**\n-     * Build the comments for the property.  Do nothing if\n-     * {@link BaseOptions#noComment()} is set to true.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildPropertyComments(Content propertyContent) {\n-        if (!options.noComment()) {\n-            writer.addComments(currentProperty, propertyContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the tag information.\n-     *\n-     * @param propertyContent the content to which the documentation will be added\n-     *\/\n-    protected void buildTagInfo(Content propertyContent) {\n-        CommentUtils cmtUtils = configuration.cmtUtils;\n-        DocCommentTree dct = utils.getDocCommentTree(currentProperty);\n-        var fullBody = dct.getFullBody();\n-        ArrayList<DocTree> blockTags = dct.getBlockTags().stream()\n-                .filter(t -> t.getKind() != DocTree.Kind.RETURN)\n-                .collect(Collectors.toCollection(ArrayList::new));\n-        String sig = \"#\" + currentProperty.getSimpleName() + \"()\";\n-        blockTags.add(cmtUtils.makeSeeTree(sig, currentProperty));\n-        \/\/ The property method is used as a proxy for the property\n-        \/\/ (which does not have an explicit element of its own.)\n-        \/\/ Temporarily override the doc comment for the property method\n-        \/\/ by removing the `@return` tag, which should not be displayed for\n-        \/\/ the property.\n-        CommentUtils.DocCommentInfo prev = cmtUtils.setDocCommentTree(currentProperty, fullBody, blockTags);\n-        try {\n-            writer.addTags(currentProperty, propertyContent);\n-        } finally {\n-            cmtUtils.setDocCommentInfo(currentProperty, prev);\n-        }\n-    }\n-\n-    \/**\n-     * Return the property writer for this builder.\n-     *\n-     * @return the property writer for this builder.\n-     *\/\n-    public PropertyWriter getWriter() {\n-        return writer;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/PropertyBuilder.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -1,577 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n-\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.SerialFieldTree;\n-import com.sun.source.doctree.SerialTree;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletException;\n-import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * Builds the serialized form.\n- *\/\n-public class SerializedFormBuilder extends AbstractBuilder {\n-\n-    \/**\n-     * The writer for this builder.\n-     *\/\n-    private SerializedFormWriter writer;\n-\n-    \/**\n-     * The writer for serializable fields.\n-     *\/\n-    private SerializedFormWriter.SerialFieldWriter fieldWriter;\n-\n-    \/**\n-     * The writer for serializable method documentation.\n-     *\/\n-    private SerializedFormWriter.SerialMethodWriter methodWriter;\n-\n-    \/**\n-     * The header for the serial version UID.  Save the string\n-     * here instead of the properties file because we do not want\n-     * this string to be localized.\n-     *\/\n-    private static final String SERIAL_VERSION_UID = \"serialVersionUID\";\n-    private static final String SERIAL_VERSION_UID_HEADER = SERIAL_VERSION_UID + \":\";\n-\n-    \/**\n-     * The current package being documented.\n-     *\/\n-    private PackageElement currentPackage;\n-\n-    \/**\n-     * The current class being documented.\n-     *\/\n-    private TypeElement currentTypeElement;\n-\n-    \/**\n-     * The current member being documented.\n-     *\/\n-    protected Element currentMember;\n-\n-    \/**\n-     * Construct a new SerializedFormBuilder.\n-     * @param context  the build context.\n-     *\/\n-    private SerializedFormBuilder(Context context) {\n-        super(context);\n-    }\n-\n-    \/**\n-     * Construct a new SerializedFormBuilder.\n-     *\n-     * @param context  the build context.\n-     * @return the new SerializedFormBuilder\n-     *\/\n-    public static SerializedFormBuilder getInstance(Context context) {\n-        return new SerializedFormBuilder(context);\n-    }\n-\n-    \/**\n-     * Build the serialized form.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    @Override\n-    public void build() throws DocletException {\n-        SortedSet<TypeElement> rootclasses = new TreeSet<>(utils.comparators.makeGeneralPurposeComparator());\n-        rootclasses.addAll(configuration.getIncludedTypeElements());\n-        if (!serialClassFoundToDocument(rootclasses)) {\n-            \/\/Nothing to document.\n-            return;\n-        }\n-        writer = configuration.getWriterFactory().getSerializedFormWriter();\n-        if (writer == null) {\n-            \/\/Doclet does not support this output.\n-            return;\n-        }\n-        buildSerializedForm();\n-    }\n-\n-    \/**\n-     * Build the serialized form.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSerializedForm() throws DocletException {\n-        Content content = writer.getHeader(resources.getText(\n-                \"doclet.Serialized_Form\"));\n-\n-        buildSerializedFormSummaries();\n-\n-        writer.addFooter();\n-        writer.printDocument(content);\n-    }\n-\n-    \/**\n-     * Build the serialized form summaries.\n-     *\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSerializedFormSummaries()\n-            throws DocletException {\n-        Content c = writer.getSerializedSummariesHeader();\n-        for (PackageElement pkg : configuration.packages) {\n-            currentPackage = pkg;\n-\n-            buildPackageSerializedForm(c);\n-        }\n-        writer.addSerializedContent(c);\n-    }\n-\n-    \/**\n-     * Build the package serialized form for the current package being processed.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildPackageSerializedForm(Content target) throws DocletException {\n-        Content packageSerializedHeader = writer.getPackageSerializedHeader();\n-        SortedSet<TypeElement> classes = utils.getAllClassesUnfiltered(currentPackage);\n-        if (classes.isEmpty()) {\n-            return;\n-        }\n-        if (!serialInclude(utils, currentPackage)) {\n-            return;\n-        }\n-        if (!serialClassFoundToDocument(classes)) {\n-            return;\n-        }\n-\n-        buildPackageHeader(packageSerializedHeader);\n-        buildClassSerializedForm(packageSerializedHeader);\n-\n-        writer.addPackageSerialized(target, packageSerializedHeader);\n-    }\n-\n-    \/**\n-     * Build the package header.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildPackageHeader(Content target) {\n-        target.add(writer.getPackageHeader(currentPackage));\n-    }\n-\n-    \/**\n-     * Build the class serialized form.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassSerializedForm(Content target)\n-            throws DocletException {\n-        Content classSerializedHeader = writer.getClassSerializedHeader();\n-        SortedSet<TypeElement> typeElements = utils.getAllClassesUnfiltered(currentPackage);\n-        for (TypeElement typeElement : typeElements) {\n-            currentTypeElement = typeElement;\n-            fieldWriter = writer.getSerialFieldWriter(currentTypeElement);\n-            methodWriter = writer.getSerialMethodWriter(currentTypeElement);\n-            if (utils.isClass(currentTypeElement) && utils.isSerializable(currentTypeElement)) {\n-                if (!serialClassInclude(utils, currentTypeElement)) {\n-                    continue;\n-                }\n-                Content classHeader = writer.getClassHeader(currentTypeElement);\n-\n-                buildSerialUIDInfo(classHeader);\n-                buildClassContent(classHeader);\n-\n-                classSerializedHeader.add(writer.getMember(classHeader));\n-            }\n-        }\n-        target.add(classSerializedHeader);\n-    }\n-\n-    \/**\n-     * Build the serial UID information for the given class.\n-     *\n-     * @param target the content to which the serial UID information will be added\n-     *\/\n-    protected void buildSerialUIDInfo(Content target) {\n-        Content serialUIDHeader = writer.getSerialUIDInfoHeader();\n-        for (VariableElement field : utils.getFieldsUnfiltered(currentTypeElement)) {\n-            if (field.getSimpleName().toString().compareTo(SERIAL_VERSION_UID) == 0 &&\n-                field.getConstantValue() != null) {\n-                writer.addSerialUIDInfo(SERIAL_VERSION_UID_HEADER,\n-                                        utils.constantValueExpression(field), serialUIDHeader);\n-                break;\n-            }\n-        }\n-        target.add(serialUIDHeader);\n-    }\n-\n-    \/**\n-     * Build the summaries for the methods and fields.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildClassContent(Content target) throws DocletException {\n-        Content classContent = writer.getClassContentHeader();\n-\n-        buildSerializableMethods(classContent);\n-        buildFieldHeader(classContent);\n-        buildSerializableFields(classContent);\n-\n-        target.add(classContent);\n-    }\n-\n-    \/**\n-     * Build the summaries for the methods that belong to the given class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSerializableMethods(Content target) throws DocletException {\n-        Content serializableMethodsHeader = methodWriter.getSerializableMethodsHeader();\n-        for (var i = utils.serializationMethods(currentTypeElement).iterator(); i.hasNext(); ) {\n-            currentMember = i.next();\n-            Content methodsContent = methodWriter.getMethodsContentHeader(!i.hasNext());\n-\n-            buildMethodSubHeader(methodsContent);\n-            buildDeprecatedMethodInfo(methodsContent);\n-            buildMethodInfo(methodsContent);\n-\n-            serializableMethodsHeader.add(methodsContent);\n-        }\n-        if (!utils.serializationMethods(currentTypeElement).isEmpty()) {\n-            target.add(methodWriter.getSerializableMethods(\n-                    resources.getText(\"doclet.Serialized_Form_methods\"),\n-                    serializableMethodsHeader));\n-            if (utils.isSerializable(currentTypeElement) && !utils.isExternalizable(currentTypeElement)) {\n-                if (utils.serializationMethods(currentTypeElement).isEmpty()) {\n-                    Content noCustomizationMsg = methodWriter.getNoCustomizationMsg(\n-                            resources.getText(\"doclet.Serializable_no_customization\"));\n-                    target.add(methodWriter.getSerializableMethods(\n-                            resources.getText(\"doclet.Serialized_Form_methods\"),\n-                            noCustomizationMsg));\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Build the method sub header.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodSubHeader(Content methodsContent)  {\n-        methodWriter.addMemberHeader((ExecutableElement)currentMember, methodsContent);\n-    }\n-\n-    \/**\n-     * Build the deprecated method description.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildDeprecatedMethodInfo(Content methodsContent) {\n-        methodWriter.addDeprecatedMemberInfo((ExecutableElement)currentMember, methodsContent);\n-    }\n-\n-    \/**\n-     * Build the information for the method.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildMethodInfo(Content methodsContent) throws DocletException  {\n-        if (options.noComment()) {\n-            return;\n-        }\n-\n-        buildMethodDescription(methodsContent);\n-        buildMethodTags(methodsContent);\n-    }\n-\n-    \/**\n-     * Build method description.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodDescription(Content methodsContent) {\n-        methodWriter.addMemberDescription((ExecutableElement)currentMember, methodsContent);\n-    }\n-\n-    \/**\n-     * Build the method tags.\n-     *\n-     * @param methodsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildMethodTags(Content methodsContent) {\n-        methodWriter.addMemberTags((ExecutableElement)currentMember, methodsContent);\n-        ExecutableElement method = (ExecutableElement)currentMember;\n-        if (method.getSimpleName().toString().compareTo(\"writeExternal\") == 0\n-                && utils.getSerialDataTrees(method).isEmpty()) {\n-            if (options.serialWarn()) {\n-                TypeElement encl  = (TypeElement) method.getEnclosingElement();\n-                messages.warning(currentMember,\n-                        \"doclet.MissingSerialDataTag\", encl.getQualifiedName().toString(),\n-                        method.getSimpleName().toString());\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Build the field header.\n-     *\n-     * @param classContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldHeader(Content classContent) {\n-        if (!utils.serializableFields(currentTypeElement).isEmpty()) {\n-            buildFieldSerializationOverview(currentTypeElement, classContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the serialization overview for the given class.\n-     *\n-     * @param typeElement the class to print the overview for.\n-     * @param classContent the content to which the documentation will be added\n-     *\/\n-    public void buildFieldSerializationOverview(TypeElement typeElement, Content classContent) {\n-        if (utils.definesSerializableFields(typeElement)) {\n-            VariableElement ve = utils.serializableFields(typeElement).first();\n-            \/\/ Check to see if there are inline comments, tags or deprecation\n-            \/\/ information to be printed.\n-            if (fieldWriter.shouldPrintOverview(ve)) {\n-                Content serializableFieldsHeader = fieldWriter.getSerializableFieldsHeader();\n-                Content fieldsOverviewContent = fieldWriter.getFieldsContentHeader(true);\n-                fieldWriter.addMemberDeprecatedInfo(ve, fieldsOverviewContent);\n-                if (!options.noComment()) {\n-                    fieldWriter.addMemberDescription(ve, fieldsOverviewContent);\n-                    fieldWriter.addMemberTags(ve, fieldsOverviewContent);\n-                }\n-                serializableFieldsHeader.add(fieldsOverviewContent);\n-                classContent.add(fieldWriter.getSerializableFields(\n-                        resources.getText(\"doclet.Serialized_Form_class\"),\n-                        serializableFieldsHeader));\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Build the summaries for the fields that belong to the given class.\n-     *\n-     * @param target the content to which the documentation will be added\n-     * @throws DocletException if there is a problem while building the documentation\n-     *\/\n-    protected void buildSerializableFields(Content target)\n-            throws DocletException {\n-        Collection<VariableElement> members = utils.serializableFields(currentTypeElement);\n-        if (!members.isEmpty()) {\n-            Content serializableFieldsHeader = fieldWriter.getSerializableFieldsHeader();\n-            for (var i = members.iterator(); i.hasNext();) {\n-                currentMember = i.next();\n-                if (!utils.definesSerializableFields(currentTypeElement)) {\n-                    Content fieldsContent = fieldWriter.getFieldsContentHeader(!i.hasNext());\n-\n-                    buildFieldSubHeader(fieldsContent);\n-                    buildFieldDeprecationInfo(fieldsContent);\n-                    buildFieldInfo(fieldsContent);\n-\n-                    serializableFieldsHeader.add(fieldsContent);\n-                } else {\n-                    buildSerialFieldTagsInfo(serializableFieldsHeader);\n-                }\n-            }\n-            target.add(fieldWriter.getSerializableFields(\n-                    resources.getText(\"doclet.Serialized_Form_fields\"),\n-                    serializableFieldsHeader));\n-        }\n-    }\n-\n-    \/**\n-     * Build the field sub header.\n-     *\n-     * @param fieldsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldSubHeader(Content fieldsContent) {\n-        if (!utils.definesSerializableFields(currentTypeElement)) {\n-            VariableElement field = (VariableElement) currentMember;\n-            fieldWriter.addMemberHeader(field.asType(),\n-                    utils.getSimpleName(field),\n-                    fieldsContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the field deprecation information.\n-     *\n-     * @param fieldsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldDeprecationInfo(Content fieldsContent) {\n-        if (!utils.definesSerializableFields(currentTypeElement)) {\n-            fieldWriter.addMemberDeprecatedInfo((VariableElement)currentMember,\n-                    fieldsContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the serial field tags information.\n-     *\n-     * @param target the content to which the documentation will be added\n-     *\/\n-    protected void buildSerialFieldTagsInfo(Content target) {\n-        if (options.noComment()) {\n-            return;\n-        }\n-        VariableElement field = (VariableElement)currentMember;\n-        \/\/ Process Serializable Fields specified as array of\n-        \/\/ ObjectStreamFields. Print a member for each serialField tag.\n-        \/\/ (There should be one serialField tag per ObjectStreamField\n-        \/\/ element.)\n-        SortedSet<SerialFieldTree> tags = new TreeSet<>(utils.comparators.makeSerialFieldTreeComparator());\n-        \/\/ sort the elements\n-        tags.addAll(utils.getSerialFieldTrees(field));\n-\n-        CommentHelper ch = utils.getCommentHelper(field);\n-        for (SerialFieldTree tag : tags) {\n-            if (tag.getName() == null || tag.getType() == null)  \/\/ ignore malformed @serialField tags\n-                continue;\n-            Content fieldsContent = fieldWriter.getFieldsContentHeader(tag.equals(tags.last()));\n-            TypeMirror type = ch.getReferencedType(tag);\n-            fieldWriter.addMemberHeader(type, tag.getName().getName().toString(), fieldsContent);\n-            fieldWriter.addMemberDescription(field, tag, fieldsContent);\n-            target.add(fieldsContent);\n-        }\n-    }\n-\n-    \/**\n-     * Build the field information.\n-     *\n-     * @param fieldsContent the content to which the documentation will be added\n-     *\/\n-    protected void buildFieldInfo(Content fieldsContent) {\n-        if (options.noComment()) {\n-            return;\n-        }\n-        VariableElement field = (VariableElement)currentMember;\n-        TypeElement te = utils.getEnclosingTypeElement(currentMember);\n-        \/\/ Process default Serializable field.\n-        if ((utils.getSerialTrees(field).isEmpty()) \/*&& !field.isSynthetic()*\/\n-                && options.serialWarn()) {\n-            messages.warning(field,\n-                    \"doclet.MissingSerialTag\", utils.getFullyQualifiedName(te),\n-                    utils.getSimpleName(field));\n-        }\n-        fieldWriter.addMemberDescription(field, fieldsContent);\n-        fieldWriter.addMemberTags(field, fieldsContent);\n-    }\n-\n-    \/**\n-     * Returns true if the given Element should be included\n-     * in the serialized form.\n-     *\n-     * @param utils the utils object\n-     * @param element the Element object to check for serializability\n-     * @return true if the element should be included in the serial form\n-     *\/\n-    public static boolean serialInclude(Utils utils, Element element) {\n-        if (element == null) {\n-            return false;\n-        }\n-        return utils.isClass(element)\n-                ? serialClassInclude(utils, (TypeElement)element)\n-                : serialDocInclude(utils, element);\n-    }\n-\n-    \/**\n-     * Returns true if the given TypeElement should be included\n-     * in the serialized form.\n-     *\n-     * @param te the TypeElement object to check for serializability.\n-     *\/\n-    private static boolean serialClassInclude(Utils utils, TypeElement te) {\n-        if (utils.isEnum(te)) {\n-            return false;\n-        }\n-        if (utils.isSerializable(te)) {\n-            if (utils.hasDocCommentTree(te) && !utils.getSerialTrees(te).isEmpty()) {\n-                return serialDocInclude(utils, te);\n-            } else {\n-                return utils.isPublic(te) || utils.isProtected(te);\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Return true if the given Element should be included\n-     * in the serialized form.\n-     *\n-     * @param element the Element to check for serializability.\n-     *\/\n-    private static boolean serialDocInclude(Utils utils, Element element) {\n-        if (utils.isEnum(element)) {\n-            return false;\n-        }\n-        List<? extends SerialTree> serial = utils.getSerialTrees(element);\n-        if (!serial.isEmpty()) {\n-            CommentHelper ch = utils.getCommentHelper(element);\n-            \/\/ look for `@serial include|exclude`\n-            String serialtext = Utils.toLowerCase(serial.get(0).toString());\n-            if (serialtext.contains(\"exclude\")) {\n-                return false;\n-            } else if (serialtext.contains(\"include\")) {\n-                return true;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Return true if any of the given typeElements have a {@code @serial include} tag.\n-     *\n-     * @param classes the typeElements to check.\n-     * @return true if any of the given typeElements have a {@code @serial include} tag.\n-     *\/\n-    private boolean serialClassFoundToDocument(SortedSet<TypeElement> classes) {\n-        for (TypeElement aClass : classes) {\n-            if (serialClassInclude(utils, aClass)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/SerializedFormBuilder.java","additions":0,"deletions":577,"binary":false,"changes":577,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This doclet-independent package has a set of classes and\n- * interfaces that are the building blocks for doclets. They\n- * define the basic structure of doclets and make doclet\n- * writing much easier because they provide the content generation\n- * code to be shared among different doclets. Builders only provide\n- * the structure and content of API documentation.\n- * They do not directly provide any style markup.\n- *\/\n-package jdk.javadoc.internal.doclets.toolkit.builders;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/package-info.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -73,1 +73,1 @@\n- *          {@link jdk.javadoc.internal.doclets.toolkit.Content}, the {@code markup} library\n+ *          {@link jdk.javadoc.internal.doclets.formats.html.Content}, the {@code markup} library\n@@ -78,12 +78,0 @@\n- *          The {@link jdk.javadoc.internal.doclets.toolkit toolkit} package provides\n- *          support for a format-neutral\n- *          {@linkplain jdk.javadoc.internal.doclets.toolkit.AbstractDoclet abstract doclet},\n- *          which uses\n- *          {@linkplain jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder builders}\n- *          to generate pages of abstract\n- *          {@linkplain jdk.javadoc.internal.doclets.toolkit.Content content}.\n- *\n- *          <p>The format-specific content for each page is provided by implementations\n- *          of various <em>writer<\/em> interfaces, created by a format-specific\n- *          {@linkplain jdk.javadoc.internal.doclets.toolkit.WriterFactory writer factory}.\n- *\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/package-info.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-                             \"-Xdebug \" +\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/SunCommandLineLauncher.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -292,3 +292,0 @@\n-            if (chunkHeader.getLastNanos() > filterEnd)  {\n-              return true;\n-            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n@@ -199,0 +202,3 @@\n+                    if (Logger.shouldLog(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO)) {\n+                        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Unexpected chunk with 0 ns duration\");\n+                    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n@@ -65,0 +68,4 @@\n+\n+        if (Logger.shouldLog(LogTag.JFR_DCMD, LogLevel.DEBUG)) {\n+            Logger.log(LogTag.JFR_DCMD, LogLevel.DEBUG, \"JFR.view time range: \" + configuration.startTime + \" - \" + configuration.endTime);\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdView.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    public QueryRecording(Configuration configuration, ArgumentParser parser) throws IOException, DCmdException {\n+    public QueryRecording(Configuration configuration, ArgumentParser parser) throws IOException, DCmdException, UserDataException {\n@@ -62,1 +62,1 @@\n-            throw new DCmdException(\"No recording data available. Start a recording with JFR.start\");\n+            throw new DCmdException(\"No recording data available. Start a recording with JFR.start.\");\n@@ -95,0 +95,3 @@\n+        if (chunks.isEmpty()) {\n+            throw new UserDataException(\"No recording data found on disk.\");\n+        }\n@@ -103,1 +106,4 @@\n-            list.add(currentChunk());\n+            RepositoryChunk current = currentChunk();\n+            if (current != null) {\n+                list.add(current);\n+            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/QueryRecording.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n-%define package_filelist %{_tmppath}\/%{name}.files\n-%define app_filelist %{_tmppath}\/%{name}.app.files\n-%define filesystem_filelist %{_tmppath}\/%{name}.filesystem.files\n+%define package_filelist %{_builddir}\/%{name}.files\n+%define app_filelist %{_builddir}\/%{name}.app.files\n+%define filesystem_filelist %{_builddir}\/%{name}.filesystem.files\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.spec","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        if ((moduleInfo != null) != isModular) {\n+        if ((moduleInfo == null) == isModular) {\n@@ -269,4 +269,1 @@\n-        if (value.isPresent()) {\n-            return value.get().toString();\n-        }\n-        return null;\n+        return value.map(Object::toString).orElse(null);\n@@ -275,2 +272,1 @@\n-    private static <T> T getPathParam(Map<String, ? super Object> params,\n-            String paramName, Supplier<T> func) throws ConfigException {\n+    private static <T> T getPathParam(String paramName, Supplier<T> func) throws ConfigException {\n@@ -288,1 +284,1 @@\n-        return getPathParam(params, paramName, () -> {\n+        return getPathParam(paramName, () -> {\n@@ -307,1 +303,1 @@\n-                    .collect(Collectors.toUnmodifiableList());\n+                    .toList();\n@@ -315,7 +311,3 @@\n-        return getPathParam(params, paramName, () -> {\n-            String value = (String) params.get(paramName);\n-            return (value == null) ? List.of() :\n-                    List.of(value.split(File.pathSeparator)).stream()\n-                    .map(Path::of)\n-                    .collect(Collectors.toUnmodifiableList());\n-        });\n+        return getPathParam(paramName, () ->\n+                params.get(paramName) instanceof String value ?\n+                        Stream.of(value.split(File.pathSeparator)).map(Path::of).toList() : List.of());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherData.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-NopLogAppender nopLogAppender;\n+char nopLogAppenderMemory[sizeof(NopLogAppender)] = {};\n@@ -49,1 +49,3 @@\n-} standardLogAppender;\n+};\n+\n+char standardLogAppenderMemory[sizeof(StandardLogAppender)] = {};\n@@ -117,0 +119,3 @@\n+    \/\/ The log appender is set for the lifetime of the application.\n+    \/\/ Use in-place new to avoid accessing destroyed instance\n+    \/\/ when the shared object destructor logs something.\n@@ -118,1 +123,1 @@\n-        Logger::defaultLogger().setAppender(standardLogAppender);\n+        Logger::defaultLogger().setAppender(*new (standardLogAppenderMemory) StandardLogAppender());\n@@ -120,1 +125,1 @@\n-        Logger::defaultLogger().setAppender(nopLogAppender);\n+        Logger::defaultLogger().setAppender(*new (nopLogAppenderMemory) NopLogAppender());\n","filename":"src\/jdk.jpackage\/share\/native\/common\/app.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {\n-        setTcpkeepAliveProbes0(fd, value);\n+    void setTcpKeepAliveProbes(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveProbes0(fd, value);\n@@ -86,2 +86,2 @@\n-    int getTcpkeepAliveProbes(int fd) throws SocketException {\n-        return getTcpkeepAliveProbes0(fd);\n+    int getTcpKeepAliveProbes(int fd) throws SocketException {\n+        return getTcpKeepAliveProbes0(fd);\n@@ -120,1 +120,1 @@\n-    private static native void setTcpkeepAliveProbes0(int fd, int value) throws SocketException;\n+    private static native void setTcpKeepAliveProbes0(int fd, int value) throws SocketException;\n@@ -124,1 +124,1 @@\n-    private static native int getTcpkeepAliveProbes0(int fd) throws SocketException;\n+    private static native int getTcpKeepAliveProbes0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/aix\/classes\/jdk\/net\/AIXSocketOptions.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n- * Method:    setTcpkeepAliveProbes0\n+ * Method:    setTcpKeepAliveProbes0\n@@ -156,1 +156,1 @@\n-JNIEXPORT void JNICALL Java_jdk_net_AIXSocketOptions_setTcpkeepAliveProbes0\n+JNIEXPORT void JNICALL Java_jdk_net_AIXSocketOptions_setTcpKeepAliveProbes0\n@@ -186,1 +186,1 @@\n- * Method:    getTcpkeepAliveProbes0\n+ * Method:    getTcpKeepAliveProbes0\n@@ -189,1 +189,1 @@\n-JNIEXPORT jint JNICALL Java_jdk_net_AIXSocketOptions_getTcpkeepAliveProbes0\n+JNIEXPORT jint JNICALL Java_jdk_net_AIXSocketOptions_getTcpKeepAliveProbes0\n","filename":"src\/jdk.net\/aix\/native\/libextnet\/AIXSocketOptions.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {\n-        setTcpkeepAliveProbes0(fd, value);\n+    void setTcpKeepAliveProbes(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveProbes0(fd, value);\n@@ -86,2 +86,2 @@\n-    int getTcpkeepAliveProbes(int fd) throws SocketException {\n-        return getTcpkeepAliveProbes0(fd);\n+    int getTcpKeepAliveProbes(int fd) throws SocketException {\n+        return getTcpKeepAliveProbes0(fd);\n@@ -130,1 +130,1 @@\n-    private static native void setTcpkeepAliveProbes0(int fd, int value) throws SocketException;\n+    private static native void setTcpKeepAliveProbes0(int fd, int value) throws SocketException;\n@@ -134,1 +134,1 @@\n-    private static native int getTcpkeepAliveProbes0(int fd) throws SocketException;\n+    private static native int getTcpKeepAliveProbes0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n- * Method:    setTcpkeepAliveProbes0\n+ * Method:    setTcpKeepAliveProbes0\n@@ -159,1 +159,1 @@\n-JNIEXPORT void JNICALL Java_jdk_net_LinuxSocketOptions_setTcpkeepAliveProbes0\n+JNIEXPORT void JNICALL Java_jdk_net_LinuxSocketOptions_setTcpKeepAliveProbes0\n@@ -189,1 +189,1 @@\n- * Method:    getTcpkeepAliveProbes0\n+ * Method:    getTcpKeepAliveProbes0\n@@ -192,1 +192,1 @@\n-JNIEXPORT jint JNICALL Java_jdk_net_LinuxSocketOptions_getTcpkeepAliveProbes0\n+JNIEXPORT jint JNICALL Java_jdk_net_LinuxSocketOptions_getTcpKeepAliveProbes0\n","filename":"src\/jdk.net\/linux\/native\/libextnet\/LinuxSocketOptions.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {\n-        setTcpkeepAliveProbes0(fd, value);\n+    void setTcpKeepAliveProbes(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveProbes0(fd, value);\n@@ -72,2 +72,2 @@\n-    int getTcpkeepAliveProbes(int fd) throws SocketException {\n-        return getTcpkeepAliveProbes0(fd);\n+    int getTcpKeepAliveProbes(int fd) throws SocketException {\n+        return getTcpKeepAliveProbes0(fd);\n@@ -106,1 +106,1 @@\n-    private static native void setTcpkeepAliveProbes0(int fd, int value) throws SocketException;\n+    private static native void setTcpKeepAliveProbes0(int fd, int value) throws SocketException;\n@@ -110,1 +110,1 @@\n-    private static native int getTcpkeepAliveProbes0(int fd) throws SocketException;\n+    private static native int getTcpKeepAliveProbes0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n- * Method:    setTcpkeepAliveProbes0\n+ * Method:    setTcpKeepAliveProbes0\n@@ -102,1 +102,1 @@\n-JNIEXPORT void JNICALL Java_jdk_net_MacOSXSocketOptions_setTcpkeepAliveProbes0\n+JNIEXPORT void JNICALL Java_jdk_net_MacOSXSocketOptions_setTcpKeepAliveProbes0\n@@ -132,1 +132,1 @@\n- * Method:    getTcpkeepAliveProbes0\n+ * Method:    getTcpKeepAliveProbes0\n@@ -135,1 +135,1 @@\n-JNIEXPORT jint JNICALL Java_jdk_net_MacOSXSocketOptions_getTcpkeepAliveProbes0\n+JNIEXPORT jint JNICALL Java_jdk_net_MacOSXSocketOptions_getTcpKeepAliveProbes0\n","filename":"src\/jdk.net\/macosx\/native\/libextnet\/MacOSXSocketOptions.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-                    setTcpkeepAliveProbes(fd, (Integer) value);\n+                    setTcpKeepAliveProbes(fd, (Integer) value);\n@@ -310,1 +310,1 @@\n-                    return getTcpkeepAliveProbes(fd);\n+                    return getTcpKeepAliveProbes(fd);\n@@ -346,1 +346,1 @@\n-    private static void setTcpkeepAliveProbes(FileDescriptor fd, int value)\n+    private static void setTcpKeepAliveProbes(FileDescriptor fd, int value)\n@@ -348,1 +348,1 @@\n-        platformSocketOptions.setTcpkeepAliveProbes(fdAccess.get(fd), value);\n+        platformSocketOptions.setTcpKeepAliveProbes(fdAccess.get(fd), value);\n@@ -366,2 +366,2 @@\n-    private static int getTcpkeepAliveProbes(FileDescriptor fd) throws SocketException {\n-        return platformSocketOptions.getTcpkeepAliveProbes(fdAccess.get(fd));\n+    private static int getTcpKeepAliveProbes(FileDescriptor fd) throws SocketException {\n+        return platformSocketOptions.getTcpKeepAliveProbes(fdAccess.get(fd));\n@@ -441,1 +441,1 @@\n-        void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {\n+        void setTcpKeepAliveProbes(int fd, final int value) throws SocketException {\n@@ -465,1 +465,1 @@\n-        int getTcpkeepAliveProbes(int fd) throws SocketException {\n+        int getTcpKeepAliveProbes(int fd) throws SocketException {\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/ExtendedSocketOptions.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,5 @@\n+    @Override\n+    boolean keepAliveOptionsSupported() {\n+        return keepAliveOptionsSupported0();\n+    }\n+\n@@ -54,0 +59,31 @@\n+    @Override\n+    void setTcpKeepAliveProbes(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveProbes0(fd, value);\n+    }\n+\n+    @Override\n+    int getTcpKeepAliveProbes(int fd) throws SocketException {\n+        return getTcpKeepAliveProbes0(fd);\n+    }\n+\n+    @Override\n+    void setTcpKeepAliveTime(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveTime0(fd, value);\n+    }\n+\n+    @Override\n+    int getTcpKeepAliveTime(int fd) throws SocketException {\n+        return getTcpKeepAliveTime0(fd);\n+    }\n+\n+    @Override\n+    void setTcpKeepAliveIntvl(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveIntvl0(fd, value);\n+    }\n+\n+    @Override\n+    int getTcpKeepAliveIntvl(int fd) throws SocketException {\n+        return getTcpKeepAliveIntvl0(fd);\n+    }\n+\n+    private static native boolean keepAliveOptionsSupported0();\n@@ -56,0 +92,6 @@\n+    private static native void setTcpKeepAliveProbes0(int fd, int value) throws SocketException;\n+    private static native int getTcpKeepAliveProbes0(int fd) throws SocketException;\n+    private static native void setTcpKeepAliveTime0(int fd, int value) throws SocketException;\n+    private static native int getTcpKeepAliveTime0(int fd) throws SocketException;\n+    private static native void setTcpKeepAliveIntvl0(int fd, int value) throws SocketException;\n+    private static native int getTcpKeepAliveIntvl0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/windows\/classes\/jdk\/net\/WindowsSocketOptions.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,2 @@\n-        if (errno == ENOPROTOOPT) {\n+        int error = WSAGetLastError();\n+        if (error == WSAENOPROTOOPT) {\n@@ -46,0 +47,51 @@\n+static jint socketOptionSupported(jint level, jint optname) {\n+    WSADATA wsaData;\n+    jint error = WSAStartup(MAKEWORD(2, 2), &wsaData);\n+\n+    if (error != 0) {\n+        return 0;\n+    }\n+\n+    SOCKET sock;\n+    jint one = 1;\n+    jint rv;\n+    socklen_t sz = sizeof(one);\n+\n+    \/* First try IPv6; fall back to IPv4. *\/\n+    sock = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);\n+    if (sock == INVALID_SOCKET) {\n+        error = WSAGetLastError();\n+        if (error == WSAEPFNOSUPPORT || error == WSAEAFNOSUPPORT) {\n+            sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n+        }\n+        if (sock == INVALID_SOCKET) {\n+            return 0;\n+        }\n+    }\n+\n+    rv = getsockopt(sock, level, optname, (char*) &one, &sz);\n+    error = WSAGetLastError();\n+\n+    if (rv != 0 && error == WSAENOPROTOOPT) {\n+        rv = 0;\n+    } else {\n+        rv = 1;\n+    }\n+\n+    closesocket(sock);\n+    WSACleanup();\n+\n+    return rv;\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    keepAliveOptionsSupported0\n+ * Signature: ()Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_jdk_net_WindowsSocketOptions_keepAliveOptionsSupported0\n+(JNIEnv *env, jobject unused) {\n+    return socketOptionSupported(IPPROTO_TCP, TCP_KEEPIDLE) && socketOptionSupported(IPPROTO_TCP, TCP_KEEPCNT)\n+            && socketOptionSupported(IPPROTO_TCP, TCP_KEEPINTVL);\n+}\n+\n@@ -106,0 +158,75 @@\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    setTcpKeepAliveProbes0\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_WindowsSocketOptions_setTcpKeepAliveProbes0\n+(JNIEnv *env, jobject unused, jint fd, jint optval) {\n+    jint rv = setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (char*) &optval, sizeof(optval));\n+    handleError(env, rv, \"set option TCP_KEEPCNT failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    getTcpKeepAliveProbes0\n+ * Signature: (I)I;\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_net_WindowsSocketOptions_getTcpKeepAliveProbes0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof(optval);\n+    rv = getsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, (char*) &optval, &sz);\n+    handleError(env, rv, \"get option TCP_KEEPCNT failed\");\n+    return optval;\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    setTcpKeepAliveTime0\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_WindowsSocketOptions_setTcpKeepAliveTime0\n+(JNIEnv *env, jobject unused, jint fd, jint optval) {\n+    jint rv = setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, (char*) &optval, sizeof(optval));\n+    handleError(env, rv, \"set option TCP_KEEPIDLE failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    getTcpKeepAliveTime0\n+ * Signature: (I)I;\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_net_WindowsSocketOptions_getTcpKeepAliveTime0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof(optval);\n+    rv = getsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, (char*) &optval, &sz);\n+    handleError(env, rv, \"get option TCP_KEEPIDLE failed\");\n+    return optval;\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    setTcpKeepAliveIntvl0\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_WindowsSocketOptions_setTcpKeepAliveIntvl0\n+(JNIEnv *env, jobject unused, jint fd, jint optval) {\n+    jint rv = setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (char*) &optval, sizeof(optval));\n+    handleError(env, rv, \"set option TCP_KEEPINTVL failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    getTcpKeepAliveIntvl0\n+ * Signature: (I)I;\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_net_WindowsSocketOptions_getTcpKeepAliveIntvl0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof(optval);\n+    rv = getsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, (char*) &optval, &sz);\n+    handleError(env, rv, \"get option TCP_KEEPINTVL failed\");\n+    return optval;\n+}\n+\n","filename":"src\/jdk.net\/windows\/native\/libextnet\/WindowsSocketOptions.c","additions":129,"deletions":2,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n+using ::testing::HasSubstr;\n+\n+\/\/ Check the state of the trimmer via print_state; returns the suspend count\n+static int check_trim_state() {\n+  char buf [1024];\n+  stringStream ss(buf, sizeof(buf));\n+  NativeHeapTrimmer::print_state(&ss);\n+  if (NativeHeapTrimmer::enabled()) {\n+    assert(TrimNativeHeapInterval > 0, \"Sanity\");\n+    EXPECT_THAT(buf, HasSubstr(\"Periodic native trim enabled\"));\n+\n+    const char* s = ::strstr(buf, \"Trims performed\");\n+    EXPECT_NOT_NULL(s);\n+\n+    uint64_t num_trims = 0;\n+    int suspend_count = 0;\n+    int stopped = 0;\n+    EXPECT_EQ(::sscanf(s, \"Trims performed: \" UINT64_FORMAT \", current suspend count: %d, stopped: %d\",\n+                       &num_trims, &suspend_count, &stopped), 3);\n+\n+    \/\/ Number of trims we can reasonably expect should be limited\n+    const double fudge_factor = 1.5;\n+    const uint64_t elapsed_ms = (uint64_t)(os::elapsedTime() * fudge_factor * 1000.0);\n+    const uint64_t max_num_trims = (elapsed_ms \/ TrimNativeHeapInterval) + 1;\n+    EXPECT_LE(num_trims, max_num_trims);\n+\n+    \/\/ We should not be stopped\n+    EXPECT_EQ(stopped, 0);\n+\n+    \/\/ Suspend count must not underflow\n+    EXPECT_GE(suspend_count, 0);\n+    return suspend_count;\n+\n+  } else {\n+    EXPECT_THAT(buf, HasSubstr(\"Periodic native trim disabled\"));\n+    EXPECT_THAT(buf, Not(HasSubstr(\"Trims performed\")));\n+    return 0;\n+  }\n+}\n+\n+TEST_VM(os, TrimNative) {\n+\n+  if (!NativeHeapTrimmer::enabled()) {\n+    return;\n+  }\n+\n+  \/\/ Try recursive pausing. This tests that we are able to pause, that pauses stack,\n+  \/\/ and that stacking works within the same thread.\n+  int c1 = 0, c2 = 0, c3 = 0;\n+  {\n+    NativeHeapTrimmer::SuspendMark sm1(\"Test1\");\n+    c1 = check_trim_state();\n+    {\n+      NativeHeapTrimmer::SuspendMark sm2(\"Test2\");\n+      c2 = check_trim_state();\n+      {\n+        NativeHeapTrimmer::SuspendMark sm3(\"Test3\");\n+        c3 = check_trim_state();\n+      }\n+    }\n+  }\n+  \/\/ We also check the state: the suspend count should go up. But since we don't know\n+  \/\/ whether concurrent code will have increased the suspend count too, this is fuzzy and\n+  \/\/ we must avoid intermittent false positives.\n+  EXPECT_GT(c2, c1);\n+  EXPECT_GT(c3, c2);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_trim_native.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -106,0 +106,2 @@\n+runtime\/os\/TestTrimNative.java#trimNative 8312525 linux-all\n+runtime\/os\/TestTrimNative.java#trimNativeLowInterval 8312525 linux-all\n@@ -120,0 +122,1 @@\n+runtime\/cds\/CDSMapTest.java 8314993 generic-all\n@@ -130,1 +133,0 @@\n-serviceability\/jvmti\/vthread\/VThreadTLSTest\/VThreadTLSTest.java#id1 8300051 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8311130\n+ * @summary Test synchronization between SVE arguments and CPU features\n+ *\n+ * @requires os.arch == \"aarch64\" & vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller\n+ *             jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:UseSVE=0\n+ *                   compiler.arguments.TestSyncCPUFeaturesWithSVEFlags\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:UseSVE=1\n+ *                   compiler.arguments.TestSyncCPUFeaturesWithSVEFlags\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:UseSVE=2\n+ *                   compiler.arguments.TestSyncCPUFeaturesWithSVEFlags\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:MaxVectorSize=8\n+ *                   compiler.arguments.TestSyncCPUFeaturesWithSVEFlags\n+ *\/\n+\n+package compiler.arguments;\n+\n+import java.util.List;\n+import java.util.Arrays;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestSyncCPUFeaturesWithSVEFlags {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        int sve_level = WB.getUintVMFlag(\"UseSVE\").intValue();\n+        List<String> features = Arrays.asList(WB.getCPUFeatures().split(\", \"));\n+        boolean has_sve = features.contains(\"sve\");\n+        boolean has_sve2 = features.contains(\"sve2\");\n+        switch (sve_level) {\n+            case 0: {\n+                \/\/ No sve and sve2\n+                Asserts.assertFalse(has_sve);\n+                Asserts.assertFalse(has_sve2);\n+                break;\n+            }\n+            case 1: {\n+                \/\/ Only has sve, no sve2\n+                Asserts.assertTrue(has_sve);\n+                Asserts.assertFalse(has_sve2);\n+                break;\n+            }\n+            case 2: {\n+                \/\/ Has both sve and sve2\n+                Asserts.assertTrue(has_sve);\n+                Asserts.assertTrue(has_sve2);\n+                break;\n+            }\n+            default: {\n+                \/\/ Should not reach here\n+                Asserts.assertTrue(false);\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestSyncCPUFeaturesWithSVEFlags.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -33,2 +33,1 @@\n- *            ((vm.opt.UseSVE == \"null\" | vm.opt.UseSVE > 1) &\n- *             os.arch==\"aarch64\" & vm.cpu.features ~= \".*svebitperm.*\"))\n+ *            (os.arch==\"aarch64\" & vm.cpu.features ~= \".*svebitperm.*\"))\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestBitShuffleOpers.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    @IR(failOn = IRNode.AND_V, applyIfCPUFeature = {\"asimd\", \"true\"}, applyIf = {\"UseSVE\", \"0\"})\n+    @IR(failOn = IRNode.AND_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -188,1 +188,1 @@\n-    @IR(failOn = IRNode.AND_V, applyIfCPUFeature = {\"asimd\", \"true\"}, applyIf = {\"UseSVE\", \"0\"})\n+    @IR(failOn = IRNode.AND_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -305,2 +305,1 @@\n-    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"UseSVE\", \"> 0\"})\n-    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -327,2 +326,1 @@\n-    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"UseSVE\", \"> 0\"})\n-    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -349,2 +347,1 @@\n-    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"UseSVE\", \"> 0\"})\n-    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -415,1 +412,1 @@\n-    @IR(failOn = IRNode.OR_V, applyIfCPUFeature = {\"asimd\", \"true\"}, applyIf = {\"UseSVE\", \"0\"})\n+    @IR(failOn = IRNode.OR_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -474,1 +471,1 @@\n-    @IR(failOn = IRNode.OR_V, applyIfCPUFeature = {\"asimd\", \"true\"}, applyIf = {\"UseSVE\", \"0\"})\n+    @IR(failOn = IRNode.OR_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -572,2 +569,1 @@\n-    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"UseSVE\", \"> 0\"})\n-    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -594,2 +590,1 @@\n-    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"UseSVE\", \"> 0\"})\n-    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -616,2 +611,1 @@\n-    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeature = {\"sve\", \"true\"}, applyIf = {\"UseSVE\", \"> 0\"})\n-    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -656,1 +650,1 @@\n-    @IR(failOn = IRNode.XOR_V, applyIfCPUFeature = {\"asimd\", \"true\"}, applyIf = {\"UseSVE\", \"0\"})\n+    @IR(failOn = IRNode.XOR_V, applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorLogicalOpIdentityTest.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -30,1 +30,1 @@\n-*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\" & (vm.opt.UseSVE == \"null\" | vm.opt.UseSVE > 0))\n+*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestNumberOfContinuousZeros.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\" & (vm.opt.UseSVE == \"null\" | vm.opt.UseSVE > 0))\n+*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopulateIndex.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* @test\n+ * @summary Run a subset of gtests with the native trimmer activated.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=os.trim* -Xlog:trimnative -XX:+UnlockExperimentalVMOptions -XX:TrimNativeHeapInterval=100\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/NativeHeapTrimmerGtest.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @summary java -Xdebug crashes on SourceDebugExtension attribute larger than 64K\n- * @run main\/othervm -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n SourceDebugExtension\n+ * @summary verify that the JVM doesn't crash when SourceDebugExtension attribute is larger than 64K\n+ * @run main\/othervm -Xrunjdwp:transport=dt_socket,server=y,suspend=n SourceDebugExtension\n","filename":"test\/hotspot\/jtreg\/runtime\/6294277\/SourceDebugExtension.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-  public static void testDoubleFlagWithValue(String value) throws Exception {\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:SweeperThreshold=\" + value, \"-version\");\n+  public static void testDoubleFlagWithValue(String flag, String value) throws Exception {\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(flag + \"=\" + value, \"-version\");\n@@ -46,2 +46,2 @@\n-    \/\/ Test double format\n-    testDoubleFlagWithValue(\"10.0\");\n+    \/\/ Test double format for -XX:SweeperThreshold\n+    testDoubleFlagWithValue(\"-XX:SweeperThreshold\", \"10.0\");\n@@ -49,2 +49,8 @@\n-    \/\/ Test integer format\n-    testDoubleFlagWithValue(\"10\");\n+    \/\/ Test integer format -XX:SweeperThreshold\n+    testDoubleFlagWithValue(\"-XX:SweeperThreshold\", \"10\");\n+\n+    \/\/ Test double format for -XX:SafepointTimeoutDelay\n+    testDoubleFlagWithValue(\"-XX:SafepointTimeoutDelay\", \"5.0\");\n+\n+    \/\/ Test integer format -XX:SafepointTimeoutDelay\n+    testDoubleFlagWithValue(\"-XX:SafepointTimeoutDelay\", \"5\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/DoubleFlagWithIntegerValue.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @requires os.family != \"aix\"\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,301 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/\/ This is a simple parser for parsing the output of\n+\/\/\n+\/\/   java -Xshare:dump -Xlog:cds+map=debug,cds+map+oops=trace:file=cds.map:none:filesize=0\n+\/\/\n+\/\/ Currently it just check the output related to JDK-8308903.\n+\/\/ I.e., each oop fields in the HeapObjects must point to a valid HeapObject.\n+\/\/\n+\/\/ It can be extended to check for the other parts of the map file, or perform\n+\/\/ more analysis on the HeapObjects.\n+public class CDSMapReader {\n+    public static class MapFile {\n+        ArrayList<HeapObject> heapObjects = new ArrayList<>();\n+        HashMap<Long, HeapObject> oopToObject = new HashMap<>();\n+        HashMap<Long, HeapObject> narrowOopToObject = new HashMap<>();\n+\n+        void add(HeapObject heapObject) {\n+            heapObjects.add(heapObject);\n+            oopToObject.put(heapObject.address.oop, heapObject);\n+            if (heapObject.address.narrowOop != 0) {\n+                narrowOopToObject.put(heapObject.address.narrowOop, heapObject);\n+            }\n+        }\n+\n+        public int heapObjectCount() {\n+            return heapObjects.size();\n+        }\n+    }\n+\n+    public static class HeapAddress {\n+        long oop;\n+        long narrowOop;\n+\n+        HeapAddress(String oopStr, String narrowOopStr) {\n+            oop = Long.parseUnsignedLong(oopStr, 16);\n+            if (narrowOopStr != null) {\n+                narrowOop = Long.parseUnsignedLong(narrowOopStr, 16);\n+            }\n+        }\n+    }\n+\n+    public static class Klass {\n+        long address;\n+        String name;\n+\n+        static Klass getKlass(String name, String addr) {\n+            \/\/ TODO: look up from a table of known Klasses\n+            Klass k = new Klass();\n+            k.name = name;\n+            k.address =  Long.parseUnsignedLong(addr, 16);\n+            return k;\n+        }\n+    }\n+\n+    public static class HeapObject {\n+        HeapAddress address;\n+        ArrayList<Field> fields;\n+        String className;\n+        Klass klass;\n+\n+        HeapObject(String className, String oop, String narrowOop) {\n+            this.className = className;\n+            address = new HeapAddress(oop, narrowOop);\n+        }\n+\n+        void setKlass(String klassName, String address) {\n+            klass = Klass.getKlass(klassName, address);\n+        }\n+\n+        void addOopField(String name, String offset, String oopStr, String narrowOopStr) {\n+            if (fields == null) {\n+                fields = new ArrayList<Field>();\n+            }\n+            fields.add(new Field(name, offset, oopStr, narrowOopStr));\n+        }\n+    }\n+\n+    public static class Field {\n+        String name;\n+        int offset;\n+        HeapAddress referentAddress; \/\/ non-null iff this is an object field\n+        int lineCount;\n+\n+        Field(String name, String offset, String oopStr, String narrowOopStr) {\n+            this.name = name;\n+            this.offset = Integer.parseInt(offset);\n+            this.referentAddress = new HeapAddress(oopStr, narrowOopStr);\n+            this.lineCount = CDSMapReader.lineCount;\n+        }\n+    }\n+\n+    \/\/ 0x00000007ffc00000:   4a5b8701 00000063 00010290 00000000 00010100 fff80003\n+    static Pattern rawDataPattern = Pattern.compile(\"^0x([0-9a-f]+): *( [0-9a-f]+)+ *$\");\n+\n+    \/\/ (one address)\n+    \/\/ 0x00000007ffc00000: @@ Object java.lang.String\n+    static Pattern objPattern1 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object (.*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/ 0x00000007ffc00000: @@ Object (0xfff80000) java.lang.String\n+    static Pattern objPattern2 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object [(]0x([0-9a-f]+)[)] (.*)\");\n+\n+    \/\/  - klass: 'java\/lang\/String' 0x0000000800010290\n+    static Pattern instanceObjKlassPattern = Pattern.compile(\"^ - klass: '([^']+)' 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: {type array byte} 0x00000008000024c8\n+    static Pattern typeArrayKlassPattern = Pattern.compile(\"^ - klass: [{]type array ([a-z]+)[}] 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: 'java\/lang\/Object'[] 0x00000008000013e0\n+    static Pattern objArrayKlassPattern = Pattern.compile(\"^ - klass: ('[^']+'(\\\\[\\\\])+) 0x([0-9a-f]+)\");\n+\n+    \/\/  - fields (3 words):\n+    static Pattern fieldsWordsPattern = Pattern.compile(\"^ - fields [(]([0-9]+) words[)]:$\");\n+\n+    \/\/ (one address)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 java.lang.String\n+    static Pattern oopFieldPattern1 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) (.*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 (0xfff8d04c) java.lang.String\n+    static Pattern oopFieldPattern2 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) [(]0x([0-9a-f]+)[)] (.*)\");\n+\n+    private static Matcher match(String line, Pattern pattern) {\n+        Matcher m = pattern.matcher(line);\n+        if (m.find()) {\n+            return m;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void parseHeapObject(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = parseHeapObjectImpl(className, oop, narrowOop);\n+        mapFile.add(heapObject);\n+    }\n+\n+    private static HeapObject parseHeapObjectImpl(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = new HeapObject(className, oop, narrowOop);\n+        Matcher m;\n+\n+        nextLine();\n+        while (line != null && match(line, rawDataPattern) != null) { \/\/ skip raw data\n+            nextLine();\n+        }\n+\n+        if (line == null || !line.startsWith(\" - \")) {\n+            return heapObject;\n+        }\n+\n+        if ((m = match(line, instanceObjKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            nextLine();\n+            if ((m = match(line, fieldsWordsPattern)) == null) {\n+                throw new RuntimeException(\"Expected field size info\");\n+            }\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+                if (!line.contains(\"marked metadata pointer\")) {\n+                    if ((m = match(line, oopFieldPattern2)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), m.group(4));\n+                    } else if ((m = match(line, oopFieldPattern1)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), null);\n+                    }\n+                }\n+            }\n+        } else if ((m = match(line, typeArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else if ((m = match(line, objArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(3));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else {\n+            throw new RuntimeException(\"Expected klass info\");\n+        }\n+    }\n+\n+    static MapFile mapFile;\n+    static BufferedReader reader;\n+    static String line = null; \/\/ current line being parsed\n+    static int lineCount = 0;\n+    static String nextLine()  throws IOException {\n+        line = reader.readLine();\n+        ++ lineCount;\n+        return line;\n+    }\n+\n+    public static MapFile read(String fileName) {\n+        mapFile = new MapFile();\n+\n+        try (BufferedReader r = new BufferedReader(new FileReader(fileName))) {\n+            reader = r;\n+            nextLine();\n+\n+            Matcher m;\n+            while (line != null) {\n+                if ((m = match(line, objPattern2)) != null) {\n+                    parseHeapObject(m.group(3), m.group(1), m.group(2));\n+                } else if ((m = match(line, objPattern1)) != null) {\n+                    parseHeapObject(m.group(2), m.group(1), null);\n+                } else {\n+                    nextLine();\n+                }\n+            }\n+            return mapFile;\n+        } catch (Throwable t) {\n+            System.out.println(\"Error parsing line \" + lineCount + \": \" + line);\n+            throw new RuntimeException(t);\n+        } finally {\n+            System.out.println(\"Parsed \" + lineCount + \" lines in \" + fileName);\n+            System.out.println(\"Found \"  + mapFile.heapObjectCount() + \" heap objects\");\n+            mapFile = null;\n+            reader = null;\n+            line = null;\n+            lineCount = 0;\n+        }\n+    }\n+\n+    private static void mustContain(HashMap<Long, HeapObject> allObjects, Field field, long pointer, boolean isNarrow) {\n+        if (allObjects.get(pointer) == null) {\n+            throw new RuntimeException((isNarrow ? \"narrowOop\" : \"oop\") + \" pointer 0x\" + Long.toHexString(pointer) +\n+                                       \" on line \" + field.lineCount + \" doesn't point to a valid heap object\");\n+        }\n+    }\n+\n+    \/\/ Check that each oop fields in the HeapObjects must point to a valid HeapObject.\n+    public static int validate(MapFile mapFile) {\n+        int count = 0;\n+        for (HeapObject heapObject : mapFile.heapObjects) {\n+            if (heapObject.fields != null) {\n+                for (Field field : heapObject.fields) {\n+                    HeapAddress referentAddress = field.referentAddress;\n+                    long oop = referentAddress.oop;\n+                    long narrowOop = referentAddress.narrowOop;\n+                    \/\/ Is this test actually doing something?\n+                    \/\/     To see how an invalidate pointer may be found, change oop in the\n+                    \/\/     following line to oop+1\n+                    mustContain(mapFile.oopToObject, field, oop, false);\n+                    count ++;\n+                    if (narrowOop != 0) {\n+                        mustContain(mapFile.narrowOopToObject, field, narrowOop, true);\n+                        count ++;\n+                    }\n+                }\n+            }\n+        }\n+        System.out.println(\"Checked \" + count + \" oop field references\");\n+        return count;\n+    }\n+\n+    public static void main(String args[]) {\n+        MapFile mapFile = read(args[0]);\n+        validate(mapFile);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapReader.java","additions":301,"deletions":0,"binary":false,"changes":301,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8308903\n+ * @summary Test the contents of -Xlog:cds+map\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver CDSMapTest\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.Platform;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+public class CDSMapTest {\n+    public static void main(String[] args) throws Exception {\n+        doTest(false);\n+\n+        if (Platform.is64bit()) {\n+            \/\/ There's no oop\/klass compression on 32-bit.\n+            doTest(true);\n+        }\n+    }\n+\n+    public static void doTest(boolean compressed) throws Exception {\n+        ArrayList<String> dumpArgs = new ArrayList<>();\n+\n+        \/\/ Use the same heap size as make\/Images.gmk\n+        dumpArgs.add(\"-Xmx128M\");\n+\n+        if (Platform.is64bit()) {\n+            \/\/ These options are available only on 64-bit.\n+            String sign = (compressed) ?  \"+\" : \"-\";\n+            dumpArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n+        }\n+\n+        dump(dumpArgs);\n+    }\n+\n+    static int id = 0;\n+    static void dump(ArrayList<String> args, String... more) throws Exception {\n+        String logName = \"SharedArchiveFile\" + (id++);\n+        String archiveName = logName + \".jsa\";\n+        String mapName = logName + \".map\";\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-Xlog:cds=debug\")\n+            .addPrefix(\"-Xlog:cds+map=debug,cds+map+oops=trace:file=\" + mapName + \":none:filesize=0\")\n+            .setArchiveName(archiveName)\n+            .addSuffix(args)\n+            .addSuffix(more);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n+        int oopFieldCount = CDSMapReader.validate(mapFile);\n+        if (mapFile.heapObjectCount() > 0 && oopFieldCount < 10000) {\n+            \/\/ heapObjectCount() may be zero if the selected GC doesn't support heap object archiving.\n+            throw new RuntimeException(\"CDS map file seems incorrect: \" + mapFile.heapObjectCount() +\n+                                       \" objects but only \" + oopFieldCount + \" oop field references\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -83,1 +83,1 @@\n-            .addPrefix(\"-Xlog:cds+map=trace:file=\" + mapName + \":none:filesize=0\")\n+            .addPrefix(\"-Xlog:cds+map*=trace:file=\" + mapName + \":none:filesize=0\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test to verify throwing an exception with extra long message does\n+ *          not cause hang.\n+ * @bug 8312401\n+ * @run main\/othervm LongExceptionMessageTest\n+ *\/\n+\n+class ClassWithLongExceptionMessage {\n+  static {\n+    if (true) throw new AssertionError(\"lorem ipsum \".repeat(16000));\n+  }\n+}\n+\n+public class LongExceptionMessageTest {\n+  public static void main(String[] args) {\n+    try {\n+      new ClassWithLongExceptionMessage();\n+    } catch(Throwable t) {}\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/LongExceptionMessageTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=ENABLED\n+ * @bug 8303215 8312182\n+ * @summary On THP=always systems, we prevent THPs from forming within thread stacks\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @requires vm.debug\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver THPsInThreadStackPreventionTest PATCH-ENABLED\n+ *\/\n+\n+\/*\n+ * @test id=DISABLED\n+ * @bug 8303215 8312182\n+ * @summary On THP=always systems, we prevent THPs from forming within thread stacks (negative test)\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @requires vm.debug\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/manual THPsInThreadStackPreventionTest  PATCH-DISABLED\n+ *\/\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+\n+public class THPsInThreadStackPreventionTest {\n+\n+    \/\/ We test the mitigation for \"huge rss for THP=always\" introduced with JDK-8312182 and JDK-8302015:\n+    \/\/\n+    \/\/ We start a program that spawns a ton of threads with a stack size close to THP page size. The threads\n+    \/\/ are idle and should not build up a lot of stack. The threads are started with an artificial delay\n+    \/\/ between thread start and stack guardpage creation, which exacerbates the RSS bloat (for explanation\n+    \/\/ please see 8312182).\n+    \/\/\n+    \/\/ We then observe RSS of that program. We expect it to stay below a reasonable maximum. The unpatched\n+    \/\/ version should show an RSS of ~2 GB (paying for the fully paged in thread stacks). The fixed variant should\n+    \/\/ cost only ~200-400 MB.\n+\n+    static final int numThreads = 1000;\n+    static final long threadStackSizeMB = 2; \/\/ must be 2M\n+    static final long heapSizeMB = 64;\n+    static final long basicRSSOverheadMB = heapSizeMB + 150;\n+    \/\/ A successful completion of this test would show not more than X KB per thread stack.\n+    static final long acceptableRSSPerThreadStack = 128 * 1024;\n+    static final long acceptableRSSForAllThreadStacks = numThreads * acceptableRSSPerThreadStack;\n+    static final long acceptableRSSLimitMB = (acceptableRSSForAllThreadStacks \/ (1024 * 1024)) + basicRSSOverheadMB;\n+\n+    private static class TestMain {\n+\n+        static class Sleeper extends Thread {\n+            CyclicBarrier barrier;\n+            public Sleeper(CyclicBarrier barrier) {\n+                this.barrier = barrier;\n+            }\n+            @Override\n+            public void run() {\n+                try {\n+                    barrier.await(); \/\/ wait for all siblings\n+                    barrier.await(); \/\/ wait main thread to print status\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+\n+        public static void main(String[] args) throws BrokenBarrierException, InterruptedException {\n+\n+            \/\/ Fire up 1000 threads with 2M stack size each.\n+            Sleeper[] threads = new Sleeper[numThreads];\n+            CyclicBarrier barrier = new CyclicBarrier(numThreads + 1);\n+\n+            for (int i = 0; i < numThreads; i++) {\n+                threads[i] = new Sleeper(barrier);\n+                threads[i].start();\n+            }\n+\n+            \/\/ Wait for all threads to come up\n+            barrier.await();\n+\n+            \/\/ print status\n+            String file = \"\/proc\/self\/status\";\n+            try (FileReader fr = new FileReader(file);\n+                 BufferedReader reader = new BufferedReader(fr)) {\n+                String line;\n+                while ((line = reader.readLine()) != null) {\n+                    System.out.println(line);\n+                }\n+            } catch (IOException | NumberFormatException e) { \/* ignored *\/ }\n+\n+            \/\/ Signal threads to stop\n+            barrier.await();\n+\n+        }\n+    }\n+\n+    static class ProcSelfStatus {\n+\n+        public long rssMB;\n+        public long swapMB;\n+        public int numLifeThreads;\n+\n+        \/\/ Parse output from \/proc\/self\/status\n+        public static ProcSelfStatus parse(OutputAnalyzer o) {\n+            ProcSelfStatus status = new ProcSelfStatus();\n+            String s = o.firstMatch(\"Threads:\\\\s*(\\\\d+)\", 1);\n+            Objects.requireNonNull(s);\n+            status.numLifeThreads = Integer.parseInt(s);\n+            s = o.firstMatch(\"VmRSS:\\\\s*(\\\\d+) kB\", 1);\n+            Objects.requireNonNull(s);\n+            status.rssMB = Long.parseLong(s) \/ 1024;\n+            s = o.firstMatch(\"VmSwap:\\\\s*(\\\\d+) kB\", 1);\n+            Objects.requireNonNull(s);\n+            status.swapMB = Long.parseLong(s) \/ 1024;\n+            return status;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        HugePageConfiguration config = HugePageConfiguration.readFromOS();\n+        \/\/ This issue is bound to THP=always\n+        if (config.getThpMode() != HugePageConfiguration.THPMode.always) {\n+            throw new SkippedException(\"Test only makes sense in THP \\\"always\\\" mode\");\n+        }\n+\n+        String[] defaultArgs = {\n+            \"-Xlog:pagesize\",\n+            \"-Xmx\" + heapSizeMB + \"m\", \"-Xms\" + heapSizeMB + \"m\", \"-XX:+AlwaysPreTouch\", \/\/ stabilize RSS\n+            \"-Xss\" + threadStackSizeMB + \"m\",\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \/\/ This will delay the child threads before they create guard pages, thereby greatly increasing the\n+            \/\/ chance of large VMA formation + hugepage coalescation; see JDK-8312182\n+            \"-XX:+DelayThreadStartALot\"\n+        };\n+        ArrayList<String> finalargs = new ArrayList<>(Arrays.asList(defaultArgs));\n+\n+        switch (args[0]) {\n+            case \"PATCH-ENABLED\": {\n+                finalargs.add(TestMain.class.getName());\n+                ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs);\n+\n+                OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+                output.shouldHaveExitValue(0);\n+\n+                \/\/ this line indicates the mitigation is active:\n+                output.shouldContain(\"[pagesize] JVM will attempt to prevent THPs in thread stacks.\");\n+\n+                ProcSelfStatus status = ProcSelfStatus.parse(output);\n+                if (status.numLifeThreads < numThreads) {\n+                    throw new RuntimeException(\"Number of live threads lower than expected: \" + status.numLifeThreads + \", expected \" + numThreads);\n+                } else {\n+                    System.out.println(\"Found \" + status.numLifeThreads + \" to be alive. Ok.\");\n+                }\n+\n+                long rssPlusSwapMB = status.swapMB + status.rssMB;\n+\n+                if (rssPlusSwapMB > acceptableRSSLimitMB) {\n+                    throw new RuntimeException(\"RSS+Swap larger than expected: \" + rssPlusSwapMB + \"m, expected at most \" + acceptableRSSLimitMB + \"m\");\n+                } else {\n+                    if (rssPlusSwapMB < heapSizeMB) { \/\/ we pretouch the java heap, so we expect to see at least that:\n+                        throw new RuntimeException(\"RSS+Swap suspiciously low: \" + rssPlusSwapMB + \"m, expected at least \" + heapSizeMB + \"m\");\n+                    }\n+                    System.out.println(\"Okay: RSS+Swap=\" + rssPlusSwapMB + \", within acceptable limit of \" + acceptableRSSLimitMB);\n+                }\n+            }\n+            break;\n+\n+            case \"PATCH-DISABLED\": {\n+\n+                \/\/ Only execute manually! this will allocate ~2gb of memory!\n+\n+                \/\/ explicitly disable the no-THP-workaround:\n+                finalargs.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+                finalargs.add(\"-XX:+DisableTHPStackMitigation\");\n+\n+                finalargs.add(TestMain.class.getName());\n+                ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs);\n+                OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+                output.shouldHaveExitValue(0);\n+\n+                \/\/ We deliberately switched off mitigation, VM should tell us:\n+                output.shouldContain(\"[pagesize] JVM will *not* prevent THPs in thread stacks. This may cause high RSS.\");\n+\n+                \/\/ Parse output from self\/status\n+                ProcSelfStatus status = ProcSelfStatus.parse(output);\n+                if (status.numLifeThreads < numThreads) {\n+                    throw new RuntimeException(\"Number of live threads lower than expected (\" + status.numLifeThreads + \", expected \" + numThreads +\")\");\n+                } else {\n+                    System.out.println(\"Found \" + status.numLifeThreads + \" to be alive. Ok.\");\n+                }\n+\n+                long rssPlusSwapMB = status.swapMB + status.rssMB;\n+\n+                if (rssPlusSwapMB < acceptableRSSLimitMB) {\n+                    throw new RuntimeException(\"RSS+Swap lower than expected: \" + rssPlusSwapMB + \"m, expected more than \" + acceptableRSSLimitMB + \"m\");\n+                }\n+                break;\n+            }\n+\n+            default: throw new RuntimeException(\"Bad argument: \" + args[0]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/THPsInThreadStackPreventionTest.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=trimNative\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative trimNative\n+ *\/\n+\n+\/*\n+ * @test id=trimNativeHighInterval\n+ * @summary High interval trimming should not even kick in for short program runtimes\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative trimNativeHighInterval\n+ *\/\n+\n+\/*\n+ * @test id=trimNativeLowInterval\n+ * @summary Very low (sub-second) interval, nothing should explode\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative trimNativeLowInterval\n+ *\/\n+\n+\/*\n+ * @test id=testOffByDefault\n+ * @summary Test that trimming is disabled by default\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative testOffByDefault\n+ *\/\n+\n+\/*\n+ * @test id=testOffExplicit\n+ * @summary Test that trimming can be disabled explicitly\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative testOffExplicit\n+ *\/\n+\n+\/*\n+ * @test id=testOffOnNonCompliantPlatforms\n+ * @summary Test that trimming is correctly reported as unavailable if unavailable\n+ * @requires (os.family!=\"linux\") | vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative testOffOnNonCompliantPlatforms\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestTrimNative {\n+\n+    \/\/ Actual RSS increase is a lot larger than 4 MB. Depends on glibc overhead, and NMT malloc headers in debug VMs.\n+    \/\/ We need small-grained allocations to make sure they actually increase RSS (all touched) and to see the\n+    \/\/ glibc-retaining-memory effect.\n+    static final int szAllocations = 128;\n+    static final int totalAllocationsSize = 128 * 1024 * 1024; \/\/ 128 MB total\n+    static final int numAllocations = totalAllocationsSize \/ szAllocations;\n+\n+    static long[] ptrs = new long[numAllocations];\n+\n+    enum Unit {\n+        B(1), K(1024), M(1024*1024), G(1024*1024*1024);\n+        public final long size;\n+        Unit(long size) { this.size = size; }\n+    }\n+\n+    private static String[] prepareOptions(String[] extraVMOptions, String[] programOptions) {\n+        List<String> allOptions = new ArrayList<String>();\n+        if (extraVMOptions != null) {\n+            allOptions.addAll(Arrays.asList(extraVMOptions));\n+        }\n+        allOptions.add(\"-Xmx128m\");\n+        allOptions.add(\"-Xms128m\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+AlwaysPreTouch\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+UnlockDiagnosticVMOptions\"); \/\/ For whitebox\n+        allOptions.add(\"-XX:+WhiteBoxAPI\");\n+        allOptions.add(\"-Xbootclasspath\/a:.\");\n+        allOptions.add(\"-XX:-ExplicitGCInvokesConcurrent\"); \/\/ Invoke explicit GC on System.gc\n+        allOptions.add(\"-Xlog:trimnative=debug\");\n+        allOptions.add(\"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        if (programOptions != null) {\n+            allOptions.addAll(Arrays.asList(programOptions));\n+        }\n+        return allOptions.toArray(new String[0]);\n+    }\n+\n+    private static OutputAnalyzer runTestWithOptions(String[] extraOptions, String[] programOptions) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(prepareOptions(extraOptions, programOptions));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n+    }\n+\n+    private static void checkExpectedLogMessages(OutputAnalyzer output, boolean expectEnabled,\n+                                                 int expectedInterval) {\n+        if (expectEnabled) {\n+            output.shouldContain(\"Periodic native trim enabled (interval: \" + expectedInterval + \" ms\");\n+            output.shouldContain(\"Native heap trimmer start\");\n+            output.shouldContain(\"Native heap trimmer stop\");\n+        } else {\n+            output.shouldNotContain(\"Periodic native trim enabled\");\n+        }\n+    }\n+\n+    \/**\n+     * Given JVM output, look for one or more log lines that describes a successful negative trim. The total amount\n+     * of trims should be matching about what the test program allocated.\n+     * @param output\n+     * @param minTrimsExpected min number of periodic trim lines expected in UL log\n+     * @param maxTrimsExpected min number of periodic trim lines expected in UL log\n+     *\/\n+    private static void parseOutputAndLookForNegativeTrim(OutputAnalyzer output, int minTrimsExpected,\n+                                                          int maxTrimsExpected) {\n+        output.reportDiagnosticSummary();\n+        List<String> lines = output.asLines();\n+        Pattern pat = Pattern.compile(\".*\\\\[trimnative\\\\] Periodic Trim \\\\(\\\\d+\\\\): (\\\\d+)([BKMG])->(\\\\d+)([BKMG]).*\");\n+        int numTrimsFound = 0;\n+        long rssReductionTotal = 0;\n+        for (String line : lines) {\n+            Matcher mat = pat.matcher(line);\n+            if (mat.matches()) {\n+                long rss1 = Long.parseLong(mat.group(1)) * Unit.valueOf(mat.group(2)).size;\n+                long rss2 = Long.parseLong(mat.group(3)) * Unit.valueOf(mat.group(4)).size;\n+                if (rss1 > rss2) {\n+                    rssReductionTotal += (rss1 - rss2);\n+                }\n+                numTrimsFound ++;\n+            }\n+            if (numTrimsFound > maxTrimsExpected) {\n+                throw new RuntimeException(\"Abnormal high number of periodic trim attempts found (more than \" + maxTrimsExpected +\n+                        \"). Does the interval setting not work?\");\n+            }\n+        }\n+        if (numTrimsFound < minTrimsExpected) {\n+            throw new RuntimeException(\"We found fewer (periodic) trim lines in UL log than expected (expected at least \" + minTrimsExpected +\n+                    \", found \" + numTrimsFound + \").\");\n+        }\n+        if (maxTrimsExpected > 0) {\n+            \/\/ This is very fuzzy. Test program malloced X bytes, then freed them again and trimmed. But the log line prints change in RSS.\n+            \/\/ Which, of course, is influenced by a lot of other factors. But we expect to see *some* reasonable reduction in RSS\n+            \/\/ due to trimming.\n+            float fudge = 0.5f;\n+            \/\/ On ppc, we see a vastly diminished return (~3M reduction instead of ~200), I suspect because of the underlying\n+            \/\/ 64k pages lead to a different geometry. Manual tests with larger reclaim sizes show that autotrim works. For\n+            \/\/ this test, we just reduce the fudge factor.\n+            if (Platform.isPPC()) { \/\/ le and be both\n+                fudge = 0.01f;\n+            }\n+            long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n+            if (rssReductionTotal < expectedMinimalReduction) {\n+                throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n+                        \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+            }\n+        }\n+    }\n+\n+    static class Tester {\n+        public static void main(String[] args) throws Exception {\n+            long sleeptime = Long.parseLong(args[0]);\n+\n+            System.out.println(\"Will spike now...\");\n+            WhiteBox wb = WhiteBox.getWhiteBox();\n+            for (int i = 0; i < numAllocations; i++) {\n+                ptrs[i] = wb.NMTMalloc(szAllocations);\n+                wb.preTouchMemory(ptrs[i], szAllocations);\n+            }\n+            for (int i = 0; i < numAllocations; i++) {\n+                wb.NMTFree(ptrs[i]);\n+            }\n+            System.out.println(\"Done spiking.\");\n+\n+            System.out.println(\"GC...\");\n+            System.gc();\n+\n+            \/\/ give GC time to react\n+            System.out.println(\"Sleeping...\");\n+            Thread.sleep(sleeptime);\n+            System.out.println(\"Done.\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        switch (args[0]) {\n+            case \"trimNative\": {\n+                long trimInterval = 500; \/\/ twice per second\n+                long ms1 = System.currentTimeMillis();\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=\" + trimInterval },\n+                        new String[] { TestTrimNative.Tester.class.getName(), \"5000\" }\n+                );\n+                long ms2 = System.currentTimeMillis();\n+                long runtime_ms = ms2 - ms1;\n+\n+                checkExpectedLogMessages(output, true, 500);\n+\n+                long maxTrimsExpected = runtime_ms \/ trimInterval;\n+                long minTrimsExpected = maxTrimsExpected \/ 2;\n+                parseOutputAndLookForNegativeTrim(output, (int) minTrimsExpected, (int) maxTrimsExpected);\n+            } break;\n+\n+            case \"trimNativeHighInterval\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=\" + Integer.MAX_VALUE },\n+                        new String[] { TestTrimNative.Tester.class.getName(), \"5000\" }\n+                );\n+                checkExpectedLogMessages(output, true, Integer.MAX_VALUE);\n+                \/\/ We should not see any trims since the interval would prevent them\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+            } break;\n+\n+            case \"trimNativeLowInterval\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=1\" },\n+                        new String[] { TestTrimNative.Tester.class.getName(), \"0\" }\n+                );\n+                checkExpectedLogMessages(output, true, 1);\n+                parseOutputAndLookForNegativeTrim(output, 1, 3000);\n+            } break;\n+\n+            case \"testOffOnNonCompliantPlatforms\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=1\" },\n+                        new String[] { \"-version\" }\n+                );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+                \/\/ The following output is expected to be printed with warning level, so it should not need -Xlog\n+                output.shouldContain(\"[warning][trimnative] Native heap trim is not supported on this platform\");\n+            } break;\n+\n+            case \"testOffExplicit\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=0\" },\n+                        new String[] { \"-version\" }\n+                );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+            } break;\n+\n+            case \"testOffByDefault\": {\n+                OutputAnalyzer output = runTestWithOptions(null, new String[] { \"-version\" } );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+            } break;\n+\n+            default:\n+                throw new RuntimeException(\"Invalid test \" + args[0]);\n+\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTrimNative.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,0 @@\n-                \"-Xdebug\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/ShMemLongName.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.Platform;\n@@ -34,1 +35,1 @@\n- * @requires (os.family==\"linux\") & !vm.musl\n+ * @requires os.family == \"linux\"\n@@ -45,1 +46,5 @@\n-        output.shouldMatch(\".*Trim native heap: RSS\\\\+Swap: \\\\d+[BKM]->\\\\d+[BKM].*\");\n+        if (Platform.isMusl()) {\n+            output.shouldContain(\"Not available\");\n+        } else {\n+            output.shouldMatch(\"Trim native heap: RSS\\\\+Swap: \\\\d+[BKMG]->\\\\d+[BKMG] \\\\([+-]\\\\d+[BKMG]\\\\)\");\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-                + \" -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=0\"\n+                + \" -Xrunjdwp:transport=dt_socket,server=y,address=0\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-            \" -Xdebug -Xrunjdwp:transport=dt_shmem,server=y,address=\" +\n+            \" -Xrunjdwp:transport=dt_shmem,server=y,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,0 @@\n-                \"-Xdebug\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach004\/TestDriver.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-                + \" -Xdebug -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0\"\n+                + \" -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attachnosuspend\/attachnosuspend001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-                \" -Xdebug -Xrunjdwp:suspend=y,transport=\" +\n+                \" -Xrunjdwp:suspend=y,transport=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/LaunchingConnector\/launch\/launch003.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-                \" -Xdebug -Xrunjdwp:suspend=y,transport=\" +\n+                \" -Xrunjdwp:suspend=y,transport=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/LaunchingConnector\/launch\/launch004.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            \" -Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=\" +\n+            \" -Xrunjdwp:transport=dt_socket,server=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/accept\/accept001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-            \" -Xdebug -Xrunjdwp:transport=dt_shmem,server=n,address=\" +\n+            \" -Xrunjdwp:transport=dt_shmem,server=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/accept\/accept002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            \" -Xdebug -Xrunjdwp:transport=dt_socket,server=n,suspend=n,address=\" +\n+            \" -Xrunjdwp:transport=dt_socket,server=n,suspend=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/listennosuspend\/listennosuspend001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-            \" -Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=\" +\n+            \" -Xrunjdwp:transport=dt_socket,server=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/startListening\/startlis001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-            \" -Xdebug -Xrunjdwp:transport=dt_shmem,server=n,address=\" +\n+            \" -Xrunjdwp:transport=dt_shmem,server=n,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ListeningConnector\/startListening\/startlis002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,1 @@\n-        String commandToRun = targetJava + \" -Xdebug -Xrunjdwp:transport=dt_socket,address=\" +\n+        String commandToRun = targetJava + \" -Xrunjdwp:transport=dt_socket,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,1 @@\n-        String commandToRun = targetJava + \" -Xdebug -Xrunjdwp:transport=dt_socket,address=\" +\n+        String commandToRun = targetJava + \" -Xrunjdwp:transport=dt_socket,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM003.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-        String commandToRun = targetJava + \" -Xdebug -Xrunjdwp:transport=dt_socket,address=\" +\n+        String commandToRun = targetJava + \" -Xrunjdwp:transport=dt_socket,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,1 +138,1 @@\n-        String commandToRun = targetJava + \" -Xdebug -Xrunjdwp:transport=dt_socket,address=\" +\n+        String commandToRun = targetJava + \" -Xrunjdwp:transport=dt_socket,address=\" +\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachineManager\/createVirtualMachine\/createVM005.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -331,2 +331,0 @@\n-        args.add(\"-Xdebug\");\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeBinder.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+\n+# Valhalla\n+java\/lang\/Thread\/virtual\/stress\/PingPong.java 8314996 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 7099223,8274106 macosx-aarch64,linux-all,windows-all\n+java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 7099223,8274106 macosx-all,linux-all,windows-all\n@@ -481,0 +481,2 @@\n+java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java              8312482 linux-all\n+java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java 8312482 linux-all\n@@ -740,2 +742,0 @@\n-javax\/rmi\/ssl\/SSLSocketParametersTest.sh                        8162906 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,1 @@\n-        String cmd = exe + \" -Xdebug -Xrunjdwp:transport=dt_socket,timeout=15000,address=\" +\n+        String cmd = exe + \" -Xrunjdwp:transport=dt_socket,timeout=15000,address=\" +\n","filename":"test\/jdk\/com\/sun\/jdi\/connect\/spi\/SimpleLaunchingConnector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * @test\n- * @bug     6173675 8231209 8304074\n+ * @test    id=G1\n+ * @bug     6173675 8231209 8304074 8313081\n@@ -28,1 +28,10 @@\n- * @author  Paul Hohensee\n+ * @requires vm.gc.G1\n+ * @run main\/othervm -XX:+UseG1GC ThreadAllocatedMemory\n+ *\/\n+\n+\/*\n+ * @test    id=Serial\n+ * @bug     6173675 8231209 8304074 8313081\n+ * @summary Basic test of ThreadMXBean.getThreadAllocatedBytes\n+ * @requires vm.gc.Serial\n+ * @run main\/othervm -XX:+UseSerialGC ThreadAllocatedMemory\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemory.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-                \/\/+ \"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 \"\n+                \/\/+ \"-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 \"\n","filename":"test\/jdk\/java\/awt\/Clipboard\/HTMLTransferTest\/HTMLTransferTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-                \/\/ ProcessCommunicator.executeChildProcess(this.getClass(),\" -cp \\\"C:\\\\Documents and Settings\\\\df153228\\\\IdeaProjects\\\\UnicodeTestDebug\\\\out\\\\production\\\\UnicodeTestDebug\\\" -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005 \", args);\n+                \/\/ ProcessCommunicator.executeChildProcess(this.getClass(),\" -cp \\\"C:\\\\Documents and Settings\\\\df153228\\\\IdeaProjects\\\\UnicodeTestDebug\\\\out\\\\production\\\\UnicodeTestDebug\\\" -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005 \", args);\n","filename":"test\/jdk\/java\/awt\/datatransfer\/DragUnicodeBetweenJVMTest\/DragUnicodeBetweenJVMTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -263,4 +263,7 @@\n-        StructLayout padding = MemoryLayout.structLayout(JAVA_INT).withName(\"struct\");\n-        assertEquals(padding.toString(), \"[i4](struct)\");\n-        var toStringUnaligned = padding.withByteAlignment(8).toString();\n-        assertEquals(toStringUnaligned, \"8%[i4](struct)\");\n+        for (ByteOrder order : List.of(ByteOrder.LITTLE_ENDIAN, ByteOrder.BIG_ENDIAN)) {\n+            String intRepresentation = (order == ByteOrder.LITTLE_ENDIAN ? \"i\" : \"I\");\n+            StructLayout padding = MemoryLayout.structLayout(JAVA_INT.withOrder(order)).withName(\"struct\");\n+            assertEquals(padding.toString(), \"[\" + intRepresentation + \"4](struct)\");\n+            var toStringUnaligned = padding.withByteAlignment(8).toString();\n+            assertEquals(toStringUnaligned, \"8%[\" + intRepresentation + \"4](struct)\");\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm ModuleSelectionTest java.base\n+ * @run main\/othervm ModuleSelectionTest jdk.internal.le\n","filename":"test\/jdk\/java\/io\/Console\/ModuleSelectionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8136895\n+ * @summary Verify stream closed after write error in StreamEncoder::implClose\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+import java.nio.charset.MalformedInputException;\n+import java.nio.charset.StandardCharsets;\n+\n+public class CloseWriterOnFailedFlush {\n+    private static final String STR_IOE = \"Test\";   \/\/ IOException\n+    private static final String STR_MIE = \"\\ud83c\"; \/\/ MalformedInputException\n+\n+    public static void main(String[] args) throws IOException {\n+        boolean failed = false;\n+\n+        for (String s : new String[] {STR_IOE, STR_MIE}) {\n+            System.out.println(\"string: \" + s);\n+            ErroringOutputStream stream = new ErroringOutputStream();\n+            try (Writer writer = new OutputStreamWriter(stream,\n+                     StandardCharsets.UTF_8.newEncoder())) {\n+                writer.write(s);\n+            } catch (IOException ex) {\n+                Class exClass = ex.getClass();\n+                if (s.equals(STR_IOE) && exClass != IOException.class ||\n+                    s.equals(STR_MIE) && exClass != MalformedInputException.class)\n+                    throw ex;\n+            }\n+\n+            if (stream.isOpen()) {\n+                System.err.println(\"Stream is STILL open\");\n+                failed = true;\n+            } else {\n+                System.out.println(\"Stream is closed\");\n+            }\n+        }\n+\n+        if (failed)\n+            throw new RuntimeException(\"Test failed\");\n+    }\n+\n+    private static class ErroringOutputStream extends OutputStream {\n+        private boolean open = true;\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            throw new IOException();\n+        }\n+\n+        public boolean isOpen() {\n+            return open;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            open = false;\n+            System.out.println(\"Closing\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/OutputStreamWriter\/CloseWriterOnFailedFlush.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,378 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.IntSupplier;\n+import java.util.function.ToLongFunction;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandleProxies.*;\n+import static java.lang.invoke.MethodType.genericMethodType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.classfile.Classfile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 6983726 8206955 8269351\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ * @summary Basic sanity tests for MethodHandleProxies\n+ * @build BasicTest Client\n+ * @run junit BasicTest\n+ *\/\n+public class BasicTest {\n+\n+    @Test\n+    public void testUsual() throws Throwable {\n+        AtomicInteger ai = new AtomicInteger(5);\n+        var mh = MethodHandles.lookup().findVirtual(AtomicInteger.class, \"getAndIncrement\", methodType(int.class));\n+        IntSupplier is = asInterfaceInstance(IntSupplier.class, mh.bindTo(ai));\n+        assertEquals(5, is.getAsInt());\n+        assertEquals(6, is.getAsInt());\n+        assertEquals(7, is.getAsInt());\n+    }\n+\n+    \/**\n+     * Established null behaviors of MHP API.\n+     *\/\n+    @Test\n+    public void testNulls() {\n+        assertThrows(NullPointerException.class, () ->\n+                        asInterfaceInstance(null, MethodHandles.zero(void.class)),\n+                \"asInterfaceInstance - intfc\");\n+        assertThrows(NullPointerException.class, () ->\n+                        asInterfaceInstance(Runnable.class, null),\n+                \"asInterfaceInstance - target\");\n+\n+        assertFalse(isWrapperInstance(null), \"isWrapperInstance\");\n+\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(null),\n+                \"wrapperInstanceTarget\");\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(null),\n+                \"wrapperInstanceType\");\n+    }\n+\n+    @Test\n+    public void testWrapperInstance() throws Throwable {\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertTrue(isWrapperInstance(proxy));\n+        assertSame(mh, wrapperInstanceTarget(proxy));\n+        assertSame(Comparator.class, wrapperInstanceType(proxy));\n+    }\n+\n+    \/**\n+     * Tests undeclared exceptions and declared exceptions in proxies.\n+     *\/\n+    @Test\n+    public void testThrowables() {\n+        \/\/ don't wrap\n+        assertThrows(Error.class, throwing(Error.class, new Error())::close,\n+                \"Errors should be propagated\");\n+        assertThrows(RuntimeException.class, throwing(RuntimeException.class, new RuntimeException())::close,\n+                \"RuntimeException should be propagated\");\n+        assertThrows(IOException.class, throwing(IOException.class, new IOException())::close,\n+                \"Declared IOException should be propagated\");\n+        \/\/ wrap\n+        assertThrows(UndeclaredThrowableException.class, throwing(IllegalAccessException.class,\n+                        new IllegalAccessException())::close,\n+                \"Undeclared IllegalAccessException should be wrapped\");\n+    }\n+\n+    \/**\n+     * Tests that invalid interfaces are rejected.\n+     *\/\n+    @Test\n+    public void testRejects() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(PackagePrivate.class, mh),\n+                \"non-public interface\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(loadHidden(), mh),\n+                \"hidden interface\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(MultiAbstractMethods.class, mh),\n+                \"multiple abstract method names\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(NoAbstractMethods.class, mh),\n+                \"no abstract method\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(Sealed.class, mh),\n+                \"sealed interface\");\n+    }\n+\n+    \/**\n+     * Tests that non-sealed interfaces can be implemented.\n+     *\/\n+    @Test\n+    public void testNonSealed() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"Non-Sealed\");\n+        NonSealed proxy = asInterfaceInstance(NonSealed.class, target);\n+        assertEquals(proxy.m(), \"Non-Sealed\");\n+    }\n+\n+    \/**\n+     * Tests that Proxy correctly proxies potential bridge abstract methods.\n+     *\/\n+    @Test\n+    public void testMultiSameName() throws Throwable {\n+        var baseAndChild = loadBaseAndChild();\n+        var baseClass = baseAndChild.get(0);\n+        var childClass = baseAndChild.get(1);\n+        checkMethods(childClass.getMethods());\n+        checkMethods(childClass.getDeclaredMethods());\n+\n+        var lookup = MethodHandles.lookup();\n+        var baseValueMh = lookup.findVirtual(baseClass, \"value\", genericMethodType(0))\n+                .asType(genericMethodType(1));\n+        var childIntegerValueMh = lookup.findVirtual(childClass, \"value\", methodType(Integer.class))\n+                .asType(methodType(Integer.class, Object.class));\n+        var childIntValueMh = lookup.findVirtual(childClass, \"value\", methodType(int.class))\n+                .asType(methodType(int.class, Object.class));\n+\n+        Object child = asInterfaceInstance(childClass, MethodHandles.constant(Integer.class, 7));\n+\n+        assertEquals(7, (Object) baseValueMh.invokeExact(child));\n+        assertEquals(7, (Integer) childIntegerValueMh.invokeExact(child));\n+        assertEquals(7, (int) childIntValueMh.invokeExact(child));\n+    }\n+\n+    \/**\n+     * Tests that default methods can be used.\n+     *\/\n+    @Test\n+    public void testDefaultMethods() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"F\");\n+        C proxy = asInterfaceInstance(C.class, target);\n+\n+        assertEquals(proxy.f(), \"F\");\n+        assertEquals(proxy.a(), \"A\");\n+        assertEquals(proxy.b(), \"B\");\n+        assertEquals(proxy.c(), \"C\");\n+        assertEquals(proxy.concat(), \"ABC\");\n+    }\n+\n+    \/**\n+     * Tests that correct implementation of default methods are called,\n+     * and correct abstract methods are implemented.\n+     *\/\n+    @Test\n+    public void testOverrides() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"concat\");\n+        D proxy = asInterfaceInstance(D.class, target);\n+\n+        assertEquals(proxy.a(), \"OA\");\n+        assertEquals(proxy.b(), \"OB\");\n+        assertEquals(proxy.c(), \"OC\");\n+        assertEquals(proxy.f(), \"OF\");\n+        assertEquals(proxy.concat(), \"concat\");\n+    }\n+\n+    \/**\n+     * Tests primitive type conversions in proxies.\n+     *\/\n+    @Test\n+    public void testPrimitiveConversion() throws Throwable {\n+        var mh = MethodHandles.lookup().findStatic(BasicTest.class, \"mul\",\n+                methodType(long.class, int.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Function<Integer, Long> func = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh);\n+        assertEquals(32423432L * 32423432L, func.apply(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        ToLongFunction<Integer> func1 = (ToLongFunction<Integer>) asInterfaceInstance(ToLongFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func1.applyAsLong(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        IntFunction<Long> func2 = (IntFunction<Long>) asInterfaceInstance(IntFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func2.apply(32423432));\n+    }\n+\n+    \/**\n+     * Tests common type conversions in proxies.\n+     *\/\n+    @Test\n+    public void testBasicConversion() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        asInterfaceInstance(Client.class, mh).exec(); \/\/ return value dropped, runs fine\n+\n+        var nullMh = MethodHandles.zero(String.class);\n+        var badIterable = asInterfaceInstance(Iterable.class, nullMh);\n+        assertNull(badIterable.iterator()); \/\/ null is convertible\n+    }\n+\n+    \/**\n+     * Tests incompatible type conversions in proxy construction.\n+     *\/\n+    @Test\n+    public void testWrongConversion() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        assertThrows(WrongMethodTypeException.class, () -> asInterfaceInstance(IntSupplier.class, mh),\n+                \"cannot convert String return to int under any circumstance\");\n+\n+        var proxy = asInterfaceInstance(Iterable.class, mh);\n+        assertThrows(ClassCastException.class, proxy::iterator);\n+    }\n+\n+    private static <T extends Throwable> Closeable throwing(Class<T> clz, T value) {\n+        return asInterfaceInstance(Closeable.class, MethodHandles.throwException(void.class, clz).bindTo(value));\n+    }\n+\n+    private static long mul(int i) {\n+        return (long) i * i;\n+    }\n+\n+    void checkMethods(Method[] methods) {\n+        assertTrue(methods.length > 1, () -> \"Should have more than 1 declared methods, found only \" + Arrays.toString(methods));\n+        for (Method method : methods) {\n+            assertTrue(method.accessFlags().contains(AccessFlag.ABSTRACT), () -> method + \" is not abstract\");\n+        }\n+    }\n+\n+    private Class<?> loadHidden() {\n+        try (var is = BasicTest.class.getResourceAsStream(\"Client.class\")) {\n+            var bytes = Objects.requireNonNull(is).readAllBytes();\n+            var lookup = MethodHandles.lookup();\n+            return lookup.defineHiddenClass(bytes, true).lookupClass();\n+        } catch (Throwable ex) {\n+            return fail(\"Hidden interface loading failure\", ex);\n+        }\n+    }\n+\n+    \/\/ Base: Object value();\n+    \/\/ Child: Integer value(); int value();\n+    private List<Class<?>> loadBaseAndChild() throws IllegalAccessException {\n+        ClassDesc baseCd = ClassDesc.of(\"BasicTest$Base\");\n+        ClassDesc childCd = ClassDesc.of(\"BasicTest$Child\");\n+        var objMtd = MethodTypeDesc.of(CD_Object);\n+        var integerMtd = MethodTypeDesc.of(CD_Integer);\n+        var intMtd = MethodTypeDesc.of(CD_int);\n+        var classfile = Classfile.of(Classfile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.defaultResolver().orElse(\n+                ClassHierarchyResolver.of(List.of(baseCd, childCd), Map.ofEntries(Map.entry(baseCd, CD_Object),\n+                        Map.entry(childCd, CD_Object))))));\n+\n+        var baseBytes = classfile.build(baseCd, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", objMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var lookup = MethodHandles.lookup();\n+        var base = lookup.ensureInitialized(lookup.defineClass(baseBytes));\n+\n+        var childBytes = classfile.build(childCd, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(baseCd);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", integerMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+            clb.withMethod(\"value\", intMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var child = lookup.ensureInitialized(lookup.defineClass(childBytes));\n+        return List.of(base, child);\n+    }\n+\n+    public interface MultiAbstractMethods {\n+        String a();\n+        String b();\n+    }\n+\n+    public interface NoAbstractMethods {\n+        String toString();\n+    }\n+\n+    interface PackagePrivate {\n+        Object value();\n+    }\n+\n+    public interface A {\n+        default String a() {\n+            return \"A\";\n+        }\n+    }\n+\n+    public interface B {\n+        default String b() {\n+            return \"B\";\n+        }\n+    }\n+\n+    public interface C extends A, B {\n+        String f();\n+\n+        default String c() {\n+            return \"C\";\n+        }\n+\n+        default String concat() {\n+            return a() + b() + c();\n+        }\n+    }\n+\n+    public interface D extends C {\n+        String concat();\n+\n+        default String f() {\n+            return \"OF\";\n+        }\n+\n+        default String a() {\n+            return \"OA\";\n+        }\n+\n+        default String b() {\n+            return \"OB\";\n+        }\n+\n+        default String c() {\n+            return \"OC\";\n+        }\n+    }\n+\n+    public sealed interface Sealed permits NonSealed {\n+        String m();\n+    }\n+\n+    public non-sealed interface NonSealed extends Sealed {\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+\n+\/**\n+ * A general-purposed public client interface for testing.\n+ *\/\n+public interface Client {\n+    \/**\n+     * Returns a lookup from Client.class.\n+     *\/\n+    static Lookup lookup() {\n+        return MethodHandles.lookup();\n+    }\n+\n+    void exec();\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Client.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8206955 8269351\n- * @run testng\/othervm -ea -esa test.java.lang.invoke.MethodHandlesProxiesTest\n- *\/\n-\n-package test.java.lang.invoke;\n-\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class MethodHandlesProxiesTest {\n-\n-    public interface A {\n-        default String a() {\n-            return \"A\";\n-        }\n-    }\n-\n-    public interface B {\n-        default String b() {\n-            return \"B\";\n-        }\n-    }\n-\n-    public interface C extends A, B {\n-        String f();\n-\n-        default String c() {\n-            return \"C\";\n-        }\n-\n-        default String concat() {\n-            return a() + b() + c();\n-        }\n-    }\n-\n-    public interface Override extends C {\n-        String f();\n-\n-        default String a() {\n-            return \"OA\";\n-        }\n-\n-        default String b() {\n-            return \"OB\";\n-        }\n-\n-        default String c() {\n-            return \"OC\";\n-        }\n-    }\n-\n-    @Test\n-    public static void testDefaultMethods() throws Throwable {\n-        MethodHandle target = MethodHandles.constant(String.class, \"F\");\n-        C proxy = MethodHandleProxies.asInterfaceInstance(C.class, target);\n-\n-        assertEquals(proxy.f(), \"F\");\n-        assertEquals(proxy.a(), \"A\");\n-        assertEquals(proxy.b(), \"B\");\n-        assertEquals(proxy.c(), \"C\");\n-        assertEquals(proxy.concat(), \"ABC\");\n-    }\n-\n-    @Test\n-    public static void testOverriddenDefaultMethods() throws Throwable {\n-        MethodHandle target = MethodHandles.constant(String.class, \"F\");\n-        Override proxy = MethodHandleProxies.asInterfaceInstance(Override.class, target);\n-\n-        assertEquals(proxy.a(), \"OA\");\n-        assertEquals(proxy.b(), \"OB\");\n-        assertEquals(proxy.c(), \"OC\");\n-    }\n-\n-    public sealed interface Intf permits NonSealedInterface {\n-        String m();\n-    }\n-\n-    public non-sealed interface NonSealedInterface extends Intf {\n-    }\n-\n-    @Test(expectedExceptions = { IllegalArgumentException.class })\n-    public void testSealedInterface() {\n-        MethodHandle target = MethodHandles.constant(String.class, \"Sealed\");\n-        MethodHandleProxies.asInterfaceInstance(Intf.class, target);\n-    }\n-\n-    @Test\n-    public void testNonSealedInterface() {\n-        MethodHandle target = MethodHandles.constant(String.class, \"Non-Sealed\");\n-        NonSealedInterface proxy = MethodHandleProxies.asInterfaceInstance(NonSealedInterface.class, target);\n-        assertEquals(proxy.m(), \"Non-Sealed\");\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/MethodHandlesProxiesTest.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+\n+import static jdk.test.lib.Asserts.assertSame;\n+\n+\/*\n+ * @test\n+ * @bug 6983726\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Asserts Client\n+ * @run main\/othervm\/policy=jtreg.security.policy WithSecurityManagerTest\n+ * @summary Checks MethodHandleProxies behavior with security manager present\n+ *\/\n+public class WithSecurityManagerTest {\n+    public interface NestedInterface {\n+        void task();\n+    }\n+\n+    public static void main(String... args) {\n+        var originalMh = MethodHandles.zero(void.class);\n+\n+        \/\/ Test system and user interfaces\n+        for (Class<?> cl : List.of(Runnable.class, Client.class, NestedInterface.class)) {\n+            try {\n+                Object o = MethodHandleProxies.asInterfaceInstance(cl, originalMh);\n+                testWrapperInstanceTarget(o, originalMh);\n+                testWrapperInstanceType(o, cl);\n+            } catch (Throwable ex) {\n+                throw new AssertionError(\"Test failed for \" + cl, ex);\n+            }\n+        }\n+    }\n+\n+    private static void testWrapperInstanceTarget(Object wrapper, MethodHandle originalMh) {\n+        var recoveredTarget = MethodHandleProxies.wrapperInstanceTarget(wrapper);\n+        assertSame(originalMh, recoveredTarget, \"wrapperInstanceTarget recovery\");\n+    }\n+\n+    private static void testWrapperInstanceType(Object wrapper, Class<?> type) {\n+        var recoveredType = MethodHandleProxies.wrapperInstanceType(wrapper);\n+        assertSame(type, recoveredType, \"wrapperInstanceType recovery\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WithSecurityManagerTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.test.lib.util.ForceGC;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.WeakReference;\n+import java.util.Comparator;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandleProxies.*;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.misc.ValhallaFeatures;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 6983726\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.misc\n+ * @summary Tests on implementation hidden classes spinned by MethodHandleProxies\n+ * @build WrapperHiddenClassTest Client jdk.test.lib.util.ForceGC\n+ * @run junit WrapperHiddenClassTest\n+ *\/\n+public class WrapperHiddenClassTest {\n+\n+    \/**\n+     * Tests an adversary \"implementation\" class will not be\n+     * \"recovered\" by the wrapperInstance* APIs\n+     *\/\n+    @Test\n+    public void testWrapperInstance() throws Throwable {\n+        Comparator<Integer> hostile = createHostileInstance();\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertTrue(isWrapperInstance(proxy));\n+        assertFalse(isWrapperInstance(hostile));\n+        assertSame(mh, wrapperInstanceTarget(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(hostile));\n+        assertSame(Comparator.class, wrapperInstanceType(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(hostile));\n+    }\n+\n+    private static final String TYPE = \"interfaceType\";\n+    private static final String TARGET = \"target\";\n+    private static final ClassDesc CD_HostileWrapper = ClassDesc.of(\"HostileWrapper\");\n+    private static final ClassDesc CD_Comparator = ClassDesc.of(\"java.util.Comparator\");\n+    private static final MethodTypeDesc MTD_int_Object_Object = MethodTypeDesc.of(CD_int, CD_Object, CD_Object);\n+    private static final MethodTypeDesc MTD_int_Integer = MethodTypeDesc.of(CD_int, CD_Integer);\n+\n+    \/\/ Update this template when the MHP template is updated\n+    @SuppressWarnings(\"unchecked\")\n+    private Comparator<Integer> createHostileInstance() throws Throwable {\n+        var cf = Classfile.of();\n+        var bytes = cf.build(CD_HostileWrapper, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags((ValhallaFeatures.isEnabled() ? ACC_IDENTITY : 0) | ACC_FINAL | ACC_SYNTHETIC);\n+            clb.withInterfaceSymbols(CD_Comparator);\n+\n+            \/\/ static and instance fields\n+            clb.withField(TYPE, CD_Class, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+            clb.withField(TARGET, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+\n+            \/\/ <clinit>\n+            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                cob.constantInstruction(CD_Comparator);\n+                cob.putstatic(CD_HostileWrapper, TYPE, CD_Class);\n+                cob.return_();\n+            });\n+\n+            \/\/ <init>\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+\n+            \/\/ implementation\n+            clb.withMethodBody(\"compare\", MTD_int_Object_Object, ACC_PUBLIC, cob -> {\n+                cob.aload(1);\n+                cob.checkcast(CD_Integer);\n+                cob.aload(2);\n+                cob.checkcast(CD_Integer);\n+                cob.invokestatic(CD_Integer, \"compareTo\", MTD_int_Integer);\n+                cob.ireturn();\n+            });\n+        });\n+        var l = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        return (Comparator<Integer>) l.findConstructor(l.lookupClass(), MethodType.methodType(void.class)).invoke();\n+    }\n+\n+    \/**\n+     * Ensures a user interface cannot access a Proxy implementing it.\n+     *\/\n+    @Test\n+    public void testNoAccess() {\n+        var instance = asInterfaceInstance(Client.class, MethodHandles.zero(void.class));\n+        var instanceClass = instance.getClass();\n+        var interfaceLookup = Client.lookup();\n+        assertEquals(MethodHandles.Lookup.ORIGINAL, interfaceLookup.lookupModes() & MethodHandles.Lookup.ORIGINAL,\n+                \"Missing original flag on interface's lookup\");\n+        assertThrows(IllegalAccessException.class, () -> MethodHandles.privateLookupIn(instanceClass,\n+                interfaceLookup));\n+    }\n+\n+    \/**\n+     * Tests the Proxy module properties for Proxies implementing system and\n+     * user interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Client.class, Runnable.class})\n+    public void testModule(Class<?> ifaceClass) {\n+        var mh = MethodHandles.zero(void.class);\n+\n+        var inst = asInterfaceInstance(ifaceClass, mh);\n+        Module ifaceModule = ifaceClass.getModule();\n+        Class<?> implClass = inst.getClass();\n+        Module implModule = implClass.getModule();\n+\n+        String implPackage = implClass.getPackageName();\n+        assertFalse(implModule.isExported(implPackage),\n+                \"implementation should not be exported\");\n+        assertTrue(ifaceModule.isExported(ifaceClass.getPackageName(), implModule),\n+                \"interface package should be exported to implementation\");\n+        assertTrue(implModule.isOpen(implPackage, MethodHandleProxies.class.getModule()),\n+                \"implementation class is not reflectively open to MHP class\");\n+        assertTrue(implModule.isNamed(), \"dynamic module must be named\");\n+        assertTrue(implModule.getName().startsWith(\"jdk.MHProxy\"),\n+                () -> \"incorrect dynamic module name: \" + implModule.getName());\n+\n+        assertSame(ifaceClass.getClassLoader(), implClass.getClassLoader(),\n+                \"wrapper class should use the interface's loader \");\n+        assertSame(implClass.getClassLoader(), implModule.getClassLoader(),\n+                \"module class loader should be wrapper class's loader\");\n+    }\n+\n+    \/**\n+     * Tests the access control of Proxies implementing system and user\n+     * interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Client.class, Runnable.class})\n+    public void testNoInstantiation(Class<?> ifaceClass) throws ReflectiveOperationException {\n+        var mh = MethodHandles.zero(void.class);\n+        var instanceClass = asInterfaceInstance(ifaceClass, mh).getClass();\n+        var ctor = instanceClass.getDeclaredConstructor(MethodHandles.Lookup.class, MethodHandle.class, MethodHandle.class);\n+\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(Client.lookup(), mh, mh));\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.lookup(), mh, mh));\n+        assertThrows(IllegalAccessException.class, () -> ctor.newInstance(MethodHandles.publicLookup(), mh, mh));\n+    }\n+\n+    \/**\n+     * Tests the caching and weak reference of implementation classes for\n+     * system and user interfaces.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(classes = {Runnable.class, Client.class})\n+    public void testWeakImplClass(Class<?> ifaceClass) {\n+        var mh = MethodHandles.zero(void.class);\n+\n+        var wrapper1 = asInterfaceInstance(ifaceClass, mh);\n+        var implClass = wrapper1.getClass();\n+\n+        System.gc(); \/\/ helps debug if incorrect items are weakly referenced\n+        var wrapper2 = asInterfaceInstance(ifaceClass, mh);\n+        assertSame(implClass, wrapper2.getClass(),\n+                \"MHP should reuse old implementation class when available\");\n+\n+        var implClassRef = new WeakReference<>(implClass);\n+        \/\/ clear strong references\n+        implClass = null;\n+        wrapper1 = null;\n+        wrapper2 = null;\n+\n+        if (!ForceGC.wait(() -> implClassRef.refersTo(null))) {\n+            fail(\"MHP impl class cannot be cleared by GC\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/WrapperHiddenClassTest.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/jtreg.security.policy","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/invoke\/7196190\/jtreg.security.policy","status":"copied"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.InvocationTargetException;\n-\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-\/**\n- * @test\n- * @summary test MethodHandleProxies that adds qualified export of sun.invoke\n- * from java.base to a dynamic module\n- * @run testng ProxyForMethodHandle\n- *\/\n-public class ProxyForMethodHandle {\n-    \/**\n-     * MethodHandleProxies will add qualified export of sun.invoke from java.base\n-     * to a dynamic module\n-     *\/\n-    @Test\n-    public static void testRunnableMethodHandle() throws Exception {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodType mt = MethodType.methodType(void.class);\n-        MethodHandle mh = lookup.findStatic(ProxyForMethodHandle.class, \"runForRunnable\", mt);\n-        Runnable proxy = MethodHandleProxies.asInterfaceInstance(Runnable.class, mh);\n-        proxy.run();\n-\n-        Class<?> proxyClass = proxy.getClass();\n-        Module target = proxyClass.getModule();\n-        assertDynamicModule(target, proxyClass.getClassLoader(), proxyClass);\n-    }\n-\n-    static void runForRunnable() {\n-        System.out.println(\"runForRunnable\");\n-    }\n-\n-    public static void assertDynamicModule(Module m, ClassLoader ld, Class<?> proxyClass) {\n-        if (!m.isNamed() || !m.getName().startsWith(\"jdk.proxy\")) {\n-            throw new RuntimeException(m.getName() + \" not dynamic module\");\n-        }\n-\n-        if (ld != m.getClassLoader() || proxyClass.getClassLoader() != ld) {\n-            throw new RuntimeException(\"unexpected class loader\");\n-        }\n-\n-        try {\n-            Constructor<?> cons = proxyClass.getConstructor(InvocationHandler.class);\n-            cons.newInstance(handler);\n-            throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n-        } catch (IllegalAccessException e) {\n-            \/\/ expected\n-        } catch (NoSuchMethodException|InstantiationException|InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    private final static InvocationHandler handler =\n-            (proxy, m, params) -> { throw new RuntimeException(m.toString()); };\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyForMethodHandle.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @modules java.base\/sun.invoke\n+ * @modules java.base\/jdk.internal.misc\n@@ -40,2 +40,2 @@\n-        \/\/ unnamed module gets access to sun.invoke package (e.g. via --add-exports)\n-        new ProxyModuleMapping(sun.invoke.WrapperInstance.class).test();\n+        \/\/ unnamed module gets access to jdk.internal.misc package (e.g. via --add-exports)\n+        new ProxyModuleMapping(jdk.internal.misc.VM.BufferPool.class).test();\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyModuleMapping.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.net.InetSocketAddress;\n@@ -72,1 +73,1 @@\n-        \/\/wildcardAddr = new InetSocketAddress(0).getAddress();\n+        wildcardAddr = new InetSocketAddress(0).getAddress();\n@@ -80,3 +81,0 @@\n-        \/*\n-        \/\/Commented until JDK-8236852 is fixed\n-\n@@ -88,2 +86,0 @@\n-        \/\/Commented until JDK-8236807 is fixed\n-\n@@ -91,0 +87,1 @@\n+        \/\/ Not currently tested. See JDK-8236807\n@@ -92,4 +89,2 @@\n-        var addr = socket.getAddress();\n-        wildcardValidPkt.setAddress(addr);\n-        wildcardValidPkt.setPort(socket.getLocalPort());\n-      *\/\n+        wildcardValidPkt.setAddress(wildcardAddr);\n+        wildcardValidPkt.setPort(datagramSocket.getLocalPort());\n@@ -102,0 +97,4 @@\n+                { datagramSocket,        wildcardZeroPkt },\n+                \/\/ Re-enable when JDK-8236807 fixed\n+                \/\/{ datagramSocket,        wildcardValidPkt },\n+\n@@ -103,0 +102,3 @@\n+                { datagramSocketAdaptor, wildcardZeroPkt },\n+                \/\/ Re-enable when JDK-8236807 fixed\n+                \/\/{ datagramSocketAdaptor, wildcardValidPkt },\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendPortZero.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.net.InetSocketAddress;\n@@ -71,1 +72,1 @@\n-        \/\/wildcardAddr = new InetSocketAddress(0).getAddress();\n+        wildcardAddr = new InetSocketAddress(0).getAddress();\n@@ -79,3 +80,0 @@\n-        \/*\n-        \/\/Commented until JDK-8236852 is fixed\n-\n@@ -87,2 +85,0 @@\n-        \/\/Commented until JDK-8236807 is fixed\n-\n@@ -90,0 +86,1 @@\n+        \/\/ Not currently tested. See JDK-8236807\n@@ -91,4 +88,2 @@\n-        var addr = socket.getAddress();\n-        wildcardValidPkt.setAddress(addr);\n-        wildcardValidPkt.setPort(socket.getLocalPort());\n-      *\/\n+        wildcardValidPkt.setAddress(wildcardAddr);\n+        wildcardValidPkt.setPort(multicastSocket.getLocalPort());\n@@ -100,1 +95,4 @@\n-                { multicastSocket,       loopbackZeroPkt }\n+                { multicastSocket,       loopbackZeroPkt },\n+                { multicastSocket,       wildcardZeroPkt },\n+                \/\/ Not currently tested. See JDK-8236807\n+                \/\/{ multicastSocket,       wildcardValidPkt }\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SendPortZero.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8136895\n+ * @summary Verify channel closed after write error in StreamEncoder::implClose\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.MalformedInputException;\n+import java.nio.charset.StandardCharsets;\n+\n+public class CloseWriterOnFailedFlush {\n+    private static final String STR_IOE = \"Test\";   \/\/ IOException\n+    private static final String STR_MIE = \"\\ud83c\"; \/\/ MalformedInputException\n+\n+    public static void main(String[] args) throws IOException {\n+        boolean failed = false;\n+\n+        for (String s : new String[] {STR_IOE, STR_MIE}) {\n+            System.out.println(\"string: \" + s);\n+            ErroringByteChannel channel = new ErroringByteChannel();\n+            try (Writer writer = Channels.newWriter\n+                    (channel, StandardCharsets.UTF_8.newEncoder(), -1 )) {\n+                writer.write(s);\n+            } catch (IOException ex) {\n+                Class exClass = ex.getClass();\n+                if (s.equals(STR_IOE) && exClass != IOException.class ||\n+                    s.equals(STR_MIE) && exClass != MalformedInputException.class)\n+                    throw ex;\n+            }\n+\n+            if (channel.isOpen()) {\n+                System.err.println(\"Channel is STILL open\");\n+                failed = true;\n+            } else {\n+                System.out.println(\"Channel is closed\");\n+            }\n+        }\n+\n+        if (failed)\n+            throw new RuntimeException(\"Test failed\");\n+    }\n+\n+    private static class ErroringByteChannel implements WritableByteChannel {\n+        private boolean open = true;\n+\n+        @Override\n+        public int write(ByteBuffer src) throws IOException {\n+            throw new IOException();\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return open;\n+        }\n+\n+        @Override\n+        public void close() {\n+            open = false;\n+            System.out.println(\"Closing\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/CloseWriterOnFailedFlush.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -25,1 +25,2 @@\n- * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876 8298478\n+ * @bug 4313887 6838333 6925932 7006126 8037945 8072495 8140449 8254876 8262742\n+ *      8298478\n@@ -185,0 +186,21 @@\n+    \/\/ Note: \"expected\" is first parameter here\n+    PathOps resolve(String expected, String first, String... more) {\n+        out.format(\"test resolve %s varargs (String)\\n\", path());\n+        checkPath();\n+        check(path.resolve(first, more), expected);\n+        Path[] others = new Path[more.length];\n+        int i = 0;\n+        for (String s : more) {\n+            others[i++] = Path.of(s);\n+        }\n+        return resolve(expected, Path.of(first), others);\n+    }\n+\n+    \/\/ Note: \"expected\" is first parameter here\n+    PathOps resolve(String expected, Path first, Path... more) {\n+        out.format(\"test resolve %s varargs (Path)\\n\", path());\n+        checkPath();\n+        check(path.resolve(first, more), expected);\n+        return this;\n+    }\n+\n@@ -546,0 +568,29 @@\n+        \/\/ resolve - varargs\n+        test(\"C:\\\\tmp\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"C:\\\\gus\", \"\\\\foo\", \"bar\", \"\\\\gus\")\n+            .resolve(\"C:\\\\tmp\\\\baz\", \"\", \"\", \"baz\");\n+        test(\"C:\\\\tmp\\\\foo\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\", \"\", \"bar\\\\gus\", \"\")\n+            .resolve(\"C:\\\\tmp\\\\foo\\\\bar\\\\gus\\\\foo\\\\baz\",\n+                     \"\", \"bar\\\\gus\", \"foo\\\\baz\")\n+            .resolve(\"C:\\\\bar\\\\gus\\\\baz\", \"\", \"C:\\\\bar\\\\gus\", \"baz\")\n+            .resolve(\"C:\\\\tmp\\\\bar\", \"C:\\\\bar\\\\gus\", \"baz\", \"C:\\\\tmp\\\\bar\");\n+        test(\"tmp\")\n+            .resolve(\"tmp\\\\foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\\\\gus\", \"\\\\foo\", \"bar\", \"\\\\gus\")\n+            .resolve(\"tmp\\\\baz\", \"\", \"\", \"baz\");\n+        test(\"\")\n+            .resolve(\"\", \"\", \"\")\n+            .resolve(\"\\\\bar\", \"foo\", \"\\\\bar\", \"\")\n+            .resolve(\"foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"baz\", \"\", \"\", \"baz\");\n+        test(\"\\\\\")\n+            .resolve(\"\\\\foo\", \"foo\", \"\")\n+            .resolve(\"\\\\foo\", \"\", \"foo\")\n+            .resolve(\"\\\\bar\", \"foo\", \"\", \"\\\\bar\");\n+        test(\"C:\")\n+            .resolve(\"C:foo\\\\bar\\\\gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"C:baz\", \"\", \"baz\")\n+            .resolve(\"C:\", \"\", \"\");\n+\n@@ -1672,0 +1723,25 @@\n+        \/\/ resolve - varargs\n+        test(\"\/tmp\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\/gus\", \"\/foo\", \"bar\", \"\/gus\")\n+            .resolve(\"\/tmp\/baz\", \"\", \"\", \"baz\");\n+        test(\"\/tmp\/foo\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\", \"\", \"bar\/gus\", \"\")\n+            .resolve(\"\/tmp\/foo\/bar\/gus\/foo\/baz\", \"\", \"bar\/gus\", \"foo\/baz\")\n+            .resolve(\"\/bar\/gus\/baz\", \"\", \"\/bar\/gus\", \"baz\")\n+            .resolve(\"\/tmp\/bar\", \"\/bar\/gus\", \"baz\", \"\/tmp\/bar\");\n+        test(\"tmp\")\n+            .resolve(\"tmp\/foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"\/gus\", \"\/foo\", \"bar\", \"\/gus\")\n+            .resolve(\"tmp\/baz\", \"\", \"\", \"baz\");\n+        test(\"\")\n+            .resolve(\"\", \"\", \"\")\n+            .resolve(\"\/bar\", \"foo\", \"\/bar\", \"\")\n+            .resolve(\"foo\/bar\/gus\", \"foo\", \"bar\", \"gus\")\n+            .resolve(\"baz\", \"\", \"\", \"baz\");\n+        test(\"\/\")\n+            .resolve(\"\/foo\", \"\", \"\", \"foo\", \"\")\n+            .resolve(\"\/foo\", \"foo\", \"\")\n+            .resolve(\"\/foo\", \"\", \"foo\")\n+            .resolve(\"\/bar\", \"foo\", \"\", \"\/bar\");\n+\n@@ -2080,1 +2156,1 @@\n-            Path.of(\"foo\", null);\n+            Path.of(\"foo\", (String[])null);\n","filename":"test\/jdk\/java\/nio\/file\/Path\/PathOps.java","additions":78,"deletions":2,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Confirm that a bug in an error message has been fixed.\n- * @bug 6481179\n- *\/\n-\n-import java.text.MessageFormat;\n-import java.text.ParseException;\n-\n-public class Bug6481179 {\n-\n-    public static void main(String[] args) {\n-        boolean err = false;\n-\n-        try {\n-            MessageFormat.format(\"Testdata {1,invalid_format_type}\",\n-                                 new Object[] { \"val0\", \"val1\" });\n-\n-            System.err.println(\"Error: IllegalArgumentException should be thrown.\");\n-            err = true;\n-        }\n-        catch (IllegalArgumentException e) {\n-            String expected = \"unknown format type: invalid_format_type\";\n-            String got = e.getMessage();\n-\n-            if (!expected.equals(got)) {\n-                System.err.println(\"Error: Unexpected error message: \" + got);\n-                err = true;\n-            }\n-        }\n-        catch (Exception e) {\n-            System.err.println(\"Error: Unexpected exception was thrown: \" + e);\n-            err = true;\n-        }\n-\n-        if (err) {\n-            throw new RuntimeException(\"Failed.\");\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/Bug6481179.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Validate some exceptions in MessageFormat\n+ * @bug 6481179 8039165\n+ * @run junit MessageFormatExceptions\n+ *\/\n+\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class MessageFormatExceptions {\n+\n+    \/\/ MessageFormat should throw NPE when constructed with a null pattern\n+    @Test\n+    public void nullPatternTest() {\n+        assertThrows(NullPointerException.class, () -> new MessageFormat(null));\n+        assertThrows(NullPointerException.class, () -> new MessageFormat(null, Locale.US));\n+        assertThrows(NullPointerException.class,\n+                () -> MessageFormat.format(null, new Object[] { \"val0\", \"val1\" }));\n+    }\n+\n+    \/\/ 8039165: When MessageFormat is constructed with a null locale a NPE\n+    \/\/ can potentially be thrown depending on the subformat created. Either\n+    \/\/ during the creation of the object itself, or later when format() is called.\n+    \/\/ The following are some examples.\n+    @Test\n+    public void nullLocaleTest() {\n+        \/\/ Fails when constructor invokes applyPattern()\n+        assertThrows(NullPointerException.class,\n+                () -> new MessageFormat(\"{0, date}\", null));\n+        \/\/ Fail when constructor invokes applyPattern()\n+        assertThrows(NullPointerException.class,\n+                () -> new MessageFormat(\"{0, number}\", null));\n+        \/\/ Fail when object calls format()\n+        assertThrows(NullPointerException.class,\n+                () -> new MessageFormat(\"{0}\", null).format(new Object[]{42}));\n+        \/\/ Fail when object calls format(), but locale is set via .setLocale()\n+        MessageFormat msgFmt = new MessageFormat(\"{0}\");\n+        msgFmt.setLocale(null);\n+        assertThrows(NullPointerException.class, () -> msgFmt.format(new Object[]{42}));\n+        \/\/ Does not always fail if locale is null\n+        assertDoesNotThrow(() ->\n+                new MessageFormat(\"{0}\", null).format(new Object[]{\"hello\"}));\n+\n+    }\n+\n+    \/\/ 6481179: Invalid format type should be provided in error message of IAE\n+    @Test\n+    public void formatMsgTest() {\n+        IllegalArgumentException iae = assertThrows(IllegalArgumentException.class,\n+                () -> MessageFormat.format(\"Testdata {1,invalid_format_type}\", new Object[] { \"val0\", \"val1\" }));\n+        assertEquals(\"unknown format type: invalid_format_type\", iae.getMessage());\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageFormatExceptions.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -62,0 +62,1 @@\n+\n@@ -65,9 +66,14 @@\n-    public WhiteBox() throws ReflectiveOperationException {\n-        Class<?> qClass = LinkedTransferQueue.class;\n-        Class<?> nodeClass = Class.forName(qClass.getName() + \"$Node\");\n-        MethodHandles.Lookup lookup\n-            = MethodHandles.privateLookupIn(qClass, MethodHandles.lookup());\n-        HEAD = lookup.findVarHandle(qClass, \"head\", nodeClass);\n-        TAIL = lookup.findVarHandle(qClass, \"tail\", nodeClass);\n-        NEXT = lookup.findVarHandle(nodeClass, \"next\", nodeClass);\n-        ITEM = lookup.findVarHandle(nodeClass, \"item\", Object.class);\n+    public WhiteBox() throws Throwable { \/\/ throws ReflectiveOperationException {\n+        try {\n+            Class<?> qClass = LinkedTransferQueue.class;\n+            Class<?> nodeClass = Class.forName(qClass.getName() + \"$DualNode\");\n+            MethodHandles.Lookup lookup\n+                = MethodHandles.privateLookupIn(qClass, MethodHandles.lookup());\n+            HEAD = lookup.findVarHandle(qClass, \"head\", nodeClass);\n+            TAIL = lookup.findVarHandle(qClass, \"tail\", nodeClass);\n+            NEXT = lookup.findVarHandle(nodeClass, \"next\", nodeClass);\n+            ITEM = lookup.findVarHandle(nodeClass, \"item\", Object.class);\n+        } catch (Throwable ex) {\n+            ex.printStackTrace();\n+            throw ex;\n+        }\n@@ -81,0 +87,10 @@\n+    \/*\n+     * Modified for jdk22: Accommodate lazy initialization, so counts\n+     * may vary by 1, and some nodes become headers vs unlinked,\n+     * compared to previous versions.\n+     *\/\n+\n+    static void checkCount(int val, int expect) {\n+        assertTrue(val == expect || val == expect - 1);\n+    }\n+\n@@ -127,2 +143,4 @@\n-        assertNull(next(head(q)));\n-        assertNull(item(head(q)));\n+        if (head(q) != null) {\n+            assertNull(next(head(q)));\n+            assertNull(item(head(q)));\n+        }\n@@ -130,1 +148,1 @@\n-        assertEquals(nodeCount(q), 2);\n+        checkCount(nodeCount(q), 2);\n@@ -133,1 +151,1 @@\n-        assertEquals(nodeCount(q), 1);\n+        checkCount(nodeCount(q), 1);\n@@ -161,1 +179,1 @@\n-        assertEquals(nodeCount(q), n + 1);\n+        checkCount(nodeCount(q), n + 1);\n@@ -165,2 +183,2 @@\n-        assertEquals(nodeCount(q), n);\n-        assertIsSelfLinked(oldHead);\n+        checkCount(nodeCount(q), n);\n+        \/\/        assertIsSelfLinked(oldHead);\n@@ -207,1 +225,1 @@\n-        assertEquals(nodeCount(q), c - 1);\n+        checkCount(nodeCount(q), c - 1);\n@@ -220,1 +238,1 @@\n-        assertEquals(nodeCount(q), c - 1);\n+        checkCount(nodeCount(q), c - 1);\n@@ -231,1 +249,1 @@\n-        int n = rnd.nextInt(6);\n+        int n = 1 + rnd.nextInt(6);\n@@ -241,1 +259,1 @@\n-        assertEquals(q.size(), c - (q.contains(n - 1) ? 0 : 1));\n+        checkCount(c - (q.contains(n - 1) ? 0 : 1), q.size() + 1);\n@@ -266,1 +284,1 @@\n-        assertEquals(nodeCount(q), 1);\n+        checkCount(nodeCount(q), 1);\n@@ -292,1 +310,1 @@\n-        assertEquals(nodeCount(q), n + 1);\n+        checkCount(nodeCount(q), n + 1);\n@@ -298,1 +316,1 @@\n-            assertEquals(nodeCount(q), q.isEmpty() ? 1 : c - (slack ? 2 : 0));\n+            checkCount(nodeCount(q), q.isEmpty() ? 1 : c - (slack ? 2 : 0));\n@@ -321,1 +339,2 @@\n-            boolean slack = next(tail(q)) != null;\n+            boolean empty = (tail(q) == null);\n+            boolean slack = !empty && (next(tail(q)) != null);\n@@ -325,1 +344,1 @@\n-            else {\n+            else if (!empty) {\n@@ -368,2 +387,0 @@\n-        assertNotNull(head(q));\n-        assertNotNull(tail(q));\n@@ -371,2 +388,3 @@\n-        for (Object h; next(h = head(q)) == h; )\n-            assertNotSame(h, head(q)); \/\/ must be update race\n+        Object h;\n+        if ((h = head(q)) != null)\n+            assertNotSame(h, next(h));\n","filename":"test\/jdk\/java\/util\/concurrent\/LinkedTransferQueue\/WhiteBox.java","additions":47,"deletions":29,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.ComponentOrientation;\n+\n+import javax.swing.JComponent;\n+import javax.swing.JFileChooser;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+\/*\n+ * @test\n+ * @bug 6442919\n+ * @library ..\/regtesthelpers\n+ * @build Util\n+ * @summary Test to check the orientation of Popup menu is set\n+ * as per FileChooser orientation.\n+ * @run main FCPopupMenuOrientationTest\n+ *\/\n+\n+public class FCPopupMenuOrientationTest {\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                for (UIManager.LookAndFeelInfo laf :\n+                        UIManager.getInstalledLookAndFeels()) {\n+                    String className = laf.getName().toLowerCase();\n+                    if (className.contains(\"motif\")\n+                            || className.contains(\"mac\")\n+                            || className.contains(\"gtk\")) {\n+                        continue;\n+                    }\n+                    setLookAndFeel(laf);\n+                    JFileChooser fc = new JFileChooser();\n+                    fc.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);\n+\n+                    JComponent comp = (JComponent) Util.findSubComponent(\n+                            fc, \"FilePane\");\n+                    JPopupMenu popupMenu = comp.getComponentPopupMenu();\n+                    if (popupMenu.getComponentOrientation() !=\n+                            fc.getComponentOrientation()) {\n+                        throw new RuntimeException(\"File Chooser component \" +\n+                                \"orientation doesn't match with PopupMenu\");\n+                    }\n+                }\n+            }\n+        });\n+        System.out.println(\"Test Pass\");\n+    }\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+            System.out.println(\"Set L&F : \" + laf.getName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LookAndFeel: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException |\n+                 IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FCPopupMenuOrientationTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n-\n+import java.awt.EventQueue;\n@@ -37,1 +37,1 @@\n-\n+    static volatile long total = 0;\n@@ -72,1 +72,0 @@\n-                long total = 0;\n@@ -79,2 +78,8 @@\n-\n-                    pmis.getProgressMonitor().setNote(total\/(1024*1024)+\" MB Read\");\n+                    System.out.println(\"total \" + total);\n+                    if ((total % (1024*1024)) == 0) {\n+                        try {\n+                            EventQueue.invokeAndWait(() -> {\n+                                pmis.getProgressMonitor().setNote(total\/(1024*1024)+\" MB Read\");\n+                            });\n+                        } catch (Exception e) {}\n+                    }\n","filename":"test\/jdk\/javax\/swing\/ProgressMonitor\/ProgressTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,11 +57,14 @@\n-\n-        try (Recording r = new Recording()) {\n-            r.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n-            r.start();\n-            leak = createChain();\n-            List<RecordedEvent> events = Events.fromRecording(r);\n-            if (OldObjects.countMatchingEvents(events, byte[].class, null, null, -1, \"createChain\") == 0) {\n-                throw new Exception(\"Could not find ChainNode\");\n-            }\n-            for (RecordedEvent e : events) {\n-                OldObjects.validateReferenceChainLimit(e, OldObjects.MAX_CHAIN_LENGTH);\n+        while (true) {\n+            try (Recording r = new Recording()) {\n+                r.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n+                r.start();\n+                leak = createChain();\n+                List<RecordedEvent> events = Events.fromRecording(r);\n+                if (OldObjects.countMatchingEvents(events, byte[].class, null, null, -1, \"createChain\") > 0) {\n+                    for (RecordedEvent e : events) {\n+                        OldObjects.validateReferenceChainLimit(e, OldObjects.MAX_CHAIN_LENGTH);\n+                    }\n+                    return;\n+                }\n+                System.out.println(\"Could not find old object sample of type byte[]. Retrying.\");\n+                leak = null;\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestHeapDeep.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- *                   -XX:+UseG1GC jdk.jfr.jcmd.TestJcmdView\n+ *                   -XX:+UseG1GC -Xlog:jfr+dcmd=debug -Xlog:jfr+system+parser=info jdk.jfr.jcmd.TestJcmdView\n@@ -97,1 +97,1 @@\n-            oldCollection.countDown();\n+            oldCollection.await();\n@@ -108,0 +108,1 @@\n+            System.out.println(\"Time before testEventType() \" + Instant.now());\n@@ -114,0 +115,1 @@\n+            System.out.println(\"About to rotate chunk\");\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdView.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import jdk.jfr.Configuration;\n+import jdk.jfr.Recording;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @summary The test verifies JFR.view command\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.jcmd.TestJcmdViewMissingData\n+ *\/\n+public class TestJcmdViewMissingData {\n+\n+    public static void main(String... args) throws Exception {\n+        testNotInitialized();\n+        testInMemory();\n+        testClosed();\n+    }\n+\n+    private static void testNotInitialized() {\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.view\", \"jvm-information\");\n+        output.shouldContain(\"No recording data available. Start a recording with JFR.start.\");\n+    }\n+\n+    private static void testInMemory() throws Exception {\n+        Configuration c = Configuration.getConfiguration(\"default\");\n+        try (Recording r = new Recording(c)) {\n+            r.setToDisk(false);\n+            r.start();\n+            OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.view\", \"hot-methods\");\n+            output.shouldContain(\"No recording data found on disk.\");\n+            r.stop();\n+        }\n+    }\n+\n+    private static void testClosed() throws Exception {\n+        Configuration c = Configuration.getConfiguration(\"default\");\n+        try (Recording r = new Recording(c)) {\n+            r.start();\n+            r.stop();\n+        }\n+        OutputAnalyzer output = JcmdHelper.jcmd(\"JFR.view\", \"hot-methods\");\n+        output.shouldContain(\"No recording data found on disk.\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdViewMissingData.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-        boolean ocspEnabled = false;\n@@ -61,1 +60,0 @@\n-            ocspEnabled = true;\n@@ -64,4 +62,4 @@\n-        new AmazonCA_1().runTest(pathValidator, ocspEnabled);\n-        new AmazonCA_2().runTest(pathValidator, ocspEnabled);\n-        new AmazonCA_3().runTest(pathValidator, ocspEnabled);\n-        new AmazonCA_4().runTest(pathValidator, ocspEnabled);\n+        new AmazonCA_1().runTest(pathValidator);\n+        new AmazonCA_2().runTest(pathValidator);\n+        new AmazonCA_3().runTest(pathValidator);\n+        new AmazonCA_4().runTest(pathValidator);\n@@ -73,1 +71,1 @@\n-    \/\/ Owner: CN=Amazon, OU=Server CA 1A, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon RSA 2048 M02, O=Amazon, C=US\n@@ -75,4 +73,35 @@\n-    \/\/ Serial number: 67f9457508c648c09ca652e71791830e72592\n-    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n-    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIERzCCAy+gAwIBAgITBn+UV1CMZIwJymUucXkYMOclkjANBgkqhkiG9w0BAQsF\\n\" +\n+    \/\/ Serial number: 773124a4bcbd44ec7b53beaf194842d3a0fa1\n+    \/\/ Valid from: Tue Aug 23 15:25:30 PDT 2022 until: Fri Aug 23 15:25:30 PDT 2030\n+    private static final String INT_VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIEXjCCA0agAwIBAgITB3MSSkvL1E7HtTvq8ZSELToPoTANBgkqhkiG9w0BAQsF\\n\" +\n+            \"ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\\n\" +\n+            \"b24gUm9vdCBDQSAxMB4XDTIyMDgyMzIyMjUzMFoXDTMwMDgyMzIyMjUzMFowPDEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n+            \"QSAyMDQ4IE0wMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALtDGMZa\\n\" +\n+            \"qHneKei1by6+pUPPLljTB143Si6VpEWPc6mSkFhZb\/6qrkZyoHlQLbDYnI2D7hD0\\n\" +\n+            \"sdzEqfnuAjIsuXQLG3A8TvX6V3oFNBFVe8NlLJHvBseKY88saLwufxkZVwk74g4n\\n\" +\n+            \"WlNMXzla9Y5F3wwRHwMVH443xGz6UtGSZSqQ94eFx5X7Tlqt8whi8qCaKdZ5rNak\\n\" +\n+            \"+r9nUThOeClqFd4oXych\/\/Rc7Y0eX1KNWHYSI1Nk31mYgiK3JvH063g+K9tHA63Z\\n\" +\n+            \"eTgKgndlh+WI+zv7i44HepRZjA1FYwYZ9Vv\/9UkC5Yz8\/yU65fgjaE+wVHM4e\/Yy\\n\" +\n+            \"C2osrPWE7gJ+dXMCAwEAAaOCAVowggFWMBIGA1UdEwEB\/wQIMAYBAf8CAQAwDgYD\\n\" +\n+            \"VR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNV\\n\" +\n+            \"HQ4EFgQUwDFSzVpQw4J8dHHOy+mc+XrrguIwHwYDVR0jBBgwFoAUhBjMhTTsvAyU\\n\" +\n+            \"lC4IWZzHshBOCggwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8v\\n\" +\n+            \"b2NzcC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDov\\n\" +\n+            \"L2NydC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8E\\n\" +\n+            \"ODA2MDSgMqAwhi5odHRwOi8vY3JsLnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jv\\n\" +\n+            \"b3RjYTEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMA0GCSqGSIb3DQEBCwUAA4IB\\n\" +\n+            \"AQAtTi6Fs0Azfi+iwm7jrz+CSxHH+uHl7Law3MQSXVtR8RV53PtR6r\/6gNpqlzdo\\n\" +\n+            \"Zq4FKbADi1v9Bun8RY8D51uedRfjsbeodizeBB8nXmeyD33Ep7VATj4ozcd31YFV\\n\" +\n+            \"fgRhvTSxNrrTlNpWkUk0m3BMPv8sg381HhA6uEYokE5q9uws\/3YkKqRiEz3TsaWm\\n\" +\n+            \"JqIRZhMbgAfp7O7FUwFIb7UIspogZSKxPIWJpxiPo3TcBambbVtQOcNRWz5qCQdD\\n\" +\n+            \"slI2yayq0n2TXoHyNCLEH8rpsJRVILFsg0jc7BaFrMnF462+ajSehgj12IidNeRN\\n\" +\n+            \"4zl+EoNaWdpnWndvSpAEkq2P\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=Amazon RSA 2048 M01, O=Amazon, C=US\n+    \/\/ Issuer: CN=Amazon Root CA 1, O=Amazon, C=US\n+    \/\/ Serial number: 77312380b9d6688a33b1ed9bf9ccda68e0e0f\n+    \/\/ Valid from: Tue Aug 23 15:21:28 PDT 2022 until: Fri Aug 23 15:21:28 PDT 2030\n+    private static final String INT_REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIEXjCCA0agAwIBAgITB3MSOAudZoijOx7Zv5zNpo4ODzANBgkqhkiG9w0BAQsF\\n\" +\n@@ -80,21 +109,22 @@\n-            \"b24gUm9vdCBDQSAxMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENB\\n\" +\n-            \"IDFBMQ8wDQYDVQQDEwZBbWF6b24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\\n\" +\n-            \"AoIBAQCeQM3XCsIZunv8bSJxOqkc\/ed87uL76FDB7teBNThDRB+1J7aITuadbNfH\\n\" +\n-            \"5ZfZykrdZ1qQLKxP6DwHOmJr9u2b4IxjUX9qUMuq4B02ghD2g6yU3YivEosZ7fpo\\n\" +\n-            \"srD2TBN29JpgPGrOrpOE+ArZuIpBjdKFinemu6fTDD0NCeQlfyHXd1NOYyfYRLTa\\n\" +\n-            \"xlpDqr\/2M41BgSkWQfSPHHyRWNQgWBiGsIQaS8TK0g8OWi1ov78+2K9DWT+AHgXW\\n\" +\n-            \"AanjZK91GfygPXJYSlAGxSiBAwH\/KhAMifhaoFYAbH0Yuohmd85B45G2xVsop4TM\\n\" +\n-            \"Dsl007U7qnS7sdJ4jYGzEvva\/a95AgMBAAGjggE5MIIBNTASBgNVHRMBAf8ECDAG\\n\" +\n-            \"AQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHQ4EFgQUYtRCXoZwdWqQvMa40k1g\\n\" +\n-            \"wjS6UTowHwYDVR0jBBgwFoAUhBjMhTTsvAyUlC4IWZzHshBOCggwewYIKwYBBQUH\\n\" +\n-            \"AQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8vb2NzcC5yb290Y2ExLmFtYXpvbnRy\\n\" +\n-            \"dXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDovL2NydC5yb290Y2ExLmFtYXpvbnRy\\n\" +\n-            \"dXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8EODA2MDSgMqAwhi5odHRwOi8vY3Js\\n\" +\n-            \"LnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jvb3RjYTEuY3JsMBEGA1UdIAQKMAgw\\n\" +\n-            \"BgYEVR0gADANBgkqhkiG9w0BAQsFAAOCAQEAMHbSWHRFMzGNIE0qhN6gnRahTrTU\\n\" +\n-            \"CDPwe7l9\/q0IA+QBlrpUHnlAreetYeH1jB8uF3qXXzy22gpBU7NqulTkqSPByT1J\\n\" +\n-            \"xOhpT2FpO5R3VAdMPdWfSEgtrED0jkmyUQrR1T+\/A+nBLdJZeQcl+OqLgeY790JM\\n\" +\n-            \"JJTsJnnI6FBWeTGhcDI4Y+n3KS3QCVePeWI7jx1dhrHcXH+QDX8Ywe31hV7YENdr\\n\" +\n-            \"HDpUXrjK6eHN8gazy8G6pndXHFwHp4auiZbJbYAk\/q1peOTRagD2JojcLkm+i3cD\\n\" +\n-            \"843t4By6YT\/PVlePU2PCWejkrJQnKQAPOov7IA8kuO2RDWuzE\/zF6Hotdg==\\n\" +\n+            \"b24gUm9vdCBDQSAxMB4XDTIyMDgyMzIyMjEyOFoXDTMwMDgyMzIyMjEyOFowPDEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n+            \"QSAyMDQ4IE0wMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOtxLKnL\\n\" +\n+            \"H4gokjIwr4pXD3i3NyWVVYesZ1yX0yLI2qIUZ2t88Gfa4gMqs1YSXca1R\/lnCKeT\\n\" +\n+            \"epWSGA+0+fkQNpp\/L4C2T7oTTsddUx7g3ZYzByDTlrwS5HRQQqEFE3O1T5tEJP4t\\n\" +\n+            \"f+28IoXsNiEzl3UGzicYgtzj2cWCB41eJgEmJmcf2T8TzzK6a614ZPyq\/w4CPAff\\n\" +\n+            \"nAV4coz96nW3AyiE2uhuB4zQUIXvgVSycW7sbWLvj5TDXunEpNCRwC4kkZjK7rol\\n\" +\n+            \"jtT2cbb7W2s4Bkg3R42G3PLqBvt2N32e\/0JOTViCk8\/iccJ4sXqrS1uUN4iB5Nmv\\n\" +\n+            \"JK74csVl+0u0UecCAwEAAaOCAVowggFWMBIGA1UdEwEB\/wQIMAYBAf8CAQAwDgYD\\n\" +\n+            \"VR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNV\\n\" +\n+            \"HQ4EFgQUgbgOY4qJEhjl+js7UJWf5uWQE4UwHwYDVR0jBBgwFoAUhBjMhTTsvAyU\\n\" +\n+            \"lC4IWZzHshBOCggwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8v\\n\" +\n+            \"b2NzcC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDov\\n\" +\n+            \"L2NydC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8E\\n\" +\n+            \"ODA2MDSgMqAwhi5odHRwOi8vY3JsLnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jv\\n\" +\n+            \"b3RjYTEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMA0GCSqGSIb3DQEBCwUAA4IB\\n\" +\n+            \"AQCtAN4CBSMuBjJitGuxlBbkEUDeK\/pZwTXv4KqPK0G50fOHOQAd8j21p0cMBgbG\\n\" +\n+            \"kfMHVwLU7b0XwZCav0h1ogdPMN1KakK1DT0VwA\/+hFvGPJnMV1Kx2G4S1ZaSk0uU\\n\" +\n+            \"5QfoiYIIano01J5k4T2HapKQmmOhS\/iPtuo00wW+IMLeBuKMn3OLn005hcrOGTad\\n\" +\n+            \"hcmeyfhQP7Z+iKHvyoQGi1C0ClymHETx\/chhQGDyYSWqB\/THwnN15AwLQo0E5V9E\\n\" +\n+            \"SJlbe4mBlqeInUsNYugExNf+tOiybcrswBy8OFsd34XOW3rjSUtsuafd9AWySa3h\\n\" +\n+            \"xRRrwszrzX\/WWGm6wyB+f7C4\\n\" +\n@@ -103,4 +133,4 @@\n-    \/\/ Owner: CN=good.sca1a.amazontrust.com\n-    \/\/ Issuer: CN=Amazon, OU=Server CA 1A, O=Amazon, C=US\n-    \/\/ Serial number: 75a5dd4b767bedc94a4239da65ed9dfef8218\n-    \/\/ Valid from: Fri Dec 17 12:21:50 PST 2021 until: Tue Jan 17 12:21:50 PST 2023\n+    \/\/ Owner: CN=valid.rootca1.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon RSA 2048 M02, O=Amazon, C=US\n+    \/\/ Serial number: 60c6e837b2e7586d8464eb34f4a85fe\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n@@ -108,23 +138,33 @@\n-            \"MIIEIDCCAwigAwIBAgITB1pd1LdnvtyUpCOdpl7Z3++CGDANBgkqhkiG9w0BAQsF\\n\" +\n-            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n-            \"ZXIgQ0EgMUExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDIxNTBaFw0yMzAx\\n\" +\n-            \"MTcyMDIxNTBaMCUxIzAhBgNVBAMTGmdvb2Quc2NhMWEuYW1hem9udHJ1c3QuY29t\\n\" +\n-            \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5SadXE1HIzUp4ob40roo\\n\" +\n-            \"qBiJy57vLcZklkWoxRU2JtIauuZUl8fLT\/KOjzW71fqMMTxnvEbtKtRtZKDFjrg7\\n\" +\n-            \"uPf8Q1J9tqxme6iFlrBlou+moQQ7Spi3H9q7v08vX19XIREGIwHbicbxVujdeA0w\\n\" +\n-            \"G0fGMlw+Gs8GNiBQplr+oXC7i2CoPmwnR\/T8iHjCEznKQIMxiZL4gOHLwh4EKdBA\\n\" +\n-            \"auirpTq0iXUtC2BcM\/w1Zx1UTLu0idmclcxVSYE8hXfV8e7JGpNI1gCqkgrskof3\\n\" +\n-            \"A6CMCIH\/D1VETFtGKn+gGWenWwnELmKuvHObQGXmcwOV3aXBdNFTmfzcshwqm\/mE\\n\" +\n-            \"zQIDAQABo4IBJjCCASIwDgYDVR0PAQH\/BAQDAgWgMB0GA1UdDgQWBBTURzXdgGMB\\n\" +\n-            \"tNyiP16WXB1oM2qqmzAfBgNVHSMEGDAWgBRi1EJehnB1apC8xrjSTWDCNLpROjAd\\n\" +\n-            \"BgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYIKwYBBQUHAQEEaTBnMC0G\\n\" +\n-            \"CCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2ExYS5hbWF6b250cnVzdC5jb20wNgYI\\n\" +\n-            \"KwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhMWEuYW1hem9udHJ1c3QuY29tL3NjYTFh\\n\" +\n-            \"LmNlcjAlBgNVHREEHjAcghpnb29kLnNjYTFhLmFtYXpvbnRydXN0LmNvbTATBgNV\\n\" +\n-            \"HSAEDDAKMAgGBmeBDAECATANBgkqhkiG9w0BAQsFAAOCAQEAVNyn7lB3IOstAJj+\\n\" +\n-            \"avkPfojb+QaUpFjnkKyb7c5kUBEWaaEl27W58OLoIHoEJvfOypv2bTq1fuIx9P88\\n\" +\n-            \"1HP7DrI7vBtfnAgyIjF2mzL6Jyt7buR7u\/cXTO0fsl\/uk3wfrJBl860\/Nab+WYoj\\n\" +\n-            \"pvJm0b75WVnU30Khy\/xrhNfN2nvCJ5VMoHqV6KnKrMjA5KpdeTvVaIgyxtV6B8vY\\n\" +\n-            \"VsBbtzJ6n8mN7N8YkEkHV6TG7l+FVPHQdJFtD\/qhTd5C4uu4XUehxOta894hLy6z\\n\" +\n-            \"8Mv9BGtmwyUIEd0KQQdkXrWx\/iAq6zo0imAeN\/s8tjqAzxnw6M5F9cDqjqkYqgXZ\\n\" +\n-            \"eIkPBA==\\n\" +\n+            \"MIIGKDCCBRCgAwIBAgIQBgxug3sudYbYRk6zT0qF\/jANBgkqhkiG9w0BAQsFADA8\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n+            \"UlNBIDIwNDggTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLTEr\\n\" +\n+            \"MCkGA1UEAxMidmFsaWQucm9vdGNhMS5kZW1vLmFtYXpvbnRydXN0LmNvbTCCASIw\\n\" +\n+            \"DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL3hA+omhUcO8nYO8\/+dkpbYz8WI\\n\" +\n+            \"1ms7Y7JA2pPFfp2N\/aWcf6m5ORm1BkyGLOttjTu318Qpa9eahQ1Pi3RNe3BtqjD9\\n\" +\n+            \"jcHncpwAFMsXy1beZA7sZ7AA4vKltA3t6yrU5ruTLUGQwUndeIBBSTW5QpdT9I\/p\\n\" +\n+            \"EM7d+Miwre63kofbJ1lVPAJvN\/udMVqGWNF8V5qscklUUHoSKA3FWWsiCyIgnthg\\n\" +\n+            \"G3u6R1KH66Qionp0ho\/ttvrBCI0C\/bdrdH+wybFv8oFFvAW2U9xn2Azt47\/2kHHm\\n\" +\n+            \"tTRjrgufhDbcz\/MLR6hwBXAJuwVvJZmSqe7B4IILFexu6wjxZfyqVm2FMr8CAwEA\\n\" +\n+            \"AaOCAzMwggMvMB8GA1UdIwQYMBaAFMAxUs1aUMOCfHRxzsvpnPl664LiMB0GA1Ud\\n\" +\n+            \"DgQWBBSkrnsTnjwYhDRAeLy\/9FXm\/7hApDBlBgNVHREEXjBcgiJ2YWxpZC5yb290\\n\" +\n+            \"Y2ExLmRlbW8uYW1hem9udHJ1c3QuY29tghpnb29kLnNjYTBhLmFtYXpvbnRydXN0\\n\" +\n+            \"LmNvbYIaZ29vZC5zY2ExYS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWg\\n\" +\n+            \"MB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAs\\n\" +\n+            \"hipodHRwOi8vY3JsLnIybTAyLmFtYXpvbnRydXN0LmNvbS9yMm0wMi5jcmwwEwYD\\n\" +\n+            \"VR0gBAwwCjAIBgZngQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFo\\n\" +\n+            \"dHRwOi8vb2NzcC5yMm0wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0\\n\" +\n+            \"dHA6Ly9jcnQucjJtMDIuYW1hem9udHJ1c3QuY29tL3IybTAyLmNlcjAMBgNVHRMB\\n\" +\n+            \"Af8EAjAAMIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdgDuzdBk1dsazsVct520\\n\" +\n+            \"zROiModGfLzs3sNRSFlGcR+1mwAAAYgHvXWVAAAEAwBHMEUCICAs74qT1f9ufSr5\\n\" +\n+            \"PgQqtQFiXBbmbb3i4xwVV78USU5NAiEA\/iJEfnTG+hZZaHYv2wVbg6tUY8fQgIhI\\n\" +\n+            \"2rbl6PrD9FIAdgBIsONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgH\\n\" +\n+            \"vXWWAAAEAwBHMEUCIQDf2nWyee\/5+vSgk\/O8P0BFvXYu89cyAugZHyd919BdAgIg\\n\" +\n+            \"UnGGpQtZmWnPMmdgpzI7jrCLuC370Tn0i7Aktdzj2X8AdgDatr9rP7W2Ip+bwrtc\\n\" +\n+            \"a+hwkXFsu1GEhTS9pD0wSNf7qwAAAYgHvXVpAAAEAwBHMEUCIGN6cT+6uwDospXe\\n\" +\n+            \"gMa8b38oXouXUT66X2gOiJ0SoRyQAiEAjDMu2vEll5tRpUvU8cD4gR2xV4hqoDxx\\n\" +\n+            \"Q+QGW+PvJxcwDQYJKoZIhvcNAQELBQADggEBACtxC3LlQvULeI3lt7ZYFSWndEhm\\n\" +\n+            \"tNUotoeKSXJXdoIpqSr10bzMPX9SHvemgOUtzP3JNqWPHw1uW9YFyeDE6yWj\/B13\\n\" +\n+            \"Xj1hv1cqYIwyaOZBerU\/9PT5PaCn20AC9DHbc7iBv+zs+DYiqlAFJ1GVaprwLul4\\n\" +\n+            \"8wp3gnC3Hjb8NykydCo6vw0AJ2UzjpjiTyVZ93jITzLOiboOUa1gQGnojzWlYaet\\n\" +\n+            \"sXe+RDylBp\/Wuj1ZS7v\/etltzYm5GanPi4y\/p7Ta3Uky6std\/GM6XbPRdBEFboFR\\n\" +\n+            \"B2IP0divd9c74Q+tLgpsAz5yXm9LtYPMcEPC2YRN2PgBg67c5+A7eIOluuw=\\n\" +\n@@ -133,4 +173,4 @@\n-    \/\/ Owner: CN=revoked.sca1a.amazontrust.com\n-    \/\/ Issuer: CN=Amazon, OU=Server CA 1A, O=Amazon, C=US\n-    \/\/ Serial number: 75a5de4434092b2cd6ed81eb5e6248e1e5f2a\n-    \/\/ Valid from: Fri Dec 17 12:25:17 PST 2021 until: Tue Jan 17 12:25:17 PST 2023\n+    \/\/ Owner: CN=revoked.rootca1.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon RSA 2048 M01, O=Amazon, C=US\n+    \/\/ Serial number: e1023665b1268d788cc25bf69a9d05e\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n@@ -138,23 +178,34 @@\n-            \"MIIEJjCCAw6gAwIBAgITB1pd5ENAkrLNbtgeteYkjh5fKjANBgkqhkiG9w0BAQsF\\n\" +\n-            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n-            \"ZXIgQ0EgMUExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDI1MTdaFw0yMzAx\\n\" +\n-            \"MTcyMDI1MTdaMCgxJjAkBgNVBAMTHXJldm9rZWQuc2NhMWEuYW1hem9udHJ1c3Qu\\n\" +\n-            \"Y29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqYk4ZkF9yJgRa0fL\\n\" +\n-            \"96gmxwlJlyvsQmqumxUGw0u1L+nDgGMFD1bHILOw2AO+feNy8kuTnJVb+zN+2f6l\\n\" +\n-            \"rMGM1sGKh8W\/ZRIdvmcdeZ2kEDyxLotMRXDQ6hJXDj30DSAYNkdqairJItdcev8+\\n\" +\n-            \"t9LRRNRQwL0sXf5FITQPBnlVCrF9Q42p9hhYUhvsS8jSWPIvUbZajOXKs6AfxyPV\\n\" +\n-            \"2Q7TybgnRlawznXxflPzXRMpCSQZ9WdI\/kYbFOjDNtYA05EI4d8IYm+C5U1eJT30\\n\" +\n-            \"dKFeU0xzFsrPirzifFMPIhXKxS5rUELuFRUq4sFTN28Sj7Ij\/rr+O9Im8jJZq0lo\\n\" +\n-            \"bqLoQwIDAQABo4IBKTCCASUwDgYDVR0PAQH\/BAQDAgWgMB0GA1UdDgQWBBRugPQP\\n\" +\n-            \"CWEwQp0pw2dEMw\/gT7F4gzAfBgNVHSMEGDAWgBRi1EJehnB1apC8xrjSTWDCNLpR\\n\" +\n-            \"OjAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYIKwYBBQUHAQEEaTBn\\n\" +\n-            \"MC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2ExYS5hbWF6b250cnVzdC5jb20w\\n\" +\n-            \"NgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhMWEuYW1hem9udHJ1c3QuY29tL3Nj\\n\" +\n-            \"YTFhLmNlcjAoBgNVHREEITAfgh1yZXZva2VkLnNjYTFhLmFtYXpvbnRydXN0LmNv\\n\" +\n-            \"bTATBgNVHSAEDDAKMAgGBmeBDAECATANBgkqhkiG9w0BAQsFAAOCAQEAQF9QvedW\\n\" +\n-            \"gqD5LPsZ5cg+DkGFBVqhWgsvp8so4gmKHklSHvisEek\/Yfi7tvHCUAP2P0MuV\/49\\n\" +\n-            \"O2A+1tXQL1+hVM1auSfDOQdUy4xsKSWV+PofQe82iz+6dwRf+HNgOtyNcQ6aGD3t\\n\" +\n-            \"87DXnJPkBTEPHGxDkjnOwurSffaV1m00bxfb6T1Txvyjs9ClnZf68Jv6oj+2rbs1\\n\" +\n-            \"+TqKXP0Ma3AgXB37Cq2ozYzpAxy9GBIKIahGX2d2qsuZ2aj6XwJwUayIuU0WTOHK\\n\" +\n-            \"eeXvKS2uvY9UaIvTeepSWXyAbBMKagQhgAtf3X6ILodQi5Gk7lCuY48oArKziTgN\\n\" +\n-            \"vB7mK7JqaM2P4g==\\n\" +\n+            \"MIIGMjCCBRqgAwIBAgIQDhAjZlsSaNeIzCW\/aanQXjANBgkqhkiG9w0BAQsFADA8\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n+            \"UlNBIDIwNDggTTAxMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLzEt\\n\" +\n+            \"MCsGA1UEAxMkcmV2b2tlZC5yb290Y2ExLmRlbW8uYW1hem9udHJ1c3QuY29tMIIB\\n\" +\n+            \"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxSPd1PWACxZohFCAJT1JWuXK\\n\" +\n+            \"GY29wZZ9yY0zoiq6+qYiUIU0crktytUNNI1ZpW\/3qXpEw2ZQkM6WF1LshXtwGwrA\\n\" +\n+            \"zJwSeX1L9T5rOKhoBvoFeqfX7xu4VBM1\/fDGt5X+NRFfD9Op9UfK5OsnL05TYach\\n\" +\n+            \"rdnfOA5wKGvMgFiN5CeOD0AtumXSuAnTZC85ojJTHjPF+hqV893WvrrUxLyyxtvh\\n\" +\n+            \"lq\/WttFOjhfQu2IkfyDAFiH939uzUi0WSTAdsbsHuko5mDTDnOfMRbaaWZu0At01\\n\" +\n+            \"EgaIPeK+kGdi7EYwVndIwTKLeQ4mjIM8aj8Heg\/y2hZ0kOmfCUZdUmJFlNoCIQID\\n\" +\n+            \"AQABo4IDOzCCAzcwHwYDVR0jBBgwFoAUgbgOY4qJEhjl+js7UJWf5uWQE4UwHQYD\\n\" +\n+            \"VR0OBBYEFMeBhIOkuWUY4DYqFrfgbD2eUeFtMG0GA1UdEQRmMGSCJHJldm9rZWQu\\n\" +\n+            \"cm9vdGNhMS5kZW1vLmFtYXpvbnRydXN0LmNvbYIdcmV2b2tlZC5zY2EwYS5hbWF6\\n\" +\n+            \"b250cnVzdC5jb22CHXJldm9rZWQuc2NhMWEuYW1hem9udHJ1c3QuY29tMA4GA1Ud\\n\" +\n+            \"DwEB\/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0f\\n\" +\n+            \"BDQwMjAwoC6gLIYqaHR0cDovL2NybC5yMm0wMS5hbWF6b250cnVzdC5jb20vcjJt\\n\" +\n+            \"MDEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggr\\n\" +\n+            \"BgEFBQcwAYYhaHR0cDovL29jc3AucjJtMDEuYW1hem9udHJ1c3QuY29tMDYGCCsG\\n\" +\n+            \"AQUFBzAChipodHRwOi8vY3J0LnIybTAxLmFtYXpvbnRydXN0LmNvbS9yMm0wMS5j\\n\" +\n+            \"ZXIwDAYDVR0TAQH\/BAIwADCCAX4GCisGAQQB1nkCBAIEggFuBIIBagFoAHYA7s3Q\\n\" +\n+            \"ZNXbGs7FXLedtM0TojKHRny87N7DUUhZRnEftZsAAAGIB72TggAABAMARzBFAiAZ\\n\" +\n+            \"naLbRHRuaRrE304GSuWX\/79MU\/e+SSlr0cNJ0kNNaAIhAPnz9HayL4txhkTEZiMs\\n\" +\n+            \"nttNnNqD17I0J17JLVOF4i\/4AHYASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/\\n\" +\n+            \"qznYhHMAAAGIB72TmwAABAMARzBFAiEAgEqT7CYGQ\/u36\/3YcxBH78QfknI9kgcY\\n\" +\n+            \"sgJLkurUF6cCIFZZ\/b803+ek6o+bmdV\/uVx2UlskAyyolZ2okBAb6IscAHYA2ra\/\\n\" +\n+            \"az+1tiKfm8K7XGvocJFxbLtRhIU0vaQ9MEjX+6sAAAGIB72TbQAABAMARzBFAiEA\\n\" +\n+            \"6z2RSoK263hvYF71rj1d0TpC70\/6zagSRR4glHOT6IACICYvaMAnrCNSTSiZ20Wz\\n\" +\n+            \"Ju5roTippO3BWKhQYrTKZuu4MA0GCSqGSIb3DQEBCwUAA4IBAQB4S1JGulFpMIaP\\n\" +\n+            \"NtLUJmjWz8eexQdWLDVF+H8dd6xpZgpiYtig\/Ynphzuk1IIF8DkT3CeK\/9vrezgI\\n\" +\n+            \"igNjneN9B4eIuzi\/rJzIKeUwpZ2k5D+36Ab4esseoc+TopmNerw8hidt2g818jER\\n\" +\n+            \"D71ppSMakeQFPGe\/Hs2\/cVa\/G1DNVcU2XAut45yRZ\/+xsZ0\/mcBDVsG9P5uGCN5O\\n\" +\n+            \"7SAp4J959WnKDqgVuU9WowPE5IjmS9BAv2gjniFYdDV2yksyf7+8edHd1KfSVX06\\n\" +\n+            \"pLx6CuCVZGJFG4Q2Aa1YAh1Wvt9hqWeXXpNRO2\/wChL5rhT4GajsrGepsk4bjxYX\\n\" +\n+            \"Wf2iZ8mX\\n\" +\n@@ -163,8 +214,1 @@\n-    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n-        \/\/ EE certificates don't have CRLDP extension\n-        if (!ocspEnabled){\n-            pathValidator.validate(new String[]{INT},\n-                    ValidatePathWithParams.Status.GOOD, null, System.out);\n-\n-            return;\n-        }\n+    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n@@ -173,1 +217,1 @@\n-        pathValidator.validate(new String[]{VALID, INT},\n+        pathValidator.validate(new String[]{VALID, INT_VALID},\n@@ -177,1 +221,1 @@\n-        pathValidator.validate(new String[]{REVOKED, INT},\n+        pathValidator.validate(new String[]{REVOKED, INT_REVOKED},\n@@ -179,1 +223,1 @@\n-                \"Fri Dec 17 12:28:05 PST 2021\", System.out);\n+                \"Mon May 15 13:36:57 PDT 2023\", System.out);\n@@ -185,1 +229,1 @@\n-    \/\/ Owner: CN=Amazon, OU=Server CA 2A, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n@@ -187,2 +231,2 @@\n-    \/\/ Serial number: 67f945755f187a91f8163f3e624620177ff38\n-    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n+    \/\/ Serial number: 773125b0c34c3c940299a9f04a39e5a52ccd9\n+    \/\/ Valid from: Tue Aug 23 15:29:13 PDT 2022 until: Fri Aug 23 15:29:13 PDT 2030\n@@ -190,1 +234,1 @@\n-            \"MIIGRzCCBC+gAwIBAgITBn+UV1Xxh6kfgWPz5iRiAXf\/ODANBgkqhkiG9w0BAQwF\\n\" +\n+            \"MIIGXjCCBEagAwIBAgITB3MSWww0w8lAKZqfBKOeWlLM2TANBgkqhkiG9w0BAQwF\\n\" +\n@@ -192,32 +236,33 @@\n-            \"b24gUm9vdCBDQSAyMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENB\\n\" +\n-            \"IDJBMQ8wDQYDVQQDEwZBbWF6b24wggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK\\n\" +\n-            \"AoICAQC0P8hSLewmrZ41CCPBQytZs5NBFMq5ztbnMf+kZUp9S25LPfjNW3zgC\/6E\\n\" +\n-            \"qCTWNVMMHhq7ez9IQJk48qbfBTLlZkuKnUWbA9vowrDfcxUN0mRE4B\/TJbveXyTf\\n\" +\n-            \"vE91iDlqDrERecE9D8sdjzURrtHTp27lZdRkXFvfEVCq4hl3sHkzjodisaQthLp1\\n\" +\n-            \"gLsiA7vKt+8zcL4Aeq52UyYb8r4\/jdZ3KaQp8O\/T4VwDCRKm8ey3kttpJWaflci7\\n\" +\n-            \"eRzNjY7gE3NMANVXCeQwOBfH2GjINFCObmPsqiBuoAnsv2k5aQLNoU1OZk08ClXm\\n\" +\n-            \"mEZ2rI5qZUTX1HuefBJnpMkPugFCw8afaHnB13SkLE7wxX8SZRdDIe5WiwyDL1tR\\n\" +\n-            \"2+8lpz4JsMoFopHmD3GaHyjbN+hkOqHgLltwewOsiyM0u3CZphypN2KeD+1FLjnY\\n\" +\n-            \"TgdIAd1FRgK2ZXDDrEdjnsSEfShKf0l4mFPSBs9E3U6sLmubDRXKLLLpa\/dF4eKu\\n\" +\n-            \"LEKS1bXYT28iM6D5gSCnzho5G4d18jQD\/slmc5XmRo5Pig0RyBwDaLuxeIZuiJ0A\\n\" +\n-            \"J6YFhffbrLYF5dEQl0cU+t3VBK5u\/o1WkWXsZawU038lWn\/AXerodT\/pAcrtWA4E\\n\" +\n-            \"NQEN09WEKMhZVPhqdwhF\/Gusr04mQtKt7T2v6UMQvtVglv5E7wIDAQABo4IBOTCC\\n\" +\n-            \"ATUwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYE\\n\" +\n-            \"FNpDStD8AcBLv1gnjHbNCoHzlC70MB8GA1UdIwQYMBaAFLAM8Eww9AVYAkj9M+VS\\n\" +\n-            \"r0uE42ZSMHsGCCsGAQUFBwEBBG8wbTAvBggrBgEFBQcwAYYjaHR0cDovL29jc3Au\\n\" +\n-            \"cm9vdGNhMi5hbWF6b250cnVzdC5jb20wOgYIKwYBBQUHMAKGLmh0dHA6Ly9jcnQu\\n\" +\n-            \"cm9vdGNhMi5hbWF6b250cnVzdC5jb20vcm9vdGNhMi5jZXIwPwYDVR0fBDgwNjA0\\n\" +\n-            \"oDKgMIYuaHR0cDovL2NybC5yb290Y2EyLmFtYXpvbnRydXN0LmNvbS9yb290Y2Ey\\n\" +\n-            \"LmNybDARBgNVHSAECjAIMAYGBFUdIAAwDQYJKoZIhvcNAQEMBQADggIBAEO5W+iF\\n\" +\n-            \"yChjDyyrmiwFupVWQ0Xy2ReFNQiZq7XKVHvsLQe01moSLnxcBxioOPBKt1KkZO7w\\n\" +\n-            \"Gcbmke0+7AxLaG\/F5NPnzRtK1\/pRhXQ0XdU8pVh\/1\/h4GoqRlZ\/eN0JDarUhZPkV\\n\" +\n-            \"kSr96LUYDTxcsAidF7zkzWfmtcJg\/Aw8mi14xKVEa6aVyKu54c8kKkdlt0WaigOv\\n\" +\n-            \"Z\/xYhxp24AfoFKaIraDNdsD8q2N7eDYeN4WGLzNSlil+iFjzflI9mq1hTuI\/ZNjV\\n\" +\n-            \"rbvob6FUQ8Cc524gMjbpZCNuZ1gfXzwwhGp0AnQF6CJsWF9uwPpZEVFnnnfiWH3M\\n\" +\n-            \"oup41EvBhqaAqOlny0sm5pI82nRUCAE3DLkJ1+eAtdQaYblZQkQrRyTuPmJEm+5y\\n\" +\n-            \"QwdDVw6uHc5OsSj\/tyhh8zJ2Xq3zgh3dMONGjJEysxGaCoIb+61PWwMy2dIarVwI\\n\" +\n-            \"r+c+AY+3PrhgBspNdWZ87JzNHii7ksdjUSVGTTy1vGXgPYrv0lp0IMnKaZP58xiw\\n\" +\n-            \"rDx7uTlQuPVWNOZvCaT3ZcoxTsNKNscIUe+WJjWx5hdzpv\/oksDPY5ltZ0j3hlDS\\n\" +\n-            \"D+Itk95\/cNJVRM\/0HpxI1SX9MTZtOSJoEDdUtOpVaOuBAvEK4gvTzdt0r5L+fuI6\\n\" +\n-            \"o5LAuRo\/LO1xVRH49KFRoaznzU3Ch9+kbPb3\\n\" +\n+            \"b24gUm9vdCBDQSAyMB4XDTIyMDgyMzIyMjkxM1oXDTMwMDgyMzIyMjkxM1owPDEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n+            \"QSA0MDk2IE0wMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMGMl\/pZ\\n\" +\n+            \"1OsxHY9gw\/YfdON4mmrANkPwi7z2djHA5ELt\/vRI3Su0le6OoipLf03iyoCnYy4Y\\n\" +\n+            \"rpfTbhyDriE8NJpps2ODJ5W1h0rz6FM1Q5Jt35wfk+4CEfATBTegHVlUJ0rJgzK5\\n\" +\n+            \"Yl\/jrk12ZsC4ZeRn54shszcK6bHj4LZIHXhrYIIfetBMMD8V7hlhd54AclEWutUV\\n\" +\n+            \"eBEjkSCzDSk+pQKIjCL0crqvRSPvUNry\/BV65zfGmceSYxpcLmV7k7Spwpo+1z8w\\n\" +\n+            \"+Odfnx2vsm7olPldfaThqk6fXBtInORl4Ef32xF3VDT13UeXtQPolFhnp8UOci64\\n\" +\n+            \"bW+R8tbtGpUXIA8Dhr8SgYPH6NW4jhUD4+AG8yer8ctA1Hl9tq+6tYr26q3yuCLu\\n\" +\n+            \"5rwJdfMG634fWIRXSj+GJi8SfAdGtPyXwu5799NWesV4vUkrkSXdIBK4TQCuK+jx\\n\" +\n+            \"aJ5Y+Zo2l3GFsWyMPNORLjoQXbjF6KAyjTyICLq9VzoQKhyx4Ll2CNrQv8CxqtDC\\n\" +\n+            \"GvXi9kREJYAF6lscOB0xglAAF5lndcaNkVHEVOMdg9ZZtdJywHWm8Qed1Wty2qr+\\n\" +\n+            \"hmA7booWQNRE12nW1niC5D4cP2ykPK9HSgb7xWdUF32VidUc9tNKM6xKjSd\/R\/tP\\n\" +\n+            \"p+XAybNSwEooPt3\/OvyhpVRjLuWoqqbClTKdAgMBAAGjggFaMIIBVjASBgNVHRMB\\n\" +\n+            \"Af8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcD\\n\" +\n+            \"AQYIKwYBBQUHAwIwHQYDVR0OBBYEFJ5xHxodk6nZLY7MSFM\/A1TznuZmMB8GA1Ud\\n\" +\n+            \"IwQYMBaAFLAM8Eww9AVYAkj9M+VSr0uE42ZSMHsGCCsGAQUFBwEBBG8wbTAvBggr\\n\" +\n+            \"BgEFBQcwAYYjaHR0cDovL29jc3Aucm9vdGNhMi5hbWF6b250cnVzdC5jb20wOgYI\\n\" +\n+            \"KwYBBQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhMi5hbWF6b250cnVzdC5jb20vcm9v\\n\" +\n+            \"dGNhMi5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2EyLmFt\\n\" +\n+            \"YXpvbnRydXN0LmNvbS9yb290Y2EyLmNybDATBgNVHSAEDDAKMAgGBmeBDAECATAN\\n\" +\n+            \"BgkqhkiG9w0BAQwFAAOCAgEAl1GgKXOn0j1MWT1KJVSewQ28SGbie3UwZj1dMsjJ\\n\" +\n+            \"amCrQPn2ngSNbLm9+ulFiBDU8xKR9Zx3tZps55IUKWLUPkfMC+vkV7asDBqqzzE0\\n\" +\n+            \"F\/MkekgPfOjx1V9S6Wfg3sSg+9KcluurXFElruqKfOm4cqmkV776X1G+AaaQ7mlU\\n\" +\n+            \"giCYi6NqRQSyhn8zrKkNnbO6QL5a9ICC47kiZYRAR\/hRvZOt11QUK5tCMXJXo0iO\\n\" +\n+            \"4XKkMu+jdnehP1kh4xuZhYznIgKK6MJIITFI\/Jj89U4SOPncyuS94sUuE2EqvvO\/\\n\" +\n+            \"t81qeoey6wThz5iRbU\/0CvDFnTMgebWGUZ2UZJ+az\/rb3KYXGfVWasLIonkvYT7z\\n\" +\n+            \"vHOGNAA9oQ8TTgPOmPfSVyfpplKtO\/aybWp5QSH2csIwuvw5dkmpkc42iD57XHob\\n\" +\n+            \"5LbMJg99z3vQBmod\/ipmOpND95\/BeA2mllBZgZ53S0nvDXDzbzR9Fd81PAz9Qruo\\n\" +\n+            \"dOJKcD6plKQjZjkLzNh1v\/RoCFO8kiJGE4UBMTM8FUk0DXH4bALII4wwmDelrSUu\\n\" +\n+            \"lKvDTDxZvPF4dbEXICNPd51EMGPgETxwboOV+bzWFVI0IWQ8PhZ2VuMPDk2taOMp\\n\" +\n+            \"NsuLtlYc2twPb9r\/Hvgv7G6+ItpBHZwOVt1oI3pHbjMp7P3pOZSPr6G1WkNy9mX8\\n\" +\n+            \"rVc=\\n\" +\n@@ -226,4 +271,4 @@\n-    \/\/ Owner: CN=good.sca2a.amazontrust.com\n-    \/\/ Issuer: CN=Amazon, OU=Server CA 2A, O=Amazon, C=US\n-    \/\/ Serial number: 75a5dd7d82269ed466af69794f34050bdffa2\n-    \/\/ Valid from: Fri Dec 17 12:22:32 PST 2021 until: Tue Jan 17 12:22:32 PST 2023\n+    \/\/ Owner: CN=valid.rootca2.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n+    \/\/ Serial number: 662f7646d76193cbb76946d111e49fa\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n@@ -231,33 +276,43 @@\n-            \"MIIGIDCCBAigAwIBAgITB1pd19giae1GavaXlPNAUL3\/ojANBgkqhkiG9w0BAQwF\\n\" +\n-            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n-            \"ZXIgQ0EgMkExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDIyMzJaFw0yMzAx\\n\" +\n-            \"MTcyMDIyMzJaMCUxIzAhBgNVBAMTGmdvb2Quc2NhMmEuYW1hem9udHJ1c3QuY29t\\n\" +\n-            \"MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAsCQonlc6fSTDJbH2y6wC\\n\" +\n-            \"mLeTD3noluSM4LPO53RgLTUvNqrxh\/iy9jDGgYP2xN8GGngRI8C65jZqGpJb0Hcp\\n\" +\n-            \"ADYssYKWcTR5OH8rUVsJ6DkJLx0AUOG+iJcCaqPudkw7WBReFEok7E058gCTbXps\\n\" +\n-            \"kNRT3w92CzzXa+49yxaAP0I6AQ9BqZP6gbAR1hmd9BDMCdak1JIswGVC3wGAKJFi\\n\" +\n-            \"c3FS3YeY7VyuXofeEwutvMH4Iag9DZU2puqskrGSmtrVju8CY6w1E\/cmBWD9kfpu\\n\" +\n-            \"Qet2LBZuzmws8XhCjU5cHOeA8pg2m7ZnyNBeZajg4hrbPq8ACjjDmEHiDgazoOGN\\n\" +\n-            \"1mV1BXZ2qonK+zJAMqE\/L0czEPjdROaF786pPY5Cpi1Rzk0R3KKjGhSHgzfCa2eX\\n\" +\n-            \"cQjBtA7AxLkK+1cI18hYg+okaV+EBrkxXGzeyTjvWbliotIQ9utabXGqJvJtIDeX\\n\" +\n-            \"OQSdSXlBKgwGTE5\/Ju8\/6NkJgSMEku\/Q9SYvfkzPXrj5VAHgPz4KhholeC4A4hRd\\n\" +\n-            \"Y3Xtr\/U5Xr3fTzLdOcLDKYW4\/OGCl8byjwx8bqO7q8YmgDg572Go3gUbNmlm2QN+\\n\" +\n-            \"NaXhBhPrl4KoHzawApTcod3adhSQziIMGjKYoKhV+ZGNoaLe7IUX0jyX3zygRS6k\\n\" +\n-            \"n6yeyeh1unDfqSvne9+hDEsCAwEAAaOCASYwggEiMA4GA1UdDwEB\/wQEAwIFoDAd\\n\" +\n-            \"BgNVHQ4EFgQU71fB1r7\/l2pFd0ydSNEiGaD+9uIwHwYDVR0jBBgwFoAU2kNK0PwB\\n\" +\n-            \"wEu\/WCeMds0KgfOULvQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMHUG\\n\" +\n-            \"CCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDovL29jc3Auc2NhMmEuYW1h\\n\" +\n-            \"em9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8vY3J0LnNjYTJhLmFtYXpv\\n\" +\n-            \"bnRydXN0LmNvbS9zY2EyYS5jZXIwJQYDVR0RBB4wHIIaZ29vZC5zY2EyYS5hbWF6\\n\" +\n-            \"b250cnVzdC5jb20wEwYDVR0gBAwwCjAIBgZngQwBAgEwDQYJKoZIhvcNAQEMBQAD\\n\" +\n-            \"ggIBAKULtBRmu4CtBTfBG6hXkBdFGneJlomw02h8dj7xkXof+DoLYtkuJ6XRp89f\\n\" +\n-            \"9UgYJMBjwKaAFjZzcVYvTd8YKdXzCXy4phxuHTfaV6ZH0WyvOlcTXsfdhJA4oD1G\\n\" +\n-            \"prB4\/PaymwSbv8ZQAE3eg1hytLLlR9+YUS0HfpwaH\/PIa0TzKG8Vuu5zKGSlJjeh\\n\" +\n-            \"Thp\/uMBC4twM558Jv2sxoUA5HjgPUyZW7r2eLFbOM1H4oR1US5zFYgzrEK1W12DO\\n\" +\n-            \"t65mI2YHbDepm5FoizwWYe4uaDCqWjCgzQw8pMGoiDABMaoNQ83Zi8r2sLGibAlb\\n\" +\n-            \"cVLcjsORsF6TNmYTW1KDT\/9hXlOaAhFwfAwKg6cZw51WEg51sPdi5USk\/oszavc5\\n\" +\n-            \"Ft\/IZaWSfkA1Xm0EyFwOwCOvGJIb9PWv5PfGZz4xnZlWhp6LfN31e3TagTUbzLVX\\n\" +\n-            \"XwbDI1cofCl18z6pidXXCASBCAajQ8N4GxNP6qqX9ou0yOBEXxwVqIJLcu3tueCI\\n\" +\n-            \"3Cb3rWfbybAVhuuP2ERKHJMY8XDCt0O\/g8Kj6O69NABOWvNkU3ARzszGzgBfv4IR\\n\" +\n-            \"jJJEskjxX7Q085iXlaRX\/mu+TpTkqK1ZbpBB1Z2PeVMujP+qsWSWGTZBXuI8eqyU\\n\" +\n-            \"dhq+VlyoVtWeMqKYMtakCJxnhwMZnn0sTzZk\/Yno+k9Jn0Rk\\n\" +\n+            \"MIIICzCCBfOgAwIBAgIQBmL3ZG12GTy7dpRtER5J+jANBgkqhkiG9w0BAQwFADA8\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n+            \"UlNBIDQwOTYgTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLTEr\\n\" +\n+            \"MCkGA1UEAxMidmFsaWQucm9vdGNhMi5kZW1vLmFtYXpvbnRydXN0LmNvbTCCAiIw\\n\" +\n+            \"DQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAON5EbEKoBiujI7Ja8mLZLJbaY7f\\n\" +\n+            \"RtoWIjU\/F0l9ueWFogXmEaA1jWsl97F3WTHTyGKz6ChCjPMSyoXXpY+yoE90QUyX\\n\" +\n+            \"w35uWEhNrc40drMJkyN+QXitSrH346GCOKvpYVvu18UD4W8hDhg8vvbOQYhtmSf7\\n\" +\n+            \"Rfrs7\/qUdXpzpvR9VjWktbQAzJT8fB\/jFNjNQJTknynjGiYO5GF51+peOCLK6qw8\\n\" +\n+            \"9kKYEigR4K8\/aWL283rC4xRxZqVioy433VG02l\/Fwdv8o\/vL9YYIqkyspCB9fpFw\\n\" +\n+            \"Q50yYrwEomxuOz7rXhmdfeNaFYuyTtOUSKff6p2oqO0S7pcLujUVMlO4dYBDELQF\\n\" +\n+            \"cabByNjwblviCtGKJMIzD6Thkgamp3iXQgcU498+P5r7N5CYbMmkJEdcuILg+bgJ\\n\" +\n+            \"\/LUUTT+IMt2txYlO\/ld3N0EHlgVt7rztW5mtm6Ba8jN7cLSh7ZWu6Fr1+oK7bl5T\\n\" +\n+            \"wPxSfqT5W3BwQKS3YptIoKEWUb+VNnS\/dYx\/7IspF9+z6kw4g+V2EY9M4ZYNakzM\\n\" +\n+            \"AI7KIj4thMFoWeYrJq0dUMZ297QCBPRdAwh9hhkq2LYi2x8tMUtcBnhb\/q75sO+E\\n\" +\n+            \"icPqFVv7iMDZ\/8Xep+0UoClF3JGmZW3UNtwcbi7Pn\/OqtaMi7E8xnHUgc4ZchtXO\\n\" +\n+            \"v8VtVvDeZAlY5TjVAgMBAAGjggMWMIIDEjAfBgNVHSMEGDAWgBSecR8aHZOp2S2O\\n\" +\n+            \"zEhTPwNU857mZjAdBgNVHQ4EFgQUnGekBRKIZBYgCEajbpCMC24bp2owSQYDVR0R\\n\" +\n+            \"BEIwQIIidmFsaWQucm9vdGNhMi5kZW1vLmFtYXpvbnRydXN0LmNvbYIaZ29vZC5z\\n\" +\n+            \"Y2EyYS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWgMB0GA1UdJQQWMBQG\\n\" +\n+            \"CCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAshipodHRwOi8vY3Js\\n\" +\n+            \"LnI0bTAyLmFtYXpvbnRydXN0LmNvbS9yNG0wMi5jcmwwEwYDVR0gBAwwCjAIBgZn\\n\" +\n+            \"gQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5y\\n\" +\n+            \"NG0wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQucjRt\\n\" +\n+            \"MDIuYW1hem9udHJ1c3QuY29tL3I0bTAyLmNlcjAMBgNVHRMBAf8EAjAAMIIBfQYK\\n\" +\n+            \"KwYBBAHWeQIEAgSCAW0EggFpAWcAdgDuzdBk1dsazsVct520zROiModGfLzs3sNR\\n\" +\n+            \"SFlGcR+1mwAAAYgHvX9QAAAEAwBHMEUCIQD8qPPCLL2Grd+\/YNALWqAq7LC7YBaa\\n\" +\n+            \"dNg5+6Q4kRDEqgIgEkf\/UMsMNfTRaOZvoOgAK9\/F0xX\/CfdcUTjULhmoA+cAdQBI\\n\" +\n+            \"sONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgHvX8UAAAEAwBGMEQC\\n\" +\n+            \"IBVFDtapMMWJOqyu8Cv6XEhFmbU8N33c2owed\/\/pa80xAiAT9T6Wba3B9DFUmrL5\\n\" +\n+            \"cCGKLqciIEUPhPbvjCuUepelrAB2ANq2v2s\/tbYin5vCu1xr6HCRcWy7UYSFNL2k\\n\" +\n+            \"PTBI1\/urAAABiAe9ft8AAAQDAEcwRQIhAP2XDC\/RlmVtH4WrfSwVosR\/f\/WXRhG5\\n\" +\n+            \"mk9Nwq+ZOIriAiAopPXSH7VwXa3bEAIiTwcV1l10QIDZaIPCU5olknU5CjANBgkq\\n\" +\n+            \"hkiG9w0BAQwFAAOCAgEAFuwMIJdP5rgz6cqOIj2EgF2OU8CUGi\/wJ45BomXWv4Rv\\n\" +\n+            \"U5mOKB+jHOGZZC9dncjAMa44RwoF2I7\/8Y3qLVaoNm46ObvvS+6UvzTcyQqXM7JU\\n\" +\n+            \"cSmdlf9DkspjKPDvMBokVrM4ak5AoxUjuru5qaia3nvbxq7XKO9\/FGUaUaU8Xlsd\\n\" +\n+            \"V6Fo8VmNwFc88VCqOp8eI\/IicHxMDLl8TKXMvr3CYh8A9nCeFGcV+4CL+7JF2t5K\\n\" +\n+            \"YvV5r074Wyk0QMlRVYMNDl0t+VAEoDJ7RRE+kEvplWcsX9S2wvr4HhkA4iChpwFm\\n\" +\n+            \"2UDTppHskSWyLsuNQvipn0zTzZ8RIxXd\/ei0qCdhKmkV7x9cgbTiyXgaI7iJEtdo\\n\" +\n+            \"RvYNcXc2RmitWjY5Av8yJGOk0eYpCwRrBv6ughbtJe3NMrqUeTyrKidIEo9KnRSA\\n\" +\n+            \"rMokRbHunkroS97VkoK\/9j9pNJki+qAH9XTLYWcm\/5+cTSGRsN+escRgZwV6KWg\/\\n\" +\n+            \"JQQe5LbwU2HHzNqWuk63GC\/ngVlWXjaVFfbNVmYEKZFFazcZchesN1YyDu+WndOx\\n\" +\n+            \"+rTcuke2feOvQ4EnVviM0k85JZNiqPDH2iafAWyqZFUYTnb7XK3HhJflAniv\/SLq\\n\" +\n+            \"DQfbJmtQtNHdJYgVmC1u2RT9gbJDIAj0ZI4vU2WVB5Hmd9F31un6jundEuG4+S4=\\n\" +\n@@ -266,4 +321,4 @@\n-    \/\/ Owner: CN=revoked.sca2a.amazontrust.com\n-    \/\/ Issuer: CN=Amazon, OU=Server CA 2A, O=Amazon, C=US\n-    \/\/ Serial number: 75a5df2d3387cfe5fd4cad9ff00f8c882b98d\n-    \/\/ Valid from: Fri Dec 17 12:28:31 PST 2021 until: Tue Jan 17 12:28:31 PST 2023\n+    \/\/ Owner: CN=revoked.rootca2.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n+    \/\/ Serial number: 788baa8f47bc5b1c624424216240fd3\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n@@ -271,33 +326,44 @@\n-            \"MIIGJjCCBA6gAwIBAgITB1pd8tM4fP5f1MrZ\/wD4yIK5jTANBgkqhkiG9w0BAQwF\\n\" +\n-            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n-            \"ZXIgQ0EgMkExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDI4MzFaFw0yMzAx\\n\" +\n-            \"MTcyMDI4MzFaMCgxJjAkBgNVBAMTHXJldm9rZWQuc2NhMmEuYW1hem9udHJ1c3Qu\\n\" +\n-            \"Y29tMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAu\/9+ky4Z5U24pBYd\\n\" +\n-            \"6xyb1BGQHTXS5nW8QjLWx+xaunRitgIBB8ZZ8OzUmH2mp2S\/9Vq1nqii9TvuzA9K\\n\" +\n-            \"JJQZLK8K+OJX\/ZwFdSxTgLcyeJ9cCswj\/C3SBA1NopZ3DmEWeXlh7aZhl8IXB6kp\\n\" +\n-            \"zI87Tg72F2JJokWNPYdx7xXhf\/WVeDeNRkz1iE5UTwL+qaNuzT7S8BdnFWqa3l4a\\n\" +\n-            \"Q1J\/YVww0XRhsYJulNVGhoKNf71q8KWw8hJ\/zgMxrBFywu7d3OBw6NX3bowZ+jMQ\\n\" +\n-            \"apJEWiwUYOjH3XcOO6TiChwQMypBrcbGgrD\/msTlvIBinHwpWaAgX0kT80+wH1Bq\\n\" +\n-            \"mw72fEjeE\/Y6EL6WIUr1HQdLhvBDxtPgxnAaxptmg126cF4jV\/e+D+IGf6qpN1gR\\n\" +\n-            \"JQC\/0+AnASAJ0cGKjSODbl5miqtc0kFSReMsOJeT7gdoPCMg4gWyo62GSvdaAA0I\\n\" +\n-            \"DA8a0HWLAzXU7SwbytTUTYeVI8QeNm2ZGKvMoHDWSDz69V6gGmNl\/YSvyJ2zPOZL\\n\" +\n-            \"8oRKRUCOA2LPdK0s7nebe0EBXF09FzzE4HdegRe7r86t6FE400W4wxwJjvjdHXcF\\n\" +\n-            \"s9fI+mgofMvVuK2u3wTdHOrEbfm1GXmj3BlFBORUI11A7K0lmIA02M2jkAN13foe\\n\" +\n-            \"rFLYg+28UjT4aN62zkynKD1iNwkCAwEAAaOCASkwggElMA4GA1UdDwEB\/wQEAwIF\\n\" +\n-            \"oDAdBgNVHQ4EFgQUOzuuTB9A8p71qwA3qxqOABf69nkwHwYDVR0jBBgwFoAU2kNK\\n\" +\n-            \"0PwBwEu\/WCeMds0KgfOULvQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMC\\n\" +\n-            \"MHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDovL29jc3Auc2NhMmEu\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8vY3J0LnNjYTJhLmFt\\n\" +\n-            \"YXpvbnRydXN0LmNvbS9zY2EyYS5jZXIwKAYDVR0RBCEwH4IdcmV2b2tlZC5zY2Ey\\n\" +\n-            \"YS5hbWF6b250cnVzdC5jb20wEwYDVR0gBAwwCjAIBgZngQwBAgEwDQYJKoZIhvcN\\n\" +\n-            \"AQEMBQADggIBALAPC6I\/k\/WqJ8dxt7yhhSKA5RyGjd16kh+zq57Cjy0Wmj3BtSFJ\\n\" +\n-            \"l0652ULeHZDjhtEAEMFlWdxuuUJ82UhzPzujeVv5e8CLROYWp52Jb9CFPTwF54ow\\n\" +\n-            \"0a6recetYvOHBTeQ0cmo3nY6Z8eHDRUdk\/aGQku1cesntFOIWm+EDj7SDYnUm3Ub\\n\" +\n-            \"ECdMv8entU5yjo\/herVNMT6GGnKfjRxM0FWJWoHKKC\/EPIka34VN6LOZO4Ftl9wI\\n\" +\n-            \"Ms7w3EgweEqLOyaGSAFwzrcQwKkPBm8fW5CefDtB64CtC8NUuo+XOQ2\/JlRnWGLk\\n\" +\n-            \"CHxesJBUNk5c\/IBDPLmyrKCLbGUqwsehQGQdSrLIH0857pTJi30D+\/KDvgQynaay\\n\" +\n-            \"zPWLrSJvXUOQ9Vir+RQtbiMOqUDXX15Vty2mxLqjos1zCAxgrorZ7H2OSBZIWYzE\\n\" +\n-            \"8UgF1\/vOlAtMjYyLLgb2UyqAY2HybKjtYYAyV\/oIPjVRXygaOGkDZseqqXuslq5I\\n\" +\n-            \"ZSDU5hF6Hy6D6gsCVdshswwuRg39248M79qsMDw0Xa7xGcwqdfwTHv4Rb3G\/kTrA\\n\" +\n-            \"8iR2YP\/RdABKkTkUKRXs0kYPFoJ0wQPDD5slkLjdZNeezoNrw1rWEEUh1iildiRA\\n\" +\n-            \"i1p+pwXSyZ+m5Gv0\/W84DDhLmAdvFov5muga8UccNbHuObtt1vHIhHe1\\n\" +\n+            \"MIIIEjCCBfqgAwIBAgIQB4i6qPR7xbHGJEJCFiQP0zANBgkqhkiG9w0BAQwFADA8\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n+            \"UlNBIDQwOTYgTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLzEt\\n\" +\n+            \"MCsGA1UEAxMkcmV2b2tlZC5yb290Y2EyLmRlbW8uYW1hem9udHJ1c3QuY29tMIIC\\n\" +\n+            \"IjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzJfddWdrWhA9dSJdmy23veN9\\n\" +\n+            \"oLvSqpM4YaXGZmPtKUmbFMLs2I3vCKrzflRKeOpl3MCc2hh6TH\/3z+Q\/fGugXLsY\\n\" +\n+            \"H8QcjSbiIOd15n+3dUFTLKaoWMyseMcWiOIVaN5rCDVXiAHdt1pc147wyFQIzqNK\\n\" +\n+            \"J\/xiV1u9eT2MFue+4bd7kUNAcmI8M+SXruhto4jtAV8ugpTEChTDlyO\/l8xmaM1Q\\n\" +\n+            \"HkijsHX7Aq72Q\/3PH\/U+wbJ9pmpTp4x2AEJoo45IGfB\/NKDTrv5otLBuiP8Y0M7b\\n\" +\n+            \"K7irRPDFBqMNZw7S7p39SnC+V\/WibJQk5Bo\/8vcwDJX+WnDkw1QD\/uXu3ugDzSDD\\n\" +\n+            \"iBDViMOdN+3K47s4x2kdssoh4WWScMlAVb4vyN7IA3J4TnwA\/1uCWhw4LE1WvY7N\\n\" +\n+            \"etekhVP1eWF8IzNY0oo2u2ie79777xvBtmtp7RnvYLGv7I+xVhjH5qGNzn9fRCUm\\n\" +\n+            \"QDego5HAfJ0PLlMEagdW8asCak1WaC117adnibL6WPtFA2FD2i6gNalTvhXhK2Ex\\n\" +\n+            \"alGxrVd\/BCseT3bMp783jqScJO1g6xRHu0Qx+RyrOGVvcKZa6Y0DcAc8psRpkHaO\\n\" +\n+            \"HZY+lE8O2CIxpAJlwSnD6BoDNo8sg1IqFNkECw3wqfeMPBcg38k6zjAxwRDcIx6U\\n\" +\n+            \"SwDl4d3sjrmy3gOFFXMCAwEAAaOCAxswggMXMB8GA1UdIwQYMBaAFJ5xHxodk6nZ\\n\" +\n+            \"LY7MSFM\/A1TznuZmMB0GA1UdDgQWBBQXpWT7gMHO+HKoHM1gU1VQVnylRzBOBgNV\\n\" +\n+            \"HREERzBFgiRyZXZva2VkLnJvb3RjYTIuZGVtby5hbWF6b250cnVzdC5jb22CHXJl\\n\" +\n+            \"dm9rZWQuc2NhMmEuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\/wQEAwIFoDAdBgNV\\n\" +\n+            \"HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQwMjAwoC6gLIYqaHR0\\n\" +\n+            \"cDovL2NybC5yNG0wMi5hbWF6b250cnVzdC5jb20vcjRtMDIuY3JsMBMGA1UdIAQM\\n\" +\n+            \"MAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDov\\n\" +\n+            \"L29jc3AucjRtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8v\\n\" +\n+            \"Y3J0LnI0bTAyLmFtYXpvbnRydXN0LmNvbS9yNG0wMi5jZXIwDAYDVR0TAQH\/BAIw\\n\" +\n+            \"ADCCAX0GCisGAQQB1nkCBAIEggFtBIIBaQFnAHYA7s3QZNXbGs7FXLedtM0TojKH\\n\" +\n+            \"Rny87N7DUUhZRnEftZsAAAGIB72CzgAABAMARzBFAiEA2vPYIPfGJeynPaZHq\/c0\\n\" +\n+            \"GGvyT6MpvFGMW0s0woLRT28CIEFbZbFSCnKugaqw9QDNi7vYmIF3Gyi3s6G2cCxY\\n\" +\n+            \"4RJXAHYASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/qznYhHMAAAGIB72DDgAA\\n\" +\n+            \"BAMARzBFAiAvfNcgtFEwk5C9dvMUYANbIAv0IOdF1new8Umn3cM+JwIhALbs\/3L9\\n\" +\n+            \"0ndF7sRKDZmfronNruptFlrI528P5Qi2P528AHUA2ra\/az+1tiKfm8K7XGvocJFx\\n\" +\n+            \"bLtRhIU0vaQ9MEjX+6sAAAGIB72CxQAABAMARjBEAiBKUns2FPbs0cThb6e7SnyL\\n\" +\n+            \"y4\/qP3V1Q\/ASt\/ZDRTeEQQIgWSQO4Gsz32srtqYuTM9AsFd92WA44kJHincdcGVX\\n\" +\n+            \"XbIwDQYJKoZIhvcNAQEMBQADggIBAAnaNbn2wXylTCS7dtgB3rWdUf6hja1UDuvB\\n\" +\n+            \"uZEL2dUOvyXfVFLNxKdeWBPzqpwEBNNwPQXhoI97TXlyu2x60jLzQamoGoRQ3s0P\\n\" +\n+            \"NLhasLGEIQH\/oYdMV\/yp8EI8fUuRVE3xyw39FRqOrmsUFAnxNQmBO\/09JM7sLcvS\\n\" +\n+            \"wwh14p9dFTTolJHgnL4ZEtmZxSddFG+GBSTJ\/A7dVSmwIudwzd+goA6173BI6yeT\\n\" +\n+            \"hhQumLctQiOM7y1MzFeV8rL+oIpd2xuzyhKKT1EgvU6\/wyt0Ib8QqsFsrXPnUOKk\\n\" +\n+            \"HAq3SeZyq35QUaTKoaH9L1iZMbSCG9Jm6FMb12SdAz53653tYvAiUS76oD8Jot13\\n\" +\n+            \"RZu5NUlWAVLLq0OaEtuGp0bh+cVtzVnCC9m1qa46YpY0SojpvSbakgQMMGIgDlT3\\n\" +\n+            \"wFE7tST4WlsDC1f\/m+H9V5qz\/j0U8D3eNNdowxPqx\/JZq\/sk9ZK5KyMFARrvM+fh\\n\" +\n+            \"YrVYjKt91mu7JaS4pPOyZmJ8OQ14EvrN7BXc7IkNrI1reeaRFe49k5DAETB8VmP5\\n\" +\n+            \"2F0SWou2KkgtJvU4Z7YjlZ2HNHnpjTK5KdPNpRSt7EUy2zn9NCNoyQhnws70FyXv\\n\" +\n+            \"oPFyG92lnUQOKaAUhVRwTr9fvnkdMOzSKg\/spxi2Ogdzym5Jw68eguwi0dVqX2+9\\n\" +\n+            \"3zViP2aH\\n\" +\n@@ -306,8 +372,1 @@\n-    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n-        \/\/ EE certificates don't have CRLDP extension\n-        if (!ocspEnabled){\n-            pathValidator.validate(new String[]{INT},\n-                    ValidatePathWithParams.Status.GOOD, null, System.out);\n-\n-            return;\n-        }\n+    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n@@ -322,1 +381,1 @@\n-                \"Fri Dec 17 12:29:36 PST 2021\", System.out);\n+                \"Mon May 15 13:38:54 PDT 2023\", System.out);\n@@ -328,1 +387,1 @@\n-    \/\/ Owner: CN=Amazon, OU=Server CA 3A, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon ECDSA 256 M02, O=Amazon, C=US\n@@ -330,4 +389,27 @@\n-    \/\/ Serial number: 67f945758fe55b9ee3f75831d47f07d226c8a\n-    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n-    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIICuzCCAmGgAwIBAgITBn+UV1j+VbnuP3WDHUfwfSJsijAKBggqhkjOPQQDAjA5\\n\" +\n+    \/\/ Serial number: 773126de2c2fafd2c47ad88b1566e0182046d\n+    \/\/ Valid from: Tue Aug 23 15:33:24 PDT 2022 until: Fri Aug 23 15:33:24 PDT 2030\n+    private static final String INT_VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIC1DCCAnmgAwIBAgITB3MSbeLC+v0sR62IsVZuAYIEbTAKBggqhkjOPQQDAjA5\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\\n\" +\n+            \"Um9vdCBDQSAzMB4XDTIyMDgyMzIyMzMyNFoXDTMwMDgyMzIyMzMyNFowPTELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n+            \"IDI1NiBNMDIwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAS9vQLD4W\/Kg4AnFRl8\\n\" +\n+            \"x\/FUbLqtd5ICYjUijGsytF9hmgb\/Dyk+Ebt4cw6rAlGbaiOLapSJKZiZr+UQdh3I\\n\" +\n+            \"QOr+o4IBWjCCAVYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYw\\n\" +\n+            \"HQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBS7eJrXaDMy\\n\" +\n+            \"nRq7bP2xNEwB3svQdTAfBgNVHSMEGDAWgBSrttvXBp43rDCGB5Fwx5zEGbF4wDB7\\n\" +\n+            \"BggrBgEFBQcBAQRvMG0wLwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwLnJvb3RjYTMu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tMDoGCCsGAQUFBzAChi5odHRwOi8vY3J0LnJvb3RjYTMu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tL3Jvb3RjYTMuY2VyMD8GA1UdHwQ4MDYwNKAyoDCGLmh0\\n\" +\n+            \"dHA6Ly9jcmwucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNhMy5jcmwwEwYD\\n\" +\n+            \"VR0gBAwwCjAIBgZngQwBAgEwCgYIKoZIzj0EAwIDSQAwRgIhAKSYEcDcp3kcPMzh\\n\" +\n+            \"OIYDWZOLu4InPod4fQhRTmc2zBAgAiEAmwdGE4AuNWhw9N8REhf82rJLNm7h9Myg\\n\" +\n+            \"TsR9Wu0bQYU=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n+\n+    \/\/ Owner: CN=Amazon ECDSA 256 M01, O=Amazon, C=US\n+    \/\/ Issuer: CN=Amazon Root CA 3, O=Amazon, C=US\n+    \/\/ Serial number: 773126684d577c0fcf8d3a342bea86f94fc8f\n+    \/\/ Valid from: Tue Aug 23 15:31:46 PDT 2022 until: Fri Aug 23 15:31:46 PDT 2030\n+    private static final String INT_REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIC0zCCAnmgAwIBAgITB3MSZoTVd8D8+NOjQr6ob5T8jzAKBggqhkjOPQQDAjA5\\n\" +\n@@ -335,13 +417,14 @@\n-            \"Um9vdCBDQSAzMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjELMAkG\\n\" +\n-            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENBIDNB\\n\" +\n-            \"MQ8wDQYDVQQDEwZBbWF6b24wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATYcYsK\\n\" +\n-            \"mYdR0Gj8Xz45E\/lfcTTnXhg2EtAIYBIHyXv\/ZQyyyCas1aptX\/I5T1coT6XK181g\\n\" +\n-            \"nB8hADuKfWlNoIYRo4IBOTCCATUwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8B\\n\" +\n-            \"Af8EBAMCAYYwHQYDVR0OBBYEFATc4JXl6LlrlKHvjFsxHhN+VZfaMB8GA1UdIwQY\\n\" +\n-            \"MBaAFKu229cGnjesMIYHkXDHnMQZsXjAMHsGCCsGAQUFBwEBBG8wbTAvBggrBgEF\\n\" +\n-            \"BQcwAYYjaHR0cDovL29jc3Aucm9vdGNhMy5hbWF6b250cnVzdC5jb20wOgYIKwYB\\n\" +\n-            \"BQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNh\\n\" +\n-            \"My5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2EzLmFtYXpv\\n\" +\n-            \"bnRydXN0LmNvbS9yb290Y2EzLmNybDARBgNVHSAECjAIMAYGBFUdIAAwCgYIKoZI\\n\" +\n-            \"zj0EAwIDSAAwRQIgOl\/vux0qfxNm05W3eofa9lKwz6oKvdu6g6Sc0UlwgRcCIQCS\\n\" +\n-            \"WSQ6F6JHLoeOWLyFFF658eNKEKbkEGMHz34gLX\/N3g==\\n\" +\n+            \"Um9vdCBDQSAzMB4XDTIyMDgyMzIyMzE0NloXDTMwMDgyMzIyMzE0NlowPTELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n+            \"IDI1NiBNMDEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAT80w+2RwNHzyXmVUM\/\\n\" +\n+            \"OUKBZpJkTzHyCKDl4sBrUfjzVjot\/lNba9kYzMKSHYv95CUDoMaF2h2KAqx65uLQ\\n\" +\n+            \"Y8ago4IBWjCCAVYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYw\\n\" +\n+            \"HQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBRPWfy8BhYo\\n\" +\n+            \"v6LI2wj7zxMkumlCXDAfBgNVHSMEGDAWgBSrttvXBp43rDCGB5Fwx5zEGbF4wDB7\\n\" +\n+            \"BggrBgEFBQcBAQRvMG0wLwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwLnJvb3RjYTMu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tMDoGCCsGAQUFBzAChi5odHRwOi8vY3J0LnJvb3RjYTMu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tL3Jvb3RjYTMuY2VyMD8GA1UdHwQ4MDYwNKAyoDCGLmh0\\n\" +\n+            \"dHA6Ly9jcmwucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNhMy5jcmwwEwYD\\n\" +\n+            \"VR0gBAwwCjAIBgZngQwBAgEwCgYIKoZIzj0EAwIDSAAwRQIhALRfxq3SQIhj5xA4\\n\" +\n+            \"S5UAY\/KlKqayZDpnbBdCDH8Kqmf\/AiAUVZddALefnqRe+ifxN2FUp461LL6\/cgVM\\n\" +\n+            \"EH3Ty27f1Q==\\n\" +\n@@ -350,4 +433,4 @@\n-    \/\/ Owner: CN=good.sca3a.amazontrust.com\n-    \/\/ Issuer: CN=Amazon, OU=Server CA 3A, O=Amazon, C=US\n-    \/\/ Serial number: 75a5dd9ec12f37f4bbed4bada4b75164a642f\n-    \/\/ Valid from: Fri Dec 17 12:23:00 PST 2021 until: Tue Jan 17 12:23:00 PST 2023\n+    \/\/ Owner: CN=valid.rootca3.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon ECDSA 256 M02, O=Amazon, C=US\n+    \/\/ Serial number: 8e2f14864fb28e4a1da0f15a5118cc8\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n@@ -355,14 +438,25 @@\n-            \"MIIClDCCAjqgAwIBAgITB1pd2ewS839LvtS62kt1FkpkLzAKBggqhkjOPQQDAjBG\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n-            \"Q0EgM0ExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDIzMDBaFw0yMzAxMTcy\\n\" +\n-            \"MDIzMDBaMCUxIzAhBgNVBAMTGmdvb2Quc2NhM2EuYW1hem9udHJ1c3QuY29tMFkw\\n\" +\n-            \"EwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE275wkVMovF+U\/fRduMcuthD8AYpYTUgc\\n\" +\n-            \"qoEHEccF6eZYzoGlufHJCwtLHXk9qXeXtjZV8N90ksYahFV+oGFcpaOCASYwggEi\\n\" +\n-            \"MA4GA1UdDwEB\/wQEAwIHgDAdBgNVHQ4EFgQUS8gTB11XA49gH4IGAD6p3UilrIMw\\n\" +\n-            \"HwYDVR0jBBgwFoAUBNzgleXouWuUoe+MWzEeE35Vl9owHQYDVR0lBBYwFAYIKwYB\\n\" +\n-            \"BQUHAwEGCCsGAQUFBwMCMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0\\n\" +\n-            \"cDovL29jc3Auc2NhM2EuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRw\\n\" +\n-            \"Oi8vY3J0LnNjYTNhLmFtYXpvbnRydXN0LmNvbS9zY2EzYS5jZXIwJQYDVR0RBB4w\\n\" +\n-            \"HIIaZ29vZC5zY2EzYS5hbWF6b250cnVzdC5jb20wEwYDVR0gBAwwCjAIBgZngQwB\\n\" +\n-            \"AgEwCgYIKoZIzj0EAwIDSAAwRQIgRRteTEwQoqw95mKff0ydDMD1+YQbcN6QLw\/a\\n\" +\n-            \"NwDti9ICIQDYMNw6u0d5gaZZo\/zizl1JRVAuSxoO5lNOrleaEOkImA==\\n\" +\n+            \"MIIEfjCCBCWgAwIBAgIQCOLxSGT7KOSh2g8VpRGMyDAKBggqhkjOPQQDAjA9MQsw\\n\" +\n+            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n+            \"U0EgMjU2IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC0xKzAp\\n\" +\n+            \"BgNVBAMTInZhbGlkLnJvb3RjYTMuZGVtby5hbWF6b250cnVzdC5jb20wWTATBgcq\\n\" +\n+            \"hkjOPQIBBggqhkjOPQMBBwNCAAQfWc7gBGBBBmseCb2XWWRQVhCUQDVml3mVgvj5\\n\" +\n+            \"RmnP1y5wpifUTFqu8ELdI7YGZ4JMSnetiKNmLtg5yhTEjzCQo4IDFTCCAxEwHwYD\\n\" +\n+            \"VR0jBBgwFoAUu3ia12gzMp0au2z9sTRMAd7L0HUwHQYDVR0OBBYEFHCE8orvZDUK\\n\" +\n+            \"5TI9MYadzxWR9CZGMEkGA1UdEQRCMECCInZhbGlkLnJvb3RjYTMuZGVtby5hbWF6\\n\" +\n+            \"b250cnVzdC5jb22CGmdvb2Quc2NhM2EuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\\n\" +\n+            \"\/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQw\\n\" +\n+            \"MjAwoC6gLIYqaHR0cDovL2NybC5lMm0wMi5hbWF6b250cnVzdC5jb20vZTJtMDIu\\n\" +\n+            \"Y3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEF\\n\" +\n+            \"BQcwAYYhaHR0cDovL29jc3AuZTJtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUF\\n\" +\n+            \"BzAChipodHRwOi8vY3J0LmUybTAyLmFtYXpvbnRydXN0LmNvbS9lMm0wMi5jZXIw\\n\" +\n+            \"DAYDVR0TAQH\/BAIwADCCAXwGCisGAQQB1nkCBAIEggFsBIIBaAFmAHUA7s3QZNXb\\n\" +\n+            \"Gs7FXLedtM0TojKHRny87N7DUUhZRnEftZsAAAGIB71y\/gAABAMARjBEAiAEAXIb\\n\" +\n+            \"aOVR26HgFaI+qoIasCb8w2sOqVxGAxf5iPgX6QIgdAlMjqeoihi1arnJpzN8Bqxy\\n\" +\n+            \"5ULMUO7GK3JEgcogJHMAdgBIsONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiE\\n\" +\n+            \"cwAAAYgHvXLkAAAEAwBHMEUCIF7wDDmWxTHwBZM7Me8eOCM1aQ\/g1c1rJg\/I+NJa\\n\" +\n+            \"HkZYAiEA8p+IviuY5piHBELjUtVlZLiS9XSSMxpQNhUerqC\/YFoAdQDatr9rP7W2\\n\" +\n+            \"Ip+bwrtca+hwkXFsu1GEhTS9pD0wSNf7qwAAAYgHvXKvAAAEAwBGMEQCIFLskZDs\\n\" +\n+            \"UG4+\/88D\/5\/QbD9zT6ZmZlwXiPZ6H2YR\/KiJAiBvi4vvNsb9KNAhJMgI2T2iCg9U\\n\" +\n+            \"CIru+US6y3ua7dKKDTAKBggqhkjOPQQDAgNHADBEAiAzvgzKV\/kvBbKWCT1NNUBD\\n\" +\n+            \"AF9okIEcJx\/ukFgzmYMwUQIgXeJeVf3izkxsgiEUSknwHsErLFs\/cEme2PSRj2AW\\n\" +\n+            \"dYA=\\n\" +\n@@ -371,4 +465,4 @@\n-    \/\/ Owner: CN=revoked.sca3a.amazontrust.com\n-    \/\/ Issuer: CN=Amazon, OU=Server CA 3A, O=Amazon, C=US\n-    \/\/ Serial number: 75a5df9c88c0613777baba663000de147a26b\n-    \/\/ Valid from: Fri Dec 17 12:30:04 PST 2021 until: Tue Jan 17 12:30:04 PST 2023\n+    \/\/ Owner: CN=revoked.rootca3.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon ECDSA 256 M01, O=Amazon, C=US\n+    \/\/ Serial number: c458bfaeedae16a5e61fe64773fc898\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n@@ -376,14 +470,25 @@\n-            \"MIICmzCCAkCgAwIBAgITB1pd+ciMBhN3e6umYwAN4UeiazAKBggqhkjOPQQDAjBG\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n-            \"Q0EgM0ExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDMwMDRaFw0yMzAxMTcy\\n\" +\n-            \"MDMwMDRaMCgxJjAkBgNVBAMTHXJldm9rZWQuc2NhM2EuYW1hem9udHJ1c3QuY29t\\n\" +\n-            \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEbppBP3Dj0qoRHMB9VMTXhw2Fg8ef\\n\" +\n-            \"o32r\/Mu3IzT8T6kWCk3UqVDL3UIn3qVZLCW1nJfVc1d1EeSDvyjCL3u3f6OCASkw\\n\" +\n-            \"ggElMA4GA1UdDwEB\/wQEAwIHgDAdBgNVHQ4EFgQUv8lJ3W7O74zVj+0zhD4+rrqZ\\n\" +\n-            \"yvMwHwYDVR0jBBgwFoAUBNzgleXouWuUoe+MWzEeE35Vl9owHQYDVR0lBBYwFAYI\\n\" +\n-            \"KwYBBQUHAwEGCCsGAQUFBwMCMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYh\\n\" +\n-            \"aHR0cDovL29jc3Auc2NhM2EuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipo\\n\" +\n-            \"dHRwOi8vY3J0LnNjYTNhLmFtYXpvbnRydXN0LmNvbS9zY2EzYS5jZXIwKAYDVR0R\\n\" +\n-            \"BCEwH4IdcmV2b2tlZC5zY2EzYS5hbWF6b250cnVzdC5jb20wEwYDVR0gBAwwCjAI\\n\" +\n-            \"BgZngQwBAgEwCgYIKoZIzj0EAwIDSQAwRgIhAKrA0fOK4NKDKHTY8ESeVW3D\/7NH\\n\" +\n-            \"tbNdfcIXolAoFfmFAiEAylAsKdND8c4w69jlFTId0X8F\/mrXzKfLFCQ+b\/7jTto=\\n\" +\n+            \"MIIEhzCCBC2gAwIBAgIQDEWL+u7a4WpeYf5kdz\/ImDAKBggqhkjOPQQDAjA9MQsw\\n\" +\n+            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n+            \"U0EgMjU2IE0wMTAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC8xLTAr\\n\" +\n+            \"BgNVBAMTJHJldm9rZWQucm9vdGNhMy5kZW1vLmFtYXpvbnRydXN0LmNvbTBZMBMG\\n\" +\n+            \"ByqGSM49AgEGCCqGSM49AwEHA0IABAsSs5kW5TZlS0SDrMb9iUQAqEaKa12Fc6SN\\n\" +\n+            \"9UR6qtOFdW\/1UuziDq3Hl5dqsAYZJkbJSPCIsD2HTP\/EGTMKITCjggMbMIIDFzAf\\n\" +\n+            \"BgNVHSMEGDAWgBRPWfy8BhYov6LI2wj7zxMkumlCXDAdBgNVHQ4EFgQUeE55ET2e\\n\" +\n+            \"i8KbY7KHTxOuvCkRpTowTgYDVR0RBEcwRYIkcmV2b2tlZC5yb290Y2EzLmRlbW8u\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tgh1yZXZva2VkLnNjYTNhLmFtYXpvbnRydXN0LmNvbTAO\\n\" +\n+            \"BgNVHQ8BAf8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMDsG\\n\" +\n+            \"A1UdHwQ0MDIwMKAuoCyGKmh0dHA6Ly9jcmwuZTJtMDEuYW1hem9udHJ1c3QuY29t\\n\" +\n+            \"L2UybTAxLmNybDATBgNVHSAEDDAKMAgGBmeBDAECATB1BggrBgEFBQcBAQRpMGcw\\n\" +\n+            \"LQYIKwYBBQUHMAGGIWh0dHA6Ly9vY3NwLmUybTAxLmFtYXpvbnRydXN0LmNvbTA2\\n\" +\n+            \"BggrBgEFBQcwAoYqaHR0cDovL2NydC5lMm0wMS5hbWF6b250cnVzdC5jb20vZTJt\\n\" +\n+            \"MDEuY2VyMAwGA1UdEwEB\/wQCMAAwggF9BgorBgEEAdZ5AgQCBIIBbQSCAWkBZwB2\\n\" +\n+            \"AHb\/iD8KtvuVUcJhzPWHujS0pM27KdxoQgqf5mdMWjp0AAABiAe9lQ8AAAQDAEcw\\n\" +\n+            \"RQIgZVFAX5WPZRBpEOqk620v4Rbzxh\/3wrJ5QBMBJ0Mb8B0CIQC0oxFVLfs+PAv7\\n\" +\n+            \"25wawOu2VgDXG9lJAJtCwk3gN8BshQB2AEiw42vapkc0D+VqAvqdMOscUgHLVt0s\\n\" +\n+            \"gdm7v6s52IRzAAABiAe9lQ4AAAQDAEcwRQIhAIPVMj6IfjAUKeGYbpG9s0DRdWbc\\n\" +\n+            \"b8OzsOf+kRqk03NMAiB777hfoFCUMPrN0g8o5v6zp3T3qOhRnYY0TZN4q4NnMgB1\\n\" +\n+            \"ANq2v2s\/tbYin5vCu1xr6HCRcWy7UYSFNL2kPTBI1\/urAAABiAe9lN4AAAQDAEYw\\n\" +\n+            \"RAIgL0qoVbKLFD+Y3f\/V6Rw+euZrPO6d1HEVPQGo7wLzkl8CIGHp3PQmmrEofl76\\n\" +\n+            \"4da7bY0L+csFW0sB8clN0KziMfe6MAoGCCqGSM49BAMCA0gAMEUCIQC+6VdX9X5g\\n\" +\n+            \"x3NSUmJ7py01Zxf26TNBv1ildxqesvZ\/7wIgIrefriRzPiIFDHCUbdjk0VlmMwZR\\n\" +\n+            \"VzXXHINsGCiCKOs=\\n\" +\n@@ -392,8 +497,1 @@\n-    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n-        \/\/ EE certificates don't have CRLDP extension\n-        if (!ocspEnabled){\n-            pathValidator.validate(new String[]{INT},\n-                    ValidatePathWithParams.Status.GOOD, null, System.out);\n-\n-            return;\n-        }\n+    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n@@ -402,1 +500,1 @@\n-        pathValidator.validate(new String[]{VALID, INT},\n+        pathValidator.validate(new String[]{VALID, INT_VALID},\n@@ -406,1 +504,1 @@\n-        pathValidator.validate(new String[]{REVOKED, INT},\n+        pathValidator.validate(new String[]{REVOKED, INT_REVOKED},\n@@ -408,1 +506,1 @@\n-                \"Fri Dec 17 12:30:37 PST 2021\", System.out);\n+                \"Mon May 15 13:41:22 PDT 2023\", System.out);\n@@ -414,1 +512,1 @@\n-    \/\/ Owner: CN=Amazon, OU=Server CA 4A, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n@@ -416,2 +514,2 @@\n-    \/\/ Serial number: 67f94575a8862a9072e3239c37ceba1274e18\n-    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n+    \/\/ Serial number: 773127dfaa6b9e2b95538aa76dde4307f17c4\n+    \/\/ Valid from: Tue Aug 23 15:36:58 PDT 2022 until: Fri Aug 23 15:36:58 PDT 2030\n@@ -419,1 +517,1 @@\n-            \"MIIC+TCCAn6gAwIBAgITBn+UV1qIYqkHLjI5w3zroSdOGDAKBggqhkjOPQQDAzA5\\n\" +\n+            \"MIIDETCCApagAwIBAgITB3MSffqmueK5VTiqdt3kMH8XxDAKBggqhkjOPQQDAzA5\\n\" +\n@@ -421,14 +519,15 @@\n-            \"Um9vdCBDQSA0MB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjELMAkG\\n\" +\n-            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENBIDRB\\n\" +\n-            \"MQ8wDQYDVQQDEwZBbWF6b24wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASRP0kIW0Ha\\n\" +\n-            \"7+ORvEVhIS5gIgkH66X5W9vBRTX14oG\/1elIyI6LbFZ+E5KAufL0XoWJGI1WbPRm\\n\" +\n-            \"HW246FKSzF0wOEZZyxEROz6tuaVsnXRHRE76roS\/Wr064uJpKH+Lv+SjggE5MIIB\\n\" +\n-            \"NTASBgNVHRMBAf8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHQ4EFgQU\\n\" +\n-            \"pSHN2+tTIZmqytlnQpQlsnv0wuMwHwYDVR0jBBgwFoAU0+zHOmVuzOHadppW+5zz\\n\" +\n-            \"hm1X5YEwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8vb2NzcC5y\\n\" +\n-            \"b290Y2E0LmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDovL2NydC5y\\n\" +\n-            \"b290Y2E0LmFtYXpvbnRydXN0LmNvbS9yb290Y2E0LmNlcjA\/BgNVHR8EODA2MDSg\\n\" +\n-            \"MqAwhi5odHRwOi8vY3JsLnJvb3RjYTQuYW1hem9udHJ1c3QuY29tL3Jvb3RjYTQu\\n\" +\n-            \"Y3JsMBEGA1UdIAQKMAgwBgYEVR0gADAKBggqhkjOPQQDAwNpADBmAjEA59RAOBaj\\n\" +\n-            \"uh0rT\/OOTWPEv6TBnb9XEadburBaXb8SSrR8il+NdkfS9WXRAzbwrG7LAjEA3ukD\\n\" +\n-            \"1HrQq+WXHBM5sIuViJI\/Zh7MOjsc159Q+dn36PBqLRq03AXqE\/lRjnv8C5nj\\n\" +\n+            \"Um9vdCBDQSA0MB4XDTIyMDgyMzIyMzY1OFoXDTMwMDgyMzIyMzY1OFowPTELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n+            \"IDM4NCBNMDIwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATNYzWQDXV0NoNmR0hJPwJq\\n\" +\n+            \"hjYOOS9z0B2Z7MQudxg5x3Vsib6N+tJkq8dljRq5o6K0bbh\/kRVfoi9wfKhB03Yz\\n\" +\n+            \"gkerrwRCH7Z9gU5nbBY+Y5+EtImq4yOB0n7JQgQxWemjggFaMIIBVjASBgNVHRMB\\n\" +\n+            \"Af8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcD\\n\" +\n+            \"AQYIKwYBBQUHAwIwHQYDVR0OBBYEFKbZqzuHmTP\/6Gj4i2GDbNCyuq+9MB8GA1Ud\\n\" +\n+            \"IwQYMBaAFNPsxzplbszh2naaVvuc84ZtV+WBMHsGCCsGAQUFBwEBBG8wbTAvBggr\\n\" +\n+            \"BgEFBQcwAYYjaHR0cDovL29jc3Aucm9vdGNhNC5hbWF6b250cnVzdC5jb20wOgYI\\n\" +\n+            \"KwYBBQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhNC5hbWF6b250cnVzdC5jb20vcm9v\\n\" +\n+            \"dGNhNC5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2E0LmFt\\n\" +\n+            \"YXpvbnRydXN0LmNvbS9yb290Y2E0LmNybDATBgNVHSAEDDAKMAgGBmeBDAECATAK\\n\" +\n+            \"BggqhkjOPQQDAwNpADBmAjEA2zCG6x0xMlgSXWEGLN8+1XN+OCYF5vj0Z1jtVy+A\\n\" +\n+            \"pdLlzuxNt9HBWn3hvqvO2W8KAjEApNdsZOCmk5uZBYiuCSBnDH3jyKhN6dWyuuHW\\n\" +\n+            \"9Wj7SxKnOU5+wYWZA0BQAv1KT62i\\n\" +\n@@ -437,4 +536,4 @@\n-    \/\/ Owner: CN=good.sca4a.amazontrust.com\n-    \/\/ Issuer: CN=Amazon, OU=Server CA 4A, O=Amazon, C=US\n-    \/\/ Serial number: 75a5ddc1a4ea5a18110454883269df9409bf5\n-    \/\/ Valid from: Fri Dec 17 12:23:29 PST 2021 until: Tue Jan 17 12:23:29 PST 2023\n+    \/\/ Owner: CN=valid.rootca4.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n+    \/\/ Serial number: f579bed3369f1a147ea5d0e8e6532d3\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n@@ -442,16 +541,26 @@\n-            \"MIIC0TCCAlegAwIBAgITB1pd3BpOpaGBEEVIgyad+UCb9TAKBggqhkjOPQQDAzBG\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n-            \"Q0EgNEExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDIzMjlaFw0yMzAxMTcy\\n\" +\n-            \"MDIzMjlaMCUxIzAhBgNVBAMTGmdvb2Quc2NhNGEuYW1hem9udHJ1c3QuY29tMHYw\\n\" +\n-            \"EAYHKoZIzj0CAQYFK4EEACIDYgAE7VpccYyJsD19xB1owlNs9PGkXkjptJZK6eFY\\n\" +\n-            \"q9Tc+CZLaOAhi47uuWsPwyIYB3vEIUXoWWKTvgycHhsmVQDQ2hLYMS+h9tQgnqVN\\n\" +\n-            \"TDYpEnnBa6AUbTKXtJDLG+z+7Kd7o4IBJjCCASIwDgYDVR0PAQH\/BAQDAgeAMB0G\\n\" +\n-            \"A1UdDgQWBBRHzxN3jV4vU1PEmHmTqB8YXXoMYDAfBgNVHSMEGDAWgBSlIc3b61Mh\\n\" +\n-            \"marK2WdClCWye\/TC4zAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYI\\n\" +\n-            \"KwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2E0YS5hbWF6\\n\" +\n-            \"b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhNGEuYW1hem9u\\n\" +\n-            \"dHJ1c3QuY29tL3NjYTRhLmNlcjAlBgNVHREEHjAcghpnb29kLnNjYTRhLmFtYXpv\\n\" +\n-            \"bnRydXN0LmNvbTATBgNVHSAEDDAKMAgGBmeBDAECATAKBggqhkjOPQQDAwNoADBl\\n\" +\n-            \"AjEAyHMRGLsUVEufoih22dPfO5LrLpO4\/2VzeNBbUvP\/mOcwvMrrq1yQjot3CTdm\\n\" +\n-            \"ZwnRAjAj2zmAM5asBZwuEN1pbEFgHdojio0O4oYvUsdMooLOKJsBD7hmgAdhpObO\\n\" +\n-            \"Xv0oNIE=\\n\" +\n+            \"MIIEvjCCBESgAwIBAgIQD1eb7TNp8aFH6l0OjmUy0zAKBggqhkjOPQQDAzA9MQsw\\n\" +\n+            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n+            \"U0EgMzg0IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC0xKzAp\\n\" +\n+            \"BgNVBAMTInZhbGlkLnJvb3RjYTQuZGVtby5hbWF6b250cnVzdC5jb20wdjAQBgcq\\n\" +\n+            \"hkjOPQIBBgUrgQQAIgNiAAT6\/95JFuvx5t9MVeRZmBtXq63Q2fXZnSwEy2U2F4Qc\\n\" +\n+            \"ejhDwcYfD2HmT6S6GrKqLNJMa5n2YOvet4LZpKJLFF+BQo6FJt5cXkzHHxZ1I4z3\\n\" +\n+            \"8pGU79CpCgFOFy6QUlF68NajggMXMIIDEzAfBgNVHSMEGDAWgBSm2as7h5kz\/+ho\\n\" +\n+            \"+Ithg2zQsrqvvTAdBgNVHQ4EFgQUR\/GnpQkrUsCj8jF6\/JIE1Rs07zswSQYDVR0R\\n\" +\n+            \"BEIwQIIidmFsaWQucm9vdGNhNC5kZW1vLmFtYXpvbnRydXN0LmNvbYIaZ29vZC5z\\n\" +\n+            \"Y2E0YS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgeAMB0GA1UdJQQWMBQG\\n\" +\n+            \"CCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAshipodHRwOi8vY3Js\\n\" +\n+            \"LmUzbTAyLmFtYXpvbnRydXN0LmNvbS9lM20wMi5jcmwwEwYDVR0gBAwwCjAIBgZn\\n\" +\n+            \"gQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5l\\n\" +\n+            \"M20wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuZTNt\\n\" +\n+            \"MDIuYW1hem9udHJ1c3QuY29tL2UzbTAyLmNlcjAMBgNVHRMBAf8EAjAAMIIBfgYK\\n\" +\n+            \"KwYBBAHWeQIEAgSCAW4EggFqAWgAdgDuzdBk1dsazsVct520zROiModGfLzs3sNR\\n\" +\n+            \"SFlGcR+1mwAAAYgHvZA9AAAEAwBHMEUCIQCmzmQOzunsuAg1GpIcNx0isG6ylbhP\\n\" +\n+            \"y9JP4UFclL2hdwIgBtTM89mE7QJDj7h7xr2eRPio1ehgmeYH1PHXxCqHIGYAdgBI\\n\" +\n+            \"sONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgHvZB1AAAEAwBHMEUC\\n\" +\n+            \"IF9hbi82CLU5umfRze4NpX6u4jlT+N8KSaBe6UbhqjBZAiEAi2Y6PTt2+107LxtM\\n\" +\n+            \"oBpHprph7hQvGfjPE+p+rfM\/X+EAdgDatr9rP7W2Ip+bwrtca+hwkXFsu1GEhTS9\\n\" +\n+            \"pD0wSNf7qwAAAYgHvZBeAAAEAwBHMEUCIAI+m4mVE3HtZOEMC5VI7m0nEPdPPJUq\\n\" +\n+            \"fxUKPpeIVmk5AiEA0scVJy7g3Fv+2nTVhbcwWCwn\/Gvc+0txQrc529juflcwCgYI\\n\" +\n+            \"KoZIzj0EAwMDaAAwZQIxAKV837BpqlNHg35EsCCtrJPoQ6RuY9UoHm1O2CdsCXGR\\n\" +\n+            \"Z3kAnlgIV8A\/waI6wQqfsQIwdCqaC+qN60JCnX09YKRD15eQjq1rN3w+llI+lEbS\\n\" +\n+            \"FSMsnoHJcqMZLo9s+4Rf0zS3\\n\" +\n@@ -460,4 +569,4 @@\n-    \/\/ Owner: CN=revoked.sca4a.amazontrust.com\n-    \/\/ Issuer: CN=Amazon, OU=Server CA 4A, O=Amazon, C=US\n-    \/\/ Serial number: 75a5e0442d0fed2b11850ed6746a2200bb4af\n-    \/\/ Valid from: Fri Dec 17 12:32:23 PST 2021 until: Tue Jan 17 12:32:23 PST 2023\n+    \/\/ Owner: CN=revoked.rootca4.demo.amazontrust.com\n+    \/\/ Issuer: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n+    \/\/ Serial number: 4a5d392936b4decb818b7fb106ebbd8\n+    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n@@ -465,16 +574,26 @@\n-            \"MIIC1zCCAl2gAwIBAgITB1peBELQ\/tKxGFDtZ0aiIAu0rzAKBggqhkjOPQQDAzBG\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n-            \"Q0EgNEExDzANBgNVBAMTBkFtYXpvbjAeFw0yMTEyMTcyMDMyMjNaFw0yMzAxMTcy\\n\" +\n-            \"MDMyMjNaMCgxJjAkBgNVBAMTHXJldm9rZWQuc2NhNGEuYW1hem9udHJ1c3QuY29t\\n\" +\n-            \"MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEqxQKCDKJYXzA0uR3jyfk\/ZRyPAJolRNI\\n\" +\n-            \"xI3+vlQW7SqVs+MziCLFPuU68kf74a5\/YFWK\/bRdXrVue4IMbM8TKO2FwXIHn\/Iw\\n\" +\n-            \"udkJIG+CdqnL4IlH+tFf+l47vRzMS0TQo4IBKTCCASUwDgYDVR0PAQH\/BAQDAgeA\\n\" +\n-            \"MB0GA1UdDgQWBBR04rEvUxTzLh0OGHyMgrYanP7lqzAfBgNVHSMEGDAWgBSlIc3b\\n\" +\n-            \"61MhmarK2WdClCWye\/TC4zAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIw\\n\" +\n-            \"dQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2E0YS5h\\n\" +\n-            \"bWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhNGEuYW1h\\n\" +\n-            \"em9udHJ1c3QuY29tL3NjYTRhLmNlcjAoBgNVHREEITAfgh1yZXZva2VkLnNjYTRh\\n\" +\n-            \"LmFtYXpvbnRydXN0LmNvbTATBgNVHSAEDDAKMAgGBmeBDAECATAKBggqhkjOPQQD\\n\" +\n-            \"AwNoADBlAjEAgOyeHMBYmO9rfMgCnV4oOQ5PcjSAgotYwEGqFHA5+TuIPBTcdFar\\n\" +\n-            \"J1j1JY+EirQ3AjAuGMJdyiQfAVi1n5wT1\/2nIOIEGtV2\/9CrNmhmjIzKrfu+HUUk\\n\" +\n-            \"bduxD7hNhott7NE=\\n\" +\n+            \"MIIExjCCBEygAwIBAgIQBKXTkpNrTey4GLf7EG672DAKBggqhkjOPQQDAzA9MQsw\\n\" +\n+            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n+            \"U0EgMzg0IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC8xLTAr\\n\" +\n+            \"BgNVBAMTJHJldm9rZWQucm9vdGNhNC5kZW1vLmFtYXpvbnRydXN0LmNvbTB2MBAG\\n\" +\n+            \"ByqGSM49AgEGBSuBBAAiA2IABFYfMbv5\/vgqDunZj4ffJiuELtdwfEPXx9QlZnCm\\n\" +\n+            \"rBP3Z4\/GvUVRVmyh5sYdnbCGCEClH\/RxU6BC5SKv+TzhsFLEumhezanljnQXRAIL\\n\" +\n+            \"a1OGbP8zLLP6FuAD0cjY3P3adKOCAx0wggMZMB8GA1UdIwQYMBaAFKbZqzuHmTP\/\\n\" +\n+            \"6Gj4i2GDbNCyuq+9MB0GA1UdDgQWBBSqnGV5pN\/agPCtVdV37CP1z\/DUqjBOBgNV\\n\" +\n+            \"HREERzBFgiRyZXZva2VkLnJvb3RjYTQuZGVtby5hbWF6b250cnVzdC5jb22CHXJl\\n\" +\n+            \"dm9rZWQuc2NhNGEuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\/wQEAwIHgDAdBgNV\\n\" +\n+            \"HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQwMjAwoC6gLIYqaHR0\\n\" +\n+            \"cDovL2NybC5lM20wMi5hbWF6b250cnVzdC5jb20vZTNtMDIuY3JsMBMGA1UdIAQM\\n\" +\n+            \"MAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDov\\n\" +\n+            \"L29jc3AuZTNtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8v\\n\" +\n+            \"Y3J0LmUzbTAyLmFtYXpvbnRydXN0LmNvbS9lM20wMi5jZXIwDAYDVR0TAQH\/BAIw\\n\" +\n+            \"ADCCAX8GCisGAQQB1nkCBAIEggFvBIIBawFpAHYAdv+IPwq2+5VRwmHM9Ye6NLSk\\n\" +\n+            \"zbsp3GhCCp\/mZ0xaOnQAAAGIB72QJQAABAMARzBFAiA74zKrlL+y5rYwSLxBL8fs\\n\" +\n+            \"QYRYXF0s0sGoaSEeAg1DkgIhAPu8Z0TLIFoppmyiv+A5z6S+SG+v\/kOsAYmQmiUO\\n\" +\n+            \"5scIAHcASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/qznYhHMAAAGIB72QJgAA\\n\" +\n+            \"BAMASDBGAiEAg+x7JBT3oIaZdnfgGN1G6SAiNUL7zR\/tBhbWIG9tz94CIQDGwBiV\\n\" +\n+            \"Tslt11+W3ZaNsS7UtUIiB45YHUc4qKm5ry2fTAB2ANq2v2s\/tbYin5vCu1xr6HCR\\n\" +\n+            \"cWy7UYSFNL2kPTBI1\/urAAABiAe9kAgAAAQDAEcwRQIgPvKfSpMJKRocGk9+GNr3\\n\" +\n+            \"hUj8x8WySB\/\/0X116TNgA0gCIQDhGRqxnEZmEFGEfj5GY9vjEfm0kKwcL0lCuwBu\\n\" +\n+            \"NZG4dzAKBggqhkjOPQQDAwNoADBlAjEA1PLdsrko3tDs50aAeEU9Gn+0CG8QKy7R\\n\" +\n+            \"fQaXBTjGETDgGJk\/7zGNpGelKPr\/UYV9AjASwdA32S8jIADxA8HrqiMsVYDFMnbU\\n\" +\n+            \"jLLwR6CTLtAcWtwVmoQ2x0usvTvN8YJBPoA=\\n\" +\n@@ -483,8 +602,1 @@\n-    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n-        \/\/ EE certificates don't have CRLDP extension\n-        if (!ocspEnabled){\n-            pathValidator.validate(new String[]{INT},\n-                    ValidatePathWithParams.Status.GOOD, null, System.out);\n-\n-            return;\n-        }\n+    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n@@ -499,1 +611,1 @@\n-                \"Fri Dec 17 12:32:59 PST 2021\", System.out);\n+                \"Mon May 15 13:42:48 PDT 2023\", System.out);\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/AmazonCA.java","additions":461,"deletions":349,"binary":false,"changes":810,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,9 @@\n+    private static void ck(String s, int actual, int expected)\n+        throws IOException {\n+        if (actual != expected) {\n+            String msg = String.format(\"%s: actual (%d) != expected (%d)%n\",\n+                                       s, actual, expected);\n+            throw new IOException(msg);\n+        }\n+    }\n+\n@@ -49,3 +58,1 @@\n-        if (out.length != expected.length) {\n-            throw new IOException(\"Failed\");\n-        }\n+        ck(\"Lengths are unequal\", out.length, expected.length);\n@@ -54,2 +61,1 @@\n-            if (out[i] != expected[i])\n-                throw new IOException(\"Failed\");\n+            ck(\"Values are unequal\", out[i], expected[i]);\n","filename":"test\/jdk\/sun\/nio\/cs\/StreamEncoderClose.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8080462 8229243\n+ * @bug 8080462 8229243 8307185\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestGCMKeyAndIvCheck.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,2 @@\n- * @summary AsyncSSLSocketClose.java has timing issue\n+ * @summary AsyncSSLSocketClose.java has timing issue.\n+ * @library \/javax\/net\/ssl\/templates\n@@ -41,0 +42,1 @@\n+import java.util.Arrays;\n@@ -43,0 +45,2 @@\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -44,1 +48,6 @@\n-public class BlockedAsyncClose implements Runnable {\n+\/*\n+ * To manually verify that the write thread was blocked when socket.close() is called,\n+ * run the test with -Djavax.net.debug=ssl. You should see the message\n+ * \"SSLSocket output duplex close failed: SO_LINGER timeout, close_notify message cannot be sent.\"\n+ *\/\n+public class BlockedAsyncClose extends SSLContextTemplate implements Runnable {\n@@ -50,6 +59,1 @@\n-\n-    \/\/ Where do we find the keystores?\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n+    private final Lock writeLock = new ReentrantLock();\n@@ -58,13 +62,1 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n-\n-        new BlockedAsyncClose();\n+        new BlockedAsyncClose().runTest();\n@@ -73,3 +65,2 @@\n-    public BlockedAsyncClose() throws Exception {\n-        SSLServerSocketFactory sslssf =\n-                (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();\n+    public void runTest() throws Exception {\n+        SSLServerSocketFactory sslssf = createServerSSLContext().getServerSocketFactory();\n@@ -80,2 +71,1 @@\n-        SSLSocketFactory sslsf =\n-            (SSLSocketFactory)SSLSocketFactory.getDefault();\n+        SSLSocketFactory sslsf = createClientSSLContext().getSocketFactory();\n@@ -86,1 +76,1 @@\n-        (new Thread(this)).start();\n+        new Thread(this).start();\n@@ -97,1 +87,0 @@\n-        System.out.println(\"Calling Socket.close\");\n@@ -99,3 +88,5 @@\n-        \/\/ Sleep for a while so that the write thread blocks by hitting the\n-        \/\/ output stream buffer limit.\n-        Thread.sleep(1000);\n+        \/\/ if the writeLock is not released by the other thread within 10\n+        \/\/ seconds it is probably blocked, and we can try to close the socket\n+        while (writeLock.tryLock(10, TimeUnit.SECONDS)) {\n+            writeLock.unlock();\n+        }\n@@ -103,0 +94,1 @@\n+        System.out.println(\"Calling socket.close()\");\n@@ -104,1 +96,0 @@\n-        System.out.println(\"ssl socket get closed\");\n@@ -111,3 +102,1 @@\n-        for (int i = 0; i < ba.length; i++) {\n-            ba[i] = 0x7A;\n-        }\n+        Arrays.fill(ba, (byte) 0x7A);\n@@ -131,0 +120,1 @@\n+\n@@ -132,0 +122,2 @@\n+\n+                writeLock.lock();\n@@ -133,0 +125,5 @@\n+                \/\/ This isn't in a try\/finally. If an exception is thrown\n+                \/\/ and the lock is released, the main thread will\n+                \/\/ loop until the test times out. So don't release it.\n+                writeLock.unlock();\n+\n@@ -147,1 +144,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/BlockedAsyncClose.java","additions":33,"deletions":37,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -215,2 +215,2 @@\n-            \"ClassWriterImpl\",\n-            \"ConstantsSummaryWriterImpl\",\n+            \"ClassWriter\",\n+            \"ConstantsSummaryWriter\",\n@@ -224,1 +224,1 @@\n-            \"ModuleWriterImpl\",\n+            \"ModuleWriter\",\n@@ -228,1 +228,1 @@\n-            \"PackageWriterImpl\",\n+            \"PackageWriter\",\n@@ -230,1 +230,1 @@\n-            \"SerializedFormWriterImpl\",\n+            \"SerializedFormWriter\",\n@@ -324,4 +324,4 @@\n-            case \"AnnotationTypeWriterImpl\":\n-            case \"ClassWriterImpl\":\n-            case \"ModuleWriterImpl\":\n-            case \"PackageWriterImpl\":\n+            case \"AnnotationTypeWriter\":\n+            case \"ClassWriter\":\n+            case \"ModuleWriter\":\n+            case \"PackageWriter\":\n@@ -336,1 +336,1 @@\n-            case \"ConstantsSummaryWriterImpl\":\n+            case \"ConstantsSummaryWriter\":\n@@ -373,1 +373,1 @@\n-            case \"SerializedFormWriterImpl\":\n+            case \"SerializedFormWriter\":\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMetadata\/TestMetadata.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *           8175200 8186332 8182765 8196202 8187288 8173730 8215307\n+ *           8175200 8186332 8182765 8196202 8187288 8173730 8215307 8312445\n@@ -678,1 +678,1 @@\n-                    <a href=\"A.html#c()\">c<\/a>=<a href=\"..\/pkg2\/Foo.html\" title=\"class in pkg2\">Foo.class<\/a>,\"\"\",\n+                    <a href=\"A.html#c()\">c<\/a>=<a href=\"..\/pkg2\/Foo.html\" title=\"class in pkg2\">Foo<\/a>.class,\"\"\",\n@@ -682,1 +682,1 @@\n-                    ass in pkg\">TypeParameterSubClass.class<\/a>,\"\"\",\n+                    ass in pkg\">TypeParameterSubClass<\/a>.class,\"\"\",\n@@ -697,1 +697,10 @@\n-                    <a href=\"A.html#primitiveClassTest()\">primitiveClassTest<\/a>=boolean.class,\"\"\");\n+                    <a href=\"A.html#primitiveClassTest()\">primitiveClassTest<\/a>=boolean.class,\"\"\",\n+                \/\/ Arrays\n+                \"\"\"\n+                    <a href=\"A.html#arrayClassTest()\">arrayClassTest<\/a>=java.lang.String[][].class,\"\"\",\n+                \"\"\"\n+                    <a href=\"A.html#arrayPrimitiveTest()\">arrayPrimitiveTest<\/a>=boolean[].class,\"\"\",\n+                \"\"\"\n+                    <a href=\"A.html#classArrayTest()\">classArrayTest<\/a>={<a href=\"..\/pkg\/TypeParame\\\n+                    terSubClass.html\" title=\"class in pkg\">TypeParameterSubClass<\/a>[][].class,java.\\\n+                    lang.String.class,long[][][].class})\"\"\");\n@@ -699,2 +708,0 @@\n-        \/\/ XXX:  Add array test case after this if fixed:\n-        \/\/5020899: Incorrect internal representation of class-valued annotation elements\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/TestNewLanguageFeatures.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-    Class c();\n+    Class<?> c();\n@@ -40,3 +40,4 @@\n-    Class primitiveClassTest();\n-    Class arrayClassTest();\n-    Class arrayPrimitiveTest();\n+    Class<?> primitiveClassTest();\n+    Class<?> arrayClassTest();\n+    Class<?> arrayPrimitiveTest();\n+    Class<?>[] classArrayTest();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/pkg1\/A.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,3 @@\n-   arrayClassTest = String[].class,\n-   arrayPrimitiveTest = boolean[].class)\n+   arrayClassTest = String[][].class,\n+   arrayPrimitiveTest = boolean[].class,\n+   classArrayTest = {TypeParameterSubClass[][].class, String.class, long[][][].class})\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/pkg1\/B.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.ineffectual.extern.method.enum\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+enum IneffectualExternEnum implements Externalizable {\n+    INSTANCE;\n+\n+    @Override\n+    public void writeExternal(ObjectOutput oo) {\n+        ;\n+    }\n+\n+    @Override\n+    public void readExternal(ObjectInput oi) {\n+        ;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IneffectualExternEnum.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.ineffectual.externalizable.method.record\n+\n+\/\/ options: -Xlint:serial\n+\n+import java.io.*;\n+\n+record IneffectualExternRecord(int foo) implements Externalizable {\n+    @Override\n+    public void writeExternal(ObjectOutput oo) {\n+        ;\n+    }\n+\n+    @Override\n+    public void readExternal(ObjectInput oi) {\n+        ;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IneffectualExternRecord.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.selector.type.not.allowed\n+\n+public class SelectorTypeNotAllowed {\n+    private void noLong(long sel) {\n+        switch (sel) {\n+            default -> {}\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SelectorTypeNotAllowed.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+ \/*\n+ * @test\n+ * @bug 8312229\n+ * @summary Ensure javac does not crash when a variable is used from an anonymous class\n+ * @compile T8312229.java\n+ *\/\n+public class T8312229 {\n+    void test(Object o) {\n+        Runnable r = () -> {\n+            var l = switch (o) {\n+                default -> {\n+                    Integer i = 42;\n+                    yield new Runnable() {\n+                        public void run() {\n+                            i.toString(); \/\/ should not crash here\n+                        }\n+                    };\n+                }\n+            };\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8312229.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -1,4 +1,4 @@\n-SwitchNoExtraTypes.java:12:18: compiler.err.constant.label.not.compatible: boolean, boolean\n-SwitchNoExtraTypes.java:18:18: compiler.err.constant.label.not.compatible: int, long\n-SwitchNoExtraTypes.java:24:18: compiler.err.constant.label.not.compatible: int, float\n-SwitchNoExtraTypes.java:30:18: compiler.err.constant.label.not.compatible: int, double\n+SwitchNoExtraTypes.java:11:16: compiler.err.selector.type.not.allowed: boolean\n+SwitchNoExtraTypes.java:17:16: compiler.err.selector.type.not.allowed: long\n+SwitchNoExtraTypes.java:23:16: compiler.err.selector.type.not.allowed: float\n+SwitchNoExtraTypes.java:29:16: compiler.err.selector.type.not.allowed: double\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,18 @@\n+EnumExternClassBody.java:25:25: compiler.warn.ineffectual.extern.method.enum: readExternal\n+EnumExternClassBody.java:30:25: compiler.warn.ineffectual.extern.method.enum: writeExternal\n+EnumExternClassBody.java:35:38: compiler.warn.ineffectual.serial.field.enum: serialVersionUID\n+EnumExternClassBody.java:36:53: compiler.warn.ineffectual.serial.field.enum: serialPersistentFields\n+EnumExternClassBody.java:38:25: compiler.warn.ineffectual.serial.method.enum: writeObject\n+EnumExternClassBody.java:42:27: compiler.warn.ineffectual.serial.method.enum: writeReplace\n+EnumExternClassBody.java:46:25: compiler.warn.ineffectual.serial.method.enum: readObject\n+EnumExternClassBody.java:51:25: compiler.warn.ineffectual.serial.method.enum: readObjectNoData\n+EnumExternClassBody.java:55:27: compiler.warn.ineffectual.serial.method.enum: readResolve\n+EnumExternClassBody.java:66:21: compiler.warn.ineffectual.extern.method.enum: readExternal\n+EnumExternClassBody.java:71:21: compiler.warn.ineffectual.extern.method.enum: writeExternal\n+EnumExternClassBody.java:83:25: compiler.warn.ineffectual.extern.method.enum: readExternal\n+EnumExternClassBody.java:88:25: compiler.warn.ineffectual.extern.method.enum: writeExternal\n+EnumExternClassBody.java:101:25: compiler.warn.ineffectual.extern.method.enum: readExternal\n+EnumExternClassBody.java:106:25: compiler.warn.ineffectual.extern.method.enum: writeExternal\n+EnumExternClassBody.java:112:30: compiler.warn.ineffectual.extern.method.enum: readExternal\n+EnumExternClassBody.java:113:30: compiler.warn.ineffectual.extern.method.enum: writeExternal\n+17 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/ClassBody.out","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8310835\n+ * @compile\/ref=EnumExtern.out -XDrawDiagnostics -Xlint:serial EnumExtern.java\n+ * @compile\/ref=empty.out      -XDrawDiagnostics               EnumExtern.java\n+ *\/\n+\n+import java.io.*;\n+\n+enum EnumExtern implements Externalizable {\n+    INSTANCE;\n+\n+    \/\/ Verify a warning is generated in an enum class for each of the\n+    \/\/ distinguished serial fields and methods as well as extern methods.\n+\n+    private static final long serialVersionUID = 42;\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    private Object writeReplace() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    private void readObjectNoData() throws ObjectStreamException {\n+        return;\n+    }\n+\n+    private Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    \/\/ ineffective Externalizable methods\n+    @Override\n+    public void writeExternal(ObjectOutput oo) {\n+        ;\n+    }\n+\n+    @Override\n+    public void readExternal(ObjectInput oi) {\n+        ;\n+    }\n+\n+    \/\/ _Not_ Externalizable methods; shouldn't generate a warning\n+    public void writeExternal() {\n+        ;\n+    }\n+\n+    public void readExternal() {\n+        ;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/EnumExtern.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+EnumExtern.java:16:31: compiler.warn.ineffectual.serial.field.enum: serialVersionUID\n+EnumExtern.java:17:46: compiler.warn.ineffectual.serial.field.enum: serialPersistentFields\n+EnumExtern.java:19:18: compiler.warn.ineffectual.serial.method.enum: writeObject\n+EnumExtern.java:23:20: compiler.warn.ineffectual.serial.method.enum: writeReplace\n+EnumExtern.java:27:18: compiler.warn.ineffectual.serial.method.enum: readObject\n+EnumExtern.java:32:18: compiler.warn.ineffectual.serial.method.enum: readObjectNoData\n+EnumExtern.java:36:20: compiler.warn.ineffectual.serial.method.enum: readResolve\n+EnumExtern.java:42:17: compiler.warn.ineffectual.extern.method.enum: writeExternal\n+EnumExtern.java:47:17: compiler.warn.ineffectual.extern.method.enum: readExternal\n+9 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/EnumExtern.out","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8312415\n+ * @compile\/ref=ClassBody.out -XDrawDiagnostics -Xlint:serial EnumExternClassBody.java\n+ * @compile\/ref=empty.out     -XDrawDiagnostics               EnumExternClassBody.java\n+ *\/\n+\n+import java.io.*;\n+\n+\/*\n+ * Verify warnings are generated as appropriate for enum constants\n+ * with specialized class bodies.\n+ *\/\n+class EnumExternClassBody {\n+\n+    \/*\n+     * Define externalization methods both in the enum class and a\n+     * specialized enum constant.\n+     *\/\n+    private static enum ColorExtern1 implements Externalizable {\n+        RED(  0xFF_00_00),\n+        GREEN(0x00_FF_00),\n+        BLUE( 0x00_00_FF) {\n+           @Override\n+            public void readExternal(ObjectInput in) {\n+                throw new RuntimeException();\n+            }\n+\n+           @Override\n+            public void writeExternal(ObjectOutput out) throws IOException {\n+                throw new RuntimeException();\n+            }\n+\n+           \/\/ Look for serialization members too\n+           private static final long serialVersionUID = 42;\n+           private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+           private void writeObject(ObjectOutputStream stream) throws IOException {\n+                throw new RuntimeException();\n+           }\n+\n+           private Object writeReplace() throws ObjectStreamException {\n+               return null;\n+           }\n+\n+           private void readObject(ObjectInputStream stream)\n+               throws IOException, ClassNotFoundException {\n+                throw new RuntimeException();\n+           }\n+\n+           private void readObjectNoData() throws ObjectStreamException {\n+               return;\n+           }\n+\n+           private Object readResolve() throws ObjectStreamException {\n+               return null;\n+           }\n+        };\n+\n+        int rgb;\n+        private ColorExtern1(int rgb) {\n+            this.rgb = rgb;\n+        }\n+\n+        @Override\n+        public void readExternal(ObjectInput in) {\n+            throw new RuntimeException();\n+        }\n+\n+        @Override\n+        public void writeExternal(ObjectOutput out) throws IOException {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/*\n+     * Define externalization methods only on specialized enum\n+     * constants.\n+     *\/\n+    private static enum ColorExtern2 implements Externalizable {\n+        CYAN {\n+           @Override\n+            public void readExternal(ObjectInput in) {\n+                throw new RuntimeException();\n+            }\n+\n+           @Override\n+            public void writeExternal(ObjectOutput out) throws IOException {\n+                throw new RuntimeException();\n+            }\n+        };\n+    }\n+\n+    \/*\n+     * Define externalization methods only on specialized enum\n+     * constants.\n+     *\/\n+    private static enum ColorExtern3 implements Externalizable {\n+        MAGENTA {\n+           @Override\n+            public void readExternal(ObjectInput in) {\n+                throw new RuntimeException();\n+            }\n+\n+           @Override\n+            public void writeExternal(ObjectOutput out) throws IOException {\n+                throw new RuntimeException();\n+            }\n+        };\n+\n+        \/\/ Acceptable to have ineffectual warnings for these abstract methods\n+        public abstract void readExternal(ObjectInput in);\n+        public abstract void writeExternal(ObjectOutput out) throws IOException ;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/EnumExternClassBody.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/ref=empty.out -XDrawDiagnostics               EnumSerial.java\n+ * @compile\/ref=empty.out      -XDrawDiagnostics               EnumSerial.java\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/EnumSerial.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8310835\n+ * @compile\/ref=RecordExtern.out -XDrawDiagnostics -Xlint:serial RecordExtern.java\n+ *\/\n+\n+import java.io.*;\n+\n+record RecordExtern(int foo) implements Externalizable {\n+    \/\/ Verify a warning is generated in a record class for each of the\n+    \/\/ ineffectual extern methods.\n+\n+    \/\/ ineffective Externalizable methods\n+    @Override\n+    public void writeExternal(ObjectOutput oo) {\n+        ;\n+    }\n+\n+    @Override\n+    public void readExternal(ObjectInput oi) {\n+        ;\n+    }\n+\n+    \/\/ *Not* Externalizable methods; shouldn't generate a warning\n+    public void writeExternal() {\n+        ;\n+    }\n+\n+    public void readExternal() {\n+        ;\n+    }\n+\n+    \/\/ Check warnings for serialization methods and fields too\n+\n+    \/\/ partially effective\n+    private static final long serialVersionUID = 42;\n+\n+    \/\/ ineffectual\n+    private static final ObjectStreamField[] serialPersistentFields = {};\n+\n+    \/\/ ineffectual\n+    private void writeObject(ObjectOutputStream stream) throws IOException {\n+        stream.defaultWriteObject();\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object writeReplace() throws ObjectStreamException {\n+        return null;\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObject(ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+    }\n+\n+    \/\/ ineffectual\n+    private void readObjectNoData() throws ObjectStreamException {\n+        return;\n+    }\n+\n+    \/\/ (possibly) effective\n+    private Object readResolve() throws ObjectStreamException {\n+        return null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/RecordExtern.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+RecordExtern.java:15:17: compiler.warn.ineffectual.externalizable.method.record: writeExternal\n+RecordExtern.java:20:17: compiler.warn.ineffectual.externalizable.method.record: readExternal\n+RecordExtern.java:39:46: compiler.warn.ineffectual.serial.field.record\n+RecordExtern.java:42:18: compiler.warn.ineffectual.serial.method.record: writeObject\n+RecordExtern.java:52:18: compiler.warn.ineffectual.serial.method.record: readObject\n+RecordExtern.java:58:18: compiler.warn.ineffectual.serial.method.record: readObjectNoData\n+6 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/RecordExtern.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -784,0 +784,2 @@\n+\n+  public native void preTouchMemory(long addr, long size);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,578 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorExtractBenchmark {\n+    private int idx = 0;\n+    private boolean[] res = new boolean[8];\n+\n+    private static final VectorMask bmask64 = VectorMask.fromLong(ByteVector.SPECIES_64, 1L);\n+    private static final VectorMask bmask128 = VectorMask.fromLong(ByteVector.SPECIES_128, 1L);\n+    private static final VectorMask bmask256 = VectorMask.fromLong(ByteVector.SPECIES_256, 1L);\n+    private static final VectorMask bmask512 = VectorMask.fromLong(ByteVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask smask64 = VectorMask.fromLong(ShortVector.SPECIES_64, 1L);\n+    private static final VectorMask smask128 = VectorMask.fromLong(ShortVector.SPECIES_128, 1L);\n+    private static final VectorMask smask256 = VectorMask.fromLong(ShortVector.SPECIES_256, 1L);\n+    private static final VectorMask smask512 = VectorMask.fromLong(ShortVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask imask64 = VectorMask.fromLong(IntVector.SPECIES_64, 1L);\n+    private static final VectorMask imask128 = VectorMask.fromLong(IntVector.SPECIES_128, 1L);\n+    private static final VectorMask imask256 = VectorMask.fromLong(IntVector.SPECIES_256, 1L);\n+    private static final VectorMask imask512 = VectorMask.fromLong(IntVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask lmask64 = VectorMask.fromLong(LongVector.SPECIES_64, 1L);\n+    private static final VectorMask lmask128 = VectorMask.fromLong(LongVector.SPECIES_128, 1L);\n+    private static final VectorMask lmask256 = VectorMask.fromLong(LongVector.SPECIES_256, 1L);\n+    private static final VectorMask lmask512 = VectorMask.fromLong(LongVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask fmask64 = VectorMask.fromLong(FloatVector.SPECIES_64, 1L);\n+    private static final VectorMask fmask128 = VectorMask.fromLong(FloatVector.SPECIES_128, 1L);\n+    private static final VectorMask fmask256 = VectorMask.fromLong(FloatVector.SPECIES_256, 1L);\n+    private static final VectorMask fmask512 = VectorMask.fromLong(FloatVector.SPECIES_512, 1L);\n+\n+    private static final VectorMask dmask64 = VectorMask.fromLong(DoubleVector.SPECIES_64, 1L);\n+    private static final VectorMask dmask128 = VectorMask.fromLong(DoubleVector.SPECIES_128, 1L);\n+    private static final VectorMask dmask256 = VectorMask.fromLong(DoubleVector.SPECIES_256, 1L);\n+    private static final VectorMask dmask512 = VectorMask.fromLong(DoubleVector.SPECIES_512, 1L);\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte64_con() {\n+        res[0] = bmask64.laneIsSet(0);\n+        res[1] = bmask64.laneIsSet(1);\n+        res[2] = bmask64.laneIsSet(2);\n+        res[3] = bmask64.laneIsSet(3);\n+        res[4] = bmask64.laneIsSet(4);\n+        res[5] = bmask64.laneIsSet(5);\n+        res[6] = bmask64.laneIsSet(6);\n+        res[7] = bmask64.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte64_var() {\n+        res[0] = bmask64.laneIsSet(idx);\n+        res[1] = bmask64.laneIsSet(idx + 1);\n+        res[2] = bmask64.laneIsSet(idx + 2);\n+        res[3] = bmask64.laneIsSet(idx + 3);\n+        res[4] = bmask64.laneIsSet(idx + 4);\n+        res[5] = bmask64.laneIsSet(idx + 5);\n+        res[6] = bmask64.laneIsSet(idx + 6);\n+        res[7] = bmask64.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte128_con() {\n+        res[0] = bmask128.laneIsSet(0);\n+        res[1] = bmask128.laneIsSet(1);\n+        res[2] = bmask128.laneIsSet(2);\n+        res[3] = bmask128.laneIsSet(3);\n+        res[4] = bmask128.laneIsSet(12);\n+        res[5] = bmask128.laneIsSet(13);\n+        res[6] = bmask128.laneIsSet(14);\n+        res[7] = bmask128.laneIsSet(15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte128_var() {\n+        res[0] = bmask128.laneIsSet(idx);\n+        res[1] = bmask128.laneIsSet(idx + 1);\n+        res[2] = bmask128.laneIsSet(idx + 2);\n+        res[3] = bmask128.laneIsSet(idx + 3);\n+        res[4] = bmask128.laneIsSet(idx + 12);\n+        res[5] = bmask128.laneIsSet(idx + 13);\n+        res[6] = bmask128.laneIsSet(idx + 14);\n+        res[7] = bmask128.laneIsSet(idx + 15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte256_con() {\n+        res[0] = bmask256.laneIsSet(0);\n+        res[1] = bmask256.laneIsSet(1);\n+        res[2] = bmask256.laneIsSet(2);\n+        res[3] = bmask256.laneIsSet(3);\n+        res[4] = bmask256.laneIsSet(28);\n+        res[5] = bmask256.laneIsSet(29);\n+        res[6] = bmask256.laneIsSet(30);\n+        res[7] = bmask256.laneIsSet(31);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte256_var() {\n+        res[0] = bmask256.laneIsSet(idx);\n+        res[1] = bmask256.laneIsSet(idx + 1);\n+        res[2] = bmask256.laneIsSet(idx + 2);\n+        res[3] = bmask256.laneIsSet(idx + 3);\n+        res[4] = bmask256.laneIsSet(idx + 28);\n+        res[5] = bmask256.laneIsSet(idx + 29);\n+        res[6] = bmask256.laneIsSet(idx + 30);\n+        res[7] = bmask256.laneIsSet(idx + 31);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte512_con() {\n+        res[0] = bmask512.laneIsSet(0);\n+        res[1] = bmask512.laneIsSet(1);\n+        res[2] = bmask512.laneIsSet(2);\n+        res[3] = bmask512.laneIsSet(3);\n+        res[4] = bmask512.laneIsSet(60);\n+        res[5] = bmask512.laneIsSet(61);\n+        res[6] = bmask512.laneIsSet(62);\n+        res[7] = bmask512.laneIsSet(63);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetByte512_var() {\n+        res[0] = bmask512.laneIsSet(idx);\n+        res[1] = bmask512.laneIsSet(idx + 1);\n+        res[2] = bmask512.laneIsSet(idx + 2);\n+        res[3] = bmask512.laneIsSet(idx + 3);\n+        res[4] = bmask512.laneIsSet(idx + 60);\n+        res[5] = bmask512.laneIsSet(idx + 61);\n+        res[6] = bmask512.laneIsSet(idx + 62);\n+        res[7] = bmask512.laneIsSet(idx + 63);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort64_con() {\n+        res[0] = smask64.laneIsSet(0);\n+        res[1] = smask64.laneIsSet(1);\n+        res[2] = smask64.laneIsSet(2);\n+        res[3] = smask64.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort64_var() {\n+        res[0] = smask64.laneIsSet(idx);\n+        res[1] = smask64.laneIsSet(idx + 1);\n+        res[2] = smask64.laneIsSet(idx + 2);\n+        res[3] = smask64.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort128_con() {\n+        res[0] = smask128.laneIsSet(0);\n+        res[1] = smask128.laneIsSet(1);\n+        res[2] = smask128.laneIsSet(2);\n+        res[3] = smask128.laneIsSet(3);\n+        res[4] = smask128.laneIsSet(4);\n+        res[5] = smask128.laneIsSet(5);\n+        res[6] = smask128.laneIsSet(6);\n+        res[7] = smask128.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort128_var() {\n+        res[0] = smask128.laneIsSet(idx);\n+        res[1] = smask128.laneIsSet(idx + 1);\n+        res[2] = smask128.laneIsSet(idx + 2);\n+        res[3] = smask128.laneIsSet(idx + 3);\n+        res[4] = smask128.laneIsSet(idx + 4);\n+        res[5] = smask128.laneIsSet(idx + 5);\n+        res[6] = smask128.laneIsSet(idx + 6);\n+        res[7] = smask128.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort256_con() {\n+        res[0] = smask256.laneIsSet(0);\n+        res[1] = smask256.laneIsSet(1);\n+        res[2] = smask256.laneIsSet(2);\n+        res[3] = smask256.laneIsSet(3);\n+        res[4] = smask256.laneIsSet(12);\n+        res[5] = smask256.laneIsSet(13);\n+        res[6] = smask256.laneIsSet(14);\n+        res[7] = smask256.laneIsSet(15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort256_var() {\n+        res[0] = smask256.laneIsSet(idx);\n+        res[1] = smask256.laneIsSet(idx + 1);\n+        res[2] = smask256.laneIsSet(idx + 2);\n+        res[3] = smask256.laneIsSet(idx + 3);\n+        res[4] = smask256.laneIsSet(idx + 12);\n+        res[5] = smask256.laneIsSet(idx + 13);\n+        res[6] = smask256.laneIsSet(idx + 14);\n+        res[7] = smask256.laneIsSet(idx + 15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort512_con() {\n+        res[0] = smask512.laneIsSet(0);\n+        res[1] = smask512.laneIsSet(1);\n+        res[2] = smask512.laneIsSet(2);\n+        res[3] = smask512.laneIsSet(3);\n+        res[4] = smask512.laneIsSet(28);\n+        res[5] = smask512.laneIsSet(29);\n+        res[6] = smask512.laneIsSet(30);\n+        res[7] = smask512.laneIsSet(31);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetShort512_var() {\n+        res[0] = smask512.laneIsSet(idx);\n+        res[1] = smask512.laneIsSet(idx + 1);\n+        res[2] = smask512.laneIsSet(idx + 2);\n+        res[3] = smask512.laneIsSet(idx + 3);\n+        res[4] = smask512.laneIsSet(idx + 28);\n+        res[5] = smask512.laneIsSet(idx + 29);\n+        res[6] = smask512.laneIsSet(idx + 30);\n+        res[7] = smask512.laneIsSet(idx + 31);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt64_con() {\n+        res[0] = imask64.laneIsSet(0);\n+        res[1] = imask64.laneIsSet(1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt64_var() {\n+        res[0] = imask64.laneIsSet(idx);\n+        res[1] = imask64.laneIsSet(idx + 1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt128_con() {\n+        res[0] = imask128.laneIsSet(0);\n+        res[1] = imask128.laneIsSet(1);\n+        res[2] = imask128.laneIsSet(2);\n+        res[3] = imask128.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt128_var() {\n+        res[0] = imask128.laneIsSet(idx);\n+        res[1] = imask128.laneIsSet(idx + 1);\n+        res[2] = imask128.laneIsSet(idx + 2);\n+        res[3] = imask128.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt256_con() {\n+        res[0] = imask256.laneIsSet(0);\n+        res[1] = imask256.laneIsSet(1);\n+        res[2] = imask256.laneIsSet(2);\n+        res[3] = imask256.laneIsSet(3);\n+        res[4] = imask256.laneIsSet(4);\n+        res[5] = imask256.laneIsSet(5);\n+        res[6] = imask256.laneIsSet(6);\n+        res[7] = imask256.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt256_var() {\n+        res[0] = imask256.laneIsSet(idx);\n+        res[1] = imask256.laneIsSet(idx + 1);\n+        res[2] = imask256.laneIsSet(idx + 2);\n+        res[3] = imask256.laneIsSet(idx + 3);\n+        res[4] = imask256.laneIsSet(idx + 4);\n+        res[5] = imask256.laneIsSet(idx + 5);\n+        res[6] = imask256.laneIsSet(idx + 6);\n+        res[7] = imask256.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt512_con() {\n+        res[0] = imask512.laneIsSet(0);\n+        res[1] = imask512.laneIsSet(1);\n+        res[2] = imask512.laneIsSet(2);\n+        res[3] = imask512.laneIsSet(3);\n+        res[4] = imask512.laneIsSet(12);\n+        res[5] = imask512.laneIsSet(13);\n+        res[6] = imask512.laneIsSet(14);\n+        res[7] = imask512.laneIsSet(15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetInt512_var() {\n+        res[0] = imask512.laneIsSet(idx);\n+        res[1] = imask512.laneIsSet(idx + 1);\n+        res[2] = imask512.laneIsSet(idx + 2);\n+        res[3] = imask512.laneIsSet(idx + 3);\n+        res[4] = imask512.laneIsSet(idx + 12);\n+        res[5] = imask512.laneIsSet(idx + 13);\n+        res[6] = imask512.laneIsSet(idx + 14);\n+        res[7] = imask512.laneIsSet(idx + 15);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong64_con() {\n+        res[0] = lmask64.laneIsSet(0);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong64_var() {\n+        res[0] = lmask64.laneIsSet(idx);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong128_con() {\n+        res[0] = lmask128.laneIsSet(0);\n+        res[1] = lmask128.laneIsSet(1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong128_var() {\n+        res[0] = lmask128.laneIsSet(idx);\n+        res[1] = lmask128.laneIsSet(idx + 1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong256_con() {\n+        res[0] = lmask256.laneIsSet(0);\n+        res[1] = lmask256.laneIsSet(1);\n+        res[2] = lmask256.laneIsSet(2);\n+        res[3] = lmask256.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong256_var() {\n+        res[0] = lmask256.laneIsSet(idx);\n+        res[1] = lmask256.laneIsSet(idx + 1);\n+        res[2] = lmask256.laneIsSet(idx + 2);\n+        res[3] = lmask256.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong512_con() {\n+        res[0] = lmask512.laneIsSet(0);\n+        res[1] = lmask512.laneIsSet(1);\n+        res[2] = lmask512.laneIsSet(2);\n+        res[3] = lmask512.laneIsSet(3);\n+        res[4] = lmask512.laneIsSet(4);\n+        res[5] = lmask512.laneIsSet(5);\n+        res[6] = lmask512.laneIsSet(6);\n+        res[7] = lmask512.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetLong512_var() {\n+        res[0] = lmask512.laneIsSet(idx);\n+        res[1] = lmask512.laneIsSet(idx + 1);\n+        res[2] = lmask512.laneIsSet(idx + 2);\n+        res[3] = lmask512.laneIsSet(idx + 3);\n+        res[4] = lmask512.laneIsSet(idx + 4);\n+        res[5] = lmask512.laneIsSet(idx + 5);\n+        res[6] = lmask512.laneIsSet(idx + 6);\n+        res[7] = lmask512.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat64_con() {\n+        res[0] = fmask64.laneIsSet(0);\n+        res[1] = fmask64.laneIsSet(1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat64_var() {\n+        res[0] = fmask64.laneIsSet(idx);\n+        res[1] = fmask64.laneIsSet(idx + 1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat128_con() {\n+        res[0] = fmask128.laneIsSet(0);\n+        res[1] = fmask128.laneIsSet(1);\n+        res[2] = fmask128.laneIsSet(2);\n+        res[3] = fmask128.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat128_var() {\n+        res[0] = fmask128.laneIsSet(idx);\n+        res[1] = fmask128.laneIsSet(idx + 1);\n+        res[2] = fmask128.laneIsSet(idx + 2);\n+        res[3] = fmask128.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat256_con() {\n+        res[0] = fmask256.laneIsSet(0);\n+        res[1] = fmask256.laneIsSet(1);\n+        res[2] = fmask256.laneIsSet(2);\n+        res[3] = fmask256.laneIsSet(3);\n+        res[4] = fmask256.laneIsSet(4);\n+        res[5] = fmask256.laneIsSet(5);\n+        res[6] = fmask256.laneIsSet(6);\n+        res[7] = fmask256.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat256_var() {\n+        res[0] = fmask256.laneIsSet(idx);\n+        res[1] = fmask256.laneIsSet(idx + 1);\n+        res[2] = fmask256.laneIsSet(idx + 2);\n+        res[3] = fmask256.laneIsSet(idx + 3);\n+        res[4] = fmask256.laneIsSet(idx + 4);\n+        res[5] = fmask256.laneIsSet(idx + 5);\n+        res[6] = fmask256.laneIsSet(idx + 6);\n+        res[7] = fmask256.laneIsSet(idx + 7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat512_con() {\n+        res[0] = fmask512.laneIsSet(0);\n+        res[1] = fmask512.laneIsSet(1);\n+        res[2] = fmask512.laneIsSet(2);\n+        res[3] = fmask512.laneIsSet(3);\n+        res[4] = fmask512.laneIsSet(12);\n+        res[5] = fmask512.laneIsSet(13);\n+        res[6] = fmask512.laneIsSet(14);\n+        res[7] = fmask512.laneIsSet(15);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetFloat512_var() {\n+        res[0] = fmask512.laneIsSet(idx);\n+        res[1] = fmask512.laneIsSet(idx + 1);\n+        res[2] = fmask512.laneIsSet(idx + 2);\n+        res[3] = fmask512.laneIsSet(idx + 3);\n+        res[4] = fmask512.laneIsSet(idx + 12);\n+        res[5] = fmask512.laneIsSet(idx + 13);\n+        res[6] = fmask512.laneIsSet(idx + 14);\n+        res[7] = fmask512.laneIsSet(idx + 15);\n+        return res;\n+    }\n+\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble64_con() {\n+        res[0] = dmask64.laneIsSet(0);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble64_var() {\n+        res[0] = dmask64.laneIsSet(idx);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble128_con() {\n+        res[0] = dmask128.laneIsSet(0);\n+        res[1] = dmask128.laneIsSet(1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble128_var() {\n+        res[0] = dmask128.laneIsSet(idx);\n+        res[1] = dmask128.laneIsSet(idx + 1);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble256_con() {\n+        res[0] = dmask256.laneIsSet(0);\n+        res[1] = dmask256.laneIsSet(1);\n+        res[2] = dmask256.laneIsSet(2);\n+        res[3] = dmask256.laneIsSet(3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble256_var() {\n+        res[0] = dmask256.laneIsSet(idx);\n+        res[1] = dmask256.laneIsSet(idx + 1);\n+        res[2] = dmask256.laneIsSet(idx + 2);\n+        res[3] = dmask256.laneIsSet(idx + 3);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble512_con() {\n+        res[0] = dmask512.laneIsSet(0);\n+        res[1] = dmask512.laneIsSet(1);\n+        res[2] = dmask512.laneIsSet(2);\n+        res[3] = dmask512.laneIsSet(3);\n+        res[4] = dmask512.laneIsSet(4);\n+        res[5] = dmask512.laneIsSet(5);\n+        res[6] = dmask512.laneIsSet(6);\n+        res[7] = dmask512.laneIsSet(7);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public boolean[] microMaskLaneIsSetDouble512_var() {\n+        res[0] = dmask512.laneIsSet(idx);\n+        res[1] = dmask512.laneIsSet(idx + 1);\n+        res[2] = dmask512.laneIsSet(idx + 2);\n+        res[3] = dmask512.laneIsSet(idx + 3);\n+        res[4] = dmask512.laneIsSet(idx + 4);\n+        res[5] = dmask512.laneIsSet(idx + 5);\n+        res[6] = dmask512.laneIsSet(idx + 6);\n+        res[7] = dmask512.laneIsSet(idx + 7);\n+        return res;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorExtractBenchmark.java","additions":578,"deletions":0,"binary":false,"changes":578,"status":"added"}]}