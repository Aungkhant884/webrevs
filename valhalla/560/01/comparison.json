{"files":[{"patch":"@@ -4842,2 +4842,2 @@\n-    const Type* elem = tary->_elem;\n-    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(),\n+    const Type* res_elem = NULL;\n+    if (meet_aryptr(ptr, _ary->_elem, tap->_ary->_elem, this->klass(), tap->klass(),\n@@ -4847,1 +4847,1 @@\n-                    res_klass, res_xk, res_not_flat, res_not_null_free) == NOT_SUBTYPE) {\n+                    res_elem, res_klass, res_xk, res_not_flat, res_not_null_free) == NOT_SUBTYPE) {\n@@ -4877,1 +4877,1 @@\n-    return make(ptr, o, TypeAry::make(elem, tary->_size, tary->_stable, res_not_flat, res_not_null_free), res_klass, res_xk, off, field_off, instance_id, speculative, depth);\n+    return make(ptr, o, TypeAry::make(res_elem, tary->_size, tary->_stable, res_not_flat, res_not_null_free), res_klass, res_xk, off, field_off, instance_id, speculative, depth);\n@@ -4948,1 +4948,2 @@\n-TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass,\n+TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type* this_elem, const Type* tap_elem,\n+                                         ciKlass* this_klass, ciKlass* tap_klass,\n@@ -4952,1 +4953,2 @@\n-                                         ciKlass*& res_klass, bool& res_xk, bool& res_not_flat, bool& res_not_null_free) {\n+                                         const Type*& res_elem, ciKlass*& res_klass,\n+                                         bool& res_xk, bool& res_not_flat, bool& res_not_null_free) {\n@@ -4955,0 +4957,1 @@\n+  res_elem = this_elem->meet(tap_elem);\n@@ -4958,1 +4961,1 @@\n-  if (elem->isa_int()) {\n+  if (res_elem->isa_int()) {\n@@ -4969,1 +4972,1 @@\n-      elem = Type::BOTTOM;\n+      res_elem = Type::BOTTOM;\n@@ -4984,3 +4987,3 @@\n-      if (above_centerline(ptr) || (elem->make_ptr() && above_centerline(elem->make_ptr()->_ptr)) ||\n-          elem->isa_inlinetype()) {\n-        elem = Type::BOTTOM;\n+      if (above_centerline(ptr) || (res_elem->make_ptr() && above_centerline(res_elem->make_ptr()->_ptr)) ||\n+          res_elem->isa_inlinetype()) {\n+        res_elem = Type::BOTTOM;\n@@ -5000,0 +5003,3 @@\n+        if (this_elem->isa_inlinetype()) {\n+          res_elem = this_elem;\n+        }\n@@ -5003,1 +5009,1 @@\n-      return result;\n+      break;\n@@ -5013,1 +5019,1 @@\n-      return result;\n+      break;\n@@ -5020,0 +5026,3 @@\n+        if (tap_elem->isa_inlinetype()) {\n+          res_elem = tap_elem;\n+        }\n@@ -5024,1 +5033,1 @@\n-      return result;\n+      break;\n@@ -5030,0 +5039,1 @@\n+\n@@ -5928,1 +5938,1 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, int null_free) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n@@ -5932,1 +5942,1 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset, bool not_flat, bool not_null_free, int null_free) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n@@ -5937,1 +5947,7 @@\n-    const TypeAryKlassPtr* res = TypeAryKlassPtr::make(ptr, etype, NULL, offset, not_flat, not_null_free, null_free ? 1 : 0);\n+\n+    \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+    if (etype->klass_is_exact() && etype->isa_instklassptr() && etype->is_instklassptr()->klass()->is_inlinetype() && !null_free) {\n+      etype = TypeInstKlassPtr::make(NotNull, etype->is_instklassptr()->klass(), Offset(etype->is_instklassptr()->offset()), etype->is_instklassptr()->flatten_array());\n+    }\n+\n+    const TypeAryKlassPtr* res = TypeAryKlassPtr::make(ptr, etype, NULL, offset, not_flat, not_null_free, null_free);\n@@ -5954,11 +5970,6 @@\n-  bool not_null_free = k->is_array_klass() && (k->as_array_klass()->element_klass() == NULL ||\n-                                               !k->as_array_klass()->element_klass()->can_be_inline_klass(true));\n-  bool not_flat = k->is_array_klass() && !k->is_flat_array_klass();\n-  bool null_free = k->is_array_klass() && k->as_array_klass()->is_elem_null_free();\n-  if (k->is_obj_array_klass() && ptr == Constant) {\n-    \/\/ An object array can't be flat or null-free if the klass is exact\n-    not_flat = true;\n-    if (!null_free) {\n-      not_null_free = true;\n-    }\n-  }\n+  bool null_free = k->as_array_klass()->is_elem_null_free();\n+  bool not_null_free = ptr == Constant ? !null_free : !k->is_flat_array_klass() && (k->is_type_array_klass() || !k->as_array_klass()->element_klass()->can_be_inline_klass(false));\n+\n+  bool not_flat = !UseFlatArray || not_null_free || (k->as_array_klass()->element_klass() != NULL &&\n+                                                     k->as_array_klass()->element_klass()->is_inlinetype() &&\n+                                                     !k->as_array_klass()->element_klass()->flatten_array());\n@@ -6133,1 +6144,1 @@\n-  bool null_free = _null_free != 0;\n+  bool null_free = _null_free;\n@@ -6215,1 +6226,1 @@\n-    const Type* elem = _elem->meet(tap->_elem);\n+    const Type* res_elem = NULL;\n@@ -6221,1 +6232,2 @@\n-    MeetResult res = meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(),\n+    MeetResult res = meet_aryptr(ptr, _elem, tap->_elem, this->klass(), tap->klass(),\n+                                 this->klass_is_exact(), tap->klass_is_exact(),\n@@ -6224,1 +6236,1 @@\n-                                 res_klass, res_xk, res_not_flat, res_not_null_free);\n+                                 res_elem, res_klass, res_xk, res_not_flat, res_not_null_free);\n@@ -6226,1 +6238,1 @@\n-    int null_free = _null_free & tap->_null_free;\n+    bool null_free = meet_null_free(tap->_null_free);\n@@ -6228,1 +6240,1 @@\n-      null_free = 0;\n+      null_free = false;\n@@ -6230,11 +6242,0 @@\n-      \/\/ FIXME: should this be done for TypeAryPtr::xmeet() as well? Does this need to be moved into meet_aryptr()?\n-      if (above_centerline(tap->ptr()) && _elem->isa_inlinetype()) {\n-        elem = _elem;\n-      } else if (above_centerline(_ptr) && tap->_elem->isa_inlinetype()) {\n-        elem = tap->_elem;\n-      } else if (below_centerline(tap->ptr()) && _elem->isa_inlinetype()) {\n-        elem = tap->_elem;\n-      } else if (below_centerline(_ptr) && tap->_elem->isa_inlinetype()) {\n-        elem = _elem;\n-      }\n-\n@@ -6247,1 +6248,1 @@\n-    return make(ptr, elem, res_klass, off, res_not_flat, res_not_null_free, null_free);\n+    return make(ptr, res_elem, res_klass, off, res_not_flat, res_not_null_free, null_free);\n@@ -6310,1 +6311,1 @@\n-  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), -_null_free);\n+  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), dual_null_free());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":48,"deletions":47,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -1019,5 +1019,5 @@\n-  static MeetResult\n-  meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk,\n-              PTR this_ptr, PTR tap_ptr, bool this_not_flat, bool tap_not_flat,\n-              bool this_not_null_free, bool tap_not_null_free, ciKlass*& res_klass,\n-              bool& res_xk, bool& res_not_flat, bool& res_not_null_free);\n+\n+  static MeetResult meet_aryptr(PTR &ptr, const Type* this_elem, const Type* tap_elem, ciKlass* this_klass, ciKlass* tap_klass,\n+                                bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, bool this_not_flat, bool tap_not_flat,\n+                                bool this_not_null_free, bool tap_not_null_free, const Type*& res_elem, ciKlass*&res_klass,\n+                                bool &res_xk, bool &res_not_flat, bool &res_not_null_free);\n@@ -1613,1 +1613,1 @@\n-  const int _null_free;\n+  const bool _null_free;\n@@ -1621,0 +1621,8 @@\n+  bool dual_null_free() const {\n+    return _null_free;\n+  }\n+\n+  bool meet_null_free(bool other) const {\n+    return _null_free && other;\n+  }\n+\n@@ -1627,2 +1635,2 @@\n-  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, int null_free);\n-  static const TypeAryKlassPtr *make(PTR ptr, const Type *elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, int null_free);\n+  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free);\n+  static const TypeAryKlassPtr *make(PTR ptr, const Type *elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-        protected static final String MYVALUE_ARRAY_KLASS = \"\\\\[precise compiler\/valhalla\/inlinetypes\/MyValue\";\n+        protected static final String MYVALUE_ARRAY_KLASS = \"\\\\[(precise )?compiler\/valhalla\/inlinetypes\/MyValue\";\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}