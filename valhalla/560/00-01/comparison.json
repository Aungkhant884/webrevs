{"files":[{"patch":"@@ -5938,1 +5938,1 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, int null_free) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n@@ -5942,1 +5942,1 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset, bool not_flat, bool not_null_free, int null_free) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n@@ -5948,0 +5948,1 @@\n+    \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n@@ -5952,1 +5953,1 @@\n-    const TypeAryKlassPtr* res = TypeAryKlassPtr::make(ptr, etype, NULL, offset, not_flat, not_null_free, null_free ? 1 : 0);\n+    const TypeAryKlassPtr* res = TypeAryKlassPtr::make(ptr, etype, NULL, offset, not_flat, not_null_free, null_free);\n@@ -5969,11 +5970,6 @@\n-  bool not_null_free = k->is_array_klass() && (k->as_array_klass()->element_klass() == NULL ||\n-                                               !k->as_array_klass()->element_klass()->can_be_inline_klass(true));\n-  bool not_flat = k->is_array_klass() && !k->is_flat_array_klass();\n-  bool null_free = k->is_array_klass() && k->as_array_klass()->is_elem_null_free();\n-  if (k->is_obj_array_klass() && ptr == Constant) {\n-    \/\/ An object array can't be flat or null-free if the klass is exact\n-    not_flat = true;\n-    if (!null_free) {\n-      not_null_free = true;\n-    }\n-  }\n+  bool null_free = k->as_array_klass()->is_elem_null_free();\n+  bool not_null_free = ptr == Constant ? !null_free : !k->is_flat_array_klass() && (k->is_type_array_klass() || !k->as_array_klass()->element_klass()->can_be_inline_klass(false));\n+\n+  bool not_flat = !UseFlatArray || not_null_free || (k->as_array_klass()->element_klass() != NULL &&\n+                                                     k->as_array_klass()->element_klass()->is_inlinetype() &&\n+                                                     !k->as_array_klass()->element_klass()->flatten_array());\n@@ -6148,1 +6144,1 @@\n-  bool null_free = _null_free != 0;\n+  bool null_free = _null_free;\n@@ -6242,1 +6238,1 @@\n-    int null_free = _null_free & tap->_null_free;\n+    bool null_free = meet_null_free(tap->_null_free);\n@@ -6244,1 +6240,1 @@\n-      null_free = 0;\n+      null_free = false;\n@@ -6315,1 +6311,1 @@\n-  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), -_null_free);\n+  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), dual_null_free());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1613,1 +1613,1 @@\n-  const int _null_free;\n+  const bool _null_free;\n@@ -1621,0 +1621,8 @@\n+  bool dual_null_free() const {\n+    return _null_free;\n+  }\n+\n+  bool meet_null_free(bool other) const {\n+    return _null_free && other;\n+  }\n+\n@@ -1627,2 +1635,2 @@\n-  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, int null_free);\n-  static const TypeAryKlassPtr *make(PTR ptr, const Type *elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, int null_free);\n+  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free);\n+  static const TypeAryKlassPtr *make(PTR ptr, const Type *elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"}]}