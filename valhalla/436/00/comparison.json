{"files":[{"patch":"@@ -819,0 +819,2 @@\n+int java_lang_Class::_primary_mirror_offset;\n+int java_lang_Class::_secondary_mirror_offset;\n@@ -1055,2 +1057,2 @@\n-        InlineKlass* vk = InlineKlass::cast(InstanceKlass::cast(element_klass));\n-        comp_mirror = Handle(THREAD, vk->java_mirror());\n+        InlineKlass* vk = InlineKlass::cast(element_klass);\n+        comp_mirror = Handle(THREAD, vk->val_mirror());\n@@ -1064,1 +1066,6 @@\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+        oop comp_oop = element_klass->java_mirror();\n+        if (element_klass->is_inline_klass()) {\n+          InlineKlass* ik = InlineKlass::cast(element_klass);\n+          comp_oop = k->name()->is_Q_array_signature() ? ik->val_mirror() : ik->ref_mirror();\n+        }\n+        comp_mirror = Handle(THREAD, comp_oop);\n@@ -1104,0 +1111,6 @@\n+\n+    if (k->is_inline_klass()) {\n+      oop secondary_mirror = create_secondary_mirror(k, mirror, CHECK);\n+      set_primary_mirror(mirror(), mirror());\n+      set_secondary_mirror(mirror(), secondary_mirror);\n+    }\n@@ -1109,0 +1122,21 @@\n+\/\/ Create the secondary mirror for inline class. Sets all the fields of this java.lang.Class\n+\/\/ instance with the same value as the primary mirror\n+oop java_lang_Class::create_secondary_mirror(Klass* k, Handle mirror, TRAPS) {\n+  assert(k->is_inline_klass(), \"primitive class\");\n+  \/\/ Allocate mirror (java.lang.Class instance)\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK_0);\n+  Handle secondary_mirror(THREAD, mirror_oop);\n+\n+  java_lang_Class::set_klass(secondary_mirror(), k);\n+  java_lang_Class::set_static_oop_field_count(secondary_mirror(), static_oop_field_count(mirror()));\n+  \/\/ ## do we need to set init lock?\n+  java_lang_Class::set_init_lock(secondary_mirror(), init_lock(mirror()));\n+\n+  set_protection_domain(secondary_mirror(), protection_domain(mirror()));\n+  set_class_loader(secondary_mirror(), class_loader(mirror()));\n+  \/\/ ## handle if java.base is not yet defined\n+  set_module(secondary_mirror(), module(mirror()));\n+  set_primary_mirror(secondary_mirror(), mirror());\n+  set_secondary_mirror(secondary_mirror(), secondary_mirror());\n+  return secondary_mirror();\n+}\n@@ -1255,1 +1289,1 @@\n-    \/\/ Inline types have a val type mirror and a ref type mirror. Don't handle this for now. TODO:CDS\n+    \/\/ Inline types have a primary mirror and a secondary mirror. Don't handle this for now. TODO:CDS\n@@ -1475,0 +1509,20 @@\n+oop java_lang_Class::primary_mirror(oop java_class) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_primary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_primary_mirror(oop java_class, oop mirror) {\n+  assert(_primary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_primary_mirror_offset, mirror);\n+}\n+\n+oop java_lang_Class::secondary_mirror(oop java_class) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  return java_class->obj_field(_secondary_mirror_offset);\n+}\n+\n+void java_lang_Class::set_secondary_mirror(oop java_class, oop mirror) {\n+  assert(_secondary_mirror_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_secondary_mirror_offset, mirror);\n+}\n+\n@@ -1578,1 +1632,1 @@\n-  bool is_value = false;\n+  bool is_Q_descriptor = false;\n@@ -1584,1 +1638,1 @@\n-    is_value = k->is_inline_klass();\n+    is_Q_descriptor = k->is_inline_klass() && is_secondary_mirror(java_class);\n@@ -1592,5 +1646,1 @@\n-    if (is_value) {\n-      st->print(\"Q\");\n-    } else {\n-      st->print(\"L\");\n-    }\n+    st->print(is_Q_descriptor ? \"Q\" : \"L\");\n@@ -1618,1 +1668,6 @@\n-      const char* sigstr = k->signature_name();\n+      const char* sigstr;\n+      if (k->is_inline_klass() && is_secondary_mirror(java_class)) {\n+        sigstr = InlineKlass::cast(k)->val_signature_name();\n+      } else {\n+        sigstr = k->signature_name();\n+      }\n@@ -1699,0 +1754,2 @@\n+  macro(_primary_mirror_offset,      k, \"primaryType\",         class_signature,       false); \\\n+  macro(_secondary_mirror_offset,    k, \"secondaryType\",       class_signature,       false); \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":69,"deletions":12,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -248,0 +248,3 @@\n+  static int _primary_mirror_offset;\n+  static int _secondary_mirror_offset;\n+\n@@ -262,0 +265,3 @@\n+  static void set_primary_mirror(oop java_class, oop comp_mirror);\n+  static void set_secondary_mirror(oop java_class, oop comp_mirror);\n+\n@@ -274,0 +280,1 @@\n+  static oop  create_secondary_mirror(Klass* k, Handle mirror, TRAPS);\n@@ -321,0 +328,5 @@\n+  static oop  primary_mirror(oop java_class);\n+  static oop  secondary_mirror(oop java_class);\n+  static bool is_primary_mirror(oop java_class);\n+  static bool is_secondary_mirror(oop java_class);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -237,0 +237,18 @@\n+inline bool java_lang_Class::is_primary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == primary_mirror(java_class);\n+  } else {\n+    return true;\n+  }\n+}\n+\n+inline bool java_lang_Class::is_secondary_mirror(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  if (k->is_inline_klass()) {\n+    return java_class == secondary_mirror(java_class);\n+  } else {\n+    return false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -690,0 +690,2 @@\n+  template(primaryType_name,                           \"primaryType\")                                             \\\n+  template(secondaryType_name,                         \"secondaryType\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,3 @@\n-  oop java_class = klass->java_mirror();\n+  oop java_class = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(klass)->val_mirror()\n+                      : klass->java_mirror();\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1049,1 +1049,3 @@\n-      result_oop = resolved->java_mirror();\n+      result_oop = tag.is_Qdescriptor_klass()\n+                      ? InlineKlass::cast(resolved)->val_mirror()\n+                      : resolved->java_mirror();\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,0 +145,12 @@\n+  \/\/ ref and val mirror\n+  oop ref_mirror() const { return java_mirror(); }\n+  oop val_mirror() const { return java_lang_Class::secondary_mirror(java_mirror()); }\n+\n+  \/\/ naming\n+  const char* ref_signature_name() const {\n+    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+  }\n+  const char* val_signature_name() const {\n+    return InstanceKlass::signature_name_of_carrier(JVM_SIGNATURE_INLINE_TYPE);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2877,0 +2877,4 @@\n+  return signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+}\n+\n+const char* InstanceKlass::signature_name_of_carrier(char c) const {\n@@ -2895,1 +2899,1 @@\n-  dest[dest_index++] = JVM_SIGNATURE_CLASS;\n+  dest[dest_index++] = c;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1264,0 +1264,1 @@\n+  const char* signature_name_of_carrier(char c) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -594,2 +594,0 @@\n-  \/\/ For value classes, this returns the name with a leading 'Q' and a trailing ';'\n-  \/\/     and the package separators as '\/'.\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jni.h\"\n@@ -501,2 +502,12 @@\n-  jboolean ret = sub_klass->is_subtype_of(super_klass) ?\n-                   JNI_TRUE : JNI_FALSE;\n+  jboolean ret;\n+  if (sub_klass == super_klass && sub_klass->is_inline_klass()) {\n+    \/\/ val type is a subtype of ref type\n+    InlineKlass* ik = InlineKlass::cast(sub_klass);\n+    if (sub_mirror == super_mirror || (ik->val_mirror() == sub_mirror && ik->ref_mirror() == super_mirror)) {\n+      ret = JNI_TRUE;\n+    } else {\n+      ret = JNI_FALSE;\n+    }\n+  } else {\n+    ret = sub_klass->is_subtype_of(super_klass) ? JNI_TRUE : JNI_FALSE;\n+  }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-    if (k->is_inline_klass()) {\n+    if (k->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n@@ -397,1 +397,5 @@\n-  klass = klass->array_klass(dim, CHECK_NULL);\n+  if (klass->is_inline_klass() && java_lang_Class::is_secondary_mirror(element_mirror)) {\n+    klass = InlineKlass::cast(klass)->null_free_inline_array_klass(dim, CHECK_NULL);\n+  } else {\n+    klass = klass->array_klass(dim, CHECK_NULL);\n+  }\n@@ -1188,1 +1192,1 @@\n-    rtype = T_INLINE_TYPE;\n+    rtype = java_lang_Class::is_primary_mirror(return_type_mirror) ? T_OBJECT : T_INLINE_TYPE;\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -439,1 +439,2 @@\n-  return klass->java_mirror();\n+  return has_Q_descriptor() ? InlineKlass::cast(klass)->val_mirror()\n+                            : klass->java_mirror();\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-               + getName();\n+               + getName() + (isPrimitiveClass() && isPrimaryType() ? \".ref\" : \"\");\n@@ -554,0 +554,5 @@\n+    \/\/ set by VM if this class is an exotic type such as primitive class\n+    \/\/ otherwise, these two fields are null\n+    private transient Class<T> primaryType;\n+    private transient Class<T> secondaryType;\n+\n@@ -556,0 +561,8 @@\n+     * <p>\n+     * Each primitive class has a {@linkplain #isPrimaryType() primary type}\n+     * representing the <em>primitive reference type<\/em> and a\n+     * {@linkplain #isValueType() secondary type} representing\n+     * the <em>primitive value type<\/em>.  The primitive reference type\n+     * and primitive value type can be obtained by calling the\n+     * {@link #asPrimaryType()} and {@link #asValueType} method\n+     * of a primitive class respectively.\n@@ -565,24 +578,2 @@\n-     * Returns an {@code Optional<Class>} object representing the <em>primitive value type<\/em>\n-     * of this class if this {@code Class} represents the <em>reference type<\/em>\n-     * of a {@linkplain #isPrimitiveClass() primitive class}.\n-     * If this {@code Class} represents the value type of a primitive class,\n-     * then this method returns this class.\n-     * Otherwise an empty {@link Optional} is returned.\n-     *\n-     * @return the {@code Optional<Class>} representing the primitive value type of\n-     *         this class if this class is either the value type\n-     *         or the reference type of a primitive class;\n-     *         an empty {@link Optional} otherwise\n-     * @since Valhalla\n-     *\/\n-    public Optional<Class<?>> valueType() {\n-        if (isPrimitive() || isInterface() || isArray())\n-            return Optional.empty();\n-\n-        Class<?>[] valRefTypes = getPrimitiveTypes();\n-        return valRefTypes.length > 0 ? Optional.of(valRefTypes[0]) : Optional.empty();\n-    }\n-\n-    \/**\n-     * Returns a {@code Class} object representing the reference type\n-     * of this class.\n+     * Returns a {@code Class} object representing the primary type\n+     * of this class or interface.\n@@ -590,3 +581,2 @@\n-     * If this {@code Class} represents a {@linkplain #isPrimitiveClass()\n-     * primitive reference type}, then this method\n-     * returns the <em>primitive reference type<\/em> type of this primitive class.\n+     * If this {@code Class} object represents a reference type, then\n+     * this method returns this class.\n@@ -594,2 +584,3 @@\n-     * If this {@code Class} represents the reference type\n-     * of a primitive class, then this method returns this class.\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive class}, then this method returns the <em>primitive reference type<\/em>\n+     * type of this primitive class.\n@@ -597,3 +588,1 @@\n-     * If this class is an identity class, then this method returns this class.\n-     * <p>\n-     * Otherwise this method returns an empty {@code Optional}.\n+     * If this is a primitive type, then this method returns this class.\n@@ -601,2 +590,2 @@\n-     * @return the {@code Optional<Class>} object representing the reference type for\n-     *         this class, if present; an empty {@link Optional} otherwise.\n+     * @return the {@code Class} representing the primary type of\n+     *         this class or interface\n@@ -605,7 +594,2 @@\n-    public Optional<Class<?>> referenceType() {\n-        if (isPrimitive()) return Optional.empty();\n-        if (isInterface() || isArray()) return Optional.of(this);\n-        if (!isPrimitiveClass()) return Optional.of(this);\n-\n-        Class<?>[] valRefTypes = getPrimitiveTypes();\n-        return valRefTypes.length == 2 ? Optional.of(valRefTypes[1]) : Optional.empty();\n+    public Class<?> asPrimaryType() {\n+        return isPrimitiveClass() ? primaryType : this;\n@@ -614,3 +598,3 @@\n-    \/*\n-     * Returns true if this Class object represents a primitive reference\n-     * type for a primitive class.\n+    \/**\n+     * Returns a {@code Class} object representing the <em>primitive value type<\/em>\n+     * of this class if this class is a {@linkplain #isPrimitiveClass() primitive class}.\n@@ -618,3 +602,5 @@\n-     * A primitive reference type must be a sealed abstract class that\n-     * permits the primitive value type to extend.  The primitive value type\n-     * and primitive reference type for a primitive type must be of the same package.\n+     * @return the {@code Class} representing the primitive value type of\n+     *         this class if this class is a primitive class\n+     * @throws UnsupportedOperationException if this class or interface\n+     *         is not a primitive class\n+     * @since Valhalla\n@@ -622,17 +608,3 @@\n-    private boolean isPrimitiveReferenceType() {\n-        if (isPrimitive() || isArray() || isInterface() || isPrimitiveClass())\n-            return false;\n-\n-        int mods = getModifiers();\n-        if (!Modifier.isAbstract(mods)) {\n-            return false;\n-        }\n-\n-        Class<?>[] valRefTypes = getPrimitiveTypes();\n-        return valRefTypes.length == 2 && valRefTypes[1] == this;\n-    }\n-\n-    private transient Class<?>[] primitiveTypes;\n-    private Class<?>[] getPrimitiveTypes() {\n-        if (isPrimitive() || isArray() || isInterface())\n-            return null;\n+    public Class<?> asValueType() {\n+        if (isPrimitiveClass())\n+            return secondaryType;\n@@ -640,15 +612,1 @@\n-        Class<?>[] valRefTypes = primitiveTypes;\n-        if (valRefTypes == null) {\n-            \/\/ So newPrimitiveTypeArray is called without holding any lock to\n-            \/\/ avoid potential deadlock when multiple threads attempt to\n-            \/\/ initialize the primitive types for C and E where D is\n-            \/\/ the superclass of both C and E (which is an error case)\n-            valRefTypes = newTypeArrayForPrimitiveClass();\n-        }\n-        synchronized (this) {\n-            \/\/ set the value and reference types if not set\n-            if (primitiveTypes == null) {\n-                primitiveTypes = valRefTypes;\n-            }\n-        }\n-        return primitiveTypes;\n+        throw new UnsupportedOperationException(this.getName() + \" is not a primitive class\");\n@@ -657,4 +615,12 @@\n-    \/*\n-     * Returns an array of Class objects whose element at index 0 represents the\n-     * primitive value type and element at index 1 represents the\n-     * primitive reference type, if present.\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents the primary type\n+     * of this class or interface.\n+     * <p>\n+     * If this is a primitive type, then this method returns {@code true}.\n+     * <p>\n+     * If this {@code Class} object represents a reference type, then\n+     * this method returns {@code true}.\n+     * <p>\n+     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n+     * primitive} reference type, then this method returns {@code true};\n+     * otherwise, this method returns {@code false}.\n@@ -662,3 +628,3 @@\n-     * If this Class object is neither a primitive value type nor\n-     * a primitive reference type for a primitive class, then an empty array\n-     * is returned.\n+     * @return {@code true} if this {@code Class} object represents\n+     * the primary type of this class or interface\n+     * @since Valhalla\n@@ -666,4 +632,1 @@\n-    private Class<?>[] newTypeArrayForPrimitiveClass() {\n-        if (isPrimitive() || isArray() || isInterface())\n-            return null;\n-\n+    public boolean isPrimaryType() {\n@@ -671,13 +634,1 @@\n-            Class<?> superClass = getSuperclass();\n-            if (superClass != Object.class && superClass.isPrimitiveReferenceType()) {\n-                return new Class<?>[] { this, superClass };\n-            } else {\n-                return new Class<?>[] { this };\n-            }\n-        } else {\n-            Class<?> valType = primitiveValueType();\n-            if (valType != null) {\n-                return new Class<?>[] { valType, this};\n-            } else {\n-                return EMPTY_CLASS_ARRAY;\n-            }\n+            return this == primaryType;\n@@ -685,0 +636,1 @@\n+        return true;\n@@ -687,4 +639,7 @@\n-    \/*\n-     * Returns the primitive value type if this Class represents\n-     * a primitive reference type.  If this class is a primitive class\n-     * then this method returns this class.  Otherwise, returns null.\n+    \/**\n+     * Returns {@code true} if this {@code Class} object represents\n+     * a {@linkplain #isPrimitiveClass() primitive} value type.\n+     *\n+     * @return {@code true} if this {@code Class} object represents the\n+     * value type of a primitive class\n+     * @since Valhalla\n@@ -692,23 +647,2 @@\n-    private Class<?> primitiveValueType() {\n-        if (isPrimitive() || isArray() || isInterface())\n-            return null;\n-\n-        if (isPrimitiveClass())\n-            return this;\n-\n-        int mods = getModifiers();\n-        if (!Modifier.isAbstract(mods)) {\n-            return null;\n-        }\n-\n-        \/\/ A primitive reference type must be a sealed abstract class\n-        \/\/ that permits the primitive class type to extend.\n-        \/\/ The primitive class project type and primitive reference type for\n-        \/\/ a primitive class type must be of the same package.\n-        Class<?>[] subclasses = getPermittedSubclasses0();\n-        if ((subclasses.length == 1) &&\n-                (subclasses[0].isPrimitiveClass()) &&\n-                (getPackageName().equals(subclasses[0].getPackageName()))) {\n-            return subclasses[0];\n-        }\n-        return null;\n+    public boolean isValueType() {\n+        return isPrimitiveClass() && this == secondaryType;\n@@ -1025,1 +959,1 @@\n-     *     returns \"[[LPoint$ref;\"\n+     *     returns \"[[LPoint;\"\n@@ -1854,1 +1788,6 @@\n-        return getName();\n+        if (isPrimitiveClass()) {\n+            \/\/ TODO: null-default\n+            return isPrimaryType() ? getName() + \".ref\" : getName();\n+        } else {\n+            return getName();\n+        }\n@@ -4025,2 +3964,2 @@\n-     * @throws NullPointerException if this is an {@linkplain #isPrimitiveClass()\n-     * primitive class} and the object is {@code null}\n+     * @throws NullPointerException if this is an {@linkplain #isValueType()\n+     * primitive value type} and the object is {@code null}\n@@ -4033,2 +3972,2 @@\n-        if (isPrimitiveClass() && obj == null)\n-            throw new NullPointerException(getName() + \" is a primitive class\");\n+        if (isValueType() && obj == null)\n+            throw new NullPointerException(getName() + \" is a primitive value type\");\n@@ -4545,1 +4484,1 @@\n-        String typeDesc = isPrimitiveClass() ? \"Q\" : \"L\";\n+        String typeDesc = isValueType()  ? \"Q\" : \"L\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":77,"deletions":138,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -385,6 +385,2 @@\n-     * If {@code fromType} is a primitive class, this method returns {@code true}\n-     * if {@code toType} is the {@linkplain Class#referenceType() primitive reference type}\n-     * of {@code fromType}.\n-     * If {@code toType} is a primitive class, this method returns {@code true}\n-     * if {@code toType} is the {@linkplain Class#valueType() primitive value type}\n-     * of {@code fromType}.\n+     * If {@code fromType} and {@code toType} is of the same primitive class,\n+     * this method returns {@code true}.\n@@ -403,2 +399,3 @@\n-        if (!fromType.isPrimitiveClass() && !toType.isPrimitiveClass()) {\n-            return false;\n+        if (fromType.isPrimitiveClass() && toType.isPrimitiveClass()) {\n+            \/\/ val projection can be converted to ref projection; or vice verse\n+            return fromType.asPrimaryType() == toType.asPrimaryType();\n@@ -407,1 +404,1 @@\n-        return fromType.valueType().equals(toType.valueType());\n+        return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -84,1 +84,2 @@\n-            mtype = mtype.insertParameterTypes(0, refc);\n+            Class<?> receiverType = refc.isPrimitiveClass() ? refc.asValueType() : refc;\n+            mtype = mtype.insertParameterTypes(0, receiverType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-                       methodType.returnType() != defc) {\n+                       methodType.returnType() != defc.asValueType()) {\n+                \/\/ TODO: allow to return Object or perhaps one of the supertypes of that class\n@@ -120,1 +121,1 @@\n-                throw new IllegalArgumentException(\"static constructor must be of \" + getDeclaringClass().getName());\n+                throw new IllegalArgumentException(\"static constructor must be of \" + defc.getName());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+        Class<?> c = clazz.isPrimitiveClass() ? clazz.asValueType() : clazz;\n@@ -195,1 +196,1 @@\n-            return itype.changeReturnType(clazz);\n+            return itype.changeReturnType(c);\n@@ -197,1 +198,1 @@\n-            return itype.insertParameterTypes(0, clazz);\n+            return itype.insertParameterTypes(0, c);\n@@ -480,1 +481,1 @@\n-            return type.isPrimitiveClass();\n+            return type.isValueType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1625,0 +1625,1 @@\n+            assert lookupClass.isPrimaryType();\n@@ -3448,0 +3449,1 @@\n+            Class<?> defc = c.getDeclaringClass();\n@@ -3450,1 +3452,1 @@\n-                return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);\n+                return lookup.getDirectConstructorNoSecurityManager(defc, ctor);\n@@ -3453,1 +3455,1 @@\n-                assert(ctor.isMethod() && ctor.getReturnType() == ctor.getDeclaringClass() && ctor.getReferenceKind() == REF_invokeStatic);\n+                assert(ctor.isMethod() && ctor.getReturnType() == defc && ctor.getReferenceKind() == REF_invokeStatic) : ctor.toString();\n@@ -3455,1 +3457,1 @@\n-                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), ctor.getDeclaringClass(), ctor, lookup);\n+                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), defc, ctor, lookup);\n@@ -3827,1 +3829,1 @@\n-            if (!fullPrivilegeLookup && defc != refc) {\n+            if (!fullPrivilegeLookup && defc.asPrimaryType() != refc.asPrimaryType()) {\n@@ -3910,1 +3912,1 @@\n-                               (defc == refc ||\n+                               (defc.asPrimaryType() == refc.asPrimaryType() ||\n@@ -3915,1 +3917,1 @@\n-                           (defc == refc ||\n+                           (defc.asPrimaryType() == refc.asPrimaryType() ||\n@@ -3992,1 +3994,0 @@\n-\n@@ -4326,3 +4327,0 @@\n-        if (arrayClass.isPrimitiveClass()) {\n-            throw new UnsupportedOperationException();\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.stream.Collectors;\n@@ -892,1 +893,1 @@\n-                \")\" + rtype.getSimpleName());\n+                \")\" + toSimpleName(rtype));\n@@ -894,1 +895,1 @@\n-            sj.add(ptypes[i].getSimpleName());\n+            sj.add(toSimpleName(ptypes[i]));\n@@ -899,0 +900,7 @@\n+    static String toSimpleName(Class<?> c) {\n+        if (c.isPrimitiveClass() && c.isPrimaryType()) {\n+            return c.getSimpleName() + \".ref\";\n+        } else {\n+            return c.getSimpleName();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+        Class<?> valType = lookup.lookupClass().asValueType();\n@@ -94,1 +95,1 @@\n-                return inlineTypeHashCode(lookup.lookupClass());\n+                return inlineTypeHashCode(valType);\n@@ -96,1 +97,1 @@\n-                return substitutableInvoker(lookup.lookupClass()).asType(methodType);\n+                return substitutableInvoker(valType).asType(methodType);\n@@ -98,1 +99,1 @@\n-                return inlineTypeToString(lookup.lookupClass());\n+                return inlineTypeToString(valType);\n@@ -110,1 +111,1 @@\n-            Lookup lookup = new MethodHandles.Lookup(type);\n+            Lookup lookup = new MethodHandles.Lookup(type.asPrimaryType());\n@@ -156,0 +157,4 @@\n+        static Class<?> fieldType(MethodHandle getter) {\n+            Class<?> ftype = getter.type().returnType();\n+            return ftype;\n+        }\n@@ -162,1 +167,1 @@\n-            assert type.isPrimitiveClass();\n+            assert type.isValueType();\n@@ -169,1 +174,1 @@\n-                Class<?> ftype = getter.type().returnType();\n+                Class<?> ftype = fieldType(getter);\n@@ -184,1 +189,1 @@\n-            assert type.isPrimitiveClass();\n+            assert type.isValueType();\n@@ -196,0 +201,2 @@\n+                Class<?> ftype = fieldType(getter);\n+\n@@ -200,1 +207,1 @@\n-                MethodHandle hasher = hashCodeForType(getter.type().returnType());\n+                MethodHandle hasher = hashCodeForType(ftype);\n@@ -213,1 +220,1 @@\n-            assert type.isPrimitiveClass();\n+            assert type.isValueType();\n@@ -221,1 +228,1 @@\n-            Lookup lookup = new MethodHandles.Lookup(type);\n+            Lookup lookup = new MethodHandles.Lookup(type.asPrimaryType());\n@@ -224,0 +231,1 @@\n+                Class<?> ftype = fieldType(getter);\n@@ -225,1 +233,0 @@\n-                Class<?> ftype = fieldInfo.getMethodType().returnType();\n@@ -268,1 +275,1 @@\n-                Class<?> type = a.getClass();\n+                Class<?> type = a.getClass().asValueType();\n@@ -304,0 +311,3 @@\n+                if (componentType.isPrimitiveClass()) {\n+                    componentType = componentType.asValueType();\n+                }\n@@ -498,0 +508,3 @@\n+            if (type.isPrimitiveClass()) {\n+                type = type.asValueType();\n+            }\n@@ -541,1 +554,1 @@\n-        if (type.isPrimitiveClass())\n+        if (type.isValueType())\n@@ -550,1 +563,1 @@\n-            return MethodHandleBuilder.inlineTypeEquals(type);\n+            return MethodHandleBuilder.inlineTypeEquals(type.asValueType());\n@@ -561,1 +574,0 @@\n-            Class<?> type = o.getClass();\n@@ -564,2 +576,3 @@\n-            if (!type.isPrimitiveClass())\n-                throw new InternalError(\"must be primitive type: \" + type.getName());\n+            if (!o.getClass().isPrimitiveClass())\n+                throw new InternalError(\"must be primitive type: \" + o.getClass().getName());\n+            Class<?> type = o.getClass().asValueType();\n@@ -577,1 +590,1 @@\n-            return MethodHandleBuilder.inlineTypeHashCode(type);\n+            return MethodHandleBuilder.inlineTypeHashCode(type.asValueType());\n@@ -588,1 +601,0 @@\n-            Class<?> type = o.getClass();\n@@ -591,2 +603,3 @@\n-            if (!type.isPrimitiveClass())\n-                throw new InternalError(\"must be primitive type: \" + type.getName());\n+            if (!o.getClass().isPrimitiveClass())\n+                throw new InternalError(\"must be primitive type: \" + o.getClass().getName());\n+            Class<?> type = o.getClass().asValueType();\n@@ -604,1 +617,1 @@\n-            return MethodHandleBuilder.inlineTypeToString(type);\n+            return MethodHandleBuilder.inlineTypeToString(type.asValueType());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ValueBootstrapMethods.java","additions":35,"deletions":22,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1651,0 +1651,6 @@\n+            \/\/ the field type (value) is mapped to the return type of MethodType\n+            \/\/ the receiver type is mapped to a parameter type of MethodType\n+            \/\/ So use the value type if it's a primitive class\n+            if (receiver != null && receiver.isPrimitiveClass()) {\n+                receiver = receiver.asValueType();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-            return maybeAdapt(componentType.isPrimitiveClass() && UNSAFE.isFlattenedArray(arrayClass)\n+            return maybeAdapt(componentType.isValueType() && UNSAFE.isFlattenedArray(arrayClass)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-            if (handle.fieldType.isPrimitiveClass())\n+            if (handle.fieldType.isValueType())\n@@ -504,1 +504,1 @@\n-            if (handle.fieldType.isPrimitiveClass())\n+            if (handle.fieldType.isValueType())\n@@ -747,1 +747,1 @@\n-        assert componentType.isPrimitiveClass() && UNSAFE.isFlattenedArray(arrayClass);\n+        assert componentType.isValueType() && UNSAFE.isFlattenedArray(arrayClass);\n@@ -806,1 +806,1 @@\n-            if (handle.componentType.isPrimitiveClass())\n+            if (handle.componentType.isValueType())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+        assert declaringClass.isPrimaryType();\n@@ -362,1 +363,1 @@\n-        sb.append(getDeclaringClass().getTypeName());\n+        sb.append(getDeclaringClassTypeName());\n@@ -368,1 +369,1 @@\n-        sb.append(getDeclaringClass().getTypeName());\n+        sb.append(getDeclaringClassTypeName());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -780,0 +780,8 @@\n+\n+    String getDeclaringClassTypeName() {\n+        Class<?> c = getDeclaringClass();\n+        if (c.isPrimitiveClass()) {\n+            c = c.asValueType();\n+        }\n+        return c.getTypeName();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+        assert declaringClass.isPrimaryType();\n@@ -330,1 +331,1 @@\n-            + getDeclaringClass().getTypeName() + \".\"\n+            + getDeclaringClassTypeName() + \".\"\n@@ -336,1 +337,9 @@\n-        return \"field \" + getDeclaringClass().getTypeName() + \".\" + getName();\n+        return \"field \" + getDeclaringClassTypeName() + \".\" + getName();\n+    }\n+\n+    String getDeclaringClassTypeName() {\n+        Class<?> c = getDeclaringClass();\n+        if (c.isPrimitiveClass()) {\n+            c = c.asValueType();\n+        }\n+        return c.getTypeName();\n@@ -364,1 +373,1 @@\n-            + getDeclaringClass().getTypeName() + \".\"\n+            + getDeclaringClassTypeName() + \".\"\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+        assert declaringClass.isPrimaryType();\n@@ -421,1 +422,1 @@\n-        sb.append(getDeclaringClass().getTypeName()).append('.');\n+        sb.append(getDeclaringClassTypeName()).append('.');\n@@ -427,1 +428,1 @@\n-        return \"method \" + getDeclaringClass().getTypeName() +\n+        return \"method \" + getDeclaringClassTypeName() +\n@@ -490,1 +491,1 @@\n-        sb.append(getDeclaringClass().getTypeName()).append('.');\n+        sb.append(getDeclaringClassTypeName()).append('.');\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -875,1 +875,1 @@\n-            if (type != c) {\n+            if (type.asPrimaryType() != c.asPrimaryType()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -867,1 +867,1 @@\n-                if (type.isPrimitiveClass()) {\n+                if (type.isValueType()) {\n@@ -922,1 +922,1 @@\n-         * to invoke Class.asPrimaryType if the class is regular value type.\n+         * to invoke Class::asValueType if the class is a primitive value type.\n@@ -932,0 +932,5 @@\n+            if (cl.isValueType()) {\n+              mv.visitMethodInsn(INVOKEVIRTUAL,\n+                                 JL_CLASS,\n+                                 \"asValueType\", \"()Ljava\/lang\/Class;\", false);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-        if (ref == null && pc.isPrimitiveClass()) {\n+        if (ref == null && pc.isValueType()) {\n@@ -278,1 +278,1 @@\n-        if (ref == null && pc.isPrimitiveClass()) {\n+        if (ref == null && pc.isValueType()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        return !field.getType().isPrimitiveClass();\n+        return !field.getType().isPrimitiveClass() || field.getType().isPrimaryType();\n@@ -75,1 +75,5 @@\n-            if (!field.getType().isAssignableFrom(value.getClass())) {\n+            Class<?> type = value.getClass();\n+            if (type.isPrimitiveClass()) {\n+                type = type.asValueType();\n+            }\n+            if (!field.getType().isAssignableFrom(type)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeFieldAccessorImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-                return Class.forName(name, false, loader);\n+                Class<?> clz = Class.forName(name, false, loader);\n+                return c == 'Q' ? clz.asValueType() : clz.asPrimaryType();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-        if (defc == lookupClass  &&\n+        if (defc.asPrimaryType() == lookupClass  &&\n@@ -144,1 +144,1 @@\n-            assert (canAccess && refc == defc) || !canAccess;\n+            assert (canAccess && refc.asPrimaryType() == defc.asPrimaryType()) || !canAccess;\n@@ -152,1 +152,1 @@\n-        return (refc == lookupClass ||\n+        return (refc.asPrimaryType() == lookupClass.asPrimaryType() ||\n@@ -277,1 +277,1 @@\n-        if (type == refc) {\n+        if (type.asPrimaryType() == refc.asPrimaryType()) {\n@@ -337,1 +337,1 @@\n-        return (type == res);\n+        return (type.asPrimaryType() == res);\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        Asserts.assertEquals(emptyField.empty.getClass(), EmptyInline.class);\n+        Asserts.assertEquals(emptyField.empty.getClass(), EmptyInline.ref.class);\n@@ -79,1 +79,1 @@\n-        Asserts.assertEquals(w.empty.getClass(), EmptyInline.class);\n+        Asserts.assertEquals(w.empty.getClass(), EmptyInline.ref.class);\n@@ -82,1 +82,1 @@\n-        Asserts.assertEquals(w.empty.getClass(), EmptyInline.class);\n+        Asserts.assertEquals(w.empty.getClass(), EmptyInline.ref.class);\n@@ -88,1 +88,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n@@ -97,1 +97,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n@@ -103,1 +103,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n@@ -109,1 +109,1 @@\n-            Asserts.assertEquals(element.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(element.getClass(), EmptyInline.ref.class);\n@@ -133,1 +133,1 @@\n-            Asserts.assertEquals(e.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(e.getClass(), EmptyInline.ref.class);\n@@ -137,1 +137,1 @@\n-            Asserts.assertEquals(e.getClass(), EmptyInline.class);\n+            Asserts.assertEquals(e.getClass(), EmptyInline.ref.class);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/EmptyInlineTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-        assertTrue(myInts instanceof MyInt.ref[]);\n+        assertTrue(myInts instanceof MyInt[]);\n@@ -292,1 +292,1 @@\n-        assertTrue(cls.isPrimitiveClass());\n+        assertTrue(cls.isValueType());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeArray.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        checkGetClass(val, MyInt.class);\n+        checkGetClass(val, MyInt.ref.class);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ObjectMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-                    return (aClass.isPrimitiveClass() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n+                    return (aClass.isValueType() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n@@ -273,1 +273,1 @@\n-                return aClass != null && aClass.isPrimitiveClass();\n+                return aClass != null && aClass.isValueType();\n@@ -282,1 +282,2 @@\n-                        return Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                        Class<?> c = Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                        return basicTypeHelper.isInlineClass(desc) ? c.asValueType() : c.asPrimaryType();\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary test reflection on inline types\n+ * @compile --enable-preview --source ${jdk.version} BasicTest.java\n+ * @run testng\/othervm --enable-preview BasicTest\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import static org.testng.Assert.*;\n+\n+public class BasicTest {\n+    static primitive class Point {\n+        int x;\n+        int y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        int x() {\n+            return x;\n+        }\n+\n+        int y() {\n+            return y;\n+        }\n+        static Point.val newVal(int x, int y) {\n+            return new Point(x, y);\n+        }\n+        static Point.ref toRef(Object o) {\n+            return (Point.ref) o;\n+        }\n+        static Point.val toVal(Point.ref o) {\n+            return (Point.val) o;\n+        }\n+    }\n+\n+    @DataProvider(name=\"constants\")\n+    static Object[][] constants() {\n+        return new Object[][]{\n+            new Object[] { Point.class, Point.class.asValueType()},\n+            new Object[] { Point.val.class, Point.class.asValueType()},\n+            new Object[] { Point.ref.class, Point.class.asPrimaryType()},\n+        };\n+    }\n+\n+    @Test(dataProvider=\"constants\")\n+    public void ldc(Class<?> type, Class<?> expected) {\n+        assertTrue(type == expected);\n+    }\n+\n+    @DataProvider(name=\"refTypes\")\n+    static Object[][] refTypes() {\n+        return new Object[][]{\n+                new Object[] { int.class, true},\n+                new Object[] { Integer.class, true},\n+                new Object[] { Object.class, true},\n+                new Object[] { Point.ref.class, true},\n+                new Object[] { Point.val.class, false},\n+                new Object[] { Point.class.asPrimaryType(), true},\n+                new Object[] { Point.class.asValueType(), false},\n+        };\n+    }\n+    @Test(dataProvider=\"refTypes\")\n+    public void isPrimaryType(Class<?> type, boolean isRefType) {\n+        assertTrue(type.isPrimaryType() == isRefType);\n+    }\n+\n+    @Test\n+    public void testMirrors() {\n+        Class<?> refType = Point.class.asPrimaryType();\n+        Class<?> valType = Point.class.asValueType();\n+\n+        assertTrue(refType == Point.ref.class);\n+        \/\/ ## ldc not implemented\n+        assertTrue(valType == Point.val.class);\n+        assertTrue(refType != valType);\n+        assertTrue(refType.isPrimitiveClass());\n+        assertTrue(valType.isPrimitiveClass());\n+        assertTrue(refType.isPrimaryType());\n+        assertFalse(valType.isPrimaryType());\n+\n+        assertEquals(refType.getName(), \"BasicTest$Point\");\n+        assertEquals(valType.getName(), \"BasicTest$Point\");\n+    }\n+\n+    @DataProvider(name=\"names\")\n+    static Object[][] names() {\n+        return new Object[][]{\n+                new Object[] { \"BasicTest$Point\", Point.class.asPrimaryType()},\n+                new Object[] { \"[QBasicTest$Point;\", Point[].class},\n+                new Object[] { \"[LBasicTest$Point;\", Point.ref[].class},\n+        };\n+    }\n+    @Test(dataProvider=\"names\")\n+    public void classForName(String name, Class<?> expected) throws ClassNotFoundException {\n+        Class<?> type = Class.forName(name);\n+        assertTrue(type == expected);\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        Point.ref ref = Point.toRef(null);\n+        assertTrue(ref == null);\n+        try {\n+            Point.toVal(null);\n+            throw new RuntimeException(\"expected NPE thrown\");\n+        } catch (NullPointerException e) {}\n+    }\n+\n+    @Test\n+    public void testConversion() {\n+        Point p = new Point(10,20);\n+        Point.ref ref = Point.toRef(p);\n+        Point.val val = Point.toVal(ref);\n+        assertEquals(ref, p);\n+        assertEquals(val, p);\n+    }\n+\n+    @Test\n+    public void testMembers() {\n+        Method[] refMethods = Point.ref.class.getDeclaredMethods();\n+        Method[] valMethods = Point.val.class.getDeclaredMethods();\n+        assertEquals(refMethods, valMethods);\n+        assertTrue(valMethods.length == 5);\n+\n+        Field[] refFields = Point.ref.class.getDeclaredFields();\n+        Field[] valFields = Point.val.class.getDeclaredFields();\n+        assertEquals(refFields, valFields);\n+        assertTrue(valFields.length == 2);\n+\n+        Constructor[] refCtors = Point.ref.class.getDeclaredConstructors();\n+        Constructor[] valCtors = Point.val.class.getDeclaredConstructors();\n+        assertEquals(refCtors, valCtors);\n+        assertTrue(valCtors.length == 1);\n+        assertTrue(Modifier.isStatic(valCtors[0].getModifiers()));\n+    }\n+\n+    @DataProvider(name=\"methods\")\n+    static Object[][] methods() {\n+        return new Object[][]{\n+                new Object[] { \"toVal\", Point.val.class, new Class<?>[] { Point.ref.class }},\n+                new Object[] { \"toRef\", Point.ref.class, new Class<?>[] { Object.class }},\n+        };\n+    }\n+    @Test(dataProvider = \"methods\")\n+    public void testMethod(String name, Class<?> returnType, Class<?>[] paramTypes) throws ReflectiveOperationException {\n+        Method m = Point.class.getDeclaredMethod(name, paramTypes);\n+        System.out.print(m.toString() + \"  \");\n+        System.out.println(m.getReturnType().descriptorString());\n+        assertTrue(m.getDeclaringClass() == Point.class.asPrimaryType());\n+        assertTrue(m.getReturnType() == returnType);\n+        assertEquals(m.getParameterTypes(), paramTypes);\n+    }\n+\n+    @Test\n+    public void testConstructor() throws ReflectiveOperationException {\n+        Constructor<?> ctor = Point.class.getDeclaredConstructor(int.class, int.class);\n+        assertTrue(ctor.getDeclaringClass() == Point.class.asPrimaryType());\n+    }\n+\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/BasicTest.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -62,1 +62,1 @@\n-        Class<?> c = Class.forName(cn);\n+        Class<?> c = Class.forName(cn).asValueType();\n@@ -65,1 +65,1 @@\n-        assertEquals(c, INLINE_TYPE);\n+        assertTrue(c == INLINE_TYPE);\n@@ -72,1 +72,1 @@\n-        assertEquals(o.getClass(), INLINE_TYPE);\n+        assertTrue(o.getClass() == INLINE_TYPE.asPrimaryType());\n","filename":"test\/jdk\/valhalla\/valuetypes\/InlineConstructorTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import org.testng.annotations.DataProvider;\n@@ -90,2 +89,0 @@\n-        test.setValueField(\"nfp\", mv, p);\n-        test.setValueField(\"l\", mv, l);\n@@ -94,3 +91,4 @@\n-        test.setValueField(\"staticLine\", null, l);\n-        \/\/ staticLine is a nullable field\n-        test.setValueField(\"staticLine\", null, null);\n+        \/\/ the following are nullable fields\n+        test.setField(\"nfp\", mv, p, false);\n+        test.setField(\"staticLine\", null, l, false);\n+        test.setField(\"staticLine\", null, null, false);\n@@ -122,1 +120,1 @@\n-            assertTrue(elementType == elementType.valueType().get());\n+            assertTrue(elementType == elementType.asValueType());\n@@ -195,0 +193,4 @@\n+        setField(name, obj, value, true);\n+    }\n+\n+    void setField(String name, Object obj, Object value, boolean isValue) throws Throwable {\n@@ -197,1 +199,2 @@\n-        assertTrue(f.getType().isPrimitiveClass() || f.getType().valueType().isPresent());\n+        assertTrue(f.getType().isPrimitiveClass());\n+        assertTrue(f.getType().isValueType() == isValue);\n@@ -292,1 +295,1 @@\n-        boolean canBeNull = !f.getType().isPrimitiveClass();\n+        boolean canBeNull = f.getType().isPrimaryType();\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodHandleTest.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\n@@ -36,1 +35,0 @@\n-import java.util.Objects;\n@@ -169,1 +167,1 @@\n-            { VALUE1,                hash(hashCodeComponents(VALUE1))},\n+            { VALUE1,               hash(hashCodeComponents(VALUE1))},\n@@ -194,0 +192,3 @@\n+        if (type.isPrimitiveClass()) {\n+            type = type.asValueType();\n+        }\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -142,3 +142,1 @@\n-            \/\/ TODO: methods are in the reference projection\n-            Class<?> declaringClass = defc \/* defc.referenceType().get() *\/;\n-            declaringClass.getDeclaredMethod(name, params);\n+            defc.getDeclaredMethod(name, params);\n@@ -155,12 +153,12 @@\n-            { \"point\",      MethodType.methodType(Point.ref.class),                                     true },\n-            { \"pointValue\", MethodType.methodType(Point.class),                                         true },\n-            { \"has\",        MethodType.methodType(boolean.class, Point.class, Point.ref.class),         true },\n-            { \"point\",      MethodType.methodType(Point.class),                                         false },\n-            { \"pointValue\", MethodType.methodType(Point.ref.class),                                     false },\n-            { \"has\",        MethodType.methodType(boolean.class, Point.ref.class, Point.class),         false },\n-            { \"point\",      MethodType.fromMethodDescriptorString(\"()LPoint$ref;\", loader),             true },\n-            { \"point\",      MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),                 false },\n-            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),                 true },\n-            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()LPoint$ref;\", loader),             false },\n-            { \"has\",        MethodType.fromMethodDescriptorString(\"(QPoint;LPoint$ref;)Z\", loader),     true },\n-            { \"has\",        MethodType.fromMethodDescriptorString(\"(LPoint$ref;LPoint$ref;)Z\", loader), false },\n+            { \"point\",      MethodType.methodType(Point.ref.class),                                      true },\n+            { \"pointValue\", MethodType.methodType(Point.class),                                          true },\n+            { \"has\",        MethodType.methodType(boolean.class, Point.class, Point.ref.class),          true },\n+            { \"point\",      MethodType.methodType(Point.class),                                          false },\n+            { \"pointValue\", MethodType.methodType(Point.ref.class),                                      false },\n+            { \"has\",        MethodType.methodType(boolean.class, Point.ref.class, Point.class),          false },\n+            { \"point\",      MethodType.fromMethodDescriptorString(\"()LPoint;\", loader),        true },\n+            { \"point\",      MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),        false },\n+            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),        true },\n+            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()LPoint;\", loader),        false },\n+            { \"has\",        MethodType.fromMethodDescriptorString(\"(QPoint;LPoint;)Z\", loader),true },\n+            { \"has\",        MethodType.fromMethodDescriptorString(\"(LPoint;LPoint;)Z\", loader),false },\n","filename":"test\/jdk\/valhalla\/valuetypes\/QTypeDescriptorTest.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -43,7 +43,0 @@\n-    @Test\n-    public static void sanityTest() {\n-        assertTrue(Point.ref.class.getPermittedSubclasses().length == 1);\n-        assertTrue(Line.ref.class.getPermittedSubclasses().length == 1);\n-        assertTrue(NonFlattenValue.ref.class.getPermittedSubclasses().length == 1);\n-    }\n-\n@@ -58,1 +51,0 @@\n-        \/\/ TODO: static field is in the reference projection\n@@ -88,7 +80,6 @@\n-        Class<?> inlineClass = Point.class;\n-        assertTrue(inlineClass.isPrimitiveClass());\n-        assertFalse(Point.ref.class.isPrimitiveClass());\n-        assertEquals(inlineClass.valueType().get(), Point.class);\n-        assertEquals(inlineClass.referenceType().get(), Point.ref.class);\n-        assertEquals(Point.ref.class.valueType().get(), Point.class);\n-        assertEquals(Point.ref.class.referenceType().get(), Point.ref.class);\n+        assertTrue(Point.class.isPrimitiveClass());\n+        assertTrue(Point.ref.class.isPrimitiveClass());\n+        assertFalse(Point.class.isPrimaryType());\n+        assertTrue(Point.ref.class.isPrimaryType());\n+        assertEquals(Point.class.asValueType(), Point.class);\n+        assertEquals(Point.class.asPrimaryType(), Point.ref.class);\n@@ -120,1 +111,1 @@\n-        assertEquals(Point.ref.class.getName(), \"Point$ref\");\n+        assertEquals(Point.ref.class.getName(), \"Point\");\n@@ -123,1 +114,1 @@\n-        assertEquals((new Point.ref[0][0]).getClass().getName(), \"[[LPoint$ref;\");\n+        assertEquals((new Point.ref[0][0]).getClass().getName(), \"[[LPoint;\");\n@@ -130,3 +121,3 @@\n-        this.c = Class.forName(cn);\n-        if (!c.isPrimitiveClass() || c != type) {\n-            throw new RuntimeException(cn + \" is not an inline class\");\n+        this.c = Class.forName(cn).asValueType();\n+        if (c != type) {\n+            throw new RuntimeException(c + \" is not a primitive value type\");\n@@ -136,3 +127,3 @@\n-        assertEquals(type, o.getClass());\n-        assertEquals(type, c.valueType().get());\n-        assertEquals(c, c.valueType().get());\n+        assertEquals(type.asPrimaryType(), o.getClass());\n+        assertEquals(type, c.asValueType());\n+        assertEquals(c, c.asValueType());\n@@ -147,2 +138,2 @@\n-        testArray(c.valueType().get());\n-        testArray(c.referenceType().get());\n+        testArray(c.asValueType());\n+        testArray(c.asPrimaryType());\n@@ -152,6 +143,2 @@\n-        Class<?> valType = c.valueType().get();\n-        Class<?> refType = c.referenceType().get();\n-\n-        assertTrue(valType != null);\n-        assertEquals(refType.getTypeName(), c.getTypeName() + \"$ref\");\n-        assertEquals(refType.getSimpleName(), c.getSimpleName() + \"$ref\");\n+        Class<?> valType = c.asValueType();\n+        Class<?> refType = c.asPrimaryType();\n@@ -159,3 +146,3 @@\n-        assertEquals(refType.getName(), valType.getName() + \"$ref\");\n-        assertEquals(refType.getTypeName(), valType.getTypeName() + \"$ref\");\n-        assertEquals(refType.getSimpleName(), valType.getSimpleName() + \"$ref\");\n+        assertEquals(refType.getName(), valType.getName());\n+        assertEquals(refType.getTypeName(), c.getTypeName() + \".ref\");\n+        assertEquals(refType.getSimpleName(), c.getSimpleName());\n@@ -163,2 +150,2 @@\n-        assertEquals(valType.referenceType().get(), refType);\n-        assertEquals(refType.valueType().get(), valType);\n+        assertEquals(valType.asPrimaryType(), refType);\n+        assertEquals(refType.asValueType(), valType);\n@@ -172,1 +159,1 @@\n-        assertTrue(componentType.isPrimitiveClass() || componentType.valueType().isPresent());\n+        assertTrue(componentType.isPrimitiveClass());\n@@ -175,1 +162,1 @@\n-        assertEquals(arrayType.referenceType().get(), arrayType);\n+        assertEquals(arrayType.asPrimaryType(), arrayType);\n@@ -198,1 +185,1 @@\n-        assertEquals(o.getClass(), c);\n+        assertEquals(o.getClass(), c.asPrimaryType());\n@@ -203,1 +190,1 @@\n-        assertEquals(o.getClass(), c);\n+        assertEquals(o.getClass(), c.asPrimaryType());\n@@ -225,2 +212,0 @@\n-        \/\/ TODO: methods are in the reference projection\n-        \/\/ Class<?> declaringClass = c.referenceType().get();\n@@ -237,2 +222,0 @@\n-        \/\/ TODO: methods are in the reference projection\n-        \/\/ Class<?> declaringClass = c.referenceType().get();\n@@ -281,2 +264,0 @@\n-        \/\/ TODO: methods are in the reference projection\n-        \/\/ Class<?> declaringClass = c.referenceType().get();\n@@ -302,1 +283,1 @@\n-        return type.getName();\n+        return type.getTypeName();\n","filename":"test\/jdk\/valhalla\/valuetypes\/Reflection.java","additions":28,"deletions":47,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-        assertEquals(minfo.getDeclaringClass(), c);\n+        assertEquals(minfo.getDeclaringClass(), c.asPrimaryType());\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticInitFactoryTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        if (componentType.isPrimitiveClass()) {\n+        if (componentType.isValueType()) {\n@@ -61,1 +61,1 @@\n-            Object[] lArray = (Object[]) Array.newInstance(componentType.referenceType().get(), 0);\n+            Object[] lArray = (Object[]) Array.newInstance(componentType.asPrimaryType(), 0);\n@@ -75,1 +75,1 @@\n-        sb.append(c.isPrimitiveClass() ? \"Q\" : \"L\").append(c.getName()).append(\";\");\n+        sb.append(c.isValueType() ? \"Q\" : \"L\").append(c.getName()).append(\";\");\n@@ -95,1 +95,1 @@\n-        if (!componentType.isPrimitiveClass()) {\n+        if (!componentType.isValueType()) {\n@@ -110,1 +110,1 @@\n-        assertTrue(componentType.isPrimitiveClass());\n+        assertTrue(componentType.isValueType());\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueArray.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                    SplitPrimitiveClassNestHostTest.class.referenceType().get()))\n+                    SplitPrimitiveClassNestHostTest.class.asPrimaryType()))\n@@ -67,1 +67,1 @@\n-        if (!nestHost.equals(SplitPrimitiveClassNestHostTest.class.referenceType().get()))\n+        if (!nestHost.equals(SplitPrimitiveClassNestHostTest.class.asPrimaryType()))\n@@ -95,1 +95,1 @@\n-        if (!members[3].equals(Inner.class.referenceType().get()))\n+        if (!members[3].equals(Inner.class.asPrimaryType()))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/SplitPrimitiveClassNestHostTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}