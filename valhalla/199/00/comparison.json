{"files":[{"patch":"@@ -389,0 +389,3 @@\n+                if (c.isValue() && c.projection != null) {\n+                    c.projection.flags_field = (c.flags_field & ~(VALUE | UNATTRIBUTED | FINAL)) | SEALED;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -146,0 +146,4 @@\n+    \/** Flag is set for a type restricted field.\n+     *\/\n+    public static final int RESTRICTED_FIELD       = 1<<19;\n+\n@@ -521,0 +525,1 @@\n+        RESTRICTED_FIELD(Flags.RESTRICTED_FIELD),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1674,2 +1674,0 @@\n-            if (!isValue())\n-                return null;\n@@ -1691,1 +1689,1 @@\n-            long projectionFlags = (this.flags() & ~(VALUE | UNATTRIBUTED | FINAL)) | SEALED;\n+            long projectionFlags = (this.flags_field & ~(VALUE | UNATTRIBUTED | FINAL)) | SEALED;\n@@ -1695,14 +1693,17 @@\n-            for (Symbol s : this.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n-                Symbol clone = null;\n-                if (s.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)s;\n-                    MethodSymbol refMethod = valMethod.clone(projection);\n-                    valMethod.projection = refMethod;\n-                    refMethod.projection = valMethod;\n-                    clone = refMethod;\n-                } else if (s.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)s;\n-                    VarSymbol refVar = valVar.clone(projection);\n-                    valVar.projection = refVar;\n-                    refVar.projection = valVar;\n-                    clone = refVar;\n+            if (this.completer == Completer.NULL_COMPLETER) {\n+                for (Symbol s : this.members().getSymbols(s -> (s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n+                    Symbol clone = null;\n+                    if (s.kind == MTH) {\n+                        MethodSymbol valMethod = (MethodSymbol)s;\n+                        MethodSymbol refMethod = valMethod.clone(projection);\n+                        valMethod.projection = refMethod;\n+                        refMethod.projection = valMethod;\n+                        clone = refMethod;\n+                    } else if (s.kind == VAR) {\n+                        VarSymbol valVar = (VarSymbol)s;\n+                        VarSymbol refVar = valVar.clone(projection);\n+                        valVar.projection = refVar;\n+                        refVar.projection = valVar;\n+                        clone = refVar;\n+                    }\n+                    projection.members_field.enter(clone);\n@@ -1710,1 +1711,0 @@\n-                projection.members_field.enter(clone);\n@@ -1712,1 +1712,13 @@\n-            projection.completer = Completer.NULL_COMPLETER;\n+\n+            projection.completer = new Completer() {\n+                @Override\n+                public void complete(Symbol sym) throws CompletionFailure {\n+                    ClassSymbol.this.complete();\n+                }\n+\n+                @Override\n+                public boolean isTerminal() {\n+                    return ClassSymbol.this.completer.isTerminal();\n+                }\n+            };\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":31,"deletions":19,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+    \/** enable alternate code generation to faciliate specialization experiments using type restrictions *\/\n+    public boolean flattenWithTypeRestrictions;\n+\n@@ -129,0 +132,1 @@\n+        flattenWithTypeRestrictions = options.isSet(\"flattenWithTypeRestrictions\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1271,0 +1271,13 @@\n+            new AttributeReader(names.RestrictedField, V60, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowInlineTypes;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind == VAR && sym.owner.kind == TYP) {\n+                        final Type type = poolReader.getType(nextChar());\n+                        Assert.check(((ClassSymbol)((ClassType)sym.type).tsym).projection == type.tsym);\n+                        sym.flags_field |= RESTRICTED_FIELD;\n+                    }\n+                }\n+            },\n@@ -2238,1 +2251,2 @@\n-        return v;\n+        return (v.flags_field & RESTRICTED_FIELD) == RESTRICTED_FIELD ?\n+                new VarSymbol(flags, name, ((ClassSymbol)v.type.tsym).projection.type, currentOwner) : v;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -976,1 +976,8 @@\n-        databuf.appendChar(poolWriter.putDescriptor(v));\n+        boolean emitRestrictedField = false;\n+        if (types.flattenWithTypeRestrictions && v.type.isValue()) {\n+            emitRestrictedField = true;\n+            databuf.appendChar(poolWriter.putDescriptor(v.type.referenceProjection()));\n+        } else {\n+            databuf.appendChar(poolWriter.putDescriptor(v));\n+        }\n+\n@@ -985,0 +992,6 @@\n+        if (emitRestrictedField) {\n+            int alenIdx = writeAttr(names.RestrictedField);\n+            databuf.appendChar(poolWriter.putDescriptor(v));\n+            endAttr(alenIdx);\n+            acount++;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -37,0 +38,2 @@\n+import java.util.HashMap;\n+\n@@ -157,1 +160,5 @@\n-        return new MemberItem(member, nonvirtual);\n+        if (this.types.flattenWithTypeRestrictions && member.kind == Kind.VAR && member.type.isValue()) {\n+            return new MemberItem(getFlattenedField(member), nonvirtual);\n+        } else {\n+            return new MemberItem(member, nonvirtual);\n+        }\n@@ -159,0 +166,15 @@\n+        \/\/ where\n+        private Symbol getFlattenedField(Symbol member) {\n+            if (flatFieldsMap == null)\n+                flatFieldsMap = new HashMap<>();\n+            Symbol flatField = flatFieldsMap.get(member);\n+            if (flatField == null) {\n+                flatFieldsMap.put(member, flatField = new VarSymbol(member.flags(),\n+                                                        member.name,\n+                                                        member.type.referenceProjection(),\n+                                                        member.owner));\n+            }\n+            return flatField;\n+        }\n+\n+     private HashMap<Symbol, Symbol> flatFieldsMap;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Items.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+    public final Name RestrictedField;\n@@ -340,0 +341,1 @@\n+        RestrictedField = fromString(\"RestrictedField\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+    public static final String RestrictedField          = \"RestrictedField\";\n@@ -140,0 +141,1 @@\n+            standardAttributes.put(RestrictedField, RestrictedField_attribute.class);\n@@ -207,0 +209,1 @@\n+        R visitRestrictedField(RestrictedField_attribute attr, P p);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -658,0 +658,6 @@\n+        @Override\n+        public Void visitRestrictedField(RestrictedField_attribute attr, ClassOutputStream out) {\n+            out.writeShort(attr.restricted_type_index);\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * See JVMS, section 4.8.9.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+\n+public class RestrictedField_attribute extends Attribute {\n+    RestrictedField_attribute(ClassReader cr, int name_index, int length) throws IOException {\n+        super(name_index, length);\n+        restricted_type_index = cr.readUnsignedShort();\n+    }\n+    public RestrictedField_attribute(ConstantPool constant_pool, int restricted_type_index)\n+            throws ConstantPoolException {\n+        this(constant_pool.getUTF8Index(Attribute.RestrictedField), restricted_type_index);\n+    }\n+    public RestrictedField_attribute(int name_index, int restricted_type_index) {\n+        super(name_index, 2);\n+        this.restricted_type_index = restricted_type_index;\n+    }\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitRestrictedField(this, data);\n+    }\n+\n+    public String getRestrictedType(ConstantPool constant_pool) throws ConstantPoolException {\n+        return constant_pool.getUTF8Value(restricted_type_index);\n+    }\n+\n+    public final int restricted_type_index;\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RestrictedField_attribute.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.tools.classfile.RestrictedField_attribute;\n@@ -768,0 +769,16 @@\n+    @Override\n+    public Void visitRestrictedField(RestrictedField_attribute attr, Void p) {\n+        print(\"RestrictedField: #\" + attr.restricted_type_index);\n+        tab();\n+        println(\"\/\/ \" + getRestrictedType(attr));\n+        return null;\n+    }\n+\n+    String getRestrictedType(RestrictedField_attribute info) {\n+        try {\n+            return info.getRestrictedType(constant_pool);\n+        } catch (ConstantPoolException e) {\n+            return report(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1374,0 +1374,5 @@\n+\n+        @Override\n+        public Void visitRestrictedField(RestrictedField_attribute attr, T p) {\n+            return null;\n+        }\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    public R visitRestrictedField(RestrictedField_attribute attr, P p) { return null; }\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/AttributeVisitor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253312\n+ * @summary Enable JVM experiments in specialization under an opt-in mode\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions RestrictedFieldCodegenTest.java\n+ * @run main\/othervm -Xverify:none RestrictedFieldCodegenTest\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+class PointBox {\n+\n+    static inline class Point {\n+        public double x;\n+        public double y;\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    public Point p;\n+\n+    public static void main(String... args) {\n+        PointBox b = new PointBox();\n+        if (b.p != new Point(0,0)) throw new RuntimeException();\n+        b.p = new Point(1.0, 2.0);\n+        if (b.p != new Point(1.0, 2.0)) throw new RuntimeException();\n+    }\n+}\n+\n+public class RestrictedFieldCodegenTest {\n+\n+    public static void main(String [] args) {\n+        new RestrictedFieldCodegenTest().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                                            Paths.get(System.getProperty(\"test.classes\"),\n+                                                \"PointBox.class\").toString() };\n+        runCheck(params, new String [] {\n+\n+         \"public PointBox$Point$ref p;\",\n+         \"descriptor: LPointBox$Point$ref;\",\n+         \"RestrictedField: #25                    \/\/ QPointBox$Point;\",\n+         \" 9: getfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         \"36: putfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         \"40: getfield      #10                 \/\/ Field p:LPointBox$Point$ref;\",\n+         });\n+\n+     }\n+\n+     void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        System.out.println(\"Checking javap\");\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        System.out.println(\"Javap = \" + out);\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+         if (errors > 0) {\n+             throw new AssertionError(\"Unexpected javap output: \" + out);\n+         }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldCodegenTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8253312\n+ * @summary Enable JVM experiments in specialization under an opt-in mode\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @compile -XDflattenWithTypeRestrictions -XDrawDiagnostics RestrictedFieldCodegenTest.java\n+ * @compile\/fail\/ref=RestrictedFieldTypeTest.out -XDflattenWithTypeRestrictions -XDrawDiagnostics RestrictedFieldTypeTest.java\n+ *\/\n+\n+public class RestrictedFieldTypeTest {\n+    PointBox rft = new PointBox();\n+    void foo() {\n+        rft.p = null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldTypeTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+RestrictedFieldTypeTest.java:13:17: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, PointBox.Point)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/RestrictedFieldTypeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"}]}