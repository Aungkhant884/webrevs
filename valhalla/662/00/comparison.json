{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.util.HashSet;\n@@ -360,0 +361,10 @@\n+        \/\/ generate Preload attribute if it references any value class\n+        PreloadAttributeBuilder builder = new PreloadAttributeBuilder(targetClass);\n+        builder.add(factoryType)\n+               .add(interfaceMethodType)\n+               .add(implMethodType)\n+               .add(dynamicMethodType)\n+               .add(altMethods);\n+        if (!builder.isEmpty())\n+            cw.visitAttribute(builder.build());\n+\n@@ -593,0 +604,66 @@\n+    \/*\n+     * Preload attribute builder\n+     *\/\n+    static class PreloadAttributeBuilder {\n+        private final Set<Class<?>> preloadClasses = new HashSet<>();\n+        PreloadAttributeBuilder(Class<?> targetClass) {\n+            if (requiresPreload(targetClass)) {\n+                preloadClasses.add(targetClass);\n+            }\n+        }\n+\n+        \/*\n+         * Add the value types referenced in the given MethodType.\n+         *\/\n+        PreloadAttributeBuilder add(MethodType mt) {\n+            \/\/ parameter types\n+            for (Class<?> paramType : mt.ptypes()) {\n+                if (requiresPreload(paramType)) {\n+                    preloadClasses.add(paramType);\n+                }\n+            }\n+            \/\/ return type\n+            if (requiresPreload(mt.returnType())) {\n+                preloadClasses.add(mt.returnType());\n+            }\n+            return this;\n+        }\n+\n+        PreloadAttributeBuilder add(MethodType... mtypes) {\n+            for (MethodType mt : mtypes) {\n+                add(mt);\n+            }\n+            return this;\n+        }\n+\n+        boolean requiresPreload(Class<?> cls) {\n+            Class<?> c = cls;\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+            }\n+            return (c.isValue() && !c.isPrimitiveClass()) || c.isPrimitiveValueType();\n+        }\n+\n+        boolean isEmpty() {\n+            return preloadClasses.isEmpty();\n+        }\n+\n+        Attribute build() {\n+            return new Attribute(\"Preload\") {\n+                @Override\n+                protected ByteVector write(ClassWriter cw,\n+                                           byte[] code,\n+                                           int len,\n+                                           int maxStack,\n+                                           int maxLocals) {\n+                    ByteVector attr = new ByteVector();\n+                    attr.putShort(preloadClasses.size());\n+                    for (Class<?> c : preloadClasses) {\n+                        attr.putShort(cw.newClass(Type.getInternalName(c)));\n+                    }\n+                    return attr;\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.org.objectweb.asm.Attribute;\n+import jdk.internal.org.objectweb.asm.ByteVector;\n@@ -43,0 +45,1 @@\n+import java.util.HashSet;\n@@ -47,0 +50,1 @@\n+import java.util.Set;\n@@ -493,0 +497,1 @@\n+        Set<Class<?>> preloadClasses = new HashSet<>();\n@@ -501,0 +506,1 @@\n+                preloadClasses.addAll(pm.preloadClasses());\n@@ -503,0 +509,3 @@\n+        if (preloadClasses.size() > 0) {\n+            generatePreloadAttribute(preloadClasses);\n+        }\n@@ -677,0 +686,18 @@\n+    private void generatePreloadAttribute(Set<Class<?>> preloadClasses) {\n+        Attribute attr = new Attribute(\"Preload\") {\n+            @Override\n+            protected ByteVector write(ClassWriter cw,\n+                                       byte[] code,\n+                                       int len,\n+                                       int maxStack,\n+                                       int maxLocals) {\n+                ByteVector attr = new ByteVector();\n+                attr.putShort(preloadClasses.size());\n+                for (Class<?> c : preloadClasses) {\n+                    attr.putShort(cw.newClass(Type.getInternalName(c)));\n+                }\n+                return attr;\n+            }\n+        };\n+        visitAttribute(attr);\n+    }\n@@ -806,0 +833,21 @@\n+        Set<Class<?>> preloadClasses() {\n+            Set<Class<?>> preloadClasses = new HashSet<>();\n+            for (Class<?> type : parameterTypes) {\n+                if (requiresPreload(type)) {\n+                    preloadClasses.add(type);\n+                }\n+            }\n+            if (requiresPreload(returnType)) {\n+                preloadClasses.add(returnType);\n+            }\n+            return preloadClasses;\n+        }\n+\n+        boolean requiresPreload(Class<?> cls) {\n+            Class<?> c = cls;\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+            }\n+            return (c.isValue() && !c.isPrimitiveClass()) || c.isPrimitiveValueType();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test lambdas with parameter types or return type of value class\n+ * @run testng\/othervm LambdaTest\n+ *\/\n+\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class LambdaTest {\n+    static value class V {\n+        int v;\n+        V(int v) {\n+            this.v = v;\n+        }\n+\n+        static V get(int v) {\n+            return new V(v);\n+        }\n+    }\n+\n+    static primitive class P {\n+        int p;\n+        P(int p) {\n+            this.p = p;\n+        }\n+\n+        static P get(int p) {\n+            return new P(p);\n+        }\n+    }\n+\n+    static int getV(V v) {\n+        return v.v;\n+    }\n+\n+    static int getP(P p) {\n+        return p.p;\n+    }\n+\n+    @Test\n+    public void testValueParameterType() {\n+        Function<P.ref, Integer> func1 = LambdaTest::getP;\n+        assertTrue(func1.apply(new P(100)) == 100);\n+\n+        Function<V, Integer> func2 = LambdaTest::getV;\n+        assertTrue(func2.apply(new V(200)) == 200);\n+    }\n+\n+    @Test\n+    public void testValueReturnType() {\n+        IntFunction<P.ref> func1 = P::get;\n+        assertEquals(func1.apply(10), new P(10));\n+\n+        IntFunction<V> func2 = V::get;\n+        assertEquals(func2.apply(20), new V(20));\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/LambdaTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test dynamic proxies with parameter types or return type of value class\n+ * @run testng\/othervm ProxyTest\n+ *\/\n+\n+import java.lang.reflect.*;\n+import java.util.Arrays;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class ProxyTest {\n+    static value class V {\n+        int v;\n+        V(int v) {\n+            this.v = v;\n+        }\n+    }\n+\n+    static primitive class P {\n+        int p;\n+        P(int p) {\n+            this.p = p;\n+        }\n+    }\n+\n+    interface I {\n+        int getV(V v);\n+        int getP(P p);\n+    }\n+\n+    interface J {\n+        int[] getV(V[] v);\n+    }\n+\n+    @Test\n+    public void testProxy() throws Exception {\n+        InvocationHandler handler = new InvocationHandler() {\n+            @Override\n+            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                switch (method.getName()) {\n+                    case \"getV\":\n+                        V v = (V)args[0];\n+                        return v.v;\n+                    case \"getP\":\n+                        P p = (P)args[0];\n+                        return p.p;\n+                    default:\n+                        throw new UnsupportedOperationException(method.toString());\n+                }\n+            }\n+        };\n+\n+        Class<?>[] intfs = new Class<?>[] { I.class };\n+        I i = (I) Proxy.newProxyInstance(ProxyTest.class.getClassLoader(), intfs, handler);\n+\n+        assertTrue(i.getV(new V(100)) == 100);\n+        assertTrue(i.getP(new P(200)) == 200);\n+    }\n+\n+    @Test\n+    public void testValueArrayType() {\n+        InvocationHandler handler = new InvocationHandler() {\n+            @Override\n+            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                switch (method.getName()) {\n+                    case \"getV\":\n+                        V[] vs = (V[])args[0];\n+                        return Arrays.stream(vs).mapToInt(v -> v.v).toArray();\n+                    default:\n+                        throw new UnsupportedOperationException(method.toString());\n+                }\n+            }\n+        };\n+\n+        Class<?>[] intfs = new Class<?>[] { J.class };\n+        J j = (J) Proxy.newProxyInstance(ProxyTest.class.getClassLoader(), intfs, handler);\n+\n+        V[] array = new V[] { new V(10), new V(20), new V(30)};\n+        assertEquals(j.getV(array), new int[] { 10, 20, 30});\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/ProxyTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -107,19 +107,0 @@\n-    @Test\n-    public void testProxy() throws Exception {\n-        InvocationHandler handler = new InvocationHandler() {\n-            @Override\n-            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                if (method.getName().equals(\"toLine\")) {\n-                    return toLine((Point)args[0], (NonFlattenValue)args[1]);\n-                }\n-                throw new UnsupportedOperationException(method.toString());\n-            }\n-        };\n-\n-        Class<?>[] intfs = new Class<?>[] { I.class };\n-        I intf = (I) Proxy.newProxyInstance(QTypeDescriptorTest.class.getClassLoader(), intfs, handler);\n-        Line l = intf.toLine(P0, NFV);\n-        assertEquals(l.p1, P0);\n-        assertEquals(l.p2, NFV.pointValue());\n-    }\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/QTypeDescriptorTest.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"}]}