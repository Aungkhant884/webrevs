{"files":[{"patch":"@@ -79,5 +79,0 @@\n-\/\/ Can this inline type be scalarized?\n-bool ciInlineKlass::is_scalarizable() const {\n-  GUARDED_VM_ENTRY(return to_InlineKlass()->is_scalarizable();)\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-  bool is_scalarizable() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+  _is_init = read_from(stream);\n@@ -170,0 +171,5 @@\n+    if (_is_init == NULL) {\n+      \/\/ MarkerValue is used for null-free objects\n+      _is_init = new MarkerValue();\n+    }\n+    _is_init->write_on(stream);\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+  ScopeValue*                _is_init;\n@@ -125,1 +126,1 @@\n-  ObjectValue(int id, ScopeValue* klass)\n+  ObjectValue(int id, ScopeValue* klass, ScopeValue* is_init = NULL)\n@@ -128,0 +129,1 @@\n+     , _is_init(is_init)\n@@ -137,0 +139,1 @@\n+     , _is_init(NULL)\n@@ -145,0 +148,1 @@\n+  ScopeValue*                 is_init() const           { return _is_init; }\n@@ -150,0 +154,1 @@\n+  bool                        maybe_null() const        { return !_is_init->is_marker(); }\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -343,5 +343,0 @@\n-\/\/ Can this inline type be scalarized?\n-bool InlineKlass::is_scalarizable() const {\n-  return ScalarizeInlineTypes;\n-}\n-\n@@ -350,1 +345,1 @@\n-  return InlineTypePassFieldsAsArgs && is_scalarizable();\n+  return InlineTypePassFieldsAsArgs;\n@@ -355,1 +350,1 @@\n-  return InlineTypeReturnedAsFields && is_scalarizable() && (init || return_regs() != NULL);\n+  return InlineTypeReturnedAsFields && (init || return_regs() != NULL);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-  bool is_scalarizable() const;\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -834,3 +834,0 @@\n-        \/\/ Only possible with is_mh_late_inline() when the callee does not \"know\" that the caller expects an oop\n-        assert(is_mh_late_inline(), \"sanity\");\n-        assert(buffer_oop != NULL, \"should have allocated a buffer\");\n@@ -839,0 +836,1 @@\n+          assert(buffer_oop != NULL, \"should have allocated a buffer\");\n@@ -1182,3 +1180,2 @@\n-  if (sig_type->is_inlinetypeptr() && !arg->is_InlineType() &&\n-      !kit.gvn().type(arg)->maybe_null() && t->as_inline_klass()->is_scalarizable()) {\n-    arg = InlineTypeNode::make_from_oop(&kit, arg, t->as_inline_klass());\n+  if (sig_type->is_inlinetypeptr() && !arg->is_InlineType()) {\n+    arg = InlineTypeNode::make_from_oop(&kit, arg, t->as_inline_klass(), !kit.gvn().type(arg)->maybe_null());\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -501,0 +501,7 @@\n+        if (iklass != NULL && iklass->is_inlinetype()) {\n+          Node* init_node = mcall->in(first_ind++);\n+          if (!init_node->is_top()) {\n+            st->print(\" [is_init\");\n+            format_helper(regalloc, st, init_node, \":\", -1, NULL);\n+          }\n+        }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1915,0 +1915,37 @@\n+\/\/ Push inline type input nodes (and null) down through the phi recursively (can handle data loops).\n+InlineTypeBaseNode* PhiNode::push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk) {\n+  InlineTypeBaseNode* vt = NULL;\n+  if (_type->isa_ptr()) {\n+    vt = InlineTypePtrNode::make_null(*phase, vk)->clone_with_phis(phase, in(0));\n+  } else {\n+    vt = InlineTypeNode::make_null(*phase, vk)->clone_with_phis(phase, in(0));\n+  }\n+  if (can_reshape) {\n+    \/\/ Replace phi right away to be able to use the inline\n+    \/\/ type node when reaching the phi again through data loops.\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+      Node* u = fast_out(i);\n+      igvn->rehash_node_delayed(u);\n+      imax -= u->replace_edge(this, vt);\n+      --i;\n+    }\n+    assert(outcnt() == 0, \"should be dead now\");\n+  }\n+  for (uint i = 1; i < req(); ++i) {\n+    Node* n = in(i)->uncast();\n+    Node* other = NULL;\n+    if (n->is_InlineTypeBase()) {\n+      other = n;\n+    } else if (phase->type(n)->is_zero_type()) {\n+      other = InlineTypePtrNode::make_null(*phase, vk);\n+    } else {\n+      assert(can_reshape, \"can only handle phis during IGVN\");\n+      other = phase->transform(n->as_Phi()->push_inline_types_through(phase, can_reshape, vk));\n+    }\n+    bool transform = !can_reshape && (i == (req()-1)); \/\/ Transform phis on last merge\n+    vt->merge_with(phase, other->as_InlineTypeBase(), i, transform);\n+  }\n+  return vt;\n+}\n+\n@@ -1928,19 +1965,0 @@\n-  \/\/ If all inputs are inline types of the same type, push the inline type node down\n-  \/\/ through the phi because inline type nodes should be merged through their input values.\n-  if (req() > 2 && in(1) != NULL && in(1)->is_InlineTypeBase() && (can_reshape || in(1)->is_InlineType())) {\n-    int opcode = in(1)->Opcode();\n-    uint i = 2;\n-    \/\/ Check if inputs are values of the same type\n-    for (; i < req() && in(i) && in(i)->is_InlineTypeBase() && in(i)->cmp(*in(1)); i++) {\n-      assert(in(i)->Opcode() == opcode, \"mixing pointers and values?\");\n-    }\n-    if (i == req()) {\n-      InlineTypeBaseNode* vt = in(1)->as_InlineTypeBase()->clone_with_phis(phase, in(0));\n-      for (i = 2; i < req(); ++i) {\n-        bool transform = !can_reshape && (i == (req()-1)); \/\/ Transform phis on last merge\n-        vt->merge_with(phase, in(i)->as_InlineTypeBase(), i, transform);\n-      }\n-      return vt;\n-    }\n-  }\n-\n@@ -2485,0 +2503,35 @@\n+  \/\/ Check recursively if inputs are either an inline type, constant null\n+  \/\/ or another Phi (including self references through data loops). If so,\n+  \/\/ push the inline types down through the phis to enable folding of loads.\n+  if (EnableValhalla && req() > 2 && progress == NULL) {\n+    ResourceMark rm;\n+    Unique_Node_List worklist;\n+    worklist.push(this);\n+    bool can_optimize = true;\n+    ciInlineKlass* vk = NULL;\n+\n+    for (uint next = 0; next < worklist.size() && can_optimize; next++) {\n+      Node* phi = worklist.at(next);\n+      for (uint i = 1; i < phi->req() && can_optimize; i++) {\n+        Node* n = phi->in(i);\n+        if (n == NULL) {\n+          can_optimize = false;\n+          break;\n+        }\n+        n = n->uncast();\n+        const Type* t = phase->type(n);\n+        if (n->is_InlineTypeBase() && n->as_InlineTypeBase()->can_merge() &&\n+            (vk == NULL || vk == t->inline_klass())) {\n+          vk = (vk == NULL) ? t->inline_klass() : vk;\n+        } else if (n->is_Phi() && can_reshape) {\n+          worklist.push(n);\n+        } else if (!t->is_zero_type()) {\n+          can_optimize = false;\n+        }\n+      }\n+    }\n+    if (can_optimize && vk != NULL) {\n+      progress = push_inline_types_through(phase, can_reshape, vk);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":72,"deletions":19,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -218,0 +218,2 @@\n+  InlineTypeBaseNode* push_inline_types_through(PhaseGVN* phase, bool can_reshape, ciInlineKlass* vk);\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,0 +432,3 @@\n+    if (n->outcnt() == 0) {\n+      worklist->push(n);\n+    }\n@@ -1912,1 +1915,1 @@\n-    for (uint i = 1; i < root()->req(); i++){\n+    for (uint i = 1; i < root()->req(); i++) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -753,2 +753,1 @@\n-    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineType() &&\n-        !gvn().type(peek())->maybe_null() && rtype->as_inline_klass()->is_scalarizable()) {\n+    if (rtype->basic_type() == T_INLINE_TYPE && !peek()->is_InlineType() && !gvn().type(peek())->maybe_null()) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1250,0 +1250,15 @@\n+  if (value->is_InlineTypePtr()) {\n+    \/\/ Null checking a scalarized but nullable inline type. Check the is_init\n+    \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+    InlineTypePtrNode* vtptr = value->as_InlineTypePtr();\n+    while (vtptr->get_oop()->is_InlineTypePtr()) {\n+      vtptr = vtptr->get_oop()->as_InlineTypePtr();\n+    }\n+    null_check_common(vtptr->get_is_init(), type, assert_null, null_control, speculative);\n+    if (stopped()) {\n+      return top();\n+    }\n+    bool do_replace_in_map = (null_control == NULL || (*null_control) == top());\n+    return cast_not_null(value, do_replace_in_map);\n+  }\n+\n@@ -1427,17 +1442,0 @@\n-Node* GraphKit::null2default(Node* value, ciInlineKlass* vk) {\n-  assert(!vk->is_scalarizable(), \"Should only be used for non scalarizable inline klasses\");\n-  Node* null_ctl = top();\n-  value = null_check_oop(value, &null_ctl);\n-  if (!null_ctl->is_top()) {\n-    \/\/ Return default value if oop is null\n-    Node* region = new RegionNode(3);\n-    region->init_req(1, control());\n-    region->init_req(2, null_ctl);\n-    value = PhiNode::make(region, value, TypeInstPtr::make(TypePtr::BotPTR, vk));\n-    value->set_req(2, InlineTypeNode::default_oop(gvn(), vk));\n-    set_control(gvn().transform(region));\n-    value = gvn().transform(value);\n-  }\n-  return value;\n-}\n-\n@@ -1449,0 +1447,15 @@\n+  } else if (obj->is_InlineTypePtr()) {\n+    \/\/ Cast oop input instead\n+    Node* cast = cast_not_null(obj->as_InlineTypePtr()->get_oop(), do_replace_in_map);\n+    if (cast->is_top()) {\n+      return top();\n+    }\n+    \/\/ Create a new node with the casted oop input and is_init set\n+    InlineTypeBaseNode* vt = new InlineTypePtrNode(obj->as_InlineTypePtr());\n+    vt->set_oop(cast);\n+    vt->set_is_init(_gvn);\n+    vt = _gvn.transform(vt)->as_InlineTypePtr();\n+    if (do_replace_in_map) {\n+      replace_in_map(obj, vt);\n+    }\n+    return vt;\n@@ -1459,5 +1472,0 @@\n-  if (t->is_inlinetypeptr() && t->inline_klass()->is_scalarizable()) {\n-    \/\/ Scalarize inline type now that we know it's non-null\n-    cast = InlineTypeNode::make_from_oop(this, cast, t->inline_klass())->as_ptr(&gvn());\n-  }\n-\n@@ -1843,1 +1851,1 @@\n-      InlineTypeNode* vt = arg->as_InlineType();\n+      InlineTypeBaseNode* vt = arg->as_InlineTypeBase();\n@@ -1912,6 +1920,12 @@\n-  } else if (call->tf()->returns_inline_type_as_fields()) {\n-    \/\/ Return of multiple values (inline type fields): we create a\n-    \/\/ InlineType node, each field is a projection from the call.\n-    ciInlineKlass* vk = call->method()->return_type()->as_inline_klass();\n-    uint base_input = TypeFunc::Parms;\n-    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false);\n+  } else if (call->method()->return_type()->is_inlinetype()) {\n+    const Type* ret_type = call->tf()->range_sig()->field_at(TypeFunc::Parms);\n+    if (call->tf()->returns_inline_type_as_fields()) {\n+      \/\/ Return of multiple values (inline type fields): we create a\n+      \/\/ InlineType node, each field is a projection from the call.\n+      ciInlineKlass* vk = call->method()->return_type()->as_inline_klass();\n+      uint base_input = TypeFunc::Parms;\n+      ret = InlineTypeNode::make_from_multi(this, call, ret_type->inline_klass(), base_input, false);\n+    } else {\n+      ret = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+      ret = _gvn.transform(InlineTypeNode::make_from_oop(this, ret, ret_type->inline_klass(), !ret_type->maybe_null()));\n+    }\n@@ -3117,1 +3131,1 @@\n-      if (recv_xtype->is_inlinetypeptr() && recv_xtype->inline_klass()->is_scalarizable()) {\n+      if (recv_xtype->is_inlinetypeptr()) {\n@@ -3119,1 +3133,1 @@\n-        res = InlineTypeNode::make_from_oop(this, res, recv_xtype->inline_klass())->as_ptr(&gvn());\n+        res = InlineTypeNode::make_from_oop(this, res, recv_xtype->inline_klass())->as_InlineTypeBase()->as_ptr(&gvn());\n@@ -3475,0 +3489,1 @@\n+  bool safe_for_replace = (failure_control == NULL);\n@@ -3486,1 +3501,1 @@\n-    if (from_inline) {\n+    if (obj->is_InlineTypeBase()) {\n@@ -3503,0 +3518,1 @@\n+            assert(safe_for_replace, \"must be\");\n@@ -3505,3 +3521,2 @@\n-          if (toop->is_inlinetypeptr() && toop->inline_klass()->is_scalarizable() && !gvn().type(obj)->maybe_null()) {\n-            obj = InlineTypeNode::make_from_oop(this, obj, toop->inline_klass());\n-          }\n+          assert(stopped() || !toop->is_inlinetypeptr() ||\n+                 obj->is_InlineTypeBase(), \"should have been scalarized\");\n@@ -3513,0 +3528,1 @@\n+            assert(safe_for_replace, \"must be\");\n@@ -3534,1 +3550,0 @@\n-  bool safe_for_replace = false;\n@@ -3542,1 +3557,0 @@\n-    safe_for_replace = true;\n@@ -3565,0 +3579,1 @@\n+    assert(safe_for_replace, \"must be\");\n@@ -3625,1 +3640,1 @@\n-        if (from_inline) {\n+        if (not_null_obj->is_InlineTypeBase()) {\n@@ -3694,1 +3709,1 @@\n-  if (!stopped() && !from_inline) {\n+  if (!stopped() && !res->is_InlineTypeBase()) {\n@@ -3696,2 +3711,11 @@\n-    if (toop->is_inlinetypeptr() && toop->inline_klass()->is_scalarizable() && !gvn().type(res)->maybe_null()) {\n-      res = InlineTypeNode::make_from_oop(this, res, toop->inline_klass());\n+    if (toop->is_inlinetypeptr()) {\n+      Node* vt = InlineTypeNode::make_from_oop(this, res, toop->inline_klass(), !gvn().type(res)->maybe_null());\n+      res = vt;\n+      if (safe_for_replace) {\n+        if (vt->isa_InlineType() && C->inlining_incrementally()) {\n+          vt = vt->as_InlineType()->as_ptr(&_gvn);\n+        }\n+        replace_in_map(obj, vt);\n+        replace_in_map(not_null_obj, vt);\n+        replace_in_map(res, vt);\n+      }\n@@ -4717,6 +4741,4 @@\n-    \/\/ Check type of constant which might be more precise\n-    if (con_type->is_inlinetypeptr() && con_type->inline_klass()->is_scalarizable()) {\n-      assert(!con_type->is_zero_type(), \"Inline types are null-free\");\n-      con = InlineTypeNode::make_from_oop(this, con, con_type->inline_klass());\n-    } else if (con_type->is_zero_type() && field->is_null_free()) {\n-      con = InlineTypeNode::default_oop(gvn(), field->type()->as_inline_klass());\n+    if (field->type()->is_inlinetype()) {\n+      con = InlineTypeNode::make_from_oop(this, con, field->type()->as_inline_klass(), field->is_null_free());\n+    } else if (con_type->is_inlinetypeptr()) {\n+      con = InlineTypeNode::make_from_oop(this, con, con_type->inline_klass(), field->is_null_free());\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":69,"deletions":47,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -394,2 +394,0 @@\n-  Node* null2default(Node* value, ciInlineKlass* vk = NULL);\n-\n@@ -710,0 +708,2 @@\n+    \/\/ TODO Remove this code once InlineTypeNodes are replaced by InlineTypePtrNodes\n+    set_argument(0, n);\n@@ -713,1 +713,1 @@\n-    if (recv_type->is_inlinetypeptr() && recv_type->inline_klass()->is_scalarizable()) {\n+    if (recv_type->is_inlinetypeptr()) {\n@@ -715,1 +715,1 @@\n-      InlineTypeNode* vt = InlineTypeNode::make_from_oop(this, n, recv_type->inline_klass());\n+      Node* vt = InlineTypeNode::make_from_oop(this, n, recv_type->inline_klass());\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,6 @@\n+  if (vt->is_InlineTypePtr()) {\n+    \/\/ Use nullable type\n+    const Type* t = Type::get_const_type(inline_klass());\n+    gvn->set_type(vt, t);\n+    vt->as_InlineTypePtr()->set_type(t);\n+  }\n@@ -48,0 +54,6 @@\n+  \/\/ Create a PhiNode for merging the is_init values\n+  PhiNode* is_init = PhiNode::make(region, vt->get_is_init(), phi_type);\n+  gvn->set_type(is_init, phi_type);\n+  gvn->record_for_igvn(is_init);\n+  vt->set_req(IsInit, is_init);\n+\n@@ -53,1 +65,1 @@\n-      \/\/ Handle flattened inline type fields recursively\n+      \/\/ Handle inline type fields recursively\n@@ -76,1 +88,1 @@\n-    for (uint i = Oop; i < field_count(); ++i) {\n+    for (uint i = Values; i < field_count(); ++i) {\n@@ -89,0 +101,13 @@\n+\/\/ Check if all inline type fields have inline type node values\n+bool InlineTypeBaseNode::can_merge() {\n+  for (uint i = 0; i < field_count(); ++i) {\n+    ciType* type = field_type(i);\n+    Node* val = field_value(i);\n+    if (type->is_inlinetype() &&\n+        (!val->is_InlineTypeBase() || !val->as_InlineTypeBase()->can_merge())) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -97,0 +122,7 @@\n+\n+  phi = get_is_init()->as_Phi();\n+  phi->set_req(pnum, other->get_is_init());\n+  if (transform) {\n+    set_req(IsInit, gvn->transform(phi));\n+  }\n+\n@@ -122,0 +154,4 @@\n+  phi = get_is_init()->as_Phi();\n+  phi->add_req(NULL);\n+  assert(phi->req() == region->req(), \"must be same size as region\");\n+\n@@ -124,2 +160,2 @@\n-    if (val->is_InlineType()) {\n-      val->as_InlineType()->add_new_path(region);\n+    if (val->is_InlineTypeBase()) {\n+      val->as_InlineTypeBase()->add_new_path(region);\n@@ -203,1 +239,1 @@\n-int InlineTypeBaseNode::make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List& worklist, SafePointNode* sfpt) {\n+void InlineTypeBaseNode::make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List& worklist, SafePointNode* sfpt) {\n@@ -216,0 +252,7 @@\n+  \/\/ Nullable inline types have an is_init field that needs\n+  \/\/ to be checked before using the field values.\n+  if (igvn->type(get_is_init())->maybe_null()) {\n+    sfpt->add_req(get_is_init());\n+  } else {\n+    sfpt->add_req(igvn->C->top());\n+  }\n@@ -230,1 +273,6 @@\n-  return sfpt->replace_edges_in_range(this, sobj, jvms->debug_start(), jvms->debug_end(), igvn);\n+  for (uint i = jvms->debug_start(); i < jvms->debug_end(); i++) {\n+    Node* debug = sfpt->in(i);\n+    if (debug != NULL && debug->uncast() == this) {\n+      sfpt->set_req(i, sobj);\n+    }\n+  }\n@@ -234,1 +282,9 @@\n-  \/\/ Process all safepoint uses and scalarize inline type\n+  \/\/ If the inline type has a constant or loaded oop, use the oop instead of scalarization\n+  \/\/ in the safepoint to avoid keeping field loads live just for the debug info.\n+  Node* oop = get_oop();\n+  bool use_oop = allow_oop && (is_InlineTypePtr() || is_allocated(igvn)) &&\n+                 (oop->is_Con() || oop->is_Load() || (oop->isa_DecodeN() && oop->in(1)->is_Load()));\n+\n+  ResourceMark rm;\n+  Unique_Node_List safepoints;\n+  Unique_Node_List vt_worklist;\n@@ -236,10 +292,9 @@\n-  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-    SafePointNode* sfpt = fast_out(i)->isa_SafePoint();\n-    if (sfpt != NULL && !sfpt->is_CallLeaf() && (!sfpt->is_Call() || sfpt->as_Call()->has_debug_use(this))) {\n-      int nb = 0;\n-      if (allow_oop && is_allocated(igvn) && get_oop()->is_Con()) {\n-        \/\/ Inline type is allocated with a constant oop, link it directly\n-        nb = sfpt->replace_edges_in_range(this, get_oop(), sfpt->jvms()->debug_start(), sfpt->jvms()->debug_end(), igvn);\n-        igvn->rehash_node_delayed(sfpt);\n-      } else {\n-        nb = make_scalar_in_safepoint(igvn, worklist, sfpt);\n+  worklist.push(this);\n+  while (worklist.size() > 0) {\n+    Node* n = worklist.pop();\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* use = n->fast_out(i);\n+      if (use->is_SafePoint() && !use->is_CallLeaf() && (!use->is_Call() || use->as_Call()->has_debug_use(n))) {\n+        safepoints.push(use);\n+      } else if (use->is_ConstraintCast()) {\n+        worklist.push(use);\n@@ -247,1 +302,16 @@\n-      --i; imax -= nb;\n+    }\n+  }\n+\n+  \/\/ Process all safepoint uses and scalarize inline type\n+  while (safepoints.size() > 0) {\n+    SafePointNode* sfpt = safepoints.pop()->as_SafePoint();\n+    if (use_oop) {\n+      for (uint i = sfpt->jvms()->debug_start(); i < sfpt->jvms()->debug_end(); i++) {\n+        Node* debug = sfpt->in(i);\n+        if (debug != NULL && debug->uncast() == this) {\n+          sfpt->set_req(i, get_oop());\n+        }\n+      }\n+      igvn->rehash_node_delayed(sfpt);\n+    } else {\n+      make_scalar_in_safepoint(igvn, vt_worklist, sfpt);\n@@ -251,2 +321,2 @@\n-  for (uint i = 0; i < worklist.size(); ++i) {\n-    InlineTypeBaseNode* vt = worklist.at(i)->isa_InlineTypeBase();\n+  for (uint i = 0; i < vt_worklist.size(); ++i) {\n+    InlineTypeBaseNode* vt = vt_worklist.at(i)->isa_InlineTypeBase();\n@@ -284,1 +354,1 @@\n-    bool is_null_free = field_is_null_free(i);\n+    bool null_free = field_is_null_free(i);\n@@ -294,1 +364,2 @@\n-      if (base->is_Con() && !is_array) {\n+      bool mismatched = (decorators & C2_MISMATCHED) != 0;\n+      if (base->is_Con() && !is_array && !mismatched) {\n@@ -307,1 +378,1 @@\n-          is_null_free = true;\n+          null_free = true;\n@@ -321,7 +392,3 @@\n-      if (is_null_free) {\n-        \/\/ Loading a non-flattened inline type from memory\n-        if (ft->as_inline_klass()->is_scalarizable()) {\n-          value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass());\n-        } else {\n-          value = kit->null2default(value, ft->as_inline_klass());\n-        }\n+      \/\/ Loading a non-flattened inline type from memory\n+      if (ft->is_inlinetype()) {\n+        value = InlineTypeNode::make_from_oop(kit, value, ft->as_inline_klass(), null_free);\n@@ -522,0 +589,5 @@\n+  Node* is_init = get_is_init();\n+  if (is_init->isa_InlineTypePtr()) {\n+    set_req(IsInit, is_init->as_InlineTypePtr()->get_is_init());\n+    return this;\n+  }\n@@ -523,1 +595,1 @@\n-  if (oop->isa_InlineTypePtr()) {\n+  if (oop->isa_InlineTypePtr() && !phase->type(oop)->maybe_null()) {\n@@ -526,0 +598,1 @@\n+    set_is_init(*phase);\n@@ -537,1 +610,3 @@\n-  return new InlineTypeNode(vk, oop);\n+  InlineTypeNode* vt = new InlineTypeNode(vk, oop);\n+  vt->set_is_init(gvn);\n+  return vt;\n@@ -540,1 +615,1 @@\n-Node* InlineTypeNode::default_oop(PhaseGVN& gvn, ciInlineKlass* vk) {\n+Node* InlineTypeBaseNode::default_oop(PhaseGVN& gvn, ciInlineKlass* vk) {\n@@ -550,5 +625,5 @@\n-    Node* value = NULL;\n-    if (vt->field_is_null_free(i)) {\n-      ciInlineKlass* field_klass = field_type->as_inline_klass();\n-      if (field_klass->is_scalarizable()) {\n-        value = make_default(gvn, field_klass);\n+    Node* value = gvn.zerocon(field_type->basic_type());\n+    if (field_type->is_inlinetype()) {\n+      ciInlineKlass* vk = field_type->as_inline_klass();\n+      if (vt->field_is_null_free(i)) {\n+        value = make_default(gvn, vk);\n@@ -556,1 +631,1 @@\n-        value = default_oop(gvn, field_klass);\n+        value = InlineTypePtrNode::make_null(gvn, vk);\n@@ -558,2 +633,0 @@\n-    } else {\n-      value = gvn.zerocon(field_type->basic_type());\n@@ -568,1 +641,18 @@\n-bool InlineTypeNode::is_default(PhaseGVN* gvn) const {\n+InlineTypeNode* InlineTypeNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n+  InlineTypeNode* vt = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT));\n+  for (uint i = 0; i < vt->field_count(); i++) {\n+    ciType* field_type = vt->field_type(i);\n+    Node* value = gvn.zerocon(field_type->basic_type());\n+    if (field_type->is_inlinetype()) {\n+      if (vt->field_is_null_free(i)) {\n+        value = InlineTypeNode::make_null(gvn, field_type->as_inline_klass());\n+      } else {\n+        value = InlineTypePtrNode::make_null(gvn, field_type->as_inline_klass());\n+      }\n+    }\n+    vt->set_field_value(i, value);\n+  }\n+  return gvn.transform(vt)->as_InlineType();\n+}\n+\n+bool InlineTypeBaseNode::is_default(PhaseGVN* gvn) const {\n@@ -571,0 +661,3 @@\n+    if (value->is_InlineTypePtr()) {\n+      value = value->as_InlineTypePtr()->get_oop();\n+    }\n@@ -572,2 +665,1 @@\n-        !(value->is_InlineType() && value->as_InlineType()->is_default(gvn)) &&\n-        !(field_type(i)->is_inlinetype() && value == default_oop(*gvn, field_type(i)->as_inline_klass()))) {\n+        !(field_is_null_free(i) && value->is_InlineType() && value->as_InlineType()->is_default(gvn))) {\n@@ -580,1 +672,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk) {\n+Node* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free) {\n@@ -582,0 +674,1 @@\n+\n@@ -583,1 +676,5 @@\n-    return make_default(gvn, vk);\n+    InlineTypeNode* def = make_default(gvn, vk);\n+    if (!null_free) {\n+      return gvn.transform(new InlineTypePtrNode(def, false));\n+    }\n+    return def;\n@@ -587,1 +684,1 @@\n-  InlineTypeNode* vt = new InlineTypeNode(vk, oop);\n+  InlineTypeBaseNode* vt = NULL;\n@@ -589,5 +686,8 @@\n-  if (oop->isa_InlineTypePtr()) {\n-    \/\/ Can happen with late inlining\n-    InlineTypePtrNode* vtptr = oop->as_InlineTypePtr();\n-    vt->set_oop(vtptr->get_oop());\n-    for (uint i = Oop+1; i < vtptr->req(); ++i) {\n+  if (oop->uncast()->isa_InlineTypePtr()) {\n+    InlineTypePtrNode* vtptr = oop->uncast()->as_InlineTypePtr();\n+    if (!null_free) {\n+      return vtptr;\n+    }\n+    vt = new InlineTypeNode(vk, vtptr->get_oop());\n+    vt->set_is_init(gvn);\n+    for (uint i = Values; i < vtptr->req(); ++i) {\n@@ -596,0 +696,1 @@\n+    return gvn.transform(vt);\n@@ -603,1 +704,5 @@\n-      return make_default(gvn, vk);\n+      if (null_free) {\n+        return make_default(gvn, vk);\n+      } else {\n+        return InlineTypePtrNode::make_null(gvn, vk);\n+      }\n@@ -605,1 +710,6 @@\n-    vt->set_oop(not_null_oop);\n+    if (null_free) {\n+      vt = new InlineTypeNode(vk, not_null_oop);\n+    } else {\n+      vt = new InlineTypePtrNode(vk, not_null_oop);\n+    }\n+    vt->set_is_init(gvn);\n@@ -609,2 +719,6 @@\n-      \/\/ Return default inline type if oop is null\n-      InlineTypeNode* def = make_default(gvn, vk);\n+      InlineTypeBaseNode* null_vt = NULL;\n+      if (null_free) {\n+        null_vt = make_default(gvn, vk);\n+      } else {\n+        null_vt = InlineTypePtrNode::make_null(gvn, vk);\n+      }\n@@ -615,2 +729,2 @@\n-      vt = vt->clone_with_phis(&gvn, region)->as_InlineType();\n-      vt->merge_with(&gvn, def, 2, true);\n+      vt = vt->clone_with_phis(&gvn, region);\n+      vt->merge_with(&gvn, null_vt, 2, true);\n@@ -620,0 +734,5 @@\n+    if (null_free) {\n+      vt = new InlineTypeNode(vk, oop);\n+    } else {\n+      vt = new InlineTypePtrNode(vk, oop);\n+    }\n@@ -622,0 +741,1 @@\n+    vt->set_is_init(gvn);\n@@ -623,2 +743,2 @@\n-    assert(vt->is_default(&gvn) || init_ctl != kit->control() || !gvn.type(oop)->is_inlinetypeptr() || oop->is_Con() || oop->Opcode() == Op_InlineTypePtr ||\n-           AllocateNode::Ideal_allocation(oop, &gvn) != NULL || vt->is_loaded(&gvn) == oop, \"inline type should be loaded\");\n+    assert(!null_free || vt->as_InlineType()->is_default(&gvn) || init_ctl != kit->control() || !gvn.type(oop)->is_inlinetypeptr() || oop->is_Con() || oop->Opcode() == Op_InlineTypePtr ||\n+           AllocateNode::Ideal_allocation(oop, &gvn) != NULL || vt->as_InlineType()->is_loaded(&gvn) == oop, \"inline type should be loaded\");\n@@ -626,3 +746,2 @@\n-\n-  assert(vt->is_allocated(&gvn), \"inline type should be allocated\");\n-  return gvn.transform(vt)->as_InlineType();\n+  assert(!null_free || vt->is_allocated(&gvn), \"inline type should be allocated\");\n+  return gvn.transform(vt);\n@@ -710,3 +829,3 @@\n-    if (value->is_InlineType()) {\n-      InlineTypeNode* vt = value->as_InlineType();\n-      if (vt->inline_klass()->is_empty()) {\n+    if (value->is_InlineTypeBase()) {\n+      InlineTypeBaseNode* vt = value->as_InlineTypeBase();\n+      if (vt->type()->inline_klass()->is_empty()) {\n@@ -714,1 +833,1 @@\n-      } else if (field_is_flattened(i)) {\n+      } else if (field_is_flattened(i) && vt->is_InlineType()) {\n@@ -716,1 +835,1 @@\n-        base = vt->is_loaded(phase, vk, base, offset - vt->inline_klass()->first_field_offset());\n+        base = vt->as_InlineType()->is_loaded(phase, vk, base, offset - vt->type()->inline_klass()->first_field_offset());\n@@ -754,1 +873,1 @@\n-Node* InlineTypeNode::tagged_klass(ciInlineKlass* vk, PhaseGVN& gvn) {\n+Node* InlineTypeBaseNode::tagged_klass(ciInlineKlass* vk, PhaseGVN& gvn) {\n@@ -761,1 +880,1 @@\n-void InlineTypeNode::pass_fields(GraphKit* kit, Node* n, uint& base_input) {\n+void InlineTypeBaseNode::pass_fields(GraphKit* kit, Node* n, uint& base_input) {\n@@ -792,0 +911,1 @@\n+    bool null_free = field_is_null_free(i);\n@@ -807,7 +927,3 @@\n-      if (field_is_null_free(i)) {\n-        \/\/ Non-flattened inline type field\n-        if (type->as_inline_klass()->is_scalarizable()) {\n-          parm = make_from_oop(kit, parm, type->as_inline_klass());\n-        } else {\n-          parm = kit->null2default(parm, type->as_inline_klass());\n-        }\n+      \/\/ Non-flattened inline type field\n+      if (type->is_inlinetype()) {\n+        parm = make_from_oop(kit, parm, type->as_inline_klass(), null_free);\n@@ -866,1 +982,1 @@\n-    if (base != NULL) {\n+    if (base != NULL && !phase->type(base)->maybe_null()) {\n@@ -949,21 +1065,10 @@\n-Node* InlineTypePtrNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  if (can_reshape) {\n-    \/\/ Remove useless InlineTypePtr nodes that might keep other nodes alive\n-    ResourceMark rm;\n-    Unique_Node_List users;\n-    users.push(this);\n-    bool useless = true;\n-    for (uint i = 0; i < users.size(); ++i) {\n-      Node* use = users.at(i);\n-      if (use->is_Cmp() || use->Opcode() == Op_Return || use->Opcode() == Op_CastP2X || (use == this && i != 0) ||\n-          (use->is_Load() && use->outcnt() == 1 && use->unique_out() == this)) {\n-        \/\/ No need to keep track of field values, we can just use the oop\n-        continue;\n-      }\n-      if (use->is_Load() || use->is_Store() || (use->is_InlineTypeBase() && use != this) || use->is_SafePoint()) {\n-        \/\/ We need to keep track of field values to allow the use to be folded\/scalarized\n-        useless = false;\n-        break;\n-      }\n-      for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n-        users.push(use->fast_out(j));\n+InlineTypePtrNode* InlineTypePtrNode::make_null(PhaseGVN& gvn, ciInlineKlass* vk) {\n+  InlineTypePtrNode* ptr = new InlineTypePtrNode(vk, gvn.zerocon(T_OBJECT));\n+  for (uint i = 0; i < ptr->field_count(); i++) {\n+    ciType* field_type = ptr->field_type(i);\n+    Node* value = gvn.zerocon(field_type->basic_type());\n+    if (field_type->is_inlinetype()) {\n+      if (ptr->field_is_null_free(i)) {\n+        value = InlineTypeNode::make_null(gvn, field_type->as_inline_klass());\n+      } else {\n+        value = InlineTypePtrNode::make_null(gvn, field_type->as_inline_klass());\n@@ -972,6 +1077,1 @@\n-    if (useless) {\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      igvn->_worklist.push(this);\n-      igvn->replace_in_uses(this, get_oop());\n-      return NULL;\n-    }\n+    ptr->set_field_value(i, value);\n@@ -979,0 +1079,2 @@\n+  return gvn.transform(ptr)->as_InlineTypePtr();\n+}\n@@ -980,1 +1082,12 @@\n-  return InlineTypeBaseNode::Ideal(phase, can_reshape);\n+Node* InlineTypePtrNode::Identity(PhaseGVN* phase) {\n+  if (get_oop()->is_InlineTypePtr()) {\n+    return get_oop();\n+  }\n+  return this;\n+}\n+\n+const Type* InlineTypePtrNode::Value(PhaseGVN* phase) const {\n+  if (phase->type(in(IsInit))->isa_ptr() && !phase->type(in(IsInit))->is_ptr()->maybe_null()) {\n+    return _type->join_speculative(TypePtr::NOTNULL);\n+  }\n+  return _type;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":219,"deletions":106,"binary":false,"changes":325,"status":"modified"},{"patch":"@@ -42,2 +42,3 @@\n-  enum { Control,   \/\/ Control input\n-         Oop,       \/\/ Oop of TypeInstPtr\n+  enum { Control,   \/\/ Control input.\n+         Oop,       \/\/ Oop to heap allocated buffer (NULL if not buffered).\n+         IsInit,    \/\/ Needs to be checked for NULL before using the field values.\n@@ -52,1 +53,1 @@\n-  int make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List& worklist, SafePointNode* sfpt);\n+  void make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List& worklist, SafePointNode* sfpt);\n@@ -56,0 +57,3 @@\n+  \/\/ Checks if the inline type fields are all set to default values\n+  bool is_default(PhaseGVN* gvn) const;\n+\n@@ -57,0 +61,4 @@\n+\n+  \/\/ Returns the constant oop of the default inline type allocation\n+  static Node* default_oop(PhaseGVN& gvn, ciInlineKlass* vk);\n+\n@@ -60,0 +68,1 @@\n+  bool can_merge();\n@@ -66,0 +75,2 @@\n+  Node* get_is_init() const { return in(IsInit); }\n+  void  set_is_init(PhaseGVN& gvn) { set_req(IsInit, InlineTypeBaseNode::default_oop(gvn, inline_klass())); }\n@@ -99,0 +110,7 @@\n+  Node* tagged_klass(PhaseGVN& gvn) {\n+    return tagged_klass(inline_klass(), gvn);\n+  }\n+  static Node* tagged_klass(ciInlineKlass* vk, PhaseGVN& gvn);\n+  \/\/ Pass inline type as fields at a call or return\n+  void pass_fields(GraphKit* kit, Node* n, uint& base_input);\n+\n@@ -112,0 +130,1 @@\n+    init_req(IsInit, oop);\n@@ -117,3 +136,0 @@\n-  \/\/ Checks if the inline type fields are all set to default values\n-  bool is_default(PhaseGVN* gvn) const;\n-\n@@ -127,0 +143,2 @@\n+  \/\/ Create with null field values\n+  static InlineTypeNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk);\n@@ -128,1 +146,1 @@\n-  static InlineTypeNode* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk);\n+  static Node* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free = true);\n@@ -137,9 +155,0 @@\n-  \/\/ Returns the constant oop of the default inline type allocation\n-  static Node* default_oop(PhaseGVN& gvn, ciInlineKlass* vk);\n-\n-  Node* tagged_klass(PhaseGVN& gvn) {\n-    return tagged_klass(inline_klass(), gvn);\n-  }\n-  static Node* tagged_klass(ciInlineKlass* vk, PhaseGVN& gvn);\n-  \/\/ Pass inline type as fields at a call or return\n-  void pass_fields(GraphKit* kit, Node* n, uint& base_input);\n@@ -163,2 +172,3 @@\n-  InlineTypePtrNode(const InlineTypeBaseNode* vt)\n-    : InlineTypeBaseNode(TypeInstPtr::make(TypePtr::NotNull, vt->type()->inline_klass()), vt->req()) {\n+public:\n+  InlineTypePtrNode(const InlineTypeBaseNode* vt, bool null_free = true)\n+    : InlineTypeBaseNode(TypeInstPtr::make(null_free ? TypePtr::NotNull : TypePtr::BotPTR, vt->type()->inline_klass()), vt->req()) {\n@@ -167,1 +177,2 @@\n-    for (uint i = Oop+1; i < vt->req(); i++) {\n+    init_req(IsInit, vt->get_is_init());\n+    for (uint i = Values; i < vt->req(); i++) {\n@@ -172,1 +183,12 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  InlineTypePtrNode(ciInlineKlass* vk, Node* oop)\n+      : InlineTypeBaseNode(TypeInstPtr::make(TypePtr::BotPTR, vk), Values + vk->nof_declared_nonstatic_fields()) {\n+    init_class_id(Class_InlineTypePtr);\n+    init_req(Oop, oop);\n+    init_req(IsInit, oop);\n+  }\n+\n+  static InlineTypePtrNode* make_null(PhaseGVN& gvn, ciInlineKlass* vk);\n+\n+  virtual Node* Identity(PhaseGVN* phase);\n+\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -174,1 +196,0 @@\n-public:\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":42,"deletions":21,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2172,0 +2172,1 @@\n+  bool null_free = false;\n@@ -2177,0 +2178,1 @@\n+      null_free = alias_type->field()->is_null_free();\n@@ -2183,1 +2185,2 @@\n-      const TypeOopPtr *elem_type = adr_type->is_aryptr()->elem()->isa_oopptr();\n+      const TypeOopPtr* elem_type = adr_type->is_aryptr()->elem()->make_oopptr();\n+      null_free = adr_type->is_aryptr()->is_null_free();\n@@ -2194,0 +2197,3 @@\n+    if (null_free) {\n+      tjp = tjp->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    }\n@@ -2296,2 +2302,2 @@\n-  if (base->is_InlineType()) {\n-    InlineTypeNode* vt = base->as_InlineType();\n+  if (base->is_InlineTypeBase()) {\n+    InlineTypeBaseNode* vt = base->as_InlineTypeBase();\n@@ -2299,1 +2305,1 @@\n-      if (!vt->is_allocated(&_gvn) || !_gvn.type(vt)->is_inlinetype()->larval()) {\n+      if (!vt->is_allocated(&_gvn) || !_gvn.type(vt)->isa_inlinetype() || !_gvn.type(vt)->is_inlinetype()->larval()) {\n@@ -2323,4 +2329,7 @@\n-      \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n-      PreserveReexecuteState preexecs(this);\n-      jvms()->set_should_reexecute(true);\n-      base = vt->buffer(this)->get_oop();\n+      if (vt->is_InlineType()) {\n+        \/\/ Re-execute the unsafe access if allocation triggers deoptimization.\n+        PreserveReexecuteState preexecs(this);\n+        jvms()->set_should_reexecute(true);\n+        vt = vt->buffer(this);\n+      }\n+      base = vt->get_oop();\n@@ -2438,0 +2447,2 @@\n+    } else {\n+      mismatched = true;\n@@ -2450,1 +2461,1 @@\n-  assert(!mismatched || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n+  assert(!mismatched || type == T_INLINE_TYPE || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n@@ -2502,0 +2513,5 @@\n+        const TypeOopPtr* ptr = value_type->make_oopptr();\n+        if (ptr != NULL && ptr->is_inlinetypeptr()) {\n+          \/\/ Load a non-flattened inline type from memory\n+          p = InlineTypeNode::make_from_oop(this, p, ptr->inline_klass(), !ptr->maybe_null());\n+        }\n@@ -2529,8 +2545,0 @@\n-    if (field != NULL && field->is_null_free() && !field->is_flattened()) {\n-      \/\/ Load a non-flattened inline type from memory\n-      if (value_type->inline_klass()->is_scalarizable()) {\n-        p = InlineTypeNode::make_from_oop(this, p, value_type->inline_klass());\n-      } else {\n-        p = null2default(p, value_type->inline_klass());\n-      }\n-    }\n@@ -2552,1 +2560,1 @@\n-        val->as_InlineType()->store_flattened(this, base, base, holder, offset, decorators);\n+        val->as_InlineTypeBase()->store_flattened(this, base, base, holder, offset, decorators);\n@@ -2554,1 +2562,1 @@\n-        val->as_InlineType()->store_flattened(this, base, adr, NULL, 0, decorators);\n+        val->as_InlineTypeBase()->store_flattened(this, base, adr, NULL, 0, decorators);\n@@ -2982,2 +2990,7 @@\n-\n-  Node* obj = new_instance(kls, test);\n+  Node* obj = NULL;\n+  ciKlass* klass = _gvn.type(kls)->is_klassptr()->klass();\n+  if (klass->is_inlinetype()) {\n+    obj = InlineTypeNode::make_default(_gvn, klass->as_inline_klass());\n+  } else {\n+    obj = new_instance(kls, test);\n+  }\n@@ -4215,3 +4228,6 @@\n-  if (obj->is_InlineType()) {\n-    ciKlass* vk = _gvn.type(obj)->inline_klass();\n-    set_result(makecon(TypeInstPtr::make(vk->java_mirror())));\n+  if (obj->is_InlineTypeBase()) {\n+    const Type* t = _gvn.type(obj);\n+    if (t->maybe_null()) {\n+      null_check(obj);\n+    }\n+    set_result(makecon(TypeInstPtr::make(t->inline_klass()->java_mirror())));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":40,"deletions":24,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -649,1 +649,1 @@\n-          NOT_PRODUCT(fail_eliminate = \"Undefined field referrence\";)\n+          NOT_PRODUCT(fail_eliminate = \"Undefined field reference\";)\n@@ -795,0 +795,1 @@\n+  assert(safepoints.length() == 0 || !res_type->is_inlinetypeptr(), \"Inline type allocations should not have safepoint uses\");\n@@ -1170,1 +1171,1 @@\n-      assert(!inline_alloc || !tklass->klass()->as_inline_klass()->is_scalarizable(), \"Scalarizable inline type allocations should not have safepoint uses\");\n+      assert(!inline_alloc, \"Inline type allocations should not have safepoint uses\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-  Node* generate_array_guard(Node** ctrl, Node* mem, Node* obj, RegionNode* region, jint lh_con);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -311,20 +311,0 @@\n-Node* PhaseMacroExpand::generate_array_guard(Node** ctrl, Node* mem, Node* obj_or_klass, RegionNode* region, jint lh_con) {\n-  if ((*ctrl)->is_top())  return NULL;\n-\n-  Node* kls = NULL;\n-  if (_igvn.type(obj_or_klass)->isa_oopptr()) {\n-    Node* k_adr = basic_plus_adr(obj_or_klass, oopDesc::klass_offset_in_bytes());\n-    kls = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));\n-  } else {\n-    assert(_igvn.type(obj_or_klass)->isa_klassptr(), \"what else?\");\n-    kls = obj_or_klass;\n-  }\n-  Node* layout_val = make_load(NULL, mem, kls, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);\n-\n-  layout_val = transform_later(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));\n-  Node* cmp = transform_later(new CmpINode(layout_val, intcon(lh_con)));\n-  Node* bol = transform_later(new BoolNode(cmp, BoolTest::eq));\n-\n-  return generate_fair_guard(ctrl, bol, region);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1244,2 +1244,3 @@\n-  if (base != NULL && base->is_InlineTypePtr() && offset > oopDesc::klass_offset_in_bytes()) {\n-    Node* value = base->as_InlineTypePtr()->field_value_by_offset((int)offset, true);\n+  InlineTypePtrNode* vt = (base != NULL) ? base->uncast()->isa_InlineTypePtr() : NULL;\n+  if (vt != NULL && offset > oopDesc::klass_offset_in_bytes()) {\n+    Node* value = vt->field_value_by_offset((int)offset, true);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -872,0 +872,17 @@\n+      uint first_ind = spobj->first_index(sfpt->jvms());\n+      \/\/ Nullable, scalarized inline types have an is_init input\n+      \/\/ that needs to be checked before using the field values.\n+      ScopeValue* is_init = NULL;\n+      if (cik->is_inlinetype()) {\n+        Node* init_node = sfpt->in(first_ind++);\n+        assert(init_node != NULL, \"is_init node not found\");\n+        if (!init_node->is_top()) {\n+          const Type* init_type = init_node->bottom_type();\n+          if (init_node->is_Con()) {\n+            is_init = new ConstantOopWriteValue(init_type->is_zero_type() ? 0 : init_type->isa_oopptr()->const_oop()->constant_encoding());\n+          } else {\n+            OptoReg::Name init_reg = C->regalloc()->get_reg_first(init_node);\n+            is_init = new_loc_value(C->regalloc(), init_reg, init_type->isa_narrowoop() ? Location::narrowoop : Location::oop);\n+          }\n+        }\n+      }\n@@ -874,1 +891,1 @@\n-                                    : new ObjectValue(spobj->_idx, klass_sv);\n+                                    : new ObjectValue(spobj->_idx, klass_sv, is_init);\n@@ -877,1 +894,0 @@\n-      uint first_ind = spobj->first_index(sfpt->jvms());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-    if (t->is_inlinetypeptr() && t->inline_klass()->is_scalarizable() && !t->maybe_null()) {\n+    if (t->is_inlinetypeptr()) {\n@@ -611,1 +611,1 @@\n-      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass());\n+      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null());\n@@ -828,1 +828,1 @@\n-        ret_type->is_inlinetypeptr() && ret_type->inline_klass()->is_scalarizable() && !ret_type->maybe_null()) {\n+        ret_type->is_inlinetypeptr() && !ret_type->maybe_null()) {\n@@ -924,2 +924,1 @@\n-      assert(res->is_InlineType(), \"what else supports multi value return?\");\n-      InlineTypeNode* vt = res->as_InlineType();\n+      InlineTypeBaseNode* vt = res->as_InlineTypeBase();\n@@ -935,0 +934,4 @@\n+      if (res->is_InlineType()) {\n+        assert(res->as_InlineType()->is_allocated(&kit.gvn()), \"must be allocated\");\n+        res = res->as_InlineType()->get_oop();\n+      }\n@@ -1740,0 +1743,2 @@\n+          \/\/ TODO Currently, the implementation relies on the assumption that InlineTypePtrNodes\n+          \/\/ are always buffered. We therefore need to allocate here.\n@@ -1742,0 +1747,4 @@\n+        } else if (!n->is_InlineTypeBase() && t->is_inlinetypeptr()) {\n+          \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n+          assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n+          map()->set_req(j, InlineTypePtrNode::make_null(gvn(), t->inline_klass()));\n@@ -1743,1 +1752,0 @@\n-        assert(!t->isa_inlinetype() || n->is_InlineType(), \"inconsistent typeflow info\");\n@@ -1846,2 +1854,2 @@\n-      } else if (m->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)){\n-        phi = m->as_InlineType()->get_oop()->as_Phi();\n+      } else if (m->is_InlineTypeBase() && m->as_InlineTypeBase()->has_phi_inputs(r)) {\n+        phi = m->as_InlineTypeBase()->get_oop()->as_Phi();\n@@ -1885,1 +1893,1 @@\n-      if (phi != NULL && n->is_InlineType()) {\n+      if (phi != NULL && phi->bottom_type()->is_inlinetypeptr()) {\n@@ -1888,2 +1896,2 @@\n-        InlineTypeNode* vtm = m->as_InlineType(); \/\/ Current inline type\n-        InlineTypeNode* vtn = n->as_InlineType(); \/\/ Incoming inline type\n+        InlineTypeBaseNode* vtm = m->as_InlineTypeBase(); \/\/ Current inline type\n+        InlineTypeBaseNode* vtn = n->as_InlineTypeBase(); \/\/ Incoming inline type\n@@ -2079,2 +2087,2 @@\n-      } else if (n->is_InlineType() && n->as_InlineType()->has_phi_inputs(r)) {\n-        n->as_InlineType()->add_new_path(r);\n+      } else if (n->is_InlineTypeBase() && n->as_InlineTypeBase()->has_phi_inputs(r)) {\n+        n->as_InlineTypeBase()->add_new_path(r);\n@@ -2103,1 +2111,1 @@\n-  InlineTypeBaseNode* vt = o->isa_InlineType();\n+  InlineTypeBaseNode* vt = o->isa_InlineTypeBase();\n@@ -2140,1 +2148,1 @@\n-  if (vt != NULL) {\n+  if (vt != NULL && (t->is_inlinetypeptr() || t->isa_inlinetype())) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -107,0 +107,4 @@\n+      if (elemptr->is_inlinetypeptr()) {\n+        assert(elemptr->maybe_null(), \"null free array should be handled above\");\n+        ld = InlineTypeNode::make_from_oop(this, ld, elemptr->inline_klass(), false);\n+      }\n@@ -212,6 +216,5 @@\n-  if (bt == T_INLINE_TYPE) {\n-    \/\/ Loading a non-flattened inline type from an array\n-    assert(!gvn().type(ld)->maybe_null(), \"inline type array elements should never be null\");\n-    if (elemptr->inline_klass()->is_scalarizable()) {\n-      ld = InlineTypeNode::make_from_oop(this, ld, elemptr->inline_klass());\n-    }\n+  ld = record_profile_for_speculation_at_array_load(ld);\n+  \/\/ Loading a non-flattened inline type\n+  if (elemptr != NULL && elemptr->is_inlinetypeptr()) {\n+    assert(!ary_t->is_null_free() || !elemptr->maybe_null(), \"inline type array elements should never be null\");\n+    ld = InlineTypeNode::make_from_oop(this, ld, elemptr->inline_klass(), !elemptr->maybe_null());\n@@ -219,4 +222,0 @@\n-  if (!ld->is_InlineType()) {\n-    ld = record_profile_for_speculation_at_array_load(ld);\n-  }\n-\n@@ -277,7 +276,1 @@\n-      if (!cast_val->is_InlineType()) {\n-        inc_sp(3);\n-        cast_val = null_check(cast_val);\n-        if (stopped()) return;\n-        dec_sp(3);\n-        cast_val = InlineTypeNode::make_from_oop(this, cast_val, ary_t->elem()->inline_klass());\n-      }\n+      assert(!tval->maybe_null(), \"should be guaranteed by array store check\");\n@@ -288,1 +281,1 @@\n-      cast_val->as_InlineType()->store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+      cast_val->as_InlineTypeBase()->store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -292,6 +285,1 @@\n-      if (!cast_val->is_InlineType() && tval->maybe_null()) {\n-        inc_sp(3);\n-        cast_val = null_check(cast_val);\n-        if (stopped()) return;\n-        dec_sp(3);\n-      }\n+      assert(!tval->maybe_null(), \"should be guaranteed by array store check\");\n@@ -359,1 +347,1 @@\n-          val->as_InlineType()->store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+          val->as_InlineTypeBase()->store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -2015,0 +2003,3 @@\n+  if (cast->is_InlineType()) {\n+    cast = cast->as_InlineType()->get_oop();\n+  }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  if (is_field && field_holder->is_inlinetype() && peek()->is_InlineType()) {\n+  if (is_field && field_holder->is_inlinetype() && peek()->is_InlineTypeBase()) {\n@@ -55,1 +55,5 @@\n-    InlineTypeNode* vt = pop()->as_InlineType();\n+    InlineTypeBaseNode* vt = peek()->as_InlineTypeBase();\n+    if (vt->is_InlineTypePtr()) {\n+      null_check(vt);\n+    }\n+    pop();\n@@ -187,1 +191,1 @@\n-    if (field->is_null_free()) {\n+    if (field_klass->is_inlinetype()) {\n@@ -189,5 +193,1 @@\n-      if (field_klass->as_inline_klass()->is_scalarizable()) {\n-        ld = InlineTypeNode::make_from_oop(this, ld, field_klass->as_inline_klass());\n-      } else {\n-        ld = null2default(ld, field_klass->as_inline_klass());\n-      }\n+      ld = InlineTypeNode::make_from_oop(this, ld, field_klass->as_inline_klass(), field->is_null_free());\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -156,0 +156,3 @@\n+    if (_gvn.type(ary)->is_aryptr()->is_null_free()) {\n+      null_check(obj);\n+    }\n@@ -261,0 +264,5 @@\n+  \/\/ If we statically know that this is an inline type array, use precise element klass for checkcast\n+  if (!elemtype->isa_inlinetype()) {\n+    elemtype = elemtype->make_oopptr();\n+  }\n+  bool null_free = false;\n@@ -263,0 +271,1 @@\n+    null_free = elemtype->isa_inlinetype() || !elemtype->maybe_null();\n@@ -267,1 +276,1 @@\n-  return gen_checkcast(obj, a_e_klass);\n+  return gen_checkcast(obj, a_e_klass, NULL, null_free);\n@@ -327,5 +336,1 @@\n-  if (vk->is_scalarizable()) {\n-    push(vt);\n-  } else {\n-    push(vt->get_oop());\n-  }\n+  push(vt);\n@@ -349,1 +354,1 @@\n-  if (!val->is_InlineType() && field->is_null_free()) {\n+  if (!val->is_InlineTypeBase() && field->type()->is_inlinetype()) {\n@@ -351,2 +356,2 @@\n-    assert(!gvn().type(val)->maybe_null(), \"Inline types are null-free\");\n-    val = InlineTypeNode::make_from_oop(this, val, gvn().type(val)->inline_klass());\n+    assert(!field->is_null_free() || !gvn().type(val)->maybe_null(), \"Null store to null-free field\");\n+    val = InlineTypeNode::make_from_oop(this, val, field->type()->as_inline_klass(), field->is_null_free());\n@@ -367,1 +372,0 @@\n-  Node* res = new_vt;\n@@ -369,8 +373,1 @@\n-  if (!holder_klass->is_scalarizable()) {\n-    \/\/ Re-execute withfield if buffering triggers deoptimization\n-    PreserveReexecuteState preexecs(this);\n-    jvms()->set_should_reexecute(true);\n-    inc_sp(nargs);\n-    res = new_vt->buffer(this)->get_oop();\n-  }\n-  push(_gvn.transform(res));\n+  push(_gvn.transform(new_vt));\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -1144,0 +1145,7 @@\n+  if (in(1)->is_InlineTypePtr() && phase->type(in(2))->is_zero_type()) {\n+    \/\/ Null checking a scalarized but nullable inline type. Check the is_init\n+    \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+    set_req_X(1, in(1)->as_InlineTypePtr()->get_is_init(), phase);\n+    return this;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-    if (vk->is_scalarizable() && is_null_free) {\n+    if (is_null_free) {\n@@ -2087,1 +2087,1 @@\n-      field_array[pos++] = get_const_type(return_type);\n+      field_array[pos++] = get_const_type(return_type); \/\/ Oop might be null when returning as fields\n@@ -4339,1 +4339,1 @@\n-        return TypeInstPtr::make(ptr, _klass);\n+        return make(ptr, _klass, false, NULL, Offset(0), _flatten_array, InstanceBot, _speculative);\n@@ -4341,1 +4341,1 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass());\n+        return make(ptr, ciEnv::current()->Object_klass());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -843,0 +843,2 @@\n+  virtual bool maybe_null() const { return false; }\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1060,1 +1060,0 @@\n-\n@@ -1062,1 +1061,0 @@\n-    oop obj = NULL;\n@@ -1064,0 +1062,11 @@\n+    \/\/ Check if the object may be null and has an additional is_init input that needs\n+    \/\/ to be checked before using the field values. Skip re-allocation if it is null.\n+    if (sv->maybe_null()) {\n+      assert(k->is_inline_klass(), \"must be an inline klass\");\n+      StackValue* init_value = StackValue::create_stack_value(fr, reg_map, sv->is_init());\n+      if (init_value->get_obj().is_null()) {\n+        continue;\n+      }\n+    }\n+\n+    oop obj = NULL;\n@@ -1461,1 +1470,1 @@\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    assert(obj.not_null() || realloc_failures || sv->maybe_null(), \"reallocation was missed\");\n@@ -1563,1 +1572,0 @@\n-  assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n@@ -1565,1 +1573,6 @@\n-    tty->print(\" allocation failed\");\n+    if (k->is_inline_klass()) {\n+      tty->print(\" is null\");\n+    } else {\n+      assert(realloc_failures, \"reallocation was missed\");\n+      tty->print(\" allocation failed\");\n+    }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2072,3 +2072,0 @@\n-  develop(bool, ScalarizeInlineTypes, true,                                 \\\n-          \"Scalarize inline types in compiled code\")                        \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -190,2 +190,8 @@\n-    Handle ov = ((ObjectValue *)sv)->value();\n-    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n+    ObjectValue* ov = ((ObjectValue *)sv);\n+    bool scalar_replaced = ov->value().is_null();\n+    if (ov->maybe_null()) {\n+      \/\/ Don't treat inline type as scalar replaced if it is null\n+      StackValue* is_init_value = StackValue::create_stack_value(fr, reg_map, ov->is_init());\n+      scalar_replaced &= is_init_value->get_obj().not_null();\n+    }\n+    return new StackValue(ov->value(), scalar_replaced ? 1 : 0);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-        protected static final String LOAD   = START + \"Load(B|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/MyValue.*\" + END;\n+        protected static final String LOAD   = START + \"Load(B|C|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/.*\" + END;\n@@ -122,1 +122,1 @@\n-        protected static final String STORE  = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/MyValue.*\" + END;\n+        protected static final String STORE  = START + \"Store(B|C|S|I|L|F|D|P|N)\" + MID + \"@compiler\/valhalla\/inlinetypes\/.*\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-        } catch(NullPointerException npe) {}\n+        } catch (NullPointerException npe) {}\n@@ -103,1 +103,1 @@\n-        } catch(NullPointerException npe) {}\n+        } catch (NullPointerException npe) {}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2115,1 +2115,1 @@\n-    @Test()\n+    @Test\n@@ -2139,1 +2139,1 @@\n-    @Test()\n+    @Test\n@@ -3104,1 +3104,1 @@\n-    @Test()\n+    @Test\n@@ -3123,1 +3123,1 @@\n-    @Test()\n+    @Test\n@@ -3157,1 +3157,1 @@\n-    @Test()\n+    @Test\n@@ -3182,1 +3182,1 @@\n-    @Test()\n+    @Test\n@@ -3209,1 +3209,1 @@\n-    @Test()\n+    @Test\n@@ -3248,1 +3248,1 @@\n-    @Test()\n+    @Test\n@@ -3283,1 +3283,1 @@\n-    @IR(failOn = {ALLOC, ALLOCA, ALLOC_G, ALLOCA_G, LOOP, LOAD, STORE, TRAP, LOAD_UNKNOWN_INLINE,\n+    @IR(failOn = {ALLOC_G, ALLOCA_G, LOOP, LOAD, STORE, TRAP, LOAD_UNKNOWN_INLINE,\n@@ -3304,1 +3304,1 @@\n-    @IR(failOn = {ALLOC, ALLOCA, ALLOC_G, LOOP, LOAD, STORE, TRAP,\n+    @IR(failOn = {ALLOCA, ALLOC_G, LOOP, LOAD, STORE, TRAP,\n@@ -3329,1 +3329,1 @@\n-    \/\/ @IR(failOn = {ALLOC, ALLOCA, ALLOC_G, ALLOCA_G, LOOP, LOAD, STORE, TRAP, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    \/\/ @IR(failOn = {ALLOC_G, ALLOCA_G, LOOP, LOAD, STORE, TRAP, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n@@ -3350,1 +3350,1 @@\n-    \/\/ @IR(failOn = {ALLOC, ALLOCA, ALLOC_G, LOOP, LOAD, STORE, TRAP, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    \/\/ @IR(failOn = {ALLOCA, ALLOC_G, LOOP, LOAD, STORE, TRAP, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n@@ -3429,1 +3429,1 @@\n-    @Test()\n+    @Test\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -49,4 +49,0 @@\n-        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n-        scenarios[2].addFlags(\"-DVerifyIR=false\");\n-        scenarios[3].addFlags(\"-XX:FlatArrayElementMaxSize=0\");\n-\n@@ -54,1 +50,1 @@\n-                   .addScenarios(scenarios)\n+                   .addScenarios(InlineTypes.DEFAULT_SCENARIOS)\n@@ -287,1 +283,2 @@\n-    @IR(counts = {SCOBJ, \">= 1\"}, \/\/ at least 1\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {SCOBJ, \">= 1\"}, \/\/ at least 1\n@@ -655,1 +652,1 @@\n-    @Test()\n+    @Test\n@@ -679,1 +676,2 @@\n-    @IR(failOn = {ALLOC, ALLOCA, STORE})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC, ALLOCA, STORE})\n@@ -768,1 +766,2 @@\n-    @IR(failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n@@ -800,1 +799,2 @@\n-    @IR(failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n@@ -962,1 +962,1 @@\n-    @Test()\n+    @Test\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -346,1 +346,1 @@\n-        failOn = {ALLOC, LOAD, TRAP})\n+        failOn = {ALLOC, TRAP})\n@@ -382,1 +382,1 @@\n-            failOn = {ALLOC, LOAD, TRAP})\n+        failOn = {ALLOC, TRAP})\n@@ -687,1 +687,1 @@\n-    @Test()\n+    @Test\n@@ -711,1 +711,1 @@\n-    @Test()\n+    @Test\n@@ -745,1 +745,1 @@\n-    @Test()\n+    @Test\n@@ -766,1 +766,1 @@\n-    @Test()\n+    @Test\n@@ -916,1 +916,1 @@\n-    @Test()\n+    @Test\n@@ -929,1 +929,1 @@\n-    @Test()\n+    @Test\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-            if (i.b < 0101)\n+            if (i.b < 101) {\n@@ -186,0 +186,1 @@\n+            }\n@@ -191,3 +192,4 @@\n-        if (d[0].c > 1)\n-            for (int n = 0; n < 7; ++n)\n-                ;\n+        if (d[0].c > 1) {\n+            for (int n = 0; n < 7; ++n) {\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGenerated.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    @Test()\n+    @Test\n@@ -111,1 +111,1 @@\n-    @Test()\n+    @Test\n@@ -141,1 +141,1 @@\n-    @Test()\n+    @Test\n@@ -153,1 +153,1 @@\n-    @Test()\n+    @Test\n@@ -166,1 +166,1 @@\n-    @Test()\n+    @Test\n@@ -183,1 +183,1 @@\n-    @Test()\n+    @Test\n@@ -197,1 +197,1 @@\n-    @Test()\n+    @Test\n@@ -212,1 +212,1 @@\n-    @Test()\n+    @Test\n@@ -224,1 +224,1 @@\n-    @Test()\n+    @Test\n@@ -239,1 +239,1 @@\n-    @Test()\n+    @Test\n@@ -251,1 +251,1 @@\n-    @Test()\n+    @Test\n@@ -267,1 +267,1 @@\n-    @Test()\n+    @Test\n@@ -283,1 +283,1 @@\n-    @Test()\n+    @Test\n@@ -295,1 +295,1 @@\n-    @Test()\n+    @Test\n@@ -307,1 +307,1 @@\n-    @Test()\n+    @Test\n@@ -319,1 +319,1 @@\n-    @Test()\n+    @Test\n@@ -332,1 +332,1 @@\n-    @Test()\n+    @Test\n@@ -347,1 +347,1 @@\n-    @Test()\n+    @Test\n@@ -567,1 +567,1 @@\n-    public void test30_verifier() {\n+    public void test30_verifier(RunInfo info) {\n@@ -765,1 +765,1 @@\n-    @Test()\n+    @Test\n@@ -781,1 +781,1 @@\n-    @Test()\n+    @Test\n@@ -795,1 +795,1 @@\n-    @Test()\n+    @Test\n@@ -810,1 +810,1 @@\n-    @Test()\n+    @Test\n@@ -824,1 +824,1 @@\n-    @Test()\n+    @Test\n@@ -839,1 +839,1 @@\n-    @Test()\n+    @Test\n@@ -853,1 +853,1 @@\n-    @Test()\n+    @Test\n@@ -869,1 +869,1 @@\n-    @Test()\n+    @Test\n@@ -886,1 +886,1 @@\n-    @Test()\n+    @Test\n@@ -903,1 +903,1 @@\n-    @Test()\n+    @Test\n@@ -915,1 +915,1 @@\n-    @Test()\n+    @Test\n@@ -948,1 +948,1 @@\n-    @Test()\n+    @Test\n@@ -963,1 +963,1 @@\n-    @Test()\n+    @Test\n@@ -990,1 +990,1 @@\n-    @Test()\n+    @Test\n@@ -1043,1 +1043,1 @@\n-    @Test()\n+    @Test\n@@ -1078,1 +1078,1 @@\n-    @Test()\n+    @Test\n@@ -1092,1 +1092,1 @@\n-    @Test()\n+    @Test\n@@ -1106,1 +1106,1 @@\n-    @Test()\n+    @Test\n@@ -1124,1 +1124,1 @@\n-    @Test()\n+    @Test\n@@ -1144,1 +1144,1 @@\n-    @Test()\n+    @Test\n@@ -1161,1 +1161,1 @@\n-    @Test()\n+    @Test\n@@ -1176,1 +1176,1 @@\n-    @Test()\n+    @Test\n@@ -1415,0 +1415,74 @@\n+\n+    \/\/ getValue to retrieve flattened field from (nullable) inline type\n+    @Test\n+    @IR(failOn = {CALL_Unsafe})\n+    public MyValue2 test71(boolean b, MyValue1.val v1, MyValue1.ref v2) {\n+        if (b) {\n+            if (V1_FLATTENED) {\n+                return U.getValue(v1, V1_OFFSET, MyValue2.class.asValueType());\n+            }\n+            return (MyValue2)U.getReference(v1, V1_OFFSET);\n+        } else {\n+            if (V1_FLATTENED) {\n+                return U.getValue(v2, V1_OFFSET, MyValue2.class.asValueType());\n+            }\n+            return (MyValue2)U.getReference(v2, V1_OFFSET);\n+        }\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier(RunInfo info) {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        Asserts.assertEQ(test71(true, v, v), v.v1);\n+        Asserts.assertEQ(test71(false, v, v), v.v1);\n+    }\n+\n+    \/\/ Same as test71 but with non-constant offset\n+    @Test\n+    @IR(failOn = {CALL_Unsafe})\n+    public MyValue2 test72(boolean b, MyValue1.val v1, MyValue1.ref v2, long offset) {\n+        if (b) {\n+            if (V1_FLATTENED) {\n+                return U.getValue(v1, offset, MyValue2.class.asValueType());\n+            }\n+            return (MyValue2)U.getReference(v1, V1_OFFSET);\n+        } else {\n+            if (V1_FLATTENED) {\n+                return U.getValue(v2, offset, MyValue2.class.asValueType());\n+            }\n+            return (MyValue2)U.getReference(v2, V1_OFFSET);\n+        }\n+    }\n+\n+    @Run(test = \"test72\")\n+    public void test72_verifier(RunInfo info) {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        Asserts.assertEQ(test72(true, v, v, V1_OFFSET), v.v1);\n+        Asserts.assertEQ(test72(false, v, v, V1_OFFSET), v.v1);\n+    }\n+\n+    static final MyValue1.val test73_value1 = MyValue1.createWithFieldsInline(rI, rL);\n+    static final MyValue1.ref test73_value2 = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+\n+    \/\/ Same as test72 but with constant base\n+    @Test\n+    @IR(failOn = {CALL_Unsafe})\n+    public MyValue2 test73(boolean b, long offset) {\n+        if (b) {\n+            if (V1_FLATTENED) {\n+                return U.getValue(test73_value1, offset, MyValue2.class.asValueType());\n+            }\n+            return (MyValue2)U.getReference(test73_value1, V1_OFFSET);\n+        } else {\n+            if (V1_FLATTENED) {\n+                return U.getValue(test73_value2, offset, MyValue2.class.asValueType());\n+            }\n+            return (MyValue2)U.getReference(test73_value2, V1_OFFSET);\n+        }\n+    }\n+\n+    @Run(test = \"test73\")\n+    public void test73_verifier(RunInfo info) {\n+        Asserts.assertEQ(test73(true, V1_OFFSET), test73_value1.v1);\n+        Asserts.assertEQ(test73(false, V1_OFFSET), test73_value2.v1);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":115,"deletions":41,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-        scenarios[2].addFlags(\"-DVerifyIR=false\");\n@@ -105,0 +104,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -274,1 +274,0 @@\n-    @IR(failOn = {LOAD, LOOP})\n@@ -348,1 +347,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE})\n+    @IR(failOn = {ALLOC_G})\n@@ -551,1 +550,0 @@\n-    @IR(failOn = {LOAD, LOOP})\n@@ -569,0 +567,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -601,0 +600,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -617,0 +617,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1077,0 +1078,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1096,0 +1098,2 @@\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC_G})\n@@ -1118,0 +1122,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1146,0 +1151,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -1303,0 +1309,2 @@\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC_G})\n@@ -1344,0 +1352,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -1360,0 +1369,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -1373,0 +1383,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -1394,1 +1405,1 @@\n-        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class),\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class.asValueType()),\n@@ -1405,0 +1416,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1429,0 +1441,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1447,0 +1460,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1460,0 +1474,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1473,0 +1488,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1485,0 +1501,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1497,0 +1514,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1604,0 +1622,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1685,0 +1704,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -1707,0 +1727,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -1912,1 +1933,1 @@\n-    @IR(failOn = {ALLOC, STORE})\n+    @IR(failOn = {ALLOC_G, STORE})\n@@ -1935,1 +1956,1 @@\n-    @IR(failOn = {ALLOC, STORE})\n+    @IR(failOn = {ALLOC_G, STORE})\n@@ -1958,1 +1979,1 @@\n-    @IR(failOn = {ALLOC, STORE})\n+    @IR(failOn = {ALLOC_G, STORE})\n@@ -1986,0 +2007,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -2008,0 +2030,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -2047,0 +2070,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -2070,0 +2094,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -2093,0 +2118,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -2116,0 +2142,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -2136,0 +2163,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -2197,1 +2225,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n@@ -2238,0 +2266,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -2279,1 +2308,4 @@\n-    @IR(counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 1\"})\n@@ -2298,1 +2330,1 @@\n-    @IR(applyIf = {\"UseG1GC\", \"true\"},\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n@@ -2300,1 +2332,1 @@\n-    @IR(applyIf = {\"UseG1GC\", \"false\"},\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n@@ -2321,1 +2353,1 @@\n-    @IR(applyIf = {\"UseG1GC\", \"true\"},\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n@@ -2323,1 +2355,1 @@\n-    @IR(applyIf = {\"UseG1GC\", \"false\"},\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n@@ -2343,1 +2375,4 @@\n-    @IR(counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 1\"})\n@@ -2363,1 +2398,4 @@\n-    @IR(counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"!= -1\"},\n+        counts = {COUNTEDLOOP_MAIN, \"= 0\"})\n@@ -2433,1 +2471,2 @@\n-    @IR(counts = {CLASS_CHECK_TRAP, \"= 2\"},\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {CLASS_CHECK_TRAP, \"= 2\"},\n@@ -2500,1 +2539,2 @@\n-    @IR(counts = {CLASS_CHECK_TRAP, \"= 2\", LOOP, \"= 1\"},\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        counts = {CLASS_CHECK_TRAP, \"= 2\", LOOP, \"= 1\"},\n@@ -2743,1 +2783,0 @@\n-    @IR(failOn = {LOAD, LOOP})\n@@ -2774,2 +2813,1 @@\n-    @IR(failOn = {ALLOC_G, MEMBAR, ALLOCA_G,\n-                  LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    @IR(failOn = {ALLOC_G, MEMBAR, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n@@ -2797,2 +2835,1 @@\n-    @IR(failOn = {ALLOC_G, ALLOCA_G,\n-                  LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    @IR(failOn = {ALLOC_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n@@ -2843,2 +2880,1 @@\n-    @IR(failOn = {ALLOC_G, MEMBAR, ALLOCA_G,\n-                  LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    @IR(failOn = {ALLOC_G, MEMBAR, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n@@ -2862,2 +2898,1 @@\n-    @IR(failOn = {ALLOC_G, ALLOCA_G,\n-                  LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    @IR(failOn = {ALLOC_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n@@ -2893,1 +2928,1 @@\n-    @IR(applyIf = {\"UseG1GC\", \"true\"},\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n@@ -2896,1 +2931,1 @@\n-    @IR(applyIf = {\"UseG1GC\", \"false\"},\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n@@ -2924,6 +2959,6 @@\n-    @IR(applyIf = {\"UseG1GC\", \"true\"},\n-            failOn = {LOAD_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n-            counts = {COUNTEDLOOP, \"= 4\", STORE_UNKNOWN_INLINE, \"= 9\"})\n-    @IR(applyIf = {\"UseG1GC\", \"false\"},\n-            failOn = {LOAD_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n-            counts = {COUNTEDLOOP, \"= 4\", STORE_UNKNOWN_INLINE, \"= 12\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"true\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 4\", STORE_UNKNOWN_INLINE, \"= 9\"})\n+    @IR(applyIfAnd = {\"UseG1GC\", \"false\", \"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTEDLOOP, \"= 4\", STORE_UNKNOWN_INLINE, \"= 12\"})\n@@ -3087,1 +3122,1 @@\n-        for (int i = 0 ; i < lArr.length; i++) {\n+        for (int i = 0; i < lArr.length; i++) {\n@@ -3105,1 +3140,1 @@\n-        for (int i = 0 ; i < lArr.length; i++) {\n+        for (int i = 0; i < lArr.length; i++) {\n@@ -3124,1 +3159,1 @@\n-        for (int i = 0 ; i < lArr.length; i++) {\n+        for (int i = 0; i < lArr.length; i++) {\n@@ -3142,1 +3177,1 @@\n-        for (int i = 0 ; i < lArr.length; i++) {\n+        for (int i = 0; i < lArr.length; i++) {\n@@ -3161,1 +3196,1 @@\n-        for (int i = 0 ; i < lArr.length; i++) {\n+        for (int i = 0; i < lArr.length; i++) {\n@@ -3178,1 +3213,1 @@\n-        for (int i = 0 ; i < lArr.length; i++) {\n+        for (int i = 0; i < lArr.length; i++) {\n@@ -3196,1 +3231,1 @@\n-        for (int i = 0 ; i < lArr.length; i++) {\n+        for (int i = 0; i < lArr.length; i++) {\n@@ -3214,1 +3249,1 @@\n-        for (int i = 0 ; i < lArr.length; i++) {\n+        for (int i = 0; i < lArr.length; i++) {\n@@ -3232,1 +3267,1 @@\n-        for (int i = 0 ; i < lArr.length; i++) {\n+        for (int i = 0; i < lArr.length; i++) {\n@@ -3348,1 +3383,1 @@\n-    @IR(failOn = {ALLOC, ALLOC_G, LOAD, STORE, TRAP})\n+    @IR(failOn = {ALLOC_G, TRAP})\n@@ -3366,1 +3401,1 @@\n-    @IR(failOn = {ALLOC, ALLOC_G})\n+    @IR(failOn = {ALLOC_G})\n@@ -3383,1 +3418,1 @@\n-    @IR(failOn = {ALLOC, ALLOC_G})\n+    @IR(failOn = {ALLOC_G})\n@@ -3405,0 +3440,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -3425,1 +3461,1 @@\n-    @IR(failOn = {ALLOC, ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n@@ -3441,1 +3477,1 @@\n-    @IR(failOn = {ALLOC, ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n@@ -3455,0 +3491,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -3473,0 +3510,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -3519,1 +3557,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n@@ -3550,1 +3588,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n@@ -3581,1 +3619,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n@@ -3612,1 +3650,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n@@ -3672,0 +3710,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -3740,0 +3779,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -3762,1 +3802,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n@@ -3775,1 +3815,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n@@ -3790,7 +3830,0 @@\n-    static final primitive class SimpleInlineType {\n-        final int x;\n-        public SimpleInlineType(int x) {\n-            this.x = x;\n-        }\n-    }\n-\n@@ -3799,1 +3832,2 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    \/\/ TODO 8228361\n+    \/\/ @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n@@ -3801,2 +3835,2 @@\n-        SimpleInlineType val1 = new SimpleInlineType(i);\n-        SimpleInlineType val2 = new SimpleInlineType(i);\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(i, rD);\n@@ -3813,1 +3847,2 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n+    \/\/ TODO 8228361\n+    \/\/ @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n@@ -3815,2 +3850,2 @@\n-        SimpleInlineType.ref val1 = new SimpleInlineType(i);\n-        SimpleInlineType.ref val2 = new SimpleInlineType(i);\n+        MyValue2.ref val1 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2.ref val2 = MyValue2.createWithFieldsInline(i, rD);\n@@ -3840,1 +3875,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n@@ -3861,0 +3896,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -3882,0 +3918,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -3896,1 +3933,1 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE})\n@@ -3947,0 +3984,1 @@\n+    @IR(failOn = {ALLOC_G})\n@@ -3963,0 +4001,95 @@\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    private static final MethodHandle setArrayElementIncompatibleRef = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"setArrayElementIncompatibleRef\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class.asPrimaryType()),\n+        CODE -> {\n+            CODE.\n+            aload_1().\n+            iload_2().\n+            aload_3().\n+            aastore().\n+            return_();\n+        });\n+\n+    \/\/ Same as test44 but with .ref store to array\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public void test145(MyValue1[] va, int index, MyValue2.ref v) throws Throwable {\n+        setArrayElementIncompatibleRef.invoke(this, va, index, v);\n+    }\n+\n+    @Run(test = \"test145\")\n+    @Warmup(10000)\n+    public void test145_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test145(testValue1Array, index, testValue2);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test inline type connected to result node\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1 test146(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    @Run(test = \"test146\")\n+    @Warmup(10000)\n+    public void test146_verifier() {\n+        Asserts.assertEQ(test146(testValue1), testValue1);\n+    }\n+\n+    \/\/ Same as test146 but with .ref cast\n+    @Test\n+    @IR(failOn = {ALLOC_G})\n+    public MyValue1.ref test147(Object obj) {\n+        return (MyValue1.ref)obj;\n+    }\n+\n+    @Run(test = \"test147\")\n+    @Warmup(10000)\n+    public void test147_verifier() {\n+        Asserts.assertEQ(test147(testValue1), testValue1);\n+        Asserts.assertEQ(test147(null), null);\n+    }\n+\n+    @ForceInline\n+    public Object test148_helper(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    \/\/ Same as test146 but with helper method\n+    @Test\n+    public Object test148(Object obj) {\n+        return test148_helper(obj);\n+    }\n+\n+    @Run(test = \"test148\")\n+    @Warmup(10000)\n+    public void test148_verifier() {\n+        Asserts.assertEQ(test148(testValue1), testValue1);\n+    }\n+\n+    @ForceInline\n+    public Object test149_helper(Object obj) {\n+        return (MyValue1.ref)obj;\n+    }\n+\n+    \/\/ Same as test147 but with helper method\n+    @Test\n+    public Object test149(Object obj) {\n+        return test149_helper(obj);\n+    }\n+\n+    @Run(test = \"test149\")\n+    @Warmup(10000)\n+    public void test149_verifier() {\n+        Asserts.assertEQ(test149(testValue1), testValue1);\n+        Asserts.assertEQ(test149(null), null);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":203,"deletions":70,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -288,1 +288,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -807,1 +807,1 @@\n-        for (int i = 1; i < 8 ; ++i) {\n+        for (int i = 1; i < 8; ++i) {\n@@ -942,1 +942,1 @@\n-    @Test()\n+    @Test\n@@ -2165,1 +2165,1 @@\n-    @Test()\n+    @Test\n@@ -2194,1 +2194,1 @@\n-    @Test()\n+    @Test\n@@ -2281,1 +2281,1 @@\n-    @Test()\n+    @Test\n@@ -2302,1 +2302,1 @@\n-    @Test()\n+    @Test\n@@ -2332,1 +2332,1 @@\n-    @Test()\n+    @Test\n@@ -2392,1 +2392,1 @@\n-    @Test()\n+    @Test\n@@ -2412,1 +2412,1 @@\n-    @Test()\n+    @Test\n@@ -2433,1 +2433,1 @@\n-    @Test()\n+    @Test\n@@ -2449,1 +2449,1 @@\n-    @Test()\n+    @Test\n@@ -2467,1 +2467,1 @@\n-    @Test()\n+    @Test\n@@ -2492,1 +2492,1 @@\n-    @Test()\n+    @Test\n@@ -2524,1 +2524,1 @@\n-    @Test()\n+    @Test\n@@ -2583,1 +2583,1 @@\n-    @Test()\n+    @Test\n@@ -2607,1 +2607,1 @@\n-    @Test()\n+    @Test\n@@ -2631,1 +2631,1 @@\n-    @Test()\n+    @Test\n@@ -2673,1 +2673,1 @@\n-    @Test()\n+    @Test\n@@ -2699,1 +2699,1 @@\n-    @Test()\n+    @Test\n@@ -2724,1 +2724,1 @@\n-    @Test()\n+    @Test\n@@ -2748,1 +2748,1 @@\n-    @Test()\n+    @Test\n@@ -2772,1 +2772,1 @@\n-    @Test()\n+    @Test\n@@ -2808,0 +2808,1 @@\n+    @ForceInline\n@@ -2815,1 +2816,1 @@\n-    @Test()\n+    @Test\n@@ -2847,1 +2848,1 @@\n-    @Test()\n+    @Test\n@@ -2862,1 +2863,1 @@\n-    @Test()\n+    @Test\n@@ -2877,1 +2878,1 @@\n-    @Test()\n+    @Test\n@@ -2889,0 +2890,377 @@\n+\n+    MyValue1.ref[] refArray = new MyValue1.ref[2];\n+    MyValue1[] flatArray = new MyValue1[1];\n+\n+    \/\/ Test scalarization of .ref\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE, TRAP})\n+    public int test112(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test112\")\n+    public void test112_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test112(true), refArray[0].x);\n+        Asserts.assertEquals(test112(false), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            try {\n+                Asserts.assertEquals(test112(false), testValue1.x);\n+                test112(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test112 but with call to hash()\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test113(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test113\")\n+    public void test113_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test113(true), refArray[0].hash());\n+        Asserts.assertEquals(test113(false), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            try {\n+                Asserts.assertEquals(test113(false), testValue1.hash());\n+                test113(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test114(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test114\")\n+    public void test114_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test114(true).hash(), refArray[0].hash());\n+        Asserts.assertEquals(test114(false).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            Asserts.assertEquals(test114(true), null);\n+        }\n+    }\n+\n+    \/\/ Test scalarization when .ref is referenced in safepoint debug info\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test115(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refArray[0];\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test115\")\n+    public void test115_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test115(true, false, info.getTest()), refArray[0].x);\n+        Asserts.assertEquals(test115(false, false, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            try {\n+                Asserts.assertEquals(test115(false, false, info.getTest()), testValue1.x);\n+                test115(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test115(true, true, info.getTest()), refArray[0].x);\n+            Asserts.assertEquals(test115(false, true, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test116(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refArray[0];\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test116\")\n+    public void test116_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test116(true, false, info.getTest()).hash(), refArray[0].hash());\n+        Asserts.assertEquals(test116(false, false, info.getTest()).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            Asserts.assertEquals(test116(true, false, info.getTest()), null);\n+            refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test116(true, true, info.getTest()).hash(), refArray[0].hash());\n+            Asserts.assertEquals(test116(false, true, info.getTest()).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test117(boolean b) {\n+        MyValue1.ref val = null;\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test117\")\n+    public void test117_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test117(true), testValue1.x);\n+        try {\n+            test117(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test118(boolean b) {\n+        MyValue1.ref val = null;\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test118\")\n+    public void test118_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test118(true).hash(), testValue1.hash());\n+        Asserts.assertEquals(test118(false), null);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public int test119(boolean b) {\n+        MyValue1.ref val = refArray[0];\n+        if (b) {\n+            val = null;\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test119\")\n+    public void test119_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test119(false), testValue1.x);\n+        try {\n+            test119(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test120(boolean b) {\n+        MyValue1.ref val = refArray[0];\n+        if (b) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test120\")\n+    public void test120_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test120(false).hash(), testValue1.hash());\n+        Asserts.assertEquals(test120(true), null);\n+    }\n+\n+    @ForceInline\n+    public Object test121_helper() {\n+        return flatArray[0];\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC_G, STORE})\n+    public void test121(boolean b) {\n+        Object o = null;\n+        if (b) {\n+            o = refArray[0];\n+        } else {\n+            o = test121_helper();\n+        }\n+        flatArray[0] = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test121\")\n+    public void test121_verifier() {\n+        refArray[0] = testValue1;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatArray[0] = vt;\n+        test121(false);\n+        Asserts.assertEquals(flatArray[0].hash(), vt.hash());\n+        test121(true);\n+        Asserts.assertEquals(flatArray[0].hash(), testValue1.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test122_helper() {\n+        return refArray[0];\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"FlatArrayElementMaxSize\", \"= -1\"},\n+        failOn = {ALLOC_G, STORE})\n+    public void test122(boolean b) {\n+        Object o = null;\n+        if (b) {\n+            o = flatArray[0];\n+        } else {\n+            o = test122_helper();\n+        }\n+        flatArray[0] = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test122\")\n+    public void test122_verifier() {\n+        refArray[0] = testValue1;\n+        test122(false);\n+        Asserts.assertEquals(flatArray[0].hash(), testValue1.hash());\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatArray[0] = vt;\n+        test122(true);\n+        Asserts.assertEquals(flatArray[0].hash(), vt.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test123_helper() {\n+        return refArray[0];\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public long test123(boolean b, MyValue1.ref val, Method m, boolean deopt) {\n+        MyValue1.ref[] array = new MyValue1.ref[1];\n+        array[0] = val;\n+        Object res = null;\n+        if (b) {\n+            res = array[0];\n+        } else {\n+            res = test123_helper();\n+        }\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)res).hash();\n+    }\n+\n+    @Run(test = \"test123\")\n+    public void test123_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.default;\n+        Asserts.assertEquals(test123(true, testValue1, info.getTest(), false), testValue1.hash());\n+        Asserts.assertEquals(test123(false, testValue1, info.getTest(), false), MyValue1.default.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test123(true, testValue1, info.getTest(), true), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test124_helper(MyValue2.ref val) {\n+        MyValue2.ref[] array = new MyValue2.ref[1];\n+        array[0] = val;\n+        return array[0];\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public long test124(boolean b, MyValue2.ref val, Method m, boolean deopt) {\n+        Object res = null;\n+        if (b) {\n+            res = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        } else {\n+            res = test124_helper(val);\n+        }\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue2)res).hash();\n+    }\n+\n+    @Run(test = \"test124\")\n+    public void test124_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.default;\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        Asserts.assertEquals(test124(true, val1, info.getTest(), false), val2.hash());\n+        Asserts.assertEquals(test124(false, val1, info.getTest(), false), val1.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test124(true, val1, info.getTest(), true), val2.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test125_helper(Object[] array, MyValue2.ref val) {\n+        array[0] = val;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE})\n+    public long test125(boolean b, MyValue2.ref val, Method m, boolean deopt) {\n+        Object[] res = new MyValue2.ref[1];\n+        if (b) {\n+            res[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        } else {\n+            test125_helper(res, val);\n+        }\n+        val = ((MyValue2)res[0]);\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test125\")\n+    public void test125_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.default;\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        Asserts.assertEquals(test125(true, val1, info.getTest(), false), val2.hash());\n+        Asserts.assertEquals(test125(false, val1, info.getTest(), false), val1.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test125(true, val1, info.getTest(), true), val2.hash());\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":404,"deletions":26,"binary":false,"changes":430,"status":"modified"},{"patch":"@@ -34,4 +34,2 @@\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.ALLOC;\n-import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.STORE;\n-import static compiler.valhalla.inlinetypes.InlineTypes.rI;\n-import static compiler.valhalla.inlinetypes.InlineTypes.rL;\n+import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n@@ -92,0 +90,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -104,1 +103,1 @@\n-    public void test1_verifier() throws Throwable {\n+    public void test1_verifier() {\n@@ -110,0 +109,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -128,0 +128,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -149,0 +150,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -164,0 +166,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -196,0 +199,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -224,1 +228,2 @@\n-    public void test7() throws Throwable {\n+    @IR(failOn = {ALLOC})\n+    public void test7() {\n@@ -242,1 +247,1 @@\n-    public void test7_verifier() throws Throwable {\n+    public void test7_verifier() {\n@@ -247,1 +252,2 @@\n-    public void test8() throws Throwable {\n+    @IR(failOn = {ALLOC})\n+    public void test8() {\n@@ -257,1 +263,1 @@\n-    public void test8_verifier() throws Throwable {\n+    public void test8_verifier() {\n@@ -263,1 +269,2 @@\n-    public void test9(boolean flag1) {\n+    @IR(failOn = {ALLOC})\n+    public void test9(boolean flag) {\n@@ -265,1 +272,1 @@\n-        if (flag1) {\n+        if (flag) {\n@@ -286,1 +293,2 @@\n-    public void test10(boolean flag) throws Throwable {\n+    @IR(failOn = {ALLOC})\n+    public void test10(boolean flag) {\n@@ -292,1 +300,1 @@\n-    public void test10_verifier() throws Throwable {\n+    public void test10_verifier() {\n@@ -304,1 +312,2 @@\n-    public void test11(boolean flag) throws Throwable {\n+    @IR(failOn = {ALLOC})\n+    public void test11(boolean flag) {\n@@ -310,1 +319,1 @@\n-    public void test11_verifier() throws Throwable {\n+    public void test11_verifier() {\n@@ -330,0 +339,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -374,0 +384,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -416,1 +427,2 @@\n-    @Test()\n+    @Test\n+    @IR(failOn = {ALLOC})\n@@ -443,1 +455,2 @@\n-    @Test()\n+    @Test\n+    @IR(failOn = {ALLOC})\n@@ -472,0 +485,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -494,1 +508,2 @@\n-    @Test()\n+    @Test\n+    @IR(failOn = {ALLOC})\n@@ -527,0 +542,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -557,0 +573,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -574,0 +591,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -615,0 +633,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -637,0 +656,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -652,0 +672,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -671,0 +692,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -700,1 +722,1 @@\n-    public void test25_verifier() {\n+    public void test25_verifier(RunInfo info) {\n@@ -705,0 +727,8 @@\n+        if (!info.isWarmUp()) {\n+            try {\n+                test25(false, null, testValue1);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n@@ -735,1 +765,1 @@\n-    @Test()\n+    @Test\n@@ -761,1 +791,2 @@\n-    @Test()\n+    @Test\n+    @IR(failOn = {ALLOC})\n@@ -802,0 +833,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -818,0 +850,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -832,1 +865,1 @@\n-    private static final MyValue1.ref constNullField = null;\n+    private static final MyValue1.ref constNullRefField = null;\n@@ -835,0 +868,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -836,1 +870,1 @@\n-        return constNullField;\n+        return constNullRefField;\n@@ -860,0 +894,1 @@\n+    @IR(failOn = {ALLOC})\n@@ -892,1 +927,1 @@\n-    @Test()\n+    @Test\n@@ -973,1 +1008,2 @@\n-    public MyValue1 test40() throws Throwable {\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test40() {\n@@ -979,1 +1015,1 @@\n-    public void test40_verifier() throws Throwable {\n+    public void test40_verifier() {\n@@ -987,0 +1023,1366 @@\n+\n+    MyValue1.ref refField;\n+    MyValue1 flatField;\n+\n+    \/\/ Test scalarization of .ref\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE, TRAP})\n+    public int test41(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refField;\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test41(true), refField.x);\n+        Asserts.assertEquals(test41(false), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test41(false), testValue1.x);\n+                test41(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test41 but with call to hash()\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test42(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refField;\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test42(true), refField.hash());\n+        Asserts.assertEquals(test42(false), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test42(false), testValue1.hash());\n+                test42(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test43(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refField;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test43(true).hash(), refField.hash());\n+        Asserts.assertEquals(test43(false).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test43(true), null);\n+        }\n+    }\n+\n+    \/\/ Test scalarization when .ref is referenced in safepoint debug info\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test44(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refField;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test44(true, false, info.getTest()), refField.x);\n+        Asserts.assertEquals(test44(false, false, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test44(false, false, info.getTest()), testValue1.x);\n+                test44(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test44(true, true, info.getTest()), refField.x);\n+            Asserts.assertEquals(test44(false, true, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test45(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refField;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test45(true, false, info.getTest()).hash(), refField.hash());\n+        Asserts.assertEquals(test45(false, false, info.getTest()).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test45(true, false, info.getTest()), null);\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test45(true, true, info.getTest()).hash(), refField.hash());\n+            Asserts.assertEquals(test45(false, true, info.getTest()).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public int test46(boolean b) {\n+        MyValue1.ref val = null;\n+        if (b) {\n+            val = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier() {\n+        Asserts.assertEquals(test46(true), testValue1.x);\n+        try {\n+            test46(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test47(boolean b) {\n+        MyValue1.ref val = null;\n+        if (b) {\n+            val = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier() {\n+        Asserts.assertEquals(test47(true).hash(), testValue1.hash());\n+        Asserts.assertEquals(test47(false), null);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public int test48(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier() {\n+        Asserts.assertEquals(test48(false), testValue1.x);\n+        try {\n+            test48(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test49(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier() {\n+        Asserts.assertEquals(test49(false).hash(), testValue1.hash());\n+        Asserts.assertEquals(test49(true), null);\n+    }\n+\n+    @ForceInline\n+    public Object test50_helper() {\n+        return flatField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, TRAP})\n+    public void test50(boolean b) {\n+        Object o = null;\n+        if (b) {\n+            o = testValue1;\n+        } else {\n+            o = test50_helper();\n+        }\n+        flatField = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatField = vt;\n+        test50(false);\n+        Asserts.assertEquals(flatField.hash(), vt.hash());\n+        test50(true);\n+        Asserts.assertEquals(flatField.hash(), testValue1.hash());\n+    }\n+\n+    static final primitive class MyValue1Wrapper {\n+        final MyValue1.ref vt;\n+\n+        @ForceInline\n+        public MyValue1Wrapper(MyValue1.ref vt) {\n+            this.vt = vt;\n+        }\n+\n+        @ForceInline\n+        public long hash() {\n+            return (vt != null) ? vt.hash() : 0;\n+        }\n+    }\n+\n+    MyValue1Wrapper wrapperField;\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE, TRAP})\n+    public long test51(boolean b) {\n+        MyValue1Wrapper.ref val = MyValue1Wrapper.default;\n+        if (b) {\n+            val = wrapperField;\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        wrapperField = new MyValue1Wrapper(testValue1);\n+        Asserts.assertEquals(test51(true), wrapperField.hash());\n+        Asserts.assertEquals(test51(false), MyValue1Wrapper.default.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public boolean test52(boolean b) {\n+        MyValue1.ref val = MyValue1.default;\n+        if (b) {\n+            val = null;\n+        }\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        return w.vt == null;\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        Asserts.assertTrue(test52(true));\n+        Asserts.assertFalse(test52(false));\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public boolean test53(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        return w.vt == null;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        Asserts.assertTrue(test53(true));\n+        Asserts.assertFalse(test53(false));\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    public long test54(boolean b1, boolean b2) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = null;\n+        }\n+        MyValue1Wrapper.ref w = MyValue1Wrapper.default;\n+        if (b2) {\n+            w = new MyValue1Wrapper(val);\n+        }\n+        return w.hash();\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier() {\n+        MyValue1Wrapper w = new MyValue1Wrapper(MyValue1.createWithFieldsInline(rI, rL));\n+        Asserts.assertEquals(test54(false, false), MyValue1Wrapper.default.hash());\n+        Asserts.assertEquals(test54(false, true), w.hash());\n+        Asserts.assertEquals(test54(true, false), MyValue1Wrapper.default.hash());\n+        Asserts.assertEquals(test54(true, true), 0L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, STORE, TRAP})\n+    public int test55(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test55(true), refField.x);\n+        Asserts.assertEquals(test55(false), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test55(false), testValue1.x);\n+                test55(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE, TRAP})\n+    public long test56(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        return w.vt.hash();\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test56(true), refField.hash());\n+        Asserts.assertEquals(test56(false), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test56(false), testValue1.hash());\n+                test56(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test57(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test57(true).hash(), refField.hash());\n+        Asserts.assertEquals(test57(false).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test57(true), null);\n+        }\n+    }\n+\n+    \/\/ Test scalarization when .ref is referenced in safepoint debug info\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test58(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b1) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test58(true, false, info.getTest()), refField.x);\n+        Asserts.assertEquals(test58(false, false, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test58(false, false, info.getTest()), testValue1.x);\n+                test58(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test58(true, true, info.getTest()), refField.x);\n+            Asserts.assertEquals(test58(false, true, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test59(boolean b1, boolean b2, Method m) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b1) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test59(true, false, info.getTest()).hash(), refField.hash());\n+        Asserts.assertEquals(test59(false, false, info.getTest()).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test59(true, false, info.getTest()), null);\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test59(true, true, info.getTest()).hash(), refField.hash());\n+            Asserts.assertEquals(test59(false, true, info.getTest()).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public int test60(boolean b) {\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(null);\n+        if (b) {\n+            MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+            w = new MyValue1Wrapper(val);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() {\n+        Asserts.assertEquals(test60(true), testValue1.x);\n+        try {\n+            test60(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test61(boolean b) {\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(null);\n+        if (b) {\n+            MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+            w = new MyValue1Wrapper(val);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        Asserts.assertEquals(test61(true).hash(), testValue1.hash());\n+        Asserts.assertEquals(test61(false), null);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public int test62(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(null);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        Asserts.assertEquals(test62(false), testValue1.x);\n+        try {\n+            test62(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1.ref test63(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(null);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        Asserts.assertEquals(test63(false).hash(), testValue1.hash());\n+        Asserts.assertEquals(test63(true), null);\n+    }\n+\n+    @ForceInline\n+    public MyValue1.ref test64_helper() {\n+        return flatField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, TRAP})\n+    public void test64(boolean b) {\n+        MyValue1Wrapper.ref w = new MyValue1Wrapper(null);\n+        if (b) {\n+            w = new MyValue1Wrapper(testValue1);\n+        } else {\n+            w = new MyValue1Wrapper(test64_helper());\n+        }\n+        flatField = w.vt;\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatField = vt;\n+        test64(false);\n+        Asserts.assertEquals(flatField.hash(), vt.hash());\n+        test64(true);\n+        Asserts.assertEquals(flatField.hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    public long test65(boolean b) {\n+        MyValue1.ref val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        if (val != null) {\n+            return val.hashPrimitive();\n+        }\n+        return 42;\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        Asserts.assertEquals(test65(true), 42L);\n+        Asserts.assertEquals(test65(false), MyValue1.createWithFieldsInline(rI, rL).hashPrimitive());\n+    }\n+\n+    @ForceInline\n+    public Object test66_helper(Object arg) {\n+        return arg;\n+    }\n+\n+    \/\/ Test that .ref arg does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test66(boolean b1, boolean b2, MyValue1.ref arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test66_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test66(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test66(false, false, arg, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test66(false, false, arg, info.getTest()), testValue1.x);\n+                test66(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test66(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test66(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @DontInline\n+    public MyValue1.ref test67_helper1() {\n+        return refField;\n+    }\n+\n+    @ForceInline\n+    public Object test67_helper2() {\n+        return test67_helper1();\n+    }\n+\n+    \/\/ Test that .ref return does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public long test67(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test67_helper2();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test67(true, false, info.getTest()), refField.hash());\n+        Asserts.assertEquals(test67(false, false, info.getTest()), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test67(false, false, info.getTest()), testValue1.hash());\n+                test67(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test67(true, true, info.getTest()), refField.hash());\n+            Asserts.assertEquals(test67(false, true, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test68_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Test that scalarization enabled by cast is applied to parsing map\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test68(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test68_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test68(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test68(false, false, arg, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test68(false, false, arg, info.getTest()), testValue1.x);\n+                test68(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test68(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test68(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test69_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test68 but with ClassCastException\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test69(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test69_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test69\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test69_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test69(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test69(false, false, arg, info.getTest()), testValue1.x);\n+        try {\n+            test69(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test69(false, false, arg, info.getTest()), testValue1.x);\n+                test69(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test69(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test69(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test70_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test68 but with ClassCastException and frequent NullPointerException\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test70(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test70_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test70\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test70_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test70(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test70(false, false, arg, info.getTest()), testValue1.x);\n+        try {\n+            test70(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            Asserts.assertEquals(test70(false, false, arg, info.getTest()), testValue1.x);\n+            test70(true, false, null, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test70(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test70(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test71_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1.ref)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test68 but with .ref cast\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test71(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test71_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1.ref)val).x;\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test71(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test71(false, false, arg, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test71(false, false, arg, info.getTest()), testValue1.x);\n+                test71(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test71(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test71(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test72_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1.ref)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test71 but with ClassCastException and hash() call\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public long test72(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test72_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    @Run(test = \"test72\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test72_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test72(true, false, arg, info.getTest()), arg.hash());\n+        Asserts.assertEquals(test72(false, false, arg, info.getTest()), testValue1.hash());\n+        try {\n+            test72(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test72(false, false, arg, info.getTest()), testValue1.hash());\n+                test72(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test72(true, true, arg, info.getTest()), arg.hash());\n+            Asserts.assertEquals(test72(false, true, arg, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test73_helper(Object arg) {\n+        MyValue1.ref tmp = (MyValue1.ref)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test71 but with ClassCastException and frequent NullPointerException\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public int test73(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test73_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1.ref)val).x;\n+    }\n+\n+    @Run(test = \"test73\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test73_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test73(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test73(false, false, arg, info.getTest()), testValue1.x);\n+        try {\n+            test73(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            Asserts.assertEquals(test73(false, false, arg, info.getTest()), testValue1.x);\n+            test73(true, false, null, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test73(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test73(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test74_helper(Object arg) {\n+        return (MyValue1.ref)arg;\n+    }\n+\n+    \/\/ Same as test73 but result of cast is used and hash() is called\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public long test74(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test74_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    @Run(test = \"test74\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test74_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test74(true, false, arg, info.getTest()), arg.hash());\n+        Asserts.assertEquals(test74(false, false, arg, info.getTest()), testValue1.hash());\n+        try {\n+            test74(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            Asserts.assertEquals(test74(false, false, arg, info.getTest()), testValue1.hash());\n+            test74(true, false, null, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test74(true, true, arg, info.getTest()), arg.hash());\n+            Asserts.assertEquals(test74(false, true, arg, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    \/\/ Test new merge path being added for exceptional control flow\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1.ref test75(MyValue1.ref vt, Object obj) {\n+        try {\n+            vt = (MyValue1.ref)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        RuntimeException tmp = new RuntimeException(\"42\"); \/\/ Make sure RuntimeException is loaded\n+        MyValue1.ref vt = testValue1;\n+        MyValue1.ref result = test75(vt, Integer.valueOf(rI));\n+        Asserts.assertEquals(result.hash(), vt.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test76_helper() {\n+        return constNullRefField;\n+    }\n+\n+    \/\/ Test that constant null .ref field does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test76(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test76_helper();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier(RunInfo info) {\n+        Asserts.assertEquals(test76(false, false, info.getTest()), testValue1.hash());\n+        try {\n+            test76(true, false, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test76(false, true, info.getTest()), testValue1.hash());\n+            try {\n+                test76(true, true, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    private static final Object constObjectValField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+\n+    @ForceInline\n+    public Object test77_helper() {\n+        return constObjectValField;\n+    }\n+\n+    \/\/ Test that constant object field with inline type content does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test77(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test77_helper();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier(RunInfo info) {\n+        Asserts.assertEquals(test77(true, false, info.getTest()), ((MyValue1)constObjectValField).hash());\n+        Asserts.assertEquals(test77(false, false, info.getTest()), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+          Asserts.assertEquals(test77(true, false, info.getTest()), ((MyValue1)constObjectValField).hash());\n+          Asserts.assertEquals(test77(false, false, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test78_helper() {\n+        return null;\n+    }\n+\n+    \/\/ Test that constant null does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test78(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test78_helper();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier(RunInfo info) {\n+        Asserts.assertEquals(test78(false, false, info.getTest()), testValue1.hash());\n+        try {\n+            test78(true, false, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test78(false, true, info.getTest()), testValue1.hash());\n+            try {\n+                test78(true, true, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test79_helper() {\n+        return null;\n+    }\n+\n+    \/\/ Same as test78 but will trigger different order of PhiNode inputs\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test79(boolean b1, boolean b2, Method m) {\n+        Object val = test79_helper();\n+        if (b1) {\n+            val = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier(RunInfo info) {\n+        Asserts.assertEquals(test79(true, false, info.getTest()), testValue1.hash());\n+        try {\n+            test79(false, false, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test79(true, true, info.getTest()), testValue1.hash());\n+            try {\n+                test79(false, true, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test80_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return MyValue1.createWithFieldsInline(i, i);\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Test that phi nodes referencing themselves (loops) do not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test80() {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        for (int i = 0; i < 100; ++i) {\n+            val = test80_helper(val, i);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    private final long test80Result = test80();\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() {\n+        Asserts.assertEquals(test80(), test80Result);\n+    }\n+\n+    @ForceInline\n+    public Object test81_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return MyValue1.createWithFieldsInline(i, i);\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Test nested loops\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test81() {\n+        Object val = null;\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    val = test81_helper(val, i + j + k);\n+                }\n+                val = test81_helper(val, i + j);\n+            }\n+            val = test81_helper(val, i);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    private final long test81Result = test81();\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        Asserts.assertEquals(test82(), test82Result);\n+    }\n+\n+    @ForceInline\n+    public Object test82_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return MyValue1.createWithFieldsInline(i, i);\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Test loops with casts\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test82() {\n+        Object val = null;\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    val = test82_helper(val, i + j + k);\n+                }\n+                if (val != null) {\n+                    val = test82_helper(val, i + j);\n+                }\n+            }\n+            val = test82_helper(val, i);\n+        }\n+        return ((MyValue1.ref)val).hash();\n+    }\n+\n+    private final long test82Result = test82();\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier() {\n+        Asserts.assertEquals(test82(), test82Result);\n+    }\n+\n+    @ForceInline\n+    public Object test83_helper(boolean b) {\n+        if (b) {\n+            return MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Test that CastPP does not block sclarization in safepoints\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test83(boolean b, Method m) {\n+        Object val = test83_helper(b);\n+        if (val != null) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return ((MyValue1.ref)val).hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier(RunInfo info) {\n+        Asserts.assertEquals(test83(false, info.getTest()), 0L);\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test83(true, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test84_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return new MyValue1Wrapper(MyValue1.createWithFieldsInline(i, i));\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Same as test80 but with wrapper\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test84() {\n+        Object val = new MyValue1Wrapper(MyValue1.createWithFieldsInline(rI, rL));\n+        for (int i = 0; i < 100; ++i) {\n+            val = test84_helper(val, i);\n+        }\n+        return ((MyValue1Wrapper.ref)val).vt.hash();\n+    }\n+\n+    private final long test84Result = test84();\n+\n+    @Run(test = \"test84\")\n+    public void test84_verifier() {\n+        Asserts.assertEquals(test84(), test84Result);\n+    }\n+\n+    @ForceInline\n+    public Object test85_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return new MyValue1Wrapper(MyValue1.createWithFieldsInline(i, i));\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Same as test81 but with wrapper\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE})\n+    public long test85() {\n+        Object val = new MyValue1Wrapper(null);\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    val = test85_helper(val, i + j + k);\n+                }\n+                val = test85_helper(val, i + j);\n+            }\n+            val = test85_helper(val, i);\n+        }\n+        return ((MyValue1Wrapper.ref)val).vt.hash();\n+    }\n+\n+    private final long test85Result = test85();\n+\n+    @Run(test = \"test85\")\n+    public void test85_verifier() {\n+        Asserts.assertEquals(test82(), test82Result);\n+    }\n+\n+    static final class ObjectWrapper {\n+        public Object obj;\n+\n+        @ForceInline\n+        public ObjectWrapper(Object obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    \/\/ Test scalarization with phi referencing itself\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC, LOAD, STORE})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, STORE})\n+    public long test86(MyValue1 vt) {\n+        ObjectWrapper val = new ObjectWrapper(vt);\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                val.obj = val.obj;\n+            }\n+        }\n+        return ((MyValue1.ref)val.obj).hash();\n+    }\n+\n+    @Run(test = \"test86\")\n+    public void test86_verifier() {\n+        test86(testValue1);\n+        Asserts.assertEquals(test86(testValue1), testValue1.hash());\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":1428,"deletions":26,"binary":false,"changes":1454,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        for (int i = 0 ; i < 50_000; ++i) {\n+        for (int i = 0; i < 50_000; ++i) {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}