{"files":[{"patch":"@@ -43,0 +43,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -383,0 +386,16 @@\n+\n+\/\/ Inlined fields of primitive classes are dumped as identity objects and require unique object ids.\n+\/\/ We cannot use address of the object in container oop (as we do for identity objects)\n+\/\/ because the address can be the same for inlined object which contains inlined field with offset 0.\n+class InlinedObjectSupport : public StackObj {\n+    friend class DumpWriter;\n+    InlinedObjectSupport(int initial_value = 1) : _counter(initial_value) {}\n+\n+    int _counter;\n+    int getId() { return _counter++; }\n+public:\n+    InlinedObjectSupport save() const {\n+        return InlinedObjectSupport(_counter);\n+    }\n+};\n+\n@@ -417,0 +436,2 @@\n+  InlinedObjectSupport _inlined_object_support;\n+\n@@ -428,0 +449,2 @@\n+  InlinedObjectSupport& inlined_object_support() { return _inlined_object_support; }\n+\n@@ -435,0 +458,1 @@\n+  void write_inlinedObjectID(InlinedObjectSupport &inlinedObjectSupport);\n@@ -541,0 +565,8 @@\n+void DumpWriter::write_inlinedObjectID(InlinedObjectSupport& inlinedObjectSupport) {\n+#ifdef _LP64\n+  write_u8(inlinedObjectSupport.getId());\n+#else\n+  write_u4(inlinedObjectSupport.getId());\n+#endif\n+}\n+\n@@ -640,2 +672,3 @@\n-  \/\/ dumps the raw value of the given field\n-  static void dump_field_value(DumpWriter* writer, char type, oop obj, int offset);\n+  \/\/ dumps the raw value of the given field; obj and offset specify the object (offset is 0 for identity objects)\n+  \/\/ for inlined fields writed object id generated by writer->inlined_object_support()\n+  static void dump_field_value(DumpWriter* writer, const FieldStream& fld, oop obj, int offset);\n@@ -646,2 +679,9 @@\n-  \/\/ dump the raw values of the instance fields of the given object\n-  static void dump_instance_fields(DumpWriter* writer, oop o);\n+  \/\/ dump the raw values of the instance fields of the given identity or inlined object;\n+  \/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n+  \/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class\n+  static void dump_instance_fields(DumpWriter* writer, oop o, int offset, Klass* klass);\n+  \/\/ dump inlined instance fields of the given object (identity or inlined);\n+  \/\/ o is the holder object, offset and klass specify flattened field (or field of flattened field, etc.);\n+  \/\/ for identity object offset is 0 and klass is o->klass()\n+  static void dump_inlined_instance_fields(DumpWriter* writer, oop o, int offset, Klass* klass, InlinedObjectSupport &ios);\n+\n@@ -652,0 +692,2 @@\n+  \/\/ creates HPROF_GC_INSTANCE_DUMP record for the given inlined object\n+  static void dump_inlined_object(DumpWriter* writer, oop holder, int offset, InlineKlass* klass, InlinedObjectSupport& ios);\n@@ -662,1 +704,2 @@\n-  static void dump_object_array(DumpWriter* writer, objArrayOop array);\n+  \/\/static void dump_object_array(DumpWriter* writer, objArrayOop array);\n+  static void dump_object_array(DumpWriter* writer, arrayOop array);\n@@ -696,0 +739,1 @@\n+    case JVM_SIGNATURE_INLINE_TYPE: return HPROF_NORMAL_OBJECT;\n@@ -726,0 +770,1 @@\n+    case JVM_SIGNATURE_INLINE_TYPE:\n@@ -768,2 +813,5 @@\n-\/\/ dumps the raw value of the given field\n-void DumperSupport::dump_field_value(DumpWriter* writer, char type, oop obj, int offset) {\n+\/\/ dumps the raw value of the given field; obj and offset specify the object (offset is 0 for identity objects)\n+\/\/ for inlined fields writed object id generated by writer->inlined_object_support()\n+void DumperSupport::dump_field_value(DumpWriter* writer, const FieldStream& fld, oop obj, int offset) {\n+  char type = fld.signature()->char_at(0);\n+  offset += fld.offset();\n@@ -771,0 +819,7 @@\n+    case JVM_SIGNATURE_INLINE_TYPE: {\n+      if (fld.field_descriptor().is_inlined()) {\n+        writer->write_inlinedObjectID(writer->inlined_object_support());\n+        break;\n+      }\n+    }\n+    \/\/ pass through\n@@ -898,0 +953,3 @@\n+      \/\/ if this changes, need to handle this properly (dump inlined objects after dump_static_fields)\n+      assert(!fld.field_descriptor().is_inlined(), \"static fields cannot be inlined\");\n+\n@@ -899,1 +957,1 @@\n-      dump_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset());\n+      dump_field_value(writer, fld, ik->java_mirror(), 0);\n@@ -929,0 +987,1 @@\n+\n@@ -930,2 +989,2 @@\n-void DumperSupport::dump_instance_fields(DumpWriter* writer, oop o) {\n-  InstanceKlass* ik = InstanceKlass::cast(o->klass());\n+void DumperSupport::dump_instance_fields(DumpWriter* writer, oop o, int offset, Klass *klass) {\n+  InstanceKlass* ik = InstanceKlass::cast(klass);\n@@ -935,2 +994,1 @@\n-      Symbol* sig = fld.signature();\n-      dump_field_value(writer, sig->char_at(0), o, fld.offset());\n+      dump_field_value(writer, fld, o, offset);\n@@ -941,1 +999,17 @@\n-\/\/ dumps the definition of the instance fields for a given class\n+void DumperSupport::dump_inlined_instance_fields(DumpWriter *writer, oop o, int offset, Klass *klass, InlinedObjectSupport &ios) {\n+  InstanceKlass* ik = InstanceKlass::cast(klass);\n+\n+  assert(&ios != &writer->inlined_object_support(), \"must be saved copy\");\n+\n+  for (FieldStream fld(ik, false, false); !fld.eos(); fld.next()) {\n+    if (!fld.access_flags().is_static()) {\n+      if (fld.field_descriptor().is_inlined()) {\n+        InstanceKlass* holder_klass = fld.field_descriptor().field_holder();\n+        InlineKlass* field_klass = InlineKlass::cast(holder_klass->get_inline_type_field_klass(fld.index()));\n+        dump_inlined_object(writer, o, offset + fld.offset(), field_klass, ios);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ gets the count of the instance fields for a given class\n@@ -967,0 +1041,31 @@\n+\/\/ creates HPROF_GC_INSTANCE_DUMP record for the given inlined object\n+void DumperSupport::dump_inlined_object(DumpWriter* writer, oop holder, int offset, InlineKlass* klass, InlinedObjectSupport& ios) {\n+  u4 is = instance_size(klass);\n+  u4 size = 1 + sizeof(address) + 4 + sizeof(address) + 4 + is;\n+\n+  writer->start_sub_record(HPROF_GC_INSTANCE_DUMP, size);\n+  writer->write_inlinedObjectID(ios);\n+\n+  writer->write_u4(STACK_TRACE_ID);\n+\n+  \/\/ class ID\n+  writer->write_classID(klass);\n+\n+  \/\/ number of bytes that follow\n+  writer->write_u4(is);\n+\n+  \/\/ the object if flattened, so all fields are stored without headers\n+  \/\/ update offset here instead of handling it in both dump_instance_fields and dump_inlined_instance_fields\n+  offset -= klass->first_field_offset();\n+\n+  InlinedObjectSupport saved_ios = writer->inlined_object_support().save();\n+\n+  \/\/ field values\n+  dump_instance_fields(writer, holder, offset, klass);\n+\n+  writer->end_sub_record();\n+\n+  \/\/ dump flattened fields\n+  dump_inlined_instance_fields(writer, holder, offset, klass, saved_ios);\n+}\n+\n@@ -983,0 +1088,2 @@\n+  InlinedObjectSupport saved_ios = writer->inlined_object_support().save();\n+\n@@ -984,1 +1091,1 @@\n-  dump_instance_fields(writer, o);\n+  dump_instance_fields(writer, o, 0, o->klass());\n@@ -987,0 +1094,3 @@\n+\n+  \/\/ dump inlined fields\n+  dump_inlined_instance_fields(writer, o, 0, o->klass(), saved_ios);\n@@ -1081,2 +1191,2 @@\n- \/\/ array classes\n- while (k != NULL) {\n+  \/\/ array classes\n+  while (k != NULL) {\n@@ -1117,1 +1227,1 @@\n-  assert(type >= T_BOOLEAN && type <= T_OBJECT, \"invalid array element type\");\n+  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_INLINE_TYPE, \"invalid array element type\");\n@@ -1122,1 +1232,1 @@\n-  if (type == T_OBJECT) {\n+  if (type == T_OBJECT || type == T_INLINE_TYPE) {\n@@ -1142,1 +1252,1 @@\n-void DumperSupport::dump_object_array(DumpWriter* writer, objArrayOop array) {\n+void DumperSupport::dump_object_array(DumpWriter* writer, arrayOop array) {\n@@ -1156,8 +1266,20 @@\n-  \/\/ [id]* elements\n-  for (int index = 0; index < length; index++) {\n-    oop o = array->obj_at(index);\n-    if (o != NULL && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == NULL) {\n-      ResourceMark rm;\n-      log_debug(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s) referenced by \" INTPTR_FORMAT \" (%s)\",\n-                           p2i(o), o->klass()->external_name(),\n-                           p2i(array), array->klass()->external_name());\n+  InlinedObjectSupport ios = writer->inlined_object_support().save();\n+  if (array->is_objArray()) {\n+    \/\/ [id]* elements\n+    objArrayOop objArray = objArrayOop(array);\n+    for (int index = 0; index < length; index++) {\n+      oop o = objArray->obj_at(index);\n+      if (o != NULL && log_is_enabled(Debug, cds, heap) && mask_dormant_archived_object(o) == NULL) {\n+        ResourceMark rm;\n+        log_debug(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s) referenced by \" INTPTR_FORMAT \" (%s)\",\n+                             p2i(o), o->klass()->external_name(),\n+                             p2i(array), array->klass()->external_name());\n+      }\n+      o = mask_dormant_archived_object(o);\n+      writer->write_objectID(o);\n+    }\n+  } else { \/\/ flatArray\n+    \/\/ [id]* elements\n+    flatArrayOop flatArray = flatArrayOop(array);\n+    for (int index = 0; index < length; index++) {\n+      writer->write_inlinedObjectID(writer->inlined_object_support());\n@@ -1165,2 +1287,0 @@\n-    o = mask_dormant_archived_object(o);\n-    writer->write_objectID(o);\n@@ -1170,0 +1290,13 @@\n+\n+  if (array->is_flatArray()) {\n+    flatArrayOop flatArray = flatArrayOop(array);\n+    FlatArrayKlass* vaklass = FlatArrayKlass::cast(flatArray->klass());\n+    InlineKlass* vklass = vaklass->element_klass();\n+    for (int index = 0; index < length; index++) {\n+      \/\/ need offset in the holder to read inlined object. calculate it from flatArrayOop::value_at_addr()\n+      int offset = (int)((address)flatArray->value_at_addr(index, vaklass->layout_helper())\n+                        - cast_from_oop<address>(flatArray));\n+\n+      dump_inlined_object(writer, flatArray, offset, vklass, ios);\n+    }\n+  }\n@@ -1440,1 +1573,1 @@\n-  } else if (o->is_objArray()) {\n+  } else if (o->is_objArray() || o->is_flatArray()) {\n@@ -1442,1 +1575,1 @@\n-    DumperSupport::dump_object_array(writer(), objArrayOop(o));\n+    DumperSupport::dump_object_array(writer(), arrayOop(o));\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":164,"deletions":31,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -0,0 +1,495 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @requires vm.jvmti\n+ * @run main HeapDump\n+ *\/\n+\n+import java.io.File;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.TimeUnit;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.hprof.model.HackJavaValue;\n+import jdk.test.lib.hprof.model.JavaByte;\n+import jdk.test.lib.hprof.model.JavaClass;\n+import jdk.test.lib.hprof.model.JavaField;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.JavaObject;\n+import jdk.test.lib.hprof.model.JavaObjectArray;\n+import jdk.test.lib.hprof.model.JavaStatic;\n+import jdk.test.lib.hprof.model.JavaThing;\n+import jdk.test.lib.hprof.model.JavaValueArray;\n+import jdk.test.lib.hprof.model.Snapshot;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.Enumeration;\n+\n+import jdk.test.lib.hprof.parser.Reader;\n+\n+\n+class TestClass {\n+\n+    public static primitive class MyPrimitive {\n+        public byte fld1;\n+        public int fld2;\n+\n+        public MyPrimitive(int v1, int v2) { fld1 = (byte)v1; fld2 = v2; }\n+        public static MyPrimitive create(int v1, int v2) { return new MyPrimitive(v1, v2); }\n+    }\n+\n+    public static primitive class PrimitiveHolder {\n+        \/\/ offset of the inlined flatObj is the same as offset of inlined PrimitiveHolder\n+        public MyPrimitive flatObj = MyPrimitive.create(12, 142);\n+\n+        public PrimitiveHolder(int n) { }\n+        public static PrimitiveHolder create(int n) { return new PrimitiveHolder(n); }\n+    }\n+\n+    \/\/ primitive class with reference\n+    public static primitive class MyPrimitiveRef {\n+        public int fld1;\n+        public int fld2;\n+        public String strObj;\n+\n+        public MyPrimitiveRef(int v1, int v2) { fld1 = v1; fld2 = v2; strObj = \"#\" + String.valueOf(v1); }\n+        public static MyPrimitiveRef create(int v1, int v2) { return new MyPrimitiveRef(v1, v2); }\n+    }\n+\n+    public static primitive class PrimitiveHolderRef {\n+        public MyPrimitiveRef[] flatArr = new MyPrimitiveRef[4];\n+        public MyPrimitiveRef flatObj = MyPrimitiveRef.create(13, 143);\n+\n+        public PrimitiveHolderRef(int n) {\n+            for (int i = 0; i < flatArr.length; i++) {\n+                flatArr[i] = MyPrimitiveRef.create(i + n + 1, i + n + 11);\n+            }\n+        }\n+        public static PrimitiveHolderRef create(int n) { return new PrimitiveHolderRef(n); }\n+    }\n+\n+    public MyPrimitive[] flatArr = new MyPrimitive[4];\n+    public MyPrimitive flatObj = MyPrimitive.create(11, 141);\n+    public MyPrimitiveRef flatObjRef = MyPrimitiveRef.create(11, 144);\n+    public MyPrimitiveRef[] flatArrRef = new MyPrimitiveRef[4];\n+    public String strObj = \"targ.strObj\";\n+\n+    public Object nullObj;\n+\n+    public final PrimitiveHolder primHolder = PrimitiveHolder.create(16);\n+    \/\/ array of compound primitive objects\n+    public final PrimitiveHolderRef[] primHolderArr = new PrimitiveHolderRef[4];\n+\n+\n+    \/\/ static inlined fields\n+    public static MyPrimitive flatObjStatic = MyPrimitive.create(11, 241);\n+    public static MyPrimitiveRef[] flatArrRefStatic = new MyPrimitiveRef[4];\n+    static {\n+        for (int i = 0; i < flatArrRefStatic.length; i++) {\n+            flatArrRefStatic[i] = MyPrimitiveRef.create(i + 200, i + 225);\n+        }\n+    }\n+\n+    public TestClass() {\n+        for (int i = 0; i < flatArr.length; i++) {\n+            flatArr[i] = MyPrimitive.create(i + 10, i + 110);\n+        }\n+        for (int i = 0; i < flatArrRef.length; i++) {\n+            flatArrRef[i] = MyPrimitiveRef.create(i + 100, i + 120);\n+        }\n+        for (int i = 0; i < primHolderArr.length; i++) {\n+            primHolderArr[i] = PrimitiveHolderRef.create(20+i);\n+        }\n+    }\n+}\n+\n+class HeapDumpTarg extends LingeredApp {\n+\n+    public static void main(String[] args) {\n+        TestClass testObj = new TestClass();\n+        LingeredApp.main(args);\n+        System.out.println(testObj);\n+    }\n+\n+}\n+\n+public class HeapDump {\n+\n+    public static void copyDirectory(String sourceDirectoryLocation, String destinationDirectoryLocation)\n+            throws Exception {\n+        Files.walk(Paths.get(sourceDirectoryLocation))\n+                .forEach(source -> {\n+                    Path destination = Paths.get(destinationDirectoryLocation, source.toString()\n+                            .substring(sourceDirectoryLocation.length()));\n+                    try {\n+                        Files.copy(source, destination);\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        LingeredApp theApp = null;\n+        String hprogFile = new File(System.getProperty(\"test.classes\") + \"\/Myheapdump.hprof\").getAbsolutePath();\n+        try {\n+            theApp = new HeapDumpTarg();\n+\n+            LingeredApp.startApp(theApp\/*, \"-XX:+PrintInlineLayout\"*\/);\n+\n+            \/\/jcmd <pid> GC.heap_dump\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                                        .createUsingTestJDK(\"jcmd\")\n+                                        .addToolArg(Long.toString(theApp.getPid()))\n+                                        .addToolArg(\"GC.heap_dump\")\n+                                        .addToolArg(hprogFile);\n+            Process jcmd = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(launcher.getCommand()));\n+            \/\/ If something goes wrong with heap dumping most likely we'll get crash of the target VM\n+            while (!jcmd.waitFor(5, TimeUnit.SECONDS)) {\n+                if (!theApp.getProcess().isAlive()) {\n+                    log(\"ERROR: target VM died, killing jcmd...\");\n+                    jcmd.destroyForcibly();\n+                    throw new Exception(\"Target VM died\");\n+                }\n+            }\n+\n+            if (jcmd.exitValue() != 0) {\n+                throw new Exception(\"Jcmd exited with code \" + jcmd.exitValue());\n+            }\n+        } finally {\n+            try {\n+                copyDirectory(\".\", System.getProperty(\"test.classes\") + \"\/scratch\");\n+            } finally {\n+                LingeredApp.stopApp(theApp);\n+            }\n+\n+        }\n+\n+        \/\/ test object to compare\n+        TestClass testObj = new TestClass();\n+\n+        log(\"Reading \" + hprogFile + \"...\");\n+        try (Snapshot snapshot = Reader.readFile(hprogFile,true, 0)) {\n+            log(\"Snapshot read, resolving...\");\n+            snapshot.resolve(true);\n+            log(\"Snapshot resolved.\");\n+\n+            JavaObject dumpObj = findObject(snapshot, testObj.getClass().getName());\n+\n+            log(\"\");\n+            print(dumpObj);\n+\n+            log(\"\");\n+            log(\"Verifying object \" + testObj.getClass().getName() + \" (dumped object \" + dumpObj + \")\");\n+            compareObjectFields(\"  \", testObj, dumpObj);\n+        }\n+    }\n+\n+    private static JavaObject findObject(Snapshot snapshot, String className) throws Exception {\n+        log(\"looking for \" + className + \"...\");\n+        JavaClass jClass = snapshot.findClass(className);\n+        if (jClass == null) {\n+            throw new Exception(\"'\" + className + \"' not found\");\n+        }\n+        Enumeration<JavaHeapObject> objects = jClass.getInstances(false);\n+        if (!objects.hasMoreElements()) {\n+            throw new Exception(\"No '\" + className + \"' instances found\");\n+        }\n+        JavaHeapObject heapObj = objects.nextElement();\n+        if (objects.hasMoreElements()) {\n+            throw new Exception(\"More than 1 instances of '\" + className + \"' found\");\n+        }\n+        if (!(heapObj instanceof JavaObject)) {\n+            throw new Exception(\"'\" + className + \"' instance is not JavaObject (\" + heapObj.getClass() + \")\");\n+        }\n+        return (JavaObject)heapObj;\n+    }\n+\n+    \/\/ description of the current object for logging and error reporting\n+    private static String objDescr;\n+    private static boolean errorReported = false;\n+\n+    private static void compareObjects(String logPrefix, Object testObj, JavaThing dumpObj) throws Exception {\n+        if (testObj == null) {\n+            if (!isNullValue(dumpObj)) {\n+                throw new Exception(\"null expected, but dumped object is \" + dumpObj);\n+            }\n+            log(logPrefix + objDescr + \": null\");\n+        } else if (dumpObj instanceof JavaObject obj) {\n+            \/\/ special handling for Strings\n+            \/\/ we know testValue != null\n+            if (testObj instanceof String testStr) {\n+                objDescr += \" (String, \" + obj.getIdString() + \")\";\n+                if (!obj.getClazz().isString()) {\n+                    throw new Exception(\"value (\" + obj + \")\"\n+                            + \" is not String (\" + obj.getClazz() + \")\");\n+                }\n+                String dumpStr = getStringValue(obj);\n+                if (!testStr.equals(dumpStr)) {\n+                    throw new Exception(\"different values:\"\n+                            + \" expected \\\"\" + testStr + \"\\\", actual \\\"\" + dumpStr + \"\\\"\");\n+                }\n+                log(logPrefix + objDescr + \": \\\"\" + testStr + \"\\\" ( == \\\"\" + dumpStr + \"\\\")\");\n+            } else {\n+                \/\/ other Object\n+                log(logPrefix + objDescr + \": Object \" + obj);\n+                if (isTestClass(obj.getClazz().getName())) {\n+                    compareObjectFields(logPrefix + \"  \", testObj, obj);\n+                }\n+            }\n+        } else {\n+            throw new Exception(\"Object expected, but the value (\" + dumpObj + \")\"\n+                    + \" is not JavaObject (\" + dumpObj.getClass() + \")\");\n+        }\n+    }\n+\n+    private static void compareObjectFields(String logPrefix, Object testObj, JavaObject dumpObj) throws Exception {\n+        Field[] fields = testObj.getClass().getDeclaredFields();\n+        for (Field testField : fields) {\n+            boolean isStatic = Modifier.isStatic(testField.getModifiers());\n+            testField.setAccessible(true);\n+            objDescr = \"- \" + (isStatic ? \"(static) \" : \"\")\n+                    + testField.getName() + \" ('\" + testField.getType().descriptorString() + \"')\";\n+            try {\n+                Object testValue = testField.get(testObj);\n+\n+                JavaField dumpField = getField(dumpObj, testField.getName(), isStatic);\n+                JavaThing dumpValue = isStatic\n+                        ? dumpObj.getClazz().getStaticField(dumpField.getName())\n+                        : dumpObj.getField(dumpField.getName());\n+\n+                objDescr += \", dump signature '\" + dumpField.getSignature() + \"'\";\n+\n+                compareType(testField, dumpField);\n+\n+                if (testValue == null) {\n+                    if (!isNullValue(dumpValue)) {\n+                        throw new Exception(\"null expected, but dumped object is \" + dumpValue);\n+                    }\n+                    log(logPrefix + objDescr + \": null\");\n+                } else {\n+                    switch (testField.getType().descriptorString().charAt(0)) {\n+                    case 'L':\n+                    case 'Q':\n+                        compareObjects(logPrefix, testValue, dumpValue);\n+                        break;\n+                    case '[':\n+                        int testLength = Array.getLength(testValue);\n+                        objDescr += \" (Array of '\" + testField.getType().getComponentType() + \"'\"\n+                                + \", length = \" + testLength + \", \" + dumpValue + \")\";\n+                        if (dumpValue instanceof JavaValueArray arr) {\n+                            \/\/ array of primitive type\n+                            char testElementType = testField.getType().getComponentType().descriptorString().charAt(0);\n+                            if ((char) arr.getElementType() != testElementType) {\n+                                throw new Exception(\"wrong element type: '\" + (char) arr.getElementType() + \"'\");\n+                            }\n+                            int dumpLength = arr.getLength();\n+                            if (dumpLength != testLength) {\n+                                throw new Exception(\"wrong array size: \" + dumpLength);\n+                            }\n+                            JavaThing[] dumpElements = arr.getElements();\n+                            log(logPrefix + objDescr);\n+                            for (int j = 0; j < testLength; j++) {\n+                                Object elementValue = Array.get(testValue, j);\n+                                objDescr = \"[\" + j + \"]\";\n+                                comparePrimitiveValues(elementValue, dumpElements[j]);\n+                                log(logPrefix + \"  [\" + j + \"]: \" + elementValue + \" ( == \" + dumpElements[j] + \")\");\n+                            }\n+                        } else if (dumpValue instanceof JavaObjectArray arr) {\n+                            int dumpLength = arr.getLength();\n+                            if (dumpLength != testLength) {\n+                                throw new Exception(\"wrong array size: \" + dumpLength);\n+                            }\n+                            JavaThing[] dumpElements = arr.getElements();\n+                            log(logPrefix + objDescr);\n+                            for (int j = 0; j < testLength; j++) {\n+                                Object elementValue = Array.get(testValue, j);\n+                                objDescr = \"[\" + j + \"]\";\n+                                compareObjects(logPrefix + \"  \", elementValue, dumpElements[j]);\n+                            }\n+                        } else {\n+                            throw new Exception(\"Array expected, but the value (\" + dumpValue + \")\"\n+                                    + \" is neither JavaValueArray nor JavaObjectArray\"\n+                                    + \" (\" + dumpValue.getClass() + \")\");\n+                        }\n+                        break;\n+                    default:\n+                        comparePrimitiveValues(testValue, dumpValue);\n+                        log(logPrefix + objDescr + \": \" + testValue + \" ( == \" + dumpValue + \")\");\n+                        break;\n+                    }\n+                }\n+            } catch (Exception ex) {\n+                if (!errorReported) {\n+                    log(logPrefix + objDescr + \": ERROR - \" + ex.getMessage());\n+                    errorReported = true;\n+                }\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    private static JavaField getField(JavaObject obj, String fieldName, boolean isStatic) throws Exception {\n+        if (isStatic) {\n+            JavaStatic[] statics = obj.getClazz().getStatics();\n+            for (JavaStatic st: statics) {\n+                if (st.getField().getName().equals(fieldName)) {\n+                    return st.getField();\n+                }\n+            }\n+        } else {\n+            JavaField[] fields = obj.getClazz().getFields();\n+            for (JavaField field : fields) {\n+                if (fieldName.equals(field.getName())) {\n+                    return field;\n+                }\n+            }\n+        }\n+        throw new Exception(\"field '\" + fieldName + \"' not found\");\n+    }\n+\n+    private static void compareType(Field field, JavaField dumpField) throws Exception {\n+        String sig = field.getType().descriptorString();\n+        char type = sig.charAt(0);\n+        if (type == '[' || type == 'Q') {\n+            type = 'L';\n+        }\n+        if (dumpField.getSignature().charAt(0) != type) {\n+            throw new Exception(\"type mismatch:\"\n+                    + \" expected '\" + type + \"' (\" + sig + \")\"\n+                    + \", found '\" + dumpField.getSignature().charAt(0) + \"' (\" + dumpField.getSignature() + \")\");\n+        }\n+    }\n+\n+    private static void comparePrimitiveValues(Object testValue, JavaThing dumpValue) throws Exception {\n+        \/\/ JavaByte.toString() returns hex\n+        String testStr = testValue instanceof Byte byteValue\n+                ? (new JavaByte(byteValue)).toString()\n+                : String.valueOf(testValue);\n+        String dumpStr = dumpValue.toString();\n+        if (!testStr.equals(dumpStr)) {\n+            throw new Exception(\"Wrong value: expected \" + testStr + \", actual \" + dumpStr);\n+        }\n+    }\n+\n+    private static boolean isNullValue(JavaThing value) {\n+        return value == null\n+                \/\/ dumped value is HackJavaValue with string representation \"<null>\"\n+                || (value instanceof HackJavaValue &&  \"<null>\".equals(value.toString()));\n+    }\n+\n+    private static String getStringValue(JavaObject value) {\n+        JavaThing valueObj = value.getField(\"value\");\n+        if (valueObj instanceof JavaValueArray valueArr) {\n+            try {\n+                if (valueArr.getElementType() == 'B') {\n+                    Field valueField = JavaByte.class.getDeclaredField(\"value\");\n+                    valueField.setAccessible(true);\n+                    JavaThing[] things = valueArr.getElements();\n+                    byte[] bytes = new byte[things.length];\n+                    for (int i = 0; i < things.length; i++) {\n+                        bytes[i] = valueField.getByte(things[i]);\n+                    }\n+                    return new String(bytes);\n+                }\n+            } catch (Exception ignored) {\n+            }\n+            return valueArr.valueString();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void print(JavaObject dumpObject) {\n+        log(\"Dumped object \" + dumpObject + \":\");\n+        print(\"\", dumpObject);\n+    }\n+\n+    private static void print(String prefix, JavaObject dumpObject) {\n+        JavaClass clazz = dumpObject.getClazz();\n+        \/\/ print only test classes\n+        if (!isTestClass(clazz.getName())) {\n+            return;\n+        }\n+\n+        JavaField[] fields = clazz.getFields();\n+        for (JavaField field : fields) {\n+            printFieldValue(prefix, field, false, dumpObject.getField(field.getName()));\n+        }\n+\n+        JavaStatic[] statics = clazz.getStatics();\n+        for (JavaStatic st: statics) {\n+            printFieldValue(prefix, st.getField(), true, st.getValue());\n+        }\n+    }\n+\n+    private static void printFieldValue(String prefix, JavaField field, boolean isStatic, JavaThing value) {\n+        String logPrefix = prefix + \"- \" + (isStatic ? \"(static) \" : \"\")\n+                + field.getName() + \" ('\" + field.getSignature() + \"'): \";\n+        if (isNullValue(value)) {\n+            log(logPrefix + \"null\");\n+        } else {\n+            if (value instanceof JavaObject obj) {\n+                logPrefix += \"(class '\" + obj.getClazz().getName() + \"'): \";\n+                if (obj.getClazz().isString()) {\n+                    String dumpStr = getStringValue(obj);\n+                    log(logPrefix + \"\\\"\" + dumpStr + \"\\\"\");\n+                } else {\n+                    log(logPrefix + \"object \" + obj);\n+                    print(prefix + \"  \", obj);\n+                }\n+            } else if (value instanceof JavaObjectArray arr) {\n+                log(logPrefix + \" array \" + arr + \" length: \" + arr.getLength());\n+                JavaThing[] values = arr.getValues();\n+                for (int v = 0; v < values.length; v++) {\n+                    log(prefix + \"  [\" + v + \"]: \" + values[v]);\n+                    if (values[v] instanceof JavaObject obj) {\n+                        print(prefix + \"    \", obj);\n+                    }\n+                }\n+            } else if (value instanceof JavaValueArray arr) { \/\/ array of primitive type\n+                log(logPrefix + \"(array of '\" + (char) arr.getElementType() + \"')\" + \": \" + arr.valueString());\n+            } else {\n+                log(logPrefix + value.toString());\n+            }\n+        }\n+    }\n+\n+    private static boolean isTestClass(String className) {\n+        return className.startsWith(\"TestClass\");\n+    }\n+\n+    private static void log(String msg) {\n+        System.out.println(msg);\n+        System.out.flush();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Valhalla\/HeapDump\/HeapDump.java","additions":495,"deletions":0,"binary":false,"changes":495,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,2 +72,2 @@\n-            case T_BYTE:\n-            case T_BOOLEAN:\n+            case 'B':\n+            case 'Z':\n@@ -75,2 +75,2 @@\n-            case T_CHAR:\n-            case T_SHORT:\n+            case 'C':\n+            case 'S':\n@@ -78,2 +78,2 @@\n-            case T_INT:\n-            case T_FLOAT:\n+            case 'I':\n+            case 'F':\n@@ -81,2 +81,2 @@\n-            case T_LONG:\n-            case T_DOUBLE:\n+            case 'J':\n+            case 'D':\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaValueArray.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}