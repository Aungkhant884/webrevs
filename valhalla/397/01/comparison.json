{"files":[{"patch":"@@ -414,1 +414,1 @@\n-void Compile::remove_useless_nodes(Unique_Node_List &useful) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n@@ -437,1 +437,1 @@\n-      record_for_igvn(n->unique_out());\n+      worklist->push(n->unique_out());\n@@ -441,1 +441,3 @@\n-  remove_useless_nodes(_macro_nodes,        useful); \/\/ remove useless macro and predicate opaq nodes\n+  remove_useless_nodes(_macro_nodes,        useful); \/\/ remove useless macro nodes\n+  remove_useless_nodes(_predicate_opaqs,    useful); \/\/ remove useless predicate opaque nodes\n+  remove_useless_nodes(_skeleton_predicate_opaqs, useful);\n@@ -445,0 +447,5 @@\n+#ifdef ASSERT\n+  if (_modified_nodes != NULL) {\n+    _modified_nodes->remove_useless_nodes(useful.member_set());\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-  void              remove_useless_nodes (Unique_Node_List &useful);\n+  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -509,0 +509,12 @@\n+    if (outcnt() == 0) {\n+      return NULL;\n+    }\n+  }\n+  Node* oop = get_oop();\n+  if (oop->isa_InlineTypePtr()) {\n+    InlineTypePtrNode* vtptr = oop->as_InlineTypePtr();\n+    set_oop(vtptr->get_oop());\n+    for (uint i = Values; i < vtptr->req(); ++i) {\n+      set_req(i, vtptr->in(i));\n+    }\n+    return this;\n@@ -839,8 +851,0 @@\n-  } else if (oop->isa_InlineTypePtr()) {\n-    \/\/ Can happen with late inlining\n-    InlineTypePtrNode* vtptr = oop->as_InlineTypePtr();\n-    set_oop(vtptr->get_oop());\n-    for (uint i = Oop+1; i < vtptr->req(); ++i) {\n-      set_req(i, vtptr->in(i));\n-    }\n-    return this;\n@@ -875,1 +879,1 @@\n-            replace_allocation(igvn, res, get_oop());\n+            replace_allocation(igvn, res, oop);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -428,1 +428,1 @@\n-  C->remove_useless_nodes(_useful);\n+  C->disconnect_useless_nodes(_useful, worklist);\n@@ -1759,1 +1759,1 @@\n-PhaseCCP::PhaseCCP( PhaseIterGVN *igvn ) : PhaseIterGVN(igvn) {\n+PhaseCCP::PhaseCCP(PhaseIterGVN* igvn) : PhaseIterGVN(igvn), _trstack(C->live_nodes() >> 1) {\n@@ -1813,0 +1813,5 @@\n+    if (n->is_SafePoint()) {\n+      \/\/ Make sure safepoints are processed by PhaseCCP::transform even if they are\n+      \/\/ not reachable from the bottom. Otherwise, infinite loops would be removed.\n+      _trstack.push(n);\n+    }\n@@ -1932,0 +1937,1 @@\n+  _useful.push(new_node); \/\/ Keep track of nodes that are reachable from the bottom\n@@ -1933,6 +1939,3 @@\n-  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n-  GrowableArray <Node *> trstack(C->live_nodes() >> 1);\n-\n-  trstack.push(new_node);           \/\/ Process children of cloned node\n-  while ( trstack.is_nonempty() ) {\n-    Node *clone = trstack.pop();\n+  _trstack.push(new_node);           \/\/ Process children of cloned node\n+  while (_trstack.is_nonempty()) {\n+    Node* clone = _trstack.pop();\n@@ -1947,1 +1950,2 @@\n-          trstack.push(new_input);\n+          _useful.push(new_input);\n+          _trstack.push(new_input);\n@@ -1953,0 +1957,17 @@\n+\n+  \/\/ The above transformation might lead to subgraphs becoming unreachable from the\n+  \/\/ bottom while still being reachable from the top. As a result, nodes in that\n+  \/\/ subgraph are not transformed and their bottom types are not updated, leading to\n+  \/\/ an inconsistency between bottom_type() and type(). In rare cases, LoadNodes in\n+  \/\/ such a subgraph, kept alive by InlineTypePtrNodes, might be re-enqueued for IGVN\n+  \/\/ indefinitely by MemNode::Ideal_common because their address type is inconsistent.\n+  \/\/ Therefore, we aggressively remove all useless nodes here even before\n+  \/\/ PhaseIdealLoop::build_loop_late gets a chance to remove them anyway.\n+  if (C->cached_top_node()) {\n+    _useful.push(C->cached_top_node());\n+  }\n+  C->update_dead_node_list(_useful);\n+  remove_useless_nodes(_useful.member_set());\n+  _worklist.remove_useless_nodes(_useful.member_set());\n+  C->disconnect_useless_nodes(_useful, &_worklist);\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -570,0 +570,3 @@\n+  GrowableArray<Node*> _trstack; \/\/ Stack for transform operation\n+  Unique_Node_List _useful;      \/\/ Nodes reachable from the bottom\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-        int arraySize = Math.abs(rI) % 10;;\n+        int arraySize = Math.abs(rI) % 10;\n@@ -336,1 +336,1 @@\n-        int arraySize = Math.abs(rI) % 10;;\n+        int arraySize = Math.abs(rI) % 10;\n@@ -384,1 +384,1 @@\n-        int arraySize = Math.abs(rI) % 10;;\n+        int arraySize = Math.abs(rI) % 10;\n@@ -405,1 +405,1 @@\n-        int arraySize = Math.abs(rI) % 10;;\n+        int arraySize = Math.abs(rI) % 10;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,8 @@\n+class MyValue4Wrapper {\n+    public MyValue4.ref val;\n+\n+    public MyValue4Wrapper(MyValue4 val) {\n+        this.val = val;\n+    }\n+}\n+\n@@ -222,0 +230,24 @@\n+    void test15() {\n+        MyValue4 val = new MyValue4();\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                MyValue4[] array = new MyValue4[1];\n+                for (int k = 0; k < 10; ++k) {\n+                    array[0] = val;\n+                    val = array[0];\n+                }\n+            }\n+        }\n+    }\n+\n+    void test16() {\n+        MyValue4 val = MyValue4.default;\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                val = (new MyValue4Wrapper(val)).val;\n+                for (int k = 0; k < 10; ++k) {\n+                }\n+            }\n+        }\n+    }\n+\n@@ -246,0 +278,2 @@\n+            t.test15();\n+            t.test16();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGenerated.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"}]}