{"files":[{"patch":"@@ -826,0 +826,1 @@\n+          vt->set_is_buffered();\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2179,2 +2179,1 @@\n-  if (can_reshape && EliminateLocks && !is_non_esc_obj() &&\n-      !obj_type->isa_inlinetype() && !obj_type->is_inlinetypeptr()) {\n+  if (can_reshape && EliminateLocks && !is_non_esc_obj() && !obj_type->is_inlinetypeptr()) {\n@@ -2377,2 +2376,1 @@\n-  if (can_reshape && EliminateLocks && !is_non_esc_obj() &&\n-      !obj_type->isa_inlinetype() && !obj_type->is_inlinetypeptr()) {\n+  if (can_reshape && EliminateLocks && !is_non_esc_obj() && !obj_type->is_inlinetypeptr()) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2010,1 +2010,1 @@\n-    \/\/ Remove inline type nodes\n+    \/\/ Remove inline type nodes by replacing them with their oop input\n@@ -2015,3 +2015,5 @@\n-      } else if (vt->is_InlineType()) {\n-        igvn.replace_node(vt, vt->get_oop());\n-      } else {\n+        continue;\n+      }\n+      for (DUIterator i = vt->outs(); vt->has_out(i); i++) {\n+        DEBUG_ONLY(bool must_be_buffered = false);\n+        Node* u = vt->out(i);\n@@ -2021,18 +2023,16 @@\n-        for (DUIterator i = vt->outs(); vt->has_out(i); i++) {\n-          if (vt->out(i)->is_Blackhole()) {\n-            BlackholeNode* bh = vt->out(i)->as_Blackhole();\n-\n-            \/\/ Unlink the old input\n-            int idx = bh->find_edge(vt);\n-            assert(idx != -1, \"The edge should be there\");\n-            bh->del_req(idx);\n-            --i;\n-\n-            if (vt->is_allocated(&igvn)) {\n-              \/\/ Already has the allocated instance, blackhole that\n-              bh->add_req(vt->get_oop());\n-            } else {\n-              \/\/ Not allocated yet, blackhole the components\n-              for (uint c = 0; c < vt->field_count(); c++) {\n-                bh->add_req(vt->field_value(c));\n-              }\n+        if (u->is_Blackhole()) {\n+          BlackholeNode* bh = u->as_Blackhole();\n+\n+          \/\/ Unlink the old input\n+          int idx = bh->find_edge(vt);\n+          assert(idx != -1, \"The edge should be there\");\n+          bh->del_req(idx);\n+          --i;\n+\n+          if (vt->is_allocated(&igvn)) {\n+            \/\/ Already has the allocated instance, blackhole that\n+            bh->add_req(vt->get_oop());\n+          } else {\n+            \/\/ Not allocated yet, blackhole the components\n+            for (uint c = 0; c < vt->field_count(); c++) {\n+              bh->add_req(vt->field_value(c));\n@@ -2040,3 +2040,0 @@\n-\n-            \/\/ Node modified, record for IGVN\n-            igvn.record_for_igvn(bh);\n@@ -2044,1 +2041,0 @@\n-        }\n@@ -2046,0 +2042,3 @@\n+          \/\/ Node modified, record for IGVN\n+          igvn.record_for_igvn(bh);\n+        }\n@@ -2047,2 +2046,15 @@\n-        for (DUIterator_Fast imax, i = vt->fast_outs(imax); i < imax; i++) {\n-          assert(vt->fast_out(i)->is_InlineType(), \"Unexpected inline type user\");\n+        \/\/ Verify that inline type is buffered when replacing by oop\n+        else if (u->is_InlineType()) {\n+          InlineTypeNode* vt2 = u->as_InlineType();\n+          for (uint i = 0; i < vt2->field_count(); ++i) {\n+            if (vt2->field_value(i) == vt && !vt2->field_is_flattened(i)) {\n+              \/\/ Use in non-flat field\n+              must_be_buffered = true;\n+            }\n+          }\n+        } else if (u->Opcode() != Op_Return || !tf()->returns_inline_type_as_fields()) {\n+          must_be_buffered = true;\n+        }\n+        if (must_be_buffered && !vt->is_allocated(&igvn)) {\n+          vt->dump(-3);\n+          assert(false, \"Should have been buffered\");\n@@ -2051,1 +2063,0 @@\n-        igvn.replace_node(vt, igvn.C->top());\n@@ -2053,0 +2064,1 @@\n+      igvn.replace_node(vt, vt->get_oop());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":41,"deletions":29,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2090,2 +2090,1 @@\n-          if (not_global_escape(alock->obj_node()) &&\n-              !obj_type->isa_inlinetype() && !obj_type->is_inlinetypeptr()) {\n+          if (not_global_escape(alock->obj_node()) && !obj_type->is_inlinetypeptr()) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2943,2 +2943,3 @@\n-  if (sub_t->isa_inlinetype()) {\n-    obj_or_subklass = makecon(TypeKlassPtr::make(sub_t->inline_klass()));\n+  if (sub_t->make_oopptr() != NULL && sub_t->make_oopptr()->is_inlinetypeptr()) {\n+    sub_t = TypeKlassPtr::make(sub_t->inline_klass());\n+    obj_or_subklass = makecon(sub_t);\n@@ -2952,1 +2953,1 @@\n-    if (!sub_t->isa_klassptr() && !sub_t->isa_inlinetype()) {\n+    if (!sub_t->isa_klassptr()) {\n@@ -2973,1 +2974,1 @@\n-  if (rec_t->isa_inlinetype()) {\n+  if (rec_t->is_inlinetypeptr()) {\n@@ -3429,0 +3430,7 @@\n+  if (obj->is_InlineType()) {\n+    \/\/ Re-execute if buffering during triggers deoptimization\n+    PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n+    obj = obj->as_InlineType()->buffer(this, safe_for_replace);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1129,1 +1129,2 @@\n-  const Type* toop = phase->type(get_oop());\n+  Node* oop = get_oop();\n+  const Type* toop = phase->type(oop);\n@@ -1131,1 +1132,1 @@\n-  if (toop->is_zero_type() && _type->isa_oopptr()->is_known_instance()) {\n+  if (oop->is_Con() && toop->is_zero_type() && _type->isa_oopptr()->is_known_instance()) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  void  set_is_buffered() { _is_buffered = true; }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3942,0 +3942,2 @@\n+  Node* io = i_o();\n+  Node* mem = merged_memory();\n@@ -3975,0 +3977,3 @@\n+    \/\/ Set IO and memory because gen_checkcast may override them when buffering inline types\n+    set_i_o(io);\n+    set_all_memory(mem);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-  if (obj_type->isa_inlinetype() || obj_type->is_inlinetypeptr()) {\n+  if (obj_type->is_inlinetypeptr()) {\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,5 +159,0 @@\n-  if (type->isa_inlinetype() != NULL) {\n-    \/\/ The interpreter passes inline types as oops\n-    type = TypeOopPtr::make_from_klass(type->inline_klass());\n-    type = type->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n-  }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1079,0 +1079,2 @@\n+    \/\/ TODO 8239003 Re-enable\n+    \/*\n@@ -1100,0 +1102,1 @@\n+    *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -51,1 +52,0 @@\n- * @build test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -2214,1 +2214,1 @@\n-    private final long test80Result = test80();\n+    private long test80Result = 0;\n@@ -2218,0 +2218,3 @@\n+        if (test80Result == 0) {\n+            test80Result = test80();\n+        }\n@@ -2246,1 +2249,1 @@\n-    private final long test81Result = test81();\n+    private long test81Result = 0;\n@@ -2250,1 +2253,4 @@\n-        Asserts.assertEquals(test82(), test82Result);\n+        if (test81Result == 0) {\n+            test81Result = test81();\n+        }\n+        Asserts.assertEquals(test81(), test81Result);\n@@ -2280,1 +2286,1 @@\n-    private final long test82Result = test82();\n+    private long test82Result = 0;\n@@ -2284,0 +2290,3 @@\n+        if (test82Result == 0) {\n+            test82Result = test81();\n+        }\n@@ -2335,1 +2344,1 @@\n-    private final long test84Result = test84();\n+    private long test84Result = 0;\n@@ -2339,0 +2348,3 @@\n+        if (test84Result == 0) {\n+            test84Result = test84();\n+        }\n@@ -2367,1 +2379,1 @@\n-    private final long test85Result = test85();\n+    private long test85Result = 0;\n@@ -2371,0 +2383,3 @@\n+        if (test85Result == 0) {\n+            test85Result = test85();\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}