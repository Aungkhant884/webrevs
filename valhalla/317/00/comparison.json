{"files":[{"patch":"@@ -2010,5 +2010,8 @@\n-        Node* clone = new StoreCMNode(m->in(MemNode::Control), m->in(MemNode::Memory), m->in(MemNode::Address),\n-                                      m->adr_type(), m->in(MemNode::ValueIn), m->in(MemNode::OopStore),\n-                                      get_alias_index(adr_type));\n-        igvn.register_new_node_with_optimizer(clone);\n-        igvn.replace_node(m, clone);\n+        if (adr_type != TypeAryPtr::INLINES) {\n+          \/\/ store was optimized out and we lost track of the adr_type\n+          Node* clone = new StoreCMNode(m->in(MemNode::Control), m->in(MemNode::Memory), m->in(MemNode::Address),\n+                                        m->adr_type(), m->in(MemNode::ValueIn), m->in(MemNode::OopStore),\n+                                        get_alias_index(adr_type));\n+          igvn.register_new_node_with_optimizer(clone);\n+          igvn.replace_node(m, clone);\n+        }\n@@ -2118,1 +2121,1 @@\n-                  if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat()) {\n+                  if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat() || j == (uint)index) {\n@@ -2148,1 +2151,1 @@\n-                if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat()) {\n+                if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat() || j == (uint)index) {\n@@ -2201,0 +2204,16 @@\n+#ifdef ASSERT\n+  if (!_flattened_accesses_share_alias) {\n+    wq.clear();\n+    wq.push(root());\n+    for (uint i = 0; i < wq.size(); i++) {\n+      Node* n = wq.at(i);\n+      assert(n->adr_type() != TypeAryPtr::INLINES, \"should have been removed from the graph\");\n+      for (uint j = 0; j < n->req(); j++) {\n+        Node* m = n->in(j);\n+        if (m != NULL) {\n+          wq.push(m);\n+        }\n+      }\n+    }\n+  }\n+#endif\n@@ -3358,1 +3377,16 @@\n-      n->add_prec(prec);\n+      if (prec->is_MergeMem()) {\n+        MergeMemNode* mm = prec->as_MergeMem();\n+        Node* base = mm->base_memory();\n+        for (int i = AliasIdxRaw + 1; i < num_alias_types(); i++) {\n+          const Type* adr_type = get_adr_type(i);\n+          if (adr_type->isa_aryptr() && adr_type->is_aryptr()->is_flat()) {\n+            Node* m = mm->memory_at(i);\n+            n->add_prec(m);\n+          }\n+        }\n+        if (mm->outcnt() == 0) {\n+          mm->disconnect_inputs(this);\n+        }\n+      } else {\n+        n->add_prec(prec);\n+      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":42,"deletions":8,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-      for (int i = node->req()-1; i >= 0; --i) {\n+      for (int i = node->len()-1; i >= 0; --i) {\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2143,1 +2143,1 @@\n-      for (int i = n->req() - 1; i >= 0; --i) { \/\/ For my children\n+      for (int i = n->len() - 1; i >= 0; --i) { \/\/ For my children\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3013,3 +3013,7 @@\n-    Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n-    set_req(MemNode::OopStore, mem);\n-    return this;\n+    if (oop_alias_idx() != phase->C->get_alias_index(TypeAryPtr::INLINES) ||\n+        phase->C->flattened_accesses_share_alias()) {\n+      \/\/ The alias that was recorded is no longer accurate enough.\n+      Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n+      set_req(MemNode::OopStore, mem);\n+      return this;\n+    }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8260363\n+ * @summary [lworld] C2 compilation fails with assert(n->Opcode() != Op_Phi) failed: cannot match\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation TestFlatArrayAliasesCardMark\n+ *\n+ *\/\n+\n+\n+inline class Test0 {\n+    int x = 42;\n+    short[] array = new short[7];\n+}\n+\n+public class TestFlatArrayAliasesCardMark {\n+    int f = 1;\n+\n+    public void method1(Test0[] array) {\n+        for (int i = 0; i < 100; ++i) {\n+            array[0] = array[0];\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    f = 42;\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFlatArrayAliasesCardMark t = new TestFlatArrayAliasesCardMark();\n+        Test0[] array = new Test0[] {new Test0()};\n+        for (int l1 = 0; l1 < 10000; ++l1) {\n+            t.method1(array);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatArrayAliasesCardMark.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}