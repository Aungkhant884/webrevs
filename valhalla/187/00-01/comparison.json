{"files":[{"patch":"@@ -1598,14 +1598,2 @@\n-void LIRGenerator::access_sub_element(LIRItem& array, LIRItem& index, LIR_Opr& result, ciField* field, int sub_offset) {\n-  assert(field != NULL, \"Need a subelement type specified\");\n-  \/\/ Find the starting address of the source (inside the array)\n-  ciType* array_type = array.value()->declared_type();\n-  ciFlatArrayKlass* flat_array_klass = array_type->as_flat_array_klass();\n-  assert(flat_array_klass->is_loaded(), \"must be\");\n-\n-  ciInlineKlass* elem_klass = NULL;\n-  int array_header_size = flat_array_klass->array_header_in_bytes();\n-  int shift = flat_array_klass->log2_element_size();\n-\n-  BasicType subelt_type = field->type()->basic_type();\n-\n-  #ifndef _LP64\n+LIR_Opr LIRGenerator::get_index_in_register(LIRItem& index, int shift) {\n+#ifndef _LP64\n@@ -1622,0 +1610,1 @@\n+  return index_op;\n@@ -1632,0 +1621,1 @@\n+  return index_op;\n@@ -1633,0 +1623,8 @@\n+}\n+\n+void LIRGenerator::access_sub_element(LIRItem& array, LIRItem& index, LIR_Opr& result, ciField* field, int sub_offset) {\n+  assert(field != NULL, \"Need a subelement type specified\");\n+  \/\/ Find the starting address of the source (inside the array)\n+  ciType* array_type = array.value()->declared_type();\n+  ciFlatArrayKlass* flat_array_klass = array_type->as_flat_array_klass();\n+  assert(flat_array_klass->is_loaded(), \"must be\");\n@@ -1634,0 +1632,3 @@\n+  int array_header_size = flat_array_klass->array_header_in_bytes();\n+  BasicType subelt_type = field->type()->basic_type();\n+  LIR_Opr index_op = get_index_in_register(index, flat_array_klass->log2_element_size());\n@@ -1677,25 +1678,1 @@\n-  int shift = flat_array_klass->log2_element_size();\n-\n-#ifndef _LP64\n-  LIR_Opr index_op = new_register(T_INT);\n-  \/\/ FIXME -- on 32-bit, the shift below can overflow, so we need to check that\n-  \/\/ the top (shift+1) bits of index_op must be zero, or\n-  \/\/ else throw ArrayIndexOutOfBoundsException\n-  if (index.result()->is_constant()) {\n-    jint const_index = index.result()->as_jint();\n-    __ move(LIR_OprFact::intConst(const_index << shift), index_op);\n-  } else {\n-    __ shift_left(index_op, shift, index.result());\n-  }\n-#else\n-  LIR_Opr index_op = new_register(T_LONG);\n-  if (index.result()->is_constant()) {\n-    jint const_index = index.result()->as_jint();\n-    __ move(LIR_OprFact::longConst(const_index << shift), index_op);\n-  } else {\n-    __ convert(Bytecodes::_i2l, index.result(), index_op);\n-    \/\/ Need to shift manually, as LIR_Address can scale only up to 3.\n-    __ shift_left(index_op, shift, index_op);\n-  }\n-#endif\n-\n+  LIR_Opr index_op = get_index_in_register(index, flat_array_klass->log2_element_size());\n@@ -1710,1 +1687,1 @@\n-    int elm_offset = obj_offset - elem_klass->first_field_offset()  + sub_offset; \/\/ object header is not stored in array.\n+    int elm_offset = obj_offset - elem_klass->first_field_offset() + sub_offset; \/\/ object header is not stored in array.\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":17,"deletions":40,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+  LIR_Opr get_index_in_register(LIRItem& index, int shift);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}