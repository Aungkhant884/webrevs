{"files":[{"patch":"@@ -1033,5 +1033,18 @@\n-    NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before, false);\n-    _memory->new_instance(new_instance);\n-    apush(append_split(new_instance));\n-    load_indexed = new LoadIndexed(array, index, length, type, state_before);\n-    load_indexed->set_vt(new_instance);\n+\n+    ciBytecodeStream s(method());\n+    s.force_bci(bci());\n+    s.next();\n+    if (s.cur_bc() == Bytecodes::_getfield) {\n+      \/\/ potentially optimizable array access, storing information for delayed decision\n+      LoadIndexed* li = new LoadIndexed(array, index, length, type, state_before);\n+      DelayedLoadIndexed* dli = new DelayedLoadIndexed(li, state_before);\n+      li->set_delayed(dli);\n+      set_pending_load_indexed(dli);\n+      return; \/\/ Nothing else to do for now\n+    } else {\n+      NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(elem_klass, state_before, false);\n+      _memory->new_instance(new_instance);\n+      apush(append_split(new_instance));\n+      load_indexed = new LoadIndexed(array, index, length, type, state_before);\n+      load_indexed->set_vt(new_instance);\n+    }\n@@ -1041,1 +1054,1 @@\n-  if (profile_array_accesses() && is_reference_type(type)) {\n+  if (profile_array_accesses() && is_reference_type(type) && !array->is_loaded_flattened_array()) {\n@@ -1840,1 +1853,1 @@\n-      if (!has_delayed_flattened_field_access()) {\n+      if (!has_pending_field_access() && !has_pending_load_indexed()) {\n@@ -1874,5 +1887,3 @@\n-          if (!has_delayed_flattened_field_access()) {\n-            load = new LoadField(obj, offset, field, false, state_before, needs_patching);\n-          } else {\n-            load = new LoadField(_delayed_flattened_field_access->obj(),\n-                                 _delayed_flattened_field_access->offset() + offset - field->holder()->as_inline_klass()->first_field_offset(),\n+          if (has_pending_field_access()) {\n+            load = new LoadField(pending_field_access()->obj(),\n+                                 pending_field_access()->offset() + offset - field->holder()->as_inline_klass()->first_field_offset(),\n@@ -1880,1 +1891,10 @@\n-            _delayed_flattened_field_access = NULL;\n+            set_pending_field_access(NULL);\n+          } else if (has_pending_load_indexed()) {\n+            pending_load_indexed()->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());\n+            LoadIndexed* li = pending_load_indexed()->load_instr();\n+            li->set_type(type);\n+            push(type, append(li));\n+            set_pending_load_indexed(NULL);\n+            break;\n+          } else {\n+            load = new LoadField(obj, offset, field, false, state_before, needs_patching);\n@@ -1911,4 +1931,4 @@\n-            if (!has_delayed_flattened_field_access()) {\n-              null_check(obj);\n-              DelayedFlattenedFieldAccess* dffa = new DelayedFlattenedFieldAccess(obj, field, field->offset());\n-              _delayed_flattened_field_access = dffa;\n+            if (has_pending_load_indexed()) {\n+              pending_load_indexed()->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());\n+            } else if (has_pending_field_access()) {\n+              pending_field_access()->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());\n@@ -1916,1 +1936,3 @@\n-              _delayed_flattened_field_access->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());\n+              null_check(obj);\n+              DelayedFieldAccess* dfa = new DelayedFieldAccess(obj, field, field->offset());\n+              set_pending_field_access(dfa);\n@@ -1924,6 +1946,9 @@\n-            NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before, false);\n-            _memory->new_instance(new_instance);\n-            apush(append_split(new_instance));\n-            if (!has_delayed_flattened_field_access()) {\n-              copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(),\n-                          state_before, needs_patching);\n+            if (has_pending_load_indexed()) {\n+              pending_load_indexed()->update(field, offset - field->holder()->as_inline_klass()->first_field_offset());\n+              NewInlineTypeInstance* vt = new NewInlineTypeInstance(field->type()->as_inline_klass(),\n+                                                                    pending_load_indexed()->state_before(), false);\n+              _memory->new_instance(vt);\n+              pending_load_indexed()->load_instr()->set_vt(vt);\n+              apush(append_split(vt));\n+              append(pending_load_indexed()->load_instr());\n+              set_pending_load_indexed(NULL);\n@@ -1931,5 +1956,13 @@\n-              copy_inline_content(inline_klass, _delayed_flattened_field_access->obj(),\n-                                  _delayed_flattened_field_access->offset() + field->offset() - field->holder()->as_inline_klass()->first_field_offset(),\n-                                  new_instance, inline_klass->first_field_offset(),\n-                                  state_before, needs_patching);\n-              _delayed_flattened_field_access = NULL;\n+              NewInlineTypeInstance* new_instance = new NewInlineTypeInstance(inline_klass, state_before, false);\n+              _memory->new_instance(new_instance);\n+              apush(append_split(new_instance));\n+              if (has_pending_field_access()) {\n+                copy_inline_content(inline_klass, pending_field_access()->obj(),\n+                                    pending_field_access()->offset() + field->offset() - field->holder()->as_inline_klass()->first_field_offset(),\n+                                    new_instance, inline_klass->first_field_offset(),\n+                                    state_before, needs_patching);\n+                set_pending_field_access(NULL);\n+              } else {\n+                copy_inline_content(inline_klass, obj, field->offset(), new_instance, inline_klass->first_field_offset(),\n+                            state_before, needs_patching);\n+              }\n@@ -2716,1 +2749,3 @@\n-    assert(cur_bci == SynchronizationEntryBCI || cur_bci == cur_scope_data->stream()->cur_bci(), \"invalid bci\");\n+    assert(cur_bci == SynchronizationEntryBCI || cur_bci == cur_scope_data->stream()->cur_bci()\n+           || has_pending_field_access() || has_pending_load_indexed(), \"invalid bci\");\n+\n@@ -3524,1 +3559,2 @@\n-  , _delayed_flattened_field_access(NULL)\n+  , _pending_field_access(NULL)\n+  , _pending_load_indexed(NULL)\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":67,"deletions":31,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-class DelayedFlattenedFieldAccess : public CompilationResourceObj {\n+class DelayedFieldAccess : public CompilationResourceObj {\n@@ -44,1 +44,1 @@\n-  DelayedFlattenedFieldAccess(Value obj, ciField* field, int offset)\n+  DelayedFieldAccess(Value obj, ciField* field, int offset)\n@@ -214,3 +214,3 @@\n-  DelayedFlattenedFieldAccess* _delayed_flattened_field_access;\n-  bool              has_delayed_flattened_field_access() { return _delayed_flattened_field_access != NULL; }\n-\n+  \/\/ support for optimization of accesses to flattened fields and arrays\n+  DelayedFieldAccess* _pending_field_access;\n+  DelayedLoadIndexed* _pending_load_indexed;\n@@ -235,0 +235,6 @@\n+  bool              has_pending_field_access()   { return _pending_field_access != NULL; }\n+  DelayedFieldAccess* pending_field_access()     { return _pending_field_access; }\n+  void              set_pending_field_access(DelayedFieldAccess* delayed) { _pending_field_access = delayed; }\n+  bool              has_pending_load_indexed()   { return _pending_load_indexed != NULL; }\n+  DelayedLoadIndexed* pending_load_indexed()     { return _pending_load_indexed; }\n+  void              set_pending_load_indexed(DelayedLoadIndexed* delayed) { _pending_load_indexed = delayed; }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -328,0 +328,1 @@\n+  friend class GraphBuilder;\n@@ -994,0 +995,1 @@\n+class DelayedLoadIndexed;\n@@ -999,0 +1001,1 @@\n+  DelayedLoadIndexed* _delayed;\n@@ -1004,1 +1007,1 @@\n-  , _explicit_null_check(NULL), _vt(NULL) {}\n+  , _explicit_null_check(NULL), _vt(NULL), _delayed(NULL) {}\n@@ -1019,0 +1022,3 @@\n+  DelayedLoadIndexed* delayed() { return _delayed; }\n+  void set_delayed(DelayedLoadIndexed* delayed) { _delayed = delayed; }\n+\n@@ -1023,0 +1029,23 @@\n+class DelayedLoadIndexed : public CompilationResourceObj {\n+private:\n+  LoadIndexed* _load_instr;\n+  ValueStack* _state_before;\n+  ciField* _field;\n+  int _offset;\n+ public:\n+  DelayedLoadIndexed(LoadIndexed* load, ValueStack* state_before)\n+  : _load_instr(load)\n+  , _state_before(state_before)\n+  , _field(NULL)\n+  , _offset(0) { }\n+\n+  void update(ciField* field, int offset) {\n+    _field = field;\n+    _offset += offset;\n+  }\n+\n+  LoadIndexed* load_instr() { return _load_instr; }\n+  ValueStack* state_before() { return _state_before; }\n+  ciField* field() { return _field; }\n+  int offset() { return _offset; }\n+};\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -400,1 +400,6 @@\n-  output()->print(\" (%c)\", type2char(x->elt_type()));\n+  if (x->delayed() != NULL) {\n+    output()->print(\" +%d\", x->delayed()->offset());\n+    output()->print(\" (%c)\", type2char(x->delayed()->field()->type()->basic_type()));\n+  } else {\n+    output()->print(\" (%c)\", type2char(x->elt_type()));\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1598,2 +1598,1 @@\n-void LIRGenerator::access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item) {\n-  \/\/ Find the starting address of the source (inside the array)\n+LIR_Opr LIRGenerator::get_and_load_element_address(LIRItem& array, LIRItem& index) {\n@@ -1604,1 +1603,0 @@\n-  ciInlineKlass* elem_klass = flat_array_klass->element_klass()->as_inline_klass();\n@@ -1634,0 +1632,17 @@\n+  return elm_op;\n+}\n+\n+void LIRGenerator::access_sub_element(LIRItem& array, LIRItem& index, LIR_Opr& result, ciField* field, int sub_offset) {\n+  assert(field != NULL, \"Need a subelement type specified\");\n+\n+\/\/ Find the starting address of the source (inside the array)\n+  LIR_Opr elm_op = get_and_load_element_address(array, index);\n+\n+  BasicType subelt_type = field->type()->basic_type();\n+  TempResolvedAddress* elm_resolved_addr = new TempResolvedAddress(as_ValueType(subelt_type), elm_op);\n+  LIRItem elm_item(elm_resolved_addr, this);\n+\n+  DecoratorSet decorators = IN_HEAP;\n+  access_load_at(decorators, subelt_type,\n+                     elm_item, LIR_OprFact::intConst(sub_offset), result,\n+                     NULL, NULL);\n@@ -1635,0 +1650,29 @@\n+  Constant* default_value = NULL;\n+  if (field->signature()->is_Q_signature()) {\n+    assert(field->type()->as_inline_klass()->is_loaded(), \"Must be\");\n+    default_value = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n+  }\n+  if (default_value != NULL) {\n+    LabelObj* L_end = new LabelObj();\n+    __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));\n+    __ branch(lir_cond_notEqual, L_end->label());\n+    set_in_conditional_code(true);\n+    __ move(load_constant(default_value), result);\n+    __ branch_destination(L_end->label());\n+    set_in_conditional_code(false);\n+  }\n+}\n+\n+void LIRGenerator::access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item,\n+                                          ciField* field, int sub_offset) {\n+  assert(sub_offset == 0 || field != NULL, \"Sanity check\");\n+\n+\/\/ Find the starting address of the source (inside the array)\n+  LIR_Opr elm_op = get_and_load_element_address(array, index);\n+\n+  ciInlineKlass* elem_klass = NULL;\n+  if (field != NULL) {\n+    elem_klass = field->type()->as_inline_klass();\n+  } else {\n+    elem_klass = array.value()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass();\n+  }\n@@ -1639,1 +1683,1 @@\n-    int elm_offset = obj_offset - elem_klass->first_field_offset(); \/\/ object header is not stored in array.\n+    int elm_offset = obj_offset - elem_klass->first_field_offset() + sub_offset; \/\/ object header is not stored in array.\n@@ -2173,1 +2217,1 @@\n-    LIR_Opr obj = x->vt()->operand();\n+    \/\/ LIR_Opr obj = x->vt()->operand();\n@@ -2176,1 +2220,3 @@\n-    access_flattened_array(true, array, index, obj_item);\n+    access_flattened_array(true, array, index, obj_item,\n+                           x->delayed() == NULL ? 0 : x->delayed()->field(),\n+                           x->delayed() == NULL ? 0 : x->delayed()->offset());\n@@ -2180,0 +2226,1 @@\n+      fatal(\"Loaded flattened array should not be profiled\");\n@@ -2183,0 +2230,7 @@\n+  } else if (x->delayed() != NULL) {\n+    assert(x->array()->is_loaded_flattened_array(), \"must be\");\n+    LIR_Opr result = rlock_result(x, x->delayed()->field()->type()->basic_type());\n+    access_sub_element(array, index, result,\n+                       x->delayed() == NULL ? 0 : x->delayed()->field(),\n+                       x->delayed() == NULL ? 0 : x->delayed()->offset());\n+    assert(!x->should_profile(), \"Loaded flattened array should not be profiled\");\n@@ -2192,0 +2246,1 @@\n+      assert(x->delayed() == NULL, \"Delayed LoadIndexed only apply to loaded_flattened_arrays\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":61,"deletions":6,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -272,1 +272,3 @@\n-  void access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item);\n+  void access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item, ciField* field = NULL, int offset = 0);\n+  void access_sub_element(LIRItem& array, LIRItem& index, LIR_Opr& result, ciField* field, int sub_offset);\n+  LIR_Opr get_and_load_element_address(LIRItem& array, LIRItem& index);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,155 @@\n+\n+\n+    \/\/ Tests below (3 to 8) check the behavior of the C1 optimization to access\n+    \/\/ sub-elements of a flattened array without copying the element first\n+\n+    \/\/ Test access to a null array\n+    @Test(compLevel=C1)\n+    public int test3(MyValue2[] array, int index) {\n+        return array[index].x;\n+    }\n+\n+    @DontCompile\n+    public void test3_verifier(boolean warmup) {\n+        NullPointerException npe = null;\n+        try {\n+            test3(null, 0);\n+        } catch(NullPointerException e) {\n+            npe = e;\n+        }\n+        Asserts.assertNE(npe, null);\n+    }\n+\n+    \/\/ Test out of bound accesses\n+    @Test(compLevel=C1)\n+    public int test4(MyValue2[] array, int index) {\n+        return array[index].x;\n+    }\n+\n+    @DontCompile\n+    public void test4_verifier(boolean warmup) {\n+        MyValue2[] array = new MyValue2[2];\n+        ArrayIndexOutOfBoundsException aioob = null;\n+        try {\n+            test3(array, -1);\n+        } catch(ArrayIndexOutOfBoundsException e) {\n+            aioob = e;\n+        }\n+        Asserts.assertNE(aioob, null);\n+        aioob = null;\n+        try {\n+            test3(array, 2);\n+        } catch(ArrayIndexOutOfBoundsException e) {\n+            aioob = e;\n+        }\n+        Asserts.assertNE(aioob, null);\n+    }\n+\n+    \/\/ Test 1st level sub-element access to primitive field\n+    @Test(compLevel=C1)\n+    public int test5(MyValue2[] array, int index) {\n+        return array[index].x;\n+    }\n+\n+    @DontCompile\n+    public void test5_verifier(boolean warmup) {\n+        MyValue2[] array = new MyValue2[2];\n+        MyValue2 v = new MyValue2(1,(byte)2, new MyValue2Inline(5.0d, 345L));\n+        array[1] = v;\n+        int x = test5(array, 1);\n+        Asserts.assertEQ(x, 1);\n+    }\n+\n+    \/\/ Test 1st level sub-element access to flattened field\n+    @Test(compLevel=C1)\n+    public MyValue2Inline test6(MyValue2[] array, int index) {\n+        return array[index].v;\n+    }\n+\n+    @DontCompile\n+    public void test6_verifier(boolean warmup) {\n+        MyValue2[] array = new MyValue2[2];\n+        MyValue2Inline vi = new MyValue2Inline(3.5d, 678L);\n+        MyValue2 v = new MyValue2(1,(byte)2, vi);\n+        array[0] = v;\n+        MyValue2Inline vi2 = test6(array, 0);\n+        Asserts.assertEQ(vi, vi2);\n+    }\n+\n+    \/\/ Test 1st level sub-element access to non-flattened field\n+    static inline class Big {\n+        long l0,l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18,l19 ;\n+\n+        Big(long n) {\n+            l0 = n++; l1 = n++; l2 = n++; l3 = n++; l4 = n++; l5 = n++; l6 = n++; l7 = n++; l8 = n++;\n+            l9 = n++; l10 = n++; l11 = n++; l12 = n++; l13 = n++; l14 = n++; l15 = n++; l16= n++;\n+            l17 = n++; l18 = n++; l19 = n++;\n+        }\n+\n+        void check(long n, int i) {\n+            Asserts.assertEQ(l0, n); n += i;\n+            Asserts.assertEQ(l1, n); n += i;\n+            Asserts.assertEQ(l2, n); n += i;\n+            Asserts.assertEQ(l3, n); n += i;\n+            Asserts.assertEQ(l4, n); n += i;\n+            Asserts.assertEQ(l5, n); n += i;\n+            Asserts.assertEQ(l6, n); n += i;\n+            Asserts.assertEQ(l7, n); n += i;\n+            Asserts.assertEQ(l8, n); n += i;\n+            Asserts.assertEQ(l9, n); n += i;\n+            Asserts.assertEQ(l10, n); n += i;\n+            Asserts.assertEQ(l11, n); n += i;\n+            Asserts.assertEQ(l12, n); n += i;\n+            Asserts.assertEQ(l13, n); n += i;\n+            Asserts.assertEQ(l14, n); n += i;\n+            Asserts.assertEQ(l15, n); n += i;\n+            Asserts.assertEQ(l16, n); n += i;\n+            Asserts.assertEQ(l17, n); n += i;\n+            Asserts.assertEQ(l18, n); n += i;\n+            Asserts.assertEQ(l19, n);\n+        }\n+    }\n+\n+    static inline class TestValue {\n+        int i;\n+        Big big;\n+\n+        TestValue(int n) {\n+            i = n;\n+            big = new Big(n);\n+        }\n+    }\n+\n+    @Test(compLevel=C1)\n+    public Big test7(TestValue[] array, int index) {\n+        return array[index].big;\n+    }\n+\n+    @DontCompile\n+    public void test7_verifier(boolean warmup) {\n+        TestValue[] array = new TestValue[7];\n+        Big b0 = test7(array, 3);\n+        b0.check(0, 0);\n+        TestValue tv = new TestValue(9);\n+        array[5] = tv;\n+        Big b1 = test7(array, 5);\n+        b1.check(9, 1);\n+    }\n+\n+    \/\/ Test 2nd level sub-element access to primitive field\n+    @Test(compLevel=C1)\n+    public byte test8(MyValue1[] array, int index) {\n+        return array[index].v2.y;\n+    }\n+\n+    @DontCompile\n+    public void test8_verifier(boolean warmup) {\n+        MyValue1[] array = new MyValue1[23];\n+        MyValue2 mv2a = MyValue2.createWithFieldsInline(7, 63L, 8.9d);\n+        MyValue2 mv2b = MyValue2.createWithFieldsInline(11, 69L, 17.3d);\n+        MyValue1 mv1 = new MyValue1(1, 2L, (short)3, 4, null, mv2a, mv2b, 'z');\n+        array[19] = mv1;\n+        byte b = test8(array, 19);\n+        Asserts.assertEQ(b, (byte)11);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC1.java","additions":156,"deletions":1,"binary":false,"changes":157,"status":"modified"}]}