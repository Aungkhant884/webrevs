{"files":[{"patch":"@@ -34,0 +34,1 @@\n+        opens 'org.openjdk.skara.bots.notify.prbranch' to 'org.junit.platform.commons'\n","filename":"bots\/notify\/build.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-            org.openjdk.skara.bots.notify.comment.CommitCommentNotifierFactory;\n+            org.openjdk.skara.bots.notify.comment.CommitCommentNotifierFactory,\n+            org.openjdk.skara.bots.notify.prbranch.PullRequestBranchNotifierFactory;\n","filename":"bots\/notify\/src\/main\/java\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+    default void onHeadChange(PullRequest pr, Hash oldHead) {\n+    }\n+    default void onStateChange(PullRequest pr, org.openjdk.skara.issuetracker.Issue.State oldState) {\n+    }\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/PullRequestListener.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.skara.issuetracker.Issue;\n@@ -34,0 +35,2 @@\n+    private final Hash head;\n+    private final Issue.State state;\n@@ -35,1 +38,1 @@\n-    PullRequestState(PullRequest pr, Set<String> issueIds, Hash commitId) {\n+    PullRequestState(PullRequest pr, Set<String> issueIds, Hash commitId, Hash head, Issue.State state) {\n@@ -39,0 +42,2 @@\n+        this.head = head;\n+        this.state = state;\n@@ -41,1 +46,1 @@\n-    PullRequestState(String prId, Set<String> issueIds, Hash commitId) {\n+    PullRequestState(String prId, Set<String> issueIds, Hash commitId, Hash head, Issue.State state) {\n@@ -45,0 +50,2 @@\n+        this.head = head;\n+        this.state = state;\n@@ -59,0 +66,8 @@\n+    public Hash head() {\n+        return head;\n+    }\n+\n+    public Issue.State state() {\n+        return state;\n+    }\n+\n@@ -65,0 +80,2 @@\n+                \", head=\" + head +\n+                \", state=\" + state +\n@@ -79,1 +96,3 @@\n-                Objects.equals(commitId, that.commitId);\n+                Objects.equals(commitId, that.commitId) &&\n+                Objects.equals(head, that.head) &&\n+                Objects.equals(state, that.state);\n@@ -84,1 +103,1 @@\n-        return Objects.hash(prId, issueIds, commitId);\n+        return Objects.hash(prId, issueIds, commitId, head);\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/PullRequestState.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -88,0 +88,6 @@\n+                       if (!obj.contains(\"head\")) {\n+                           obj.put(\"head\", Hash.zero().hex());\n+                       }\n+                       if (!obj.contains(\"state\")) {\n+                           obj.put(\"state\", JSON.of());\n+                       }\n@@ -91,0 +97,2 @@\n+                       var state = obj.get(\"state\").isNull() ?\n+                               null : org.openjdk.skara.issuetracker.Issue.State.valueOf(obj.get(\"state\").asString());\n@@ -92,1 +100,1 @@\n-                       return new PullRequestState(id, issues, commit);\n+                       return new PullRequestState(id, issues, commit, new Hash(obj.get(\"head\").asString()), state);\n@@ -122,0 +130,6 @@\n+                                ret.put(\"head\", JSON.of(pr.head().hex()));\n+                                if (pr.state() != null) {\n+                                    ret.put(\"state\", JSON.of(pr.state().toString()));\n+                                } else {\n+                                    ret.putNull(\"state\");\n+                                }\n@@ -174,0 +188,8 @@\n+    private void notifyHeadChange(PullRequest pr, Hash oldHead) {\n+        listeners.forEach(c -> c.onHeadChange(pr, oldHead));\n+    }\n+\n+    private void notifyStateChange(org.openjdk.skara.issuetracker.Issue.State oldState) {\n+        listeners.forEach(c -> c.onStateChange(pr, oldState));\n+    }\n+\n@@ -184,1 +206,1 @@\n-        var state = new PullRequestState(pr, issues, commit);\n+        var state = new PullRequestState(pr, issues, commit, pr.headHash(), pr.state());\n@@ -196,4 +218,14 @@\n-        if (storedState.isPresent() && storedState.get().commitId().equals(Optional.of(Hash.zero()))) {\n-            var hash = resultingCommitHash();\n-            storedState = Optional.of(new PullRequestState(pr, storedState.get().issueIds(), hash));\n-            storage.put(storedState.get());\n+        if (storedState.isPresent()) {\n+            if (storedState.get().commitId().equals(Optional.of(Hash.zero()))) {\n+                var hash = resultingCommitHash();\n+                storedState = Optional.of(new PullRequestState(pr, storedState.get().issueIds(), hash, pr.headHash(), pr.state()));\n+                storage.put(storedState.get());\n+            }\n+            if (storedState.get().head().equals(Hash.zero())) {\n+                storedState = Optional.of(new PullRequestState(pr, storedState.get().issueIds(), storedState.get().commitId().orElse(null), pr.headHash(), pr.state()));\n+                storage.put(storedState.get());\n+            }\n+            if (storedState.get().state() == null) {\n+                storedState = Optional.of(new PullRequestState(pr, storedState.get().issueIds(), storedState.get().commitId().orElse(null), pr.headHash(), pr.state()));\n+                storage.put(storedState.get());\n+            }\n@@ -211,0 +243,3 @@\n+            if (!storedState.get().head().equals(state.head())) {\n+                notifyHeadChange(pr, storedState.get().head());\n+            }\n@@ -212,1 +247,1 @@\n-            if (!storedCommit.isPresent() && state.commitId().isPresent()) {\n+            if (storedCommit.isEmpty() && state.commitId().isPresent()) {\n@@ -215,0 +250,3 @@\n+            if (!storedState.get().state().equals(state.state())) {\n+                notifyStateChange(storedState.get().state());\n+            }\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/PullRequestWorkItem.java","additions":45,"deletions":7,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -306,0 +306,3 @@\n+                        if (PreIntegrations.isPreintegrationBranch(branch.name())) {\n+                            continue;\n+                        }\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/issue\/IssueNotifier.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.notify.prbranch;\n+\n+import org.openjdk.skara.bots.notify.*;\n+import org.openjdk.skara.forge.*;\n+import org.openjdk.skara.issuetracker.Issue;\n+import org.openjdk.skara.vcs.*;\n+\n+import java.io.*;\n+import java.nio.file.Path;\n+\n+public class PullRequestBranchNotifier implements Notifier, PullRequestListener {\n+    private final Path seedFolder;\n+\n+    public PullRequestBranchNotifier(Path seedFolder) {\n+        this.seedFolder = seedFolder;\n+    }\n+\n+    @Override\n+    public void attachTo(Emitter e) {\n+        e.registerPullRequestListener(this);\n+    }\n+\n+    private void pushBranch(PullRequest pr) {\n+        var hostedRepositoryPool = new HostedRepositoryPool(seedFolder);\n+        try {\n+            var seedRepo = hostedRepositoryPool.seedRepository(pr.repository(), false);\n+            seedRepo.push(pr.headHash(), pr.repository().url(), PreIntegrations.preIntegrateBranch(pr), true);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private void deleteBranch(PullRequest pr) {\n+        var hostedRepositoryPool = new HostedRepositoryPool(seedFolder);\n+        try {\n+            var seedRepo = hostedRepositoryPool.seedRepository(pr.repository(), false);\n+            seedRepo.prune(new Branch(PreIntegrations.preIntegrateBranch(pr)), pr.repository().url().toString());\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void onNewPullRequest(PullRequest pr) {\n+        if (pr.state() == Issue.State.OPEN) {\n+            pushBranch(pr);\n+        }\n+    }\n+\n+    @Override\n+    public void onStateChange(PullRequest pr, Issue.State oldState) {\n+        if (pr.state() == Issue.State.CLOSED) {\n+            deleteBranch(pr);\n+        } else {\n+            pushBranch(pr);\n+        }\n+    }\n+\n+    @Override\n+    public void onHeadChange(PullRequest pr, Hash oldHead) {\n+        if (pr.state() == Issue.State.OPEN) {\n+            pushBranch(pr);\n+        }\n+    }\n+}\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/prbranch\/PullRequestBranchNotifier.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.notify.prbranch;\n+\n+import org.openjdk.skara.bot.BotConfiguration;\n+import org.openjdk.skara.bots.notify.*;\n+import org.openjdk.skara.json.JSONObject;\n+\n+public class PullRequestBranchNotifierFactory implements NotifierFactory {\n+    @Override\n+    public String name() {\n+        return \"prbranch\";\n+    }\n+\n+    @Override\n+    public Notifier create(BotConfiguration botConfiguration, JSONObject notifierConfiguration) {\n+        var seedFolder = botConfiguration.storageFolder();\n+        return new PullRequestBranchNotifier(seedFolder.resolve(\"seeds\"));\n+    }\n+\n+}\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/prbranch\/PullRequestBranchNotifierFactory.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.notify.prbranch;\n+\n+import org.junit.jupiter.api.*;\n+import org.openjdk.skara.forge.*;\n+import org.openjdk.skara.issuetracker.*;\n+import org.openjdk.skara.json.*;\n+import org.openjdk.skara.test.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class PullRequestBranchNotifierTests {\n+    private TestBotFactory testBotBuilder(HostedRepository hostedRepository, Path storagePath) {\n+        return TestBotFactory.newBuilder()\n+                             .addHostedRepository(\"hostedrepo\", hostedRepository)\n+                             .storagePath(storagePath)\n+                             .addConfiguration(\"database\", JSON.object()\n+                                                               .put(\"repository\", \"hostedrepo:history\")\n+                                                               .put(\"name\", \"duke\")\n+                                                               .put(\"email\", \"duke@openjdk.org\"))\n+                             .addConfiguration(\"ready\", JSON.object()\n+                                                            .put(\"labels\", JSON.array())\n+                                                            .put(\"comments\", JSON.array()))\n+                             .addConfiguration(\"integrator\", JSON.of(hostedRepository.forge().currentUser().id()))\n+                             .addConfiguration(\"repositories\", JSON.object()\n+                                                                   .put(\"hostedrepo\", JSON.object()\n+                                                                                          .put(\"basename\", \"test\")\n+                                                                                          .put(\"branches\", \"master\")\n+                                                                                          .put(\"prbranch\", JSON.object())))\n+                             .build();\n+    }\n+\n+    @Test\n+    void simple(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var repo = credentials.getHostedRepository();\n+            var repoFolder = tempFolder.path().resolve(\"repo\");\n+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());\n+            credentials.commitLock(localRepo);\n+            localRepo.pushAll(repo.url());\n+\n+            var storageFolder = tempFolder.path().resolve(\"storage\");\n+            var notifyBot = testBotBuilder(repo, storageFolder).create(\"notify\", JSON.object());\n+\n+            \/\/ Initialize history\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+\n+            \/\/ Create a PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo, \"Another line\");\n+            localRepo.push(editHash, repo.url(), \"source\", true);\n+            var pr = credentials.createPullRequest(repo, \"master\", \"source\", \"This is a PR\", false);\n+            pr.addLabel(\"rfr\");\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+\n+            \/\/ The target repo should now contain the new branch\n+            var hash = localRepo.fetch(repo.url(), PreIntegrations.preIntegrateBranch(pr));\n+            assertEquals(editHash, hash);\n+\n+            \/\/ Close the PR\n+            pr.setState(Issue.State.CLOSED);\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+\n+            \/\/ The target repo should no longer contain the branch\n+            assertThrows(IOException.class, () -> localRepo.fetch(repo.url(), PreIntegrations.preIntegrateBranch(pr)));\n+\n+            \/\/ Reopen the PR\n+            pr.setState(Issue.State.OPEN);\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+\n+            \/\/ The branch should have reappeared\n+            hash = localRepo.fetch(repo.url(), PreIntegrations.preIntegrateBranch(pr));\n+            assertEquals(editHash, hash);\n+        }\n+    }\n+\n+    @Test\n+    void updated(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var repo = credentials.getHostedRepository();\n+            var repoFolder = tempFolder.path().resolve(\"repo\");\n+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());\n+            credentials.commitLock(localRepo);\n+            localRepo.pushAll(repo.url());\n+\n+            var storageFolder = tempFolder.path().resolve(\"storage\");\n+            var notifyBot = testBotBuilder(repo, storageFolder).create(\"notify\", JSON.object());\n+\n+            \/\/ Initialize history\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+\n+            \/\/ Create a PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo, \"Another line\");\n+            localRepo.push(editHash, repo.url(), \"source\", true);\n+            var pr = credentials.createPullRequest(repo, \"master\", \"source\", \"This is a PR\", false);\n+            pr.addLabel(\"rfr\");\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+\n+            \/\/ The target repo should now contain the new branch\n+            var hash = localRepo.fetch(repo.url(), PreIntegrations.preIntegrateBranch(pr));\n+            assertEquals(editHash, hash);\n+\n+            \/\/ Push another change\n+            var updatedHash = CheckableRepository.appendAndCommit(localRepo, \"Yet another line\");\n+            localRepo.push(updatedHash, repo.url(), \"source\");\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+\n+            \/\/ The branch should have been updated\n+            hash = localRepo.fetch(repo.url(), PreIntegrations.preIntegrateBranch(pr));\n+            assertEquals(updatedHash, hash);\n+        }\n+    }\n+}\n","filename":"bots\/notify\/src\/test\/java\/org\/openjdk\/skara\/bots\/notify\/prbranch\/PullRequestBranchNotifierTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -101,0 +101,3 @@\n+        if (PreIntegrations.isPreintegrationBranch(pr.targetRef())) {\n+            return true;\n+        }\n@@ -145,0 +148,1 @@\n+                 .filter(name -> !PreIntegrations.isPreintegrationBranch(name))\n@@ -233,0 +237,3 @@\n+        var dep = PreIntegrations.dependentPullRequestId(pr);\n+        dep.ifPresent(s -> ret.add(\"Dependency #\" + s + \" must be integrated first\"));\n+\n@@ -925,1 +932,1 @@\n-                                                newLabels, pr.isDraft(), expiresIn);\n+                                                newLabels, pr.targetRef(), pr.isDraft(), expiresIn);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                       List<Review> reviews, Set<String> labels, boolean isDraft, Duration expiresIn) {\n+                       List<Review> reviews, Set<String> labels, String targetRef, boolean isDraft, Duration expiresIn) {\n@@ -92,0 +92,1 @@\n+            digest.update(targetRef.getBytes(StandardCharsets.UTF_8));\n@@ -106,1 +107,1 @@\n-        var metadata = getMetadata(censusInstance, pr.title(), pr.body(), comments, reviews, labels, pr.isDraft(), null);\n+        var metadata = getMetadata(censusInstance, pr.title(), pr.body(), comments, reviews, labels, pr.targetRef(), pr.isDraft(), null);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckWorkItem.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -220,2 +220,9 @@\n-                localRepo.merge(pr.targetHash());\n-                var hash = localRepo.commit(\"Automatic merge with latest target\", \"duke\", \"duke@openjdk.org\");\n+                Hash hash;\n+                try {\n+                    localRepo.merge(pr.targetHash());\n+                    hash = localRepo.commit(\"Automatic merge with latest target\", \"duke\", \"duke@openjdk.org\");\n+                } catch (IOException e) {\n+                    localRepo.abortMerge();\n+                    localRepo.rebase(pr.targetHash(), \"duke\", \"duke@openjdk.org\");\n+                    hash = localRepo.head();\n+                }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckablePullRequest.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+        var success = false;\n@@ -175,0 +176,1 @@\n+                success = true;\n@@ -190,0 +192,5 @@\n+\n+        \/\/ Additional cleanup outside of the integration lock\n+        if (success) {\n+            PreIntegrations.retargetDependencies(pr);\n+        }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import org.junit.jupiter.api.*;\n+import org.openjdk.skara.forge.*;\n+import org.openjdk.skara.test.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.openjdk.skara.bots.pr.PullRequestAsserts.assertLastCommentContains;\n+\n+public class PreIntegrateTests {\n+    @Test\n+    void integrateFollowup(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory();\n+             var seedFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder()\n+                                         .repo(integrator)\n+                                         .censusRepo(censusBuilder.build())\n+                                         .seedStorage(seedFolder.path())\n+                                         .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo, \"First PR\", \"Base change\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"This is a pull request\");\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ The bot should reply with integration message\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+            assertLastCommentContains(pr, \"To integrate this PR with the above commit message to the `master` branch\");\n+\n+            \/\/ Simulate population of the pr branch\n+            localRepo.push(editHash, author.url(), PreIntegrations.preIntegrateBranch(pr), true);\n+\n+            \/\/ Create follow-up work\n+            var followUp = CheckableRepository.appendAndCommit(localRepo, \"Follow-up work\", \"Follow-up change\");\n+            localRepo.push(followUp, author.url(), \"followup\", true);\n+            var followUpPr = credentials.createPullRequest(author, PreIntegrations.preIntegrateBranch(pr), \"followup\", \"This is another pull request\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Approve it as another user\n+            var approvalFollowUpPr = integrator.pullRequest(followUpPr.id());\n+            approvalFollowUpPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ The bot should add an integration blocker message\n+            followUpPr = author.pullRequest(followUpPr.id());\n+            assertTrue(followUpPr.body().contains(\"Integration blocker\"));\n+            assertTrue(followUpPr.body().contains(\"Dependency #\" + pr.id() + \" must be integrated\"));\n+\n+            \/\/ Try to integrate it\n+            followUpPr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+            assertLastCommentContains(followUpPr, \"This PR has not yet been marked as ready for integration\");\n+\n+            \/\/ Push something unrelated to the target\n+            localRepo.checkout(masterHash, true);\n+            var unrelatedFile = localRepo.root().resolve(\"unrelated.txt\");\n+            Files.writeString(unrelatedFile, \"Other things happens in master\");\n+            localRepo.add(unrelatedFile);\n+            var newMasterHash = localRepo.commit(\"Unrelated change\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(newMasterHash, author.url(), \"master\");\n+\n+            \/\/ Now integrate the first one\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with an ok message\n+            assertLastCommentContains(pr, \"Pushed as commit\");\n+\n+            \/\/ The second should now become ready\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+            followUpPr = author.pullRequest(followUpPr.id());\n+            assertFalse(followUpPr.body().contains(\"Integration blocker\"));\n+            assertTrue(followUpPr.labels().contains(\"ready\"));\n+\n+            \/\/ Push something else unrelated to the target\n+            var currentMaster = localRepo.fetch(author.url(), \"master\");\n+            localRepo.checkout(currentMaster, true);\n+            var unrelatedFile2 = localRepo.root().resolve(\"unrelated2.txt\");\n+            Files.writeString(unrelatedFile2, \"Some other things happens in master\");\n+            localRepo.add(unrelatedFile2);\n+            newMasterHash = localRepo.commit(\"Second unrelated change\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(newMasterHash, author.url(), \"master\");\n+\n+            \/\/ Refresh the status\n+            followUpPr.setBody(followUpPr.body() + \" recheck\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Try to integrate it again\n+            followUpPr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+            assertLastCommentContains(followUpPr, \"Pushed as commit\");\n+\n+            \/\/ Check that everything is present\n+            var finalMaster = localRepo.fetch(author.url(), \"master\");\n+            localRepo.checkout(finalMaster, true);\n+            assertEquals(\"Other things happens in master\", Files.readString(localRepo.root().resolve(\"unrelated.txt\")));\n+            assertEquals(\"Some other things happens in master\", Files.readString(localRepo.root().resolve(\"unrelated2.txt\")));\n+            assertTrue(CheckableRepository.hasBeenEdited(localRepo));\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/PreIntegrateTests.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -294,0 +294,5 @@\n+    @Override\n+    public void setTargetRef(String targetRef) {\n+\n+    }\n+\n","filename":"bots\/tester\/src\/test\/java\/org\/openjdk\/skara\/bots\/tester\/InMemoryPullRequest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,5 +77,8 @@\n-            try {\n-                var lastFetch = Files.getLastModifiedTime(seed.resolve(\"FETCH_HEAD\"));\n-                if (lastFetch.toInstant().isAfter(Instant.now().minus(Duration.ofMinutes(1)))) {\n-                    log.info(\"Seed should be up to date, skipping fetch\");\n-                    return;\n+            if (allowStale) {\n+                try {\n+                    var lastFetch = Files.getLastModifiedTime(seed.resolve(\"FETCH_HEAD\"));\n+                    if (lastFetch.toInstant().isAfter(Instant.now().minus(Duration.ofMinutes(1)))) {\n+                        log.info(\"Seed should be up to date, skipping fetch\");\n+                        return;\n+                    }\n+                } catch (IOException ignored) {\n@@ -83,1 +86,0 @@\n-            } catch (IOException ignored) {\n@@ -95,1 +97,1 @@\n-        private ReadOnlyRepository seedRepository(boolean allowStale) throws IOException {\n+        private Repository seedRepository(boolean allowStale) throws IOException {\n@@ -97,1 +99,1 @@\n-            return ReadOnlyRepository.get(seed).orElseThrow(() -> new IOException(\"Existing seed is corrupt?\"));\n+            return Repository.get(seed).orElseThrow(() -> new IOException(\"Existing seed is corrupt?\"));\n@@ -181,1 +183,10 @@\n-        var refHash = seedRepo.resolve(ref).orElseThrow(() -> new IOException(\"Ref not found: \" + ref));\n+        var refHash = seedRepo.resolve(ref);\n+        if (refHash.isEmpty()) {\n+            \/\/ It may fail because the seed is stale - need to refresh it now\n+            seedRepo = hostedRepositoryInstance.seedRepository(false);\n+            refHash = seedRepo.resolve(ref);\n+        }\n+\n+        var hash = refHash.orElseThrow(() -> new IOException(\"Ref not found: \" + ref));\n+        return seedRepo.lines(p, hash);\n+    }\n@@ -183,1 +194,3 @@\n-        return seedRepo.lines(p, refHash);\n+    public Repository seedRepository(HostedRepository hostedRepository, boolean allowStale) throws IOException {\n+        var hostedRepositoryInstance = new HostedRepositoryInstance(hostedRepository);\n+        return hostedRepositoryInstance.seedRepository(false);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/HostedRepositoryPool.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+package org.openjdk.skara.forge;\n+\n+import java.util.Optional;\n+\n+public class PreIntegrations {\n+    public static Optional<String> dependentPullRequestId(PullRequest pr) {\n+        if (isPreintegrationBranch(pr.targetRef())) {\n+            var depStart = pr.targetRef().lastIndexOf(\"\/\");\n+            if (depStart == -1) {\n+                throw new IllegalStateException(\"Cannot parse target ref: \" + pr.targetRef());\n+            }\n+            var depId = pr.targetRef().substring(depStart + 1);\n+            return Optional.of(depId);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static String preIntegrateBranch(PullRequest pr) {\n+        return \"pr\/\" + pr.id();\n+    }\n+\n+    public static void retargetDependencies(PullRequest pr) {\n+        var dependentRef = preIntegrateBranch(pr);\n+\n+        var candidates = pr.repository().pullRequests();\n+        for (var candidate : candidates) {\n+            if (candidate.targetRef().equals(dependentRef)) {\n+                candidate.setTargetRef(pr.targetRef());\n+            }\n+        }\n+    }\n+\n+    public static boolean isPreintegrationBranch(String name) {\n+        return name.startsWith(\"pr\/\");\n+    }\n+}\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PreIntegrations.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -159,0 +159,6 @@\n+\n+    \/**\n+     * Update the ref the request is intended to be merged into.\n+     * @return\n+     *\/\n+    void setTargetRef(String targetRef);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,9 +84,0 @@\n-    private Optional<ZonedDateTime> lastBaseRefChange() {\n-        return request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/timeline\").execute().stream()\n-                      .map(JSONValue::asObject)\n-                      .filter(obj -> obj.contains(\"event\"))\n-                      .filter(obj -> obj.get(\"event\").asString().equals(\"base_ref_changed\"))\n-                      .map(o -> ZonedDateTime.parse(o.get(\"created_at\").asString()))\n-                      .max(Comparator.comparing(Function.identity()));\n-    }\n-\n@@ -120,2 +111,38 @@\n-        \/\/ In the unlikely event that the base ref has changed after a review, we treat those as invalid\n-        var lastBaseRefChange = lastBaseRefChange();\n+        \/\/ The base ref cannot change for repos only using a single branch\n+        if (!repository.multipleBranches()) {\n+            return reviews;\n+        }\n+\n+        \/\/ If the base ref has changed after a review, we treat those as invalid - unless it was a PreIntegration ref\n+        var parts = repository.name().split(\"\/\");\n+        var owner = parts[0];\n+        var name = parts[1];\n+        var number = id();\n+\n+        var query = \"{\\n\" +\n+                \"  repository(owner: \\\"\" + owner + \"\\\", name: \\\"\" + name + \"\\\") {\\n\" +\n+                \"    pullRequest(number: \" + number + \") {\\n\" +\n+                \"      timelineItems(itemTypes: BASE_REF_CHANGED_EVENT, last: 10) {\\n\" +\n+                \"        nodes {\\n\" +\n+                \"          __typename\\n\" +\n+                \"          ... on BaseRefChangedEvent {\\n\" +\n+                \"            currentRefName,\\n\" +\n+                \"            previousRefName,\\n\" +\n+                \"            createdAt\\n\" +\n+                \"          }\\n\" +\n+                \"        }\\n\" +\n+                \"      }\\n\" +\n+                \"    }\\n\" +\n+                \"  }\\n\" +\n+                \"}\";\n+        var data = host.graphQL()\n+                       .post()\n+                       .body(JSON.object().put(\"query\", query))\n+                       .execute()\n+                       .get(\"data\");\n+        var lastBaseRefChange = data.get(\"repository\").get(\"pullRequest\").get(\"timelineItems\").get(\"nodes\").stream()\n+                                    .map(JSONValue::asObject)\n+                                    .filter(obj -> !PreIntegrations.isPreintegrationBranch(obj.get(\"currentRefName\").asString()))\n+                                    .filter(obj -> !PreIntegrations.isPreintegrationBranch(obj.get(\"previousRefName\").asString()))\n+                                    .map(obj -> ZonedDateTime.parse(obj.get(\"createdAt\").asString()))\n+                                    .max(Comparator.comparing(Function.identity()));\n@@ -662,0 +689,7 @@\n+    @Override\n+    public void setTargetRef(String targetRef) {\n+        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n+               .body(\"base\", targetRef)\n+               .execute();\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubPullRequest.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+    private List<HostedBranch> branches;\n@@ -81,0 +82,7 @@\n+    boolean multipleBranches() {\n+        if (branches == null) {\n+            branches = branches();\n+        }\n+        return branches.size() > 1;\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubRepository.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -738,0 +738,7 @@\n+    @Override\n+    public void setTargetRef(String targetRef) {\n+        request.put(\"\")\n+               .body(\"target_branch\", targetRef)\n+               .execute();\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabMergeRequest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+    String targetRef;\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/PullRequestData.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-    private final String targetRef;\n@@ -50,1 +49,0 @@\n-        this.targetRef = targetRef;\n@@ -52,0 +50,1 @@\n+        data.targetRef = targetRef;\n@@ -75,1 +74,1 @@\n-        var pr = new TestPullRequest(repository, other.sourceRepository, other.id, other.author, repository.forge().currentUser(), other.targetRef, other.sourceRef, other.data);\n+        var pr = new TestPullRequest(repository, other.sourceRepository, other.id, other.author, repository.forge().currentUser(), other.data.targetRef, other.sourceRef, other.data);\n@@ -156,1 +155,1 @@\n-        return targetRef;\n+        return data.targetRef;\n@@ -161,1 +160,1 @@\n-        return targetRepository.branchHash(targetRef);\n+        return targetRepository.branchHash(data.targetRef);\n@@ -232,0 +231,6 @@\n+    @Override\n+    public void setTargetRef(String targetRef) {\n+        data.targetRef = targetRef;\n+        data.lastUpdate = ZonedDateTime.now();\n+    }\n+\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestPullRequest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}