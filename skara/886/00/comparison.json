{"files":[{"patch":"@@ -101,0 +101,3 @@\n+        if (PreIntegrations.isPreintegrationBranch(pr.targetRef())) {\n+            return true;\n+        }\n@@ -233,0 +236,3 @@\n+        var dep = PreIntegrations.dependentPullRequestId(pr);\n+        dep.ifPresent(s -> ret.add(\"Dependency #\" + s + \" must be integrated first\"));\n+\n@@ -925,1 +931,1 @@\n-                                                newLabels, pr.isDraft(), expiresIn);\n+                                                newLabels, pr.targetRef(), pr.isDraft(), expiresIn);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                       List<Review> reviews, Set<String> labels, boolean isDraft, Duration expiresIn) {\n+                       List<Review> reviews, Set<String> labels, String targetRef, boolean isDraft, Duration expiresIn) {\n@@ -92,0 +92,1 @@\n+            digest.update(targetRef.getBytes(StandardCharsets.UTF_8));\n@@ -106,1 +107,1 @@\n-        var metadata = getMetadata(censusInstance, pr.title(), pr.body(), comments, reviews, labels, pr.isDraft(), null);\n+        var metadata = getMetadata(censusInstance, pr.title(), pr.body(), comments, reviews, labels, pr.targetRef(), pr.isDraft(), null);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckWorkItem.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -220,2 +220,9 @@\n-                localRepo.merge(pr.targetHash());\n-                var hash = localRepo.commit(\"Automatic merge with latest target\", \"duke\", \"duke@openjdk.org\");\n+                Hash hash;\n+                try {\n+                    localRepo.merge(pr.targetHash());\n+                    hash = localRepo.commit(\"Automatic merge with latest target\", \"duke\", \"duke@openjdk.org\");\n+                } catch (IOException e) {\n+                    localRepo.abortMerge();\n+                    localRepo.rebase(pr.targetHash(), \"duke\", \"duke@openjdk.org\");\n+                    hash = localRepo.head();\n+                }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckablePullRequest.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-            Map.entry(\"cc\", new LabelCommand(\"cc\"))\n+            Map.entry(\"cc\", new LabelCommand(\"cc\")),\n+            Map.entry(\"preintegrate\", new PreIntegrateCommand())\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CommandWorkItem.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+        var success = false;\n@@ -175,0 +176,1 @@\n+                success = true;\n@@ -190,0 +192,5 @@\n+\n+        \/\/ Additional cleanup outside of the integration lock\n+        if (success) {\n+            PreIntegrations.retargetDependencies(pr);\n+        }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import org.openjdk.skara.forge.*;\n+import org.openjdk.skara.issuetracker.Comment;\n+\n+import java.io.*;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+public class PreIntegrateCommand implements CommandHandler {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.pr\");\n+\n+    @Override\n+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {\n+        if (!command.user().equals(pr.author())) {\n+            reply.println(\"Only the author (@\" + pr.author().userName() + \") is allowed to issue the `preintegrate` command.\");\n+            return;\n+        }\n+\n+        \/\/ Check if the author is allowed to perform pre-integrations\n+        if (!censusInstance.isCommitter(pr.author())) {\n+            reply.println(\"Only [Committers](https:\/\/openjdk.java.net\/bylaws#committer) (@\" + pr.author().userName() + \") are allowed to issue the `preintegrate` command.\");\n+            return;\n+        }\n+\n+        try {\n+            var path = scratchPath.resolve(\"integrate\").resolve(pr.repository().name());\n+            var seedPath = bot.seedStorage().orElse(scratchPath.resolve(\"seeds\"));\n+            var hostedRepositoryPool = new HostedRepositoryPool(seedPath);\n+            var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, path);\n+\n+            var preIntegrateBranch = PreIntegrations.preIntegrateBranch(pr);\n+            localRepo.push(pr.headHash(), pr.repository().url(), preIntegrateBranch);\n+\n+            reply.println(\"The current content of this pull request has been pre-integrated into the branch `\" + preIntegrateBranch + \"`. \");\n+            reply.println(\"This branch can now be targeted by additional pull requests that contain dependent work.\");\n+\n+        } catch (IOException e) {\n+            log.severe(\"An error occurred during pre-integration (\" + pr.webUrl() + \"): \" + e.getMessage());\n+            log.throwing(\"PreIntegrateCommand\", \"handle\", e);\n+            reply.println(\"An unexpected error occurred during pre-integration. No push attempt will be made. \" +\n+                                  \"The error has been logged and will be investigated. It is possible that this error \" +\n+                                  \"is caused by a transient issue; feel free to retry the operation.\");\n+        }\n+    }\n+\n+    @Override\n+    public String description() {\n+        return null;\n+    }\n+}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PreIntegrateCommand.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import org.junit.jupiter.api.*;\n+import org.openjdk.skara.forge.*;\n+import org.openjdk.skara.test.*;\n+import org.openjdk.skara.vcs.Repository;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.openjdk.skara.bots.pr.PullRequestAsserts.assertLastCommentContains;\n+\n+public class PreIntegrateTests {\n+    @Test\n+    void simple(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory();\n+             var masterFolder = new TemporaryDirectory();\n+             var pushedFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"This is a pull request\");\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ The bot should reply with integration message\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+            assertLastCommentContains(pr, \"To integrate this PR with the above commit message to the `master` branch\");\n+\n+            \/\/ Attempt a merge (the bot should only process the first one)\n+            pr.addComment(\"\/preintegrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with an ok message\n+            assertLastCommentContains(pr, \"The current content of this pull request has been pre-integrated into the branch\");\n+\n+            \/\/ The change should not be present on the master branch\n+            var masterRepo = Repository.materialize(pushedFolder.path(), author.url(), \"master\");\n+            assertFalse(CheckableRepository.hasBeenEdited(masterRepo));\n+\n+            \/\/ But it should appear in a new branch\n+            var pushedRepo = Repository.materialize(pushedFolder.path(), author.url(), PreIntegrations.preIntegrateBranch(pr));\n+            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));\n+        }\n+    }\n+\n+    @Test\n+    void integrateFollowup(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory();\n+             var seedFolder = new TemporaryDirectory();\n+             var masterFolder = new TemporaryDirectory();\n+             var pushedFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder()\n+                                         .repo(integrator)\n+                                         .censusRepo(censusBuilder.build())\n+                                         .seedStorage(seedFolder.path())\n+                                         .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo, \"First PR\", \"Base change\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"This is a pull request\");\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            var r = pr.reviews();\n+\n+\n+            \/\/ The bot should reply with integration message\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+            assertLastCommentContains(pr, \"To integrate this PR with the above commit message to the `master` branch\");\n+\n+            \/\/ Attempt a merge (the bot should only process the first one)\n+            pr.addComment(\"\/preintegrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with an ok message\n+            assertLastCommentContains(pr, \"The current content of this pull request has been pre-integrated into the branch\");\n+\n+            \/\/ Create follow-up work\n+            var followUp = CheckableRepository.appendAndCommit(localRepo, \"Follow-up work\", \"Follow-up change\");\n+            localRepo.push(followUp, author.url(), \"followup\", true);\n+            var followUpPr = credentials.createPullRequest(author, PreIntegrations.preIntegrateBranch(pr), \"followup\", \"This is another pull request\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Approve it as another user\n+            var approvalFollowUpPr = integrator.pullRequest(followUpPr.id());\n+            approvalFollowUpPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ The bot should add an integration blocker message\n+            followUpPr = author.pullRequest(followUpPr.id());\n+            assertTrue(followUpPr.body().contains(\"Integration blocker\"));\n+            assertTrue(followUpPr.body().contains(\"Dependency #\" + pr.id() + \" must be integrated\"));\n+\n+            \/\/ Try to integrate it\n+            followUpPr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+            assertLastCommentContains(followUpPr, \"This PR has not yet been marked as ready for integration\");\n+\n+            \/\/ Push something unrelated to the target\n+            localRepo.checkout(masterHash, true);\n+            var unrelatedFile = localRepo.root().resolve(\"unrelated.txt\");\n+            Files.writeString(unrelatedFile, \"Other things happens in master\");\n+            localRepo.add(unrelatedFile);\n+            var newMasterHash = localRepo.commit(\"Unrelated change\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(newMasterHash, author.url(), \"master\");\n+\n+            \/\/ Now integrate the first one\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with an ok message\n+            assertLastCommentContains(pr, \"Pushed as commit\");\n+\n+            \/\/ The second should now become ready\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+            followUpPr = author.pullRequest(followUpPr.id());\n+            assertFalse(followUpPr.body().contains(\"Integration blocker\"));\n+            assertTrue(followUpPr.labels().contains(\"ready\"));\n+\n+            \/\/ Push something else unrelated to the target\n+            var currentMaster = localRepo.fetch(author.url(), \"master\");\n+            localRepo.checkout(currentMaster, true);\n+            var unrelatedFile2 = localRepo.root().resolve(\"unrelated2.txt\");\n+            Files.writeString(unrelatedFile2, \"Some other things happens in master\");\n+            localRepo.add(unrelatedFile2);\n+            newMasterHash = localRepo.commit(\"Second unrelated change\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(newMasterHash, author.url(), \"master\");\n+\n+            \/\/ Refresh the status\n+            followUpPr.setBody(followUpPr.body() + \" recheck\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Try to integrate it again\n+            followUpPr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+            assertLastCommentContains(followUpPr, \"Pushed as commit\");\n+\n+            \/\/ Check that everything is present\n+            var finalMaster = localRepo.fetch(author.url(), \"master\");\n+            localRepo.checkout(finalMaster, true);\n+            assertEquals(\"Other things happens in master\", Files.readString(localRepo.root().resolve(\"unrelated.txt\")));\n+            assertEquals(\"Some other things happens in master\", Files.readString(localRepo.root().resolve(\"unrelated2.txt\")));\n+            assertTrue(CheckableRepository.hasBeenEdited(localRepo));\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/PreIntegrateTests.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -294,0 +294,5 @@\n+    @Override\n+    public void setTargetRef(String targetRef) {\n+\n+    }\n+\n","filename":"bots\/tester\/src\/test\/java\/org\/openjdk\/skara\/bots\/tester\/InMemoryPullRequest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,5 +77,8 @@\n-            try {\n-                var lastFetch = Files.getLastModifiedTime(seed.resolve(\"FETCH_HEAD\"));\n-                if (lastFetch.toInstant().isAfter(Instant.now().minus(Duration.ofMinutes(1)))) {\n-                    log.info(\"Seed should be up to date, skipping fetch\");\n-                    return;\n+            if (allowStale) {\n+                try {\n+                    var lastFetch = Files.getLastModifiedTime(seed.resolve(\"FETCH_HEAD\"));\n+                    if (lastFetch.toInstant().isAfter(Instant.now().minus(Duration.ofMinutes(1)))) {\n+                        log.info(\"Seed should be up to date, skipping fetch\");\n+                        return;\n+                    }\n+                } catch (IOException ignored) {\n@@ -83,1 +86,0 @@\n-            } catch (IOException ignored) {\n@@ -181,1 +183,6 @@\n-        var refHash = seedRepo.resolve(ref).orElseThrow(() -> new IOException(\"Ref not found: \" + ref));\n+        var refHash = seedRepo.resolve(ref);\n+        if (refHash.isEmpty()) {\n+            \/\/ It may fail because the seed is stale - need to refresh it now\n+            seedRepo = hostedRepositoryInstance.seedRepository(false);\n+            refHash = seedRepo.resolve(ref);\n+        }\n@@ -183,1 +190,2 @@\n-        return seedRepo.lines(p, refHash);\n+        var hash = refHash.orElseThrow(() -> new IOException(\"Ref not found: \" + ref));\n+        return seedRepo.lines(p, hash);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/HostedRepositoryPool.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+package org.openjdk.skara.forge;\n+\n+import java.util.Optional;\n+\n+public class PreIntegrations {\n+    public static Optional<String> dependentPullRequestId(PullRequest pr) {\n+        if (isPreintegrationBranch(pr.targetRef())) {\n+            var depStart = pr.targetRef().lastIndexOf(\"\/\");\n+            if (depStart == -1) {\n+                throw new IllegalStateException(\"Cannot parse target ref: \" + pr.targetRef());\n+            }\n+            var depId = pr.targetRef().substring(depStart + 1);\n+            return Optional.of(depId);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static String preIntegrateBranch(PullRequest pr) {\n+        return \"pr\/\" + pr.author().userName().replaceAll(\"[^\\\\w]\", \"_\") + \"\/\" + pr.id();\n+    }\n+\n+    public static void retargetDependencies(PullRequest pr) {\n+        var dependentRef = preIntegrateBranch(pr);\n+\n+        var candidates = pr.repository().pullRequests();\n+        for (var candidate : candidates) {\n+            if (candidate.targetRef().equals(dependentRef)) {\n+                candidate.setTargetRef(pr.targetRef());\n+            }\n+        }\n+    }\n+\n+    public static boolean isPreintegrationBranch(String name) {\n+        return name.startsWith(\"pr\/\");\n+    }\n+}\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PreIntegrations.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -159,0 +159,6 @@\n+\n+    \/**\n+     * Update the ref the request is intended to be merged into.\n+     * @return\n+     *\/\n+    void setTargetRef(String targetRef);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,9 +84,0 @@\n-    private Optional<ZonedDateTime> lastBaseRefChange() {\n-        return request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/timeline\").execute().stream()\n-                      .map(JSONValue::asObject)\n-                      .filter(obj -> obj.contains(\"event\"))\n-                      .filter(obj -> obj.get(\"event\").asString().equals(\"base_ref_changed\"))\n-                      .map(o -> ZonedDateTime.parse(o.get(\"created_at\").asString()))\n-                      .max(Comparator.comparing(Function.identity()));\n-    }\n-\n@@ -120,2 +111,38 @@\n-        \/\/ In the unlikely event that the base ref has changed after a review, we treat those as invalid\n-        var lastBaseRefChange = lastBaseRefChange();\n+        \/\/ The base ref cannot change for repos only using a single branch\n+        if (!repository.multipleBranches()) {\n+            return reviews;\n+        }\n+\n+        \/\/ If the base ref has changed after a review, we treat those as invalid - unless it was a PreIntegration ref\n+        var parts = repository.name().split(\"\/\");\n+        var owner = parts[0];\n+        var name = parts[1];\n+        var number = id();\n+\n+        var query = \"{\\n\" +\n+                \"  repository(owner: \\\"\" + owner + \"\\\", name: \\\"\" + name + \"\\\") {\\n\" +\n+                \"    pullRequest(number: \" + number + \") {\\n\" +\n+                \"      timelineItems(itemTypes: BASE_REF_CHANGED_EVENT, last: 10) {\\n\" +\n+                \"        nodes {\\n\" +\n+                \"          __typename\\n\" +\n+                \"          ... on BaseRefChangedEvent {\\n\" +\n+                \"            currentRefName,\\n\" +\n+                \"            previousRefName,\\n\" +\n+                \"            createdAt\\n\" +\n+                \"          }\\n\" +\n+                \"        }\\n\" +\n+                \"      }\\n\" +\n+                \"    }\\n\" +\n+                \"  }\\n\" +\n+                \"}\";\n+        var data = host.graphQL()\n+                       .post()\n+                       .body(JSON.object().put(\"query\", query))\n+                       .execute()\n+                       .get(\"data\");\n+        var lastBaseRefChange = data.get(\"repository\").get(\"pullRequest\").get(\"timelineItems\").get(\"nodes\").stream()\n+                                    .map(JSONValue::asObject)\n+                                    .filter(obj -> !PreIntegrations.isPreintegrationBranch(obj.get(\"currentRefName\").asString()))\n+                                    .filter(obj -> !PreIntegrations.isPreintegrationBranch(obj.get(\"previousRefName\").asString()))\n+                                    .map(obj -> ZonedDateTime.parse(obj.get(\"createdAt\").asString()))\n+                                    .max(Comparator.comparing(Function.identity()));\n@@ -662,0 +689,7 @@\n+    @Override\n+    public void setTargetRef(String targetRef) {\n+        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n+               .body(\"base\", targetRef)\n+               .execute();\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubPullRequest.java","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+    private List<HostedBranch> branches;\n@@ -81,0 +82,7 @@\n+    boolean multipleBranches() {\n+        if (branches == null) {\n+            branches = branches();\n+        }\n+        return branches.size() > 1;\n+    }\n+\n@@ -258,0 +266,1 @@\n+                       .filter(b -> !PreIntegrations.isPreintegrationBranch(b.get(\"name\").asString()))\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubRepository.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -738,0 +738,7 @@\n+    @Override\n+    public void setTargetRef(String targetRef) {\n+        request.put(\"\")\n+               .body(\"target_branch\", targetRef)\n+               .execute();\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabMergeRequest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -288,0 +288,1 @@\n+                       .filter(b -> !PreIntegrations.isPreintegrationBranch(b.get(\"name\").asString()))\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabRepository.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+    String targetRef;\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/PullRequestData.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,1 +198,3 @@\n-                result.add(new HostedBranch(b.name(), localRepository.resolve(b).orElseThrow()));\n+                if (!PreIntegrations.isPreintegrationBranch(b.name())) {\n+                    result.add(new HostedBranch(b.name(), localRepository.resolve(b).orElseThrow()));\n+                }\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestHostedRepository.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-    private final String targetRef;\n@@ -50,1 +49,0 @@\n-        this.targetRef = targetRef;\n@@ -52,0 +50,1 @@\n+        data.targetRef = targetRef;\n@@ -75,1 +74,1 @@\n-        var pr = new TestPullRequest(repository, other.sourceRepository, other.id, other.author, repository.forge().currentUser(), other.targetRef, other.sourceRef, other.data);\n+        var pr = new TestPullRequest(repository, other.sourceRepository, other.id, other.author, repository.forge().currentUser(), other.data.targetRef, other.sourceRef, other.data);\n@@ -156,1 +155,1 @@\n-        return targetRef;\n+        return data.targetRef;\n@@ -161,1 +160,1 @@\n-        return targetRepository.branchHash(targetRef);\n+        return targetRepository.branchHash(data.targetRef);\n@@ -232,0 +231,6 @@\n+    @Override\n+    public void setTargetRef(String targetRef) {\n+        data.targetRef = targetRef;\n+        data.lastUpdate = ZonedDateTime.now();\n+    }\n+\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestPullRequest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}