{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,1 @@\n-import org.openjdk.skara.forge.Forge;\n-import org.openjdk.skara.host.*;\n-import org.openjdk.skara.vcs.Repository;\n+import org.openjdk.skara.host.Credential;\n@@ -30,0 +28,1 @@\n+import org.openjdk.skara.vcs.Repository;\n@@ -32,1 +31,2 @@\n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n@@ -34,1 +34,1 @@\n-import java.nio.file.*;\n+import java.net.URISyntaxException;\n@@ -36,1 +36,3 @@\n-import java.util.*;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -41,10 +43,8 @@\n-    private static void exit(String fmt, Object...args) {\n-        System.err.println(String.format(fmt, args));\n-        System.exit(1);\n-    }\n-\n-    private static <T> Supplier<T> die(String fmt, Object... args) {\n-        return () -> {\n-            exit(fmt, args);\n-            return null;\n-        };\n+    private final Arguments arguments;\n+    private final boolean isDryRun;\n+    private final String sourceArg;\n+\n+    public GitFork(Arguments arguments) {\n+        this.arguments = arguments;\n+        this.isDryRun = arguments.contains(\"dry-run\");\n+        this.sourceArg = arguments.at(0).asString();\n@@ -53,1 +53,1 @@\n-    private static void sleep(int ms) {\n+    private String gitConfig(String key) {\n@@ -55,3 +55,14 @@\n-            Thread.sleep(ms);\n-        } catch (InterruptedException e) {\n-            \/\/ do nothing\n+            var pb = new ProcessBuilder(\"git\", \"config\", key);\n+            pb.redirectOutput(ProcessBuilder.Redirect.PIPE);\n+            pb.redirectError(ProcessBuilder.Redirect.DISCARD);\n+            var p = pb.start();\n+\n+            var output = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\n+            var res = p.waitFor();\n+            if (res != 0) {\n+                return null;\n+            }\n+\n+            return output.replace(\"\\n\", \"\");\n+        } catch (InterruptedException | IOException e) {\n+            return null;\n@@ -61,1 +72,1 @@\n-    private static String getOption(String name, String subsection, Arguments arguments) {\n+    private String getOption(String name) {\n@@ -66,5 +77,3 @@\n-        if (subsection != null && !subsection.isEmpty()) {\n-            var subsectionSpecific = gitConfig(\"fork.\" + subsection + \".\" + name);\n-            if (subsectionSpecific != null) {\n-                return subsectionSpecific;\n-            }\n+        var subsectionSpecific = gitConfig(\"fork.\" + sourceArg + \".\" + name);\n+        if (subsectionSpecific != null) {\n+            return subsectionSpecific;\n@@ -76,4 +85,7 @@\n-    private static boolean getSwitch(String name, String subsection, Arguments arguments) {\n-        if (arguments.contains(name)) {\n-            return true;\n-        }\n+    private boolean getSwitch(String name) {\n+        var option = getOption(name);\n+        return option != null && option.equalsIgnoreCase(\"true\");\n+    }\n+\n+    private URI getURIFromArgs() {\n+        var hostname = getOption(\"host\");\n@@ -81,4 +93,12 @@\n-        if (subsection != null && !subsection.isEmpty()) {\n-            var subsectionSpecific = gitConfig(\"fork.\" + subsection + \".\" + name);\n-            if (subsectionSpecific != null) {\n-                return subsectionSpecific.toLowerCase().equals(\"true\");\n+        try {\n+            if (hostname != null) {\n+                \/\/ Assume command line argument is just the path component\n+                var extraSlash = sourceArg.startsWith(\"\/\") ? \"\" : \"\/\";\n+                return new URI(\"https:\/\/\" + hostname + extraSlash + sourceArg);\n+            } else {\n+                var uri = new URI(sourceArg);\n+                if (uri.getScheme() == null) {\n+                    return new URI(\"https:\/\/\" + uri.getHost() + uri.getPath());\n+                } else {\n+                    return uri;\n+                }\n@@ -86,0 +106,3 @@\n+        } catch (URISyntaxException e) {\n+            exit(\"error: could not form a valid URI from argument: \" + sourceArg);\n+            return null; \/\/ make compiler quiet\n@@ -87,3 +110,0 @@\n-\n-        var sectionSpecific = gitConfig(\"fork.\" + name);\n-        return sectionSpecific != null && sectionSpecific.toLowerCase().equals(\"true\");\n@@ -92,6 +112,8 @@\n-    private static String gitConfig(String key) {\n-        try {\n-            var pb = new ProcessBuilder(\"git\", \"config\", key);\n-            pb.redirectOutput(ProcessBuilder.Redirect.PIPE);\n-            pb.redirectError(ProcessBuilder.Redirect.DISCARD);\n-            var p = pb.start();\n+    private Path getTargetDir(URI cloneURI) {\n+        if (arguments.at(1).isPresent()) {\n+            \/\/ If user provided an explicit name for target dir, use it\n+            return Path.of(arguments.at(1).asString());\n+        } else {\n+            \/\/ Otherwise get the base name from the URI\n+            var targetDir = Path.of(cloneURI.getPath()).getFileName();\n+            var targetDirStr = targetDir.toString();\n@@ -99,4 +121,4 @@\n-            var output = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\n-            var res = p.waitFor();\n-            if (res != 0) {\n-                return null;\n+            if (targetDirStr.endsWith(\".git\")) {\n+                return Path.of(targetDirStr.substring(0, targetDirStr.length() - \".git\".length()));\n+            } else {\n+                return targetDir;\n@@ -104,6 +126,0 @@\n-\n-            return output == null ? null : output.replace(\"\\n\", \"\");\n-        } catch (InterruptedException e) {\n-            return null;\n-        } catch (IOException e) {\n-            return null;\n@@ -113,1 +129,1 @@\n-    private static Repository clone(List<String> args, String to, boolean isMercurial) throws IOException {\n+    private Repository clone(List<String> args, URI cloneURI, Path targetDir) throws IOException {\n@@ -115,1 +131,0 @@\n-            var vcs = isMercurial ? \"hg\" : \"git\";\n@@ -117,1 +132,1 @@\n-            command.add(vcs);\n+            command.add(\"git\");\n@@ -120,7 +135,10 @@\n-            command.add(to);\n-            var pb = new ProcessBuilder(command);\n-            pb.inheritIO();\n-            var p = pb.start();\n-            var res = p.waitFor();\n-            if (res != 0) {\n-                exit(\"error: '\" + vcs + \" clone \" + String.join(\" \", args) + \"' failed with exit code: \" + res);\n+            command.add(cloneURI.toString());\n+            command.add(targetDir.toString());\n+            if (!isDryRun) {\n+                var pb = new ProcessBuilder(command);\n+                pb.inheritIO();\n+                var p = pb.start();\n+                var res = p.waitFor();\n+                if (res != 0) {\n+                    exit(\"error: '\" + \"git\" + \" clone \" + String.join(\" \", args) + \"' failed with exit code: \" + res);\n+                }\n@@ -128,1 +146,1 @@\n-            return Repository.get(Path.of(to)).orElseThrow(() -> new IOException(\"Could not find repository\"));\n+            return Repository.get(targetDir).orElseThrow(() -> new IOException(\"Could not find repository\"));\n@@ -134,82 +152,1 @@\n-    public static void main(String[] args) throws IOException, InterruptedException {\n-        var flags = List.of(\n-            Option.shortcut(\"u\")\n-                  .fullname(\"username\")\n-                  .describe(\"NAME\")\n-                  .helptext(\"Username on host\")\n-                  .optional(),\n-            Option.shortcut(\"\")\n-                  .fullname(\"reference\")\n-                  .describe(\"DIR\")\n-                  .helptext(\"Same as git clone's flags 'reference-if-able' + 'dissociate'\")\n-                  .optional(),\n-            Option.shortcut(\"\")\n-                  .fullname(\"depth\")\n-                  .describe(\"N\")\n-                  .helptext(\"Same as git clones flag 'depth'\")\n-                  .optional(),\n-            Option.shortcut(\"\")\n-                  .fullname(\"shallow-since\")\n-                  .describe(\"DATE\")\n-                  .helptext(\"Same as git clones flag 'shallow-since'\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"setup-pre-push-hook\")\n-                  .helptext(\"Setup a pre-push hook that runs git-jcheck\")\n-                  .optional(),\n-            Option.shortcut(\"\")\n-                  .fullname(\"host\")\n-                  .describe(\"HOSTNAME\")\n-                  .helptext(\"Hostname for the forge\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"no-clone\")\n-                  .helptext(\"Just fork the repository, do not clone it\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"no-remote\")\n-                  .helptext(\"Do not add an additional git remote\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"ssh\")\n-                  .helptext(\"Use the ssh:\/\/ protocol when cloning\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"https\")\n-                  .helptext(\"Use the https:\/\/ protocol when cloning\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"sync\")\n-                  .helptext(\"Sync with the upstream repository after successful fork\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"verbose\")\n-                  .helptext(\"Turn on verbose output\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"debug\")\n-                  .helptext(\"Turn on debugging output\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"version\")\n-                  .helptext(\"Print the version of this tool\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"mercurial\")\n-                  .helptext(\"Force use of mercurial\")\n-                  .optional());\n-\n-        var inputs = List.of(\n-            Input.position(0)\n-                 .describe(\"URI\")\n-                 .singular()\n-                 .optional(),\n-            Input.position(1)\n-                 .describe(\"NAME\")\n-                 .singular()\n-                 .optional());\n-\n-        var parser = new ArgumentParser(\"git-fork\", flags, inputs);\n-        var arguments = parser.parse(args);\n-        var isMercurial = arguments.contains(\"mercurial\");\n-\n+    public void fork() throws IOException, InterruptedException {\n@@ -226,0 +163,4 @@\n+        if (isDryRun) {\n+            System.out.println(\"Running in dry-run mode. No actual changes will be performed\");\n+        }\n+\n@@ -228,1 +169,5 @@\n-        var subsection = arguments.at(0).isPresent() ? arguments.at(0).asString() : null;\n+        \/\/ Get the upstream repo user specified on the command line\n+        var upstreamURI = getURIFromArgs();\n+        var upstreamWebURI = Remote.toWebURI(upstreamURI.toString());\n+        System.out.println(\"Creating fork of \" + upstreamWebURI);\n+        var credentials = setupCredentials(upstreamWebURI);\n@@ -230,3 +175,4 @@\n-        boolean useSSH = getSwitch(\"ssh\", subsection, arguments);\n-        boolean useHTTPS = getSwitch(\"https\", subsection, arguments);\n-        var hostname = getOption(\"host\", subsection, arguments);\n+        var gitForge = ForgeUtils.from(upstreamWebURI, credentials);\n+        if (gitForge.isEmpty()) {\n+            exit(\"error: could not connect to host \" + upstreamWebURI.getHost());\n+        }\n@@ -234,11 +180,43 @@\n-        URI uri = null;\n-        if (arguments.at(0).isPresent()) {\n-            var arg = arguments.at(0).asString();\n-            if (hostname != null) {\n-                var extraSlash = arg.startsWith(\"\/\") ? \"\" : \"\/\";\n-                uri = URI.create(\"https:\/\/\" + hostname + extraSlash + arg);\n-            } else {\n-                var argURI = URI.create(arg);\n-                uri = argURI.getScheme() == null ?\n-                    URI.create(\"https:\/\/\" + argURI.getHost() + argURI.getPath()) :\n-                    argURI;\n+        var repositoryPath = getTrimmedPath(upstreamWebURI);\n+        var upstreamHostedRepo = gitForge.get().repository(repositoryPath).orElseThrow(() ->\n+            new IOException(\"Could not find repository at \" + upstreamWebURI)\n+        );\n+\n+        \/\/ Create personal fork (\"origin\" from now on) at Git Forge\n+        var originHostedRepo = upstreamHostedRepo.fork();\n+        var originWebURI = originHostedRepo.webUrl();\n+        System.out.println(\"Personal fork available at \" + originWebURI);\n+\n+        if (getSwitch(\"no-clone\")) {\n+            \/\/ We're done here, if we should not create a local clone\n+            logVerbose(\"Not cloning fork due to --no-clone\");\n+            return;\n+        }\n+\n+        \/\/ Create a local clone\n+        var cloneURI = getCloneURI(originWebURI);\n+        System.out.println(\"Cloning personal fork...\");\n+        var repo = clone(getCloneArgs(), cloneURI, getTargetDir(cloneURI));\n+        System.out.println(\"Done cloning\");\n+\n+        \/\/ Setup git remote\n+        if (!getSwitch(\"no-remote\")) {\n+            System.out.println(\"Adding remote 'upstream' for \" + upstreamWebURI);\n+            if (!isDryRun) {\n+                repo.addRemote(\"upstream\", upstreamWebURI.toString());\n+            }\n+        }\n+\n+        \/\/ Sync the fork from upstream\n+        if (getSwitch(\"sync\")) {\n+            logVerbose(\"Syncing personal fork with upstream\");\n+            var syncArgs = new ArrayList<String>();\n+            syncArgs.add(\"--fast-forward\");\n+            if (getSwitch(\"no-remote\")) {\n+                \/\/ Propagate --no-remote; and also specify the remote for git sync to work\n+                syncArgs.add(\"--no-remote\");\n+                syncArgs.add(\"--from\");\n+                syncArgs.add(upstreamWebURI.toString());\n+            }\n+            if (!isDryRun) {\n+                GitSync.sync(repo, syncArgs.toArray(new String[] {}));\n@@ -246,4 +224,0 @@\n-        } else {\n-            var cwd = Path.of(\"\").toAbsolutePath();\n-            var repo = Repository.get(cwd).orElseGet(die(\"error: no git repository found at \" + cwd));\n-            uri = URI.create(repo.pullPath(\"origin\"));\n@@ -252,2 +226,9 @@\n-        if (uri == null) {\n-            exit(\"error: not a valid URI: \" + uri);\n+        \/\/ Setup jcheck hooks\n+        if (getSwitch(\"setup-pre-push-hook\")) {\n+            logVerbose(\"Setting up jcheck hooks\");\n+            if (!isDryRun) {\n+                var res = GitJCheck.run(repo, new String[] {\"--setup-pre-push-hook\"});\n+                if (res != 0) {\n+                    System.exit(res);\n+                }\n+            }\n@@ -255,0 +236,1 @@\n+    }\n@@ -256,4 +238,5 @@\n-        var webURI = Remote.toWebURI(uri.toString());\n-        var token = isMercurial ? System.getenv(\"HG_TOKEN\") : System.getenv(\"GIT_TOKEN\");\n-        var username = getOption(\"username\", subsection, arguments);\n-        var credentials = GitCredentials.fill(webURI.getHost(), webURI.getPath(), username, token, webURI.getScheme());\n+    private Credential setupCredentials(URI upstreamWebURI) throws IOException {\n+        var token = System.getenv(\"GIT_TOKEN\");\n+        var username = getOption(\"username\");\n+\n+        var credentials = GitCredentials.fill(upstreamWebURI.getHost(), upstreamWebURI.getPath(), username, token, upstreamWebURI.getScheme());\n@@ -265,1 +248,4 @@\n-            exit(\"error: no username for \" + webURI.getHost() + \" found, use git-credentials or the flag --username\");\n+            exit(\"error: no username for \" + upstreamWebURI.getHost() + \" found, use git-credentials or the flag --username\");\n+        }\n+        if (token == null) {\n+            GitCredentials.approve(credentials);\n@@ -267,0 +253,2 @@\n+        return new Credential(credentials.username(), credentials.password());\n+    }\n@@ -268,3 +256,5 @@\n-        var host = ForgeUtils.from(webURI, new Credential(credentials.username(), credentials.password()));\n-        if (host.isEmpty()) {\n-            exit(\"error: could not connect to host \" + webURI.getHost());\n+    private URI getCloneURI(URI originWebURI) {\n+        if (getSwitch(\"ssh\")) {\n+            return URI.create(\"ssh:\/\/git@\" + originWebURI.getHost() + originWebURI.getPath() + \".git\");\n+        } else {\n+            return originWebURI;\n@@ -272,0 +262,1 @@\n+    }\n@@ -273,1 +264,2 @@\n-        var repositoryPath = webURI.getPath().substring(1);\n+    private ArrayList<String> getCloneArgs() {\n+        var cloneArgs = new ArrayList<String>();\n@@ -275,3 +267,4 @@\n-        if (repositoryPath.endsWith(\"\/\")) {\n-            repositoryPath =\n-                    repositoryPath.substring(0, repositoryPath.length() - 1);\n+        var reference = getOption(\"reference\");\n+        if (reference != null) {\n+            cloneArgs.add(\"--reference-if-able=\" + expandPath(reference));\n+            cloneArgs.add(\"--dissociate\");\n@@ -280,7 +273,3 @@\n-        var hostedRepo = host.get().repository(repositoryPath).orElseThrow(() ->\n-            new IOException(\"Could not find repository at \" + webURI.toString())\n-        );\n-\n-        var fork = hostedRepo.fork();\n-        if (token == null) {\n-            GitCredentials.approve(credentials);\n+        var depth = getOption(\"depth\");\n+        if (depth != null) {\n+            cloneArgs.add(\"--depth=\" + depth);\n@@ -289,3 +278,3 @@\n-        var forkWebUrl = fork.webUrl();\n-        if (isMercurial) {\n-            forkWebUrl = URI.create(\"git+\" + forkWebUrl.toString());\n+        var shallowSince = getOption(\"shallow-since\");\n+        if (shallowSince != null) {\n+            cloneArgs.add(\"--shallow-since=\" + shallowSince);\n@@ -294,27 +283,7 @@\n-        boolean noClone = getSwitch(\"no-clone\", subsection, arguments);\n-        boolean noRemote = getSwitch(\"no-remote\", subsection, arguments);\n-        boolean shouldSync = getSwitch(\"sync\", subsection, arguments);\n-        if (noClone || !arguments.at(0).isPresent()) {\n-            if (!arguments.at(0).isPresent()) {\n-                var cwd = Path.of(\"\").toAbsolutePath();\n-                var repo = Repository.get(cwd).orElseGet(die(\"error: no git repository found at \" + cwd));\n-\n-                var forkURL = useSSH ?\n-                    \"ssh:\/\/git@\" + forkWebUrl.getHost() + forkWebUrl.getPath() :\n-                    forkWebUrl.toString();\n-                System.out.println(forkURL);\n-\n-                if (!noRemote) {\n-                    var remoteWord = isMercurial ? \"path\" : \"remote\";\n-                    System.out.print(\"Adding \" + remoteWord + \" 'clone' for \" + forkURL + \"...\");\n-                    if (isMercurial) {\n-                        forkURL = \"git+\" + forkURL;\n-                    }\n-                    repo.addRemote(\"fork\", forkURL);\n-                    System.out.println(\"done\");\n-\n-                    if (shouldSync) {\n-                        GitSync.sync(repo, new String[]{\"--from\", \"origin\", \"--to\", \"fork\"});\n-                    }\n-                }\n-            }\n+        return cloneArgs;\n+    }\n+\n+    private static String expandPath(String path) {\n+        \/\/ FIXME: Why is this not done from the shell? It should not be needed.\n+        if (path.startsWith(\"~\" + File.separator)) {\n+            return System.getProperty(\"user.home\") + path.substring(1);\n@@ -322,6 +291,3 @@\n-            var reference = getOption(\"reference\", subsection, arguments);\n-            if (reference != null && reference.startsWith(\"~\" + File.separator)) {\n-                reference = System.getProperty(\"user.home\") + reference.substring(1);\n-            }\n-            var depth = getOption(\"depth\", subsection, arguments);\n-            var shallowSince = getOption(\"shallow-since\", subsection, arguments);\n+            return path;\n+        }\n+    }\n@@ -329,14 +295,2 @@\n-            URI cloneURI = null;\n-            if (hostname != null) {\n-                if (useSSH) {\n-                    cloneURI = URI.create(\"ssh:\/\/git@\" + forkWebUrl.getHost() + forkWebUrl.getPath() + \".git\");\n-                } else {\n-                    cloneURI = URI.create(\"https:\/\/\" + forkWebUrl.getHost() + forkWebUrl.getPath());\n-                }\n-            } else {\n-                if (useSSH) {\n-                    cloneURI = URI.create(\"ssh:\/\/git@\" + forkWebUrl.getHost() + forkWebUrl.getPath() + \".git\");\n-                } else {\n-                    cloneURI = forkWebUrl;\n-                }\n-            }\n+    private static String getTrimmedPath(URI uri) {\n+        var repositoryPath = uri.getPath().substring(1);\n@@ -344,2 +298,6 @@\n-            System.out.println(\"Fork available at: \" + forkWebUrl);\n-            System.out.println(\"Cloning \" + cloneURI + \"...\");\n+        if (repositoryPath.endsWith(\"\/\")) {\n+            return repositoryPath.substring(0, repositoryPath.length() - 1);\n+        } else {\n+            return repositoryPath;\n+        }\n+    }\n@@ -347,12 +305,5 @@\n-            var cloneArgs = new ArrayList<String>();\n-            if (reference != null) {\n-                cloneArgs.add(\"--reference-if-able=\" + reference);\n-                cloneArgs.add(\"--dissociate\");\n-            }\n-            if (depth != null) {\n-                cloneArgs.add(\"--depth=\" + depth);\n-            }\n-            if (shallowSince != null) {\n-                cloneArgs.add(\"--shallow-since=\" + shallowSince);\n-            }\n-            cloneArgs.add(cloneURI.toString());\n+    private void logVerbose(String message) {\n+        if (arguments.contains(\"verbose\") || arguments.contains(\"debug\")) {\n+            System.out.println(message);\n+        }\n+    }\n@@ -360,17 +311,4 @@\n-            var defaultTo = Path.of(cloneURI.getPath()).getFileName().toString();\n-            if (defaultTo.endsWith(\".git\")) {\n-                defaultTo = defaultTo.substring(0, defaultTo.length() - \".git\".length());\n-            }\n-            String to = arguments.at(1).isPresent() ?\n-                arguments.at(1).asString() :\n-                defaultTo;\n-            var repo = clone(cloneArgs, to, isMercurial);\n-\n-            if (!noRemote) {\n-                var remoteWord = isMercurial ? \"path\" : \"remote\";\n-                System.out.print(\"Adding \" + remoteWord + \" 'upstream' for \" + webURI.toString() + \"...\");\n-                var upstreamUrl = webURI.toString();\n-                if (isMercurial) {\n-                    upstreamUrl = \"git+\" + upstreamUrl;\n-                }\n-                repo.addRemote(\"upstream\", upstreamUrl);\n+    private static void exit(String message) {\n+        System.err.println(message);\n+        System.exit(1);\n+    }\n@@ -378,1 +316,6 @@\n-                System.out.println(\"done\");\n+    private static <T> Supplier<T> die(String message) {\n+        return () -> {\n+            exit(message);\n+            return null;\n+        };\n+    }\n@@ -380,3 +323,63 @@\n-                if (shouldSync) {\n-                    GitSync.sync(repo, new String[]{\"--from\", \"upstream\", \"--to\", \"origin\", \"--fast-forward\"});\n-                }\n+    private static Arguments parseArguments(String[] args) {\n+        var flags = List.of(\n+                Option.shortcut(\"u\")\n+                        .fullname(\"username\")\n+                        .describe(\"NAME\")\n+                        .helptext(\"Username on host\")\n+                        .optional(),\n+                Option.shortcut(\"\")\n+                        .fullname(\"reference\")\n+                        .describe(\"DIR\")\n+                        .helptext(\"Same as the 'git clone' flags 'reference-if-able' + 'dissociate'\")\n+                        .optional(),\n+                Option.shortcut(\"\")\n+                        .fullname(\"depth\")\n+                        .describe(\"N\")\n+                        .helptext(\"Same as the 'git clone' flag 'depth'\")\n+                        .optional(),\n+                Option.shortcut(\"\")\n+                        .fullname(\"shallow-since\")\n+                        .describe(\"DATE\")\n+                        .helptext(\"Same as the 'git clone' flag 'shallow-since'\")\n+                        .optional(),\n+                Switch.shortcut(\"\")\n+                        .fullname(\"setup-pre-push-hook\")\n+                        .helptext(\"Setup a pre-push hook that runs git-jcheck\")\n+                        .optional(),\n+                Option.shortcut(\"\")\n+                        .fullname(\"host\")\n+                        .describe(\"HOSTNAME\")\n+                        .helptext(\"Hostname for the forge\")\n+                        .optional(),\n+                Switch.shortcut(\"\")\n+                        .fullname(\"no-clone\")\n+                        .helptext(\"Just fork the repository, do not clone it\")\n+                        .optional(),\n+                Switch.shortcut(\"\")\n+                        .fullname(\"no-remote\")\n+                        .helptext(\"Do not add an upstream git remote\")\n+                        .optional(),\n+                Switch.shortcut(\"\")\n+                        .fullname(\"ssh\")\n+                        .helptext(\"Use the ssh:\/\/ protocol when cloning (instead of https)\")\n+                        .optional(),\n+                Switch.shortcut(\"\")\n+                        .fullname(\"sync\")\n+                        .helptext(\"Sync with the upstream repository after successful fork\")\n+                        .optional(),\n+                Switch.shortcut(\"n\")\n+                        .fullname(\"dry-run\")\n+                        .helptext(\"Only simulate behavior, do no actual changes\")\n+                        .optional(),\n+                Switch.shortcut(\"\")\n+                        .fullname(\"verbose\")\n+                        .helptext(\"Turn on verbose output\")\n+                        .optional(),\n+                Switch.shortcut(\"\")\n+                        .fullname(\"debug\")\n+                        .helptext(\"Turn on debugging output\")\n+                        .optional(),\n+                Switch.shortcut(\"\")\n+                        .fullname(\"version\")\n+                        .helptext(\"Print the version of this tool\")\n+                        .optional());\n@@ -384,9 +387,17 @@\n-                var setupPrePushHooksOption = getOption(\"setup-pre-push-hook\", subsection, arguments);\n-                if (setupPrePushHooksOption != null) {\n-                    var res = GitJCheck.run(repo, new String[]{\"--setup-pre-push-hook\"});\n-                    if (res != 0) {\n-                        System.exit(res);\n-                    }\n-                }\n-            }\n-        }\n+        var inputs = List.of(\n+                Input.position(0)\n+                        .describe(\"URI\")\n+                        .singular()\n+                        .required(),\n+                Input.position(1)\n+                        .describe(\"NAME\")\n+                        .singular()\n+                        .optional());\n+\n+        var parser = new ArgumentParser(\"git fork\", flags, inputs);\n+        return parser.parse(args);\n+    }\n+\n+    public static void main(String[] args) throws IOException, InterruptedException {\n+        GitFork commandExecutor = new GitFork(parseArguments(args));\n+        commandExecutor.fork();\n","filename":"cli\/src\/main\/java\/org\/openjdk\/skara\/cli\/GitFork.java","additions":292,"deletions":281,"binary":false,"changes":573,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import org.openjdk.skara.forge.*;\n@@ -39,5 +38,8 @@\n-    private static IOException die(String message) {\n-        System.err.println(message);\n-        System.exit(1);\n-        return new IOException(\"will never reach here\");\n-    }\n+    private final Repository repo;\n+    private final Arguments arguments;\n+    private final List<String> remotes;\n+    private final boolean isDryRun;\n+    private String targetName;\n+    private URI targetURI;\n+    private String sourceName;\n+    private URI sourceURI;\n@@ -45,5 +47,5 @@\n-    private static int pull(Repository repo) throws IOException, InterruptedException {\n-        var pb = new ProcessBuilder(\"git\", \"pull\");\n-        pb.directory(repo.root().toFile());\n-        pb.inheritIO();\n-        return pb.start().waitFor();\n+    private GitSync(Repository repo, Arguments arguments) throws IOException {\n+        this.repo = repo;\n+        this.arguments = arguments;\n+        this.remotes = repo.remotes();\n+        this.isDryRun = arguments.contains(\"dry-run\");\n@@ -52,5 +54,4 @@\n-    private static int mergeFastForward(Repository repo, String ref) throws IOException, InterruptedException {\n-        var pb = new ProcessBuilder(\"git\", \"merge\", \"--ff-only\", \"--quiet\", ref);\n-        pb.directory(repo.root().toFile());\n-        pb.inheritIO();\n-        return pb.start().waitFor();\n+    private void logVerbose(String message) {\n+        if (arguments.contains(\"verbose\") || arguments.contains(\"debug\")) {\n+            System.out.println(message);\n+        }\n@@ -59,5 +60,13 @@\n-    private static int moveBranch(Repository repo, Branch branch, Hash to) throws IOException, InterruptedException {\n-        var pb = new ProcessBuilder(\"git\", \"branch\", \"--force\", branch.name(), to.hex());\n-        pb.directory(repo.root().toFile());\n-        pb.inheritIO();\n-        return pb.start().waitFor();\n+    private URI getRemoteURI(String name) throws IOException {\n+        if (name != null) {\n+            if (remotes.contains(name)) {\n+                return Remote.toURI(repo.pullPath(name));\n+            } else {\n+                try {\n+                    return Remote.toURI(name);\n+                } catch (IOException e) {\n+                    die(name + \" is not a known git remote, nor a proper git URI\");\n+                }\n+            }\n+        }\n+        return null;\n@@ -66,1 +75,1 @@\n-    private static String getOption(String name, Arguments arguments, ReadOnlyRepository repo) throws IOException {\n+    private String getOption(String name) throws IOException {\n@@ -75,48 +84,11 @@\n-    static void sync(Repository repo, String[] args) throws IOException, InterruptedException {\n-        var flags = List.of(\n-            Option.shortcut(\"\")\n-                  .fullname(\"from\")\n-                  .describe(\"REMOTE\")\n-                  .helptext(\"Fetch changes from this remote\")\n-                  .optional(),\n-            Option.shortcut(\"\")\n-                  .fullname(\"to\")\n-                  .describe(\"REMOTE\")\n-                  .helptext(\"Push changes to this remote\")\n-                  .optional(),\n-            Option.shortcut(\"\")\n-                  .fullname(\"branches\")\n-                  .describe(\"BRANCHES\")\n-                  .helptext(\"Comma separated list of branches to sync\")\n-                  .optional(),\n-            Option.shortcut(\"\")\n-                  .fullname(\"ignore\")\n-                  .describe(\"PATTERN\")\n-                  .helptext(\"Regular expression of branches to ignore\")\n-                  .optional(),\n-            Option.shortcut(\"u\")\n-                  .fullname(\"username\")\n-                  .describe(\"NAME\")\n-                  .helptext(\"Username on forge\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"pull\")\n-                  .helptext(\"Pull current branch from origin after successful sync\")\n-                  .optional(),\n-            Switch.shortcut(\"ff\")\n-                  .fullname(\"fast-forward\")\n-                  .helptext(\"Fast forward all local branches where possible\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"verbose\")\n-                  .helptext(\"Turn on verbose output\")\n-                  .optional(),\n-            Switch.shortcut(\"\")\n-                  .fullname(\"debug\")\n-                  .helptext(\"Turn on debugging output\")\n-                  .optional(),\n-            Switch.shortcut(\"v\")\n-                  .fullname(\"version\")\n-                  .helptext(\"Print the version of this tool\")\n-                  .optional()\n-        );\n+    private void syncBranch(String name) throws IOException {\n+        Hash fetchHead = null;\n+        logVerbose(\"Fetching branch \" + name + \" from  \" + sourceURI);\n+        if (!isDryRun) {\n+            fetchHead = repo.fetch(sourceURI, name);\n+        }\n+        logVerbose(\"Pushing to \" + targetURI);\n+        if (!isDryRun) {\n+            repo.push(fetchHead, targetURI, name);\n+        }\n+    }\n@@ -124,2 +96,2 @@\n-        var parser = new ArgumentParser(\"git sync\", flags);\n-        var arguments = parser.parse(args);\n+    private void fetchTarget() throws IOException {\n+        if (isDryRun) return;\n@@ -127,3 +99,12 @@\n-        if (arguments.contains(\"version\")) {\n-            System.out.println(\"git-sync version: \" + Version.fromManifest().orElse(\"unknown\"));\n-            System.exit(0);\n+        repo.fetchRemote(targetName);\n+    }\n+\n+    private void pull() throws IOException, InterruptedException {\n+        if (isDryRun) return;\n+\n+        var pb = new ProcessBuilder(\"git\", \"pull\");\n+        pb.directory(repo.root().toFile());\n+        pb.inheritIO();\n+        var result = pb.start().waitFor();\n+        if (result != 0) {\n+            die(\"Failure running git pull, exit code \" + result);\n@@ -131,0 +112,1 @@\n+    }\n@@ -132,3 +114,10 @@\n-        if (arguments.contains(\"verbose\") || arguments.contains(\"debug\")) {\n-            var level = arguments.contains(\"debug\") ? Level.FINER : Level.FINE;\n-            Logging.setup(level);\n+    private void mergeFastForward(String ref) throws IOException, InterruptedException {\n+        if (isDryRun) return;\n+\n+        var pb = new ProcessBuilder(\"git\", \"merge\", \"--ff-only\", \"--quiet\", ref);\n+        pb.directory(repo.root().toFile());\n+        pb.inheritIO();\n+        var result = pb.start().waitFor();\n+\n+        if (result != 0) {\n+            die(\"Failure running git merge, exit code \" + result);\n@@ -136,0 +125,1 @@\n+    }\n@@ -137,0 +127,2 @@\n+    private void moveBranch(Branch branch, Hash to) throws IOException, InterruptedException {\n+        if (isDryRun) return;\n@@ -138,1 +130,4 @@\n-        HttpProxy.setup();\n+        var pb = new ProcessBuilder(\"git\", \"branch\", \"--force\", branch.name(), to.hex());\n+        pb.directory(repo.root().toFile());\n+        pb.inheritIO();\n+        var result = pb.start().waitFor();\n@@ -140,1 +135,4 @@\n-        var remotes = repo.remotes();\n+        if (result != 0) {\n+            die(\"Failure running git branch, exit code \" + result);\n+        }\n+    }\n@@ -142,7 +140,13 @@\n-        String from = null;\n-        if (arguments.contains(\"from\")) {\n-            from = arguments.get(\"from\").asString();\n-        } else {\n-            var lines = repo.config(\"sync.from\");\n-            if (lines.size() == 1 && remotes.contains(lines.get(0))) {\n-                from = lines.get(0);\n+    private void setupTargetAndSource() throws IOException {\n+        String targetFromOptions = getOption(\"to\");\n+        URI targetFromOptionsURI = getRemoteURI(targetFromOptions);\n+\n+        String sourceFromOptions = getOption(\"from\");\n+        URI sourceFromOptionsURI = getRemoteURI(sourceFromOptions);\n+\n+        \/\/ Find push target repo\n+        if (!remotes.contains(\"origin\")) {\n+            if (targetFromOptions != null) {\n+                \/\/ If 'origin' is missing but we have command line arguments, use these instead\n+                targetName = targetFromOptions;\n+                targetURI = targetFromOptionsURI;\n@@ -150,5 +154,11 @@\n-                if (remotes.contains(\"upstream\")) {\n-                    from = \"upstream\";\n-                } else if (remotes.contains(\"origin\")) {\n-                    if (remotes.contains(\"fork\")) {\n-                        from = \"origin\";\n+                die(\"repo does not have an 'origin' remote defined\");\n+            }\n+        } else {\n+            targetName = \"origin\";\n+            targetURI = Remote.toURI(repo.pullPath(targetName));\n+            if (targetFromOptions != null) {\n+                if (!equalsCanonicalized(targetFromOptionsURI, targetURI)) {\n+                    if (arguments.contains(\"force\")) {\n+                        logVerbose(\"Overriding target 'origin' with \" + targetFromOptions + \" due to --force\");\n+                        targetName = targetFromOptions;\n+                        targetURI = targetFromOptionsURI;\n@@ -156,11 +166,1 @@\n-                        var originPullPath = repo.pullPath(\"origin\");\n-                        try {\n-                            var uri = Remote.toWebURI(originPullPath);\n-                            from = ForgeUtils.from(uri)\n-                                             .flatMap(f -> f.repository(uri.getPath().substring(1)))\n-                                             .flatMap(r -> r.parent())\n-                                             .map(p -> p.webUrl().toString())\n-                                             .orElse(null);\n-                        } catch (Throwable e) {\n-                            from = null;\n-                        }\n+                        die(\"git 'origin' remote and '--to' argument differ. Consider using --force.\");\n@@ -172,19 +172,15 @@\n-        if (from == null) {\n-            System.err.println(\"error: could not find repository to sync from, please specify one with --from\");\n-            System.err.println(\"       or add a remote named 'upstream'\");\n-            System.exit(1);\n-        }\n-\n-        var fromPullPath = remotes.contains(from) ?\n-            Remote.toURI(repo.pullPath(from)) : Remote.toURI(from);\n-        var fromScheme = fromPullPath.getScheme();\n-        if (fromScheme.equals(\"https\") || fromScheme.equals(\"http\")) {\n-            var token = System.getenv(\"GIT_TOKEN\");\n-            var username = getOption(\"username\", arguments, repo);\n-            var credentials = GitCredentials.fill(fromPullPath.getHost(),\n-                                                  fromPullPath.getPath(),\n-                                                  username,\n-                                                  token,\n-                                                  fromScheme);\n-            if (credentials.password() != null && credentials.username() != null && token != null) {\n-                fromPullPath = URI.create(fromScheme + \":\/\/\" + credentials.username() + \":\" + credentials.password() + \"@\" + fromPullPath.getHost() + fromPullPath.getPath());\n+        \/\/ Find pull source as given by the Git Forge as the repository's parent\n+        var forgeWebURI = Remote.toWebURI(targetURI.toString());\n+        URI sourceParentURI;\n+        String sourceParentName;\n+        try {\n+            sourceParentURI = ForgeUtils.from(forgeWebURI)\n+                    .flatMap(f -> f.repository(forgeWebURI.getPath().substring(1)))\n+                    .flatMap(r -> r.parent())\n+                    .map(p -> p.webUrl())\n+                    .orElse(null);\n+            sourceParentName = sourceParentURI.toString();\n+            logVerbose(\"Git Forge reports upstream parent is \" + sourceParentURI);\n+        } catch (Throwable e) {\n+            if (arguments.contains(\"debug\")) {\n+                e.printStackTrace();\n@@ -192,0 +188,6 @@\n+            if (!arguments.contains(\"force\")) {\n+                \/\/ Unless we force a different recipient repo, we are not allowed to have an error here\n+                die(\"cannot get parent repo from Git Forge provider for \" + forgeWebURI);\n+            }\n+            sourceParentURI = null;\n+            sourceParentName = null;\n@@ -194,8 +196,11 @@\n-        String to = null;\n-        if (arguments.contains(\"to\")) {\n-            to = arguments.get(\"to\").asString();\n-        } else {\n-            var lines = repo.config(\"sync.to\");\n-            if (lines.size() == 1) {\n-                if (!remotes.contains(lines.get(0))) {\n-                    die(\"The given remote to push to, \" + lines.get(0) + \", does not exist\");\n+        sourceURI = sourceParentURI;\n+        sourceName = sourceParentName;\n+\n+        \/\/ Find pull source as given by Git's 'upstream' remote\n+        if (remotes.contains(\"upstream\")) {\n+            sourceName = \"upstream\";\n+            var sourceUpstreamURI = Remote.toURI(repo.pullPath(\"upstream\"));\n+            if (!equalsCanonicalized(sourceUpstreamURI, sourceParentURI)) {\n+                if (arguments.contains(\"force\")) {\n+                    sourceURI = sourceUpstreamURI;\n+                    logVerbose(\"Replacing Git Forge parent with \" + sourceUpstreamURI + \" from 'upstream' remote\");\n@@ -203,1 +208,6 @@\n-                    to = lines.get(0);\n+                    System.err.println(\"error: git 'upstream' remote and the parent fork given by the Git Forge differ\");\n+                    System.err.println(\"       Git 'upstream' remote is \" + sourceUpstreamURI);\n+                    System.err.println(\"       Git Forge parent is \" + sourceParentURI);\n+                    System.err.println(\"       Remove incorrect 'upstream' remote with 'git remote remove upstream'\");\n+                    System.err.println(\"       or run with --force to use 'upstream' remote anyway\");\n+                    System.exit(1);\n@@ -205,3 +215,19 @@\n-            } else {\n-                if (remotes.contains(\"fork\")) {\n-                    to = \"fork\";\n+            }\n+        } else {\n+            \/\/ Repo is badly configured, fix it unless instructed not to\n+            if (!arguments.contains(\"no-remote\")) {\n+                System.out.println(\"Setting 'upstream' remote to \" + sourceParentURI);\n+                if (!isDryRun) {\n+                    repo.addRemote(\"upstream\", sourceParentURI.toString());\n+                }\n+            }\n+        }\n+\n+        \/\/ Find pull source as given by command line options\n+        if (sourceFromOptions != null) {\n+            if (!equalsCanonicalized(sourceFromOptionsURI, sourceURI)) {\n+                if (arguments.contains(\"force\")) {\n+                    \/\/ Use the value from the option instead\n+                    sourceName = sourceFromOptions;\n+                    sourceURI = sourceFromOptionsURI;\n+                    logVerbose(\"Replacing source repo with \" + sourceFromOptionsURI + \" from command line options\");\n@@ -209,1 +235,1 @@\n-                    to = \"origin\";\n+                    die(\"Git Forge parent and git sync '--from' option do not match\");\n@@ -214,2 +240,5 @@\n-        var toPushPath = remotes.contains(to) ?\n-            Remote.toURI(repo.pullPath(to)) : Remote.toURI(to);\n+        if (sourceURI == null) {\n+            System.err.println(\"error: could not find repository to sync from, please specify one with --from\");\n+            System.err.println(\"       or add a remote named 'upstream'\");\n+            System.exit(1);\n+        }\n@@ -217,4 +246,2 @@\n-        var canonicalPushPath = Remote.toWebURI(Remote.canonicalize(toPushPath).toString());\n-        var canonicalPullPath = Remote.toWebURI(Remote.canonicalize(fromPullPath).toString());\n-        if (canonicalPushPath.equals(canonicalPullPath)) {\n-            System.err.println(\"error: --from and --to refer to the same repository: \" + canonicalPushPath.toString());\n+        if (equalsCanonicalized(targetURI, sourceURI)) {\n+            System.err.println(\"error: --from and --to refer to the same repository: \" + targetURI);\n@@ -223,0 +250,16 @@\n+    }\n+\n+    private void setupCredentials() throws IOException {\n+        var sourceScheme = sourceURI.getScheme();\n+        if (sourceScheme.equals(\"https\") || sourceScheme.equals(\"http\")) {\n+            var token = System.getenv(\"GIT_TOKEN\");\n+            var username = getOption(\"username\");\n+            var credentials = GitCredentials.fill(sourceURI.getHost(),\n+                    sourceURI.getPath(),\n+                    username,\n+                    token,\n+                    sourceScheme);\n+            if (credentials.password() != null && credentials.username() != null && token != null) {\n+                sourceURI = URI.create(sourceScheme + \":\/\/\" + credentials.username() + \":\" + credentials.password() + \"@\" + sourceURI.getHost() + sourceURI.getPath());\n+            }\n+        }\n@@ -224,2 +267,2 @@\n-        var toScheme = toPushPath.getScheme();\n-        if (toScheme.equals(\"https\") || toScheme.equals(\"http\")) {\n+        var targetScheme = targetURI.getScheme();\n+        if (targetScheme.equals(\"https\") || targetScheme.equals(\"http\")) {\n@@ -227,6 +270,6 @@\n-            var username = getOption(\"username\", arguments, repo);\n-            var credentials = GitCredentials.fill(toPushPath.getHost(),\n-                                                  toPushPath.getPath(),\n-                                                  username,\n-                                                  token,\n-                                                  toScheme);\n+            var username = getOption(\"username\");\n+            var credentials = GitCredentials.fill(targetURI.getHost(),\n+                    targetURI.getPath(),\n+                    username,\n+                    token,\n+                    targetScheme);\n@@ -234,1 +277,1 @@\n-                die(\"error: no personal access token found, use git-credentials or the environment variable GIT_TOKEN\");\n+                die(\"no personal access token found, use git-credentials or the environment variable GIT_TOKEN\");\n@@ -237,1 +280,1 @@\n-                die(\"error: no username for \" + toPushPath.getHost() + \" found, use git-credentials or the flag --username\");\n+                die(\"no username for \" + targetURI.getHost() + \" found, use git-credentials or the flag --username\");\n@@ -240,2 +283,2 @@\n-                toPushPath = URI.create(toScheme + \":\/\/\" + credentials.username() + \":\" + credentials.password() + \"@\" +\n-                                        toPushPath.getHost() + toPushPath.getPath());\n+                targetURI = URI.create(targetScheme + \":\/\/\" + credentials.username() + \":\" + credentials.password() + \"@\" +\n+                        targetURI.getHost() + targetURI.getPath());\n@@ -246,0 +289,25 @@\n+    }\n+\n+    public void sync() throws IOException, InterruptedException {\n+        if (arguments.contains(\"version\")) {\n+            System.out.println(\"git-sync version: \" + Version.fromManifest().orElse(\"unknown\"));\n+            System.exit(0);\n+        }\n+\n+        if (arguments.contains(\"verbose\") || arguments.contains(\"debug\")) {\n+            var level = arguments.contains(\"debug\") ? Level.FINER : Level.FINE;\n+            Logging.setup(level);\n+        }\n+\n+        if (isDryRun) {\n+            System.out.println(\"Running in dry-run mode. No actual changes will be performed\");\n+        }\n+\n+        HttpProxy.setup();\n+\n+        \/\/ Setup source (from, upstream) and target (to, origin) repo names and URIs\n+        setupTargetAndSource();\n+        System.out.println(\"Will sync changes from \" + sourceURI + \" to \" + targetURI);\n+\n+        \/\/ Assure we have proper credentials for pull and push operations\n+        setupCredentials();\n@@ -273,1 +341,1 @@\n-        var remoteBranches = repo.remoteBranches(from);\n+        var remoteBranches = repo.remoteBranches(sourceName);\n@@ -277,3 +345,1 @@\n-                if (arguments.contains(\"verbose\") || arguments.contains(\"debug\")) {\n-                    System.out.println(\"Skipping branch \" + name);\n-                }\n+                logVerbose(\"Skipping branch \" + name);\n@@ -283,3 +349,1 @@\n-                if (arguments.contains(\"verbose\") || arguments.contains(\"debug\")) {\n-                    System.out.println(\"Skipping branch \" + name);\n-                }\n+                logVerbose(\"Skipping branch \" + name);\n@@ -288,5 +352,4 @@\n-            System.out.print(\"Syncing \" + from + \"\/\" + name + \" to \" + to + \"\/\" + name + \"... \");\n-            System.out.flush();\n-            var fetchHead = repo.fetch(fromPullPath, branch.name());\n-            repo.push(fetchHead, toPushPath, name);\n-            System.out.println(\"done\");\n+\n+            System.out.println(\"Syncing \" + sourceName + \"\/\" + name + \" to \" + targetName + \"\/\" + name + \"... \");\n+            syncBranch(name);\n+            System.out.println(\"Done syncing\");\n@@ -298,1 +361,1 @@\n-            shouldPull = lines.size() == 1 && lines.get(0).toLowerCase().equals(\"true\");\n+            shouldPull = lines.size() == 1 && lines.get(0).equalsIgnoreCase(\"true\");\n@@ -305,4 +368,2 @@\n-                    int err = pull(repo);\n-                    if (err != 0) {\n-                        System.exit(err);\n-                    }\n+                    logVerbose(\"Pulling from \" + repo);\n+                    pull();\n@@ -316,1 +377,1 @@\n-            shouldFastForward = lines.size() == 1 && lines.get(0).toLowerCase().equals(\"true\");\n+            shouldFastForward = lines.size() == 1 && lines.get(0).equalsIgnoreCase(\"true\");\n@@ -319,2 +380,2 @@\n-            if (!remotes.contains(to)) {\n-                die(\"error: --fast-forward can only be used when --to is the name of a remote\");\n+            if (!remotes.contains(targetName)) {\n+                die(\"--fast-forward can only be used when --to is the name of a remote\");\n@@ -322,1 +383,2 @@\n-            repo.fetchRemote(to);\n+            logVerbose(\"Fetching from remote \" + targetName);\n+            fetchTarget();\n@@ -326,1 +388,1 @@\n-                remoteBranchNames.add(to + \"\/\" + branch.name());\n+                remoteBranchNames.add(targetName + \"\/\" + branch.name());\n@@ -339,5 +401,6 @@\n-                        var err = currentBranch.isPresent() && branch.equals(currentBranch.get()) ?\n-                            mergeFastForward(repo, upstreamBranch.get()) :\n-                            moveBranch(repo, branch, upstreamHash.get());\n-                        if (err != 0) {\n-                            System.exit(1);\n+                        if (currentBranch.isPresent() && branch.equals(currentBranch.get())) {\n+                            logVerbose(\"Fast-forwarding current branch\");\n+                            mergeFastForward(upstreamBranch.get());\n+                        } else {\n+                            logVerbose(\"Fast-forwarding branch \" + upstreamBranch.get());\n+                            moveBranch(branch, upstreamHash.get());\n@@ -351,0 +414,89 @@\n+    private static IOException die(String message) {\n+        System.err.println(\"error: \" + message);\n+        System.exit(1);\n+        return new IOException(\"will never reach here\");\n+    }\n+\n+    private static boolean equalsCanonicalized(URI a, URI b) throws IOException {\n+        if (a == null || b == null) {\n+            if (a == null && b == null) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        var canonicalA = Remote.toWebURI(Remote.canonicalize(a).toString());\n+        var canonicalB = Remote.toWebURI(Remote.canonicalize(b).toString());\n+        return canonicalA.equals(canonicalB);\n+    }\n+\n+    private static Arguments parseArguments(String[] args) {\n+        var flags = List.of(\n+            Option.shortcut(\"\")\n+                  .fullname(\"from\")\n+                  .describe(\"REMOTE\")\n+                  .helptext(\"Fetch changes from this remote\")\n+                  .optional(),\n+            Option.shortcut(\"\")\n+                  .fullname(\"to\")\n+                  .describe(\"REMOTE\")\n+                  .helptext(\"Push changes to this remote\")\n+                  .optional(),\n+            Option.shortcut(\"\")\n+                  .fullname(\"branches\")\n+                  .describe(\"BRANCHES\")\n+                  .helptext(\"Comma separated list of branches to sync\")\n+                  .optional(),\n+            Option.shortcut(\"\")\n+                  .fullname(\"ignore\")\n+                  .describe(\"PATTERN\")\n+                  .helptext(\"Regular expression of branches to ignore\")\n+                  .optional(),\n+            Option.shortcut(\"u\")\n+                  .fullname(\"username\")\n+                  .describe(\"NAME\")\n+                  .helptext(\"Username on forge\")\n+                  .optional(),\n+            Switch.shortcut(\"\")\n+                  .fullname(\"pull\")\n+                  .helptext(\"Pull current branch from origin after successful sync\")\n+                  .optional(),\n+            Switch.shortcut(\"ff\")\n+                  .fullname(\"fast-forward\")\n+                  .helptext(\"Fast forward all local branches where possible\")\n+                  .optional(),\n+            Switch.shortcut(\"\")\n+                   .fullname(\"no-remote\")\n+                   .helptext(\"Do not add an additional git remote\")\n+                   .optional(),\n+            Switch.shortcut(\"n\")\n+                   .fullname(\"dry-run\")\n+                   .helptext(\"Only simulate behavior, do no actual changes\")\n+                   .optional(),\n+            Switch.shortcut(\"\")\n+                   .fullname(\"force\")\n+                   .helptext(\"Force syncing even between unrelated repos (beware!)\")\n+                   .optional(),\n+            Switch.shortcut(\"\")\n+                  .fullname(\"verbose\")\n+                  .helptext(\"Turn on verbose output\")\n+                  .optional(),\n+            Switch.shortcut(\"\")\n+                  .fullname(\"debug\")\n+                  .helptext(\"Turn on debugging output\")\n+                  .optional(),\n+            Switch.shortcut(\"v\")\n+                  .fullname(\"version\")\n+                  .helptext(\"Print the version of this tool\")\n+                  .optional()\n+        );\n+\n+        var parser = new ArgumentParser(\"git sync\", flags);\n+        return parser.parse(args);\n+    }\n+\n+    public static void sync(Repository repo, String[] args) throws IOException, InterruptedException {\n+        GitSync commandExecutor = new GitSync(repo, parseArguments(args));\n+        commandExecutor.sync();\n+    }\n+\n@@ -354,1 +506,1 @@\n-                die(\"error: no repository found at \" + cwd.toString())\n+                die(\"no repository found at \" + cwd)\n@@ -357,1 +509,2 @@\n-        sync(repo, args);\n+        GitSync commandExecutor = new GitSync(repo, parseArguments(args));\n+        commandExecutor.sync();\n","filename":"cli\/src\/main\/java\/org\/openjdk\/skara\/cli\/GitSync.java","additions":336,"deletions":183,"binary":false,"changes":519,"status":"modified"}]}