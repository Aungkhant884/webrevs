{"files":[{"patch":"@@ -68,0 +68,2 @@\n+    private static final int THRESHOLD = 5;\n+\n@@ -366,0 +368,1 @@\n+            int existingCommits = localRepo.getExistingCommits();\n@@ -369,5 +372,18 @@\n-                    for (var listener : listeners) {\n-                        log.info(\"Resetting mark for branch '\" + ref.name() + \"' for listener '\" + listener.name() + \"'\");\n-                        \/\/ Initial the hash for the branches in the first commit, so that the branches will not be treated as 'new'\n-                        \/\/ and the first commit will be treated as 'update', so we will get notifications\n-                        history.setBranchHash(new Branch(ref.name()), listener.name(), new Hash(INITIAL_GIT_HASH));\n+                    if (existingCommits <= THRESHOLD) {\n+                        \/\/ In this case, the repo will be considered as a new repo, notify bot will notify start from the first commit\n+                        log.info(\"This is a new repo\");\n+                        for (var listener : listeners) {\n+                            log.info(\"Resetting mark for branch '\" + ref.name() + \"' for listener '\" + listener.name() + \"'\");\n+                            \/\/ Initial the hash for the branches in the first commit, so that the branches will not be treated as 'new'\n+                            \/\/ and the first commit will be treated as 'update', so we will get notifications\n+                            history.setBranchHash(new Branch(ref.name()), listener.name(), new Hash(INITIAL_GIT_HASH));\n+                        }\n+                    } else {\n+                        \/\/ In this case, the repo will be considered as an existing repo with history, notify bot will only notify on new commits\n+                        log.info(\"This is an existing repo with history\");\n+                        for (var listener : listeners) {\n+                            log.info(\"Resetting mark for branch '\" + ref.name() + \"' for listener '\" + listener.name() + \"'\");\n+                            \/\/ Initial the hash for the branches in the first commit, so that the branches will not be treated as 'new'\n+                            \/\/ and the first commit will be treated as 'update', so we will get notifications\n+                            history.setBranchHash(new Branch(ref.name()), listener.name(), ref.hash());\n+                        }\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/RepositoryWorkItem.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1182,0 +1182,80 @@\n+\n+    @Test\n+    void testMailingListWithExistingRepo(TestInfo testInfo) throws IOException {\n+        try (var listServer = new TestMailmanServer();\n+             var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var repo = credentials.getHostedRepository();\n+            var repoFolder = tempFolder.path().resolve(\"repo\");\n+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            credentials.commitLock(localRepo);\n+            localRepo.pushAll(repo.url());\n+\n+            var listAddress = EmailAddress.parse(listServer.createList(\"test\"));\n+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);\n+            var mailmanList = mailmanServer.getListReader(listAddress.address());\n+            var tagStorage = createTagStorage(repo);\n+            var branchStorage = createBranchStorage(repo);\n+            var prStateStorage = createPullRequestStateStorage(repo);\n+            var storageFolder = tempFolder.path().resolve(\"storage\");\n+\n+            var sender = EmailAddress.from(\"duke\", \"duke@duke.duke\");\n+            var notifyBot = NotifyBot.newBuilder()\n+                    .repository(repo)\n+                    .storagePath(storageFolder)\n+                    .branches(Pattern.compile(\"master\"))\n+                    .tagStorageBuilder(tagStorage)\n+                    .branchStorageBuilder(branchStorage)\n+                    .prStateStorageBuilder(prStateStorage)\n+                    .build();\n+            var updater = MailingListNotifier.newBuilder()\n+                    .server(mailmanServer)\n+                    .recipient(listAddress)\n+                    .sender(sender)\n+                    .reportNewTags(false)\n+                    .reportNewBranches(false)\n+                    .reportNewBuilds(false)\n+                    .headers(Map.of(\"extra1\", \"value1\", \"extra2\", \"value2\"))\n+                    .allowedAuthorDomains(Pattern.compile(\"none\"))\n+                    .build();\n+            updater.attachTo(notifyBot);\n+\n+            CheckableRepository.appendAndCommit(localRepo,\"commit1\", \"commit1\");\n+            CheckableRepository.appendAndCommit(localRepo,\"commit2\", \"commit2\");\n+            var updateHash = CheckableRepository.appendAndCommit(localRepo,\"commit3\", \"commit3\");\n+            localRepo.push(updateHash,repo.url(),\"master\");\n+\n+            \/\/ No mail should be sent on first commit because it has a long history(commit times > 5)\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+            assertThrows(RuntimeException.class, () -> listServer.processIncoming());\n+\n+            var editHash = CheckableRepository.appendAndCommit(localRepo, \"Another line\", \"23456789: More fixes\");\n+            localRepo.push(editHash, repo.url(), \"master\");\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+            listServer.processIncoming();\n+\n+            var conversations = mailmanList.conversations(Duration.ofDays(1));\n+            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));\n+            \/\/ get the latest email\n+            var email = conversations.get(0).first();\n+            assertEquals(listAddress, email.sender());\n+            assertEquals(sender, email.author());\n+            assertEquals(email.recipients(), List.of(listAddress));\n+            assertTrue(email.subject().contains(\": 23456789: More fixes\"));\n+            assertFalse(email.subject().contains(\"master\"));\n+            assertTrue(email.body().contains(\"Changeset: \" + editHash.abbreviate()));\n+            assertTrue(email.body().contains(\"23456789: More fixes\"));\n+            assertFalse(email.body().contains(\"Committer\"));\n+            assertFalse(email.body().contains(masterHash.abbreviate()));\n+            assertTrue(email.hasHeader(\"extra1\"));\n+            assertEquals(\"value1\", email.headerValue(\"extra1\"));\n+            assertTrue(email.hasHeader(\"extra2\"));\n+            assertEquals(\"value2\", email.headerValue(\"extra2\"));\n+            assertTrue(email.hasHeader(\"X-Git-URL\"));\n+            assertEquals(repo.webUrl().toString(), email.headerValue(\"X-Git-URL\"));\n+            assertTrue(email.hasHeader(\"X-Git-Changeset\"));\n+            assertEquals(editHash.hex(), email.headerValue(\"X-Git-Changeset\"));\n+        }\n+    }\n+\n","filename":"bots\/notify\/src\/test\/java\/org\/openjdk\/skara\/bots\/notify\/mailinglist\/MailingListNotifierTests.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -300,0 +300,2 @@\n+\n+    int getExistingCommits() throws IOException;\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/Repository.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1650,0 +1650,7 @@\n+\n+    @Override\n+    public int getExistingCommits() throws IOException {\n+        try (var p = capture(\"git\", \"rev-list\", \"--all\", \"--count\")) {\n+            return Integer.valueOf(await(p).stdout().get(0));\n+        }\n+    }\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/git\/GitRepository.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1497,0 +1497,6 @@\n+\n+    @Override\n+    public int getExistingCommits() throws IOException {\n+        \/\/TODO:: implement it later, return 10 here so that it will maintain the previous behavior\n+        return 10;\n+    }\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/hg\/HgRepository.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}