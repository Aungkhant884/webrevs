{"files":[{"patch":"@@ -251,0 +251,3 @@\n+        var backportDiff = commit.parentDiffs().get(0);\n+        var prDiff = pr.diff();\n+        var isClean = DiffComparator.areFuzzyEqual(backportDiff, prDiff);\n@@ -252,83 +255,1 @@\n-        var originalPatches = new HashMap<String, Patch>();\n-        for (var patch : commit.parentDiffs().get(0).patches()) {\n-            originalPatches.put(patch.toString(), patch);\n-        }\n-        var prPatches = new HashMap<String, Patch>();\n-        for (var patch : pr.diff().patches()) {\n-            prPatches.put(patch.toString(), patch);\n-        }\n-\n-        if (originalPatches.size() != prPatches.size()) {\n-            if (hasCleanLabel) {\n-                pr.removeLabel(\"clean\");\n-            }\n-            return false;\n-        }\n-\n-        var descriptions = new HashSet<>(originalPatches.keySet());\n-        descriptions.removeAll(prPatches.keySet());\n-        if (!descriptions.isEmpty()) {\n-            if (hasCleanLabel) {\n-                pr.removeLabel(\"clean\");\n-            }\n-            return false;\n-        }\n-\n-        for (var desc : originalPatches.keySet()) {\n-            var original = originalPatches.get(desc).asTextualPatch();\n-            var backport = prPatches.get(desc).asTextualPatch();\n-            if (original.hunks().size() != backport.hunks().size()) {\n-                if (hasCleanLabel) {\n-                    pr.removeLabel(\"clean\");\n-                }\n-                return false;\n-            }\n-            if (original.additions() != backport.additions()) {\n-                if (hasCleanLabel) {\n-                    pr.removeLabel(\"clean\");\n-                }\n-                return false;\n-            }\n-            if (original.deletions() != backport.deletions()) {\n-                if (hasCleanLabel) {\n-                    pr.removeLabel(\"clean\");\n-                }\n-                return false;\n-            }\n-            for (var i = 0; i < original.hunks().size(); i++) {\n-                var originalHunk = original.hunks().get(i);\n-                var backportHunk = backport.hunks().get(i);\n-\n-                if (originalHunk.source().lines().size() != backportHunk.source().lines().size()) {\n-                    if (hasCleanLabel) {\n-                        pr.removeLabel(\"clean\");\n-                    }\n-                    return false;\n-                }\n-                var sourceLines = new HashSet<>(originalHunk.source().lines());\n-                sourceLines.removeAll(backportHunk.source().lines());\n-                if (!sourceLines.isEmpty()) {\n-                    if (hasCleanLabel) {\n-                        pr.removeLabel(\"clean\");\n-                    }\n-                    return false;\n-                }\n-\n-                if (originalHunk.target().lines().size() != backportHunk.target().lines().size()) {\n-                    if (hasCleanLabel) {\n-                        pr.removeLabel(\"clean\");\n-                    }\n-                    return false;\n-                }\n-                var targetLines = new HashSet<>(originalHunk.target().lines());\n-                targetLines.removeAll(backportHunk.target().lines());\n-                if (!targetLines.isEmpty()) {\n-                    if (hasCleanLabel) {\n-                        pr.removeLabel(\"clean\");\n-                    }\n-                    return false;\n-                }\n-            }\n-        }\n-\n-        if (!hasCleanLabel) {\n+        if (isClean && !hasCleanLabel) {\n@@ -337,1 +258,4 @@\n-        return true;\n+        if (!isClean && hasCleanLabel) {\n+            pr.removeLabel(\"clean\");\n+        }\n+        return isClean;\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":8,"deletions":84,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.vcs;\n+\n+import java.io.*;\n+import java.nio.file.*;\n+import java.util.*;\n+\n+public class DiffComparator {\n+    public static boolean areFuzzyEqual(Diff a, Diff b) {\n+        var aPatches = new HashMap<String, Patch>();\n+        for (var patch : a.patches()) {\n+            aPatches.put(patch.toString(), patch);\n+        }\n+        var bPatches = new HashMap<String, Patch>();\n+        for (var patch : b.patches()) {\n+            bPatches.put(patch.toString(), patch);\n+        }\n+\n+        if (aPatches.size() != bPatches.size()) {\n+            return false;\n+        }\n+        var onlyInA = new HashSet<>(aPatches.keySet());\n+        onlyInA.removeAll(bPatches.keySet());\n+        if (!onlyInA.isEmpty()) {\n+            return false;\n+        }\n+        var onlyInB = new HashSet<>(bPatches.keySet());\n+        onlyInB.removeAll(aPatches.keySet());\n+        if (!onlyInB.isEmpty()) {\n+            return false;\n+        }\n+\n+        for (var key : aPatches.keySet()) {\n+            var aPatch = aPatches.get(key).asTextualPatch();\n+            var bPatch = bPatches.get(key).asTextualPatch();\n+            if (!areFuzzyEqual(aPatch, bPatch)) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    private static boolean areFuzzyEqual(Patch a, Patch b) {\n+        var aHunks = a.asTextualPatch().hunks();\n+        var bHunks = b.asTextualPatch().hunks();\n+        if (aHunks.size() != bHunks.size()) {\n+            return false;\n+        }\n+        for (var i = 0; i < aHunks.size(); i++) {\n+            var aHunk = aHunks.get(i);\n+            var bHunk = bHunks.get(i);\n+\n+            if (aHunk.source().lines().size() != bHunk.source().lines().size()) {\n+                return false;\n+            }\n+            for (var j = 0; j < aHunk.source().lines().size(); j++) {\n+                var aLine = aHunk.source().lines().get(i);\n+                var bLine = bHunk.source().lines().get(i);\n+                if (!aLine.equals(bLine)) {\n+                    return false;\n+                }\n+            }\n+\n+            if (aHunk.target().lines().size() != bHunk.target().lines().size()) {\n+                return false;\n+            }\n+            for (var j = 0; j < aHunk.target().lines().size(); j++) {\n+                var aLine = aHunk.target().lines().get(i);\n+                var bLine = bHunk.target().lines().get(i);\n+                if (!aLine.equals(bLine)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/DiffComparator.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"}]}