{"files":[{"patch":"@@ -29,1 +29,1 @@\n-import java.util.Comparator;\n+import java.util.HashMap;\n@@ -33,2 +33,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -54,1 +52,1 @@\n-    private Map<String, ZonedDateTime> issueUpdatedAt = Map.of();\n+    private Map<String, ZonedDateTime> issueUpdatedAt = new HashMap<>();\n@@ -58,2 +56,0 @@\n-    private final List<Issue> retryIssues = new ArrayList<>();\n-\n@@ -72,0 +68,1 @@\n+        var ret = new ArrayList<WorkItem>();\n@@ -81,1 +78,1 @@\n-                issueUpdatedAt = Map.of(issue.id(), issue.updatedAt());\n+                issueUpdatedAt.put(issue.id(), issue.updatedAt());\n@@ -90,1 +87,1 @@\n-            return List.of();\n+            return ret;\n@@ -93,0 +90,1 @@\n+        var newIssuesUpdatedAt = new HashMap<String, ZonedDateTime>();\n@@ -94,40 +92,5 @@\n-        if (!issues.isEmpty()) {\n-            lastUpdatedAt = issues.stream()\n-                    .map(Issue::updatedAt)\n-                    .max(Comparator.naturalOrder())\n-                    .orElseThrow(() -> new RuntimeException(\"No updatedAt field found in any Issue\"));\n-        }\n-        var newIssuesUpdatedAt = issues.stream()\n-                .collect(Collectors.toMap(Issue::id, Issue::updatedAt));\n-\n-        var filtered = issues.stream()\n-                .filter(i -> !issueUpdatedAt.containsKey(i.id()) || i.updatedAt().isAfter(issueUpdatedAt.get(i.id())))\n-                .toList();\n-\n-        var withRetries = addRetries(filtered);\n-\n-        var workItems = withRetries.stream()\n-                .map(i -> (WorkItem) new IssueWorkItem(this, i, e -> this.retryIssue(i)))\n-                .toList();\n-\n-        issueUpdatedAt = newIssuesUpdatedAt;\n-\n-        return workItems;\n-    }\n-\n-    private synchronized void retryIssue(Issue issue) {\n-        retryIssues.add(issue);\n-    }\n-\n-    private synchronized List<Issue> addRetries(List<Issue> issues) {\n-        if (retryIssues.isEmpty()) {\n-            return issues;\n-        } else {\n-            var retries = retryIssues.stream()\n-                    .filter(retryIssue -> issues.stream().noneMatch(i -> retryIssue.id().equals(i.id())))\n-                    .toList();\n-            retryIssues.clear();\n-            if (retries.isEmpty()) {\n-                return issues;\n-            } else {\n-                return Stream.concat(issues.stream(), retries.stream()).toList();\n+        for (var issue : issues) {\n+            newIssuesUpdatedAt.put(issue.id(), issue.updatedAt());\n+            \/\/ Update the lastUpdatedAt value with the highest found value for next call\n+            if (issue.updatedAt().isAfter(lastUpdatedAt)) {\n+                lastUpdatedAt = issue.updatedAt();\n@@ -135,0 +98,8 @@\n+            var lastUpdate = issueUpdatedAt.get(issue.id());\n+            if (lastUpdate != null) {\n+                if (!issue.updatedAt().isAfter(lastUpdate)) {\n+                    continue;\n+                }\n+            }\n+            var issueWorkItem = new IssueWorkItem(this, issue);\n+            ret.add(issueWorkItem);\n@@ -136,0 +107,2 @@\n+        issueUpdatedAt = newIssuesUpdatedAt;\n+        return ret;\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/CSRIssueBot.java","additions":21,"deletions":48,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import org.openjdk.skara.forge.PullRequestPoller;\n@@ -44,1 +43,9 @@\n-    private final PullRequestPoller poller;\n+    \/\/ Keeps track of updatedAt timestamps from the previous call to getPeriodicItems,\n+    \/\/ so we can avoid re-evaluating PRs that are returned again without any actual\n+    \/\/ update. This is needed because timestamp based searches aren't exact enough\n+    \/\/ to avoid sometimes receiving the same items multiple times.\n+    private Map<String, ZonedDateTime> prsUpdatedAt = new HashMap<>();\n+    \/\/ The last found updateAt in any returned PR. Used for limiting results on the\n+    \/\/ next call to the hosted repo. Should only contain timestamps originating\n+    \/\/ from the remote repo to avoid problems with mismatched clocks.\n+    private ZonedDateTime lastUpdatedAt;\n@@ -49,1 +56,0 @@\n-        this.poller = new PullRequestPoller(repo, false, false, false);\n@@ -59,6 +65,22 @@\n-        var prs = poller.updatedPullRequests();\n-        var items = prs.stream()\n-                .map(pr -> (WorkItem) new PullRequestWorkItem(repo, pr.id(), project,\n-                        e -> poller.retryPullRequest(pr), pr.updatedAt()))\n-                .toList();\n-        poller.lastBatchHandled();\n+        var items = new ArrayList<WorkItem>();\n+        log.info(\"Fetching all open pull requests for \" + repo.name());\n+        Map<String, ZonedDateTime> newPrsUpdatedAt = new HashMap<>();\n+        \/\/ On the first run we have to re-evaluate all open PRs, after that, only\n+        \/\/ looking at PRs that have been updated should be enough.\n+        var prs = lastUpdatedAt != null ? repo.openPullRequestsAfter(lastUpdatedAt) : repo.openPullRequests();\n+        for (PullRequest pr : prs) {\n+            newPrsUpdatedAt.put(pr.id(), pr.updatedAt());\n+            \/\/ Update lastUpdatedAt with the last found updatedAt for the next call\n+            if (lastUpdatedAt == null || pr.updatedAt().isAfter(lastUpdatedAt)) {\n+                lastUpdatedAt = pr.updatedAt();\n+            }\n+            var lastUpdate = prsUpdatedAt.get(pr.id());\n+            if (lastUpdate != null) {\n+                if (!pr.updatedAt().isAfter(lastUpdate)) {\n+                    continue;\n+                }\n+            }\n+            var pullRequestWorkItem = new PullRequestWorkItem(repo, pr.id(), project, pr.updatedAt());\n+            items.add(pullRequestWorkItem);\n+        }\n+        prsUpdatedAt = newPrsUpdatedAt;\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/CSRPullRequestBot.java","additions":31,"deletions":9,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.function.Consumer;\n@@ -50,3 +49,1 @@\n-    private final Consumer<RuntimeException> errorHandler;\n-\n-    public IssueWorkItem(CSRIssueBot bot, Issue csrIssue, Consumer<RuntimeException> errorHandler) {\n+    public IssueWorkItem(CSRIssueBot bot, Issue csrIssue) {\n@@ -55,1 +52,0 @@\n-        this.errorHandler = errorHandler;\n@@ -90,2 +86,1 @@\n-                .map(pr -> new PullRequestWorkItem(pr.repository(), pr.id(), csrIssue.project(),\n-                        errorHandler, csrIssue.updatedAt()))\n+                .map(pr -> new PullRequestWorkItem(pr.repository(), pr.id(), csrIssue.project(), csrIssue.updatedAt()))\n@@ -105,5 +100,0 @@\n-\n-    @Override\n-    public void handleRuntimeException(RuntimeException e) {\n-        errorHandler.accept(e);\n-    }\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/IssueWorkItem.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Consumer;\n@@ -57,1 +56,0 @@\n-    final Consumer<RuntimeException> errorHandler;\n@@ -66,1 +64,1 @@\n-            Consumer<RuntimeException> errorHandler, ZonedDateTime triggerUpdatedAt) {\n+            ZonedDateTime triggerUpdatedAt) {\n@@ -70,1 +68,0 @@\n-        this.errorHandler = errorHandler;\n@@ -259,5 +256,0 @@\n-\n-    @Override\n-    public void handleRuntimeException(RuntimeException e) {\n-        errorHandler.accept(e);\n-    }\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/PullRequestWorkItem.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"}]}