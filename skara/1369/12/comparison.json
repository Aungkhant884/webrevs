{"files":[{"patch":"@@ -25,0 +25,1 @@\n+import java.time.Duration;\n@@ -46,0 +47,12 @@\n+    \/**\n+     * Some forges do not always update the \"updated_at\" fields of various objects\n+     * when the object changes. This method returns a Duration indicating how long\n+     * the shortest update interval is for the \"updated_at\" field. This is needed\n+     * to be taken into account when running queries (typically by padding the\n+     * timestamp by this duration to guarantee that no results are missed). The\n+     * default returns 0 which means no special considerations are needed.\n+     *\/\n+    default Duration minTimeStampUpdateInterval() {\n+        return Duration.ZERO;\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/Forge.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,324 @@\n+package org.openjdk.skara.forge;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.openjdk.skara.issuetracker.Comment;\n+import org.openjdk.skara.issuetracker.Issue;\n+import org.openjdk.skara.vcs.Hash;\n+\n+\/**\n+ * A PullRequestPoller handles querying for new and updated pull requests. It\n+ * guarantees that no pull request updates at the forge are missed and avoids\n+ * returning the same update multiple times as much as possible.\n+ * <p>\n+ * On the first call, all open PRs, and if configured, non-open PRs (up to a\n+ * limit), are returned. After that only updated PRs should be included.\n+ * <p>\n+ * After each call for updated pull requests, the result needs to be\n+ * acknowledged once it has been processed by the caller. Failing to\n+ * acknowledge makes the next call include everything from the last call\n+ * again. This helps to avoid missing any updates due to errors.\n+ * <p>\n+ * In addition to this, it's also possible to schedule PRs for retries with\n+ * or without quarantine. A regular retry will not block the same PR if it\n+ * gets returned by the regular query, but doing so will cancel the future\n+ * retry. A quarantine type retry will completely block that PR until the\n+ * quarantine is lifted. In both cases, the actual object returned will be\n+ * the same one provided in the retry call, unless a newer instance has\n+ * been returned by a query since then.\n+ *\/\n+public class PullRequestPoller {\n+\n+    private static final Logger log = Logger.getLogger(PullRequestPoller.class.getName());\n+\n+    private static final Duration CLOSED_PR_AGE_LIMIT = Duration.ofDays(7);\n+\n+    private final HostedRepository repository;\n+    private final Duration queryPadding;\n+    private final boolean includeClosed;\n+    private final boolean trustUpdatedAt;\n+    private final boolean checkComments;\n+    private final boolean checkReviews;\n+\n+    private record PullRequestRetry(PullRequest pr, Instant when) {}\n+    private final Map<String, PullRequestRetry> retryMap = new HashMap<>();\n+    private final Map<String, PullRequestRetry> quarantineMap = new HashMap<>();\n+\n+    \/**\n+     * This record represents all the query results data needed to correctly figure\n+     * out if future results have been updated or not.\n+     *\/\n+    private record QueryResult(Map<String, PullRequest> pullRequests, Map<String, List<Comment>> comments,\n+                               Map<String, List<Review>> reviews, ZonedDateTime maxUpdatedAt,\n+                               Instant afterQuery, List<PullRequest> result) {}\n+    private QueryResult current;\n+    private QueryResult prev;\n+\n+    \/**\n+     * When enough time has past since the last time we actually received results\n+     * padding the updatedAt query parameter is no longer needed. This is indicated\n+     * using this boolean.\n+     *\/\n+    private boolean paddingNeeded = true;\n+\n+    public PullRequestPoller(HostedRepository repository, boolean includeClosed, boolean commentsRelevant,\n+            boolean reviewsRelevant) {\n+        this.repository = repository;\n+        this.includeClosed = includeClosed;\n+        queryPadding = repository.forge().minTimeStampUpdateInterval();\n+        if (!queryPadding.isZero()) {\n+            trustUpdatedAt = false;\n+            checkComments = commentsRelevant;\n+            checkReviews = reviewsRelevant;\n+        } else {\n+            trustUpdatedAt = true;\n+            checkComments = false;\n+            checkReviews = false;\n+        }\n+    }\n+\n+    \/**\n+     * The main API method. Call this go get updated PRs. When done processing the results\n+     * call lastBatchHandled() to acknowledge that all the returned PRs have been handled\n+     * and should not be included in the next call of this method.\n+     *\/\n+    public List<PullRequest> updatedPullRequests() {\n+        var beforeQuery = Instant.now();\n+        List<PullRequest> prs = queryPullRequests();\n+\n+        \/\/ If nothing was found. Update the paddingNeeded state if enough time\n+        \/\/ has passed since last we found something.\n+        if (prs.isEmpty()) {\n+            if (prev != null && prev.afterQuery.isBefore(beforeQuery.minus(queryPadding))) {\n+                paddingNeeded = false;\n+            }\n+        } else {\n+            paddingNeeded = true;\n+        }\n+        var afterQuery = Instant.now();\n+\n+        \/\/ Convert the query result into a map\n+        var pullRequestMap = prs.stream().collect(Collectors.toMap(PullRequest::id, pr -> pr));\n+\n+        \/\/ Find the max updatedAt value in the result set. Fall back on the previous\n+        \/\/ value (happens if no results were returned), or null (if no results have\n+        \/\/ been found at all so far).\n+        var maxUpdatedAt = prs.stream()\n+                .map(PullRequest::updatedAt)\n+                .max(Comparator.naturalOrder())\n+                .orElseGet(() -> prev != null ? prev.maxUpdatedAt : null);\n+\n+        \/\/ If checking comments, save the current state of comments for future\n+        \/\/ comparisons.\n+        var commentsMap = fetchComments(prs, maxUpdatedAt);\n+\n+        \/\/ If checking reviews, save the current state of reviews for future\n+        \/\/ comparisons.\n+        var reviewsMap = fetchReviews(prs, maxUpdatedAt);\n+\n+        \/\/ Filter the results\n+        var filtered = prs.stream()\n+                .filter(this::isUpdated)\n+                .toList();\n+\n+        var withRetries = addRetries(filtered);\n+\n+        var result = processQuarantined(withRetries);\n+\n+        \/\/ Save the state of the current query results\n+        current = new QueryResult(pullRequestMap, commentsMap, reviewsMap, maxUpdatedAt, afterQuery, result);\n+\n+        log.info(\"Found \" + result.size() + \" updated pull requests for \" + repository.name());\n+        return result;\n+    }\n+\n+    \/**\n+     * After calling getUpdatedPullRequests(), this method must be called to acknowledge\n+     * that all the PRs returned have been handled. If not, the previous results will be\n+     * included in the next call to getUpdatedPullRequests() again.\n+     *\/\n+    public synchronized void lastBatchHandled() {\n+        if (current != null) {\n+            prev = current;\n+            current = null;\n+            \/\/ Remove any returned PRs from the retry\/quarantine sets\n+            prev.result.forEach(pr -> retryMap.remove(pr.id()));\n+            prev.result.forEach(pr -> quarantineMap.remove(pr.id()));\n+        }\n+    }\n+\n+    \/**\n+     * If handling of a pull request fails, call this to have it be included in the next\n+     * update, regardless of if it was updated or not.\n+     * @param pr PullRequest to retry\n+     *\/\n+    public synchronized void retryPullRequest(PullRequest pr) {\n+        retryPullRequest(pr, Instant.MIN);\n+    }\n+\n+    \/**\n+     * Schedules a pull request to be re-evaluated after a certain time, unless it is\n+     * updated before that.\n+     * @param pr PullRequest to retry\n+     * @param at Time at which to process it\n+     *\/\n+    public synchronized void retryPullRequest(PullRequest pr, Instant at) {\n+        retryMap.put(pr.id(), new PullRequestRetry(pr, at));\n+    }\n+\n+    \/**\n+     * Schedules a pull request to be retried after a quarantine period has passed.\n+     * If a quarantined pull request is returned by a query, it will be removed from\n+     * the result set until the quarantine time has passed.\n+     * @param pr PullRequest to quarantine\n+     * @param until Time at which the quarantine is lifted\n+     *\/\n+    public synchronized void quarantinePullRequest(PullRequest pr, Instant until) {\n+        quarantineMap.put(pr.id(), new PullRequestRetry(pr, until));\n+    }\n+\n+    \/**\n+     * Queries the repository for pull requests. On the first round (or until any\n+     * results have been received), get all pull requests. After that limit the\n+     * results using the maxUpdatedAt value from the previous results. Use padding\n+     * if needed to guarantee that we never miss an update.\n+     *\/\n+    private List<PullRequest> queryPullRequests() {\n+        if (prev == null || prev.maxUpdatedAt == null) {\n+            if (includeClosed) {\n+                log.fine(\"Fetching all open and recent closed pull requests for \" + repository.name());\n+                \/\/ We need to guarantee that all open PRs are always included in the first round.\n+                \/\/ The pullRequests(ZonedDateTime) call has a size limit, so may leave some out.\n+                \/\/ There may also be open PRs that haven't been updated since the closed age limit.\n+                var openPrs = repository.openPullRequests();\n+                var allPrs = repository.pullRequestsAfter(ZonedDateTime.now().minus(CLOSED_PR_AGE_LIMIT));\n+                return Stream.concat(openPrs.stream(), allPrs.stream().filter(pr -> !pr.isOpen())).toList();\n+            } else {\n+                log.fine(\"Fetching all open pull requests for \" + repository.name());\n+                return repository.openPullRequests();\n+            }\n+        } else {\n+            var queryUpdatedAt = paddingNeeded ? prev.maxUpdatedAt.minus(queryPadding) : prev.maxUpdatedAt;\n+            if (includeClosed) {\n+                log.fine(\"Fetching open and closed pull requests updated after \" + queryUpdatedAt + \" for \" + repository.name());\n+                return repository.pullRequestsAfter(queryUpdatedAt);\n+            } else {\n+                log.fine(\"Fetching open pull requests updated after \" + queryUpdatedAt + \" for \" + repository.name());\n+                return repository.openPullRequestsAfter(queryUpdatedAt);\n+            }\n+        }\n+    }\n+\n+    private Map<String, List<Comment>> fetchComments(List<PullRequest> prs, ZonedDateTime maxUpdatedAt) {\n+        if (checkComments) {\n+            return prs.stream()\n+                    .filter(pr -> pr.updatedAt().isAfter(maxUpdatedAt.minus(queryPadding)))\n+                    .collect(Collectors.toMap(Issue::id, Issue::comments));\n+        } else {\n+            return Map.of();\n+        }\n+    }\n+\n+    private Map<String, List<Review>> fetchReviews(List<PullRequest> prs, ZonedDateTime maxUpdatedAt) {\n+        if (checkReviews) {\n+            return prs.stream()\n+                    .filter(pr -> pr.updatedAt().isAfter(maxUpdatedAt.minus(queryPadding)))\n+                    .collect(Collectors.toMap(Issue::id, PullRequest::reviews));\n+        } else {\n+            return Map.of();\n+        }\n+    }\n+\n+    \/**\n+     * Evaluates if a PR has been updated since the previous query result. If we\n+     * can trust updatedAt from the forge, it's a simple comparison, otherwise\n+     * we need to compare the complete contents of the PR object, as well as\n+     * comments and\/or reviews as configured.\n+     *\/\n+    private boolean isUpdated(PullRequest pr) {\n+        if (prev == null) {\n+            return true;\n+        }\n+        var prPrev = prev.pullRequests.get(pr.id());\n+        if (prPrev == null || pr.updatedAt().isAfter(prPrev.updatedAt())) {\n+            return true;\n+        }\n+        if (!trustUpdatedAt) {\n+            if (!pr.equals(prPrev)) {\n+                return true;\n+            }\n+            if (checkComments && !pr.comments().equals(prev.comments.get(pr.id()))) {\n+                return true;\n+            }\n+            if (checkReviews && !pr.reviews().equals(prev.reviews.get(pr.id()))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns a list of all prs with retries added.\n+     *\/\n+    private synchronized List<PullRequest> addRetries(List<PullRequest> prs) {\n+        if (retryMap.isEmpty()) {\n+            return prs;\n+        } else {\n+            \/\/ Find the retries that have passed their at time.\n+            var now = Instant.now();\n+            var retries = retryMap.values().stream()\n+                    .filter(prRetry -> prRetry.when.isBefore(now))\n+                    .filter(prRetry -> prs.stream().noneMatch(pr -> pr.id().equals(prRetry.pr.id())))\n+                    .map(PullRequestRetry::pr)\n+                    .toList();\n+            if (retries.isEmpty()) {\n+                return prs;\n+            } else {\n+                return Stream.concat(prs.stream(), retries.stream()).toList();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns a list of all prs with still quarantined prs removed and newly lifted\n+     * prs added.\n+     *\/\n+    private synchronized List<PullRequest> processQuarantined(List<PullRequest> prs) {\n+        if (quarantineMap.isEmpty()) {\n+            return prs;\n+        } else {\n+            var now = Instant.now();\n+            \/\/ Replace the PR instances in the quarantineMap with any freshly fetched PRs.\n+            \/\/ By doing this, we will always return the most up-to-date version of the PR\n+            \/\/ that we have seen so far.\n+            prs.forEach(pr -> {\n+                if (quarantineMap.containsKey(pr.id())) {\n+                    quarantineMap.put(pr.id(), new PullRequestRetry(pr, quarantineMap.get(pr.id()).when));\n+                }\n+            });\n+            \/\/ Find all quarantined PRs that are now past the time\n+            var pastQuarantine = quarantineMap.values().stream()\n+                    .filter(prRetry -> prRetry.when.isBefore(now))\n+                    .filter(prRetry -> prs.stream().noneMatch(pr -> pr.id().equals(prRetry.pr.id())))\n+                    .map(PullRequestRetry::pr)\n+                    .toList();\n+            \/\/ Find all still quarantined PRs\n+            var stillQuarantined = quarantineMap.values().stream()\n+                    .filter(prRetry -> !prRetry.when.isBefore(now))\n+                    .map(prRetry -> prRetry.pr.id())\n+                    .collect(Collectors.toSet());\n+            return Stream.concat(\n+                            prs.stream().filter(pr -> !stillQuarantined.contains(pr.id())),\n+                            pastQuarantine.stream())\n+                    .toList();\n+        }\n+    }\n+}\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequestPoller.java","additions":324,"deletions":0,"binary":false,"changes":324,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.Objects;\n@@ -81,0 +82,22 @@\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        Review review = (Review) o;\n+        return id == review.id &&\n+                Objects.equals(createdAt, review.createdAt) &&\n+                Objects.equals(reviewer, review.reviewer) &&\n+                verdict == review.verdict &&\n+                Objects.equals(hash, review.hash) &&\n+                Objects.equals(body, review.body);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(createdAt, reviewer, verdict, hash, id, body);\n+    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/Review.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.time.Duration;\n@@ -255,0 +256,5 @@\n+\n+    @Override\n+    public Duration minTimeStampUpdateInterval() {\n+        return Duration.ofMinutes(1);\n+    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabHost.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -830,0 +830,21 @@\n+\n+    \/**\n+     * Equality for a GitLabMergeRequest is based on the data snapshot retrieved\n+     * when the instance was created.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        GitLabMergeRequest that = (GitLabMergeRequest) o;\n+        return json.equals(that.json);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(json);\n+    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabMergeRequest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,347 @@\n+package org.openjdk.skara.forge;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.issuetracker.Issue;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TestHost;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class PullRequestPollerTests {\n+\n+    @Test\n+    void onlyOpen(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo)) {\n+            var repo = credentials.getHostedRepository();\n+            var prPoller = new PullRequestPoller(repo, false, true, true);\n+\n+            \/\/ Create closed PR that should never be returned\n+            var prClosed = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            prClosed.setState(Issue.State.CLOSED);\n+            var prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Create a PR and poll for it\n+            var pr = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+\n+            \/\/ Poll for it again without calling lastBatchHandled(), it should be returned again\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Poll for it again after calling lastBatchHandled(), it should not be returned\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add a label and poll again.\n+            pr.addLabel(\"foo\");\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+        }\n+    }\n+\n+    @Test\n+    void includeClosed(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo)) {\n+            var repo = credentials.getHostedRepository();\n+            var prPoller = new PullRequestPoller(repo, true, true, true);\n+\n+            \/\/ Create a and an open closed PR, that should both be returned\n+            var prClosed = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            var prOpen = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            prClosed.setState(Issue.State.CLOSED);\n+            var prs = prPoller.updatedPullRequests();\n+            assertEquals(2, prs.size());\n+\n+            \/\/ Poll for it again without calling lastBatchHandled(), both should be returned again\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(2, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Poll for it again after calling lastBatchHandled(), none should not be returned\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add a label to the closed PR and poll again.\n+            prClosed.addLabel(\"foo\");\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            assertEquals(prClosed.id(), prs.get(0).id());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add a label to the open PR and poll again.\n+            prOpen.addLabel(\"foo\");\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            assertEquals(prOpen.id(), prs.get(0).id());\n+            prPoller.lastBatchHandled();\n+        }\n+    }\n+\n+    \/**\n+     * Tests polling with padding needed, with comments and reviews irrelevant.\n+     * Uses a closed PR to cover that case in our of the queryPadding tests.\n+     *\/\n+    @Test\n+    void queryPaddingLabel(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo)) {\n+            var repo = credentials.getHostedRepository();\n+            var forge = repo.forge();\n+            ((TestHost) forge).setMinTimeStampUpdateInterval(Duration.ofDays(1));\n+            var prPoller = new PullRequestPoller(repo, true, false, false);\n+\n+            \/\/ Create a closed PR and poll for it\n+            var pr = credentials.createPullRequest(repo, \"master\", \"master\", \"Foo\");\n+            pr.setState(Issue.State.CLOSED);\n+            var prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Poll for it again\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add a new label but make sure the updatedAt time was not updated. This should trigger an update.\n+            var prevUpdatedAt = pr.updatedAt();\n+            pr.addLabel(\"foo\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add comment while keeping the updatedAt time unchanged. This should not trigger an update\n+            prevUpdatedAt = pr.updatedAt();\n+            pr.addComment(\"foo\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add review while keeping the updatedAt time unchanged. This should not trigger an update\n+            prevUpdatedAt = pr.updatedAt();\n+            pr.addReview(Review.Verdict.APPROVED, \"foo\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+        }\n+    }\n+\n+    \/**\n+     * Tests polling with padding needed and creating\/modifying comments\n+     *\/\n+    @Test\n+    void queryPaddingComment(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo)) {\n+            var repo = credentials.getHostedRepository();\n+            var forge = repo.forge();\n+            ((TestHost) forge).setMinTimeStampUpdateInterval(Duration.ofDays(1));\n+            var prPoller = new PullRequestPoller(repo, true, true, false);\n+\n+            \/\/ Create a PR and poll for it\n+            var pr = credentials.createPullRequest(repo, \"master\", \"master\", \"Foo\");\n+            var prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Poll for it again\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add a new comment but make sure the updatedAt time was not updated. This should trigger an update.\n+            var prevUpdatedAt = pr.updatedAt();\n+            pr.addLabel(\"foo\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add comment while keeping updatedAt unchanged. This should trigger an update.\n+            prevUpdatedAt = pr.updatedAt();\n+            pr.addComment(\"foo\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Update comment while keeping updatedAt unchanged. This should trigger an update.\n+            prevUpdatedAt = pr.updatedAt();\n+            pr.updateComment(pr.comments().get(0).id(), \"bar\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add review while keeping updatedAt unchanged. This should not trigger an update.\n+            prevUpdatedAt = pr.updatedAt();\n+            pr.addReview(Review.Verdict.APPROVED, \"foo\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+        }\n+    }\n+\n+    \/**\n+     * Tests polling with padding needed and creating\/modifying reviews\n+     *\/\n+    @Test\n+    void queryPaddingReview(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo)) {\n+            var repo = credentials.getHostedRepository();\n+            var forge = repo.forge();\n+            ((TestHost) forge).setMinTimeStampUpdateInterval(Duration.ofDays(1));\n+            var prPoller = new PullRequestPoller(repo, true, false, true);\n+\n+            \/\/ Create a PR and poll for it\n+            var pr = credentials.createPullRequest(repo, \"master\", \"master\", \"Foo\");\n+            var prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Poll for it again\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add a label but make sure the updatedAt time was not updated. This should trigger an update.\n+            var prevUpdatedAt = pr.updatedAt();\n+            pr.addLabel(\"foo\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add comment while keeping updatedAt unchanged. This should not trigger an update\n+            prevUpdatedAt = pr.updatedAt();\n+            pr.addComment(\"foo\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Add review while keeping updatedAt unchanged. This should trigger an update\n+            prevUpdatedAt = pr.updatedAt();\n+            pr.addReview(Review.Verdict.APPROVED, \"foo\");\n+            pr.store().setLastUpdate(prevUpdatedAt);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+        }\n+    }\n+\n+    @Test\n+    void retries(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo)) {\n+            var repo = credentials.getHostedRepository();\n+            var prPoller = new PullRequestPoller(repo, false, true, true);\n+\n+            \/\/ Create PR\n+            var pr1 = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            var prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Create another PR and mark the first PR for retry\n+            var pr2 = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            prPoller.retryPullRequest(pr1);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(2, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Poll again, nothing should not be returned\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Just mark a PR for retry\n+            prPoller.retryPullRequest(pr2);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+\n+            \/\/ Call again without calling .lastBatchHandled, the retry should be included again\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Mark a PR for retry far in the future, it should not be included\n+            prPoller.retryPullRequest(pr2, Instant.now().plus(Duration.ofDays(1)));\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Update PR and add it as retry, only one copy should be returned\n+            pr1.addLabel(\"foo\");\n+            prPoller.retryPullRequest(pr1);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+        }\n+    }\n+\n+    @Test\n+    void quarantine(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo)) {\n+            var repo = credentials.getHostedRepository();\n+            var prPoller = new PullRequestPoller(repo, false, false, false);\n+\n+            \/\/ Create PR\n+            var pr1 = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            var prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            var returnedPr1 = prs.get(0);\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Mark it for quarantine far in the future, it should not be returned\n+            prPoller.quarantinePullRequest(returnedPr1, Instant.now().plus(Duration.ofDays(1)));\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Touch it, it should not be returned\n+            pr1.addLabel(\"foo\");\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Change the quarantine time to sometime in the past\n+            prPoller.quarantinePullRequest(returnedPr1, Instant.now().minus(Duration.ofMinutes(1)));\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+\n+            \/\/ Call again without marking as handled\n+            prPoller.quarantinePullRequest(pr1, Instant.now().minus(Duration.ofMinutes(1)));\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Quarantine to sometime in the past and touch it\n+            prPoller.quarantinePullRequest(returnedPr1, Instant.now().minus(Duration.ofMinutes(1)));\n+            pr1.addLabel(\"bar\");\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            \/\/ Check that the returned PR object is updated with the label\n+            assertTrue(prs.get(0).labelNames().contains(\"bar\"));\n+\n+            \/\/ Add PR both for retry and quarantine in the future, quarantine should win\n+            prPoller.retryPullRequest(pr1, Instant.now().plus(Duration.ofDays(1)));\n+            prPoller.quarantinePullRequest(pr1, Instant.now().plus(Duration.ofDays(1)));\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            prPoller.lastBatchHandled();\n+        }\n+    }\n+}\n","filename":"forge\/src\/test\/java\/org\/openjdk\/skara\/forge\/PullRequestPollerTests.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -74,5 +74,5 @@\n-        return id.equals(comment.id) &&\n-                body.equals(comment.body) &&\n-                author.equals(comment.author) &&\n-                createdAt.equals(comment.createdAt) &&\n-                updatedAt.equals(comment.updatedAt);\n+        return Objects.equals(id, comment.id) &&\n+                Objects.equals(body, comment.body) &&\n+                Objects.equals(author, comment.author) &&\n+                Objects.equals(createdAt, comment.createdAt) &&\n+                Objects.equals(updatedAt, comment.updatedAt);\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/Comment.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -162,0 +162,17 @@\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONArray that = (JSONArray) o;\n+        return values.equals(that.values);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(values);\n+    }\n","filename":"json\/src\/main\/java\/org\/openjdk\/skara\/json\/JSONArray.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.util.Objects;\n+\n@@ -46,0 +48,17 @@\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONBoolean that = (JSONBoolean) o;\n+        return value == that.value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n","filename":"json\/src\/main\/java\/org\/openjdk\/skara\/json\/JSONBoolean.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.util.Objects;\n+\n@@ -46,0 +48,17 @@\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONDecimal that = (JSONDecimal) o;\n+        return Double.compare(that.value, value) == 0;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n","filename":"json\/src\/main\/java\/org\/openjdk\/skara\/json\/JSONDecimal.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,1 +26,3 @@\n-    public JSONNull() {\n+    static JSONNull instance = new JSONNull();\n+\n+    private JSONNull() {\n","filename":"json\/src\/main\/java\/org\/openjdk\/skara\/json\/JSONNull.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.util.Objects;\n+\n@@ -60,0 +62,17 @@\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONNumber that = (JSONNumber) o;\n+        return value == that.value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n","filename":"json\/src\/main\/java\/org\/openjdk\/skara\/json\/JSONNumber.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -151,0 +151,17 @@\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONObject that = (JSONObject) o;\n+        return value.equals(that.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n","filename":"json\/src\/main\/java\/org\/openjdk\/skara\/json\/JSONObject.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-        return new JSONNull();\n+        return JSONNull.instance;\n","filename":"json\/src\/main\/java\/org\/openjdk\/skara\/json\/JSONParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.util.Objects;\n+\n@@ -84,0 +86,17 @@\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        JSONString that = (JSONString) o;\n+        return Objects.equals(value, that.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n","filename":"json\/src\/main\/java\/org\/openjdk\/skara\/json\/JSONString.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-        return new JSONNull();\n+        return JSONNull.instance;\n","filename":"json\/src\/main\/java\/org\/openjdk\/skara\/json\/JSONValue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+    \/\/ dependent code for testing.\n+    private Duration minTimeStampUpdateInterval = Duration.ZERO;\n+    \/\/ Setting this field doesn't change the behavior of the TestHost, but it changes\n+    \/\/ what the associated method returns, which triggers different code paths in\n@@ -277,0 +281,9 @@\n+    public void setMinTimeStampUpdateInterval(Duration minTimeStampUpdateInterval) {\n+        this.minTimeStampUpdateInterval = minTimeStampUpdateInterval;\n+    }\n+\n+    @Override\n+    public Duration minTimeStampUpdateInterval() {\n+        return minTimeStampUpdateInterval;\n+    }\n+\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestHost.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}