{"files":[{"patch":"@@ -1123,0 +1123,1 @@\n+        String jcheckType = \"jcheck\";\n@@ -1148,1 +1149,2 @@\n-                    var commits = localRepo.commitMetadata(localRepo.mergeBase(PullRequestUtils.targetHash(localRepo), pr.headHash()), commitHash);\n+                    var commits = localRepo.commitMetadata(localRepo.mergeBase(\n+                            PullRequestUtils.targetHash(localRepo), pr.headHash()), commitHash);\n@@ -1154,13 +1156,8 @@\n-                        try {\n-                            PullRequestCheckIssueVisitor visitor = checkablePullRequest.createVisitor(hash);\n-                            checkablePullRequest.executeChecks(hash, censusInstance, visitor, List.of(), hash);\n-                            mergeJCheckMessage.addAll(visitor.messages().stream()\n-                                    .map(StringBuilder::new)\n-                                    .map(e -> e.append(\" (in commit \" + hash.hex() + \")\"))\n-                                    .map(StringBuilder::toString)\n-                                    .toList());\n-                        } catch (Exception e) {\n-                            var message = e.getMessage() + \" (exception thrown when running jcheck with commit \" + hash.hex() + \")\";\n-                            log.warning(message);\n-                            mergeJCheckMessage.add(message);\n-                        }\n+                        jcheckType = \"merge jcheck in commit \" + hash.hex();\n+                        PullRequestCheckIssueVisitor visitor = checkablePullRequest.createVisitor(hash);\n+                        checkablePullRequest.executeChecks(hash, censusInstance, visitor, List.of(), hash);\n+                        mergeJCheckMessage.addAll(visitor.messages().stream()\n+                                .map(StringBuilder::new)\n+                                .map(e -> e.append(\" (in commit \" + hash.hex() + \")\"))\n+                                .map(StringBuilder::toString)\n+                                .toList());\n@@ -1191,1 +1188,0 @@\n-            boolean sourceBranchJCheckConfValid = true;\n@@ -1200,0 +1196,1 @@\n+                jcheckType = \"jcheck\";\n@@ -1205,15 +1202,9 @@\n-                    try {\n-                        PullRequestCheckIssueVisitor visitor2 = checkablePullRequest.createVisitor(pr.headHash());\n-                        log.info(\"Run jcheck again with the updated configuration\");\n-                        checkablePullRequest.executeChecks(localHash, censusInstance, visitor2, additionalConfiguration, pr.headHash());\n-                        secondJCheckMessage.addAll(visitor2.messages().stream()\n-                                .map(StringBuilder::new)\n-                                .map(e -> e.append(\" (failed with the updated jcheck configuration)\"))\n-                                .map(StringBuilder::toString)\n-                                .toList());\n-                    } catch (Exception e) {\n-                        var message = e.getMessage() + \" (exception thrown when running jcheck with updated jcheck configuration)\";\n-                        log.warning(message);\n-                        secondJCheckMessage.add(message);\n-                        sourceBranchJCheckConfValid = false;\n-                    }\n+                    jcheckType = \"second jcheck\";\n+                    PullRequestCheckIssueVisitor visitor2 = checkablePullRequest.createVisitor(pr.headHash());\n+                    log.info(\"Run jcheck again with the updated configuration\");\n+                    checkablePullRequest.executeChecks(localHash, censusInstance, visitor2, additionalConfiguration, pr.headHash());\n+                    secondJCheckMessage.addAll(visitor2.messages().stream()\n+                            .map(StringBuilder::new)\n+                            .map(e -> e.append(\" (failed with the updated jcheck configuration)\"))\n+                            .map(StringBuilder::toString)\n+                            .toList());\n@@ -1227,1 +1218,1 @@\n-            if (confFile.isPresent() && sourceBranchJCheckConfValid) {\n+            if (confFile.isPresent()) {\n@@ -1320,1 +1311,1 @@\n-            checkBuilder.title(\"Exception occurred during jcheck - the operation will be retried\");\n+            checkBuilder.title(\"Exception occurred during \" + jcheckType + \" - the operation will be retried\");\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":23,"deletions":32,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1353,1 +1353,1 @@\n-    void useJCheckConfFromTargetBranch(TestInfo testInfo) throws IOException {\n+    void invalidUpdatedJCheckConf(TestInfo testInfo) throws IOException {\n@@ -1378,5 +1378,4 @@\n-            \/\/ Check the status - should *not* throw because valid .jcheck\/conf from\n-            \/\/ \"master\" branch should be used\n-            TestBotRunner.runPeriodicItems(checkBot);\n-            TestBotRunner.runPeriodicItems(checkBot);\n-            TestBotRunner.runPeriodicItems(checkBot);\n+            \/\/ Check the status - should throw because in edit hash, .jcheck\/conf is updated and it will trigger second jcheck\n+            assertThrows(RuntimeException.class, () -> TestBotRunner.runPeriodicItems(checkBot));\n+            assertThrows(RuntimeException.class, () -> TestBotRunner.runPeriodicItems(checkBot));\n+            assertThrows(RuntimeException.class, () -> TestBotRunner.runPeriodicItems(checkBot));\n@@ -1384,1 +1383,1 @@\n-            \/\/ Verify that the check succeeded\n+            \/\/ Verify that the check failed\n@@ -1388,1 +1387,3 @@\n-            assertEquals(CheckStatus.SUCCESS, check.status());\n+            assertEquals(CheckStatus.FAILURE, check.status());\n+            assertEquals(\"line 0: entry must be of form 'key = value'\", check.summary().get());\n+            assertEquals(\"Exception occurred during second jcheck - the operation will be retried\", check.title().get());\n@@ -2780,1 +2781,1 @@\n-            TestBotRunner.runPeriodicItems(checkBot);\n+            assertThrows(RuntimeException.class, () -> TestBotRunner.runPeriodicItems(checkBot));\n@@ -2782,2 +2783,7 @@\n-            \/\/ pr body should have the integrationBlocker for exception\n-            assertTrue(pr.store().body().contains(\"(exception thrown when running jcheck with updated jcheck configuration)\"));\n+            \/\/ Verify that the check failed\n+            checks = pr.checks(updateHash);\n+            assertEquals(1, checks.size());\n+            check = checks.get(\"jcheck\");\n+            assertEquals(CheckStatus.FAILURE, check.status());\n+            assertEquals(\"line 18: entry must be of form 'key = value'\", check.summary().get());\n+            assertEquals(\"Exception occurred during second jcheck - the operation will be retried\", check.title().get());\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/CheckTests.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import org.openjdk.skara.forge.CheckStatus;\n@@ -1784,1 +1785,1 @@\n-            \/\/ The bot should reply with an ok message\n+            \/\/ The bot should not push the commit\n@@ -1790,2 +1791,60 @@\n-            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed when running jcheck with commit \" + otherHash1.hex() + \")\"));\n-            assertTrue(pr.store().body().contains(\"Whitespace errors (failed when running jcheck with commit \" + otherHash2.hex() + \")\"));\n+            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (in commit \" + otherHash1.hex() + \")\"));\n+            assertTrue(pr.store().body().contains(\"Whitespace errors (in commit \" + otherHash2.hex() + \")\"));\n+        }\n+    }\n+\n+    @Test\n+    void JCheckConfInvalidInOneOfTheCommits(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(integrator.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).jcheckMerge(true).build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Make more changes in another branch\n+            var otherHash1 = CheckableRepository.appendAndCommit(localRepo, \"First change in other_\/-1.2\",\n+                    \"First other_\/-1.2\");\n+            localRepo.push(otherHash1, author.authenticatedUrl(), \"other_\/-1.2\", true);\n+\n+            var confPath = localRepoFolder.resolve(\".jcheck\/conf\");\n+            Files.writeString(confPath, \"Hello there!\", StandardCharsets.UTF_8);\n+            localRepo.add(confPath);\n+            var otherHash2 = CheckableRepository.appendAndCommit(localRepo, \"Second change in other_\/-1.2\\n\\r\",\n+                    \"Second other_\/-1.2\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash2, author.authenticatedUrl(), \"other_\/-1.2\");\n+\n+            \/\/ Go back to the original master\n+            localRepo.checkout(masterHash, true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var unrelated = Files.writeString(localRepo.root().resolve(\"unrelated.txt\"), \"Unrelated\", StandardCharsets.UTF_8);\n+            localRepo.add(unrelated);\n+            var updatedMaster = localRepo.commit(\"Unrelated\", \"some\", \"some@one\");\n+            localRepo.merge(otherHash2);\n+            localRepo.push(updatedMaster, author.authenticatedUrl(), \"master\");\n+\n+            var mergeHash = localRepo.commit(\"Merge commit\", \"some\", \"some@one\");\n+            localRepo.push(mergeHash, author.authenticatedUrl(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Merge \" + author.name() + \":other_\/-1.2\");\n+\n+            \/\/ Let the bot check the status\n+            assertThrows(RuntimeException.class, () -> TestBotRunner.runPeriodicItems(mergeBot));\n+\n+            var checks = pr.checks(mergeHash);\n+            assertEquals(1, checks.size());\n+            var check = checks.get(\"jcheck\");\n+            assertEquals(CheckStatus.FAILURE, check.status());\n+            assertEquals(\"line 0: entry must be of form 'key = value'\", check.summary().get());\n+            assertEquals(\"Exception occurred during merge jcheck in commit \" + otherHash2.hex() + \" - the operation will be retried\",\n+                    check.title().get());\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/MergeTests.java","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"}]}