{"files":[{"patch":"@@ -89,1 +89,0 @@\n-            var retargetedDependencies = PreIntegrations.retargetDependencies(pr);\n@@ -91,8 +90,10 @@\n-            for (var retargeted : retargetedDependencies) {\n-                log.info(\"Posting retargeted comment on PR \" + pr.id());\n-                retargeted.addComment(\"\"\"\n-                    The dependent pull request has now been integrated, and the target branch of this pull request \\\n-                    has been updated. This means that changes from the dependent pull request can start to show up \\\n-                    as belonging to this pull request, which may be confusing for reviewers. To remedy this situation, \\\n-                    simply merge the latest changes from the new target branch into this pull request by running commands \\\n-                    similar to these in the local repository for your personal fork:\n+            if (pr.labelNames().contains(\"integrated\")) {\n+                var retargetedDependencies = PreIntegrations.retargetDependencies(pr);\n+                for (var retargeted : retargetedDependencies) {\n+                    log.info(\"Posting retargeted comment on PR \" + pr.id());\n+                    retargeted.addComment(\"\"\"\n+                            The dependent pull request has now been integrated, and the target branch of this pull request \\\n+                            has been updated. This means that changes from the dependent pull request can start to show up \\\n+                            as belonging to this pull request, which may be confusing for reviewers. To remedy this situation, \\\n+                            simply merge the latest changes from the new target branch into this pull request by running commands \\\n+                            similar to these in the local repository for your personal fork:\n@@ -100,9 +101,11 @@\n-                    ```bash\n-                    git checkout %s\n-                    git fetch %s %s\n-                    git merge FETCH_HEAD\n-                    # if there are conflicts, follow the instructions given by git merge\n-                    git commit -m \"Merge %s\"\n-                    git push\n-                    ```\n-                    \"\"\".formatted(retargeted.sourceRef(), pr.repository().webUrl(), pr.targetRef(), pr.targetRef()));\n+                            ```bash\n+                            git checkout %s\n+                            git fetch %s %s\n+                            git merge FETCH_HEAD\n+                            # if there are conflicts, follow the instructions given by git merge\n+                            git commit -m \"Merge %s\"\n+                            git push\n+                            ```\n+                            \"\"\".formatted(retargeted.sourceRef(), pr.repository().webUrl(), pr.targetRef(),\n+                            pr.targetRef()));\n+                }\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/prbranch\/PullRequestBranchNotifier.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -290,0 +290,11 @@\n+            \/\/ The follow-up PR shouldn't been retargeted because the source PR is only closed but not integrated.\n+            followUpPr = repo.pullRequest(followUpPr.id());\n+            assertEquals(PreIntegrations.preIntegrateBranch(pr), followUpPr.targetRef());\n+\n+            \/\/ Simulate integrating the PR. Re-open and re-close is necessary because we want the state to be changed.\n+            pr.setState(Issue.State.OPEN);\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+            pr.setState(Issue.State.CLOSED);\n+            pr.addLabel(\"integrated\");\n+            TestBotRunner.runPeriodicItems(notifyBot);\n+\n","filename":"bots\/notify\/src\/test\/java\/org\/openjdk\/skara\/bots\/notify\/prbranch\/PullRequestBranchNotifierTests.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}