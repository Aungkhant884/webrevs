{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import java.util.regex.Pattern;\n@@ -63,0 +64,1 @@\n+    private static final Pattern BACKPORT_PATTERN = Pattern.compile(\"<!-- backport ([0-9a-z]{40}) -->\");\n@@ -274,0 +276,110 @@\n+    private boolean updateClean(Hash hash) {\n+        var result = pr.repository().forge().search(hash);\n+        if (result.isEmpty()) {\n+            throw new IllegalStateException(\"Backport comment for PR \" + pr.id() + \" contains bad hash: \" + hash.hex());\n+        }\n+\n+        var hasCleanLabel = labels.contains(\"clean\");\n+\n+        var commit = result.get();\n+        var originalPatches = new HashMap<String, Patch>();\n+        for (var patch : commit.parentDiffs().get(0).patches()) {\n+            originalPatches.put(patch.toString(), patch);\n+        }\n+        var prPatches = new HashMap<String, Patch>();\n+        for (var patch : pr.diff().patches()) {\n+            prPatches.put(patch.toString(), patch);\n+        }\n+\n+        if (originalPatches.size() != prPatches.size()) {\n+            if (hasCleanLabel) {\n+                pr.removeLabel(\"clean\");\n+            }\n+            return false;\n+        }\n+\n+        var descriptions = new HashSet<>(originalPatches.keySet());\n+        descriptions.removeAll(prPatches.keySet());\n+        if (!descriptions.isEmpty()) {\n+            if (hasCleanLabel) {\n+                pr.removeLabel(\"clean\");\n+            }\n+            return false;\n+        }\n+\n+        for (var desc : originalPatches.keySet()) {\n+            var original = originalPatches.get(desc).asTextualPatch();\n+            var backport = prPatches.get(desc).asTextualPatch();\n+            if (original.hunks().size() != backport.hunks().size()) {\n+                if (hasCleanLabel) {\n+                    pr.removeLabel(\"clean\");\n+                }\n+                return false;\n+            }\n+            if (original.additions() != backport.additions()) {\n+                if (hasCleanLabel) {\n+                    pr.removeLabel(\"clean\");\n+                }\n+                return false;\n+            }\n+            if (original.deletions() != backport.deletions()) {\n+                if (hasCleanLabel) {\n+                    pr.removeLabel(\"clean\");\n+                }\n+                return false;\n+            }\n+            for (var i = 0; i < original.hunks().size(); i++) {\n+                var originalHunk = original.hunks().get(i);\n+                var backportHunk = backport.hunks().get(i);\n+\n+                if (originalHunk.source().lines().size() != backportHunk.source().lines().size()) {\n+                    if (hasCleanLabel) {\n+                        pr.removeLabel(\"clean\");\n+                    }\n+                    return false;\n+                }\n+                var sourceLines = new HashSet<>(originalHunk.source().lines());\n+                sourceLines.removeAll(backportHunk.source().lines());\n+                if (!sourceLines.isEmpty()) {\n+                    if (hasCleanLabel) {\n+                        pr.removeLabel(\"clean\");\n+                    }\n+                    return false;\n+                }\n+\n+                if (originalHunk.target().lines().size() != backportHunk.target().lines().size()) {\n+                    if (hasCleanLabel) {\n+                        pr.removeLabel(\"clean\");\n+                    }\n+                    return false;\n+                }\n+                var targetLines = new HashSet<>(originalHunk.target().lines());\n+                targetLines.removeAll(backportHunk.target().lines());\n+                if (!targetLines.isEmpty()) {\n+                    if (hasCleanLabel) {\n+                        pr.removeLabel(\"clean\");\n+                    }\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        if (!hasCleanLabel) {\n+            pr.addLabel(\"clean\");\n+        }\n+        return true;\n+    }\n+\n+    private Optional<Hash> backportedFrom() {\n+        var botUser = pr.repository().forge().currentUser();\n+        var backportLines = pr.comments()\n+                              .stream()\n+                              .filter(c -> c.author().equals(botUser))\n+                              .flatMap(c -> Stream.of(c.body().split(\"\\n\")))\n+                              .map(l -> BACKPORT_PATTERN.matcher(l))\n+                              .filter(Matcher::find)\n+                              .collect(Collectors.toList());\n+        return backportLines.isEmpty()?\n+            Optional.empty() : Optional.of(new Hash(backportLines.get(0).group(1)));\n+    }\n+\n@@ -849,0 +961,2 @@\n+                \/\/ Do not pass eventual original commit even for backports since it will cause\n+                \/\/ the reviewer check to be ignored.\n@@ -867,0 +981,5 @@\n+            var original = backportedFrom();\n+            var isCleanBackport = false;\n+            if (original.isPresent()) {\n+                isCleanBackport = updateClean(original.get());\n+            }\n@@ -880,1 +999,1 @@\n-            var amendedHash = checkablePullRequest.amendManualReviewers(localHash, censusInstance.namespace());\n+            var amendedHash = checkablePullRequest.amendManualReviewers(localHash, censusInstance.namespace(), original.orElse(null));\n@@ -886,0 +1005,6 @@\n+            if (isCleanBackport) {\n+                \/\/ Reviews are not needed for clean backports\n+                readyForIntegration = visitor.isReadyForReview() &&\n+                                      additionalErrors.isEmpty() &&\n+                                      integrationBlockers.isEmpty();\n+            }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":126,"deletions":1,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-    Hash amendManualReviewers(Hash commit, Namespace namespace) throws IOException {\n+    Hash amendManualReviewers(Hash commit, Namespace namespace, Hash original) throws IOException {\n@@ -144,2 +144,2 @@\n-        var originalCommitMessage = commitMessage(activeReviews, namespace, false);\n-        var amendedCommitMessage = commitMessage(activeReviews, namespace, true);\n+        var originalCommitMessage = commitMessage(activeReviews, namespace, false, original);\n+        var amendedCommitMessage = commitMessage(activeReviews, namespace, true, original);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckablePullRequest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                var amendedHash = checkablePr.amendManualReviewers(localHash, censusInstance.namespace());\n+                var amendedHash = checkablePr.amendManualReviewers(localHash, censusInstance.namespace(), original);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    private static final Pattern BACKPORT_PATTERN = Pattern.compile(\"<-- backport ([0-9a-z]{40}) -->\");\n+    private static final Pattern BACKPORT_PATTERN = Pattern.compile(\"<!-- backport ([0-9a-z]{40}) -->\");\n@@ -140,1 +140,1 @@\n-                var amendedHash = checkablePr.amendManualReviewers(localHash, censusInstance.namespace());\n+                var amendedHash = checkablePr.amendManualReviewers(localHash, censusInstance.namespace(), original);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,2 +92,3 @@\n-            assertLastCommentContains(pr, \"This backport pull request has now been updated with issue\");\n-            assertLastCommentContains(pr, \"<!-- backport \" + releaseHash.hex() + \" -->\");\n+            var backportComment = pr.comments().get(0).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + releaseHash.hex() + \" -->\"));\n@@ -128,4 +129,0 @@\n-            for (var c : pr.comments()) {\n-                System.out.println(c.body());\n-                System.out.println(\"-------------------------------\");\n-            }\n@@ -195,2 +192,4 @@\n-            assertLastCommentContains(pr, \"This backport pull request has now been updated with issue and summary\");\n-            assertLastCommentContains(pr, \"<!-- backport \" + releaseHash.hex() + \" -->\");\n+            var comments = pr.comments();\n+            var backportComment = comments.get(0).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + releaseHash.hex() + \" -->\"));\n@@ -231,4 +230,0 @@\n-            for (var c : pr.comments()) {\n-                System.out.println(c.body());\n-                System.out.println(\"-------------------------------\");\n-            }\n@@ -301,2 +296,3 @@\n-            assertLastCommentContains(pr, \"This backport pull request has now been updated with issues and summary\");\n-            assertLastCommentContains(pr, \"<!-- backport \" + releaseHash.hex() + \" -->\");\n+            var backportComment = pr.comments().get(0).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + releaseHash.hex() + \" -->\"));\n@@ -337,4 +333,0 @@\n-            for (var c : pr.comments()) {\n-                System.out.println(c.body());\n-                System.out.println(\"-------------------------------\");\n-            }\n@@ -393,0 +385,480 @@\n+\n+    @Test\n+    void cleanBackport(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory(false);\n+             var pushedFolder = new TemporaryDirectory(false)) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"hello\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var releaseHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+            localRepo.push(releaseHash, author.url(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.java.net\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + releaseHash.hex());\n+\n+            \/\/ The bot should reply with a backport message\n+            TestBotRunner.runPeriodicItems(bot);\n+            var comments = pr.comments();\n+            var backportComment = comments.get(0).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + releaseHash.hex() + \" -->\"));\n+            assertEquals(issue1Number + \": An issue\", pr.title());\n+\n+            \/\/ The bot should have added the \"clean\" label\n+            assertTrue(pr.labels().contains(\"clean\"));\n+        }\n+    }\n+\n+    @Test\n+    void fuzzyCleanBackport(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory(false);\n+             var pushedFolder = new TemporaryDirectory(false)) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"a\\nb\\nc\\nd\\n\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var masterHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            Files.writeString(newFile, \"a\\nb\\nc\\nd\\ne\");\n+            localRepo.add(newFile);\n+            var issue2 = credentials.createIssue(issues, \"Another issue\");\n+            var issue2Number = issue2.id().split(\"-\")[1];\n+            var upstreamMessage = issue2Number + \": Another issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var upstreamHash = localRepo.commit(upstreamMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+            localRepo.push(upstreamHash, author.url(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            Files.writeString(newFile, \"a\\nb\\nc\\ne\\nd\\n\");\n+            localRepo.add(newFile);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.java.net\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + upstreamHash.hex());\n+\n+            \/\/ The bot should reply with a backport message\n+            TestBotRunner.runPeriodicItems(bot);\n+            var comments = pr.comments();\n+            var backportComment = comments.get(0).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + upstreamHash.hex() + \" -->\"));\n+            assertEquals(issue2Number + \": Another issue\", pr.title());\n+\n+            \/\/ The bot should have added the \"clean\" label\n+            assertTrue(pr.labels().contains(\"clean\"));\n+        }\n+    }\n+\n+    @Test\n+    void notCleanBackport(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory(false);\n+             var pushedFolder = new TemporaryDirectory(false)) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"a\\nb\\nc\\nd\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var masterHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            Files.writeString(newFile, \"a\\nb\\nc\\nd\\ne\");\n+            localRepo.add(newFile);\n+            var issue2 = credentials.createIssue(issues, \"Another issue\");\n+            var issue2Number = issue2.id().split(\"-\")[1];\n+            var upstreamMessage = issue2Number + \": Another issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var upstreamHash = localRepo.commit(upstreamMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+            localRepo.push(upstreamHash, author.url(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            Files.writeString(newFile, \"a\\nb\\nc\\nd\\nd\");\n+            localRepo.add(newFile);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.java.net\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + upstreamHash.hex());\n+\n+            \/\/ The bot should reply with a backport message\n+            TestBotRunner.runPeriodicItems(bot);\n+            var comments = pr.comments();\n+            var backportComment = comments.get(0).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + upstreamHash.hex() + \" -->\"));\n+            assertEquals(issue2Number + \": Another issue\", pr.title());\n+\n+            \/\/ The bot should not have added the \"clean\" label\n+            assertFalse(pr.labels().contains(\"clean\"));\n+        }\n+    }\n+\n+    @Test\n+    void notCleanBackportAdditionalFile(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory(false);\n+             var pushedFolder = new TemporaryDirectory(false)) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"a\\nb\\nc\\nd\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var masterHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            Files.writeString(newFile, \"a\\nb\\nc\\nd\\ne\");\n+            localRepo.add(newFile);\n+            var issue2 = credentials.createIssue(issues, \"Another issue\");\n+            var issue2Number = issue2.id().split(\"-\")[1];\n+            var upstreamMessage = issue2Number + \": Another issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var upstreamHash = localRepo.commit(upstreamMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+            localRepo.push(upstreamHash, author.url(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            Files.writeString(newFile, \"a\\nb\\nc\\nd\\ne\");\n+            localRepo.add(newFile);\n+            var anotherFile = localRepo.root().resolve(\"another_file.txt\");\n+            Files.writeString(anotherFile, \"f\\ng\\nh\\ni\");\n+            localRepo.add(anotherFile);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.java.net\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + upstreamHash.hex());\n+\n+            \/\/ The bot should reply with a backport message\n+            TestBotRunner.runPeriodicItems(bot);\n+            var comments = pr.comments();\n+            var backportComment = comments.get(0).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + upstreamHash.hex() + \" -->\"));\n+            assertEquals(issue2Number + \": Another issue\", pr.title());\n+\n+            \/\/ The bot should not have added the \"clean\" label\n+            assertFalse(pr.labels().contains(\"clean\"));\n+        }\n+    }\n+\n+    @Test\n+    void cleanBackportFromCommitterCanBeIntegrated(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory();\n+             var pushedFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"hello\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var releaseHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+            localRepo.push(releaseHash, author.url(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.java.net\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + releaseHash.hex());\n+\n+            \/\/ The bot should reply with a backport message and that the PR is ready\n+            TestBotRunner.runPeriodicItems(bot);\n+            var backportComment = pr.comments().get(0).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + releaseHash.hex() + \" -->\"));\n+            assertEquals(issue1Number + \": An issue\", pr.title());\n+            assertLastCommentContains(pr, \"This change now passes all *automated* pre-integration checks\");\n+            assertTrue(pr.labels().contains(\"ready\"));\n+            assertTrue(pr.labels().contains(\"rfr\"));\n+            assertTrue(pr.labels().contains(\"clean\"));\n+\n+            \/\/ Integrate\n+            var prAsCommitter = author.pullRequest(pr.id());\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Find the commit\n+            assertLastCommentContains(pr, \"Pushed as commit\");\n+\n+            String hex = null;\n+            var comment = pr.comments().get(pr.comments().size() - 1);\n+            var lines = comment.body().split(\"\\n\");\n+            var pattern = Pattern.compile(\".* Pushed as commit ([0-9a-z]{40}).*\");\n+            for (var line : lines) {\n+                var m = pattern.matcher(line);\n+                if (m.matches()) {\n+                    hex = m.group(1);\n+                    break;\n+                }\n+            }\n+            assertNotNull(hex);\n+            assertEquals(40, hex.length());\n+            localRepo.checkout(localRepo.defaultBranch());\n+            localRepo.pull(author.url().toString(), \"master\", false);\n+            var commit = localRepo.lookup(new Hash(hex)).orElseThrow();\n+\n+            var message = CommitMessageParsers.v1.parse(commit);\n+            assertEquals(1, message.issues().size());\n+            assertEquals(\"An issue\", message.issues().get(0).description());\n+            assertEquals(List.of(), message.reviewers());\n+            assertEquals(Optional.of(releaseHash), message.original());\n+            assertEquals(List.of(), message.contributors());\n+            assertEquals(List.of(), message.summaries());\n+            assertEquals(List.of(), message.additional());\n+        }\n+    }\n+\n+    @Test\n+    void cleanBackportFromAuthorCanBeIntegrated(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory();\n+             var pushedFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"hello\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var releaseHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+            localRepo.push(releaseHash, author.url(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.java.net\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + releaseHash.hex());\n+\n+            \/\/ The bot should reply with a backport message and that the PR is ready\n+            TestBotRunner.runPeriodicItems(bot);\n+            var backportComment = pr.comments().get(0).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + releaseHash.hex() + \" -->\"));\n+            assertEquals(issue1Number + \": An issue\", pr.title());\n+            assertLastCommentContains(pr, \"This change now passes all *automated* pre-integration checks\");\n+            assertTrue(pr.labels().contains(\"ready\"));\n+            assertTrue(pr.labels().contains(\"rfr\"));\n+            assertTrue(pr.labels().contains(\"clean\"));\n+            assertFalse(pr.labels().contains(\"sponsor\"));\n+\n+            \/\/ Integrate\n+            var prAsAuthor = author.pullRequest(pr.id());\n+            prAsAuthor.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply with a sponsor message\n+            assertTrue(pr.labels().contains(\"sponsor\"));\n+\n+            \/\/ Sponsor the commit\n+            var prAsReviewer = reviewer.pullRequest(pr.id());\n+            prAsReviewer.addComment(\"\/sponsor\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Find the commit\n+            for (var comment : pr.comments()) {\n+                System.out.println(comment.body());\n+            }\n+            assertLastCommentContains(pr, \"Pushed as commit\");\n+\n+            String hex = null;\n+            var comment = pr.comments().get(pr.comments().size() - 1);\n+            var lines = comment.body().split(\"\\n\");\n+            var pattern = Pattern.compile(\".* Pushed as commit ([0-9a-z]{40}).*\");\n+            for (var line : lines) {\n+                var m = pattern.matcher(line);\n+                if (m.matches()) {\n+                    hex = m.group(1);\n+                    break;\n+                }\n+            }\n+            assertNotNull(hex);\n+            assertEquals(40, hex.length());\n+            localRepo.checkout(localRepo.defaultBranch());\n+            localRepo.pull(author.url().toString(), \"master\", false);\n+            var commit = localRepo.lookup(new Hash(hex)).orElseThrow();\n+\n+            var message = CommitMessageParsers.v1.parse(commit);\n+            assertNotEquals(commit.author(), commit.committer());\n+            assertEquals(1, message.issues().size());\n+            assertEquals(\"An issue\", message.issues().get(0).description());\n+            assertEquals(List.of(), message.reviewers());\n+            assertEquals(Optional.of(releaseHash), message.original());\n+            assertEquals(List.of(), message.contributors());\n+            assertEquals(List.of(), message.summaries());\n+            assertEquals(List.of(), message.additional());\n+        }\n+    }\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/BackportTests.java","additions":490,"deletions":18,"binary":false,"changes":508,"status":"modified"}]}