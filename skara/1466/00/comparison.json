{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.skara.host.HostUser;\n@@ -45,0 +46,4 @@\n+    private void showHelpInPR(PrintWriter reply) {\n+        reply.println(\"Usage: `\/backport <repository> [<branch>]` `\/backport disable <repository> [<branch>]`\");\n+    }\n+\n@@ -55,0 +60,5 @@\n+    private static final String USER_INVALID_WARNING = \"To use the `\/backport` command, you need to be in the OpenJDK [census](https:\/\/openjdk.org\/census)\"\n+            + \" and your GitHub account needs to be linked with your OpenJDK username\"\n+            + \" ([how to associate your GitHub account with your OpenJDK username]\"\n+            + \"(https:\/\/wiki.openjdk.org\/display\/skara#Skara-AssociatingyourGitHubaccountandyourOpenJDKusername)).\";\n+\n@@ -56,3 +66,81 @@\n-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n-                CommandInvocation command, List<Comment> allComments, PrintWriter reply) {\n-        reply.println(\"The command `backport` can only be used in a pull request that has been integrated.\");\n+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply, List<String> labelsToAdd, List<String> labelsToRemove) {\n+        if (censusInstance.contributor(command.user()).isEmpty()) {\n+            reply.println(USER_INVALID_WARNING);\n+            return;\n+        }\n+\n+        if (pr.isClosed() && !pr.labelNames().contains(\"integrated\")) {\n+            reply.println(\"`\/backport` command can not be used in closed but not integrated PR\");\n+            return;\n+        }\n+\n+        var args = command.args();\n+        if (args.isBlank()) {\n+            showHelpInPR(reply);\n+            return;\n+        }\n+\n+        var parts = args.split(\" \");\n+        boolean argIsValid = parts[0].equals(\"disable\") ? parts.length == 2 || parts.length == 3 : parts.length <= 2;\n+        if (!argIsValid) {\n+            showHelpInPR(reply);\n+            return;\n+        }\n+\n+        if (parts[0].equals(\"disable\")) {\n+            \/\/ Remove label\n+            var targetRepoName = parts[1];\n+            var targetBranchName = parts.length == 3 ? parts[2] : \"master\";\n+            var backportLabel = generateBackportLabel(targetRepoName, targetBranchName);\n+            if (pr.labelNames().contains(backportLabel)) {\n+                labelsToRemove.add(backportLabel);\n+                reply.println(\"Backport for repo `\" + targetRepoName + \"` on branch `\" + targetBranchName + \"` was successfully disabled.\");\n+            } else {\n+                reply.println(\"Backport for repo `\" + targetRepoName + \"` on branch `\" + targetBranchName + \"` was not enabled, so you can not disable it.\");\n+            }\n+        } else {\n+            \/\/ Add label\n+            var forge = bot.repo().forge();\n+            var repoNameArg = parts[0].replace(\"http:\/\/\", \"\")\n+                    .replace(\"https:\/\/\", \"\")\n+                    .replace(forge.hostname() + \"\/\", \"\");\n+            \/\/ If the arg is given with a namespace prefix, look for an exact match,\n+            \/\/ otherwise cut off the namespace prefix before comparing with the forks\n+            \/\/ config.\n+            var includesNamespace = repoNameArg.contains(\"\/\");\n+            var repoNameOptional = bot.forks().keySet().stream()\n+                    .filter(s -> includesNamespace\n+                            ? s.equals(repoNameArg)\n+                            : s.substring(s.indexOf(\"\/\") + 1).equals(repoNameArg))\n+                    .findAny();\n+            String targetRepoName = repoNameOptional.orElse(\"<not found>\");\n+\n+            var potentialTargetRepo = repoNameOptional.flatMap(forge::repository);\n+            if (potentialTargetRepo.isEmpty()) {\n+                reply.println(\"The target repository `\" + repoNameArg + \"` is not a valid target for backports. \");\n+                reply.print(\"List of valid target repositories: \");\n+                reply.println(String.join(\", \", bot.forks().keySet().stream().sorted().toList()) + \".\");\n+                reply.println(\"Supplying the organization\/group prefix is optional.\");\n+                return;\n+            }\n+            var targetRepo = potentialTargetRepo.get();\n+\n+            var targetBranchName = parts.length == 2 ? parts[1] : \"master\";\n+            var targetBranches = targetRepo.branches();\n+            if (targetBranches.stream().noneMatch(b -> b.name().equals(targetBranchName))) {\n+                reply.println(\"The target branch `\" + targetBranchName + \"` does not exist\");\n+                return;\n+            }\n+            var backportLabel = generateBackportLabel(targetRepoName, targetBranchName);\n+            if (pr.labelNames().contains(backportLabel)) {\n+                reply.println(\"Backport for repo `\" + targetRepoName + \"` on branch `\" + targetBranchName + \"` has already been enabled.\");\n+            } else {\n+                labelsToAdd.add(backportLabel);\n+                reply.println(\"Backport for repo `\" + targetRepoName + \"` on branch `\" + targetBranchName + \"` was successfully enabled.\");\n+                reply.println(\"Please note that instructions for creating backports will be provided once this PR is integrated.\");\n+            }\n+        }\n+    }\n+\n+    private String generateBackportLabel(String targetRepo, String targetBranchName) {\n+        return \"Backport=\" + targetRepo + \":\" + targetBranchName;\n@@ -65,4 +153,1 @@\n-            reply.println(\"To use the `\/backport` command, you need to be in the OpenJDK [census](https:\/\/openjdk.org\/census)\"\n-                    + \" and your GitHub account needs to be linked with your OpenJDK username\"\n-                    + \" ([how to associate your GitHub account with your OpenJDK username]\"\n-                    + \"(https:\/\/wiki.openjdk.org\/display\/skara#Skara-AssociatingyourGitHubaccountandyourOpenJDKusername)).\");\n+            reply.println(USER_INVALID_WARNING);\n@@ -118,0 +203,23 @@\n+        \/\/ Find real user when the command user is bot\n+        HostUser realUser = command.user();\n+        if (realUser.equals(bot.repo().forge().currentUser())) {\n+            var botComment = allComments.stream()\n+                    .filter(comment -> comment.author().equals(bot.repo().forge().currentUser()))\n+                    .filter(comment -> comment.body().contains(\"Backport for repo `\" + repoName + \"` on branch `\" + targetBranchName + \"` was successfully enabled.\"))\n+                    .reduce((first, second) -> second).orElse(null);\n+            if (botComment != null) {\n+                String[] lines = botComment.body().split(\"\\\\n\");\n+                String userName = lines[1].split(\" \")[0].substring(1);\n+                var user = bot.repo().forge().user(userName);\n+                if (user.isPresent()) {\n+                    realUser = user.get();\n+                    reply.print(\"@\");\n+                    reply.print(realUser.username());\n+                    reply.print(\" \");\n+                } else {\n+                    reply.println(\"Error: can not find the real user of Backport for repo `\" + repoName + \"` on branch `\" + targetBranchName);\n+                    return;\n+                }\n+            }\n+        }\n+\n@@ -121,1 +229,1 @@\n-            var backportBranchName = command.user().username() + \"-backport-\" + hash.abbreviate();\n+            var backportBranchName = realUser.username() + \"-backport-\" + hash.abbreviate();\n@@ -193,2 +301,2 @@\n-            if (!fork.canPush(command.user())) {\n-                fork.addCollaborator(command.user(), true);\n+            if (!fork.canPush(realUser)) {\n+                fork.addCollaborator(realUser, true);\n@@ -196,1 +304,1 @@\n-            fork.restrictPushAccess(new Branch(backportBranchName), command.user());\n+            fork.restrictPushAccess(new Branch(backportBranchName), realUser);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/BackportCommand.java","additions":119,"deletions":11,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    private static final Pattern BACKPORT_LABEL_PATTERN = Pattern.compile(\"Backport=(.+):(.+)\");\n@@ -165,0 +166,1 @@\n+            processBackportLabel(pr, allComments);\n@@ -244,0 +246,1 @@\n+                processBackportLabel(pr, allComments);\n@@ -328,0 +331,20 @@\n+    static void processBackportLabel(PullRequest pr, List<Comment> allComments) {\n+        var botUser = pr.repository().forge().currentUser();\n+        for (String label : pr.labelNames()) {\n+            var matcher = BACKPORT_LABEL_PATTERN.matcher(label);\n+            if (matcher.matches()) {\n+                var repoName = matcher.group(1);\n+                var branchName = matcher.group(2);\n+                var text = \"Creating backport for repo \" + repoName + \" on branch \" + branchName\n+                        + \"\\n<!--\\n \/backport \" + repoName + \" \" + branchName + \"\\n-->\" + \"\\n\"\n+                        + PullRequestCommandWorkItem.VALID_BOT_COMMAND_MARKER;\n+                if (allComments.stream()\n+                        .filter(c -> c.author().equals(botUser))\n+                        .noneMatch(((c -> c.body().equals(text))))) {\n+                    pr.addComment(text);\n+                }\n+                pr.removeLabel(label);\n+            }\n+        }\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            markIntegratedAndClosed(pr, prePushHash.get(), reply);\n+            markIntegratedAndClosed(pr, prePushHash.get(), reply, allComments);\n@@ -134,1 +134,1 @@\n-                markIntegratedAndClosed(pr, amendedHash, reply);\n+                markIntegratedAndClosed(pr, amendedHash, reply, allComments);\n@@ -147,1 +147,2 @@\n-    private void markIntegratedAndClosed(PullRequest pr, Hash amendedHash, PrintWriter reply) {\n+    private void markIntegratedAndClosed(PullRequest pr, Hash amendedHash, PrintWriter reply, List<Comment> allComments) {\n+        IntegrateCommand.processBackportLabel(pr, allComments);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+package org.openjdk.skara.bots.pr;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.forge.Review;\n+import org.openjdk.skara.issuetracker.Issue;\n+import org.openjdk.skara.test.*;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.openjdk.skara.bots.pr.PullRequestAsserts.assertLastCommentContains;\n+\n+public class BackportPRCommandTests {\n+    @Test\n+    void simple(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var bot = credentials.getHostedRepository();\n+            var targetRepo = credentials.getHostedRepository(\"targetRepo\");\n+            var targetRepo2 = credentials.getHostedRepository(\"targetRepo2\");\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                    .addReviewer(integrator.forge().currentUser().id())\n+                    .addReviewer(bot.forge().currentUser().id())\n+                    .addCommitter(author.forge().currentUser().id());\n+            var prBot = PullRequestBot.newBuilder()\n+                    .repo(bot)\n+                    .censusRepo(censusBuilder.build())\n+                    .seedStorage(seedFolder)\n+                    .forks(Map.of(\"targetRepo\", targetRepo, \"targetRepo2\", targetRepo2))\n+                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+\n+            \/\/ Make a change with a corresponding PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"123: This is a pull request\");\n+\n+            var reviewerPr = (TestPullRequest) integrator.pullRequest(pr.id());\n+\n+            \/\/ Enable backport for targetRepo on master\n+            pr.addComment(\"\/backport targetRepo\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"Backport for repo `targetRepo` on branch `master` was successfully enabled.\");\n+            assertTrue(pr.store().labelNames().contains(\"Backport=targetRepo:master\"));\n+\n+            \/\/ Enable backport for targetRepo2 on dev, but dev does not exist\n+            pr.addComment(\"\/backport targetRepo2 dev\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"The target branch `dev` does not exist\");\n+            assertFalse(pr.store().labelNames().contains(\"Backport=targetRepo2:dev\"));\n+\n+            \/\/ Enable backport for targetRepo2 on dev\n+            localRepo.push(masterHash, targetRepo2.url(), \"dev\", true);\n+            pr.addComment(\"\/backport targetRepo2 dev\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"Backport for repo `targetRepo2` on branch `dev` was successfully enabled.\");\n+            assertTrue(pr.store().labelNames().contains(\"Backport=targetRepo2:dev\"));\n+\n+            \/\/ disable backport for targetRepo on master\n+            reviewerPr.addComment(\"\/backport disable targetRepo\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"Backport for repo `targetRepo` on branch `master` was successfully disabled.\");\n+            assertFalse(pr.store().labelNames().contains(\"Backport=targetRepo:master\"));\n+\n+            \/\/ disable backport for targetRepo again\n+            reviewerPr.addComment(\"\/backport disable targetRepo\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"Backport for repo `targetRepo` on branch `master` was not enabled, so you can not disable it.\");\n+            assertFalse(pr.store().labelNames().contains(\"Backport=targetRepo:master\"));\n+\n+            \/\/ Enable backport for targetRepo on master as reviewer\n+            reviewerPr.addComment(\"\/backport targetRepo\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"Backport for repo `targetRepo` on branch `master` was successfully enabled.\");\n+            assertTrue(pr.store().labelNames().contains(\"Backport=targetRepo:master\"));\n+\n+            \/\/ Approve this PR\n+            reviewerPr.addReview(Review.Verdict.APPROVED, \"\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertTrue(pr.store().labelNames().contains(\"ready\"));\n+\n+            \/\/ Integrate\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"was successfully created on the branch\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"Could **not** automatically backport\");\n+\n+            \/\/ Resolve conflict\n+            localRepo.push(masterHash, targetRepo.url(), \"master\", true);\n+            \/\/ Use \/backport after the pr is integrated\n+            reviewerPr.addComment(\"\/backport targetRepo\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"was successfully created on the branch\");\n+        }\n+    }\n+\n+    @Test\n+    void testBackportCommandWhenPrIsClosed(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var bot = credentials.getHostedRepository();\n+            var targetRepo = credentials.getHostedRepository(\"targetRepo\");\n+            var targetRepo2 = credentials.getHostedRepository(\"targetRepo2\");\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                    .addReviewer(integrator.forge().currentUser().id())\n+                    .addReviewer(bot.forge().currentUser().id())\n+                    .addCommitter(author.forge().currentUser().id());\n+            var prBot = PullRequestBot.newBuilder()\n+                    .repo(bot)\n+                    .censusRepo(censusBuilder.build())\n+                    .seedStorage(seedFolder)\n+                    .forks(Map.of(\"targetRepo\", targetRepo, \"targetRepo2\", targetRepo2))\n+                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"123: This is a pull request\");\n+\n+            \/\/close the pr\n+            pr.store().setState(Issue.State.CLOSED);\n+            pr.addComment(\"\/backport targetRepo\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"`\/backport` command can not be used in closed but not integrated PR\");\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/BackportPRCommandTests.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -122,1 +122,1 @@\n-            PullRequestAsserts.assertLastCommentContains(pr, \"The command `backport` can only be used in a pull request that has been integrated.\");\n+            PullRequestAsserts.assertLastCommentContains(pr, \"Backport for repo `jdk17u-dev` on branch `master` was successfully enabled.\");\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/CommitCommandTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}