{"files":[{"patch":"@@ -19,1 +19,1 @@\n-            var issuePoller = new IssuePoller(issueProject, Duration.ZERO);\n+            var issuePoller = new IssuePoller(issueProject, Duration.ofSeconds(1));\n@@ -83,1 +83,1 @@\n-    void timeStampPadding(TestInfo testInfo) throws IOException {\n+    void timeStampPadding(TestInfo testInfo) throws IOException, InterruptedException {\n@@ -88,1 +88,1 @@\n-            var issuePoller = new IssuePoller(issueProject, Duration.ZERO);\n+            var issuePoller = new IssuePoller(issueProject, Duration.ofSeconds(1));\n@@ -108,0 +108,3 @@\n+            \/\/ Sleep to make it more likely that this and the previous calls to\n+            \/\/ updatedIssues are far enough apart to trigger padding.\n+            Thread.sleep(1);\n@@ -112,3 +115,4 @@\n-            \/\/ With the extremely short precision, the poller should now be padding\n-            \/\/ the fetch query with the precision duration to avoid fetching issue1\n-            \/\/ again. We can prove that by updating the updatedAt to something after\n+            \/\/ With the extremely short precision of 2 nanos, enough time should now\n+            \/\/ have passed between the two previous polls so that the poller is now\n+            \/\/ padding the fetch query with the precision duration.\n+            \/\/ We can prove that by updating the updatedAt of issue1 to something after\n@@ -116,1 +120,2 @@\n-            \/\/ call would return it, then isUpdated should also return true.\n+            \/\/ call would return it, then isUpdated should also return true, and\n+            \/\/ updatedIssues() would then return issue1.\n@@ -136,1 +141,1 @@\n-            var issuePoller = new IssuePoller(issueProject, Duration.ZERO);\n+            var issuePoller = new IssuePoller(issueProject, Duration.ofSeconds(1));\n","filename":"issuetracker\/src\/test\/java\/org\/openjdk\/skara\/issuetracker\/IssuePollerTests.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"}]}