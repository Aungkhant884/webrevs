{"files":[{"patch":"@@ -468,0 +468,1 @@\n+    \/\/ Handles results from both comments and discussions API\n@@ -469,16 +470,41 @@\n-       var line = o.get(\"line\").isNull()? -1 : o.get(\"line\").asInt();\n-       var path = o.get(\"path\").isNull()? null : Path.of(o.get(\"path\").asString());\n-       \/\/ GitLab does not offer updated_at for commit comments\n-       var createdAt = ZonedDateTime.parse(o.get(\"created_at\").asString());\n-       \/\/ GitLab does not offer an id for commit comments\n-       var body = o.get(\"note\").asString();\n-       var user = gitLabHost.parseAuthorField(o);\n-       var id = Integer.toString((hash.hex() + createdAt.toString() + user.id()).hashCode());\n-       return new CommitComment(hash,\n-                                path,\n-                                line,\n-                                id,\n-                                body,\n-                                gitLabHost.parseAuthorField(o),\n-                                createdAt,\n-                                createdAt);\n+        if (o.contains(\"note\")) {\n+            var line = o.get(\"line\").isNull() ? -1 : o.get(\"line\").asInt();\n+            var path = o.get(\"path\").isNull() ? null : Path.of(o.get(\"path\").asString());\n+            \/\/ GitLab does not offer updated_at for commit comments\n+            var createdAt = ZonedDateTime.parse(o.get(\"created_at\").asString());\n+            var body = o.get(\"note\").asString();\n+            return new CommitComment(hash,\n+                    path,\n+                    line,\n+                    null, \/\/ The comments API does not return an ID\n+                    body,\n+                    gitLabHost.parseAuthorField(o),\n+                    createdAt,\n+                    createdAt);\n+\n+        } else if (o.contains(\"notes\")) {\n+            var note = o.get(\"notes\").asArray().get(0);\n+            var line = -1;\n+            Path path = null;\n+            if (note.contains(\"position\")) {\n+                var position = note.get(\"position\");\n+                if (!position.get(\"new_line\").isNull()) {\n+                    line = position.get(\"new_line\").asInt();\n+                    path = Path.of(position.get(\"new_path\").asString());\n+                } else if (!position.get(\"old_line\").isNull()) {\n+                    line = position.get(\"old_line\").asInt();\n+                    path = Path.of(position.get(\"old_path\").asString());\n+                }\n+            }\n+            return new CommitComment(hash,\n+                    path,\n+                    line,\n+                    String.valueOf(note.get(\"id\").asInt()),\n+                    note.get(\"body\").asString(),\n+                    gitLabHost.parseAuthorField(note),\n+                    ZonedDateTime.parse(note.get(\"created_at\").asString()),\n+                    ZonedDateTime.parse(note.get(\"updated_at\").asString()));\n+\n+        } else {\n+            throw new RuntimeException(\"Object contains neither 'note' or 'notes', cannot parse commit comment\");\n+        }\n@@ -489,1 +515,2 @@\n-        return request.get(\"repository\/commits\/\" + hash.hex() + \"\/comments\")\n+        \/\/ Using the discussions API gives us more information, most notably the ID field\n+        return request.get(\"repository\/commits\/\" + hash.hex() + \"\/discussions\")\n@@ -515,4 +542,3 @@\n-    private Hash commitWithComment(String commitTitle,\n-                                   ZonedDateTime commentCreatedAt,\n-                                   HostUser author,\n-                                   Map<String, Set<Hash>> commitTitleToCommits) {\n+    private Optional<CommitComment> findComment(String commitTitle,\n+            String commentId,\n+            Map<String, Set<Hash>> commitTitleToCommits) {\n@@ -520,2 +546,10 @@\n-        if (candidates.size() == 1) {\n-            return candidates.iterator().next();\n+        \/\/ Even if there is only one candidate, we need to make sure the comment\n+        \/\/ exists on that commit before we try to process it. If this fails it's\n+        \/\/ most likely due to inconsistent data from GitLab, which should\n+        \/\/ eventually clear up on subsequent tries.\n+        Optional<CommitComment> found = candidates.stream()\n+                .flatMap(candidate -> commitComments(candidate).stream())\n+                .filter(comment -> comment.id().equals(commentId))\n+                .findFirst();\n+        if (found.isEmpty()) {\n+            log.warning(\"Did not find commit with title \" + commitTitle + \" for repository \" + projectName);\n@@ -523,12 +557,1 @@\n-\n-        for (var candidate : candidates) {\n-            var comments = commitComments(candidate);\n-            for (var comment : comments) {\n-                if (comment.createdAt().equals(commentCreatedAt) &&\n-                    comment.author().equals(author)) {\n-                    return candidate;\n-                }\n-            }\n-        }\n-\n-        throw new RuntimeException(\"Did not find commit with title \" + commitTitle + \" for repository \" + projectName);\n+        return found;\n@@ -551,13 +574,13 @@\n-                      .param(\"after\", updatedAfter.format(formatter))\n-                      .execute()\n-                      .stream()\n-                      .filter(o -> o.contains(\"note\") &&\n-                                   o.get(\"note\").contains(\"noteable_type\") &&\n-                                   o.get(\"note\").get(\"noteable_type\").asString().equals(\"Commit\"))\n-                      .filter(o -> o.contains(\"target_type\") &&\n-                                   !o.get(\"target_type\").isNull() &&\n-                                   o.get(\"target_type\").asString().equals(\"Note\"))\n-                      .filter(o -> o.contains(\"author\") &&\n-                                   o.get(\"author\").contains(\"id\") &&\n-                                   !excludeAuthors.contains(o.get(\"author\").get(\"id\").asInt()))\n-                      .toList();\n+                .param(\"after\", updatedAfter.format(formatter))\n+                .execute()\n+                .stream()\n+                .filter(o -> o.contains(\"note\") &&\n+                        o.get(\"note\").contains(\"noteable_type\") &&\n+                        o.get(\"note\").get(\"noteable_type\").asString().equals(\"Commit\"))\n+                .filter(o -> o.contains(\"target_type\") &&\n+                        !o.get(\"target_type\").isNull() &&\n+                        o.get(\"target_type\").asString().equals(\"Note\"))\n+                .filter(o -> o.contains(\"author\") &&\n+                        o.get(\"author\").contains(\"id\") &&\n+                        !excludeAuthors.contains(o.get(\"author\").get(\"id\").asInt()))\n+                .toList();\n@@ -572,12 +595,4 @@\n-                    .map(o -> {\n-                        var createdAt = ZonedDateTime.parse(o.get(\"note\").get(\"created_at\").asString());\n-                        var body = o.get(\"note\").get(\"body\").asString();\n-                        var user = gitLabHost.parseAuthorField(o);\n-                        var id = o.get(\"note\").get(\"id\").asInt();\n-                        var hash = commitWithComment(o.get(\"target_title\").asString(),\n-                                                     createdAt,\n-                                                     user,\n-                                                     commitTitleToCommits);\n-                        return new CommitComment(hash, null, -1, String.valueOf(id), body, user, createdAt, createdAt);\n-                    })\n-                    .toList();\n+                .map(o -> findComment(o.get(\"target_title\").asString(),\n+                        String.valueOf(o.get(\"note\").get(\"id\").asInt()), commitTitleToCommits))\n+                .flatMap(Optional::stream)\n+                .toList();\n@@ -626,0 +641,4 @@\n+    \/**\n+     * The CommitComment returned from this method will not have an ID field,\n+     * this is due to a limitation in the GitLab API.\n+     *\/\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabRepository.java","additions":79,"deletions":60,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.nio.file.Path;\n+import java.time.ZonedDateTime;\n+import java.util.Set;\n@@ -324,0 +327,34 @@\n+\n+    @Test\n+    void testCommitComments() throws IOException {\n+        var settings = ManualTestSettings.loadManualTestSettings();\n+        var username = settings.getProperty(\"gitlab.user\");\n+        var token = settings.getProperty(\"gitlab.pat\");\n+        var credential = new Credential(username, token);\n+        var uri = URIBuilder.base(settings.getProperty(\"gitlab.uri\")).build();\n+        var gitLabHost = new GitLabHost(\"gitlab\", uri, false, credential, List.of());\n+        var gitLabRepo = gitLabHost.repository(settings.getProperty(\"commit.comments.gitlab.repository\")).orElseThrow();\n+        var commitHash = new Hash(settings.getProperty(\"commit.comments.hash\"));\n+\n+        var comments = gitLabRepo.commitComments(commitHash);\n+\n+        assertFalse(comments.isEmpty());\n+    }\n+\n+    @Test\n+    void testRecentCommitComments() throws IOException {\n+        var settings = ManualTestSettings.loadManualTestSettings();\n+        var username = settings.getProperty(\"gitlab.user\");\n+        var token = settings.getProperty(\"gitlab.pat\");\n+        var credential = new Credential(username, token);\n+        var uri = URIBuilder.base(settings.getProperty(\"gitlab.uri\")).build();\n+        var gitLabHost = new GitLabHost(\"gitlab\", uri, false, credential, List.of());\n+        var gitLabRepo = gitLabHost.repository(settings.getProperty(\"commit.comments.gitlab.repository\")).orElseThrow();\n+\n+        var localRepo = GitRepository.get(Path.of(settings.getProperty(\"commit.comments.local.repository\"))).orElseThrow();\n+\n+        var comments = gitLabRepo.recentCommitComments(localRepo, Set.of(), List.of(new Branch(\"master\")),\n+                ZonedDateTime.now().minus(Duration.ofDays(4)));\n+\n+        assertFalse(comments.isEmpty());\n+    }\n","filename":"forge\/src\/test\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabRestApiTest.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"}]}