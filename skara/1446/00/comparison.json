{"files":[{"patch":"@@ -25,0 +25,2 @@\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n@@ -76,3 +78,3 @@\n-            var localRepoPath = scratchPath.resolve(\"pr\").resolve(\"commit-comments\").resolve(bot.repo().name());\n-            var localRepo = hostedRepositoryPool.materializeBare(bot.repo(), localRepoPath);\n-            localRepo.fetchAll(bot.repo().url());\n+            \/\/ We are only reading data from this local repo, so no need to make a clone,\n+            \/\/ just use the seed repo directly.\n+            var seedRepo = hostedRepositoryPool.seedRepository(bot.repo(), false);\n@@ -82,1 +84,1 @@\n-                                           .collect(Collectors.toList());\n+                                           .toList();\n@@ -84,12 +86,2 @@\n-            var commitTitleToCommits = new HashMap<String, Set<Hash>>();\n-            for (var commit : localRepo.commitMetadataFor(localBranches)) {\n-                var title = commit.message().stream().findFirst().orElse(\"\");\n-                if (commitTitleToCommits.containsKey(title)) {\n-                    commitTitleToCommits.get(title).add(commit.hash());\n-                } else {\n-                    var set = new LinkedHashSet<Hash>();\n-                    set.add(commit.hash());\n-                    commitTitleToCommits.put(title, set);\n-                }\n-            }\n-            var commitComments = repo.recentCommitComments(commitTitleToCommits, excludeCommitCommentsFrom);\n+            var commitComments = repo.recentCommitComments(seedRepo, excludeCommitCommentsFrom,\n+                    localBranches, ZonedDateTime.now().minus(Duration.ofDays(4)));\n@@ -99,1 +91,1 @@\n-                                                             .anyMatch(b -> isAncestor(localRepo, cc.commit(), b.hash())))\n+                                                             .anyMatch(b -> isAncestor(seedRepo, cc.commit(), b.hash())))\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CommitCommentsWorkItem.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+                                           .excludeCommitCommentsFrom(excludeCommitCommentsFrom)\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotFactory.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -209,1 +209,2 @@\n-    public List<CommitComment> recentCommitComments(Map<String, Set<Hash>> commitTitleToCommits, Set<Integer> excludeAuthors) {\n+    public List<CommitComment> recentCommitComments(ReadOnlyRepository unused, Set<Integer> excludeAuthors,\n+            List<Branch> branches, ZonedDateTime updatedAfter) {\n","filename":"bots\/tester\/src\/test\/java\/org\/openjdk\/skara\/bots\/tester\/InMemoryHostedRepository.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.time.Duration;\n@@ -111,1 +112,1 @@\n-        return recentCommitComments(Map.of(), Set.of());\n+        return recentCommitComments(null, Set.of(), null, ZonedDateTime.now().minus(Duration.ofDays(4)));\n@@ -113,1 +114,13 @@\n-    List<CommitComment> recentCommitComments(Map<String, Set<Hash>> commitTitleToCommits, Set<Integer> excludeAuthors);\n+\n+    \/**\n+     * Fetch recent commit comments from the forge.\n+     * @param localRepo Only needed for certain implementations. Needs to be a\n+     *                  reasonably up-to-date clone of this repository\n+     * @param excludeAuthors Set of authors to exclude from the results\n+     * @param Branches Optional list of branches to limit the search to if\n+     *                 supported by the implementation.\n+     * @param updatedAfter Filter out comments older than this\n+     * @return A list of CommitComments\n+     *\/\n+    List<CommitComment> recentCommitComments(ReadOnlyRepository localRepo, Set<Integer> excludeAuthors,\n+            List<Branch> Branches, ZonedDateTime updatedAfter);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/HostedRepository.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -379,1 +379,2 @@\n-    public List<CommitComment> recentCommitComments(Map<String, Set<Hash>> commitTitleToCommits, Set<Integer> excludeAuthors) {\n+    public List<CommitComment> recentCommitComments(ReadOnlyRepository unused, Set<Integer> excludeAuthors,\n+            List<Branch> branches, ZonedDateTime updatedAfter) {\n@@ -442,0 +443,4 @@\n+                           \/\/ It's not possible to filter on timestamp in the GraphQL API, but we\n+                           \/\/ can at least filter here to limit the amount of data returned to the\n+                           \/\/ caller.\n+                           .filter(c -> c.updatedAt().isAfter(updatedAfter))\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubRepository.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n@@ -503,0 +505,5 @@\n+    \/**\n+     * The localRepo is needed to build a map of commit title to commit hash mappings,\n+     * which in turn is needed to identify commits form the GitLab notes objects. The\n+     * notes only has the commit titles, not the hashes.\n+     *\/\n@@ -504,2 +511,6 @@\n-    public List<CommitComment> recentCommitComments(Map<String, Set<Hash>> commitTitleToCommits, Set<Integer> excludeAuthors) {\n-        var fourDaysAgo = ZonedDateTime.now().minusDays(4);\n+    public List<CommitComment> recentCommitComments(ReadOnlyRepository localRepo, Set<Integer> excludeAuthors,\n+            List<Branch> branches, ZonedDateTime updatedAfter) {\n+        if (localRepo == null) {\n+            throw new NullPointerException(\"localRepo cannot be null in GitLabMergeRequest\");\n+        }\n+\n@@ -508,1 +519,1 @@\n-                      .param(\"after\", fourDaysAgo.format(formatter))\n+                      .param(\"after\", updatedAfter.format(formatter))\n@@ -520,1 +531,1 @@\n-                      .collect(Collectors.toList());\n+                      .toList();\n@@ -522,13 +533,2 @@\n-        \/\/ Fetch eventual new commits\n-        var commits = request.get(\"repository\/commits\")\n-                             .param(\"since\", ZonedDateTime.now().minusHours(1).format(DateTimeFormatter.ISO_DATE_TIME))\n-                             .execute()\n-                             .asArray();\n-        for (var commit : commits) {\n-            var hash = new Hash(commit.get(\"id\").asString());\n-            var title = commit.get(\"title\").asString();\n-            if (commitTitleToCommits.containsKey(title)) {\n-                commitTitleToCommits.get(title).add(hash);\n-            } else {\n-                commitTitleToCommits.put(title, Set.of(hash));\n-            }\n+        if (notes.isEmpty()) {\n+            return List.of();\n@@ -537,0 +537,2 @@\n+        var commitTitleToCommits = getCommitTitleToCommitsMap(localRepo, branches);\n+\n@@ -549,1 +551,41 @@\n-                    .collect(Collectors.toList());\n+                    .toList();\n+    }\n+\n+    \/**\n+     * Lazy fetching and caching of the commitTitleToCommits map. The first time\n+     * this is called, the full map is built from the local repository. After that\n+     * it's just refreshed from the server.\n+     *\/\n+    private final Map<String, Set<Hash>> commitTitleToCommits = new HashMap<>();\n+    private boolean commitTitleToCommitsInitialized = false;\n+    private ZonedDateTime lastCommitTime = ZonedDateTime.ofInstant(Instant.EPOCH, ZoneId.systemDefault());\n+    private Map<String, Set<Hash>> getCommitTitleToCommitsMap(ReadOnlyRepository localRepo, List<Branch> branches) {\n+        if (!commitTitleToCommitsInitialized) {\n+            try {\n+                for (var commit : localRepo.commitMetadataFor(branches)) {\n+                    var title = commit.message().stream().findFirst().orElse(\"\");\n+                    commitTitleToCommits.computeIfAbsent(title, t -> new LinkedHashSet<>()).add(commit.hash());\n+                    if (lastCommitTime.isBefore(commit.authored())) {\n+                        lastCommitTime = commit.authored();\n+                    }\n+                }\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            commitTitleToCommitsInitialized = true;\n+        }\n+        \/\/ Fetch eventual new commits\n+        var commits = request.get(\"repository\/commits\")\n+                .param(\"since\", lastCommitTime.format(DateTimeFormatter.ISO_DATE_TIME))\n+                .execute()\n+                .asArray();\n+        for (var commit : commits) {\n+            var hash = new Hash(commit.get(\"id\").asString());\n+            var title = commit.get(\"title\").asString();\n+            commitTitleToCommits.computeIfAbsent(title, t -> new LinkedHashSet<>()).add(hash);\n+            var authored = ZonedDateTime.parse(commit.get(\"authored_date\").asString());\n+            if (lastCommitTime.isBefore(authored)) {\n+                lastCommitTime = authored;\n+            }\n+        }\n+        return commitTitleToCommits;\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabRepository.java","additions":60,"deletions":18,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -290,1 +290,2 @@\n-    public List<CommitComment> recentCommitComments(Map<String, Set<Hash>> commitTitleToCommits, Set<Integer> excludeAuthors) {\n+    public List<CommitComment> recentCommitComments(ReadOnlyRepository unused, Set<Integer> excludeAuthors,\n+            List<Branch> branches, ZonedDateTime updatedAfter) {\n@@ -296,0 +297,1 @@\n+                             .filter(c -> c.updatedAt().isAfter(updatedAfter))\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestHostedRepository.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}