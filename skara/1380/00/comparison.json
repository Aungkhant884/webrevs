{"files":[{"patch":"@@ -105,1 +105,1 @@\n-        poller = new PullRequestPoller(repo, true, true, true);\n+        poller = new PullRequestPoller(repo, true);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -340,0 +340,5 @@\n+\n+    @Override\n+    public Object comparisonSnapshot() {\n+        return this;\n+    }\n","filename":"bots\/tester\/src\/test\/java\/org\/openjdk\/skara\/bots\/tester\/InMemoryPullRequest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,3 +56,4 @@\n-     * Returns a list of all pull requests (both open and closed) that have been updated after the\n-     * provided time, ordered by latest updated first. If there are many pull requests that\n-     * match, the list may have been truncated.\n+     * Returns a list of all pull requests (both open and closed) that have\n+     * been updated after or on the given time, with a resolution given by\n+     * Host::timeStampQueryPrecision, ordered by latest updated first. If there\n+     * are many pull requests that match, the list may have been truncated.\n@@ -63,1 +64,2 @@\n-     * Returns a list of all open pull requests that have been updated after the given time.\n+     * Returns a list of all open pull requests that have been updated after or on\n+     * the given time, with a resolution given by Host::timeStampQueryPrecision.\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/HostedRepository.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -209,0 +209,6 @@\n+\n+    \/**\n+     * Returns an object that represents a complete snapshot of this pull request.\n+     * Used for detecting if anything has changed between two snapshots.\n+     *\/\n+    Object comparisonSnapshot();\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -13,1 +13,0 @@\n-import org.openjdk.skara.issuetracker.Comment;\n@@ -15,1 +14,0 @@\n-import org.openjdk.skara.vcs.Hash;\n@@ -45,1 +43,6 @@\n-    private final Duration queryPadding;\n+    \/\/ Negative query padding is used to compensate for the forge only updating\n+    \/\/ timestamps on pull requests once for set minimum duration.\n+    private final Duration negativeQueryPadding;\n+    \/\/ Positive query padding is used to work around timestamp queries being\n+    \/\/ inclusive down to a certain time resolution.\n+    private final Duration positiveQueryPadding;\n@@ -48,2 +51,0 @@\n-    private final boolean checkComments;\n-    private final boolean checkReviews;\n@@ -59,3 +60,2 @@\n-    private record QueryResult(Map<String, PullRequest> pullRequests, Map<String, List<Comment>> comments,\n-                               Map<String, List<Review>> reviews, ZonedDateTime maxUpdatedAt,\n-                               Instant afterQuery, List<PullRequest> result) {}\n+    record QueryResult(Map<String, PullRequest> pullRequests, Map<String, Object> comparisonSnapshots,\n+                       ZonedDateTime maxUpdatedAt, Instant afterQuery, List<PullRequest> result) {}\n@@ -66,3 +66,3 @@\n-     * When enough time has past since the last time we actually received results\n-     * padding the updatedAt query parameter is no longer needed. This is indicated\n-     * using this boolean.\n+     * When enough time has passed since the last time we returned results, applying\n+     * negative padding to the updatedAt query parameter is no longer needed. This\n+     * is indicated using this boolean.\n@@ -70,1 +70,1 @@\n-    private boolean paddingNeeded = true;\n+    private boolean negativePaddingNeeded = true;\n@@ -72,2 +72,1 @@\n-    public PullRequestPoller(HostedRepository repository, boolean includeClosed, boolean commentsRelevant,\n-            boolean reviewsRelevant) {\n+    public PullRequestPoller(HostedRepository repository, boolean includeClosed) {\n@@ -76,2 +75,3 @@\n-        queryPadding = repository.forge().minTimeStampUpdateInterval();\n-        if (!queryPadding.isZero()) {\n+        negativeQueryPadding = repository.forge().minTimeStampUpdateInterval();\n+        positiveQueryPadding = repository.forge().timeStampQueryPrecision();\n+        if (!negativeQueryPadding.isZero()) {\n@@ -79,2 +79,0 @@\n-            checkComments = commentsRelevant;\n-            checkReviews = reviewsRelevant;\n@@ -83,2 +81,0 @@\n-            checkComments = false;\n-            checkReviews = false;\n@@ -89,1 +85,1 @@\n-     * The main API method. Call this go get updated PRs. When done processing the results\n+     * The main API method. Call this to get updated PRs. When done processing the results\n@@ -96,10 +92,0 @@\n-\n-        \/\/ If nothing was found. Update the paddingNeeded state if enough time\n-        \/\/ has passed since last we found something.\n-        if (prs.isEmpty()) {\n-            if (prev != null && prev.afterQuery.isBefore(beforeQuery.minus(queryPadding))) {\n-                paddingNeeded = false;\n-            }\n-        } else {\n-            paddingNeeded = true;\n-        }\n@@ -119,7 +105,2 @@\n-        \/\/ If checking comments, save the current state of comments for future\n-        \/\/ comparisons.\n-        var commentsMap = fetchComments(prs, maxUpdatedAt);\n-\n-        \/\/ If checking reviews, save the current state of reviews for future\n-        \/\/ comparisons.\n-        var reviewsMap = fetchReviews(prs, maxUpdatedAt);\n+        \/\/ Save the current comparisonSnapshots\n+        var comparisonSnapshots = fetchComparisonSnapshots(prs, maxUpdatedAt);\n@@ -136,0 +117,11 @@\n+        \/\/ If nothing is to be returned. Update the paddingNeeded state if enough time\n+        \/\/ has passed since last we found something.\n+        if (result.isEmpty()) {\n+            if (prev != null && prev.afterQuery.isBefore(beforeQuery.minus(negativeQueryPadding)\n+                    .minus(positiveQueryPadding))) {\n+                negativePaddingNeeded = false;\n+            }\n+        } else {\n+            negativePaddingNeeded = true;\n+        }\n+\n@@ -137,1 +129,1 @@\n-        current = new QueryResult(pullRequestMap, commentsMap, reviewsMap, maxUpdatedAt, afterQuery, result);\n+        current = new QueryResult(pullRequestMap, comparisonSnapshots, maxUpdatedAt, afterQuery, result);\n@@ -209,1 +201,2 @@\n-            var queryUpdatedAt = paddingNeeded ? prev.maxUpdatedAt.minus(queryPadding) : prev.maxUpdatedAt;\n+            var queryUpdatedAt = negativePaddingNeeded\n+                    ? prev.maxUpdatedAt.minus(negativeQueryPadding) : prev.maxUpdatedAt.plus(positiveQueryPadding);\n@@ -220,18 +213,4 @@\n-    private Map<String, List<Comment>> fetchComments(List<PullRequest> prs, ZonedDateTime maxUpdatedAt) {\n-        if (checkComments) {\n-            return prs.stream()\n-                    .filter(pr -> pr.updatedAt().isAfter(maxUpdatedAt.minus(queryPadding)))\n-                    .collect(Collectors.toMap(Issue::id, Issue::comments));\n-        } else {\n-            return Map.of();\n-        }\n-    }\n-\n-    private Map<String, List<Review>> fetchReviews(List<PullRequest> prs, ZonedDateTime maxUpdatedAt) {\n-        if (checkReviews) {\n-            return prs.stream()\n-                    .filter(pr -> pr.updatedAt().isAfter(maxUpdatedAt.minus(queryPadding)))\n-                    .collect(Collectors.toMap(Issue::id, PullRequest::reviews));\n-        } else {\n-            return Map.of();\n-        }\n+    private Map<String, Object> fetchComparisonSnapshots(List<PullRequest> prs, ZonedDateTime maxUpdatedAt) {\n+        return prs.stream()\n+                .filter(pr -> !pr.updatedAt().isBefore(maxUpdatedAt.minus(negativeQueryPadding)))\n+                .collect(Collectors.toMap(Issue::id, PullRequest::comparisonSnapshot));\n@@ -241,4 +220,3 @@\n-     * Evaluates if a PR has been updated since the previous query result. If we\n-     * can trust updatedAt from the forge, it's a simple comparison, otherwise\n-     * we need to compare the complete contents of the PR object, as well as\n-     * comments and\/or reviews as configured.\n+     * Evaluates if a PR has been updated since the previous query result.\n+     * First checks updatedAt and then the comparisonSnapshot of the PR if\n+     * present in the prev data.\n@@ -254,10 +232,2 @@\n-        if (!trustUpdatedAt) {\n-            if (!pr.equals(prPrev)) {\n-                return true;\n-            }\n-            if (checkComments && !pr.comments().equals(prev.comments.get(pr.id()))) {\n-                return true;\n-            }\n-            if (checkReviews && !pr.reviews().equals(prev.reviews.get(pr.id()))) {\n-                return true;\n-            }\n+        if (!pr.comparisonSnapshot().equals(prev.comparisonSnapshots.get(pr.id()))) {\n+            return true;\n@@ -324,0 +294,5 @@\n+\n+    \/\/ Expose the query results to tests\n+    QueryResult getCurrentQueryResult() {\n+        return current;\n+    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequestPoller.java","additions":47,"deletions":72,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -785,0 +785,8 @@\n+\n+    \/**\n+     * For GitHubPullRequest, the json represents the complete snapshot\n+     *\/\n+    @Override\n+    public Object comparisonSnapshot() {\n+        return json;\n+    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubPullRequest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-                      .filter(pr -> pr.updatedAt().isAfter(updatedAfter))\n+                      .filter(pr -> !pr.updatedAt().isBefore(updatedAfter))\n@@ -186,1 +186,1 @@\n-                .filter(pr -> pr.updatedAt().isAfter(updatedAfter))\n+                .filter(pr -> !pr.updatedAt().isBefore(updatedAfter))\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubRepository.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+    \/\/ Lazy cache for comparisonSnapshot\n+    private Object comparisonSnapshot;\n+\n@@ -831,0 +834,12 @@\n+    \/**\n+     * For GitLabMergeRequest, a snapshot comparison needs to include the comments\n+     * and reviews, which are both part of the general \"notes\".\n+     *\/\n+    @Override\n+    public Object comparisonSnapshot() {\n+        if (comparisonSnapshot == null) {\n+            comparisonSnapshot = List.of(json, request.get(\"notes\").execute());\n+        }\n+        return comparisonSnapshot;\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabMergeRequest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.time.ZonedDateTime;\n@@ -12,2 +13,1 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -21,1 +21,1 @@\n-            var prPoller = new PullRequestPoller(repo, false, true, true);\n+            var prPoller = new PullRequestPoller(repo, false);\n@@ -57,1 +57,1 @@\n-            var prPoller = new PullRequestPoller(repo, true, true, true);\n+            var prPoller = new PullRequestPoller(repo, true);\n@@ -102,1 +102,1 @@\n-            var prPoller = new PullRequestPoller(repo, true, false, false);\n+            var prPoller = new PullRequestPoller(repo, true);\n@@ -114,0 +114,1 @@\n+            assertFalse(prPoller.getCurrentQueryResult().pullRequests().isEmpty());\n@@ -123,16 +124,0 @@\n-\n-            \/\/ Add comment while keeping the updatedAt time unchanged. This should not trigger an update\n-            prevUpdatedAt = pr.updatedAt();\n-            pr.addComment(\"foo\");\n-            pr.store().setLastUpdate(prevUpdatedAt);\n-            prs = prPoller.updatedPullRequests();\n-            assertEquals(0, prs.size());\n-            prPoller.lastBatchHandled();\n-\n-            \/\/ Add review while keeping the updatedAt time unchanged. This should not trigger an update\n-            prevUpdatedAt = pr.updatedAt();\n-            pr.addReview(Review.Verdict.APPROVED, \"foo\");\n-            pr.store().setLastUpdate(prevUpdatedAt);\n-            prs = prPoller.updatedPullRequests();\n-            assertEquals(0, prs.size());\n-            prPoller.lastBatchHandled();\n@@ -151,1 +136,1 @@\n-            var prPoller = new PullRequestPoller(repo, true, true, false);\n+            var prPoller = new PullRequestPoller(repo, true);\n@@ -162,0 +147,1 @@\n+            assertFalse(prPoller.getCurrentQueryResult().pullRequests().isEmpty());\n@@ -188,49 +174,1 @@\n-            \/\/ Add review while keeping updatedAt unchanged. This should not trigger an update.\n-            prevUpdatedAt = pr.updatedAt();\n-            pr.addReview(Review.Verdict.APPROVED, \"foo\");\n-            pr.store().setLastUpdate(prevUpdatedAt);\n-            prs = prPoller.updatedPullRequests();\n-            assertEquals(0, prs.size());\n-            prPoller.lastBatchHandled();\n-        }\n-    }\n-\n-    \/**\n-     * Tests polling with padding needed and creating\/modifying reviews\n-     *\/\n-    @Test\n-    void queryPaddingReview(TestInfo testInfo) throws IOException {\n-        try (var credentials = new HostCredentials(testInfo)) {\n-            var repo = credentials.getHostedRepository();\n-            var forge = repo.forge();\n-            ((TestHost) forge).setMinTimeStampUpdateInterval(Duration.ofDays(1));\n-            var prPoller = new PullRequestPoller(repo, true, false, true);\n-\n-            \/\/ Create a PR and poll for it\n-            var pr = credentials.createPullRequest(repo, \"master\", \"master\", \"Foo\");\n-            var prs = prPoller.updatedPullRequests();\n-            assertEquals(1, prs.size());\n-            prPoller.lastBatchHandled();\n-\n-            \/\/ Poll for it again\n-            prs = prPoller.updatedPullRequests();\n-            assertEquals(0, prs.size());\n-            prPoller.lastBatchHandled();\n-\n-            \/\/ Add a label but make sure the updatedAt time was not updated. This should trigger an update.\n-            var prevUpdatedAt = pr.updatedAt();\n-            pr.addLabel(\"foo\");\n-            pr.store().setLastUpdate(prevUpdatedAt);\n-            prs = prPoller.updatedPullRequests();\n-            assertEquals(1, prs.size());\n-            prPoller.lastBatchHandled();\n-\n-            \/\/ Add comment while keeping updatedAt unchanged. This should not trigger an update\n-            prevUpdatedAt = pr.updatedAt();\n-            pr.addComment(\"foo\");\n-            pr.store().setLastUpdate(prevUpdatedAt);\n-            prs = prPoller.updatedPullRequests();\n-            assertEquals(0, prs.size());\n-            prPoller.lastBatchHandled();\n-\n-            \/\/ Add review while keeping updatedAt unchanged. This should trigger an update\n+            \/\/ Add review while keeping updatedAt unchanged. This should trigger an update.\n@@ -250,1 +188,1 @@\n-            var prPoller = new PullRequestPoller(repo, false, true, true);\n+            var prPoller = new PullRequestPoller(repo, false);\n@@ -299,1 +237,1 @@\n-            var prPoller = new PullRequestPoller(repo, false, false, false);\n+            var prPoller = new PullRequestPoller(repo, false);\n@@ -347,0 +285,48 @@\n+\n+    @Test\n+    void positivePadding(TestInfo testInfo) throws IOException, InterruptedException {\n+        try (var credentials = new HostCredentials(testInfo)) {\n+            var repo = credentials.getHostedRepository();\n+            var forge = repo.forge();\n+            ((TestHost) forge).setMinTimeStampUpdateInterval(Duration.ofNanos(1));\n+            ((TestHost) forge).setTimeStampQueryPrecision(Duration.ofNanos(1));\n+            ZonedDateTime base = ZonedDateTime.now();\n+            var prPoller = new PullRequestPoller(repo, false);\n+\n+            \/\/ Create a PR with updatedAt set to 'base', and poll it so lastUpdatedAt is now 'base'\n+            var pr1 = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            pr1.store().setLastUpdate(base);\n+            var prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Create two more PRs, with updatedAt just before and just after 'base'\n+            var pr2 = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            pr2.store().setLastUpdate(base.minus(Duration.ofNanos(2)));\n+            var pr3 = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            pr3.store().setLastUpdate(base.plus(Duration.ofNanos(2)));\n+            \/\/ The negative padding is not big enough to include pr2 and pr1 has already been returned\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            assertEquals(pr3.id(), prs.get(0).id());\n+            assertTrue(prPoller.getCurrentQueryResult().pullRequests().containsKey(pr1.id()));\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Sleep a minimal amount and query again to trigger positive padding\n+            Thread.sleep(1);\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(0, prs.size());\n+            \/\/ The query should still return pr3\n+            assertTrue(prPoller.getCurrentQueryResult().pullRequests().containsKey(pr3.id()));\n+            prPoller.lastBatchHandled();\n+\n+            \/\/ Now even the query should not include p3, but we should get the new pr4\n+            var pr4 = credentials.createPullRequest(repo, null, null, \"Foo\");\n+            pr4.store().setLastUpdate(base.plus(Duration.ofNanos(4)));\n+            prs = prPoller.updatedPullRequests();\n+            assertEquals(1, prs.size());\n+            assertEquals(pr4.id(), prs.get(0).id());\n+            assertFalse(prPoller.getCurrentQueryResult().pullRequests().containsKey(pr3.id()));\n+            prPoller.lastBatchHandled();\n+        }\n+    }\n","filename":"forge\/src\/test\/java\/org\/openjdk\/skara\/forge\/PullRequestPollerTests.java","additions":59,"deletions":73,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.time.Duration;\n@@ -33,0 +34,9 @@\n+    \/**\n+     * The precision at which timeStamp based queries are supported for this\n+     * Host. The default is 1 nanosecond, knowing this can be used to avoid\n+     * re-querying for the same Issues over and over (as timestamp based\n+     * queries are often inclusive).\n+     *\/\n+    default Duration timeStampQueryPrecision() {\n+        return Duration.ofNanos(1);\n+    }\n","filename":"host\/src\/main\/java\/org\/openjdk\/skara\/host\/Host.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -23,2 +23,2 @@\n-    private record QueryResult(Map<String, Issue> issues, ZonedDateTime maxUpdatedAt,\n-                               Instant afterQuery, List<Issue> result) {}\n+    record QueryResult(Map<String, Issue> issues, ZonedDateTime maxUpdatedAt,\n+                       Instant afterQuery, List<Issue> result) {}\n@@ -164,0 +164,5 @@\n+\n+    \/\/ Expose the query results to tests\n+    QueryResult getCurrentQueryResult() {\n+        return current;\n+    }\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/IssuePoller.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+\n+    \/**\n+     * Find all issues that have been updated after or on the given time, with\n+     * a resolution given by Host::timeStampQueryPrecision.\n+     *\/\n@@ -48,2 +53,2 @@\n-     * Find all issues of CSR type updated after the given timestamp.\n-     * Note that time queries in Jira are only on minute resolution.\n+     * Find all issues of CSR type updated after or on the given time, with\n+     * a resolution given by Host::timeStampQueryPrecision.\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/IssueProject.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,9 +36,0 @@\n-    \/**\n-     * The precision at which timeStamp based queries are supported for this\n-     * IssueTracker. If this is >0, knowing this can be used to avoid\n-     * re-querying for the same Issues over and over.\n-     *\/\n-    default Duration timeStampQueryPrecision() {\n-        return Duration.ZERO;\n-    }\n-\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/IssueTracker.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import org.junit.jupiter.api.Assertions;\n@@ -12,0 +13,1 @@\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -87,1 +89,0 @@\n-            testHost.setTimeStampQueryPrecision(Duration.ofNanos(2));\n@@ -115,7 +116,2 @@\n-            \/\/ With the extremely short precision of 2 nanos, enough time should now\n-            \/\/ have passed between the two previous polls so that the poller is now\n-            \/\/ padding the fetch query with the precision duration.\n-            \/\/ We can prove that by updating the updatedAt of issue1 to something after\n-            \/\/ the last updatedAt but before last updatedAt + precision. If the fetch\n-            \/\/ call would return it, then isUpdated should also return true, and\n-            \/\/ updatedIssues() would then return issue1.\n+            \/\/ With padding triggered, no issues should be returned even at the query\n+            \/\/ level.\n@@ -123,1 +119,0 @@\n-            issue1.store().setLastUpdate(lastFoundUpdatedAt.plus(Duration.ofNanos(1)));\n@@ -126,0 +121,3 @@\n+            assertTrue(issuePoller.getCurrentQueryResult().issues().isEmpty(),\n+                    \"Nothing should have been returned by the query but contained: \"\n+                            + issuePoller.getCurrentQueryResult().issues());\n","filename":"issuetracker\/src\/test\/java\/org\/openjdk\/skara\/issuetracker\/IssuePollerTests.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    private Duration timeStampQueryPrecision = Duration.ZERO;\n+    private Duration timeStampQueryPrecision = Duration.ofNanos(1);\n@@ -257,2 +257,0 @@\n-                          \/\/ Accept updatedAfter == updatedAt to make tests more\n-                          \/\/ resilient on hardware with lower resolution system clocks.\n@@ -271,1 +269,1 @@\n-                .filter(i -> i.updatedAt().isAfter(updatedAfter))\n+                .filter(i -> !i.updatedAt().isBefore(updatedAfter))\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestHost.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-                   .filter(pr -> pr.updatedAt().isAfter(updatedAfter))\n+                   .filter(pr -> !pr.updatedAt().isBefore(updatedAfter))\n@@ -102,1 +102,1 @@\n-                .filter(pr -> pr.updatedAt().isAfter(updatedAfter))\n+                .filter(pr -> !pr.updatedAt().isBefore(updatedAfter))\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestHostedRepository.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -282,0 +282,5 @@\n+    @Override\n+    public Object comparisonSnapshot() {\n+        return List.of(this, comments(), reviews());\n+    }\n+\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestPullRequest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}