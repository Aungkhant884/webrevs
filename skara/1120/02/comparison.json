{"files":[{"patch":"@@ -25,0 +25,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -52,0 +53,2 @@\n+    private AtomicInteger workIdCounter = new AtomicInteger();\n+\n@@ -76,1 +79,0 @@\n-            log.log(Level.FINE, \"Executing item \" + item + \" on repository \" + scratchPath, TaskPhases.BEGIN);\n@@ -78,8 +80,12 @@\n-            try {\n-                followUpItems = item.run(scratchPath);\n-            } catch (RuntimeException e) {\n-                log.severe(\"Exception during item execution (\" + item + \"): \" + e.getMessage());\n-                item.handleRuntimeException(e);\n-                log.throwing(item.toString(), \"run\", e);\n-            } finally {\n-                log.log(Level.FINE, \"Item \" + item + \" is now done\", TaskPhases.END);\n+            try (var __ = new LogContext(Map.of(\"work_item\", item.toString(),\n+                    \"work_id\", String.valueOf(workIdCounter.incrementAndGet())))) {\n+                log.log(Level.FINE, \"Executing item \" + item + \" on repository \" + scratchPath, TaskPhases.BEGIN);\n+                try {\n+                    followUpItems = item.run(scratchPath);\n+                } catch (RuntimeException e) {\n+                    log.severe(\"Exception during item execution (\" + item + \"): \" + e.getMessage());\n+                    item.handleRuntimeException(e);\n+                    log.throwing(item.toString(), \"run\", e);\n+                } finally {\n+                    log.log(Level.FINE, \"Item \" + item + \" is now done\", TaskPhases.END);\n+                }\n@@ -218,6 +224,8 @@\n-        log.log(Level.FINE, \"Starting of checking for periodic items\", TaskPhases.BEGIN);\n-        try {\n-            for (var bot : bots) {\n-                var items = bot.getPeriodicItems();\n-                for (var item : items) {\n-                    submitOrSchedule(item);\n+        try (var __ = new LogContext(\"work_id\", String.valueOf(workIdCounter.incrementAndGet()))) {\n+            log.log(Level.FINE, \"Starting of checking for periodic items\", TaskPhases.BEGIN);\n+            try {\n+                for (var bot : bots) {\n+                    var items = bot.getPeriodicItems();\n+                    for (var item : items) {\n+                        submitOrSchedule(item);\n+                    }\n@@ -225,0 +233,5 @@\n+            } catch (RuntimeException e) {\n+                log.severe(\"Exception during periodic item checking: \" + e.getMessage());\n+                log.throwing(\"BotRunner\", \"checkPeriodicItems\", e);\n+            } finally {\n+                log.log(Level.FINE, \"Done checking periodic items\", TaskPhases.END);\n@@ -226,5 +239,0 @@\n-        } catch (RuntimeException e) {\n-            log.severe(\"Exception during periodic item checking: \" + e.getMessage());\n-            log.throwing(\"BotRunner\", \"checkPeriodicItems\", e);\n-        } finally {\n-            log.log(Level.FINE, \"Done checking periodic items\", TaskPhases.END);\n@@ -251,7 +259,9 @@\n-        log.log(Level.FINE, \"Starting processing of incoming rest request\", TaskPhases.BEGIN);\n-        log.fine(\"Request: \" + request);\n-        try {\n-            for (var bot : bots) {\n-                var items = bot.processWebHook(request);\n-                for (var item : items) {\n-                    submitOrSchedule(item);\n+        try (var __ = new LogContext(\"work_id\", String.valueOf(workIdCounter.incrementAndGet()))) {\n+            log.log(Level.FINE, \"Starting processing of incoming rest request\", TaskPhases.BEGIN);\n+            log.fine(\"Request: \" + request);\n+            try {\n+                for (var bot : bots) {\n+                    var items = bot.processWebHook(request);\n+                    for (var item : items) {\n+                        submitOrSchedule(item);\n+                    }\n@@ -259,0 +269,5 @@\n+            } catch (RuntimeException e) {\n+                log.severe(\"Exception during rest request processing: \" + e.getMessage());\n+                log.throwing(\"BotRunner\", \"processRestRequest\", e);\n+            } finally {\n+                log.log(Level.FINE, \"Done processing incoming rest request\", TaskPhases.END);\n@@ -260,5 +275,0 @@\n-        } catch (RuntimeException e) {\n-            log.severe(\"Exception during rest request processing: \" + e.getMessage());\n-            log.throwing(\"BotRunner\", \"processRestRequest\", e);\n-        } finally {\n-            log.log(Level.FINE, \"Done processing incoming rest request\", TaskPhases.END);\n","filename":"bot\/src\/main\/java\/org\/openjdk\/skara\/bot\/BotRunner.java","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+package org.openjdk.skara.bot;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+\n+\/**\n+ * A LogContext is used to temporarily add extra log metadata in the current thread.\n+ * It should be initiated with a try-with-resources construct. The variable itself\n+ * is never used, we only want the controlled automatic close at the end of the try\n+ * block. Typically name the variable __. Example:\n+ *\n+ * try (var __ = new LogContext(\"foo\", \"bar\")) {\n+ *     \/\/ some code that logs stuff\n+ * }\n+ *\/\n+public class LogContext implements AutoCloseable {\n+    private static final Logger log = Logger.getLogger(\"org.openjdk.skara.bot\");\n+    private final Map<String, String> context = new HashMap<>();\n+\n+    public LogContext(String key, String value) {\n+        this.init(Map.of(key, value));\n+    }\n+\n+    public LogContext(Map<String, String> ctx) {\n+        this.init(ctx);\n+    }\n+\n+    private void init(Map<String, String> newContext) {\n+        for (var entry : newContext.entrySet()) {\n+            String currentValue = LogContextMap.get(entry.getKey());\n+            if (currentValue != null) {\n+                if (!currentValue.equals(entry.getValue())) {\n+                    log.severe(\"Tried to override the current LogContext value: \" + currentValue\n+                            + \" for \" + entry.getKey() + \" with a different value: \" + entry.getValue());\n+                }\n+            } else {\n+                this.context.put(entry.getKey(), entry.getValue());\n+                LogContextMap.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+\n+    }\n+\n+    public void close() {\n+        this.context.forEach((key, value) -> {\n+            LogContextMap.remove(key);\n+        });\n+    }\n+}\n","filename":"bot\/src\/main\/java\/org\/openjdk\/skara\/bot\/LogContext.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+package org.openjdk.skara.bot;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\/**\n+ * This class holds a static thread local hashmap to store temporary log\n+ * metadata which our custom StreamHandlers can pick up and include in log\n+ * messages.\n+ *\/\n+public class LogContextMap {\n+\n+    private static final ThreadLocal<HashMap<String, String>> threadContextMap = new ThreadLocal<>();\n+\n+    public static void put(String key, String value) {\n+        if (threadContextMap.get() == null) {\n+            threadContextMap.set(new HashMap<>());\n+        }\n+        var map = threadContextMap.get();\n+        map.put(key, value);\n+    }\n+\n+    public static String get(String key) {\n+        if (threadContextMap.get() != null) {\n+            return threadContextMap.get().get(key);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public static String remove(String key) {\n+        if (threadContextMap.get() != null) {\n+            return threadContextMap.get().remove(key);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public static Set<Map.Entry<String, String>> entrySet() {\n+        if (threadContextMap.get() != null) {\n+            return threadContextMap.get().entrySet();\n+        } else {\n+            return Collections.emptySet();\n+        }\n+    }\n+}\n","filename":"bot\/src\/main\/java\/org\/openjdk\/skara\/bot\/LogContextMap.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+package org.openjdk.skara.bot;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+public class LogContextTests {\n+\n+    @Test\n+    public void simple() {\n+        String key = \"keyname\";\n+        assertNull(LogContextMap.get(key), \"Key \" + key + \" already present in context\");\n+        try (var __ = new LogContext(key, \"value\")) {\n+            assertEquals(\"value\", LogContextMap.get(key), \"Context property not set\");\n+        }\n+        assertNull(LogContextMap.get(key), \"Context property not removed\");\n+    }\n+}\n","filename":"bot\/src\/test\/java\/org\/openjdk\/skara\/bot\/LogContextTests.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -25,0 +25,3 @@\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n@@ -44,0 +47,1 @@\n+    private static final LocalDate START_TIME = LocalDate.now();\n@@ -84,5 +88,1 @@\n-            var maxRecords = 100;\n-            if (logstashConf.contains(\"maxrecords\")) {\n-                maxRecords = logstashConf.get(\"maxrecords\").asInt();\n-            }\n-            var handler = new BotLogstashHandler(URIBuilder.base(logstashConf.get(\"endpoint\").asString()).build(), maxRecords);\n+            var handler = new BotLogstashHandler(URIBuilder.base(logstashConf.get(\"endpoint\").asString()).build());\n@@ -102,0 +102,4 @@\n+            var dateTimeFormatter = DateTimeFormatter.ISO_INSTANT\n+                    .withLocale(Locale.getDefault())\n+                    .withZone(ZoneId.systemDefault());\n+            handler.addExtraField(\"instance_start_time\", START_TIME.format(dateTimeFormatter));\n","filename":"bots\/cli\/src\/main\/java\/org\/openjdk\/skara\/bots\/cli\/BotLauncher.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import org.openjdk.skara.bot.BotTaskAggregationHandler;\n+import org.openjdk.skara.bot.LogContextMap;\n@@ -36,1 +36,0 @@\n-import java.util.stream.Collectors;\n@@ -38,1 +37,1 @@\n-public class BotLogstashHandler extends BotTaskAggregationHandler {\n+public class BotLogstashHandler extends StreamHandler {\n@@ -41,1 +40,0 @@\n-    private final int maxRecords;\n@@ -53,1 +51,1 @@\n-    BotLogstashHandler(URI endpoint, int maxRecords) {\n+    BotLogstashHandler(URI endpoint) {\n@@ -55,1 +53,0 @@\n-        this.maxRecords = maxRecords;\n@@ -84,0 +81,4 @@\n+            for (var entry : LogContextMap.entrySet()) {\n+                query.put(entry.getKey(), entry.getValue());\n+            }\n+\n@@ -97,22 +98,0 @@\n-    private String formatDuration(Duration duration) {\n-        return String.format(\"[%02d:%02d]\", duration.toMinutes(), duration.toSeconds() % 60);\n-    }\n-\n-    private String formatRecord(Instant base, LogRecord record) {\n-        var writer = new StringWriter();\n-        var printer = new PrintWriter(writer);\n-\n-        printer.print(formatDuration(Duration.between(base, record.getInstant())));\n-        printer.print(\"[\");\n-        printer.print(record.getLevel().getName());\n-        printer.print(\"] \");\n-        printer.print(record.getMessage());\n-\n-        var exception = record.getThrown();\n-        if (exception != null) {\n-            exception.printStackTrace(printer);\n-        }\n-\n-        return writer.toString().stripTrailing();\n-    }\n-\n@@ -135,49 +114,0 @@\n-    \/\/ Remove every entry below minLevel\n-    private List<LogRecord> filterRecords(List<LogRecord> records, Level minLevel) {\n-        return records.stream()\n-                .filter(entry -> entry.getLevel().intValue() >= minLevel.intValue())\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public void publishAggregated(List<LogRecord> task) {\n-        var maxLevel = task.stream()\n-                           .max(Comparator.comparingInt(r -> r.getLevel().intValue()))\n-                           .map(LogRecord::getLevel)\n-                           .orElseThrow();\n-        if (maxLevel.intValue() < getLevel().intValue()) {\n-            return;\n-        }\n-\n-        var start = task.get(0).getInstant();\n-\n-        \/\/ For duplicate keys, the first value seen is retained\n-        var concatenatedFields = task.stream()\n-                .map(this::getExtraFields)\n-                .flatMap(extra -> extra.entrySet().stream())\n-                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,\n-                                          (value1, value2) -> value1));\n-\n-        \/\/ First try to accommodate size limit by filtering out low level logging\n-        if (task.size() > maxRecords) {\n-            task = filterRecords(task, Level.FINER);\n-        }\n-        if (task.size() > maxRecords) {\n-            task = filterRecords(task, Level.FINE);\n-        }\n-\n-        \/\/ If there's still too many lines, strip out the middle\n-        if (task.size() > maxRecords) {\n-            var beginning = task.subList(0, maxRecords \/ 2);\n-            var end = task.subList(task.size() - maxRecords \/ 2, task.size());\n-            task = beginning;\n-            task.addAll(end);\n-        }\n-\n-        var concatenatedMessage = task.stream()\n-                                      .map(record -> formatRecord(start, record))\n-                                      .collect(Collectors.joining(\"\\n\"));\n-\n-        publishToLogstash(start, maxLevel, concatenatedMessage, concatenatedFields);\n-    }\n-\n@@ -185,1 +115,1 @@\n-    public void publishSingle(LogRecord record) {\n+    public void publish(LogRecord record) {\n","filename":"bots\/cli\/src\/main\/java\/org\/openjdk\/skara\/bots\/cli\/BotLogstashHandler.java","additions":8,"deletions":78,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n+            var handler = new BotLogstashHandler(receiver.getEndpoint());\n@@ -51,1 +51,1 @@\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n+            var handler = new BotLogstashHandler(receiver.getEndpoint());\n@@ -60,1 +60,1 @@\n-            assertEquals(1, requests.size(), requests.toString());\n+            assertEquals(3, requests.size(), requests.toString());\n@@ -63,4 +63,7 @@\n-            assertTrue(requests.get(0).get(\"message\").asString().contains(\"Hello\"));\n-            assertTrue(requests.get(0).get(\"message\").asString().contains(\"Warning\"));\n-            assertTrue(requests.get(0).get(\"message\").asString().contains(\"Bye\"));\n-            assertTrue(requests.get(0).get(\"message\").asString().contains(Level.WARNING.toString()));\n+            assertEquals(\"Hello\", requests.get(0).get(\"message\").asString());\n+            assertEquals(\"Warning!\", requests.get(1).get(\"message\").asString());\n+            assertEquals(\"Bye\", requests.get(2).get(\"message\").asString());\n+            assertEquals(Level.WARNING.toString(), requests.get(0).get(\"level\").asString());\n+            assertNotNull(requests.get(0).get(\"work_id\"), \"work_id not set\");\n+            assertTrue(requests.get(0).get(\"work_item\").asString().contains(\"LoggingBot@\"),\n+                    \"work_item has bad value \" + requests.get(0).get(\"work_item\").asString());\n@@ -73,1 +76,1 @@\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n+            var handler = new BotLogstashHandler(receiver.getEndpoint());\n@@ -91,1 +94,1 @@\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n+            var handler = new BotLogstashHandler(receiver.getEndpoint());\n@@ -105,1 +108,1 @@\n-            assertEquals(1, requests.size(), requests.toString());\n+            assertEquals(3, requests.size(), requests.toString());\n@@ -109,109 +112,1 @@\n-            assertEquals(\"ye\", requests.get(0).get(\"optional3\").asString());\n-            assertTrue(requests.get(0).get(\"greedy\").asString().contains(\"Executing item\"));\n-        }\n-    }\n-\n-    @Test\n-    void filterLowLevels() throws IOException {\n-        try (var receiver = new RestReceiver()) {\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 10);\n-\n-            LoggingBot.runOnce(handler, Level.FINER, log -> {\n-                for (int i = 0; i < 5; ++i) {\n-                    log.fine(\"Fine nr \" + i);\n-                }\n-                for (int i = 0; i < 5; ++i) {\n-                    log.finer(\"Finer nr \" + i);\n-                }\n-            });\n-\n-            var requests = receiver.getRequests();\n-            var aggregatedLines = requests.stream()\n-                                          .filter(request -> request.get(\"message\").asString().contains(\"Executing item\"))\n-                                          .findAny()\n-                                          .orElseThrow()\n-                                          .get(\"message\")\n-                                          .asString()\n-                                          .lines()\n-                                          .collect(Collectors.toList());\n-\n-            var fineLines = aggregatedLines.stream()\n-                                           .filter(line -> line.contains(\"Fine nr\"))\n-                                           .collect(Collectors.toList());\n-            var finerLines = aggregatedLines.stream()\n-                                            .filter(line -> line.contains(\"Finer nr\"))\n-                                            .collect(Collectors.toList());\n-            assertEquals(5, fineLines.size(), aggregatedLines.toString());\n-            assertEquals(0, finerLines.size(), aggregatedLines.toString());\n-        }\n-    }\n-\n-    @Test\n-    void filterLowestLevels() throws IOException {\n-        try (var receiver = new RestReceiver()) {\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 15);\n-\n-            LoggingBot.runOnce(handler, Level.FINER, log -> {\n-                for (int i = 0; i < 5; ++i) {\n-                    log.fine(\"Fine nr \" + i);\n-                }\n-                for (int i = 0; i < 5; ++i) {\n-                    log.finer(\"Finer nr \" + i);\n-                }\n-                for (int i = 0; i < 5; ++i) {\n-                    log.finest(\"Finest nr \" + i);\n-                }\n-            });\n-\n-            var requests = receiver.getRequests();\n-            var aggregatedLines = requests.stream()\n-                                          .filter(request -> request.get(\"message\").asString().contains(\"Executing item\"))\n-                                          .findAny()\n-                                          .orElseThrow()\n-                                          .get(\"message\")\n-                                          .asString()\n-                                          .lines()\n-                                          .collect(Collectors.toList());\n-\n-            var fineLines = aggregatedLines.stream()\n-                                           .filter(line -> line.contains(\"Fine nr\"))\n-                                           .collect(Collectors.toList());\n-            var finerLines = aggregatedLines.stream()\n-                                            .filter(line -> line.contains(\"Finer nr\"))\n-                                            .collect(Collectors.toList());\n-            var finestLines = aggregatedLines.stream()\n-                                             .filter(line -> line.contains(\"Finest nr\"))\n-                                             .collect(Collectors.toList());\n-            assertEquals(5, fineLines.size(), aggregatedLines.toString());\n-            assertEquals(5, finerLines.size(), aggregatedLines.toString());\n-            assertEquals(0, finestLines.size(), aggregatedLines.toString());\n-        }\n-    }\n-\n-    @Test\n-    void filterMiddle() throws IOException {\n-        try (var receiver = new RestReceiver()) {\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n-\n-            LoggingBot.runOnce(handler, Level.FINER, log -> {\n-                for (int i = 0; i < 100; ++i) {\n-                    log.fine(\"Start nr \" + i);\n-                }\n-                for (int i = 0; i < 100; ++i) {\n-                    log.fine(\"Middle nr \" + i);\n-                }\n-                for (int i = 0; i < 100; ++i) {\n-                    log.fine(\"End nr \" + i);\n-                }\n-            });\n-\n-            var requests = receiver.getRequests();\n-            var aggregatedLines = requests.stream()\n-                                          .filter(request -> request.get(\"message\").asString().contains(\"Executing item\"))\n-                                          .findAny()\n-                                          .orElseThrow()\n-                                          .get(\"message\")\n-                                          .asString();\n-            assertTrue(aggregatedLines.contains(\"Start nr\"));\n-            assertFalse(aggregatedLines.contains(\"Middle nr\"));\n-            assertTrue(aggregatedLines.contains(\"End nr\"));\n+            assertEquals(\"ye\", requests.get(2).get(\"optional3\").asString());\n","filename":"bots\/cli\/src\/test\/java\/org\/openjdk\/skara\/bots\/cli\/BotLogstashHandlerTests.java","additions":14,"deletions":119,"binary":false,"changes":133,"status":"modified"}]}