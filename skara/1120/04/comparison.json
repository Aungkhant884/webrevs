{"files":[{"patch":"@@ -25,0 +25,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -52,0 +53,2 @@\n+    private AtomicInteger workIdCounter = new AtomicInteger();\n+\n@@ -76,1 +79,0 @@\n-            log.log(Level.FINE, \"Executing item \" + item + \" on repository \" + scratchPath, TaskPhases.BEGIN);\n@@ -78,8 +80,12 @@\n-            try {\n-                followUpItems = item.run(scratchPath);\n-            } catch (RuntimeException e) {\n-                log.severe(\"Exception during item execution (\" + item + \"): \" + e.getMessage());\n-                item.handleRuntimeException(e);\n-                log.throwing(item.toString(), \"run\", e);\n-            } finally {\n-                log.log(Level.FINE, \"Item \" + item + \" is now done\", TaskPhases.END);\n+            try (var __ = new LogContext(Map.of(\"work_item\", item.toString(),\n+                    \"work_id\", String.valueOf(workIdCounter.incrementAndGet())))) {\n+                log.log(Level.FINE, \"Executing item \" + item + \" on repository \" + scratchPath, TaskPhases.BEGIN);\n+                try {\n+                    followUpItems = item.run(scratchPath);\n+                } catch (RuntimeException e) {\n+                    log.severe(\"Exception during item execution (\" + item + \"): \" + e.getMessage());\n+                    item.handleRuntimeException(e);\n+                    log.throwing(item.toString(), \"run\", e);\n+                } finally {\n+                    log.log(Level.FINE, \"Item \" + item + \" is now done\", TaskPhases.END);\n+                }\n@@ -218,6 +224,8 @@\n-        log.log(Level.FINE, \"Starting of checking for periodic items\", TaskPhases.BEGIN);\n-        try {\n-            for (var bot : bots) {\n-                var items = bot.getPeriodicItems();\n-                for (var item : items) {\n-                    submitOrSchedule(item);\n+        try (var __ = new LogContext(\"work_id\", String.valueOf(workIdCounter.incrementAndGet()))) {\n+            log.log(Level.FINE, \"Starting of checking for periodic items\", TaskPhases.BEGIN);\n+            try {\n+                for (var bot : bots) {\n+                    var items = bot.getPeriodicItems();\n+                    for (var item : items) {\n+                        submitOrSchedule(item);\n+                    }\n@@ -225,0 +233,5 @@\n+            } catch (RuntimeException e) {\n+                log.severe(\"Exception during periodic item checking: \" + e.getMessage());\n+                log.throwing(\"BotRunner\", \"checkPeriodicItems\", e);\n+            } finally {\n+                log.log(Level.FINE, \"Done checking periodic items\", TaskPhases.END);\n@@ -226,5 +239,0 @@\n-        } catch (RuntimeException e) {\n-            log.severe(\"Exception during periodic item checking: \" + e.getMessage());\n-            log.throwing(\"BotRunner\", \"checkPeriodicItems\", e);\n-        } finally {\n-            log.log(Level.FINE, \"Done checking periodic items\", TaskPhases.END);\n@@ -251,7 +259,9 @@\n-        log.log(Level.FINE, \"Starting processing of incoming rest request\", TaskPhases.BEGIN);\n-        log.fine(\"Request: \" + request);\n-        try {\n-            for (var bot : bots) {\n-                var items = bot.processWebHook(request);\n-                for (var item : items) {\n-                    submitOrSchedule(item);\n+        try (var __ = new LogContext(\"work_id\", String.valueOf(workIdCounter.incrementAndGet()))) {\n+            log.log(Level.FINE, \"Starting processing of incoming rest request\", TaskPhases.BEGIN);\n+            log.fine(\"Request: \" + request);\n+            try {\n+                for (var bot : bots) {\n+                    var items = bot.processWebHook(request);\n+                    for (var item : items) {\n+                        submitOrSchedule(item);\n+                    }\n@@ -259,0 +269,5 @@\n+            } catch (RuntimeException e) {\n+                log.severe(\"Exception during rest request processing: \" + e.getMessage());\n+                log.throwing(\"BotRunner\", \"processRestRequest\", e);\n+            } finally {\n+                log.log(Level.FINE, \"Done processing incoming rest request\", TaskPhases.END);\n@@ -260,5 +275,0 @@\n-        } catch (RuntimeException e) {\n-            log.severe(\"Exception during rest request processing: \" + e.getMessage());\n-            log.throwing(\"BotRunner\", \"processRestRequest\", e);\n-        } finally {\n-            log.log(Level.FINE, \"Done processing incoming rest request\", TaskPhases.END);\n","filename":"bot\/src\/main\/java\/org\/openjdk\/skara\/bot\/BotRunner.java","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+package org.openjdk.skara.bot;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+\n+\/**\n+ * A LogContext is used to temporarily add extra log metadata in the current thread.\n+ * It should be initiated with a try-with-resources construct. The variable itself\n+ * is never used, we only want the controlled automatic close at the end of the try\n+ * block. Typically name the variable __. Example:\n+ *\n+ * try (var __ = new LogContext(\"foo\", \"bar\")) {\n+ *     \/\/ some code that logs stuff\n+ * }\n+ *\/\n+public class LogContext implements AutoCloseable {\n+    private static final Logger log = Logger.getLogger(\"org.openjdk.skara.bot\");\n+    private final Map<String, String> context = new HashMap<>();\n+\n+    public LogContext(String key, String value) {\n+        this.init(Map.of(key, value));\n+    }\n+\n+    public LogContext(Map<String, String> ctx) {\n+        this.init(ctx);\n+    }\n+\n+    private void init(Map<String, String> newContext) {\n+        for (var entry : newContext.entrySet()) {\n+            String currentValue = LogContextMap.get(entry.getKey());\n+            if (currentValue != null) {\n+                if (!currentValue.equals(entry.getValue())) {\n+                    log.severe(\"Tried to override the current LogContext value: \" + currentValue\n+                            + \" for \" + entry.getKey() + \" with a different value: \" + entry.getValue());\n+                }\n+            } else {\n+                this.context.put(entry.getKey(), entry.getValue());\n+                LogContextMap.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+\n+    }\n+\n+    public void close() {\n+        this.context.forEach((key, value) -> {\n+            LogContextMap.remove(key);\n+        });\n+    }\n+}\n","filename":"bot\/src\/main\/java\/org\/openjdk\/skara\/bot\/LogContext.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+package org.openjdk.skara.bot;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\/**\n+ * This class holds a static thread local hashmap to store temporary log\n+ * metadata which our custom StreamHandlers can pick up and include in log\n+ * messages.\n+ *\/\n+public class LogContextMap {\n+\n+    private static final ThreadLocal<HashMap<String, String>> threadContextMap = new ThreadLocal<>();\n+\n+    public static void put(String key, String value) {\n+        if (threadContextMap.get() == null) {\n+            threadContextMap.set(new HashMap<>());\n+        }\n+        var map = threadContextMap.get();\n+        map.put(key, value);\n+    }\n+\n+    public static String get(String key) {\n+        if (threadContextMap.get() != null) {\n+            return threadContextMap.get().get(key);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public static String remove(String key) {\n+        if (threadContextMap.get() != null) {\n+            return threadContextMap.get().remove(key);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public static Set<Map.Entry<String, String>> entrySet() {\n+        if (threadContextMap.get() != null) {\n+            return threadContextMap.get().entrySet();\n+        } else {\n+            return Collections.emptySet();\n+        }\n+    }\n+}\n","filename":"bot\/src\/main\/java\/org\/openjdk\/skara\/bot\/LogContextMap.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+package org.openjdk.skara.bot;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+public class LogContextTests {\n+\n+    @Test\n+    public void simple() {\n+        String key = \"keyname\";\n+        assertNull(LogContextMap.get(key), \"Key \" + key + \" already present in context\");\n+        try (var __ = new LogContext(key, \"value\")) {\n+            assertEquals(\"value\", LogContextMap.get(key), \"Context property not set\");\n+        }\n+        assertNull(LogContextMap.get(key), \"Context property not removed\");\n+    }\n+}\n","filename":"bot\/src\/test\/java\/org\/openjdk\/skara\/bot\/LogContextTests.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+    requires java.net.http;\n","filename":"bots\/cli\/src\/main\/java\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n@@ -44,0 +47,1 @@\n+    private static final Instant START_TIME = Instant.now();\n@@ -84,5 +88,1 @@\n-            var maxRecords = 100;\n-            if (logstashConf.contains(\"maxrecords\")) {\n-                maxRecords = logstashConf.get(\"maxrecords\").asInt();\n-            }\n-            var handler = new BotLogstashHandler(URIBuilder.base(logstashConf.get(\"endpoint\").asString()).build(), maxRecords);\n+            var handler = new BotLogstashHandler(URIBuilder.base(logstashConf.get(\"endpoint\").asString()).build());\n@@ -102,0 +102,4 @@\n+            var dateTimeFormatter = DateTimeFormatter.ISO_INSTANT\n+                    .withLocale(Locale.getDefault())\n+                    .withZone(ZoneId.systemDefault());\n+            handler.addExtraField(\"instance_start_time\", dateTimeFormatter.format(START_TIME));\n","filename":"bots\/cli\/src\/main\/java\/org\/openjdk\/skara\/bots\/cli\/BotLauncher.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n-import org.openjdk.skara.bot.BotTaskAggregationHandler;\n-import org.openjdk.skara.network.RestRequest;\n+import org.openjdk.skara.bot.LogContextMap;\n@@ -29,1 +28,0 @@\n-import java.io.*;\n@@ -31,0 +29,1 @@\n+import java.net.http.*;\n@@ -34,0 +33,1 @@\n+import java.util.concurrent.Future;\n@@ -36,1 +36,0 @@\n-import java.util.stream.Collectors;\n@@ -38,2 +37,7 @@\n-public class BotLogstashHandler extends BotTaskAggregationHandler {\n-    private final RestRequest endpoint;\n+\/**\n+ * Handles logging to logstash. Be careful not to call anything that creates new\n+ * log records from this class as that can cause infinite recursion.\n+ *\/\n+public class BotLogstashHandler extends StreamHandler {\n+    private final URI endpoint;\n+    private final HttpClient httpClient;\n@@ -41,3 +45,2 @@\n-    private final int maxRecords;\n-    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.cli\");\n-\n+    \/\/ Optionally store all futures for testing purposes\n+    private Collection<Future<HttpResponse<Void>>> futures;\n@@ -53,3 +56,6 @@\n-    BotLogstashHandler(URI endpoint, int maxRecords) {\n-        this.endpoint = new RestRequest(endpoint);\n-        this.maxRecords = maxRecords;\n+    BotLogstashHandler(URI endpoint) {\n+        this.endpoint = endpoint;\n+        this.httpClient = HttpClient.newBuilder()\n+                .followRedirects(HttpClient.Redirect.NORMAL)\n+                .connectTimeout(Duration.ofSeconds(30))\n+                .build();\n@@ -77,17 +83,8 @@\n-        try {\n-            var query = JSON.object();\n-            query.put(\"@timestamp\", dateTimeFormatter.format(time));\n-            query.put(\"level\", level.getName());\n-            query.put(\"level_value\", level.intValue());\n-            query.put(\"message\", message);\n-\n-            for (var extraField : extraFields.entrySet()) {\n-                query.put(extraField.getKey(), extraField.getValue());\n-            }\n-\n-            endpoint.post(\"\/\")\n-                    .body(query)\n-                    .executeUnparsed();\n-        } catch (RuntimeException | IOException e) {\n-            log.warning(\"Exception during logstash publishing: \" + e.getMessage());\n-            log.throwing(\"BotSlackHandler\", \"publish\", e);\n+        var query = JSON.object();\n+        query.put(\"@timestamp\", dateTimeFormatter.format(time));\n+        query.put(\"level\", level.getName());\n+        query.put(\"level_value\", level.intValue());\n+        query.put(\"message\", message);\n+\n+        for (var entry : LogContextMap.entrySet()) {\n+            query.put(entry.getKey(), entry.getValue());\n@@ -95,5 +92,0 @@\n-    }\n-\n-    private String formatDuration(Duration duration) {\n-        return String.format(\"[%02d:%02d]\", duration.toMinutes(), duration.toSeconds() % 60);\n-    }\n@@ -101,13 +93,2 @@\n-    private String formatRecord(Instant base, LogRecord record) {\n-        var writer = new StringWriter();\n-        var printer = new PrintWriter(writer);\n-\n-        printer.print(formatDuration(Duration.between(base, record.getInstant())));\n-        printer.print(\"[\");\n-        printer.print(record.getLevel().getName());\n-        printer.print(\"] \");\n-        printer.print(record.getMessage());\n-\n-        var exception = record.getThrown();\n-        if (exception != null) {\n-            exception.printStackTrace(printer);\n+        for (var extraField : extraFields.entrySet()) {\n+            query.put(extraField.getKey(), extraField.getValue());\n@@ -116,1 +97,9 @@\n-        return writer.toString().stripTrailing();\n+        var httpRequest = HttpRequest.newBuilder()\n+                .uri(endpoint)\n+                .header(\"Content-Type\", \"application\/json\")\n+                .POST(HttpRequest.BodyPublishers.ofString(query.toString()))\n+                .build();\n+        var future = httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.discarding());\n+        if (futures != null) {\n+            futures.add(future);\n+        }\n@@ -135,7 +124,0 @@\n-    \/\/ Remove every entry below minLevel\n-    private List<LogRecord> filterRecords(List<LogRecord> records, Level minLevel) {\n-        return records.stream()\n-                .filter(entry -> entry.getLevel().intValue() >= minLevel.intValue())\n-                .collect(Collectors.toList());\n-    }\n-\n@@ -143,43 +125,1 @@\n-    public void publishAggregated(List<LogRecord> task) {\n-        var maxLevel = task.stream()\n-                           .max(Comparator.comparingInt(r -> r.getLevel().intValue()))\n-                           .map(LogRecord::getLevel)\n-                           .orElseThrow();\n-        if (maxLevel.intValue() < getLevel().intValue()) {\n-            return;\n-        }\n-\n-        var start = task.get(0).getInstant();\n-\n-        \/\/ For duplicate keys, the first value seen is retained\n-        var concatenatedFields = task.stream()\n-                .map(this::getExtraFields)\n-                .flatMap(extra -> extra.entrySet().stream())\n-                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,\n-                                          (value1, value2) -> value1));\n-\n-        \/\/ First try to accommodate size limit by filtering out low level logging\n-        if (task.size() > maxRecords) {\n-            task = filterRecords(task, Level.FINER);\n-        }\n-        if (task.size() > maxRecords) {\n-            task = filterRecords(task, Level.FINE);\n-        }\n-\n-        \/\/ If there's still too many lines, strip out the middle\n-        if (task.size() > maxRecords) {\n-            var beginning = task.subList(0, maxRecords \/ 2);\n-            var end = task.subList(task.size() - maxRecords \/ 2, task.size());\n-            task = beginning;\n-            task.addAll(end);\n-        }\n-\n-        var concatenatedMessage = task.stream()\n-                                      .map(record -> formatRecord(start, record))\n-                                      .collect(Collectors.joining(\"\\n\"));\n-\n-        publishToLogstash(start, maxLevel, concatenatedMessage, concatenatedFields);\n-    }\n-\n-    @Override\n-    public void publishSingle(LogRecord record) {\n+    public void publish(LogRecord record) {\n@@ -191,0 +131,4 @@\n+\n+    void setFuturesCollection(Collection<Future<HttpResponse<Void>>> futures) {\n+        this.futures = futures;\n+    }\n","filename":"bots\/cli\/src\/main\/java\/org\/openjdk\/skara\/bots\/cli\/BotLogstashHandler.java","additions":42,"deletions":98,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import org.junit.jupiter.api.*;\n+import org.junit.jupiter.api.Test;\n@@ -28,2 +28,7 @@\n-import java.util.logging.*;\n-import java.util.stream.Collectors;\n+import java.net.http.HttpResponse;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n@@ -34,0 +39,1 @@\n+\n@@ -35,1 +41,1 @@\n-    void simple() throws IOException {\n+    void simple() throws IOException, ExecutionException, InterruptedException {\n@@ -37,1 +43,4 @@\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n+            var handler = new BotLogstashHandler(receiver.getEndpoint());\n+            var futures = new ArrayList<Future<HttpResponse<Void>>>();\n+            handler.setFuturesCollection(futures);\n+\n@@ -41,0 +50,4 @@\n+            for (Future<HttpResponse<Void>> future : futures) {\n+                future.get();\n+            }\n+\n@@ -49,1 +62,1 @@\n-    void simpleTask() throws IOException {\n+    void simpleTask() throws IOException, ExecutionException, InterruptedException {\n@@ -51,1 +64,3 @@\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n+            var handler = new BotLogstashHandler(receiver.getEndpoint());\n+            var futures = new ArrayList<Future<HttpResponse<Void>>>();\n+            handler.setFuturesCollection(futures);\n@@ -59,0 +74,4 @@\n+            for (Future<HttpResponse<Void>> future : futures) {\n+                future.get();\n+            }\n+\n@@ -60,1 +79,5 @@\n-            assertEquals(1, requests.size(), requests.toString());\n+            \/\/ The async message sending means we may get results in any order. Sort on the\n+            \/\/ timestamp to get the actual order.\n+            requests.sort(Comparator.comparing(r -> r.get(\"@timestamp\").toString()));\n+\n+            assertEquals(3, requests.size(), requests.toString());\n@@ -63,4 +86,7 @@\n-            assertTrue(requests.get(0).get(\"message\").asString().contains(\"Hello\"));\n-            assertTrue(requests.get(0).get(\"message\").asString().contains(\"Warning\"));\n-            assertTrue(requests.get(0).get(\"message\").asString().contains(\"Bye\"));\n-            assertTrue(requests.get(0).get(\"message\").asString().contains(Level.WARNING.toString()));\n+            assertEquals(\"Hello\", requests.get(0).get(\"message\").asString());\n+            assertEquals(\"Warning!\", requests.get(1).get(\"message\").asString());\n+            assertEquals(\"Bye\", requests.get(2).get(\"message\").asString());\n+            assertEquals(Level.WARNING.toString(), requests.get(0).get(\"level\").asString());\n+            assertNotNull(requests.get(0).get(\"work_id\"), \"work_id not set\");\n+            assertTrue(requests.get(0).get(\"work_item\").asString().contains(\"LoggingBot@\"),\n+                    \"work_item has bad value \" + requests.get(0).get(\"work_item\").asString());\n@@ -71,1 +97,1 @@\n-    void extraField() throws IOException {\n+    void extraField() throws IOException, ExecutionException, InterruptedException {\n@@ -73,1 +99,4 @@\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n+            var handler = new BotLogstashHandler(receiver.getEndpoint());\n+            var futures = new ArrayList<Future<HttpResponse<Void>>>();\n+            handler.setFuturesCollection(futures);\n+\n@@ -80,0 +109,4 @@\n+            for (Future<HttpResponse<Void>> future : futures) {\n+                future.get();\n+            }\n+\n@@ -89,1 +122,1 @@\n-    void extraFieldTask() throws IOException {\n+    void extraFieldTask() throws IOException, ExecutionException, InterruptedException {\n@@ -91,1 +124,4 @@\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n+            var handler = new BotLogstashHandler(receiver.getEndpoint());\n+            var futures = new ArrayList<Future<HttpResponse<Void>>>();\n+            handler.setFuturesCollection(futures);\n+\n@@ -104,0 +140,4 @@\n+            for (Future<HttpResponse<Void>> future : futures) {\n+                future.get();\n+            }\n+\n@@ -105,1 +145,5 @@\n-            assertEquals(1, requests.size(), requests.toString());\n+            \/\/ The async message sending means we may get results in any order. Sort on the\n+            \/\/ timestamp to get the actual order.\n+            requests.sort(Comparator.comparing(r -> r.get(\"@timestamp\").toString()));\n+\n+            assertEquals(3, requests.size(), requests.toString());\n@@ -109,109 +153,1 @@\n-            assertEquals(\"ye\", requests.get(0).get(\"optional3\").asString());\n-            assertTrue(requests.get(0).get(\"greedy\").asString().contains(\"Executing item\"));\n-        }\n-    }\n-\n-    @Test\n-    void filterLowLevels() throws IOException {\n-        try (var receiver = new RestReceiver()) {\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 10);\n-\n-            LoggingBot.runOnce(handler, Level.FINER, log -> {\n-                for (int i = 0; i < 5; ++i) {\n-                    log.fine(\"Fine nr \" + i);\n-                }\n-                for (int i = 0; i < 5; ++i) {\n-                    log.finer(\"Finer nr \" + i);\n-                }\n-            });\n-\n-            var requests = receiver.getRequests();\n-            var aggregatedLines = requests.stream()\n-                                          .filter(request -> request.get(\"message\").asString().contains(\"Executing item\"))\n-                                          .findAny()\n-                                          .orElseThrow()\n-                                          .get(\"message\")\n-                                          .asString()\n-                                          .lines()\n-                                          .collect(Collectors.toList());\n-\n-            var fineLines = aggregatedLines.stream()\n-                                           .filter(line -> line.contains(\"Fine nr\"))\n-                                           .collect(Collectors.toList());\n-            var finerLines = aggregatedLines.stream()\n-                                            .filter(line -> line.contains(\"Finer nr\"))\n-                                            .collect(Collectors.toList());\n-            assertEquals(5, fineLines.size(), aggregatedLines.toString());\n-            assertEquals(0, finerLines.size(), aggregatedLines.toString());\n-        }\n-    }\n-\n-    @Test\n-    void filterLowestLevels() throws IOException {\n-        try (var receiver = new RestReceiver()) {\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 15);\n-\n-            LoggingBot.runOnce(handler, Level.FINER, log -> {\n-                for (int i = 0; i < 5; ++i) {\n-                    log.fine(\"Fine nr \" + i);\n-                }\n-                for (int i = 0; i < 5; ++i) {\n-                    log.finer(\"Finer nr \" + i);\n-                }\n-                for (int i = 0; i < 5; ++i) {\n-                    log.finest(\"Finest nr \" + i);\n-                }\n-            });\n-\n-            var requests = receiver.getRequests();\n-            var aggregatedLines = requests.stream()\n-                                          .filter(request -> request.get(\"message\").asString().contains(\"Executing item\"))\n-                                          .findAny()\n-                                          .orElseThrow()\n-                                          .get(\"message\")\n-                                          .asString()\n-                                          .lines()\n-                                          .collect(Collectors.toList());\n-\n-            var fineLines = aggregatedLines.stream()\n-                                           .filter(line -> line.contains(\"Fine nr\"))\n-                                           .collect(Collectors.toList());\n-            var finerLines = aggregatedLines.stream()\n-                                            .filter(line -> line.contains(\"Finer nr\"))\n-                                            .collect(Collectors.toList());\n-            var finestLines = aggregatedLines.stream()\n-                                             .filter(line -> line.contains(\"Finest nr\"))\n-                                             .collect(Collectors.toList());\n-            assertEquals(5, fineLines.size(), aggregatedLines.toString());\n-            assertEquals(5, finerLines.size(), aggregatedLines.toString());\n-            assertEquals(0, finestLines.size(), aggregatedLines.toString());\n-        }\n-    }\n-\n-    @Test\n-    void filterMiddle() throws IOException {\n-        try (var receiver = new RestReceiver()) {\n-            var handler = new BotLogstashHandler(receiver.getEndpoint(), 100);\n-\n-            LoggingBot.runOnce(handler, Level.FINER, log -> {\n-                for (int i = 0; i < 100; ++i) {\n-                    log.fine(\"Start nr \" + i);\n-                }\n-                for (int i = 0; i < 100; ++i) {\n-                    log.fine(\"Middle nr \" + i);\n-                }\n-                for (int i = 0; i < 100; ++i) {\n-                    log.fine(\"End nr \" + i);\n-                }\n-            });\n-\n-            var requests = receiver.getRequests();\n-            var aggregatedLines = requests.stream()\n-                                          .filter(request -> request.get(\"message\").asString().contains(\"Executing item\"))\n-                                          .findAny()\n-                                          .orElseThrow()\n-                                          .get(\"message\")\n-                                          .asString();\n-            assertTrue(aggregatedLines.contains(\"Start nr\"));\n-            assertFalse(aggregatedLines.contains(\"Middle nr\"));\n-            assertTrue(aggregatedLines.contains(\"End nr\"));\n+            assertEquals(\"ye\", requests.get(2).get(\"optional3\").asString());\n","filename":"bots\/cli\/src\/test\/java\/org\/openjdk\/skara\/bots\/cli\/BotLogstashHandlerTests.java","additions":62,"deletions":126,"binary":false,"changes":188,"status":"modified"}]}