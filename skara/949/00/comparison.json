{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.util.regex.Pattern;\n@@ -56,4 +57,1 @@\n-    private String commitMessage(List<Review> activeReviews, Namespace namespace, boolean manualReviewers) throws IOException {\n-        return commitMessage(activeReviews, namespace, manualReviewers, null);\n-    }\n-    private String commitMessage(List<Review> activeReviews, Namespace namespace, boolean manualReviewers, Hash original) throws IOException {\n+    private String commitMessage(Hash head, List<Review> activeReviews, Namespace namespace, boolean manualReviewers, Hash original) throws IOException {\n@@ -85,9 +83,33 @@\n-        var issue = Issue.fromStringRelaxed(pr.title());\n-        var commitMessageBuilder = issue.map(CommitMessage::title).orElseGet(() -> CommitMessage.title(pr.title()));\n-        if (issue.isPresent()) {\n-            commitMessageBuilder.issues(additionalIssues);\n-        }\n-        commitMessageBuilder.contributors(additionalContributors)\n-                            .reviewers(new ArrayList<>(reviewers));\n-        if (original != null) {\n-            commitMessageBuilder.original(original);\n+        CommitMessageBuilder commitMessageBuilder;\n+        if (PullRequestUtils.isMerge(pr)) {\n+            var conf = JCheckConfiguration.from(localRepo, head);\n+            var title = pr.title();\n+            if (conf.isPresent()) {\n+                var mergeConf = conf.get().checks().merge();\n+                var pattern = Pattern.compile(mergeConf.message());\n+                while (true)  {\n+                    var matcher = pattern.matcher(title);\n+                    if (matcher.matches()) {\n+                        break;\n+                    } else {\n+                        if (title.length() > 1) {\n+                            title = title.substring(0, title.length() - 1);\n+                        } else {\n+                            throw new RuntimeException(\"Unable to make merge PR title '\" + pr.title() + \"' conform to '\" + mergeConf.message() + \"'\");\n+                        }\n+                    }\n+                }\n+            }\n+            commitMessageBuilder = CommitMessage.title(title);\n+        } else {\n+            var issue = Issue.fromStringRelaxed(pr.title());\n+            commitMessageBuilder = issue.map(CommitMessage::title).orElseGet(() -> CommitMessage.title(pr.title()));\n+            if (issue.isPresent()) {\n+                commitMessageBuilder.issues(additionalIssues);\n+            }\n+            if (original != null) {\n+                commitMessageBuilder.original(original);\n+            }\n+            commitMessageBuilder.contributors(additionalContributors)\n+                                .reviewers(new ArrayList<>(reviewers));\n+            summary.ifPresent(commitMessageBuilder::summary);\n@@ -95,1 +117,0 @@\n-        summary.ifPresent(commitMessageBuilder::summary);\n@@ -138,1 +159,1 @@\n-        var commitMessage = commitMessage(activeReviews, namespace, false, original);\n+        var commitMessage = commitMessage(finalHead, activeReviews, namespace, false, original);\n@@ -144,2 +165,2 @@\n-        var originalCommitMessage = commitMessage(activeReviews, namespace, false, original);\n-        var amendedCommitMessage = commitMessage(activeReviews, namespace, true, original);\n+        var originalCommitMessage = commitMessage(commit, activeReviews, namespace, false, original);\n+        var amendedCommitMessage = commitMessage(commit, activeReviews, namespace, true, original);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckablePullRequest.java","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -121,0 +121,84 @@\n+            assertEquals(\"Merge \" + author.name() + \":other\", headCommit.message().get(0));\n+            assertEquals(\"Generated Committer 1\", headCommit.author().name());\n+            assertEquals(\"integrationcommitter1@openjdk.java.net\", headCommit.author().email());\n+            assertEquals(\"Generated Committer 1\", headCommit.committer().name());\n+            assertEquals(\"integrationcommitter1@openjdk.java.net\", headCommit.committer().email());\n+        }\n+    }\n+\n+    @Test\n+    void branchMergeRestrictedMessage(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType(),\n+                                                     Path.of(\"appendable.txt\"), Set.of(\"merge\"), \"1.0\");\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make more changes in another branch\n+            var otherHash1 = CheckableRepository.appendAndCommit(localRepo, \"First change in other\",\n+                                                                 \"First other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash1, author.url(), \"other\", true);\n+            var otherHash2 = CheckableRepository.appendAndCommit(localRepo, \"Second change in other\",\n+                                                                 \"Second other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash2, author.url(), \"other\");\n+\n+            \/\/ Go back to the original master\n+            localRepo.checkout(masterHash, true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var unrelated = Files.writeString(localRepo.root().resolve(\"unrelated.txt\"), \"Unrelated\", StandardCharsets.UTF_8);\n+            localRepo.add(unrelated);\n+            var updatedMaster = localRepo.commit(\"Unrelated\", \"some\", \"some@one\");\n+            localRepo.merge(otherHash2);\n+            localRepo.push(updatedMaster, author.url(), \"master\");\n+\n+            var mergeHash = localRepo.commit(\"Merge commit\", \"some\", \"some@one\");\n+            localRepo.push(mergeHash, author.url(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Merge \" + author.name() + \":other\");\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ Let the bot check the status\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Push it\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with an ok message\n+            assertLastCommentContains(pr, \"Pushed as commit\");\n+\n+            \/\/ The change should now be present on the master branch\n+            var pushedRepoFolder = tempFolder.path().resolve(\"pushedrepo\");\n+            var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), \"master\");\n+            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));\n+\n+            \/\/ The commits from the \"other\" branch should be preserved and not squashed (but not the merge commit)\n+            var headHash = pushedRepo.resolve(\"HEAD\").orElseThrow();\n+            Set<Hash> commits;\n+            try (var tempCommits = pushedRepo.commits(masterHash.hex() + \"..\" + headHash.hex())) {\n+                commits = tempCommits.stream()\n+                                     .map(Commit::hash)\n+                                     .collect(Collectors.toSet());\n+            }\n+            assertTrue(commits.contains(otherHash1));\n+            assertTrue(commits.contains(otherHash2));\n+            assertFalse(commits.contains(mergeHash));\n+\n+            \/\/ The commit message should be just \"Merge\"\n+            var headCommit = pushedRepo.commits(headHash.hex() + \"^..\" + headHash.hex()).asList().get(0);\n+            assertEquals(\"Merge\", headCommit.message().get(0));\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/MergeTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"}]}