{"files":[{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.skara.bots.pr;\n-\n-import java.nio.file.Path;\n-import java.util.*;\n-import java.util.regex.Pattern;\n-\n-public class LabelConfiguration {\n-    private final Map<String, List<Pattern>> matchers;\n-    private final Map<String, List<String>> groups;\n-    private final Set<String> extra;\n-    private final Set<String> allowed;\n-\n-    private LabelConfiguration(Map<String, List<Pattern>> matchers, Map<String, List<String>> groups, Set<String> extra) {\n-        this.matchers = Collections.unmodifiableMap(matchers);\n-        this.groups = Collections.unmodifiableMap(groups);\n-        this.extra = Collections.unmodifiableSet(extra);\n-\n-        var allowed = new HashSet<String>();\n-        allowed.addAll(matchers.keySet());\n-        allowed.addAll(groups.keySet());\n-        allowed.addAll(extra);\n-        this.allowed = Collections.unmodifiableSet(allowed);\n-    }\n-\n-    static class LabelConfigurationBuilder {\n-        private final Map<String, List<Pattern>> matchers = new HashMap<>();\n-        private final Map<String, List<String>> groups = new HashMap<>();\n-        private final Set<String> extra = new HashSet<>();\n-\n-        public LabelConfigurationBuilder addMatchers(String label, List<Pattern> matchers) {\n-            this.matchers.put(label, matchers);\n-            return this;\n-        }\n-\n-        public LabelConfigurationBuilder addGroup(String label, List<String> members) {\n-            groups.put(label, members);\n-            return this;\n-        }\n-\n-        public LabelConfigurationBuilder addExtra(String label) {\n-            extra.add(label);\n-            return this;\n-        }\n-\n-        public LabelConfiguration build() {\n-            return new LabelConfiguration(matchers, groups, extra);\n-        }\n-    }\n-\n-    static LabelConfigurationBuilder newBuilder() {\n-        return new LabelConfigurationBuilder();\n-    }\n-\n-    public Set<String> fromChanges(Set<Path> changes) {\n-        var labels = new HashSet<String>();\n-        for (var file : changes) {\n-            for (var label : matchers.entrySet()) {\n-                for (var pattern : label.getValue()) {\n-                    var matcher = pattern.matcher(file.toString());\n-                    if (matcher.find()) {\n-                        labels.add(label.getKey());\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        var ret = new HashSet<>(labels);\n-        \/\/ If the current labels matches at least two members of a group, use the group instead\n-        for (var group : groups.entrySet()) {\n-            var count = 0;\n-            for (var groupEntry : group.getValue()) {\n-                if (ret.contains(groupEntry)) {\n-                    count++;\n-                    if (count == 2) {\n-                        ret.add(group.getKey());\n-                        ret.removeAll(group.getValue());\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    public Set<String> allowed() {\n-        return allowed;\n-    }\n-}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/LabelConfiguration.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -47,1 +47,1 @@\n-        return bot.labelConfiguration().fromChanges(files);\n+        return bot.labelConfiguration().label(files);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/LabelerWorkItem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.skara.forge.LabelConfiguration;\n@@ -36,1 +37,1 @@\n-    private LabelConfiguration labelConfiguration = LabelConfiguration.newBuilder().build();\n+    private LabelConfiguration labelConfiguration = LabelConfiguration.builder().build();\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.skara.forge.LabelConfiguration;\n@@ -67,25 +68,2 @@\n-            var labelConfiguration = LabelConfiguration.newBuilder();\n-            if (labelGroup.value().contains(\"matchers\")) {\n-                var matchers = labelGroup.value().get(\"matchers\").fields().stream()\n-                                         .collect(Collectors.toMap(JSONObject.Field::name,\n-                                                                   field -> field.value().stream()\n-                                                                                 .map(JSONValue::asString)\n-                                                                                 .map(Pattern::compile)\n-                                                                                 .collect(Collectors.toList())));\n-                matchers.forEach(labelConfiguration::addMatchers);\n-            }\n-            if (labelGroup.value().contains(\"groups\")) {\n-                var groups = labelGroup.value().get(\"groups\").fields().stream()\n-                                       .collect(Collectors.toMap(JSONObject.Field::name,\n-                                                                 field -> field.value().stream()\n-                                                                               .map(JSONValue::asString)\n-                                                                               .collect(Collectors.toList())));\n-                groups.forEach(labelConfiguration::addGroup);\n-            }\n-            if (labelGroup.value().contains(\"extra\")) {\n-                var extra = labelGroup.value().get(\"extra\").stream()\n-                                      .map(JSONValue::asString)\n-                                      .collect(Collectors.toList());\n-                extra.forEach(labelConfiguration::addExtra);\n-            }\n-            labelConfigurations.put(labelGroup.name(), labelConfiguration.build());\n+            labelConfigurations.put(labelGroup.name(),\n+                                    LabelConfiguration.fromJSON(labelGroup.value()));\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotFactory.java","additions":3,"deletions":25,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.skara.bots.pr;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import java.nio.file.Path;\n-import java.util.*;\n-import java.util.regex.Pattern;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-public class LabelConfigurationTests {\n-    @Test\n-    void simple() {\n-        var config = LabelConfiguration.newBuilder()\n-                                       .addMatchers(\"1\", List.of(Pattern.compile(\"cpp$\")))\n-                                       .addMatchers(\"2\", List.of(Pattern.compile(\"hpp$\")))\n-                                       .build();\n-\n-        assertEquals(Set.of(\"1\", \"2\"), config.allowed());\n-\n-        assertEquals(Set.of(\"1\"), config.fromChanges(Set.of(Path.of(\"a.cpp\"))));\n-        assertEquals(Set.of(\"2\"), config.fromChanges(Set.of(Path.of(\"a.hpp\"))));\n-        assertEquals(Set.of(\"1\", \"2\"), config.fromChanges(Set.of(Path.of(\"a.cpp\"), Path.of(\"a.hpp\"))));\n-    }\n-\n-    @Test\n-    void group() {\n-        var config = LabelConfiguration.newBuilder()\n-                                       .addMatchers(\"1\", List.of(Pattern.compile(\"cpp$\")))\n-                                       .addMatchers(\"2\", List.of(Pattern.compile(\"hpp$\")))\n-                                       .addGroup(\"both\", List.of(\"1\", \"2\"))\n-                                       .build();\n-\n-        assertEquals(Set.of(\"1\", \"2\", \"both\"), config.allowed());\n-\n-        assertEquals(Set.of(\"1\"), config.fromChanges(Set.of(Path.of(\"a.cpp\"))));\n-        assertEquals(Set.of(\"2\"), config.fromChanges(Set.of(Path.of(\"a.hpp\"))));\n-        assertEquals(Set.of(\"both\"), config.fromChanges(Set.of(Path.of(\"a.cpp\"), Path.of(\"a.hpp\"))));\n-    }\n-}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/LabelConfigurationTests.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -25,0 +25,1 @@\n+import org.openjdk.skara.forge.LabelConfiguration;\n@@ -47,1 +48,1 @@\n-            var labelConfiguration = LabelConfiguration.newBuilder()\n+            var labelConfiguration = LabelConfiguration.builder()\n@@ -137,1 +138,1 @@\n-            var labelConfiguration = LabelConfiguration.newBuilder()\n+            var labelConfiguration = LabelConfiguration.builder()\n@@ -267,1 +268,1 @@\n-            var labelConfiguration = LabelConfiguration.newBuilder()\n+            var labelConfiguration = LabelConfiguration.builder()\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/LabelTests.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.skara.forge.LabelConfiguration;\n@@ -44,1 +45,1 @@\n-            var labelConfiguration = LabelConfiguration.newBuilder()\n+            var labelConfiguration = LabelConfiguration.builder()\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/LabelerTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import org.openjdk.skara.vcs.ReadOnlyRepository;\n@@ -30,0 +31,3 @@\n+import org.openjdk.skara.forge.Forge;\n+import org.openjdk.skara.forge.LabelConfiguration;\n+import org.openjdk.skara.json.JSON;\n@@ -36,4 +40,1 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Optional;\n+import java.util.*;\n@@ -59,0 +60,5 @@\n+        Option.shortcut(\"\")\n+              .fullname(\"cc\")\n+              .describe(\"MAILING LISTS\")\n+              .helptext(\"Mailing lists to CC for inital RFR e-mail\")\n+              .optional(),\n@@ -100,0 +106,27 @@\n+\n+    private static LabelConfiguration labelConfiguration(Forge forge, String project) throws IOException {\n+        var group = project.split(\"\/\")[0];\n+        var skaraRemoteRepo = forge.repository(group + \"\/skara\").orElseThrow(() ->\n+            new IOException(\"error: could not resolve Skara repository\")\n+        );\n+        var rules = skaraRemoteRepo.fileContents(\"config\/mailinglist\/rules\/jdk.json\", \"master\");\n+        var json = JSON.parse(rules);\n+        return LabelConfiguration.fromJSON(json);\n+    }\n+\n+    private static Set<String> suggestedLabels(ReadOnlyRepository repo, Forge forge, String project, String targetRef, String headRef) throws IOException {\n+        var config = labelConfiguration(forge, project);\n+        var baseHash = repo.resolve(targetRef).orElseThrow(() ->\n+            new IOException(\"error: cannot resolve \" + targetRef)\n+        );\n+        var headHash = repo.resolve(headRef).orElseThrow(() ->\n+            new IOException(\"error: cannot resolve \" + headRef)\n+        );\n+        var status = repo.status(baseHash, headHash);\n+        var files = status.stream()\n+                          .filter(e -> !e.status().isDeleted())\n+                          .map(e -> e.target().path().get())\n+                          .collect(Collectors.toSet());\n+        return config.label(files);\n+    }\n+\n@@ -272,0 +305,78 @@\n+        var mailingLists = new ArrayList<String>();\n+        var parentProject = projectName(parentRepo.url());\n+        var isTargetingJDKRepo = parentProject.endsWith(\"jdk\");\n+        var cc = getOption(\"cc\", \"create\", arguments);\n+        var isCCManual = cc != null && !cc.equals(\"auto\");\n+        if (!isTargetingJDKRepo && isCCManual) {\n+            System.out.println(\"error: you cannot manually CC additional mailing lists for \" + parentProject);\n+            System.exit(1);\n+        }\n+        if (isTargetingJDKRepo) {\n+            if (isCCManual) {\n+                var config = labelConfiguration(host, parentProject);\n+                var lists = cc.split(\",\");\n+                for (var input : lists) {\n+                    var label = input;\n+                    if (label.endsWith(\"@openjdk.java.net\")) {\n+                        label = input.split(\"@\")[0];\n+                    }\n+                    if (label.endsWith(\"-dev\")) {\n+                        label = label.replace(\"-dev\", \"\");\n+                    }\n+                    if (!config.isAllowed(label) && !config.isAllowed(label + \"-dev\")) {\n+                        System.out.println(\"error: the mailing list \\\"\" + label +\n+                                           \"-dev@openjdk.java.net\\\" is not applicable, aborting.\");\n+                        System.exit(1);\n+                    }\n+                }\n+                System.out.println(\"You have chosen the following mailing lists to be CC:d for the \\\"RFR\\\" e-mail:\");\n+                for (var input : lists) {\n+                    String list = null;\n+                    if (input.endsWith(\"@openjdk.java.net\")) {\n+                        list = input;\n+                    } else if (input.endsWith(\"-dev\")) {\n+                        list = input + \"@openjdk.java.net\";\n+                    } else  {\n+                        list = input + \"-dev@openjdk.java.net\";\n+                    }\n+                    System.out.println(\"- \" + list);\n+                    mailingLists.add(list);\n+                }\n+            } else {\n+                var suggested = suggestedLabels(repo, host, parentProject, targetBranch, headRef);\n+                System.out.println(\"The following mailing lists will be CC:d for the \\\"RFR\\\" e-mail:\");\n+                for (var label : suggested) {\n+                    String list = null;\n+                    if (label.endsWith(\"-dev\")) {\n+                        list = label + \"@openjdk.java.net\";\n+                    } else {\n+                        list = label + \"-dev@openjdk.java.net\";\n+                    }\n+                    if (cc == null) {\n+                        System.out.println(\"- \" + list);\n+                    }\n+                    mailingLists.add(list);\n+                }\n+            }\n+            if (cc == null || !cc.equals(\"auto\")) {\n+                System.out.println(\"\");\n+                System.out.print(\"Do you want to proceed with this mailing list selection? [Y\/n]: \");\n+                var scanner = new Scanner(System.in);\n+                var answer = scanner.nextLine().toLowerCase();\n+                while (!(answer.equals(\"y\") || answer.equals(\"n\") || answer.isEmpty())) {\n+                    System.out.print(\"Please answer with 'y', 'n' or empty for the default choice: \");\n+                    answer = scanner.nextLine().toLowerCase();\n+                }\n+                if (!(answer.isEmpty() || answer.equals(\"y\"))) {\n+                    System.out.println(\"\");\n+                    System.out.println(\"error: user not satisfied with mailing list selection, aborting.\");\n+                    if (cc == null) {\n+                        System.out.println(\"       To specify mailing lists manually, use the --cc option.\");\n+                    } else if (cc.equals(\"auto\")) {\n+                        System.out.println(\"       You have set --cc=auto, you can use --cc to specify mailing lists manually\");\n+                    }\n+                    System.exit(1);\n+                }\n+            }\n+        }\n+\n@@ -330,0 +441,7 @@\n+        if (!mailingLists.isEmpty()) {\n+            appendPaddedHTMLComment(file, \"\");\n+            appendPaddedHTMLComment(file, \"The following mailing lists will be CC:d for the \\\"RFR\\\" e-mail:\");\n+            for (var list : mailingLists) {\n+                appendPaddedHTMLComment(file, \"- \" + list);\n+            }\n+        }\n@@ -357,0 +475,7 @@\n+\n+        if (isCCManual && !mailingLists.isEmpty()) {\n+            var arg = mailingLists.stream()\n+                                  .map(l -> l.split(\"@\")[0].replace(\"-dev\", \"\"))\n+                                  .collect(Collectors.joining(\",\"));\n+            body.add(\"\/cc \" + arg);\n+        }\n","filename":"cli\/src\/main\/java\/org\/openjdk\/skara\/cli\/pr\/GitPrCreate.java","additions":129,"deletions":4,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.forge;\n+\n+import org.openjdk.skara.json.JSONValue;\n+import org.openjdk.skara.json.JSONObject;\n+\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+public class LabelConfiguration {\n+    private final Map<String, List<Pattern>> matchers;\n+    private final Map<String, List<String>> groups;\n+    private final Set<String> extra;\n+    private final Set<String> allowed;\n+\n+    private LabelConfiguration(Map<String, List<Pattern>> matchers, Map<String, List<String>> groups, Set<String> extra) {\n+        this.matchers = Collections.unmodifiableMap(matchers);\n+        this.groups = Collections.unmodifiableMap(groups);\n+        this.extra = Collections.unmodifiableSet(extra);\n+\n+        var allowed = new HashSet<String>();\n+        allowed.addAll(matchers.keySet());\n+        allowed.addAll(groups.keySet());\n+        allowed.addAll(extra);\n+        this.allowed = Collections.unmodifiableSet(allowed);\n+    }\n+\n+    public static class Builder {\n+        private final Map<String, List<Pattern>> matchers = new HashMap<>();\n+        private final Map<String, List<String>> groups = new HashMap<>();\n+        private final Set<String> extra = new HashSet<>();\n+\n+        public Builder addMatchers(String label, List<Pattern> matchers) {\n+            this.matchers.put(label, matchers);\n+            return this;\n+        }\n+\n+        public Builder addGroup(String label, List<String> members) {\n+            groups.put(label, members);\n+            return this;\n+        }\n+\n+        public Builder addExtra(String label) {\n+            extra.add(label);\n+            return this;\n+        }\n+\n+        public LabelConfiguration build() {\n+            return new LabelConfiguration(matchers, groups, extra);\n+        }\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static LabelConfiguration fromJSON(JSONValue json) {\n+        var builder = builder();\n+        if (json.contains(\"matchers\")) {\n+            var fields = json.get(\"matchers\").fields();\n+            var matchers = fields.stream()\n+                                 .collect(Collectors.toMap(JSONObject.Field::name,\n+                                                           field -> field.value()\n+                                                                         .stream()\n+                                                                         .map(JSONValue::asString)\n+                                                                         .map(Pattern::compile)\n+                                                                         .collect(Collectors.toList())));\n+            matchers.forEach(builder::addMatchers);\n+        }\n+        if (json.contains(\"groups\")) {\n+            var fields = json.get(\"groups\").fields();\n+            var groups = fields.stream()\n+                               .collect(Collectors.toMap(JSONObject.Field::name,\n+                                                         field -> field.value()\n+                                                                       .stream()\n+                                                                       .map(JSONValue::asString)\n+                                                                       .collect(Collectors.toList())));\n+            groups.forEach(builder::addGroup);\n+        }\n+        if (json.contains(\"extra\")) {\n+            var extra = json.get(\"extra\").stream()\n+                                         .map(JSONValue::asString)\n+                                         .collect(Collectors.toList());\n+            extra.forEach(builder::addExtra);\n+        }\n+        return builder.build();\n+    }\n+\n+    public Set<String> label(Set<Path> changes) {\n+        var labels = new HashSet<String>();\n+        for (var file : changes) {\n+            for (var label : matchers.entrySet()) {\n+                for (var pattern : label.getValue()) {\n+                    var matcher = pattern.matcher(file.toString());\n+                    if (matcher.find()) {\n+                        labels.add(label.getKey());\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        var ret = new HashSet<>(labels);\n+        \/\/ If the current labels matches at least two members of a group, use the group instead\n+        for (var group : groups.entrySet()) {\n+            var count = 0;\n+            for (var groupEntry : group.getValue()) {\n+                if (ret.contains(groupEntry)) {\n+                    count++;\n+                    if (count == 2) {\n+                        ret.add(group.getKey());\n+                        ret.removeAll(group.getValue());\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    public Set<String> allowed() {\n+        return allowed;\n+    }\n+\n+    public boolean isAllowed(String s) {\n+        return allowed.contains(s);\n+    }\n+}\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/LabelConfiguration.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.forge;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class LabelConfigurationTests {\n+    @Test\n+    void simple() {\n+        var config = LabelConfiguration.builder()\n+                                       .addMatchers(\"1\", List.of(Pattern.compile(\"cpp$\")))\n+                                       .addMatchers(\"2\", List.of(Pattern.compile(\"hpp$\")))\n+                                       .build();\n+\n+        assertEquals(Set.of(\"1\", \"2\"), config.allowed());\n+\n+        assertEquals(Set.of(\"1\"), config.label(Set.of(Path.of(\"a.cpp\"))));\n+        assertEquals(Set.of(\"2\"), config.label(Set.of(Path.of(\"a.hpp\"))));\n+        assertEquals(Set.of(\"1\", \"2\"), config.label(Set.of(Path.of(\"a.cpp\"), Path.of(\"a.hpp\"))));\n+    }\n+\n+    @Test\n+    void group() {\n+        var config = LabelConfiguration.builder()\n+                                       .addMatchers(\"1\", List.of(Pattern.compile(\"cpp$\")))\n+                                       .addMatchers(\"2\", List.of(Pattern.compile(\"hpp$\")))\n+                                       .addGroup(\"both\", List.of(\"1\", \"2\"))\n+                                       .build();\n+\n+        assertEquals(Set.of(\"1\", \"2\", \"both\"), config.allowed());\n+\n+        assertEquals(Set.of(\"1\"), config.labels(Set.of(Path.of(\"a.cpp\"))));\n+        assertEquals(Set.of(\"2\"), config.labels(Set.of(Path.of(\"a.hpp\"))));\n+        assertEquals(Set.of(\"both\"), config.labels(Set.of(Path.of(\"a.cpp\"), Path.of(\"a.hpp\"))));\n+    }\n+}\n","filename":"forge\/src\/test\/java\/org\/openjdk\/skara\/forge\/LabelConfigurationTests.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}