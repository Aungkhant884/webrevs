{"files":[{"patch":"@@ -27,2 +27,0 @@\n-import org.openjdk.skara.vcs.Branch;\n-import org.openjdk.skara.vcs.Commit;\n@@ -165,4 +163,4 @@\n-        Optional<Hash> prepushHash = checkForPrePushHash(bot, pr, scratchPath, allComments, \"integrate\");\n-        if (prepushHash.isPresent()) {\n-            markIntegratedAndMerged(bot, scratchPath, pr, prepushHash.get(), reply);\n-            return;\n+        \/\/ final Optional<Hash> prepushHash = checkForPrePushHash(bot, pr, scratchPath, allComments, \"integrate\");\n+\n+        if (pr.state() == PullRequest.State.RESOLVED) {\n+            markIntegratedAndMerge(pr, reply);\n@@ -192,0 +190,2 @@\n+            final boolean integrationBranchExists = pr.repository().branchHash(\"integration\/\" + pr.id()).isPresent();\n+\n@@ -195,19 +195,6 @@\n-            Repository localRepo = new HostedRepositoryPool(bot.seedStorage().orElse(scratchPath.resolve(\"seeds\")))\n-                     .materialize(pr.repository(), scratchPath.resolve(pr.targetRef() + \"\/\" + pr.headHash().hex()));\n-            localRepo.fetch(pr.repository().url(), \"+\" + pr.targetRef() + \":\" + pr.targetRef() + pr.headHash().hex(), true);\n-            localRepo.checkout(new Branch(pr.targetRef() + pr.headHash().hex()), false);\n-\n-            \/\/ See markIntegratedAndMerged for the logic for rogue mark as merged handling\n-            final List<Commit> commits = localRepo.commits(2).asList();\n-            commits.forEach(commit -> log.fine(commit.toString()));\n-            final Commit currentMarkAsMergedCommit =\n-                    isMarkAsMergeCommit(commits.get(0)) ? commits.get(0) : null;\n-            final Commit lastMarkAsMergedCommit =\n-                    (commits.size() == 2 ? (isMarkAsMergeCommit(commits.get(1)) ? commits.get(1) : null) : null);\n-\n-            if (lastMarkAsMergedCommit != null) {\n-                localRepo.reset(lastMarkAsMergedCommit.parents().get(0), true);\n-                localRepo.push(lastMarkAsMergedCommit.parents().get(0), pr.repository().url(), pr.targetRef(), true);\n-            } else if (currentMarkAsMergedCommit != null) {\n-                localRepo.reset(currentMarkAsMergedCommit.parents().get(0), true);\n-                localRepo.push(currentMarkAsMergedCommit.parents().get(0), pr.repository().url(), pr.targetRef(), true);\n+            Repository localRepo = materializeLocalRepo(bot, pr, scratchPath, \"integrate\");\n+\n+            if (integrationBranchExists) {\n+                final Hash last = localRepo.fetch(pr.repository().url(), \"+integration\/\" + pr.id() + \":integration\/\" + pr.id(), true);\n+                localRepo.push(last, pr.sourceRepository().orElseThrow().url(), pr.sourceRef(), true);\n+                pr = pr.repository().pullRequest(pr.id());\n@@ -216,1 +203,0 @@\n-            localRepo = materializeLocalRepo(bot, pr, scratchPath, \"integrate\");\n@@ -233,0 +219,3 @@\n+                if (integrationBranchExists) {\n+                    pr.repository().deleteBranch(\"integration\/\" + pr.id());\n+                }\n@@ -265,0 +254,1 @@\n+                localRepo.push(amendedHash, pr.repository().url(), \"integration\/\" + pr.id(), true);\n@@ -266,2 +256,3 @@\n-                localRepo.push(amendedHash, pr.repository().url(), pr.targetRef());\n-                markIntegratedAndMerged(bot, scratchPath, pr, amendedHash, reply);\n+                \/\/ Force the Pull Request branch to accept edits from maintainers somehow?\n+                localRepo.push(amendedHash, pr.sourceRepository().orElseThrow().url(), pr.sourceRef(), true);\n+                markIntegratedAndMerge(pr, reply);\n@@ -344,1 +335,2 @@\n-        writer.println(\"Going to push as commit \" + hash.hex() + \".\");\n+        writer.println(\"Recording snapshot of final changes as commit \" + hash.hex() + \".\");\n+        writer.println(\"New changes can no longer be made past this point, except for if an automatic rebase fails.\");\n@@ -351,1 +343,1 @@\n-    static void markIntegratedAndMerged(PullRequestBot bot, Path scratchPath, PullRequest pr, Hash hash, PrintWriter reply) {\n+    static void markIntegratedAndMerge(PullRequest pr,PrintWriter reply) {\n@@ -354,61 +346,0 @@\n-        Repository repository;\n-        Hash markMergedHash;\n-        Commit currentMarkAsMergedCommit;\n-        Commit lastMarkAsMergedCommit;\n-\n-        try {\n-            repository = new HostedRepositoryPool(bot.seedStorage().orElse(scratchPath.resolve(\"seeds\")))\n-                      .materialize(pr.repository(), scratchPath.resolve(pr.targetRef() + \"\/\" + pr.headHash().hex()));\n-            repository.reinitialize();\n-            repository.fetch(pr.repository().url(), \"+\" + pr.targetRef() + \":\" + pr.targetRef() + pr.headHash().hex(), true);\n-            repository.checkout(new Branch(pr.targetRef() + pr.headHash().hex()), false);\n-            List<Commit> commits = repository.commits(2).asList();\n-            commits.forEach(commit -> log.fine(commit.toString()));\n-            currentMarkAsMergedCommit = isMarkAsMergeCommit(commits.get(0)) ? commits.get(0) : null;\n-            \/\/ Work with the possibility that only a single commit exists on the repository\n-            lastMarkAsMergedCommit =\n-                    (commits.size() == 2 ? (isMarkAsMergeCommit(commits.get(1)) ? commits.get(1) : null) : null);\n-\n-            \/*\n-             * Not good, have to handle this now, since commits after a mark as merged one are\n-             * treated as broken)\n-             *\/\n-            if (lastMarkAsMergedCommit != null) {\n-                \/\/ Mark as Merged commits always have a preceding commit, same applies below\n-                repository.reset(lastMarkAsMergedCommit.parents().get(0), true);\n-                repository.push(lastMarkAsMergedCommit.parents().get(0), pr.repository().url(), pr.targetRef(), true);\n-                lastMarkAsMergedCommit = null;\n-\n-                \/*\n-                 * In the unlikely and very erroneous case that 2 mark as merged commits are back\n-                 * to back getting rid of the first one would remove the one that comes after\n-                 *\/\n-                currentMarkAsMergedCommit = null;\n-            } else if (currentMarkAsMergedCommit != null) {\n-                if (pr.state() == PullRequest.State.RESOLVED ||\n-                        !currentMarkAsMergedCommit.message().get(0).substring(31).equals(hash.hex())) {\n-                    repository.reset(currentMarkAsMergedCommit.parents().get(0), true);\n-                    repository.push(currentMarkAsMergedCommit.parents().get(0), pr.repository().url(), pr.targetRef(), true);\n-                    currentMarkAsMergedCommit = null;\n-                }\n-            }\n-\n-            \/*\n-             * Not needed if Pull Request is already marked as merged, or we are on our\n-             * own mark as merged commit\n-             *\/\n-            if (pr.state() != PullRequest.State.RESOLVED && currentMarkAsMergedCommit == null) {\n-                commits = repository.commits(hash.hex(), 2).asList();\n-                commits.forEach(commit -> log.fine(commit.toString()));\n-                \/\/ There is always at least one prior commit before the integrated one\n-                repository.revert(commits.get(1).hash());\n-                repository.addremove();\n-                markMergedHash = repository.commit(\"Mark Integration as Merged for \" + hash.hex(), \"duke\", \"duke@openjdk.org\");\n-                repository.push(markMergedHash, pr.repository().url(), pr.targetRef(), false);\n-            } else {\n-                markMergedHash = (pr.state() == PullRequest.State.RESOLVED ? null : currentMarkAsMergedCommit.hash());\n-            }\n-        } catch (IOException exception) {\n-            throw new UncheckedIOException(exception);\n-        }\n-\n@@ -416,1 +347,3 @@\n-        if (pr.state() != PullRequest.State.RESOLVED) pr.setState(PullRequest.State.RESOLVED);\n+        if (pr.state() != PullRequest.State.RESOLVED) {\n+            pr.setState(PullRequest.State.RESOLVED);\n+        }\n@@ -425,1 +358,1 @@\n-        reply.println(PullRequest.commitHashMessage(hash));\n+        reply.println(PullRequest.commitHashMessage(pr.findIntegratedCommitHash().get()));\n@@ -427,17 +360,2 @@\n-        reply.println(\":bulb: You may see a message that your pull request was closed with unmerged commits. This can be safely ignored.\");\n-\n-        try {\n-            if (markMergedHash != null) {\n-                repository.reset(hash, true);\n-                repository.push(hash, pr.repository().url(), pr.targetRef(), true);\n-            }\n-        } catch (IOException exception) {\n-            throw new UncheckedIOException(exception);\n-        }\n-    }\n-\n-    static boolean isMarkAsMergeCommit(Commit commit) {\n-        return commit.author().name().equals(\"duke\")\n-                && commit.author().email().equals(\"duke@openjdk.org\")\n-                && (commit.message().size() == 1 ?\n-                    commit.message().get(0).startsWith(\"Mark Integration as Merged for \") : false);\n+        reply.println(\":bulb: You may see a message that branches were created around your pull request. This can be safely ignored.\");\n+        pr.repository().deleteBranch(\"integration\/\" + pr.id());\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":28,"deletions":110,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import org.openjdk.skara.vcs.Branch;\n-import org.openjdk.skara.vcs.Commit;\n@@ -53,4 +51,4 @@\n-        Optional<Hash> prePushHash = IntegrateCommand.checkForPrePushHash(bot, pr, scratchPath, allComments, \"sponsor\");\n-        if (prePushHash.isPresent()) {\n-            IntegrateCommand.markIntegratedAndMerged(bot, scratchPath, pr, prePushHash.get(), reply);\n-            return;\n+        \/\/ final Optional<Hash> prePushHash = IntegrateCommand.checkForPrePushHash(bot, pr, scratchPath, allComments, \"sponsor\");\n+\n+        if (pr.state() == PullRequest.State.RESOLVED) {\n+            IntegrateCommand.markIntegratedAndMerge(pr, reply);\n@@ -97,0 +95,2 @@\n+            final boolean integrationBranchExists = pr.repository().branchHash(\"integration\/\" + pr.id()).isPresent();\n+\n@@ -100,19 +100,6 @@\n-            Repository localRepo = new HostedRepositoryPool(bot.seedStorage().orElse(scratchPath.resolve(\"seeds\")))\n-                    .materialize(pr.repository(), scratchPath.resolve(pr.targetRef() + \"\/\" + pr.headHash().hex()));\n-            localRepo.fetch(pr.repository().url(), \"+\" + pr.targetRef() + \":\" + pr.targetRef() + pr.headHash().hex(), true);\n-            localRepo.checkout(new Branch(pr.targetRef() + pr.headHash().hex()), false);\n-\n-            \/\/ See markIntegratedAndMerged for the logic for rogue mark as merged handling\n-            final List<Commit> commits = localRepo.commits(2).asList();\n-            commits.forEach(commit -> log.fine(commit.toString()));\n-            final Commit currentMarkAsMergedCommit =\n-                    IntegrateCommand.isMarkAsMergeCommit(commits.get(0)) ? commits.get(0) : null;\n-            final Commit lastMarkAsMergedCommit =\n-                    (commits.size() == 2 ? (IntegrateCommand.isMarkAsMergeCommit(commits.get(1)) ? commits.get(1) : null) : null);\n-\n-            if (lastMarkAsMergedCommit != null) {\n-                localRepo.reset(lastMarkAsMergedCommit.parents().get(0), true);\n-                localRepo.push(lastMarkAsMergedCommit.parents().get(0), pr.repository().url(), pr.targetRef(), true);\n-            } else if (currentMarkAsMergedCommit != null) {\n-                localRepo.reset(currentMarkAsMergedCommit.parents().get(0), true);\n-                localRepo.push(currentMarkAsMergedCommit.parents().get(0), pr.repository().url(), pr.targetRef(), true);\n+            Repository localRepo = IntegrateCommand.materializeLocalRepo(bot, pr, scratchPath, \"sponsor\");\n+\n+            if (integrationBranchExists) {\n+                final Hash last = localRepo.fetch(pr.repository().url(), \"+integration\/\" + pr.id() + \":integration\/\" + pr.id(), true);\n+                localRepo.push(last, pr.sourceRepository().orElseThrow().url(), pr.sourceRef(), true);\n+                pr = pr.repository().pullRequest(pr.id());\n@@ -121,1 +108,0 @@\n-            localRepo = IntegrateCommand.materializeLocalRepo(bot, pr, scratchPath, \"sponsor\");\n@@ -142,0 +128,3 @@\n+                if (integrationBranchExists) {\n+                    pr.repository().deleteBranch(\"integration\/\" + pr.id());\n+                }\n@@ -156,0 +145,1 @@\n+                localRepo.push(amendedHash, pr.repository().url(), \"integration\/\" + pr.id(), true);\n@@ -157,2 +147,2 @@\n-                localRepo.push(amendedHash, pr.repository().url(), pr.targetRef());\n-                IntegrateCommand.markIntegratedAndMerged(bot, scratchPath, pr, amendedHash, reply);\n+                localRepo.push(amendedHash, pr.sourceRepository().orElseThrow().url(), pr.sourceRef(), true);\n+                IntegrateCommand.markIntegratedAndMerge(pr, reply);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":18,"deletions":28,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -534,1 +534,1 @@\n-                           .filter(comment -> comment.body().contains(\"Going to push as commit\"))\n+                           .filter(comment -> comment.body().contains(\"Recording snapshot of final changes as commit\"))\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-                    .filter(comment -> comment.body().contains(\"Going to push as commit\"))\n+                    .filter(comment -> comment.body().contains(\"Recording snapshot of final changes as commit\"))\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-            * SKARA-1663: Implement State.RESOLVED as a squash merge, until GitHub\n+            * SKARA-1663: Implement State.RESOLVED as a rebase for GitHub, until GitHub\n@@ -425,1 +425,1 @@\n-                   .body(\"merge_method\", \"squash\")\n+                   .body(\"merge_method\", \"rebase\")\n@@ -802,1 +802,6 @@\n-        return findIntegratedCommitHash(List.of(repository.forge().currentUser().id()));\n+        if (this.state() == State.RESOLVED) {\n+            return Optional.of(new Hash(json.get(\"merge_commit_sha\").asString()));\n+        } else {\n+            \/\/ Backwards Compatibility for older Pull Requests\n+            return findIntegratedCommitHash(List.of(repository.forge().currentUser().id()));\n+        }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubPullRequest.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -448,2 +448,1 @@\n-             *\n-             * SKARA-1663: Implement State.RESOLVED as a squash merge, until GitLab\n+             * SKARA-1663: Implement State.RESOLVED as a fast forward merge, until GitLab\n@@ -455,1 +454,1 @@\n-             * (In order of merge methods: Rebase, Merge, and Squash)\n+             * (In order of merge methods: Merge, and Squash)\n@@ -457,1 +456,0 @@\n-             * request.put(\"rebase\").execute();\n@@ -459,1 +457,1 @@\n-             * request.put(\"merge\").body(JSON.object().put(\"squash\", true)).execute();\n+             * request.put(\"merge\").body(JSON.object().put(\"squash\", true)).execute();\\\n@@ -461,0 +459,2 @@\n+             * Merge Requests can be rebased in GitLab via:\n+             * request.put(\"rebase\").execute();\n@@ -463,3 +463,3 @@\n-            request.put(\"merge\")\n-                   .body(JSON.object().put(\"squash\", true))\n-                   .execute();\n+            \/\/ TODO Set repository merge setting to fast forward\n+            request.put(\"merge\").body(JSON.object().put(\"squash\", false)).execute();\n+            \/\/ TODO Maybe reset repository merge setting to original\n@@ -882,1 +882,7 @@\n-        return findIntegratedCommitHash(List.of(repository.forge().currentUser().id()));\n+        final JSONValue result = json.get(\"merge_commit_sha\");\n+        if (result.isNull()) {\n+            \/\/ Backwards Compatibility for older Pull Requests\n+            return findIntegratedCommitHash(List.of(repository.forge().currentUser().id()));\n+        } else {\n+            return Optional.of(new Hash(result.asString()));\n+        }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabMergeRequest.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"}]}