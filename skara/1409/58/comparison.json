{"files":[{"patch":"@@ -80,1 +80,1 @@\n-        if (pr.state() == Issue.State.CLOSED) {\n+        if (pr.state() != Issue.State.OPEN) {\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/prbranch\/PullRequestBranchNotifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,5 @@\n-import org.openjdk.skara.forge.*;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+\n@@ -30,1 +34,0 @@\n-import java.io.*;\n@@ -33,1 +36,4 @@\n-import java.util.*;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n@@ -35,1 +41,0 @@\n-import java.util.stream.Collectors;\n@@ -37,1 +42,0 @@\n-import java.util.regex.Pattern;\n@@ -39,0 +43,9 @@\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.openjdk.skara.forge.Check;\n+import org.openjdk.skara.forge.CheckStatus;\n+import org.openjdk.skara.forge.CommitFailure;\n+import org.openjdk.skara.forge.HostedRepositoryPool;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.forge.PullRequestUtils;\n@@ -163,4 +176,4 @@\n-        Optional<Hash> prepushHash = checkForPrePushHash(bot, pr, scratchPath, allComments, \"integrate\");\n-        if (prepushHash.isPresent()) {\n-            markIntegratedAndClosed(pr, prepushHash.get(), reply);\n-            return;\n+        \/\/ final Optional<Hash> prepushHash = checkForPrePushHash(bot, pr, scratchPath, allComments, \"integrate\");\n+\n+        if (pr.state() == PullRequest.State.RESOLVED) {\n+            markIntegratedAndMerge(pr, reply);\n@@ -190,0 +203,2 @@\n+            final boolean integrationBranchExists = pr.repository().branchHash(\"integration\/\" + pr.id()).isPresent();\n+\n@@ -194,0 +209,7 @@\n+\n+            if (integrationBranchExists) {\n+                final Hash last = localRepo.fetch(pr.repository().url(), \"+integration\/\" + pr.id() + \":integration\/\" + pr.id(), true);\n+                localRepo.push(last, pr.sourceRepository().orElseThrow().url(), pr.sourceRef(), true);\n+                pr = pr.repository().pullRequest(pr.id());\n+            }\n+\n@@ -210,0 +232,3 @@\n+                if (integrationBranchExists) {\n+                    pr.repository().deleteBranch(\"integration\/\" + pr.id());\n+                }\n@@ -242,0 +267,1 @@\n+                localRepo.push(amendedHash, pr.repository().url(), \"integration\/\" + pr.id(), true);\n@@ -243,2 +269,3 @@\n-                localRepo.push(amendedHash, pr.repository().url(), pr.targetRef());\n-                markIntegratedAndClosed(pr, amendedHash, reply);\n+                \/\/ Force the Pull Request branch to accept edits from maintainers somehow?\n+                localRepo.push(amendedHash, pr.sourceRepository().orElseThrow().url(), pr.sourceRef(), true);\n+                markIntegratedAndMerge(pr, reply);\n@@ -321,1 +348,2 @@\n-        writer.println(\"Going to push as commit \" + hash.hex() + \".\");\n+        writer.println(\"Recording snapshot of final changes as commit \" + hash.hex() + \".\");\n+        writer.println(\"New changes can no longer be made past this point, except for if an automatic rebase fails.\");\n@@ -328,1 +356,1 @@\n-    static void markIntegratedAndClosed(PullRequest pr, Hash hash, PrintWriter reply) {\n+    static void markIntegratedAndMerge(PullRequest pr,PrintWriter reply) {\n@@ -332,1 +360,3 @@\n-        pr.setState(PullRequest.State.CLOSED);\n+        if (pr.state() != PullRequest.State.RESOLVED) {\n+            pr.setState(PullRequest.State.RESOLVED);\n+        }\n@@ -341,1 +371,1 @@\n-        reply.println(PullRequest.commitHashMessage(hash));\n+        reply.println(PullRequest.commitHashMessage(pr.findIntegratedCommitHash().get()));\n@@ -343,1 +373,2 @@\n-        reply.println(\":bulb: You may see a message that your pull request was closed with unmerged commits. This can be safely ignored.\");\n+        reply.println(\":bulb: You may see a message that branches were created around your pull request. This can be safely ignored.\");\n+        pr.repository().deleteBranch(\"integration\/\" + pr.id());\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":47,"deletions":16,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import org.openjdk.skara.vcs.Repository;\n@@ -50,4 +51,4 @@\n-        Optional<Hash> prePushHash = IntegrateCommand.checkForPrePushHash(bot, pr, scratchPath, allComments, \"sponsor\");\n-        if (prePushHash.isPresent()) {\n-            markIntegratedAndClosed(pr, prePushHash.get(), reply);\n-            return;\n+        \/\/ final Optional<Hash> prePushHash = IntegrateCommand.checkForPrePushHash(bot, pr, scratchPath, allComments, \"sponsor\");\n+\n+        if (pr.state() == PullRequest.State.RESOLVED) {\n+            IntegrateCommand.markIntegratedAndMerge(pr, reply);\n@@ -94,0 +95,2 @@\n+            final boolean integrationBranchExists = pr.repository().branchHash(\"integration\/\" + pr.id()).isPresent();\n+\n@@ -97,1 +100,8 @@\n-            var localRepo = IntegrateCommand.materializeLocalRepo(bot, pr, scratchPath, \"sponsor\");\n+            Repository localRepo = IntegrateCommand.materializeLocalRepo(bot, pr, scratchPath, \"sponsor\");\n+\n+            if (integrationBranchExists) {\n+                final Hash last = localRepo.fetch(pr.repository().url(), \"+integration\/\" + pr.id() + \":integration\/\" + pr.id(), true);\n+                localRepo.push(last, pr.sourceRepository().orElseThrow().url(), pr.sourceRef(), true);\n+                pr = pr.repository().pullRequest(pr.id());\n+            }\n+\n@@ -118,0 +128,3 @@\n+                if (integrationBranchExists) {\n+                    pr.repository().deleteBranch(\"integration\/\" + pr.id());\n+                }\n@@ -132,0 +145,1 @@\n+                localRepo.push(amendedHash, pr.repository().url(), \"integration\/\" + pr.id(), true);\n@@ -133,2 +147,2 @@\n-                localRepo.push(amendedHash, pr.repository().url(), pr.targetRef());\n-                markIntegratedAndClosed(pr, amendedHash, reply);\n+                localRepo.push(amendedHash, pr.sourceRepository().orElseThrow().url(), pr.sourceRef(), true);\n+                IntegrateCommand.markIntegratedAndMerge(pr, reply);\n@@ -147,4 +161,0 @@\n-    private void markIntegratedAndClosed(PullRequest pr, Hash amendedHash, PrintWriter reply) {\n-        IntegrateCommand.markIntegratedAndClosed(pr, amendedHash, reply);\n-    }\n-\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -534,1 +534,1 @@\n-                           .filter(comment -> comment.body().contains(\"Going to push as commit\"))\n+                           .filter(comment -> comment.body().contains(\"Recording snapshot of final changes as commit\"))\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-                    .filter(comment -> comment.body().contains(\"Going to push as commit\"))\n+                    .filter(comment -> comment.body().contains(\"Recording snapshot of final changes as commit\"))\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        var reviews = request.get(\"pulls\/\" + json.get(\"number\").toString() + \"\/reviews\").execute().stream()\n+        var reviews = request.get(\"pulls\/\" + this.id() + \"\/reviews\").execute().stream()\n@@ -175,1 +175,1 @@\n-        request.post(\"pulls\/\" + json.get(\"number\").toString() + \"\/reviews\")\n+        request.post(\"pulls\/\" + this.id() + \"\/reviews\")\n@@ -182,1 +182,1 @@\n-        request.put(\"pulls\/\" + json.get(\"number\").toString() + \"\/reviews\/\" + id)\n+        request.put(\"pulls\/\" + this.id() + \"\/reviews\/\" + id)\n@@ -243,1 +243,1 @@\n-        var response = request.post(\"pulls\/\" + json.get(\"number\").toString() + \"\/comments\")\n+        var response = request.post(\"pulls\/\" + this.id() + \"\/comments\")\n@@ -254,1 +254,1 @@\n-        var response = request.post(\"pulls\/\" + json.get(\"number\").toString() + \"\/comments\")\n+        var response = request.post(\"pulls\/\" + this.id() + \"\/comments\")\n@@ -263,1 +263,1 @@\n-        var reviewComments = request.get(\"pulls\/\" + json.get(\"number\").toString() + \"\/comments\").execute().stream()\n+        var reviewComments = request.get(\"pulls\/\" + this.id() + \"\/comments\").execute().stream()\n@@ -317,1 +317,1 @@\n-        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n+        request.patch(\"pulls\/\" + this.id())\n@@ -333,1 +333,1 @@\n-        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n+        request.patch(\"pulls\/\" + this.id())\n@@ -349,1 +349,1 @@\n-        return request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/comments\").execute().stream()\n+        return request.get(\"issues\/\" + this.id() + \"\/comments\").execute().stream()\n@@ -357,1 +357,1 @@\n-        var comment = request.post(\"issues\/\" + json.get(\"number\").toString() + \"\/comments\")\n+        var comment = request.post(\"issues\/\" + this.id() + \"\/comments\")\n@@ -401,2 +401,29 @@\n-        if (json.get(\"state\").asString().equals(\"open\")) {\n-            return State.OPEN;\n+        return json.get(\"state\").asString().equals(\"open\") ? State.OPEN :\n+              (json.get(\"merged_at\").isNull() ? State.CLOSED : State.RESOLVED);\n+    }\n+\n+    @Override\n+    public void setState(State state) {\n+        if (state == State.RESOLVED) {\n+\n+           \/*\n+            *\n+            * SKARA-1663: Implement State.RESOLVED as a rebase for GitHub, until GitHub\n+            * allows for marking a Pull Request as merged in the future.\n+            *\n+            * If a method for actual merging is required, the following implementation\n+            * will suffice for the different types of merges GitHub allows for:\n+            *\n+            * request.put(\"pulls\/\" + this.id() + \"\/merge\").body(\"merge_method\", \"merge\")\n+            *        .execute();\n+            *\n+            * Where \"merge_method\" can be set to one of: \"rebase\", \"squash\", or \"merge\"\n+            *\/\n+\n+            request.put(\"pulls\/\" + this.id() + \"\/merge\")\n+                   .body(\"merge_method\", \"rebase\")\n+                   .execute();\n+        } else {\n+            request.patch(\"pulls\/\" + this.id())\n+                   .body(\"state\", state == State.OPEN ? \"open\" : \"closed\")\n+                   .execute();\n@@ -404,1 +431,0 @@\n-        return State.CLOSED;\n@@ -530,7 +556,0 @@\n-    @Override\n-    public void setState(State state) {\n-        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n-               .body(\"state\", state != State.OPEN ? \"closed\" : \"open\")\n-               .execute();\n-    }\n-\n@@ -541,1 +560,1 @@\n-        request.post(\"issues\/\" + json.get(\"number\").toString() + \"\/labels\")\n+        request.post(\"issues\/\" + this.id() + \"\/labels\")\n@@ -549,1 +568,1 @@\n-        request.delete(\"issues\/\" + json.get(\"number\").toString() + \"\/labels\/\" + label)\n+        request.delete(\"issues\/\" + this.id() + \"\/labels\/\" + label)\n@@ -567,1 +586,1 @@\n-        var newLabels = request.put(\"issues\/\" + json.get(\"number\").toString() + \"\/labels\")\n+        var newLabels = request.put(\"issues\/\" + this.id() + \"\/labels\")\n@@ -579,1 +598,1 @@\n-            labels = request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/labels\").execute().stream()\n+            labels = request.get(\"issues\/\" + this.id() + \"\/labels\").execute().stream()\n@@ -624,1 +643,1 @@\n-        request.patch(\"issues\/\" + json.get(\"number\").toString()).body(param).execute();\n+        request.patch(\"issues\/\" + this.id()).body(param).execute();\n@@ -711,1 +730,1 @@\n-        return request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/timeline\")\n+        return request.get(\"issues\/\" + this.id() + \"\/timeline\")\n@@ -724,1 +743,1 @@\n-        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n+        request.patch(\"pulls\/\" + this.id())\n@@ -737,1 +756,1 @@\n-        var files = request.get(\"pulls\/\" + json.get(\"number\").toString() + \"\/files\")\n+        var files = request.get(\"pulls\/\" + this.id() + \"\/files\")\n@@ -750,1 +769,1 @@\n-        return request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/timeline\")\n+        return request.get(\"issues\/\" + this.id() + \"\/timeline\")\n@@ -768,1 +787,1 @@\n-        var timelineJSON = request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/timeline\")\n+        var timelineJSON = request.get(\"issues\/\" + this.id() + \"\/timeline\")\n@@ -782,1 +801,6 @@\n-        return findIntegratedCommitHash(List.of(repository.forge().currentUser().id()));\n+        if (this.state() == State.RESOLVED) {\n+            return Optional.of(new Hash(json.get(\"merge_commit_sha\").asString()));\n+        } else {\n+            \/\/ Backwards Compatibility for older Pull Requests\n+            return findIntegratedCommitHash(List.of(repository.forge().currentUser().id()));\n+        }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubPullRequest.java","additions":55,"deletions":31,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -346,2 +346,1 @@\n-        var targetRef = json.get(\"target_branch\").asString();\n-        return targetRef;\n+        return json.get(\"target_branch\").asString();\n@@ -439,2 +438,32 @@\n-        if (json.get(\"state\").asString().equals(\"opened\")) {\n-            return State.OPEN;\n+        final String state = json.get(\"state\").asString();\n+        return state.equals(\"opened\") ? State.OPEN :\n+              (state.equals(\"merged\") ? State.RESOLVED : State.CLOSED);\n+    }\n+\n+    @Override\n+    public void setState(State state) {\n+        if (state == State.RESOLVED) {\n+\n+            \/*\n+             * SKARA-1663: Implement State.RESOLVED as a fast forward merge, until GitLab\n+             * allows for marking a Pull Request as merged in the future.\n+             *\n+             * If a method for actual merging is required, the following implementations\n+             * will suffice for the different types of merges GitLab allows for:\n+             *\n+             * (In order of merge methods: Merge, and Squash)\n+             *\n+             * request.put(\"merge\").body(JSON.object().put(\"squash\", false)).execute();\n+             * request.put(\"merge\").body(JSON.object().put(\"squash\", true)).execute();\\\n+             *\n+             * Merge Requests can be rebased in GitLab via:\n+             * request.put(\"rebase\").execute();\n+             *\/\n+\n+            \/\/ TODO Set repository merge setting to fast forward\n+            request.put(\"merge\").body(JSON.object().put(\"squash\", false)).execute();\n+            \/\/ TODO Maybe reset repository merge setting to original\n+        } else {\n+            request.put(\"\")\n+                   .body(\"state_event\", state == State.OPEN ? \"reopen\" : \"close\")\n+                   .execute();\n@@ -442,1 +471,0 @@\n-        return State.CLOSED;\n@@ -641,7 +669,0 @@\n-    @Override\n-    public void setState(State state) {\n-        request.put(\"\")\n-               .body(\"state_event\", state != State.OPEN ? \"close\" : \"reopen\")\n-               .execute();\n-    }\n-\n@@ -861,1 +882,7 @@\n-        return findIntegratedCommitHash(List.of(repository.forge().currentUser().id()));\n+        final JSONValue result = json.get(\"merge_commit_sha\");\n+        if (result.isNull()) {\n+            \/\/ Backwards Compatibility for older Pull Requests\n+            return findIntegratedCommitHash(List.of(repository.forge().currentUser().id()));\n+        } else {\n+            return Optional.of(new Hash(result.asString()));\n+        }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabMergeRequest.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-        try (var p = capture(\"git\", \"checkout\", \"--recurse-submodules\", h.hex(), \"--\", \".\")) {\n+        try (var p = capture(\"git\", \"restore\", \"--recurse-submodules\", \"--source\", h.hex(), \"--\", \".\")) {\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/git\/GitRepository.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}