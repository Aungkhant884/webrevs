{"files":[{"patch":"@@ -80,1 +80,1 @@\n-        if (pr.state() == Issue.State.CLOSED) {\n+        if (pr.state() != Issue.State.OPEN) {\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/prbranch\/PullRequestBranchNotifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import org.openjdk.skara.vcs.Branch;\n+import org.openjdk.skara.vcs.Commit;\n@@ -165,1 +167,1 @@\n-            markIntegratedAndClosed(pr, prepushHash.get(), reply);\n+            markIntegratedAndMerged(bot, scratchPath, pr, prepushHash.get(), reply);\n@@ -244,1 +246,1 @@\n-                markIntegratedAndClosed(pr, amendedHash, reply);\n+                markIntegratedAndMerged(bot, scratchPath, pr, amendedHash, reply);\n@@ -328,1 +330,1 @@\n-    static void markIntegratedAndClosed(PullRequest pr, Hash hash, PrintWriter reply) {\n+    static void markIntegratedAndMerged(PullRequestBot bot, Path scratchPath, PullRequest pr, Hash hash, PrintWriter reply) {\n@@ -331,0 +333,15 @@\n+        Repository repository;\n+        try {\n+            repository = new HostedRepositoryPool(bot.seedStorage().orElse(scratchPath.resolve(\"seeds\")))\n+                      .materialize(pr.repository(), scratchPath.resolve(hash.hex()));\n+            repository.fetch(pr.repository().url(), pr.targetRef(), true);\n+            repository.checkout(new Branch(pr.targetRef()), false);\n+            final List<Commit> commits = repository.commits(hash.hex(), 2).asList();\n+            commits.forEach(commit -> log.fine(commit.toString()));\n+            \/\/ There is always at least one prior commit before the integrated one\n+            repository.revert(commits.get(1).hash());\n+            final Hash resetHash = repository.commit(\"Post Integration Merging of \" + hash.hex(), \"duke\", \"duke@openjdk.org\");\n+            repository.push(resetHash, pr.repository().url(), pr.targetRef(), false);\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n@@ -332,1 +349,1 @@\n-        pr.setState(PullRequest.State.CLOSED);\n+        pr.setState(PullRequest.State.RESOLVED);\n@@ -344,0 +361,6 @@\n+        try {\n+            repository.reset(hash, true);\n+            repository.push(hash, pr.repository().url(), pr.targetRef(), true);\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            markIntegratedAndClosed(pr, prePushHash.get(), reply);\n+            IntegrateCommand.markIntegratedAndMerged(bot, scratchPath, pr, prePushHash.get(), reply);\n@@ -134,1 +134,1 @@\n-                markIntegratedAndClosed(pr, amendedHash, reply);\n+                IntegrateCommand.markIntegratedAndMerged(bot, scratchPath, pr, amendedHash, reply);\n@@ -147,4 +147,0 @@\n-    private void markIntegratedAndClosed(PullRequest pr, Hash amendedHash, PrintWriter reply) {\n-        IntegrateCommand.markIntegratedAndClosed(pr, amendedHash, reply);\n-    }\n-\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        var reviews = request.get(\"pulls\/\" + json.get(\"number\").toString() + \"\/reviews\").execute().stream()\n+        var reviews = request.get(\"pulls\/\" + this.id() + \"\/reviews\").execute().stream()\n@@ -175,1 +175,1 @@\n-        request.post(\"pulls\/\" + json.get(\"number\").toString() + \"\/reviews\")\n+        request.post(\"pulls\/\" + this.id() + \"\/reviews\")\n@@ -182,1 +182,1 @@\n-        request.put(\"pulls\/\" + json.get(\"number\").toString() + \"\/reviews\/\" + id)\n+        request.put(\"pulls\/\" + this.id() + \"\/reviews\/\" + id)\n@@ -243,1 +243,1 @@\n-        var response = request.post(\"pulls\/\" + json.get(\"number\").toString() + \"\/comments\")\n+        var response = request.post(\"pulls\/\" + this.id() + \"\/comments\")\n@@ -254,1 +254,1 @@\n-        var response = request.post(\"pulls\/\" + json.get(\"number\").toString() + \"\/comments\")\n+        var response = request.post(\"pulls\/\" + this.id() + \"\/comments\")\n@@ -263,1 +263,1 @@\n-        var reviewComments = request.get(\"pulls\/\" + json.get(\"number\").toString() + \"\/comments\").execute().stream()\n+        var reviewComments = request.get(\"pulls\/\" + this.id() + \"\/comments\").execute().stream()\n@@ -317,1 +317,1 @@\n-        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n+        request.patch(\"pulls\/\" + this.id())\n@@ -333,1 +333,1 @@\n-        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n+        request.patch(\"pulls\/\" + this.id())\n@@ -349,1 +349,1 @@\n-        return request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/comments\").execute().stream()\n+        return request.get(\"issues\/\" + this.id() + \"\/comments\").execute().stream()\n@@ -357,1 +357,1 @@\n-        var comment = request.post(\"issues\/\" + json.get(\"number\").toString() + \"\/comments\")\n+        var comment = request.post(\"issues\/\" + this.id() + \"\/comments\")\n@@ -401,2 +401,30 @@\n-        if (json.get(\"state\").asString().equals(\"open\")) {\n-            return State.OPEN;\n+        return json.get(\"state\").asString().equals(\"open\") ? State.OPEN :\n+              (json.get(\"merged_at\").isNull() ? State.CLOSED : State.RESOLVED);\n+    }\n+\n+    @Override\n+    public void setState(State state) {\n+        if (state == State.RESOLVED) {\n+\n+           \/*\n+            *\n+            * SKARA-1663: Implement State.RESOLVED as a squash merge, until GitHub\n+            * allows for marking a Pull Request as merged in the future.\n+            *\n+            * If a method for actual merging is required, the following implementation\n+            * will suffice for the different types of merges GitHub allows for:\n+            *\n+            * request.put(\"pulls\/\" + this.id() + \"\/merge\").body(\"merge_method\", \"merge\")\n+            *        .execute();\n+            *\n+            * Where \"merge_method\" can be set to one of: \"rebase\", \"squash\", or \"merge\"\n+            *\n+            *\/\n+\n+            request.put(\"pulls\/\" + this.id() + \"\/merge\")\n+                   .body(\"merge_method\", \"squash\")\n+                   .execute();\n+        } else {\n+            request.patch(\"pulls\/\" + this.id())\n+                   .body(\"state\", state == State.OPEN ? \"open\" : \"closed\")\n+                   .execute();\n@@ -404,1 +432,0 @@\n-        return State.CLOSED;\n@@ -530,7 +557,0 @@\n-    @Override\n-    public void setState(State state) {\n-        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n-               .body(\"state\", state != State.OPEN ? \"closed\" : \"open\")\n-               .execute();\n-    }\n-\n@@ -541,1 +561,1 @@\n-        request.post(\"issues\/\" + json.get(\"number\").toString() + \"\/labels\")\n+        request.post(\"issues\/\" + this.id() + \"\/labels\")\n@@ -549,1 +569,1 @@\n-        request.delete(\"issues\/\" + json.get(\"number\").toString() + \"\/labels\/\" + label)\n+        request.delete(\"issues\/\" + this.id() + \"\/labels\/\" + label)\n@@ -567,1 +587,1 @@\n-        var newLabels = request.put(\"issues\/\" + json.get(\"number\").toString() + \"\/labels\")\n+        var newLabels = request.put(\"issues\/\" + this.id() + \"\/labels\")\n@@ -579,1 +599,1 @@\n-            labels = request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/labels\").execute().stream()\n+            labels = request.get(\"issues\/\" + this.id() + \"\/labels\").execute().stream()\n@@ -624,1 +644,1 @@\n-        request.patch(\"issues\/\" + json.get(\"number\").toString()).body(param).execute();\n+        request.patch(\"issues\/\" + this.id()).body(param).execute();\n@@ -711,1 +731,1 @@\n-        return request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/timeline\")\n+        return request.get(\"issues\/\" + this.id() + \"\/timeline\")\n@@ -724,1 +744,1 @@\n-        request.patch(\"pulls\/\" + json.get(\"number\").toString())\n+        request.patch(\"pulls\/\" + this.id())\n@@ -737,1 +757,1 @@\n-        var files = request.get(\"pulls\/\" + json.get(\"number\").toString() + \"\/files\")\n+        var files = request.get(\"pulls\/\" + this.id() + \"\/files\")\n@@ -750,1 +770,1 @@\n-        return request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/timeline\")\n+        return request.get(\"issues\/\" + this.id() + \"\/timeline\")\n@@ -768,1 +788,1 @@\n-        var timelineJSON = request.get(\"issues\/\" + json.get(\"number\").toString() + \"\/timeline\")\n+        var timelineJSON = request.get(\"issues\/\" + this.id() + \"\/timeline\")\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubPullRequest.java","additions":50,"deletions":30,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -346,2 +346,1 @@\n-        var targetRef = json.get(\"target_branch\").asString();\n-        return targetRef;\n+        return json.get(\"target_branch\").asString();\n@@ -439,2 +438,32 @@\n-        if (json.get(\"state\").asString().equals(\"opened\")) {\n-            return State.OPEN;\n+        final String state = json.get(\"state\").asString();\n+        return state.equals(\"opened\") ? State.OPEN :\n+              (state.equals(\"merged\") ? State.RESOLVED : State.CLOSED);\n+    }\n+\n+    @Override\n+    public void setState(State state) {\n+        if (state == State.RESOLVED) {\n+\n+            \/*\n+             *\n+             * SKARA-1663: Implement State.RESOLVED as a squash merge, until GitLab\n+             * allows for marking a Pull Request as merged in the future.\n+             *\n+             * If a method for actual merging is required, the following implementations\n+             * will suffice for the different types of merges GitLab allows for:\n+             *\n+             * (In order of merge methods: Rebase, Merge, and Squash)\n+             *\n+             * request.put(\"rebase\").execute();\n+             * request.put(\"merge\").body(JSON.object().put(\"squash\", false)).execute();\n+             * request.put(\"merge\").body(JSON.object().put(\"squash\", true)).execute();\n+             *\n+             *\/\n+\n+            request.put(\"merge\")\n+                   .body(JSON.object().put(\"squash\", true))\n+                   .execute();\n+        } else {\n+            request.put(\"\")\n+                   .body(\"state_event\", state == State.OPEN ? \"reopen\" : \"close\")\n+                   .execute();\n@@ -442,1 +471,0 @@\n-        return State.CLOSED;\n@@ -641,7 +669,0 @@\n-    @Override\n-    public void setState(State state) {\n-        request.put(\"\")\n-               .body(\"state_event\", state != State.OPEN ? \"close\" : \"reopen\")\n-               .execute();\n-    }\n-\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabMergeRequest.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-        try (var p = capture(\"git\", \"checkout\", \"--recurse-submodules\", h.hex(), \"--\", \".\")) {\n+        try (var p = capture(\"git\", \"restore\", \"--recurse-submodules\", \"--source\", h.hex(), \"--\", \".\")) {\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/git\/GitRepository.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}