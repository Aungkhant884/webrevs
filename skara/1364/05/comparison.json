{"files":[{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bot;\n+\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.openjdk.skara.forge.HostedRepository;\n+\n+public record ApprovalInfo(HostedRepository repo, Pattern branchPattern,\n+                           String requestLabel, String approvalLabel,\n+                           String disapprovalLabel, Set<String> maintainers) {\n+}\n","filename":"bot\/src\/main\/java\/org\/openjdk\/skara\/bot\/ApprovalInfo.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module {\n+    name = \"org.openjdk.skara.bots.approval\"\n+    test {\n+        requires 'org.junit.jupiter.api'\n+        requires 'org.openjdk.skara.test'\n+        opens 'org.openjdk.skara.bots.approval' to 'org.junit.platform.commons'\n+    }\n+}\n+\n+dependencies {\n+    implementation project(':host')\n+    implementation project(':bot')\n+    implementation project(':forge')\n+    implementation project(':issuetracker')\n+    implementation project(':census')\n+    implementation project(':ci')\n+    implementation project(':json')\n+    implementation project(':vcs')\n+    implementation project(':metrics')\n+    implementation project(':jcheck')\n+    implementation project(':jbs')\n+\n+    testImplementation project(':test')\n+}\n","filename":"bots\/approval\/build.gradle","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module org.openjdk.skara.bots.approval {\n+    requires org.openjdk.skara.bot;\n+    requires org.openjdk.skara.vcs;\n+    requires org.openjdk.skara.forge;\n+    requires org.openjdk.skara.issuetracker;\n+    requires org.openjdk.skara.jcheck;\n+    requires org.openjdk.skara.jbs;\n+    requires java.logging;\n+\n+    provides org.openjdk.skara.bot.BotFactory with org.openjdk.skara.bots.approval.ApprovalBotFactory;\n+}\n+\n","filename":"bots\/approval\/src\/main\/java\/module-info.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.bot.Bot;\n+import org.openjdk.skara.bot.WorkItem;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.forge.PullRequestUtils;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+import org.openjdk.skara.issuetracker.IssuePoller;\n+\n+public class ApprovalBot implements Bot {\n+    private final List<ApprovalInfo> approvalInfos;\n+    private final IssueProject issueProject;\n+    private final List<HostedRepository> repositories;\n+    private final IssuePoller poller;\n+\n+    public ApprovalBot(IssueProject issueProject, List<HostedRepository> repositories, List<ApprovalInfo> approvalInfos) {\n+        this.approvalInfos = approvalInfos;\n+        this.issueProject = issueProject;\n+        this.repositories = repositories;\n+        \/\/ When restarting the bot, the bot only polls the issues in one week,\n+        \/\/ because the bot should not be down more than one week.\n+        this.poller = new IssuePoller(issueProject, Duration.ofDays(7));\n+    }\n+\n+    @Override\n+    public List<WorkItem> getPeriodicItems() {\n+        var items = new ArrayList<WorkItem>();\n+        for (var issue : poller.updatedIssues()) {\n+            var itemsPerIssue = PullRequestUtils.pullRequestCommentLink(issue).stream()\n+                    .flatMap(uri -> repositories.stream().flatMap(r -> r.parsePullRequestUrl(uri.toString()).stream()))\n+                    .filter(pr -> pr.isOpen() && requiresApproval(pr))\n+                    .map(pr -> new ApprovalWorkItem(pr.repository(), pr.id(), issue.project(),\n+                            approvalInfos.stream().filter(info -> approvalInfoMatch(info, pr)).findFirst().get()))\n+                    .collect(Collectors.toList());\n+            items.addAll(itemsPerIssue);\n+        }\n+        poller.lastBatchHandled();\n+        return items;\n+    }\n+\n+    private boolean requiresApproval(PullRequest pr) {\n+        return approvalInfos != null &&\n+                approvalInfos.stream().anyMatch(info -> approvalInfoMatch(info, pr));\n+    }\n+\n+    private boolean approvalInfoMatch(ApprovalInfo info, PullRequest pr) {\n+        return info.repo().isSame(pr.repository()) &&\n+                info.branchPattern().matcher(pr.targetRef()).matches();\n+    }\n+\n+    @Override\n+    public String name() {\n+        return ApprovalBotFactory.NAME;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ApprovalBot@\" + issueProject.name();\n+    }\n+}\n","filename":"bots\/approval\/src\/main\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalBot.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.bot.Bot;\n+import org.openjdk.skara.bot.BotConfiguration;\n+import org.openjdk.skara.bot.BotFactory;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+\n+public class ApprovalBotFactory implements BotFactory {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.approval\");\n+    static final String NAME = \"approval\";\n+\n+    @Override\n+    public String name() {\n+        return NAME;\n+    }\n+\n+    @Override\n+    public List<Bot> create(BotConfiguration configuration) {\n+        var botList = new ArrayList<Bot>();\n+        var specific = configuration.specific();\n+        var issueProjects = new HashSet<IssueProject>();\n+        var repositories = new HashMap<IssueProject, List<HostedRepository>>();\n+        var approvalInfoMap = new HashMap<IssueProject, List<ApprovalInfo>>();\n+\n+        for (var project : specific.get(\"projects\").asArray()) {\n+            var repo = configuration.repository(project.get(\"repository\").asString());\n+            var issueProject = configuration.issueProject(project.get(\"issues\").asString());\n+            issueProjects.add(issueProject);\n+            if (!approvalInfoMap.containsKey(issueProject)) {\n+                approvalInfoMap.put(issueProject, new ArrayList<>());\n+            }\n+            if (!repositories.containsKey(issueProject)) {\n+                repositories.put(issueProject, new ArrayList<>());\n+            }\n+            repositories.get(issueProject).add(repo);\n+\n+            for (var branchInfo : project.get(\"approval\").asArray()) {\n+                var requestLabel = branchInfo.get(\"request-label\").asString();\n+                var approvalLabel = branchInfo.get(\"approval-label\").asString();\n+                var disapprovalLabel = branchInfo.get(\"disapproval-label\").asString();\n+                var maintainers = new HashSet<String>();\n+                if (branchInfo.contains(\"maintainers\")) {\n+                    for (var maintainer : branchInfo.get(\"maintainers\").asArray()) {\n+                        maintainers.add(maintainer.asString());\n+                    }\n+                }\n+                approvalInfoMap.get(issueProject).add(new ApprovalInfo(repo, Pattern.compile(branchInfo.get(\"branch\").asString()),\n+                        requestLabel, approvalLabel, disapprovalLabel, maintainers));\n+            }\n+        }\n+\n+        for (var issueProject : issueProjects) {\n+            log.info(\"Setting up approval issue bot for \" + issueProject.name());\n+            botList.add(new ApprovalBot(issueProject, repositories.get(issueProject), approvalInfoMap.get(issueProject)));\n+        }\n+\n+        return botList;\n+    }\n+}\n","filename":"bots\/approval\/src\/main\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalBotFactory.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.bot.WorkItem;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+import org.openjdk.skara.vcs.openjdk.Issue;\n+\n+public class ApprovalWorkItem implements WorkItem {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.approval\");\n+    \/\/ The tag to re-run the CheckWorkItem of the PRBot.\n+    static final String APPROVAL_UPDATE_MARKER = \"<!-- approval: 'update' -->\";\n+    static final String PROGRESS_MARKER = \"<!-- Anything below this marker will be automatically updated, please do not edit manually! -->\";\n+\n+    private final HostedRepository repo;\n+    private final String prId;\n+    private final IssueProject issueProject;\n+    private final ApprovalInfo approvalInfo;\n+\n+    public ApprovalWorkItem(HostedRepository repo, String prId, IssueProject issueProject, ApprovalInfo approvalInfo) {\n+        this.repo = repo;\n+        this.prId = prId;\n+        this.issueProject = issueProject;\n+        this.approvalInfo = approvalInfo;\n+    }\n+\n+    private String describe(PullRequest pr) {\n+        return pr.repository().name() + \"#\" + pr.id();\n+    }\n+\n+    private String getStatusMessage(PullRequest pr) {\n+        var lastIndex = pr.body().lastIndexOf(PROGRESS_MARKER);\n+        if (lastIndex == -1) {\n+            return \"\";\n+        } else {\n+            return pr.body().substring(lastIndex);\n+        }\n+    }\n+\n+    private void addUpdateMarker(PullRequest pr) {\n+        var statusMessage = getStatusMessage(pr);\n+        if (!statusMessage.contains(APPROVAL_UPDATE_MARKER)) {\n+            pr.setBody(pr.body() + \"\\n\" + APPROVAL_UPDATE_MARKER + \"\\n\");\n+        } else {\n+            log.info(\"The pull request \" + describe(pr) + \" has already had a approval update marker. \"\n+                    + \"Do not need to add it again.\");\n+        }\n+    }\n+\n+    private boolean hasApprovalProgressChecked(PullRequest pr) {\n+        var statusMessage = getStatusMessage(pr);\n+        return statusMessage.contains(\"- [x] All issues must be \"\n+                + \"[approved](https:\/\/openjdk.org\/projects\/jdk-updates\/approval.html) by a maintainer\");\n+    }\n+\n+    private boolean hasApprovalProgress(PullRequest pr) {\n+        var statusMessage = getStatusMessage(pr);\n+        return statusMessage.contains(\"- [ ] All issues must be \"\n+                + \"[approved](https:\/\/openjdk.org\/projects\/jdk-updates\/approval.html) by a maintainer\") ||\n+                statusMessage.contains(\"- [x] All issues must be \"\n+                        + \"[approved](https:\/\/openjdk.org\/projects\/jdk-updates\/approval.html) by a maintainer\");\n+    }\n+\n+    @Override\n+    public Collection<WorkItem> run(Path scratchPath) {\n+        var pr = repo.pullRequest(prId);\n+        var vcsIssue = Issue.fromStringRelaxed(pr.title());\n+        if (vcsIssue.isEmpty()) {\n+            log.info(\"No issue found in title for \" + describe(pr));\n+            return List.of();\n+        }\n+        var issueOpt = vcsIssue.flatMap(value -> issueProject.issue(value.shortId()));\n+        if (issueOpt.isEmpty()) {\n+            log.info(\"No issue found in JBS for \" + describe(pr));\n+            return List.of();\n+        }\n+        var issue = issueOpt.get();\n+\n+        if (!hasApprovalProgress(pr)) {\n+            log.info(\"The PR body of \" + describe(pr) + \" doesn't have the approval progress, adding the approval update marker.\");\n+            addUpdateMarker(pr);\n+        }\n+\n+        if (issue.labelNames().contains(approvalInfo.approvalLabel()) ||\n+                issue.labelNames().contains(approvalInfo.disapprovalLabel())) {\n+            if (!issue.labelNames().contains(approvalInfo.requestLabel())) {\n+                \/\/ The issue has the approval or disapproval label, it should always have a fix request label.\n+                log.info(\"The issue \" + issue.id() + \" has the approval or disapproval label, \"\n+                        + \"adding the missed fix request label for it.\");\n+                issue.addLabel(approvalInfo.requestLabel());\n+            }\n+            if (pr.labelNames().contains(\"approval\")) {\n+                log.info(\"The issue \" + issue.id() + \" has the approval or disapproval label, \"\n+                        + \"removing the `approval` blocked label for \" + describe(pr));\n+                pr.removeLabel(\"approval\");\n+            }\n+            if (issue.labelNames().contains(approvalInfo.approvalLabel()) && !hasApprovalProgressChecked(pr)) {\n+                log.info(\"The issue \" + issue.id() + \" has the approval label and the approval progress of the \"\n+                        + describe(pr) + \" is not checked, adding the approval update marker.\");\n+                addUpdateMarker(pr);\n+            }\n+            if (issue.labelNames().contains(approvalInfo.disapprovalLabel()) && pr.isOpen()) {\n+                log.info(\"The issue \" + issue.id() + \" has the disapproval label and the approval progress of the \"\n+                        + describe(pr) + \" is checked, adding the approval update marker.\");\n+                addUpdateMarker(pr);\n+            }\n+        }\n+        return List.of();\n+    }\n+\n+    @Override\n+    public boolean concurrentWith(WorkItem other) {\n+        if (!(other instanceof ApprovalWorkItem item)) {\n+            return true;\n+        }\n+\n+        return !(repo.isSame(item.repo) && prId.equals(item.prId));\n+    }\n+\n+    @Override\n+    public String botName() {\n+        return ApprovalBotFactory.NAME;\n+    }\n+\n+    @Override\n+    public String workItemName() {\n+        return \"approval\";\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return botName() + \"\/ApprovalWorkItem@\" + repo.name() + \"#\" + prId;\n+    }\n+}\n","filename":"bots\/approval\/src\/main\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalWorkItem.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.openjdk.skara.bots.approval.ApprovalWorkItem.APPROVAL_UPDATE_MARKER;\n+import static org.openjdk.skara.bots.approval.ApprovalWorkItem.PROGRESS_MARKER;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.forge.PullRequestUtils;\n+import org.openjdk.skara.forge.Review;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.CheckableRepository;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+import org.openjdk.skara.test.TestBotRunner;\n+\n+public class ApprovalBotTests {\n+    @Test\n+    void testApproval(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalBot(issueProject, List.of(author),\n+                    List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\" , \"test-fix-yes\" , \"test-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\" , \"master-fix-yes\" , \"master-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\" , \"jdk18-fix-yes\" , \"jdk18-fix-no\" , Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\",\n+                    issue.id() + \": \" + issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            pr.setBody(pr.body() + \"\\n- [ ] All issues must be\");\n+            PullRequestUtils.postPullRequestLinkComment(issue, pr);\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Simulate the PRBot. Add the `approval` label to the pull request.\n+            pr.addLabel(\"approval\");\n+            \/\/ Simulate the PRBot. Add the `master-fix-request` label to the issue.\n+            issue.addLabel(\"master-fix-request\");\n+\n+            \/\/ Approve the update change.\n+            issue.addLabel(\"master-fix-yes\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should remove the `approval` label of the pull request.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The bot should add the approval update marker.\n+            assertTrue(pr.store().body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+\n+    @Test\n+    void testDisapproval(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalBot(issueProject, List.of(author),\n+                    List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\" , \"test-fix-yes\" , \"test-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\" , \"master-fix-yes\" , \"master-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\" , \"jdk18-fix-yes\" , \"jdk18-fix-no\" , Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\",\n+                    issue.id() + \": \" + issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            pr.setBody(pr.body() + \"\\n- [ ] All issues must be\");\n+            PullRequestUtils.postPullRequestLinkComment(issue, pr);\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Simulate the PRBot. Add the `approval` label to the pull request.\n+            pr.addLabel(\"approval\");\n+            \/\/ Simulate the PRBot. Add the `master-fix-request` label to the issue.\n+            issue.addLabel(\"master-fix-request\");\n+\n+            \/\/ Reject the update change.\n+            issue.addLabel(\"master-fix-no\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should remove the `approval` label of the pull request.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The bot should add the approval update marker.\n+            assertTrue(pr.store().body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+\n+    @Test\n+    void testNoFixRequest(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalBot(issueProject, List.of(author),\n+                    List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\" , \"test-fix-yes\" , \"test-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\" , \"master-fix-yes\" , \"master-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\" , \"jdk18-fix-yes\" , \"jdk18-fix-no\" , Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\",\n+                    issue.id() + \": \" + issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            pr.setBody(pr.body() + \"\\n- [ ] All issues must be\");\n+            PullRequestUtils.postPullRequestLinkComment(issue, pr);\n+\n+            \/\/ Don't review the pr, so the update change is not ready for approval.\n+            \/\/ Don't add the `approval` label to the pull request.\n+            \/\/ Don't add the `master-fix-request` label to the issue.\n+\n+            \/\/ Approve the update change.\n+            issue.addLabel(\"master-fix-yes\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should add the fix request label to the issue.\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            \/\/ The pull request shouldn't have the `approval` label.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The bot should add the approval update marker.\n+            assertTrue(pr.store().body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+\n+    @Test\n+    void testWrongCheckedProgress(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalBot(issueProject, List.of(author),\n+                    List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\" , \"test-fix-yes\" , \"test-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\" , \"master-fix-yes\" , \"master-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\" , \"jdk18-fix-yes\" , \"jdk18-fix-no\" , Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\",\n+                    issue.id() + \": \" + issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            PullRequestUtils.postPullRequestLinkComment(issue, pr);\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Simulate the PRBot. Add the `approval` label to the pull request.\n+            pr.addLabel(\"approval\");\n+            \/\/ Simulate the PRBot. Add the `master-fix-request` label to the issue.\n+            issue.addLabel(\"master-fix-request\");\n+\n+            \/\/ The progress has been checked because of previous approval.\n+            pr.setBody(pr.body() + \"\\n- [x] All issues must be\");\n+\n+            \/\/ Reject the update change.\n+            issue.addLabel(\"master-fix-no\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The pull request shouldn't have the `approval` label.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The bot should add the approval update marker.\n+            assertTrue(pr.store().body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+\n+    @Test\n+    void testWrongIssue(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalBot(issueProject, List.of(author),\n+                    List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\" , \"test-fix-yes\" , \"test-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\" , \"master-fix-yes\" , \"master-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\" , \"jdk18-fix-yes\" , \"jdk18-fix-no\" , Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request which has the wrong title.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            pr.setBody(pr.body() + \"\\n- [ ] All issues must be\");\n+            PullRequestUtils.postPullRequestLinkComment(issue, pr);\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Simulate the PRBot. Add the `approval` label to the pull request.\n+            pr.addLabel(\"approval\");\n+            \/\/ Simulate the PRBot. Add the `master-fix-request` label to the issue.\n+            issue.addLabel(\"master-fix-request\");\n+\n+            \/\/ Approve the update change.\n+            issue.addLabel(\"master-fix-yes\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot shouldn't remove the `approval` label of the pull request.\n+            assertTrue(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The bot shouldn't add the approval update marker.\n+            assertFalse(pr.store().body().contains(APPROVAL_UPDATE_MARKER));\n+\n+            \/\/ Change the pr title to wrong issue id\n+            pr.setTitle(\"2: \" + issue.title());\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot shouldn't remove the `approval` label of the pull request.\n+            assertTrue(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The bot shouldn't add the approval update marker.\n+            assertFalse(pr.store().body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+}\n","filename":"bots\/approval\/src\/test\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalBotTests.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+    implementation project(':bots:approval')\n","filename":"bots\/cli\/build.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.List;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.Comment;\n+import org.openjdk.skara.issuetracker.Issue;\n+\n+public class ApprovalCommand implements CommandHandler {\n+    \/\/ The tags to re-run the CheckWorkItem of the PRBot.\n+    private static final String APPROVAL_MARKER = \"<!-- approval: 'yes' -->\";\n+    private static final String DISAPPROVAL_MARKER = \"<!-- approval: 'no' -->\";\n+\n+    private static void showHelp(PrintWriter writer) {\n+        writer.println(\"\"\"\n+                usage: `\/approval [yes|no|y|n]`\n+\n+                examples:\n+                * `\/approval`\n+                * `\/approval yes`\n+                * `\/approval no`\n+\n+                Note: Only the repository maintainers are allowed to use the `approval` command.\n+                \"\"\");\n+    }\n+\n+    private void approvalReply(PullRequest pr, PrintWriter writer) {\n+        writer.println(\"@\" + pr.author().username() + \" this pull request was approved by the maintainer.\");\n+        writer.println(APPROVAL_MARKER);\n+    }\n+\n+    private void disapprovalReply(PullRequest pr, PrintWriter writer) {\n+        writer.println(String.format(\"@%s this pull request was rejected by the maintainer. \"\n+                + \"This pull request will be closed.\", pr.author().username()));\n+        writer.println(DISAPPROVAL_MARKER);\n+    }\n+\n+    @Override\n+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                       CommandInvocation command, List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem) {\n+        if (!workItem.requiresApproval()) {\n+            reply.println(\"the `approval` command can only be used on pull requests targeting branches and repositories that require approval.\");\n+            return;\n+        }\n+\n+        var commandUser = censusInstance.namespace().get(command.user().id());\n+        if (!workItem.isMaintainer(commandUser)) {\n+            reply.println(\"only the repository maintainers are allowed to use the `approval` command.\");\n+            return;\n+        }\n+\n+        var arg = command.args().trim().toLowerCase();\n+        if (!arg.isEmpty() && !(arg.equals(\"yes\") || arg.equals(\"y\") || arg.equals(\"no\") || arg.equals(\"n\"))) {\n+            showHelp(reply);\n+            return;\n+        }\n+\n+        if (arg.equals(\"no\") || arg.equals(\"n\")) {\n+            for (var vcsIssue : workItem.issues(false, false)) {\n+                var issueOpt = bot.issueProject().issue(vcsIssue.shortId());\n+                issueOpt.ifPresent(issue -> {\n+                    if (!issue.labelNames().contains(workItem.requestLabelName())) {\n+                        \/\/ The maintainers may disapprove the PR before it is ready.\n+                        \/\/ The bot should add the fix request label firstly to avoid the strange\n+                        \/\/ middle state which has disapproval label but has no fix request label.\n+                        issue.addLabel(workItem.requestLabelName());\n+                    }\n+                    if (issue.labelNames().contains(workItem.approvalLabelName())) {\n+                        \/\/ If the maintainers have approved the PR before,\n+                        \/\/ the bot should remove the approval label first.\n+                        issue.removeLabel(workItem.approvalLabelName());\n+                    }\n+                    if (!issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                        issue.addLabel(workItem.disapprovalLabelName());\n+                    }\n+                });\n+            }\n+            if (pr.labelNames().contains(\"approval\")) {\n+                pr.removeLabel(\"approval\");\n+            }\n+            disapprovalReply(pr, reply);\n+            pr.setState(Issue.State.CLOSED);\n+            return;\n+        }\n+\n+        pr.setState(Issue.State.OPEN);\n+        for (var vcsIssue : workItem.issues(false, false)) {\n+            var issueOpt = bot.issueProject().issue(vcsIssue.shortId());\n+            issueOpt.ifPresent(issue -> {\n+                if (!issue.labelNames().contains(workItem.requestLabelName())) {\n+                    \/\/ The maintainers may approve the PR before it is ready.\n+                    \/\/ The bot should add the fix request label firstly to avoid the strange\n+                    \/\/ middle state which has approval label but has no fix request label.\n+                    issue.addLabel(workItem.requestLabelName());\n+                }\n+                if (issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                    \/\/ If the maintainers have disapproved the PR before,\n+                    \/\/ the bot should remove the disapproval label first.\n+                    issue.removeLabel(workItem.disapprovalLabelName());\n+                }\n+                if (!issue.labelNames().contains(workItem.approvalLabelName())) {\n+                    issue.addLabel(workItem.approvalLabelName());\n+                }\n+            });\n+        }\n+        if (pr.labelNames().contains(\"approval\")) {\n+            pr.removeLabel(\"approval\");\n+        }\n+        approvalReply(pr, reply);\n+    }\n+\n+    @Override\n+    public boolean allowedInBody() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"approve or disapprove a pull request which needs maintainer's approval\";\n+    }\n+}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/ApprovalCommand.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -72,1 +72,2 @@\n-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {\n+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                       CommandInvocation command, List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem) {\n@@ -109,1 +110,1 @@\n-            var versionOpt = CheckRun.getVersion(pr);\n+            var versionOpt = workItem.getVersion();\n@@ -165,1 +166,1 @@\n-        var versionOpt = CheckRun.getVersion(pr);\n+        var versionOpt = workItem.getVersion();\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CSRCommand.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import org.openjdk.skara.jbs.Backports;\n-import org.openjdk.skara.jbs.JdkVersion;\n-import org.openjdk.skara.jcheck.JCheckConfiguration;\n@@ -70,0 +67,2 @@\n+    private static final String APPROVAL_SUGGESTION_MARKER = \"<!-- Approval suggestion comment -->\";\n+    private static final String APPROVAL_PROGRESS = \"All issues must be [approved](https:\/\/openjdk.org\/projects\/jdk-updates\/approval.html) by a maintainer\";\n@@ -117,80 +116,0 @@\n-    private List<Issue> issues(boolean withCsr, boolean withJep) {\n-        var issue = Issue.fromStringRelaxed(pr.title());\n-        if (issue.isPresent()) {\n-            var issues = new ArrayList<Issue>();\n-            issues.add(issue.get());\n-            issues.addAll(SolvesTracker.currentSolved(pr.repository().forge().currentUser(), comments));\n-            if (withCsr) {\n-                getCsrIssue(issue.get()).ifPresent(issues::add);\n-            }\n-            if (withJep) {\n-                getJepIssue().ifPresent(issues::add);\n-            }\n-            return issues;\n-        }\n-        return List.of();\n-    }\n-\n-    \/**\n-     * Get the fix version from the provided PR.\n-     *\/\n-    public static Optional<JdkVersion> getVersion(PullRequest pullRequest) {\n-        var confFile = pullRequest.repository().fileContents(\".jcheck\/conf\", pullRequest.targetRef());\n-        var configuration = JCheckConfiguration.parse(confFile.lines().toList());\n-        var version = configuration.general().version().orElse(null);\n-        if (version == null || \"\".equals(version)) {\n-            return Optional.empty();\n-        }\n-        return JdkVersion.parse(version);\n-    }\n-\n-    \/**\n-     * Get the csr issue. Note: this `Issue` is not the issue in module `issuetracker`.\n-     *\/\n-    private Optional<Issue> getCsrIssue(Issue issue) {\n-        var issueProject = issueProject();\n-        if (issueProject == null) {\n-            return Optional.empty();\n-        }\n-        var jbsIssueOpt = issueProject.issue(issue.shortId());\n-        if (jbsIssueOpt.isEmpty()) {\n-            return Optional.empty();\n-        }\n-\n-        var versionOpt = getVersion(pr);\n-        if (versionOpt.isEmpty()) {\n-            return Optional.empty();\n-        }\n-\n-        return Backports.findCsr(jbsIssueOpt.get(), versionOpt.get())\n-                .flatMap(perIssue -> Issue.fromStringRelaxed(perIssue.id() + \": \" + perIssue.title()));\n-    }\n-\n-    private Optional<Issue> getJepIssue() {\n-        var comment = getJepComment();\n-        if (comment.isPresent()) {\n-            return Issue.fromStringRelaxed(comment.get().group(2) + \": \" + comment.get().group(3));\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private Optional<Matcher> getJepComment() {\n-        var jepComment = pr.comments().stream()\n-                .filter(comment -> comment.author().equals(pr.repository().forge().currentUser()))\n-                .flatMap(comment -> comment.body().lines())\n-                .map(JEPCommand.jepMarkerPattern::matcher)\n-                .filter(Matcher::find)\n-                .reduce((first, second) -> second)\n-                .orElse(null);\n-        if (jepComment == null) {\n-            return Optional.empty();\n-        }\n-\n-        var issueId = jepComment.group(2);\n-        if (\"unneeded\".equals(issueId)) {\n-            return  Optional.empty();\n-        }\n-\n-        return Optional.of(jepComment);\n-    }\n-\n@@ -246,0 +165,1 @@\n+        var issueOpt = Issue.fromStringRelaxed(pr.title());\n@@ -250,1 +170,1 @@\n-            var csrIssue = Issue.fromStringRelaxed(pr.title()).flatMap(this::getCsrIssue)\n+            var csrIssue = issueOpt.flatMap(workItem::getCsrIssue)\n@@ -267,1 +187,1 @@\n-            var comment = getJepComment();\n+            var comment = workItem.getJepComment();\n@@ -272,0 +192,16 @@\n+\n+        if (workItem.requiresApproval()) {\n+            var issue = issueOpt.flatMap(value -> issueProject() != null ? issueProject().issue(value.shortId()) : Optional.empty());\n+            if (issue.isPresent()) {\n+                if (issue.get().labelNames().contains(workItem.approvalLabelName())) {\n+                    ret.put(APPROVAL_PROGRESS, true);\n+                } else {\n+                    \/\/ The main issue doesn't have the approval label.\n+                    ret.put(APPROVAL_PROGRESS, false);\n+                }\n+            } else {\n+                \/\/ The PR doesn't have an issue.\n+                ret.put(APPROVAL_PROGRESS, false);\n+            }\n+        }\n+\n@@ -289,1 +225,1 @@\n-        var issues = issues(false, false);\n+        var issues = workItem.issues(false, false);\n@@ -598,1 +534,1 @@\n-        var issues = issues(true, true);\n+        var issues = workItem.issues(true, true);\n@@ -1016,0 +952,101 @@\n+    \/**\n+     * Add or update a suggestion comment to the pull request which needs the maintainer's approval to direct the developers.\n+     *\/\n+    private void updateApprovalSuggestionComment() {\n+        var message = new StringBuilder();\n+        message.append(\"@\");\n+        message.append(pr.author().username());\n+        message.append(\" \");\n+        message.append(\"\"\"\n+                This pull request requires [maintainer approval]\\\n+                (https:\/\/openjdk.org\/projects\/jdk-updates\/approval.html).\n+\n+                As a convenience, or if you don't have permission to post comments in JBS, \\\n+                you may use the command `\/request-approval` to supply the fix request comment \\\n+                and automatically set the correct request label.\n+                usage: `\/request-approval <comment-text>`\n+\n+                Please note that approval discussions should take place in the issue and not in the pull request.\n+                \"\"\");\n+        message.append(APPROVAL_SUGGESTION_MARKER);\n+        var existing = findComment(comments, APPROVAL_SUGGESTION_MARKER);\n+        if (existing.isPresent()) {\n+            pr.updateComment(existing.get().id(), message.toString());\n+        } else {\n+            pr.addComment(message.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Update labels of the issue and PR which need the maintainer's approval (usually backport).\n+     *\/\n+    private void updateLabelsAboutApproval(boolean readyForApproval) {\n+        if (issueProject() == null) {\n+            return;\n+        }\n+        var mainIssueOpt = Issue.fromStringRelaxed(pr.title()).flatMap(value -> issueProject().issue(value.shortId()));\n+        var issues = workItem.issues(false, false);\n+        for (var vcsIssue : issues) {\n+            var issueOpt = issueProject().issue(vcsIssue.shortId());\n+            if (issueOpt.isPresent()) {\n+                var issue = issueOpt.get();\n+                if (mainIssueOpt.isPresent() && !mainIssueOpt.get().id().equals(issue.id()) &&\n+                        mainIssueOpt.get().labelNames().contains(workItem.approvalLabelName())) {\n+                    \/\/ If approval label was only added to the main issue, the bot should add it to all the issues.\n+                    if (issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                        \/\/ Remove the previously existing disapproval label.\n+                        issue.removeLabel(workItem.disapprovalLabelName());\n+                    }\n+                    if (!issue.labelNames().contains(workItem.approvalLabelName())) {\n+                        issue.addLabel(workItem.approvalLabelName());\n+                    }\n+                } else if (mainIssueOpt.isPresent() && !mainIssueOpt.get().id().equals(issue.id()) &&\n+                        mainIssueOpt.get().labelNames().contains(workItem.disapprovalLabelName())) {\n+                    \/\/ If disapproval label was only added to the main issue, the bot should add it to all the issues.\n+                    if (issue.labelNames().contains(workItem.approvalLabelName())) {\n+                        \/\/ Remove the previously existing approval label.\n+                        issue.removeLabel(workItem.approvalLabelName());\n+                    }\n+                    if (!issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                        issue.addLabel(workItem.disapprovalLabelName());\n+                    }\n+                }\n+                if (readyForApproval && !issue.labelNames().contains(workItem.requestLabelName())) {\n+                    \/\/ Add the fix request label to the issue if the PR is ready for approval.\n+                    issue.addLabel(workItem.requestLabelName());\n+                } else if (!readyForApproval && issue.labelNames().contains(workItem.requestLabelName()) &&\n+                        !issue.labelNames().contains(workItem.approvalLabelName()) &&\n+                        !issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                    \/\/ Remove the fix request label of the issue if the PR is not ready for approval\n+                    \/\/ and the issue has not been approved or disapproved.\n+                    \/\/ One condition which causes this: firstly, the PR is ready for approval (such as a clean backport),\n+                    \/\/ so the bot adds the fix request label to the issue. Then the author of the PR submits\n+                    \/\/ new code to the PR which needs to be reviewed or other things occur so that the PR becomes not\n+                    \/\/ ready for approval, the bot should remove the fix request label to reduce the work of the maintainers.\n+                    issue.removeLabel(workItem.requestLabelName());\n+                }\n+            }\n+        }\n+\n+        if (mainIssueOpt.isPresent()) {\n+            if (readyForApproval && !mainIssueOpt.get().labelNames().contains(workItem.approvalLabelName()) &&\n+                    !mainIssueOpt.get().labelNames().contains(workItem.disapprovalLabelName())) {\n+                if (!pr.labelNames().contains(\"approval\")) {\n+                    \/\/ Add `approval` label to PR if the PR is ready for approval and the PR has not been approved.\n+                    pr.addLabel(\"approval\");\n+                }\n+            } else {\n+                \/\/ The pull request is not ready for approval or the main issue contains approval or disapproval label.\n+                if (pr.labelNames().contains(\"approval\")) {\n+                    \/\/ Remove `approval` label of PR if the PR has been approved or disapproved.\n+                    pr.removeLabel(\"approval\");\n+                }\n+                if (mainIssueOpt.get().labelNames().contains(workItem.disapprovalLabelName()) && pr.isOpen()) {\n+                    pr.addComment(String.format(\"@%s this pull request was rejected by the maintainer. \"\n+                            + \"The bot will close this pull request automatically.\", pr.author().username()));\n+                    pr.setState(org.openjdk.skara.issuetracker.Issue.State.CLOSED);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1119,0 +1156,17 @@\n+            \/\/ If the PR targets to the update repository or branch.\n+            if (workItem.requiresApproval()) {\n+                var additionalThingReady = additionalErrors.isEmpty() &&\n+                                           additionalProgresses.entrySet().stream()\n+                                             .filter(entry -> !entry.getKey().equals(APPROVAL_PROGRESS))\n+                                             .allMatch(Map.Entry::getValue) &&\n+                                           integrationBlockers.isEmpty();;\n+                var readyForApproval = visitor.messages().isEmpty() && additionalThingReady;\n+                if (isCleanBackport) {\n+                    readyForApproval = visitor.isReadyForReview() && additionalThingReady;\n+                }\n+                \/\/ The bot needs to provide a suggestion comment.\n+                updateApprovalSuggestionComment();\n+                \/\/ The labels of the issue and the PR need to be updated.\n+                updateLabelsAboutApproval(readyForApproval);\n+            }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":141,"deletions":87,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -46,1 +46,4 @@\n-    private final Pattern metadataComments = Pattern.compile(\"<!-- (?:(add|remove) (?:contributor|reviewer))|(?:summary: ')|(?:solves: ')|(?:additional required reviewers)|(?:jep: ')|(?:csr: ')\");\n+    private final Pattern metadataComments = Pattern.compile(\"\"\"\n+                    <!-- (?:(add|remove) (?:contributor|reviewer))|(?:summary: ')|(?:solves: ')|\\\n+                    (?:additional required reviewers)|(?:jep: ')|(?:csr: ')|(?:approval: ')|(?:request-approval: ')\n+                    \"\"\");\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckWorkItem.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    private static final Pattern commandPattern = Pattern.compile(\"^\\\\s*\/([A-Za-z]+)(?:\\\\s+(.*))?\");\n+    private static final Pattern commandPattern = Pattern.compile(\"^\\\\s*\/([A-Za-z\\\\-]+)(?:\\\\s+(.*))?\");\n@@ -65,0 +65,2 @@\n+            Map.entry(\"approval\", new ApprovalCommand()),\n+            Map.entry(\"request-approval\", new RequestApprovalCommand()),\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CommandExtractor.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-    default void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command,\n-                        List<Comment> allComments, PrintWriter reply, List<String> labelsToAdd, List<String> labelsToRemove) {\n+    default void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                        CommandInvocation command, List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem) {\n@@ -45,0 +45,6 @@\n+    default void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                        CommandInvocation command, List<Comment> allComments, PrintWriter reply,\n+                        PullRequestWorkItem workItem, List<String> labelsToAdd, List<String> labelsToRemove) {\n+        handle(bot, pr, censusInstance, scratchPath, command, allComments, reply, workItem);\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CommandHandler.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                       List<Comment> allComments, PrintWriter reply, List<String> labelsToAdd, List<String> labelsToRemove) {\n+                       List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem, List<String> labelsToAdd, List<String> labelsToRemove) {\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/JEPCommand.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private final List<ApprovalInfo> approvalInfos;\n@@ -79,1 +80,2 @@\n-                   Set<String> integrators, Set<Integer> excludeCommitCommentsFrom, boolean enableCsr, boolean enableJep) {\n+                   Set<String> integrators, Set<Integer> excludeCommitCommentsFrom, boolean enableCsr,\n+                   boolean enableJep, List<ApprovalInfo> approvalInfos) {\n@@ -104,0 +106,1 @@\n+        this.approvalInfos = approvalInfos;\n@@ -291,0 +294,4 @@\n+    public List<ApprovalInfo> approvalInfos() {\n+        return approvalInfos;\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBot.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import org.openjdk.skara.bot.ApprovalInfo;\n@@ -58,0 +59,1 @@\n+    private List<ApprovalInfo> approvalInfos = List.of();\n@@ -182,0 +184,5 @@\n+    public PullRequestBotBuilder approvalInfos(List<ApprovalInfo> approvalInfos) {\n+        this.approvalInfos = approvalInfos;\n+        return this;\n+    }\n+\n@@ -188,1 +195,2 @@\n-                                  confOverrideRef, censusLink, forks, integrators, excludeCommitCommentsFrom, enableCsr, enableJep);\n+                                  confOverrideRef, censusLink, forks, integrators, excludeCommitCommentsFrom, enableCsr,\n+                                  enableJep, approvalInfos);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotBuilder.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import org.openjdk.skara.host.HostUser;\n@@ -109,0 +108,1 @@\n+            var repository = configuration.repository(repo.name());\n@@ -110,1 +110,1 @@\n-                                           .repo(configuration.repository(repo.name()))\n+                                           .repo(repository)\n@@ -168,0 +168,18 @@\n+            var approvalInfos = new ArrayList<ApprovalInfo>();\n+            if (repo.value().contains(\"approval\")) {\n+                for (var branchInfo : repo.value().get(\"approval\").asArray()) {\n+                    var requestLabel = branchInfo.get(\"request-label\").asString();\n+                    var approvalLabel = branchInfo.get(\"approval-label\").asString();\n+                    var disapprovalLabel = branchInfo.get(\"disapproval-label\").asString();\n+                    var maintainers = new HashSet<String>();\n+                    if (branchInfo.contains(\"maintainers\")) {\n+                        for (var maintainer : branchInfo.get(\"maintainers\").asArray()) {\n+                            maintainers.add(maintainer.asString());\n+                        }\n+                    }\n+                    approvalInfos.add(new ApprovalInfo(repository, Pattern.compile(branchInfo.get(\"branch\").asString()),\n+                            requestLabel, approvalLabel, disapprovalLabel, maintainers));\n+                }\n+                botBuilder.approvalInfos(approvalInfos);\n+            }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotFactory.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-                    handler.get().handle(bot, pr, censusInstance, scratchPath, command, allComments, printer, labelsToAdd, labelsToRemove);\n+                    handler.get().handle(bot, pr, censusInstance, scratchPath, command, allComments, printer, this, labelsToAdd, labelsToRemove);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestCommandWorkItem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -31,0 +32,4 @@\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import org.openjdk.skara.bot.ApprovalInfo;\n@@ -32,0 +37,1 @@\n+import org.openjdk.skara.census.Contributor;\n@@ -35,0 +41,4 @@\n+import org.openjdk.skara.jbs.Backports;\n+import org.openjdk.skara.jbs.JdkVersion;\n+import org.openjdk.skara.jcheck.JCheckConfiguration;\n+import org.openjdk.skara.vcs.openjdk.Issue;\n@@ -50,0 +60,3 @@\n+    private String requestLabelName = null;\n+    private String approvalLabelName = null;\n+    private String disapprovalLabelName = null;\n@@ -107,0 +120,162 @@\n+\n+    \/**\n+     * Get the request label name from the configuration.\n+     *\/\n+    String requestLabelName() {\n+        if (requestLabelName == null) {\n+            for (var approvalInfo : bot.approvalInfos()) {\n+                if (approvalInfo.branchPattern().matcher(pr.targetRef()).matches()) {\n+                    requestLabelName = approvalInfo.requestLabel();\n+                    return requestLabelName;\n+                }\n+            }\n+            requestLabelName = \"\";\n+            return requestLabelName;\n+        }\n+        return requestLabelName;\n+    }\n+\n+    \/**\n+     * Get the approval label name from the configuration.\n+     *\/\n+    String approvalLabelName() {\n+        if (approvalLabelName == null) {\n+            for (var approvalInfo : bot.approvalInfos()) {\n+                if (approvalInfo.branchPattern().matcher(pr.targetRef()).matches()) {\n+                    approvalLabelName = approvalInfo.approvalLabel();\n+                    return approvalLabelName;\n+                }\n+            }\n+            approvalLabelName = \"\";\n+            return approvalLabelName;\n+        }\n+        return approvalLabelName;\n+    }\n+\n+    \/**\n+     * Get the disapproval label name from the configuration.\n+     *\/\n+    String disapprovalLabelName() {\n+        if (disapprovalLabelName == null) {\n+            for (var approvalInfo : bot.approvalInfos()) {\n+                if (approvalInfo.branchPattern().matcher(pr.targetRef()).matches()) {\n+                    disapprovalLabelName = approvalInfo.disapprovalLabel();\n+                    return disapprovalLabelName;\n+                }\n+            }\n+            disapprovalLabelName = \"\";\n+            return disapprovalLabelName;\n+        }\n+        return disapprovalLabelName;\n+    }\n+\n+    \/**\n+     * Judge whether the change of this PR needs the maintainer's approval.\n+     *\/\n+    boolean requiresApproval() {\n+        return bot.approvalInfos().stream()\n+                        .anyMatch(this::approvalInfoMatch);\n+    }\n+\n+    \/**\n+     * Return the first approval info from the configuration.\n+     *\/\n+    Optional<ApprovalInfo> getApprovalInfo() {\n+        return bot.approvalInfos().stream()\n+                .filter(this::approvalInfoMatch)\n+                .findFirst();\n+    }\n+\n+    private boolean approvalInfoMatch(ApprovalInfo info) {\n+        return info.repo().isSame(pr.repository())\n+                && info.branchPattern().matcher(pr.targetRef()).matches();\n+    }\n+\n+    \/**\n+     * Judge whether a contributor is the maintainer of the repository\n+     *\/\n+    boolean isMaintainer(Contributor author) {\n+        var approvalInfo = getApprovalInfo();\n+        return approvalInfo.get().maintainers().stream()\n+                .anyMatch(name -> (name.equals(author.fullName().orElse(null)) || name.equals(author.username())));\n+    }\n+\n+    List<Issue> issues(boolean withCsr, boolean withJep) {\n+        var issue = Issue.fromStringRelaxed(pr.title());\n+        if (issue.isPresent()) {\n+            var issues = new ArrayList<Issue>();\n+            issues.add(issue.get());\n+            issues.addAll(SolvesTracker.currentSolved(pr.repository().forge().currentUser(), pr.comments()));\n+            if (withCsr) {\n+                getCsrIssue(issue.get()).ifPresent(issues::add);\n+            }\n+            if (withJep) {\n+                getJepIssue().ifPresent(issues::add);\n+            }\n+            return issues;\n+        }\n+        return List.of();\n+    }\n+\n+    \/**\n+     * Get the csr issue. Note: this `Issue` is not the issue in module `issuetracker`.\n+     *\/\n+    Optional<Issue> getCsrIssue(Issue issue) {\n+        var issueProject = bot.issueProject();\n+        if (issueProject == null) {\n+            return Optional.empty();\n+        }\n+        var jbsIssueOpt = issueProject.issue(issue.shortId());\n+        if (jbsIssueOpt.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        var versionOpt = getVersion();\n+        if (versionOpt.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        return Backports.findCsr(jbsIssueOpt.get(), versionOpt.get())\n+                .flatMap(perIssue -> Issue.fromStringRelaxed(perIssue.id() + \": \" + perIssue.title()));\n+    }\n+\n+    Optional<Issue> getJepIssue() {\n+        var comment = getJepComment();\n+        if (comment.isPresent()) {\n+            return Issue.fromStringRelaxed(comment.get().group(2) + \": \" + comment.get().group(3));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    \/**\n+     * Get the fix version from the PR.\n+     *\/\n+    Optional<JdkVersion> getVersion() {\n+        var confFile = pr.repository().fileContents(\".jcheck\/conf\", pr.targetRef());\n+        var configuration = JCheckConfiguration.parse(confFile.lines().toList());\n+        var version = configuration.general().version().orElse(null);\n+        if (version == null || \"\".equals(version)) {\n+            return Optional.empty();\n+        }\n+        return JdkVersion.parse(version);\n+    }\n+\n+    Optional<Matcher> getJepComment() {\n+        var jepComment = pr.comments().stream()\n+                .filter(comment -> comment.author().equals(pr.repository().forge().currentUser()))\n+                .flatMap(comment -> comment.body().lines())\n+                .map(JEPCommand.jepMarkerPattern::matcher)\n+                .filter(Matcher::find)\n+                .reduce((first, second) -> second)\n+                .orElse(null);\n+        if (jepComment == null) {\n+            return Optional.empty();\n+        }\n+\n+        var issueId = jepComment.group(2);\n+        if (\"unneeded\".equals(issueId)) {\n+            return  Optional.empty();\n+        }\n+\n+        return Optional.of(jepComment);\n+    }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestWorkItem.java","additions":176,"deletions":1,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.Comment;\n+import org.openjdk.skara.vcs.openjdk.Issue;\n+\n+public class RequestApprovalCommand implements CommandHandler {\n+    \/\/ The tag to re-run the CheckWorkItem of the PRBot.\n+    private static final String REQUEST_APPROVAL_MARKER = \"<!-- request-approval: 'update' -->\";\n+\n+    private void showHelp(PullRequest pr, PrintWriter writer) {\n+        writer.println(String.format(\"\"\"\n+                usage: `\/request-approval <comment-text>`\n+\n+                examples:\n+                ```\n+                \/request-approval Fix Request (%s)\n+                The code applies cleanly and the test in this change fails without the patch and succeeds \\\n+                after applying it. The risk of this backport is low because the change is little and the \\\n+                issue fixed by this change also exists in other update repositories.\n+                ```\n+\n+                Note: only the pull request author is allowed to use the `request-approval` command.\n+                \"\"\", pr.repository().name()));\n+    }\n+\n+    @Override\n+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                       CommandInvocation command, List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem) {\n+        if (!workItem.requiresApproval()) {\n+            reply.println(\"this repository or the target branch of this pull request have not been configured to use the `request-approval` command.\");\n+            return;\n+        }\n+\n+        if (!pr.author().equals(command.user())) {\n+            reply.println(\"only the pull request author is allowed to use the `request-approval` command.\");\n+            return;\n+        }\n+\n+        if (command.args().isBlank()) {\n+            showHelp(pr, reply);\n+            return;\n+        }\n+\n+        var vcsIssue = Issue.fromStringRelaxed(pr.title());\n+        if (vcsIssue.isEmpty()) {\n+            reply.println(\"the title of the pull request doesn't contain the main issue.\");\n+            return;\n+        }\n+\n+        var issueOpt = bot.issueProject().issue(vcsIssue.get().shortId());\n+        if (issueOpt.isEmpty()) {\n+            reply.println(\"the main issue of the pull request title is not found.\");\n+            return;\n+        }\n+\n+        var comment = command.args().lines().map(String::strip)\n+                .collect(Collectors.joining(\"\\n\"));\n+        issueOpt.get().addComment(comment);\n+        reply.println(\"the text you provide has been successfully added to the main issue as a comment.\");\n+        reply.println(REQUEST_APPROVAL_MARKER);\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"add a comment to the main issue of a pull request which needs maintainer's approval\";\n+    }\n+\n+    @Override\n+    public boolean multiLine() {\n+        return true;\n+    }\n+}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/RequestApprovalCommand.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,563 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.openjdk.skara.bots.pr.PullRequestCommandWorkItem.VALID_BOT_COMMAND_MARKER;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.forge.Review;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.CheckableRepository;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+import org.openjdk.skara.test.TestBotRunner;\n+\n+public class ApprovalCommandTests {\n+    @Test\n+    void testNormal(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ Create another two issues.\n+            var issue2 = credentials.createIssue(issueProject, \"This is update change issue2\");\n+            issue2.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var issue3 = credentials.createIssue(issueProject, \"This is update change issue3\");\n+            issue3.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            pr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            pr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the approval should be added to the pr body.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr is ready for approval\n+            assertTrue(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Approve the update change by using the command `approval`.\n+            var maintainerPr = maintainer.pullRequest(pr.id());\n+            maintainerPr.addComment(\"\/approval yes\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.store().body().contains(\"- [x] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-no\"));\n+            \/\/ The bot should add a comment to reply.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The pull request should be open.\n+            assertTrue(pr.store().isOpen());\n+\n+            \/\/ Reject the update change by using the command `approval`.\n+            maintainerPr.addComment(\"\/approval no\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been rejected.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-no` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-no\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            \/\/ The bot should add a comment to reply.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was rejected by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The pull request should be closed.\n+            assertTrue(pr.store().isClosed());\n+\n+            \/\/ Approve the update change again.\n+            maintainerPr.addComment(\"\/approval yes\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.store().body().contains(\"- [x] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-no\"));\n+            \/\/ The bot should add a comment to reply, now it has two such comments.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer\"))\n+                    .count();\n+            assertEquals(2, commentSize);\n+            \/\/ The pull request should be open.\n+            assertTrue(pr.store().isOpen());\n+        }\n+    }\n+\n+    @Test\n+    void testApprovalNotReady(TestInfo testInfo) throws IOException {\n+        \/\/ Approve or reject the update change when it is not ready for approval.\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            \/\/ Create three issues.\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var issue2 = credentials.createIssue(issueProject, \"This is update change issue2\");\n+            issue2.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var issue3 = credentials.createIssue(issueProject, \"This is update change issue3\");\n+            issue3.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create pull request.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ Add another two issues to the pull request.\n+            pr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            pr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ Don't review the pr so that it is not ready for approval and the fix request label is not added to the issue.\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Approve the update change by using the command `approval`.\n+            var maintainerPr = maintainer.pullRequest(pr.id());\n+            maintainerPr.addComment(\"\/approval yes\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.store().body().contains(\"- [x] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-no\"));\n+            \/\/ The bot should add a comment to reply.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The pull request should be open.\n+            assertTrue(pr.store().isOpen());\n+\n+            \/\/ <---- separator ---->\n+\n+            \/\/ Clear the labels of the issues.\n+            issue.removeLabel(\"master-fix-request\");\n+            issue2.removeLabel(\"master-fix-request\");\n+            issue3.removeLabel(\"master-fix-request\");\n+            issue.removeLabel(\"master-fix-yes\");\n+            issue2.removeLabel(\"master-fix-yes\");\n+            issue3.removeLabel(\"master-fix-yes\");\n+\n+            \/\/ Create another pull request.\n+            var anotherPr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ Add another two issues to the pull request.\n+            anotherPr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            anotherPr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ Don't review the pr so that it is not ready for approval and the fix request label is not added to the issue.\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            commentSize = anotherPr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(anotherPr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval\n+            assertFalse(anotherPr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Reject the update change by using the command `approval`.\n+            maintainerPr = maintainer.pullRequest(anotherPr.id());\n+            maintainerPr.addComment(\"\/approval no\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = anotherPr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(anotherPr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr has been rejected.\n+            assertFalse(anotherPr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-no` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-no\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            \/\/ The bot should add a comment to reply.\n+            commentSize = anotherPr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was rejected by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The pull request should be closed.\n+            assertTrue(anotherPr.store().isClosed());\n+        }\n+    }\n+\n+    @Test\n+    void testAuthorization(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"main\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request targeted to the `main` branch which is not configured.\n+            var pr = credentials.createPullRequest(author, \"main\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Approve the update change.\n+            var maintainerPr = maintainer.pullRequest(pr.id());\n+            maintainerPr.addComment(\"\/approval yes\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the `approval` command can only be used on \"\n+                            + \"pull requests targeting branches and repositories that require approval.\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+\n+            \/\/ Create another pull request targeted to the `master` branch.\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var anotherPr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Reject the update change by using the reviewer role.\n+            var reviewerPr = reviewer.pullRequest(anotherPr.id());\n+            reviewerPr.addComment(\"\/approval no\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            commentSize = anotherPr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"only the repository maintainers are allowed to use the `approval` command\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+        }\n+    }\n+\n+    @Test\n+    void testCommandTypo(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Test command typo `yea`\n+            var maintainerPr = maintainer.pullRequest(pr.id());\n+            maintainerPr.addComment(\"\/approval yea\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a help comment.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"usage: `\/approval [yes|no|y|n]`\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+\n+            \/\/ Test command typo `ni`\n+            maintainerPr.addComment(\"\/approval ni\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a help comment, now the pull request has two such comments.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"usage: `\/approval [yes|no|y|n]`\"))\n+                    .count();\n+            assertEquals(2, commentSize);\n+\n+            \/\/ Note: the command is case-insensitive, the arguments `Yes`, `YeS`, `No`, `nO`, `Y`, `N` can be run successfully.\n+\n+            \/\/ Test case-insensitive\n+            maintainerPr.addComment(\"\/approval YeS\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ The pull request now shouldn't have the approved comment.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer`\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply the approved comment.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/ApprovalCommandTests.java","additions":563,"deletions":0,"binary":false,"changes":563,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.skara.bot.ApprovalInfo;\n@@ -41,0 +42,1 @@\n+import static org.openjdk.skara.bots.pr.PullRequestCommandWorkItem.VALID_BOT_COMMAND_MARKER;\n@@ -2141,0 +2143,463 @@\n+\n+    @Test\n+    void testApprovalRequest(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The issue shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr is ready for approval\n+            assertTrue(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The issue should contain the `master-fix-request` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            \/\/ The issue shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Test the title of the PR doesn't have issue id.\n+            pr.setTitle(issue.title());\n+            \/\/ Clean the labels.\n+            pr.removeLabel(\"approval\");\n+            issue.removeLabel(\"master-fix-request\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The issue shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Correct the title.\n+            pr.setTitle(issue.id() + \": \" + issue.title());\n+\n+            \/\/ Test multi issues in one pull request\n+            \/\/ Create another two issues.\n+            var issue2 = credentials.createIssue(issueProject, \"This is update change issue2\");\n+            issue2.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var issue3 = credentials.createIssue(issueProject, \"This is update change issue3\");\n+            issue3.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            pr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            pr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr is ready for approval\n+            assertTrue(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-no\"));\n+        }\n+    }\n+\n+    @Test\n+    void testApprovalAndDisapproval(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Create another two issues.\n+            var issue2 = credentials.createIssue(issueProject, \"This is update change issue2\");\n+            issue2.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var issue3 = credentials.createIssue(issueProject, \"This is update change issue3\");\n+            issue3.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            pr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            pr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ Test the update change is approved by the maintainer on the main issue.\n+            \/\/ Add the `master-fix-yes` label to the main issue.\n+            issue.addLabel(\"master-fix-yes\");\n+            \/\/ Add the update marker to the pr body. This step simulates the approval bot.\n+            pr.setBody(pr.body() + \"\\n<!-- approval: 'update' -->\\n\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.store().body().contains(\"- [x] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-no\"));\n+            \/\/ The pr is still open\n+            assertTrue(pr.store().isOpen());\n+\n+            \/\/ Test the update change is disapproved by the maintainer on the main issue.\n+            \/\/ Also test disapproval after approval.\n+            \/\/ Only need to revise the main issue, the bot will sync the label to other issues.\n+            \/\/ Clean the previous `master-fix-yes` label.\n+            issue.removeLabel(\"master-fix-yes\");\n+            \/\/ Add the `master-fix-no` label to the main issue.\n+            issue.addLabel(\"master-fix-no\");\n+            \/\/ Add the update marker to the pr body. This step simulates the approval bot.\n+            pr.setBody(pr.body() + \"\\n<!-- approval: 'update' -->\\n\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been disapproved.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-no` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-no\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            \/\/ The pr is closed now.\n+            assertTrue(pr.store().isClosed());\n+\n+            \/\/ Test the update change is approved by the maintainer on the main issue.\n+            \/\/ Also test approval after disapproval.\n+            \/\/ Only need to revise the main issue, the bot will sync the label to other issues.\n+            \/\/ Clean the previous `master-fix-no` label.\n+            issue.removeLabel(\"master-fix-no\");\n+            \/\/ Add the `master-fix-yes` label to the main issue.\n+            issue.addLabel(\"master-fix-yes\");\n+            \/\/ Add the update marker to the pr body. This step simulates the approval bot.\n+            pr.setBody(pr.body() + \"\\n<!-- approval: 'update' -->\\n\");\n+            \/\/ Open the pull request manually.\n+            pr.setState(Issue.State.OPEN);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.store().body().contains(\"- [x] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.store().labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.store().labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.store().labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.store().labelNames().contains(\"master-fix-no\"));\n+            \/\/ The pr is open (actually open by the approval bot).\n+            assertTrue(pr.store().isOpen());\n+        }\n+    }\n+\n+    @Test\n+    void testNotNeedApproval(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var mainHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(mainHash, author.url(), \"main\", true);\n+\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request to the `main` branch instead of `master` branch, so it is not an update change.\n+            var pr = credentials.createPullRequest(author, \"main\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion shouldn't be added.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be added to the pr body.\n+            assertFalse(pr.store().body().contains(\"All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not an update change (the target branch is not `master`).\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The issue shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+        }\n+    }\n+\n+    @Test\n+    void testApprovalWithCleanBackport(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            issue.setState(Issue.State.CLOSED);\n+\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Push a commit to the jdk19 branch\n+            var jdk19Branch = localRepo.branch(masterHash, \"jdk19\");\n+            localRepo.checkout(jdk19Branch);\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"a_new_file\");\n+            localRepo.add(newFile);\n+            var issueNumber = issue.id().split(\"-\")[1];\n+            var commitMessage = issueNumber + \": This is update change issue\\n\\nReviewed-by: integrationreviewer2\";\n+            var commitHash = localRepo.commit(commitMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.org\");\n+            localRepo.push(commitHash, author.url(), \"jdk19\", true);\n+\n+            \/\/ \"backport\" the commit to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"a_new_file\");\n+            localRepo.add(newFile2);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(editHash, author.url(), \"edit\", true);\n+            \/\/ This is a clean backport, so it is ready for approval.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + commitHash);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr is a clean backport.\n+            assertTrue(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The issue should contain the `master-fix-request` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            \/\/ The issue shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Add more commit to `edit` branch, then the pull request is not a clean backport now.\n+            Files.writeString(newFile2, \"another_new_file\");\n+            localRepo.add(newFile2);\n+            var editHash2 = localRepo.commit(\"another commit\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(editHash2, author.url(), \"edit\", true);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval (it is not a clean backport).\n+            assertFalse(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The issue shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ review the pr, then the pull request is ready for approval\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.store().body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr has been reviewed and is ready for approval now.\n+            assertTrue(pr.store().labelNames().contains(\"approval\"));\n+            \/\/ The issue should contain the `master-fix-request` label\n+            assertTrue(issue.store().labelNames().contains(\"master-fix-request\"));\n+            \/\/ The issue shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.store().labelNames().contains(\"master-fix-no\"));\n+        }\n+    }\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/CheckTests.java","additions":465,"deletions":0,"binary":false,"changes":465,"status":"modified"},{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.openjdk.skara.bots.pr.PullRequestCommandWorkItem.VALID_BOT_COMMAND_MARKER;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.CheckableRepository;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+import org.openjdk.skara.test.TestBotRunner;\n+\n+public class RequestApprovalCommandTests {\n+    @Test\n+    void testNormal(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Use the command `request-approval`.\n+            pr.addComment(\"\/request-approval request-approval-test\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the text you provide has been successfully \"\n+                            + \"added to the main issue as a comment\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue should have one corresponding comment.\n+            commentSize = issue.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+\n+            \/\/ Use the command `request-approval` again.\n+            pr.addComment(\"\/request-approval request-approval-test\\nanother comment\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment, now the pull request has two such comments.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the text you provide has been successfully \"\n+                            + \"added to the main issue as a comment\"))\n+                    .count();\n+            assertEquals(2, commentSize);\n+            \/\/ The issue should have two corresponding comments.\n+            commentSize = issue.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(2, commentSize);\n+        }\n+    }\n+\n+    @Test\n+    void testAuthorization(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"main\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request targeted to the `main` branch which is not configured.\n+            var pr = credentials.createPullRequest(author, \"main\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ User the command `request-approval`\n+            pr.addComment(\"\/request-approval request-approval-test\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this repository or the target branch of \"\n+                            + \"this pull request have not been configured to use the `request-approval` command\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue shouldn't have related comment.\n+            commentSize = issue.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+\n+            \/\/ Create another pull request targeted to the `master` branch.\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var anotherPr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Use the command `request-approval` by using non-author role.\n+            var reviewerPr = reviewer.pullRequest(anotherPr.id());\n+            reviewerPr.addComment(\"\/request-approval request-approval-test\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            commentSize = anotherPr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"only the pull request author is allowed to use the `request-approval` command\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue shouldn't have related comment.\n+            commentSize = issue.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+        }\n+    }\n+\n+    @Test\n+    void testWrongIssue(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = credentials.createIssue(issueProject, \"This is update change issue\");\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Use the command `request-approval`.\n+            pr.addComment(\"\/request-approval request-approval-test\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            var commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the title of the pull request doesn't contain the main issue\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue shouldn't have related comment.\n+            commentSize = issue.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+\n+            \/\/ Change the pr title to wrong issue id\n+            pr.setTitle(\"2: \" + issue.title());\n+\n+            \/\/ Use the command `request-approval` again.\n+            pr.addComment(\"\/request-approval request-approval-test\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            commentSize = pr.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the main issue of the pull request title is not found\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue shouldn't have related comment.\n+            commentSize = issue.store().comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/RequestApprovalCommandTests.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+include 'bots:approval'\n","filename":"settings.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import java.util.stream.Collectors;\n@@ -82,0 +81,16 @@\n+    public boolean isOpen() {\n+        return state == Issue.State.OPEN;\n+    }\n+\n+    public boolean isClosed() {\n+        return state == Issue.State.CLOSED;\n+    }\n+\n+    public boolean isResolved() {\n+        return state == Issue.State.RESOLVED;\n+    }\n+\n+    public boolean isFixed() {\n+        return isResolved();\n+    }\n+\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestIssueStore.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"}]}