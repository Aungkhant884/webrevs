{"files":[{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bot;\n+\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.openjdk.skara.forge.HostedRepository;\n+\n+public record ApprovalInfo(HostedRepository repo, Pattern branchPattern,\n+                           String requestLabel, String approvalLabel,\n+                           String disapprovalLabel, Set<String> maintainers) {\n+}\n","filename":"bot\/src\/main\/java\/org\/openjdk\/skara\/bot\/ApprovalInfo.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module {\n+    name = \"org.openjdk.skara.bots.approval\"\n+    test {\n+        requires 'org.junit.jupiter.api'\n+        requires 'org.openjdk.skara.test'\n+        opens 'org.openjdk.skara.bots.approval' to 'org.junit.platform.commons'\n+    }\n+}\n+\n+dependencies {\n+    implementation project(':host')\n+    implementation project(':bot')\n+    implementation project(':forge')\n+    implementation project(':issuetracker')\n+    implementation project(':census')\n+    implementation project(':ci')\n+    implementation project(':json')\n+    implementation project(':vcs')\n+    implementation project(':metrics')\n+    implementation project(':jcheck')\n+    implementation project(':jbs')\n+\n+    testImplementation project(':test')\n+}\n","filename":"bots\/approval\/build.gradle","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module org.openjdk.skara.bots.approval {\n+    requires org.openjdk.skara.bot;\n+    requires org.openjdk.skara.vcs;\n+    requires org.openjdk.skara.forge;\n+    requires org.openjdk.skara.issuetracker;\n+    requires org.openjdk.skara.jcheck;\n+    requires org.openjdk.skara.jbs;\n+    requires java.logging;\n+\n+    provides org.openjdk.skara.bot.BotFactory with org.openjdk.skara.bots.approval.ApprovalBotFactory;\n+}\n+\n","filename":"bots\/approval\/src\/main\/java\/module-info.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import java.util.List;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.bot.Bot;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+\n+public abstract class AbstractApprovalBot implements Bot {\n+    private final List<ApprovalInfo> approvalInfos;\n+    private final IssueProject issueProject;\n+\n+    AbstractApprovalBot(List<ApprovalInfo> approvalInfos, IssueProject issueProject) {\n+        this.approvalInfos = approvalInfos;\n+        this.issueProject = issueProject;\n+    }\n+\n+    List<ApprovalInfo> approvalInfos() {\n+        return approvalInfos;\n+    }\n+\n+    IssueProject issueProject() {\n+        return issueProject;\n+    }\n+\n+    boolean requiresApproval(PullRequest pr) {\n+        return approvalInfos != null &&\n+                approvalInfos.stream().anyMatch(info -> approvalInfoMatch(info, pr));\n+    }\n+\n+    boolean approvalInfoMatch(ApprovalInfo info, PullRequest pr) {\n+        return info.repo().isSame(pr.repository()) &&\n+                info.branchPattern().matcher(pr.targetRef()).matches();\n+    }\n+}\n","filename":"bots\/approval\/src\/main\/java\/org\/openjdk\/skara\/bots\/approval\/AbstractApprovalBot.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.bot.Bot;\n+import org.openjdk.skara.bot.BotConfiguration;\n+import org.openjdk.skara.bot.BotFactory;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+\n+public class ApprovalBotFactory implements BotFactory {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.approval\");\n+    static final String NAME = \"approval\";\n+\n+    @Override\n+    public String name() {\n+        return NAME;\n+    }\n+\n+    @Override\n+    public List<Bot> create(BotConfiguration configuration) {\n+        var botList = new ArrayList<Bot>();\n+        var specific = configuration.specific();\n+        var issueProjects = new HashSet<IssueProject>();\n+        var repositories = new HashMap<IssueProject, List<HostedRepository>>();\n+        var approvalInfoMap = new HashMap<IssueProject, List<ApprovalInfo>>();\n+\n+        for (var project : specific.get(\"projects\").asArray()) {\n+            var repo = configuration.repository(project.get(\"repository\").asString());\n+            var issueProject = configuration.issueProject(project.get(\"issues\").asString());\n+            issueProjects.add(issueProject);\n+            if (!approvalInfoMap.containsKey(issueProject)) {\n+                approvalInfoMap.put(issueProject, new ArrayList<>());\n+            }\n+            if (!repositories.containsKey(issueProject)) {\n+                repositories.put(issueProject, new ArrayList<>());\n+            }\n+            repositories.get(issueProject).add(repo);\n+\n+            var approvalInfoList = new ArrayList<ApprovalInfo>();\n+            for (var branchInfo : project.get(\"approval\").asArray()) {\n+                var requestLabel = branchInfo.get(\"request-label\").asString();\n+                var approvalLabel = branchInfo.get(\"approval-label\").asString();\n+                var disapprovalLabel = branchInfo.get(\"disapproval-label\").asString();\n+                var maintainers = new HashSet<String>();\n+                if (branchInfo.contains(\"maintainers\")) {\n+                    for (var maintainer : branchInfo.get(\"maintainers\").asArray()) {\n+                        maintainers.add(maintainer.asString());\n+                    }\n+                }\n+                approvalInfoList.add(new ApprovalInfo(repo, Pattern.compile(branchInfo.get(\"branch\").asString()),\n+                        requestLabel, approvalLabel, disapprovalLabel, maintainers));\n+            }\n+            approvalInfoMap.get(issueProject).addAll(approvalInfoList);\n+            var pullRequestBot = new ApprovalPullRequestBot(repo, issueProject, approvalInfoList);\n+            log.info(\"Setting up approval pull request bot for \" + repo.name());\n+            botList.add(pullRequestBot);\n+        }\n+\n+        for (var issueProject : issueProjects) {\n+            log.info(\"Setting up approval issue bot for \" + issueProject.name());\n+            botList.add(new ApprovalIssueBot(issueProject, repositories.get(issueProject), approvalInfoMap.get(issueProject)));\n+        }\n+\n+        return botList;\n+    }\n+}\n","filename":"bots\/approval\/src\/main\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalBotFactory.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.bot.Bot;\n+import org.openjdk.skara.bot.WorkItem;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+import org.openjdk.skara.issuetracker.UpdatedIssuePoller;\n+\n+public class ApprovalIssueBot extends AbstractApprovalBot implements Bot {\n+    private final List<HostedRepository> repositories;\n+    private final UpdatedIssuePoller poller;\n+\n+    public ApprovalIssueBot(IssueProject issueProject, List<HostedRepository> repositories, List<ApprovalInfo> approvalInfos) {\n+        super(approvalInfos, issueProject);\n+        this.repositories = repositories;\n+        this.poller = new UpdatedIssuePoller(issueProject);\n+    }\n+\n+    public List<HostedRepository> repositories() {\n+        return repositories;\n+    }\n+\n+    @Override\n+    public List<WorkItem> getPeriodicItems() {\n+        var items = new ArrayList<WorkItem>();\n+        for (var issue : poller.getUpdatedIssues(IssueProject::issues)) {\n+            var issueWorkItem = new ApprovalIssueWorkItem(this, issue);\n+            items.add(issueWorkItem);\n+        }\n+        return items;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return ApprovalBotFactory.NAME;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ApprovalIssueBot@\" + issueProject().name();\n+    }\n+}\n","filename":"bots\/approval\/src\/main\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalIssueBot.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import org.openjdk.skara.bot.WorkItem;\n+import org.openjdk.skara.forge.PullRequestUtils;\n+import org.openjdk.skara.issuetracker.Issue;\n+\n+public class ApprovalIssueWorkItem implements WorkItem {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.approval\");\n+    private final ApprovalIssueBot bot;\n+    private final Issue issue;\n+\n+    public ApprovalIssueWorkItem(ApprovalIssueBot bot, Issue issue) {\n+        this.bot = bot;\n+        this.issue = issue;\n+    }\n+\n+    @Override\n+    public Collection<WorkItem> run(Path scratchPath) {\n+        return PullRequestUtils.pullRequestCommentLink(issue).stream()\n+                .flatMap(uri -> bot.repositories().stream()\n+                             .flatMap(r -> r.parsePullRequestUrl(uri.toString()).stream()))\n+                .filter(pr -> pr.isOpen() && bot.requiresApproval(pr))\n+                .map(pr -> new ApprovalPullRequestWorkItem(pr.repository(), pr.id(), issue.project(),\n+                        bot.approvalInfos().stream().filter(info -> bot.approvalInfoMatch(info, pr)).findFirst().get()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public String botName() {\n+        return ApprovalBotFactory.NAME;\n+    }\n+\n+    @Override\n+    public String workItemName() {\n+        return \"approval-issue\";\n+    }\n+\n+    @Override\n+    public boolean concurrentWith(WorkItem other) {\n+        if (!(other instanceof ApprovalIssueWorkItem item)) {\n+            return true;\n+        }\n+\n+        return !(issue.project().name().equals(item.issue.project().name()) && issue.id().equals(item.issue.id()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return botName() + \"\/ApprovalIssueWorkItem@\" + issue.id();\n+    }\n+}\n","filename":"bots\/approval\/src\/main\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalIssueWorkItem.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.bot.Bot;\n+import org.openjdk.skara.bot.WorkItem;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.forge.UpdatedPullRequestPoller;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+\n+public class ApprovalPullRequestBot extends AbstractApprovalBot implements Bot {\n+    private final HostedRepository repository;\n+    private final UpdatedPullRequestPoller poller;\n+\n+    public ApprovalPullRequestBot(HostedRepository repository, IssueProject issueProject,\n+                                  List<ApprovalInfo> approvalInfos) {\n+        super(approvalInfos, issueProject);\n+        this.repository = repository;\n+        this.poller = new UpdatedPullRequestPoller(repository);\n+    }\n+\n+    @Override\n+    public List<WorkItem> getPeriodicItems() {\n+        var items = new ArrayList<WorkItem>();\n+        for (var pr : poller.getUpdatedPullRequests(HostedRepository::openPullRequestsAfter, HostedRepository::pullRequests)) {\n+            if (requiresApproval(pr)) {\n+                var pullRequestWorkItem = new ApprovalPullRequestWorkItem(repository, pr.id(), issueProject(),\n+                                approvalInfos().stream().filter(info -> approvalInfoMatch(info, pr)).findFirst().get());\n+                items.add(pullRequestWorkItem);\n+            }\n+        }\n+        return items;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return ApprovalBotFactory.NAME;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ApprovalPullRequestBot@\" + repository.name();\n+    }\n+}\n","filename":"bots\/approval\/src\/main\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalPullRequestBot.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.bot.WorkItem;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+import org.openjdk.skara.vcs.openjdk.Issue;\n+\n+public class ApprovalPullRequestWorkItem implements WorkItem {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.approval\");\n+    \/\/ The tag to re-run the CheckWorkItem of the PRBot.\n+    static final String APPROVAL_UPDATE_MARKER = \"<!-- approval: 'update' -->\";\n+    static final String PROGRESS_MARKER = \"<!-- Anything below this marker will be automatically updated, please do not edit manually! -->\";\n+\n+    private final HostedRepository repo;\n+    private final String prId;\n+    private final IssueProject issueProject;\n+    private final ApprovalInfo approvalInfo;\n+\n+    public ApprovalPullRequestWorkItem(HostedRepository repo, String prId,\n+                                       IssueProject issueProject,\n+                                       ApprovalInfo approvalInfo) {\n+        this.repo = repo;\n+        this.prId = prId;\n+        this.issueProject = issueProject;\n+        this.approvalInfo = approvalInfo;\n+    }\n+\n+    private String describe(PullRequest pr) {\n+        return pr.repository().name() + \"#\" + pr.id();\n+    }\n+\n+    private String getStatusMessage(PullRequest pr) {\n+        var lastIndex = pr.body().lastIndexOf(PROGRESS_MARKER);\n+        if (lastIndex == -1) {\n+            return \"\";\n+        } else {\n+            return pr.body().substring(lastIndex);\n+        }\n+    }\n+\n+    private void addUpdateMarker(PullRequest pr) {\n+        var statusMessage = getStatusMessage(pr);\n+        if (!statusMessage.contains(APPROVAL_UPDATE_MARKER)) {\n+            pr.setBody(pr.body() + \"\\n\" + APPROVAL_UPDATE_MARKER + \"\\n\");\n+        } else {\n+            log.info(\"The pull request \" + describe(pr) + \" has already had a approval update marker. \"\n+                    + \"Do not need to add it again.\");\n+        }\n+    }\n+\n+    private boolean hasApprovalProgressChecked(PullRequest pr) {\n+        var statusMessage = getStatusMessage(pr);\n+        return statusMessage.contains(\"- [x] Change must be properly approved by the maintainers\");\n+    }\n+\n+    private boolean hasApprovalProgress(PullRequest pr) {\n+        var statusMessage = getStatusMessage(pr);\n+        return statusMessage.contains(\"- [ ] Change must be properly approved by the maintainers\") ||\n+                statusMessage.contains(\"- [x] Change must be properly approved by the maintainers\");\n+    }\n+\n+    @Override\n+    public Collection<WorkItem> run(Path scratchPath) {\n+        var pr = repo.pullRequest(prId);\n+        var vcsIssue = Issue.fromStringRelaxed(pr.title());\n+        if (vcsIssue.isEmpty()) {\n+            log.info(\"No issue found in title for \" + describe(pr));\n+            return List.of();\n+        }\n+        var issueOpt = vcsIssue.flatMap(value -> issueProject.issue(value.shortId()));\n+        if (issueOpt.isEmpty()) {\n+            log.info(\"No issue found in JBS for \" + describe(pr));\n+            return List.of();\n+        }\n+        var issue = issueOpt.get();\n+\n+        if (!hasApprovalProgress(pr)) {\n+            log.info(\"The PR body of \" + describe(pr) + \" doesn't have the approval progress, adding the approval update marker.\");\n+            addUpdateMarker(pr);\n+        }\n+\n+        if (issue.labelNames().contains(approvalInfo.approvalLabel()) ||\n+                issue.labelNames().contains(approvalInfo.disapprovalLabel())) {\n+            if (!issue.labelNames().contains(approvalInfo.requestLabel())) {\n+                \/\/ The issue has the approval or disapproval label, it should always have a fix request label.\n+                log.info(\"The issue \" + issue.id() + \" has the approval or disapproval label, \"\n+                        + \"adding the missed fix request label for it.\");\n+                issue.addLabel(approvalInfo.requestLabel());\n+            }\n+            if (pr.labelNames().contains(\"approval\")) {\n+                log.info(\"The issue \" + issue.id() + \" has the approval or disapproval label, \"\n+                        + \"removing the `approval` blocked label for \" + describe(pr));\n+                pr.removeLabel(\"approval\");\n+            }\n+            if (issue.labelNames().contains(approvalInfo.approvalLabel()) && !hasApprovalProgressChecked(pr)) {\n+                log.info(\"The issue \" + issue.id() + \" has the approval label and the approval progress of the \"\n+                        + describe(pr) + \" is not checked, adding the approval update marker.\");\n+                addUpdateMarker(pr);\n+            }\n+            if (issue.labelNames().contains(approvalInfo.disapprovalLabel()) && pr.isOpen()) {\n+                log.info(\"The issue \" + issue.id() + \" has the disapproval label and the approval progress of the \"\n+                        + describe(pr) + \" is checked, adding the approval update marker.\");\n+                addUpdateMarker(pr);\n+            }\n+        }\n+        return List.of();\n+    }\n+\n+    @Override\n+    public boolean concurrentWith(WorkItem other) {\n+        if (!(other instanceof ApprovalPullRequestWorkItem item)) {\n+            return true;\n+        }\n+\n+        return !(repo.isSame(item.repo) && prId.equals(item.prId));\n+    }\n+\n+    @Override\n+    public String botName() {\n+        return ApprovalBotFactory.NAME;\n+    }\n+\n+    @Override\n+    public String workItemName() {\n+        return \"approval-pr\";\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return botName() + \"\/ApprovalPullRequestWorkItem@\" + repo.name() + \"#\" + prId;\n+    }\n+}\n","filename":"bots\/approval\/src\/main\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalPullRequestWorkItem.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.openjdk.skara.bots.approval.ApprovalPullRequestWorkItem.APPROVAL_UPDATE_MARKER;\n+import static org.openjdk.skara.bots.approval.ApprovalPullRequestWorkItem.PROGRESS_MARKER;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.forge.PullRequestUtils;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.CheckableRepository;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+import org.openjdk.skara.test.TestBotRunner;\n+\n+public class ApprovalIssueBotTests {\n+    @Test\n+    void testTriggerPullRequestWorkItem(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalIssueBot(issueProject, List.of(author),\n+                    List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\" , \"test-fix-yes\" , \"test-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\" , \"master-fix-yes\" , \"master-fix-no\" , Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\" , \"jdk18-fix-yes\" , \"jdk18-fix-no\" , Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\" , List.of(), Map.of());\n+            issue.setProperty(\"issuetype\" , JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\" , true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\" , true);\n+\n+            \/\/ Create a pull request\n+            var pr = credentials.createPullRequest(author, \"master\" , \"edit\" ,\n+                    issue.id() + \": \" + issue.title(), List.of(\"PR body\" , PROGRESS_MARKER));\n+            PullRequestUtils.postPullRequestLinkComment(issue, pr);\n+\n+            \/\/ run the approval issue bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The existing issue won't trigger the ApprovalIssueWorkItem and ApprovalPullRequestWorkItem.\n+            assertFalse(pr.body().contains(APPROVAL_UPDATE_MARKER));\n+\n+            \/\/ Update the issue\n+            issue.addLabel(\"master-fix-request\");\n+            \/\/ Now the pull request body doesn't have the update marker.\n+            assertFalse(pr.body().contains(APPROVAL_UPDATE_MARKER));\n+\n+            \/\/ Run the approval issue bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The updated issue trigger the ApprovalIssueWorkItem and ApprovalPullRequestWorkItem,\n+            \/\/ so the update marker is added to the pull request body.\n+            assertTrue(pr.body().contains(APPROVAL_UPDATE_MARKER));\n+\n+            \/\/ Update the issue again.\n+            issue.removeLabel(\"master-fix-request\");\n+            issue.addLabel(\"master-fix-yes\");\n+            \/\/ Now the issue doesn't have the fix request label.\n+            assertFalse(issue.labelNames().contains(\"master-fix-request\"));\n+\n+            \/\/ Run the approval issue bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The updated issue trigger the ApprovalIssueWorkItem and ApprovalPullRequestWorkItem,\n+            \/\/ so the fix request label is added to the issue automatically.\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+        }\n+    }\n+}\n","filename":"bots\/approval\/src\/test\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalIssueBotTests.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.approval;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.openjdk.skara.bots.approval.ApprovalPullRequestWorkItem.APPROVAL_UPDATE_MARKER;\n+import static org.openjdk.skara.bots.approval.ApprovalPullRequestWorkItem.PROGRESS_MARKER;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.forge.Review;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.CheckableRepository;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+import org.openjdk.skara.test.TestBotRunner;\n+\n+public class ApprovalPullRequestBotTests {\n+    @Test\n+    void testApproval(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalPullRequestBot(author, issueProject, List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                            \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                    new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                            \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                    new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                            \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\",\n+                    issue.id() + \": \" + issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            pr.setBody(pr.body() + \"\\n- [ ] Change must be properly approved by the maintainers\");\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Simulate the PRBot. Add the `approval` label to the pull request.\n+            pr.addLabel(\"approval\");\n+            \/\/ Simulate the PRBot. Add the `master-fix-request` label to the issue.\n+            issue.addLabel(\"master-fix-request\");\n+\n+            \/\/ Approve the update change.\n+            issue.addLabel(\"master-fix-yes\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should remove the `approval` label of the pull request.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ The bot should add the approval update marker.\n+            assertTrue(pr.body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+\n+    @Test\n+    void testDisapproval(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalPullRequestBot(author, issueProject, List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                            \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                    new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                            \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                    new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                            \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\",\n+                    issue.id() + \": \" + issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            pr.setBody(pr.body() + \"\\n- [ ] Change must be properly approved by the maintainers\");\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Simulate the PRBot. Add the `approval` label to the pull request.\n+            pr.addLabel(\"approval\");\n+            \/\/ Simulate the PRBot. Add the `master-fix-request` label to the issue.\n+            issue.addLabel(\"master-fix-request\");\n+\n+            \/\/ Reject the update change.\n+            issue.addLabel(\"master-fix-no\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should remove the `approval` label of the pull request.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ The bot should add the approval update marker.\n+            assertTrue(pr.body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+\n+    @Test\n+    void testNoFixRequest(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalPullRequestBot(author, issueProject, List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                            \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                    new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                            \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                    new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                            \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\",\n+                    issue.id() + \": \" + issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            pr.setBody(pr.body() + \"\\n- [ ] Change must be properly approved by the maintainers\");\n+\n+            \/\/ Don't review the pr, so the update change is not ready for approval.\n+            \/\/ Don't add the `approval` label to the pull request.\n+            \/\/ Don't add the `master-fix-request` label to the issue.\n+\n+            \/\/ Approve the update change.\n+            issue.addLabel(\"master-fix-yes\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should add the fix request label to the issue.\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            \/\/ The pull request shouldn't have the `approval` label.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ The bot should add the approval update marker.\n+            assertTrue(pr.body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+\n+    @Test\n+    void testWrongCheckedProgress(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalPullRequestBot(author, issueProject, List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                            \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                    new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                            \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                    new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                            \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\",\n+                    issue.id() + \": \" + issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Simulate the PRBot. Add the `approval` label to the pull request.\n+            pr.addLabel(\"approval\");\n+            \/\/ Simulate the PRBot. Add the `master-fix-request` label to the issue.\n+            issue.addLabel(\"master-fix-request\");\n+\n+            \/\/ The progress has been checked because of previous approval.\n+            pr.setBody(pr.body() + \"\\n- [x] Change must be properly approved by the maintainers\");\n+\n+            \/\/ Reject the update change.\n+            issue.addLabel(\"master-fix-no\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The pull request shouldn't have the `approval` label.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ The bot should add the approval update marker.\n+            assertTrue(pr.body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+\n+    @Test\n+    void testWrongIssue(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bot = new ApprovalPullRequestBot(author, issueProject, List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))));\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request which has the wrong title.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.title(), List.of(\"PR body\", PROGRESS_MARKER));\n+            pr.setBody(pr.body() + \"\\n- [ ] Change must be properly approved by the maintainers\");\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Simulate the PRBot. Add the `approval` label to the pull request.\n+            pr.addLabel(\"approval\");\n+            \/\/ Simulate the PRBot. Add the `master-fix-request` label to the issue.\n+            issue.addLabel(\"master-fix-request\");\n+\n+            \/\/ Approve the update change.\n+            issue.addLabel(\"master-fix-yes\");\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot shouldn't remove the `approval` label of the pull request.\n+            assertTrue(pr.labelNames().contains(\"approval\"));\n+            \/\/ The bot shouldn't add the approval update marker.\n+            assertFalse(pr.body().contains(APPROVAL_UPDATE_MARKER));\n+\n+            \/\/ Change the pr title to wrong issue id\n+            pr.setTitle(\"2: \" + issue.title());\n+\n+            \/\/ run the approval pull request bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot shouldn't remove the `approval` label of the pull request.\n+            assertTrue(pr.labelNames().contains(\"approval\"));\n+            \/\/ The bot shouldn't add the approval update marker.\n+            assertFalse(pr.body().contains(APPROVAL_UPDATE_MARKER));\n+        }\n+    }\n+}\n","filename":"bots\/approval\/src\/test\/java\/org\/openjdk\/skara\/bots\/approval\/ApprovalPullRequestBotTests.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+    implementation project(':bots:approval')\n","filename":"bots\/cli\/build.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.List;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.Comment;\n+import org.openjdk.skara.issuetracker.Issue;\n+\n+public class ApprovalCommand implements CommandHandler {\n+    \/\/ The tags to re-run the CheckWorkItem of the PRBot.\n+    private static final String APPROVAL_MARKER = \"<!-- approval: 'yes' -->\";\n+    private static final String DISAPPROVAL_MARKER = \"<!-- approval: 'no' -->\";\n+\n+    private static void showHelp(PrintWriter writer) {\n+        writer.println(\"\"\"\n+                usage: `\/approval [yes|no|y|n]`\n+\n+                examples:\n+                * `\/approval`\n+                * `\/approval yes`\n+                * `\/approval no`\n+\n+                Note: Only the repository maintainers are allowed to use the `approval` command.\n+                \"\"\");\n+    }\n+\n+    private void approvalReply(PullRequest pr, PrintWriter writer) {\n+        writer.println(\"@\" + pr.author().username() + \" this pull request was approved by the maintainer.\");\n+        writer.println(APPROVAL_MARKER);\n+    }\n+\n+    private void disapprovalReply(PullRequest pr, PrintWriter writer) {\n+        writer.println(String.format(\"@%s this pull request was rejected by the maintainer. \"\n+                + \"This pull request will be closed.\", pr.author().username()));\n+        writer.println(DISAPPROVAL_MARKER);\n+    }\n+\n+    @Override\n+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                       CommandInvocation command, List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem) {\n+        if (!workItem.requiresApproval()) {\n+            reply.println(\"the `approval` command can only be used on pull requests targeting branches and repositories that require approval.\");\n+            return;\n+        }\n+\n+        var commandUser = censusInstance.namespace().get(command.user().id());\n+        if (!workItem.isMaintainer(commandUser)) {\n+            reply.println(\"only the repository maintainers are allowed to use the `approval` command.\");\n+            return;\n+        }\n+\n+        var arg = command.args().trim().toLowerCase();\n+        if (!arg.isEmpty() && !(arg.equals(\"yes\") || arg.equals(\"y\") || arg.equals(\"no\") || arg.equals(\"n\"))) {\n+            showHelp(reply);\n+            return;\n+        }\n+\n+        if (arg.equals(\"no\") || arg.equals(\"n\")) {\n+            for (var vcsIssue : workItem.issues(false, false)) {\n+                var issueOpt = bot.issueProject().issue(vcsIssue.shortId());\n+                issueOpt.ifPresent(issue -> {\n+                    if (!issue.labelNames().contains(workItem.requestLabelName())) {\n+                        \/\/ The maintainers may disapprove the PR before it is ready.\n+                        \/\/ The bot should add the fix request label firstly to avoid the strange\n+                        \/\/ middle state which has disapproval label but has no fix request label.\n+                        issue.addLabel(workItem.requestLabelName());\n+                    }\n+                    if (issue.labelNames().contains(workItem.approvalLabelName())) {\n+                        \/\/ If the maintainers have approved the PR before,\n+                        \/\/ the bot should remove the approval label first.\n+                        issue.removeLabel(workItem.approvalLabelName());\n+                    }\n+                    if (!issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                        issue.addLabel(workItem.disapprovalLabelName());\n+                    }\n+                });\n+            }\n+            if (pr.labelNames().contains(\"approval\")) {\n+                pr.removeLabel(\"approval\");\n+            }\n+            disapprovalReply(pr, reply);\n+            pr.setState(Issue.State.CLOSED);\n+            return;\n+        }\n+\n+        pr.setState(Issue.State.OPEN);\n+        for (var vcsIssue : workItem.issues(false, false)) {\n+            var issueOpt = bot.issueProject().issue(vcsIssue.shortId());\n+            issueOpt.ifPresent(issue -> {\n+                if (!issue.labelNames().contains(workItem.requestLabelName())) {\n+                    \/\/ The maintainers may approve the PR before it is ready.\n+                    \/\/ The bot should add the fix request label firstly to avoid the strange\n+                    \/\/ middle state which has approval label but has no fix request label.\n+                    issue.addLabel(workItem.requestLabelName());\n+                }\n+                if (issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                    \/\/ If the maintainers have disapproved the PR before,\n+                    \/\/ the bot should remove the disapproval label first.\n+                    issue.removeLabel(workItem.disapprovalLabelName());\n+                }\n+                if (!issue.labelNames().contains(workItem.approvalLabelName())) {\n+                    issue.addLabel(workItem.approvalLabelName());\n+                }\n+            });\n+        }\n+        if (pr.labelNames().contains(\"approval\")) {\n+            pr.removeLabel(\"approval\");\n+        }\n+        approvalReply(pr, reply);\n+    }\n+\n+    @Override\n+    public boolean allowedInBody() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"approve or disapprove a pull request which needs maintainer's approval\";\n+    }\n+}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/ApprovalCommand.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -72,1 +72,2 @@\n-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {\n+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                       CommandInvocation command, List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem) {\n@@ -109,1 +110,1 @@\n-            var versionOpt = CheckRun.getVersion(pr);\n+            var versionOpt = workItem.getVersion();\n@@ -165,1 +166,1 @@\n-        var versionOpt = CheckRun.getVersion(pr);\n+        var versionOpt = workItem.getVersion();\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CSRCommand.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import org.openjdk.skara.jbs.Backports;\n-import org.openjdk.skara.jbs.JdkVersion;\n-import org.openjdk.skara.jcheck.JCheckConfiguration;\n@@ -70,0 +67,2 @@\n+    private static final String APPROVAL_SUGGESTION_MARKER = \"<!-- Approval suggestion comment -->\";\n+    private static final String APPROVAL_PROGRESS = \"All issues must be [approved](https:\/\/openjdk.org\/projects\/jdk-updates\/approval.html) by a maintainer\";\n@@ -117,80 +116,0 @@\n-    private List<Issue> issues(boolean withCsr, boolean withJep) {\n-        var issue = Issue.fromStringRelaxed(pr.title());\n-        if (issue.isPresent()) {\n-            var issues = new ArrayList<Issue>();\n-            issues.add(issue.get());\n-            issues.addAll(SolvesTracker.currentSolved(pr.repository().forge().currentUser(), comments));\n-            if (withCsr) {\n-                getCsrIssue(issue.get()).ifPresent(issues::add);\n-            }\n-            if (withJep) {\n-                getJepIssue().ifPresent(issues::add);\n-            }\n-            return issues;\n-        }\n-        return List.of();\n-    }\n-\n-    \/**\n-     * Get the fix version from the provided PR.\n-     *\/\n-    public static Optional<JdkVersion> getVersion(PullRequest pullRequest) {\n-        var confFile = pullRequest.repository().fileContents(\".jcheck\/conf\", pullRequest.targetRef());\n-        var configuration = JCheckConfiguration.parse(confFile.lines().toList());\n-        var version = configuration.general().version().orElse(null);\n-        if (version == null || \"\".equals(version)) {\n-            return Optional.empty();\n-        }\n-        return JdkVersion.parse(version);\n-    }\n-\n-    \/**\n-     * Get the csr issue. Note: this `Issue` is not the issue in module `issuetracker`.\n-     *\/\n-    private Optional<Issue> getCsrIssue(Issue issue) {\n-        var issueProject = issueProject();\n-        if (issueProject == null) {\n-            return Optional.empty();\n-        }\n-        var jbsIssueOpt = issueProject.issue(issue.shortId());\n-        if (jbsIssueOpt.isEmpty()) {\n-            return Optional.empty();\n-        }\n-\n-        var versionOpt = getVersion(pr);\n-        if (versionOpt.isEmpty()) {\n-            return Optional.empty();\n-        }\n-\n-        return Backports.findCsr(jbsIssueOpt.get(), versionOpt.get())\n-                .flatMap(perIssue -> Issue.fromStringRelaxed(perIssue.id() + \": \" + perIssue.title()));\n-    }\n-\n-    private Optional<Issue> getJepIssue() {\n-        var comment = getJepComment();\n-        if (comment.isPresent()) {\n-            return Issue.fromStringRelaxed(comment.get().group(2) + \": \" + comment.get().group(3));\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private Optional<Matcher> getJepComment() {\n-        var jepComment = pr.comments().stream()\n-                .filter(comment -> comment.author().equals(pr.repository().forge().currentUser()))\n-                .flatMap(comment -> comment.body().lines())\n-                .map(JEPCommand.jepMarkerPattern::matcher)\n-                .filter(Matcher::find)\n-                .reduce((first, second) -> second)\n-                .orElse(null);\n-        if (jepComment == null) {\n-            return Optional.empty();\n-        }\n-\n-        var issueId = jepComment.group(2);\n-        if (\"unneeded\".equals(issueId)) {\n-            return  Optional.empty();\n-        }\n-\n-        return Optional.of(jepComment);\n-    }\n-\n@@ -246,0 +165,1 @@\n+        var issueOpt = Issue.fromStringRelaxed(pr.title());\n@@ -250,1 +170,1 @@\n-            var csrIssue = Issue.fromStringRelaxed(pr.title()).flatMap(this::getCsrIssue)\n+            var csrIssue = issueOpt.flatMap(workItem::getCsrIssue)\n@@ -267,1 +187,1 @@\n-            var comment = getJepComment();\n+            var comment = workItem.getJepComment();\n@@ -272,0 +192,16 @@\n+\n+        if (workItem.requiresApproval()) {\n+            var issue = issueOpt.flatMap(value -> issueProject() != null ? issueProject().issue(value.shortId()) : Optional.empty());\n+            if (issue.isPresent()) {\n+                if (issue.get().labelNames().contains(workItem.approvalLabelName())) {\n+                    ret.put(APPROVAL_PROGRESS, true);\n+                } else {\n+                    \/\/ The main issue doesn't have the approval label.\n+                    ret.put(APPROVAL_PROGRESS, false);\n+                }\n+            } else {\n+                \/\/ The PR doesn't have an issue.\n+                ret.put(APPROVAL_PROGRESS, false);\n+            }\n+        }\n+\n@@ -289,1 +225,1 @@\n-        var issues = issues(false, false);\n+        var issues = workItem.issues(false, false);\n@@ -598,1 +534,1 @@\n-        var issues = issues(true, true);\n+        var issues = workItem.issues(true, true);\n@@ -1016,0 +952,101 @@\n+    \/**\n+     * Add or update a suggestion comment to the pull request which needs the maintainer's approval to direct the developers.\n+     *\/\n+    private void updateApprovalSuggestionComment() {\n+        var message = new StringBuilder();\n+        message.append(\"@\");\n+        message.append(pr.author().username());\n+        message.append(\" \");\n+        message.append(\"\"\"\n+                This pull request requires [maintainer approval]\\\n+                (https:\/\/openjdk.org\/projects\/jdk-updates\/approval.html).\n+\n+                As a convenience, or if you don't have permission to post comments in JBS, \\\n+                you may use the command `\/request-approval` to supply the fix request comment \\\n+                and automatically set the correct request label.\n+                usage: `\/request-approval <comment-text>`\n+\n+                Please note that approval discussions should take place in the issue and not in the pull request.\n+                \"\"\");\n+        message.append(APPROVAL_SUGGESTION_MARKER);\n+        var existing = findComment(comments, APPROVAL_SUGGESTION_MARKER);\n+        if (existing.isPresent()) {\n+            pr.updateComment(existing.get().id(), message.toString());\n+        } else {\n+            pr.addComment(message.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Update labels of the issue and PR which need the maintainer's approval (usually backport).\n+     *\/\n+    private void updateLabelsAboutApproval(boolean readyForApproval) {\n+        if (issueProject() == null) {\n+            return;\n+        }\n+        var mainIssueOpt = Issue.fromStringRelaxed(pr.title()).flatMap(value -> issueProject().issue(value.shortId()));\n+        var issues = workItem.issues(false, false);\n+        for (var vcsIssue : issues) {\n+            var issueOpt = issueProject().issue(vcsIssue.shortId());\n+            if (issueOpt.isPresent()) {\n+                var issue = issueOpt.get();\n+                if (mainIssueOpt.isPresent() && !mainIssueOpt.get().id().equals(issue.id()) &&\n+                        mainIssueOpt.get().labelNames().contains(workItem.approvalLabelName())) {\n+                    \/\/ If approval label was only added to the main issue, the bot should add it to all the issues.\n+                    if (issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                        \/\/ Remove the previously existing disapproval label.\n+                        issue.removeLabel(workItem.disapprovalLabelName());\n+                    }\n+                    if (!issue.labelNames().contains(workItem.approvalLabelName())) {\n+                        issue.addLabel(workItem.approvalLabelName());\n+                    }\n+                } else if (mainIssueOpt.isPresent() && !mainIssueOpt.get().id().equals(issue.id()) &&\n+                        mainIssueOpt.get().labelNames().contains(workItem.disapprovalLabelName())) {\n+                    \/\/ If disapproval label was only added to the main issue, the bot should add it to all the issues.\n+                    if (issue.labelNames().contains(workItem.approvalLabelName())) {\n+                        \/\/ Remove the previously existing approval label.\n+                        issue.removeLabel(workItem.approvalLabelName());\n+                    }\n+                    if (!issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                        issue.addLabel(workItem.disapprovalLabelName());\n+                    }\n+                }\n+                if (readyForApproval && !issue.labelNames().contains(workItem.requestLabelName())) {\n+                    \/\/ Add the fix request label to the issue if the PR is ready for approval.\n+                    issue.addLabel(workItem.requestLabelName());\n+                } else if (!readyForApproval && issue.labelNames().contains(workItem.requestLabelName()) &&\n+                        !issue.labelNames().contains(workItem.approvalLabelName()) &&\n+                        !issue.labelNames().contains(workItem.disapprovalLabelName())) {\n+                    \/\/ Remove the fix request label of the issue if the PR is not ready for approval\n+                    \/\/ and the issue has not been approved or disapproved.\n+                    \/\/ One condition which causes this: firstly, the PR is ready for approval (such as a clean backport),\n+                    \/\/ so the bot adds the fix request label to the issue. Then the author of the PR submits\n+                    \/\/ new code to the PR which needs to be reviewed or other things occur so that the PR becomes not\n+                    \/\/ ready for approval, the bot should remove the fix request label to reduce the work of the maintainers.\n+                    issue.removeLabel(workItem.requestLabelName());\n+                }\n+            }\n+        }\n+\n+        if (mainIssueOpt.isPresent()) {\n+            if (readyForApproval && !mainIssueOpt.get().labelNames().contains(workItem.approvalLabelName()) &&\n+                    !mainIssueOpt.get().labelNames().contains(workItem.disapprovalLabelName())) {\n+                if (!pr.labelNames().contains(\"approval\")) {\n+                    \/\/ Add `approval` label to PR if the PR is ready for approval and the PR has not been approved.\n+                    pr.addLabel(\"approval\");\n+                }\n+            } else {\n+                \/\/ The pull request is not ready for approval or the main issue contains approval or disapproval label.\n+                if (pr.labelNames().contains(\"approval\")) {\n+                    \/\/ Remove `approval` label of PR if the PR has been approved or disapproved.\n+                    pr.removeLabel(\"approval\");\n+                }\n+                if (mainIssueOpt.get().labelNames().contains(workItem.disapprovalLabelName()) && pr.isOpen()) {\n+                    pr.addComment(String.format(\"@%s this pull request was rejected by the maintainer. \"\n+                            + \"The bot will close this pull request automatically.\", pr.author().username()));\n+                    pr.setState(org.openjdk.skara.issuetracker.Issue.State.CLOSED);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1119,0 +1156,17 @@\n+            \/\/ If the PR targets to the update repository or branch.\n+            if (workItem.requiresApproval()) {\n+                var additionalThingReady = additionalErrors.isEmpty() &&\n+                                           additionalProgresses.entrySet().stream()\n+                                             .filter(entry -> !entry.getKey().equals(APPROVAL_PROGRESS))\n+                                             .allMatch(Map.Entry::getValue) &&\n+                                           integrationBlockers.isEmpty();;\n+                var readyForApproval = visitor.messages().isEmpty() && additionalThingReady;\n+                if (isCleanBackport) {\n+                    readyForApproval = visitor.isReadyForReview() && additionalThingReady;\n+                }\n+                \/\/ The bot needs to provide a suggestion comment.\n+                updateApprovalSuggestionComment();\n+                \/\/ The labels of the issue and the PR need to be updated.\n+                updateLabelsAboutApproval(readyForApproval);\n+            }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":141,"deletions":87,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -46,1 +46,4 @@\n-    private final Pattern metadataComments = Pattern.compile(\"<!-- (?:(add|remove) (?:contributor|reviewer))|(?:summary: ')|(?:solves: ')|(?:additional required reviewers)|(?:jep: ')|(?:csr: ')\");\n+    private final Pattern metadataComments = Pattern.compile(\"\"\"\n+                    <!-- (?:(add|remove) (?:contributor|reviewer))|(?:summary: ')|(?:solves: ')|\\\n+                    (?:additional required reviewers)|(?:jep: ')|(?:csr: ')|(?:approval: ')|(?:request-approval: ')\n+                    \"\"\");\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckWorkItem.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    private static final Pattern commandPattern = Pattern.compile(\"^\\\\s*\/([A-Za-z]+)(?:\\\\s+(.*))?\");\n+    private static final Pattern commandPattern = Pattern.compile(\"^\\\\s*\/([A-Za-z\\\\-]+)(?:\\\\s+(.*))?\");\n@@ -65,0 +65,2 @@\n+            Map.entry(\"approval\", new ApprovalCommand()),\n+            Map.entry(\"request-approval\", new RequestApprovalCommand()),\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CommandExtractor.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-    default void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command,\n-                        List<Comment> allComments, PrintWriter reply, List<String> labelsToAdd, List<String> labelsToRemove) {\n+    default void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                        CommandInvocation command, List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem) {\n@@ -45,0 +45,6 @@\n+    default void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                        CommandInvocation command, List<Comment> allComments, PrintWriter reply,\n+                        PullRequestWorkItem workItem, List<String> labelsToAdd, List<String> labelsToRemove) {\n+        handle(bot, pr, censusInstance, scratchPath, command, allComments, reply, workItem);\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CommandHandler.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                       List<Comment> allComments, PrintWriter reply, List<String> labelsToAdd, List<String> labelsToRemove) {\n+                       List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem, List<String> labelsToAdd, List<String> labelsToRemove) {\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/JEPCommand.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private final List<ApprovalInfo> approvalInfos;\n@@ -79,1 +80,2 @@\n-                   Set<String> integrators, Set<Integer> excludeCommitCommentsFrom, boolean enableCsr, boolean enableJep) {\n+                   Set<String> integrators, Set<Integer> excludeCommitCommentsFrom, boolean enableCsr,\n+                   boolean enableJep, List<ApprovalInfo> approvalInfos) {\n@@ -104,0 +106,1 @@\n+        this.approvalInfos = approvalInfos;\n@@ -291,0 +294,4 @@\n+    public List<ApprovalInfo> approvalInfos() {\n+        return approvalInfos;\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBot.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import org.openjdk.skara.bot.ApprovalInfo;\n@@ -58,0 +59,1 @@\n+    private List<ApprovalInfo> approvalInfos = List.of();\n@@ -182,0 +184,5 @@\n+    public PullRequestBotBuilder approvalInfos(List<ApprovalInfo> approvalInfos) {\n+        this.approvalInfos = approvalInfos;\n+        return this;\n+    }\n+\n@@ -188,1 +195,2 @@\n-                                  confOverrideRef, censusLink, forks, integrators, excludeCommitCommentsFrom, enableCsr, enableJep);\n+                                  confOverrideRef, censusLink, forks, integrators, excludeCommitCommentsFrom, enableCsr,\n+                                  enableJep, approvalInfos);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotBuilder.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import org.openjdk.skara.host.HostUser;\n@@ -109,0 +108,1 @@\n+            var repository = configuration.repository(repo.name());\n@@ -110,1 +110,1 @@\n-                                           .repo(configuration.repository(repo.name()))\n+                                           .repo(repository)\n@@ -168,0 +168,18 @@\n+            var approvalInfos = new ArrayList<ApprovalInfo>();\n+            if (repo.value().contains(\"approval\")) {\n+                for (var branchInfo : repo.value().get(\"approval\").asArray()) {\n+                    var requestLabel = branchInfo.get(\"request-label\").asString();\n+                    var approvalLabel = branchInfo.get(\"approval-label\").asString();\n+                    var disapprovalLabel = branchInfo.get(\"disapproval-label\").asString();\n+                    var maintainers = new HashSet<String>();\n+                    if (branchInfo.contains(\"maintainers\")) {\n+                        for (var maintainer : branchInfo.get(\"maintainers\").asArray()) {\n+                            maintainers.add(maintainer.asString());\n+                        }\n+                    }\n+                    approvalInfos.add(new ApprovalInfo(repository, Pattern.compile(branchInfo.get(\"branch\").asString()),\n+                            requestLabel, approvalLabel, disapprovalLabel, maintainers));\n+                }\n+                botBuilder.approvalInfos(approvalInfos);\n+            }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotFactory.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-                    handler.get().handle(bot, pr, censusInstance, scratchPath, command, allComments, printer, labelsToAdd, labelsToRemove);\n+                    handler.get().handle(bot, pr, censusInstance, scratchPath, command, allComments, printer, this, labelsToAdd, labelsToRemove);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestCommandWorkItem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -31,0 +32,4 @@\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import org.openjdk.skara.bot.ApprovalInfo;\n@@ -32,0 +37,1 @@\n+import org.openjdk.skara.census.Contributor;\n@@ -35,0 +41,4 @@\n+import org.openjdk.skara.jbs.Backports;\n+import org.openjdk.skara.jbs.JdkVersion;\n+import org.openjdk.skara.jcheck.JCheckConfiguration;\n+import org.openjdk.skara.vcs.openjdk.Issue;\n@@ -50,0 +60,3 @@\n+    private String requestLabelName = null;\n+    private String approvalLabelName = null;\n+    private String disapprovalLabelName = null;\n@@ -107,0 +120,162 @@\n+\n+    \/**\n+     * Get the request label name from the configuration.\n+     *\/\n+    String requestLabelName() {\n+        if (requestLabelName == null) {\n+            for (var approvalInfo : bot.approvalInfos()) {\n+                if (approvalInfo.branchPattern().matcher(pr.targetRef()).matches()) {\n+                    requestLabelName = approvalInfo.requestLabel();\n+                    return requestLabelName;\n+                }\n+            }\n+            requestLabelName = \"\";\n+            return requestLabelName;\n+        }\n+        return requestLabelName;\n+    }\n+\n+    \/**\n+     * Get the approval label name from the configuration.\n+     *\/\n+    String approvalLabelName() {\n+        if (approvalLabelName == null) {\n+            for (var approvalInfo : bot.approvalInfos()) {\n+                if (approvalInfo.branchPattern().matcher(pr.targetRef()).matches()) {\n+                    approvalLabelName = approvalInfo.approvalLabel();\n+                    return approvalLabelName;\n+                }\n+            }\n+            approvalLabelName = \"\";\n+            return approvalLabelName;\n+        }\n+        return approvalLabelName;\n+    }\n+\n+    \/**\n+     * Get the disapproval label name from the configuration.\n+     *\/\n+    String disapprovalLabelName() {\n+        if (disapprovalLabelName == null) {\n+            for (var approvalInfo : bot.approvalInfos()) {\n+                if (approvalInfo.branchPattern().matcher(pr.targetRef()).matches()) {\n+                    disapprovalLabelName = approvalInfo.disapprovalLabel();\n+                    return disapprovalLabelName;\n+                }\n+            }\n+            disapprovalLabelName = \"\";\n+            return disapprovalLabelName;\n+        }\n+        return disapprovalLabelName;\n+    }\n+\n+    \/**\n+     * Judge whether the change of this PR needs the maintainer's approval.\n+     *\/\n+    boolean requiresApproval() {\n+        return bot.approvalInfos().stream()\n+                        .anyMatch(this::approvalInfoMatch);\n+    }\n+\n+    \/**\n+     * Return the first approval info from the configuration.\n+     *\/\n+    Optional<ApprovalInfo> getApprovalInfo() {\n+        return bot.approvalInfos().stream()\n+                .filter(this::approvalInfoMatch)\n+                .findFirst();\n+    }\n+\n+    private boolean approvalInfoMatch(ApprovalInfo info) {\n+        return info.repo().isSame(pr.repository())\n+                && info.branchPattern().matcher(pr.targetRef()).matches();\n+    }\n+\n+    \/**\n+     * Judge whether a contributor is the maintainer of the repository\n+     *\/\n+    boolean isMaintainer(Contributor author) {\n+        var approvalInfo = getApprovalInfo();\n+        return approvalInfo.get().maintainers().stream()\n+                .anyMatch(name -> (name.equals(author.fullName().orElse(null)) || name.equals(author.username())));\n+    }\n+\n+    List<Issue> issues(boolean withCsr, boolean withJep) {\n+        var issue = Issue.fromStringRelaxed(pr.title());\n+        if (issue.isPresent()) {\n+            var issues = new ArrayList<Issue>();\n+            issues.add(issue.get());\n+            issues.addAll(SolvesTracker.currentSolved(pr.repository().forge().currentUser(), pr.comments()));\n+            if (withCsr) {\n+                getCsrIssue(issue.get()).ifPresent(issues::add);\n+            }\n+            if (withJep) {\n+                getJepIssue().ifPresent(issues::add);\n+            }\n+            return issues;\n+        }\n+        return List.of();\n+    }\n+\n+    \/**\n+     * Get the csr issue. Note: this `Issue` is not the issue in module `issuetracker`.\n+     *\/\n+    Optional<Issue> getCsrIssue(Issue issue) {\n+        var issueProject = bot.issueProject();\n+        if (issueProject == null) {\n+            return Optional.empty();\n+        }\n+        var jbsIssueOpt = issueProject.issue(issue.shortId());\n+        if (jbsIssueOpt.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        var versionOpt = getVersion();\n+        if (versionOpt.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        return Backports.findCsr(jbsIssueOpt.get(), versionOpt.get())\n+                .flatMap(perIssue -> Issue.fromStringRelaxed(perIssue.id() + \": \" + perIssue.title()));\n+    }\n+\n+    Optional<Issue> getJepIssue() {\n+        var comment = getJepComment();\n+        if (comment.isPresent()) {\n+            return Issue.fromStringRelaxed(comment.get().group(2) + \": \" + comment.get().group(3));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    \/**\n+     * Get the fix version from the PR.\n+     *\/\n+    Optional<JdkVersion> getVersion() {\n+        var confFile = pr.repository().fileContents(\".jcheck\/conf\", pr.targetRef());\n+        var configuration = JCheckConfiguration.parse(confFile.lines().toList());\n+        var version = configuration.general().version().orElse(null);\n+        if (version == null || \"\".equals(version)) {\n+            return Optional.empty();\n+        }\n+        return JdkVersion.parse(version);\n+    }\n+\n+    Optional<Matcher> getJepComment() {\n+        var jepComment = pr.comments().stream()\n+                .filter(comment -> comment.author().equals(pr.repository().forge().currentUser()))\n+                .flatMap(comment -> comment.body().lines())\n+                .map(JEPCommand.jepMarkerPattern::matcher)\n+                .filter(Matcher::find)\n+                .reduce((first, second) -> second)\n+                .orElse(null);\n+        if (jepComment == null) {\n+            return Optional.empty();\n+        }\n+\n+        var issueId = jepComment.group(2);\n+        if (\"unneeded\".equals(issueId)) {\n+            return  Optional.empty();\n+        }\n+\n+        return Optional.of(jepComment);\n+    }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestWorkItem.java","additions":176,"deletions":1,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.Comment;\n+import org.openjdk.skara.vcs.openjdk.Issue;\n+\n+public class RequestApprovalCommand implements CommandHandler {\n+    \/\/ The tag to re-run the CheckWorkItem of the PRBot.\n+    private static final String REQUEST_APPROVAL_MARKER = \"<!-- request-approval: 'update' -->\";\n+\n+    private void showHelp(PullRequest pr, PrintWriter writer) {\n+        writer.println(String.format(\"\"\"\n+                usage: `\/request-approval <comment-text>`\n+\n+                examples:\n+                ```\n+                \/request-approval Fix Request (%s)\n+                The code applies cleanly and the test in this change fails without the patch and succeeds \\\n+                after applying it. The risk of this backport is low because the change is little and the \\\n+                issue fixed by this change also exists in other update repositories.\n+                ```\n+\n+                Note: only the pull request author is allowed to use the `request-approval` command.\n+                \"\"\", pr.repository().name()));\n+    }\n+\n+    @Override\n+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath,\n+                       CommandInvocation command, List<Comment> allComments, PrintWriter reply, PullRequestWorkItem workItem) {\n+        if (!workItem.requiresApproval()) {\n+            reply.println(\"this repository or the target branch of this pull request have not been configured to use the `request-approval` command.\");\n+            return;\n+        }\n+\n+        if (!pr.author().equals(command.user())) {\n+            reply.println(\"only the pull request author is allowed to use the `request-approval` command.\");\n+            return;\n+        }\n+\n+        if (command.args().isBlank()) {\n+            showHelp(pr, reply);\n+            return;\n+        }\n+\n+        var vcsIssue = Issue.fromStringRelaxed(pr.title());\n+        if (vcsIssue.isEmpty()) {\n+            reply.println(\"the title of the pull request doesn't contain the main issue.\");\n+            return;\n+        }\n+\n+        var issueOpt = bot.issueProject().issue(vcsIssue.get().shortId());\n+        if (issueOpt.isEmpty()) {\n+            reply.println(\"the main issue of the pull request title is not found.\");\n+            return;\n+        }\n+\n+        var comment = command.args().lines().map(String::strip)\n+                .collect(Collectors.joining(\"\\n\"));\n+        issueOpt.get().addComment(comment);\n+        reply.println(\"the text you provide has been successfully added to the main issue as a comment.\");\n+        reply.println(REQUEST_APPROVAL_MARKER);\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"add a comment to the main issue of a pull request which needs maintainer's approval\";\n+    }\n+\n+    @Override\n+    public boolean multiLine() {\n+        return true;\n+    }\n+}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/RequestApprovalCommand.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,559 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.openjdk.skara.bots.pr.PullRequestCommandWorkItem.VALID_BOT_COMMAND_MARKER;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.forge.Review;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.CheckableRepository;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+import org.openjdk.skara.test.TestBotRunner;\n+\n+public class ApprovalCommandTests {\n+    @Test\n+    void testNormal(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ Create another two issues.\n+            var issue2 = issueProject.createIssue(\"This is update change issue2\", List.of(), Map.of(\"issuetype\", JSON.of(\"Bug\")));\n+            var issue3 = issueProject.createIssue(\"This is update change issue3\", List.of(), Map.of(\"issuetype\", JSON.of(\"Bug\")));\n+            pr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            pr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the approval should be added to the pr body.\n+            assertTrue(pr.body().contains(\"- [ ] Change must be properly approved by the maintainers\"));\n+            \/\/ The pr should contain the `approval` label because the pr is ready for approval\n+            assertTrue(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Approve the update change by using the command `approval`.\n+            var maintainerPr = maintainer.pullRequest(pr.id());\n+            maintainerPr.addComment(\"\/approval yes\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.body().contains(\"- [x] Change must be properly approved by the maintainers\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-no\"));\n+            \/\/ The bot should add a comment to reply.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The pull request should be open.\n+            assertTrue(pr.isOpen());\n+\n+            \/\/ Reject the update change by using the command `approval`.\n+            maintainerPr.addComment(\"\/approval no\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.body().contains(\"- [ ] Change must be properly approved by the maintainers\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been rejected.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-no` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-no\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-yes\"));\n+            \/\/ The bot should add a comment to reply.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was rejected by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The pull request should be closed.\n+            assertTrue(pr.isClosed());\n+\n+            \/\/ Approve the update change again.\n+            maintainerPr.addComment(\"\/approval yes\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.body().contains(\"- [x] Change must be properly approved by the maintainers\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-no\"));\n+            \/\/ The bot should add a comment to reply, now it has two such comments.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer\"))\n+                    .count();\n+            assertEquals(2, commentSize);\n+            \/\/ The pull request should be open.\n+            assertTrue(pr.isOpen());\n+        }\n+    }\n+\n+    @Test\n+    void testApprovalNotReady(TestInfo testInfo) throws IOException {\n+        \/\/ Approve or reject the update change when it is not ready for approval.\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            \/\/ Create three issues.\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            var issue2 = issueProject.createIssue(\"This is update change issue2\", List.of(), Map.of(\"issuetype\", JSON.of(\"Bug\")));\n+            var issue3 = issueProject.createIssue(\"This is update change issue3\", List.of(), Map.of(\"issuetype\", JSON.of(\"Bug\")));\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create pull request.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ Add another two issues to the pull request.\n+            pr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            pr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ Don't review the pr so that it is not ready for approval and the fix request label is not added to the issue.\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.body().contains(\"- [ ] Change must be properly approved by the maintainers\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Approve the update change by using the command `approval`.\n+            var maintainerPr = maintainer.pullRequest(pr.id());\n+            maintainerPr.addComment(\"\/approval yes\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.body().contains(\"- [x] Change must be properly approved by the maintainers\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-no\"));\n+            \/\/ The bot should add a comment to reply.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The pull request should be open.\n+            assertTrue(pr.isOpen());\n+\n+            \/\/ <---- separator ---->\n+\n+            \/\/ Clear the labels of the issues.\n+            issue.removeLabel(\"master-fix-request\");\n+            issue2.removeLabel(\"master-fix-request\");\n+            issue3.removeLabel(\"master-fix-request\");\n+            issue.removeLabel(\"master-fix-yes\");\n+            issue2.removeLabel(\"master-fix-yes\");\n+            issue3.removeLabel(\"master-fix-yes\");\n+\n+            \/\/ Create another pull request.\n+            var anotherPr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ Add another two issues to the pull request.\n+            anotherPr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            anotherPr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ Don't review the pr so that it is not ready for approval and the fix request label is not added to the issue.\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            commentSize = anotherPr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(anotherPr.body().contains(\"- [ ] Change must be properly approved by the maintainers\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval\n+            assertFalse(anotherPr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Reject the update change by using the command `approval`.\n+            maintainerPr = maintainer.pullRequest(anotherPr.id());\n+            maintainerPr.addComment(\"\/approval no\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = anotherPr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(anotherPr.body().contains(\"- [ ] Change must be properly approved by the maintainers\"));\n+            \/\/ The pr should contain the `approval` label because the pr has been rejected.\n+            assertFalse(anotherPr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-no` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-no\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-yes\"));\n+            \/\/ The bot should add a comment to reply.\n+            commentSize = anotherPr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was rejected by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The pull request should be closed.\n+            assertTrue(anotherPr.isClosed());\n+        }\n+    }\n+\n+    @Test\n+    void testAuthorization(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"main\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request targeted to the `main` branch which is not configured.\n+            var pr = credentials.createPullRequest(author, \"main\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Approve the update change.\n+            var maintainerPr = maintainer.pullRequest(pr.id());\n+            maintainerPr.addComment(\"\/approval yes\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the `approval` command can only be used on \"\n+                            + \"pull requests targeting branches and repositories that require approval.\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+\n+            \/\/ Create another pull request targeted to the `master` branch.\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var anotherPr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Reject the update change by using the reviewer role.\n+            var reviewerPr = reviewer.pullRequest(anotherPr.id());\n+            reviewerPr.addComment(\"\/approval no\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            commentSize = anotherPr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"only the repository maintainers are allowed to use the `approval` command\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+        }\n+    }\n+\n+    @Test\n+    void testCommandTypo(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Test command typo `yea`\n+            var maintainerPr = maintainer.pullRequest(pr.id());\n+            maintainerPr.addComment(\"\/approval yea\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a help comment.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"usage: `\/approval [yes|no|y|n]`\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+\n+            \/\/ Test command typo `ni`\n+            maintainerPr.addComment(\"\/approval ni\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a help comment, now the pull request has two such comments.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"usage: `\/approval [yes|no|y|n]`\"))\n+                    .count();\n+            assertEquals(2, commentSize);\n+\n+            \/\/ Note: the command is case-insensitive, the arguments `Yes`, `YeS`, `No`, `nO`, `Y`, `N` can be run successfully.\n+\n+            \/\/ Test case-insensitive\n+            maintainerPr.addComment(\"\/approval YeS\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ The pull request now shouldn't have the approved comment.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer`\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply the approved comment.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this pull request was approved by the maintainer\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/ApprovalCommandTests.java","additions":559,"deletions":0,"binary":false,"changes":559,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.skara.bot.ApprovalInfo;\n@@ -41,1 +42,1 @@\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+import static org.openjdk.skara.bots.pr.PullRequestCommandWorkItem.VALID_BOT_COMMAND_MARKER;\n@@ -2204,0 +2205,459 @@\n+\n+    @Test\n+    void testApprovalRequest(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ The issue shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr is ready for approval\n+            assertTrue(pr.labelNames().contains(\"approval\"));\n+            \/\/ The issue should contain the `master-fix-request` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            \/\/ The issue shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Test the title of the PR doesn't have issue id.\n+            pr.setTitle(issue.title());\n+            \/\/ Clean the labels.\n+            pr.removeLabel(\"approval\");\n+            issue.removeLabel(\"master-fix-request\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ The issue shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Correct the title.\n+            pr.setTitle(issue.id() + \": \" + issue.title());\n+\n+            \/\/ Test multi issues in one pull request\n+            \/\/ Create another two issues.\n+            var issue2 = issueProject.createIssue(\"This is update change issue2\", List.of(), Map.of(\"issuetype\", JSON.of(\"Bug\")));\n+            var issue3 = issueProject.createIssue(\"This is update change issue3\", List.of(), Map.of(\"issuetype\", JSON.of(\"Bug\")));\n+            pr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            pr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr is ready for approval\n+            assertTrue(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-no\"));\n+        }\n+    }\n+\n+    @Test\n+    void testApprovalAndDisapproval(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ Create another two issues.\n+            var issue2 = issueProject.createIssue(\"This is update change issue2\", List.of(), Map.of(\"issuetype\", JSON.of(\"Bug\")));\n+            var issue3 = issueProject.createIssue(\"This is update change issue3\", List.of(), Map.of(\"issuetype\", JSON.of(\"Bug\")));\n+            pr.addComment(\"\/issue add \" + issue2.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+            pr.addComment(\"\/issue add \" + issue3.id() + \"\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ Test the update change is approved by the maintainer on the main issue.\n+            \/\/ Add the `master-fix-yes` label to the main issue.\n+            issue.addLabel(\"master-fix-yes\");\n+            \/\/ Add the update marker to the pr body. This step simulates the approval bot.\n+            pr.setBody(pr.body() + \"\\n<!-- approval: 'update' -->\\n\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.body().contains(\"- [x] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-no\"));\n+            \/\/ The pr is still open\n+            assertTrue(pr.isOpen());\n+\n+            \/\/ Test the update change is disapproved by the maintainer on the main issue.\n+            \/\/ Also test disapproval after approval.\n+            \/\/ Only need to revise the main issue, the bot will sync the label to other issues.\n+            \/\/ Clean the previous `master-fix-yes` label.\n+            issue.removeLabel(\"master-fix-yes\");\n+            \/\/ Add the `master-fix-no` label to the main issue.\n+            issue.addLabel(\"master-fix-no\");\n+            \/\/ Add the update marker to the pr body. This step simulates the approval bot.\n+            pr.setBody(pr.body() + \"\\n<!-- approval: 'update' -->\\n\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be checked.\n+            assertTrue(pr.body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been disapproved.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-no` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-no\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-yes` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-yes\"));\n+            \/\/ The pr is closed now.\n+            assertTrue(pr.isClosed());\n+\n+            \/\/ Test the update change is approved by the maintainer on the main issue.\n+            \/\/ Also test approval after disapproval.\n+            \/\/ Only need to revise the main issue, the bot will sync the label to other issues.\n+            \/\/ Clean the previous `master-fix-no` label.\n+            issue.removeLabel(\"master-fix-no\");\n+            \/\/ Add the `master-fix-yes` label to the main issue.\n+            issue.addLabel(\"master-fix-yes\");\n+            \/\/ Add the update marker to the pr body. This step simulates the approval bot.\n+            pr.setBody(pr.body() + \"\\n<!-- approval: 'update' -->\\n\");\n+            \/\/ Open the pull request manually.\n+            pr.setState(Issue.State.OPEN);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be checked.\n+            assertTrue(pr.body().contains(\"- [x] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr has been approved.\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ These three issues should contain the `master-fix-request` and `master-fix-yes` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-request\"));\n+            assertTrue(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue2.labelNames().contains(\"master-fix-yes\"));\n+            assertTrue(issue3.labelNames().contains(\"master-fix-yes\"));\n+            \/\/ These three issues shouldn't contain the `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue2.labelNames().contains(\"master-fix-no\"));\n+            assertFalse(issue3.labelNames().contains(\"master-fix-no\"));\n+            \/\/ The pr is open (actually open by the approval bot).\n+            assertTrue(pr.isOpen());\n+        }\n+    }\n+\n+    @Test\n+    void testNotNeedApproval(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var mainHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(mainHash, author.url(), \"main\", true);\n+\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request to the `main` branch instead of `master` branch, so it is not an update change.\n+            var pr = credentials.createPullRequest(author, \"main\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ review the pr\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion shouldn't be added.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+            \/\/ The progress about the maintainer's approval shouldn't be added to the pr body.\n+            assertFalse(pr.body().contains(\"All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not an update change (the target branch is not `master`).\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ The issue shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+        }\n+    }\n+\n+    @Test\n+    void testApprovalWithCleanBackport(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            issue.setState(Issue.State.CLOSED);\n+\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Push a commit to the jdk19 branch\n+            var jdk19Branch = localRepo.branch(masterHash, \"jdk19\");\n+            localRepo.checkout(jdk19Branch);\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"a_new_file\");\n+            localRepo.add(newFile);\n+            var issueNumber = issue.id().split(\"-\")[1];\n+            var commitMessage = issueNumber + \": This is update change issue\\n\\nReviewed-by: integrationreviewer2\";\n+            var commitHash = localRepo.commit(commitMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.org\");\n+            localRepo.push(commitHash, author.url(), \"jdk19\", true);\n+\n+            \/\/ \"backport\" the commit to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"a_new_file\");\n+            localRepo.add(newFile2);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(editHash, author.url(), \"edit\", true);\n+            \/\/ This is a clean backport, so it is ready for approval.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + commitHash);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr is a clean backport.\n+            assertTrue(pr.labelNames().contains(\"approval\"));\n+            \/\/ The issue should contain the `master-fix-request` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            \/\/ The issue shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ Add more commit to `edit` branch, then the pull request is not a clean backport now.\n+            Files.writeString(newFile2, \"another_new_file\");\n+            localRepo.add(newFile2);\n+            var editHash2 = localRepo.commit(\"another commit\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(editHash2, author.url(), \"edit\", true);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr shouldn't contain the `approval` label because the pr is not ready for approval (it is not a clean backport).\n+            assertFalse(pr.labelNames().contains(\"approval\"));\n+            \/\/ The issue shouldn't contain the `master-fix-request`, `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-request\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+\n+            \/\/ review the pr, then the pull request is ready for approval\n+            var reviewPr = reviewer.pullRequest(pr.id());\n+            reviewPr.addReview(Review.Verdict.APPROVED, \"LGTM\");\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The maintainer's approval suggestion should be added only once.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"<!-- Approval suggestion comment -->\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The progress about the maintainer's approval should be added to the pr body.\n+            assertTrue(pr.body().contains(\"- [ ] All issues must be\"));\n+            \/\/ The pr should contain the `approval` label because the pr has been reviewed and is ready for approval now.\n+            assertTrue(pr.labelNames().contains(\"approval\"));\n+            \/\/ The issue should contain the `master-fix-request` label\n+            assertTrue(issue.labelNames().contains(\"master-fix-request\"));\n+            \/\/ The issue shouldn't contain the `master-fix-yes` and `master-fix-no` label\n+            assertFalse(issue.labelNames().contains(\"master-fix-yes\"));\n+            assertFalse(issue.labelNames().contains(\"master-fix-no\"));\n+        }\n+    }\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/CheckTests.java","additions":461,"deletions":1,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.openjdk.skara.bots.pr.PullRequestCommandWorkItem.VALID_BOT_COMMAND_MARKER;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.bot.ApprovalInfo;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.CheckableRepository;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+import org.openjdk.skara.test.TestBotRunner;\n+\n+public class RequestApprovalCommandTests {\n+    @Test\n+    void testNormal(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Use the command `request-approval`.\n+            pr.addComment(\"\/request-approval request-approval-test\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the text you provide has been successfully \"\n+                            + \"added to the main issue as a comment\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue should have one corresponding comment.\n+            commentSize = issue.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+\n+            \/\/ Use the command `request-approval` again.\n+            pr.addComment(\"\/request-approval request-approval-test\\nanother comment\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment, now the pull request has two such comments.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the text you provide has been successfully \"\n+                            + \"added to the main issue as a comment\"))\n+                    .count();\n+            assertEquals(2, commentSize);\n+            \/\/ The issue should have two corresponding comments.\n+            commentSize = issue.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(2, commentSize);\n+        }\n+    }\n+\n+    @Test\n+    void testAuthorization(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"main\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request targeted to the `main` branch which is not configured.\n+            var pr = credentials.createPullRequest(author, \"main\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ User the command `request-approval`\n+            pr.addComment(\"\/request-approval request-approval-test\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"this repository or the target branch of \"\n+                            + \"this pull request have not been configured to use the `request-approval` command\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue shouldn't have related comment.\n+            commentSize = issue.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+\n+            \/\/ Create another pull request targeted to the `master` branch.\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var anotherPr = credentials.createPullRequest(author, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Use the command `request-approval` by using non-author role.\n+            var reviewerPr = reviewer.pullRequest(anotherPr.id());\n+            reviewerPr.addComment(\"\/request-approval request-approval-test\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            commentSize = anotherPr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"only the pull request author is allowed to use the `request-approval` command\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue shouldn't have related comment.\n+            commentSize = issue.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+        }\n+    }\n+\n+    @Test\n+    void testWrongIssue(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var maintainer = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+            var census = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id())\n+                    .addReviewer(maintainer.forge().currentUser().id())\n+                    .build();\n+\n+            var bot = PullRequestBot.newBuilder().repo(author)\n+                    .censusRepo(census).issueProject(issueProject)\n+                    .approvalInfos(List.of(new ApprovalInfo(author, Pattern.compile(\"test\"),\n+                                    \"test-fix-request\", \"test-fix-yes\", \"test-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"master\"),\n+                                    \"master-fix-request\", \"master-fix-yes\", \"master-fix-no\", Set.of(\"integrationreviewer3\")),\n+                            new ApprovalInfo(author, Pattern.compile(\"jdk18\"),\n+                                    \"jdk18-fix-request\", \"jdk18-fix-yes\", \"jdk18-fix-no\", Set.of(\"integrationreviewer3\"))))\n+                    .build();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+\n+            \/\/ Create a pull request.\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issue.title());\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Use the command `request-approval`.\n+            pr.addComment(\"\/request-approval request-approval-test\\n\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            var commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the title of the pull request doesn't contain the main issue\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue shouldn't have related comment.\n+            commentSize = issue.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+\n+            \/\/ Change the pr title to wrong issue id\n+            pr.setTitle(\"2: \" + issue.title());\n+\n+            \/\/ Use the command `request-approval` again.\n+            pr.addComment(\"\/request-approval request-approval-test\" + VALID_BOT_COMMAND_MARKER);\n+\n+            \/\/ run the pr bot\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply a comment.\n+            commentSize = pr.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"the main issue of the pull request title is not found\"))\n+                    .count();\n+            assertEquals(1, commentSize);\n+            \/\/ The issue shouldn't have related comment.\n+            commentSize = issue.comments().stream()\n+                    .filter(comment -> comment.body().contains(\"request-approval-test\"))\n+                    .count();\n+            assertEquals(0, commentSize);\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/RequestApprovalCommandTests.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -50,0 +50,5 @@\n+    \/\/ TODO To keep the API name more consistent, the method `pullRequests(ZonedDateTime updatedAfter)`\n+    \/\/  should be renamed as ` pullRequestsAfter(ZonedDateTime updatedAfter)`.\n+    \/\/  And a new method named `openPullRequests()` should be added to get all the open pull requests,\n+    \/\/  and the method `pullRequests()` should return all the pull requests (included open and closed).\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/HostedRepository.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.forge;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+\/**\n+ * A poller to get the updated pull requests. The user can provide the corresponding functions\n+ * to get the open updated pull requests or all the updated pull requests.\n+ *\/\n+public class UpdatedPullRequestPoller {\n+    private final HostedRepository repo;\n+    \/\/ Keeps track of updatedAt timestamps from the previous call to getUpdatedPullRequests,\n+    \/\/ so we can avoid re-evaluating PRs that are returned again without any actual\n+    \/\/ update. This is needed because timestamp based searches aren't exact enough\n+    \/\/ to avoid sometimes receiving the same items multiple times.\n+    private Map<String, ZonedDateTime> prsUpdatedAt = new HashMap<>();\n+    \/\/ The last found updateAt in any returned PR. Used for limiting results on the\n+    \/\/ next call to the hosted repo. Should only contain timestamps originating\n+    \/\/ from the remote repo to avoid problems with mismatched clocks.\n+    private ZonedDateTime lastUpdatedAt;\n+\n+    public UpdatedPullRequestPoller(HostedRepository repo) {\n+        this.repo = repo;\n+    }\n+\n+    \/**\n+     * A method to get the updated pull request. The concrete operation is provided by the user.\n+     *\n+     * If you want to get the updated open pull request, you can use\n+     * `getUpdatedPullRequests(HostedRepository::openPullRequestsAfter, HostedRepository::openPullRequests)`.\n+     * Because the method `HostedRepository::openPullRequests` has not been implemented now,\n+     * you can use the method `HostedRepository::pullRequests` instead.\n+     * The class `ApprovalPullRequestBot` has such usage.\n+     *\n+     * If you want to get all the updated pull request (included open and closed), you can use\n+     * `getUpdatedPullRequests(HostedRepository::pullRequestsAfter, HostedRepository::pullRequests)`.\n+     * The method `HostedRepository::pullRequestsAfter` now is named as `HostedRepository::pullRequests`.\n+     * and the `HostedRepository::pullRequests` now only get all the open pull requests.\n+     * TODO want the class `HostedRepository` and its sub-classes to be adjusted.\n+     *\/\n+    public List<PullRequest> getUpdatedPullRequests(BiFunction<HostedRepository, ZonedDateTime, List<PullRequest>> updatedPrGetter,\n+                                                    Function<HostedRepository, List<PullRequest>> prGetter) {\n+        var prList = new ArrayList<PullRequest>();\n+        Map<String, ZonedDateTime> newPrsUpdatedAt = new HashMap<>();\n+        \/\/ On the first run we have to re-evaluate all the PRs, after that, only\n+        \/\/ looking at PRs that have been updated should be enough.\n+        var prs = lastUpdatedAt != null ? updatedPrGetter.apply(repo, lastUpdatedAt) : prGetter.apply(repo);\n+        for (PullRequest pr : prs) {\n+            newPrsUpdatedAt.put(pr.id(), pr.updatedAt());\n+            \/\/ Update lastUpdatedAt with the last found updatedAt for the next call\n+            if (lastUpdatedAt == null || pr.updatedAt().isAfter(lastUpdatedAt)) {\n+                lastUpdatedAt = pr.updatedAt();\n+            }\n+            var lastUpdate = prsUpdatedAt.get(pr.id());\n+            if (lastUpdate != null) {\n+                if (!pr.updatedAt().isAfter(lastUpdate)) {\n+                    continue;\n+                }\n+            }\n+            prList.add(pr);\n+        }\n+        prsUpdatedAt = newPrsUpdatedAt;\n+        return prList;\n+    }\n+}\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/UpdatedPullRequestPoller.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.forge;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.issuetracker.Issue;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.CheckableRepository;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+\n+public class UpdatedPullRequestPollerTests {\n+    @Test\n+    void testGetOpenUpdatedPullRequests(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var repo = credentials.getHostedRepository();\n+            var issueProject = credentials.getIssueProject();\n+\n+            var issue = issueProject.createIssue(\"This is update change issue\", List.of(), Map.of());\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var localRepo = CheckableRepository.init(tempFolder.path(), repo.repositoryType(),\n+                    Path.of(\"appendable.txt\"), Set.of(\"issues\"), null);\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, repo.url(), \"master\", true);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, repo.url(), \"edit\", true);\n+            \/\/ create four pull requests.\n+            var openPr1 = credentials.createPullRequest(repo, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+            var openPr2 = credentials.createPullRequest(repo, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+            var closedPr1 = credentials.createPullRequest(repo, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+            closedPr1.setState(Issue.State.CLOSED);\n+            var closedPr2 = credentials.createPullRequest(repo, \"master\", \"edit\", issue.id() + \": \" + issue.title());\n+            closedPr2.setState(Issue.State.CLOSED);\n+\n+            \/\/ First time, the poller should get all the open pull requests.\n+            var poller = new UpdatedPullRequestPoller(repo);\n+            var list = poller.getUpdatedPullRequests(HostedRepository::openPullRequestsAfter, HostedRepository::pullRequests);\n+            assertEquals(2, list.size());\n+            assertEquals(1, list.stream().filter(pr -> pr.id().equals(openPr1.id())).count());\n+            assertEquals(1, list.stream().filter(pr -> pr.id().equals(openPr2.id())).count());\n+\n+            \/\/ Update the open pr 1 and the closed pr 1.\n+            openPr1.addLabel(\"test\");\n+            closedPr1.addLabel(\"test\");\n+\n+            \/\/ The poller should get the open pr 1.\n+            list = poller.getUpdatedPullRequests(HostedRepository::openPullRequestsAfter, HostedRepository::pullRequests);\n+            assertEquals(1, list.size());\n+            assertEquals(1, list.stream().filter(pr -> pr.id().equals(openPr1.id())).count());\n+\n+            \/\/ Update the closed pr 1 and closed pr 2\n+            closedPr1.addLabel(\"test2\");\n+            closedPr2.addLabel(\"test2\");\n+\n+            \/\/ The poller shouldn't get any pr.\n+            list = poller.getUpdatedPullRequests(HostedRepository::openPullRequestsAfter, HostedRepository::pullRequests);\n+            assertEquals(0, list.size());\n+\n+            \/\/ Update the open pr 1 and open pr 2\n+            openPr1.addLabel(\"test2\");\n+            openPr2.addLabel(\"test2\");\n+\n+            \/\/ The poller should get the open pr 1 and open pr 2.\n+            list = poller.getUpdatedPullRequests(HostedRepository::openPullRequestsAfter, HostedRepository::pullRequests);\n+            assertEquals(2, list.size());\n+            assertEquals(1, list.stream().filter(pr -> pr.id().equals(openPr1.id())).count());\n+            assertEquals(1, list.stream().filter(pr -> pr.id().equals(openPr2.id())).count());\n+\n+            \/\/ No pr updates.\n+            list = poller.getUpdatedPullRequests(HostedRepository::openPullRequestsAfter, HostedRepository::pullRequests);\n+            assertEquals(0, list.size());\n+        }\n+    }\n+\n+    @Test\n+    void testGetAllUpdatedPullRequests(TestInfo testInfo) throws IOException {\n+        \/\/ TODO currently the class `HostedRepository` doesn't have a method to get all the pull requests.\n+        \/\/  Want the the class `HostedRepository` and its sub-classes to be adjusted.\n+    }\n+}\n","filename":"forge\/src\/test\/java\/org\/openjdk\/skara\/forge\/UpdatedPullRequestPollerTests.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.issuetracker;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * A poller to get the updated issues. The user can provide the corresponding functions\n+ * to get all the updated issues or all the updated CSR issues.\n+ *\/\n+public class UpdatedIssuePoller {\n+    private final IssueProject issueProject;\n+    \/\/ Keeps track of updatedAt timestamps from the previous call to getUpdatedIssues,\n+    \/\/ so we can avoid re-evaluating issues that are returned again without any actual update.\n+    private Map<String, ZonedDateTime> issueUpdatedAt = new HashMap<>();\n+    \/\/ The last found updatedAt from any issue.\n+    private ZonedDateTime lastUpdatedAt;\n+\n+    public UpdatedIssuePoller(IssueProject issueProject) {\n+        this.issueProject = issueProject;\n+    }\n+\n+    \/**\n+     * A method to get the updated issues. The concrete operation is provided by the user.\n+     * If you want to get all the updated issues, you can use `getUpdatedIssues(IssueProject::issues)`.\n+     * If you want to get the updated CSR issues, you can use `getUpdatedIssues(IssueProject::csrIssues)`.\n+     *\/\n+    public List<Issue> getUpdatedIssues(BiFunction<IssueProject, ZonedDateTime, List<Issue>> updatedIssueGetter) {\n+        var issueList = new ArrayList<Issue>();\n+        \/\/ In the first round, we just find the last updated issue to initialize lastUpdatedAt.\n+        \/\/ There is no need for reacting to any issue update before that,\n+        \/\/ as the UpdatedPullRequestPoller will go through every open PR at startup anyway.\n+        if (lastUpdatedAt == null) {\n+            var lastUpdatedIssue = issueProject.lastUpdatedIssue();\n+            if (lastUpdatedIssue.isPresent()) {\n+                Issue issue = lastUpdatedIssue.get();\n+                lastUpdatedAt = issue.updatedAt();\n+                issueUpdatedAt.put(issue.id(), issue.updatedAt());\n+            } else {\n+                \/\/ If no previous issue was found, initiate lastUpdatedAt to something far\n+                \/\/ enough back so that we are guaranteed to find any new issues going forward.\n+                lastUpdatedAt = ZonedDateTime.ofInstant(Instant.EPOCH, ZoneId.systemDefault());\n+            }\n+            return issueList;\n+        }\n+\n+        var newIssuesUpdatedAt = new HashMap<String, ZonedDateTime>();\n+        var issues = updatedIssueGetter.apply(issueProject, lastUpdatedAt);;\n+        for (var issue : issues) {\n+            newIssuesUpdatedAt.put(issue.id(), issue.updatedAt());\n+            \/\/ Update the lastUpdatedAt value with the highest found value for next call\n+            if (issue.updatedAt().isAfter(lastUpdatedAt)) {\n+                lastUpdatedAt = issue.updatedAt();\n+            }\n+            var lastUpdate = issueUpdatedAt.get(issue.id());\n+            if (lastUpdate != null) {\n+                if (!issue.updatedAt().isAfter(lastUpdate)) {\n+                    continue;\n+                }\n+            }\n+            issueList.add(issue);\n+        }\n+        issueUpdatedAt = newIssuesUpdatedAt;\n+        return issueList;\n+    }\n+}\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/UpdatedIssuePoller.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.issuetracker;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+\n+public class UpdatedIssuePollerTest {\n+    @Test\n+    void testGetUpdatedIssues(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bugIssue = issueProject.createIssue(\"bug issue\", List.of(), Map.of());\n+            bugIssue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var enhancementIssue = issueProject.createIssue(\"enhancement issue\", List.of(), Map.of());\n+            enhancementIssue.setProperty(\"issuetype\", JSON.of(\"Enhancement\"));\n+            var csrIssue = issueProject.createIssue(\"CSR issue\", List.of(), Map.of());\n+            csrIssue.setProperty(\"issuetype\", JSON.of(\"CSR\"));\n+            var jepIssue = issueProject.createIssue(\"JEP issue\", List.of(), Map.of());\n+            jepIssue.setProperty(\"issuetype\", JSON.of(\"JEP\"));\n+\n+            \/\/ First time, the poller should get empty list.\n+            var poller = new UpdatedIssuePoller(issueProject);\n+            var list = poller.getUpdatedIssues(IssueProject::issues);\n+            assertEquals(0, list.size());\n+\n+            \/\/ Update bug issue and csr issue.\n+            bugIssue.addLabel(\"test\");\n+            csrIssue.addLabel(\"test\");\n+\n+            \/\/ The poller should get bug issue and csr issue.\n+            list = poller.getUpdatedIssues(IssueProject::issues);\n+            assertEquals(2, list.size());\n+            assertEquals(1, list.stream().filter(issue -> issue.id().equals(bugIssue.id())).count());\n+            assertEquals(1, list.stream().filter(issue -> issue.id().equals(csrIssue.id())).count());\n+\n+            \/\/ Update bug issue, enhancement issue and jep issue.\n+            bugIssue.addLabel(\"test2\");\n+            enhancementIssue.addLabel(\"test2\");\n+            jepIssue.addLabel(\"test2\");\n+\n+            \/\/ The poller should get bug issue and jep issue.\n+            list = poller.getUpdatedIssues(IssueProject::issues);\n+            assertEquals(3, list.size());\n+            assertEquals(1, list.stream().filter(issue -> issue.id().equals(bugIssue.id())).count());\n+            assertEquals(1, list.stream().filter(issue -> issue.id().equals(enhancementIssue.id())).count());\n+            assertEquals(1, list.stream().filter(issue -> issue.id().equals(jepIssue.id())).count());\n+\n+            \/\/ No issue updates.\n+            list = poller.getUpdatedIssues(IssueProject::issues);\n+            assertEquals(0, list.size());\n+        }\n+    }\n+\n+    @Test\n+    void testGetUpdatedCsrIssues(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var issueProject = credentials.getIssueProject();\n+\n+            var bugIssue = issueProject.createIssue(\"bug issue\", List.of(), Map.of());\n+            bugIssue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var enhancementIssue = issueProject.createIssue(\"enhancement issue\", List.of(), Map.of());\n+            enhancementIssue.setProperty(\"issuetype\", JSON.of(\"Enhancement\"));\n+            var csrIssue1 = issueProject.createIssue(\"CSR issue 1\", List.of(), Map.of());\n+            csrIssue1.setProperty(\"issuetype\", JSON.of(\"CSR\"));\n+            var csrIssue2 = issueProject.createIssue(\"CSR issue 2\", List.of(), Map.of());\n+            csrIssue2.setProperty(\"issuetype\", JSON.of(\"CSR\"));\n+            var jepIssue = issueProject.createIssue(\"JEP issue\", List.of(), Map.of());\n+            jepIssue.setProperty(\"issuetype\", JSON.of(\"JEP\"));\n+\n+            \/\/ First time, the poller should get empty list.\n+            var poller = new UpdatedIssuePoller(issueProject);\n+            var list = poller.getUpdatedIssues(IssueProject::csrIssues);\n+            assertEquals(0, list.size());\n+\n+            \/\/ Update bug issue and csr issue 1.\n+            bugIssue.addLabel(\"test\");\n+            csrIssue1.addLabel(\"test\");\n+\n+            \/\/ The poller should only get csr issue 1.\n+            list = poller.getUpdatedIssues(IssueProject::csrIssues);\n+            assertEquals(1, list.size());\n+            assertEquals(1, list.stream().filter(issue -> issue.id().equals(csrIssue1.id())).count());\n+\n+            \/\/ Update bug issue, enhancement issue and jep issue.\n+            bugIssue.addLabel(\"test2\");\n+            enhancementIssue.addLabel(\"test2\");\n+            jepIssue.addLabel(\"test2\");\n+\n+            \/\/ The poller should get no issue.\n+            list = poller.getUpdatedIssues(IssueProject::csrIssues);\n+            assertEquals(0, list.size());\n+\n+            \/\/ Update csr issue 1 and csr issue 2\n+            csrIssue1.addLabel(\"test3\");\n+            csrIssue2.addLabel(\"test3\");\n+\n+            \/\/ The poller should get csr issue 1 and csr issue 2.\n+            list = poller.getUpdatedIssues(IssueProject::csrIssues);\n+            assertEquals(2, list.size());\n+            assertEquals(1, list.stream().filter(issue -> issue.id().equals(csrIssue1.id())).count());\n+            assertEquals(1, list.stream().filter(issue -> issue.id().equals(csrIssue2.id())).count());\n+\n+            \/\/ No issue updates.\n+            list = poller.getUpdatedIssues(IssueProject::csrIssues);\n+            assertEquals(0, list.size());\n+        }\n+    }\n+}\n","filename":"issuetracker\/src\/test\/java\/org\/openjdk\/skara\/issuetracker\/UpdatedIssuePollerTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+include 'bots:approval'\n","filename":"settings.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}