{"files":[{"patch":"@@ -45,1 +45,31 @@\n-        var count = Integer.parseInt(s.substring(separatorIndex + 1, s.length()));\n+\n+        \/\/ Need to work around a bug in git where git sometimes print -1\n+        \/\/ as an unsigned int for the count part of the range\n+        var countString = s.substring(separatorIndex + 1, s.length());\n+        var count =\n+            countString.equals(\"18446744073709551615\") ?  0 : Integer.parseInt(countString);\n+\n+        if (count == 0 && start != 0) {\n+            \/\/ start is off-by-one when count is 0.\n+            \/\/ but if start == 0, a file was added and we need a 0 here.\n+            start++;\n+        }\n+\n+        return new Range(start, count);\n+    }\n+\n+    public static Range fromCombinedString(String s) {\n+        var separatorIndex = s.indexOf(\",\");\n+\n+        if (separatorIndex == -1) {\n+            var start = Integer.parseInt(s);\n+            return new Range(start, 1);\n+        }\n+\n+        var start = Integer.parseInt(s.substring(0, separatorIndex));\n+\n+        \/\/ Need to work around a bug in git where git sometimes print -1\n+        \/\/ as an unsigned int for the count part of the range\n+        var countString = s.substring(separatorIndex + 1, s.length());\n+        var count =\n+            countString.equals(\"18446744073709551615\") ?  0 : Integer.parseInt(countString);\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/Range.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.vcs;\n+\n+import org.openjdk.skara.encoding.Base85;\n+import org.openjdk.skara.vcs.*;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.zip.Inflater;\n+import java.util.zip.DataFormatException;\n+\n+public class UnifiedDiffParser {\n+    public static List<Hunk> parseSingleFileDiff(String[] lines) {\n+        return parseSingleFileDiff(Arrays.asList(lines));\n+    }\n+\n+    public static List<Hunk> parseSingleFileDiff(List<String> lines) {\n+        var i = 0;\n+        if (lines.get(i).startsWith(\"diff \")) {\n+            i++;\n+        }\n+        if (lines.get(i).startsWith(\"--- \")) {\n+            i++;\n+        }\n+        if (lines.get(i).startsWith(\"+++ \")) {\n+            i++;\n+        }\n+\n+        var hunks = new ArrayList<Hunk>();\n+        while (i < lines.size()) {\n+            var words = lines.get(i).split(\"\\\\s\");\n+            if (!words[0].startsWith(\"@@\")) {\n+                throw new IllegalStateException(\"Unexpected diff line at index \" + i + \": \" + lines.get(i));\n+            }\n+            var sourceRange = Range.fromString(words[1].substring(1));\n+            var targetRange = Range.fromString(words[2].substring(1));\n+\n+            var nextHeader = i + 1;\n+            while (nextHeader < lines.size()) {\n+                if (lines.get(nextHeader).startsWith(\"@@\")) {\n+                    break;\n+                }\n+                nextHeader++;\n+            }\n+\n+            var hunkLines = lines.subList(i, nextHeader);\n+            hunks.addAll(parseSingleFileDiff(sourceRange, targetRange, hunkLines));\n+            i = nextHeader;\n+        }\n+\n+        return hunks;\n+    }\n+\n+    public static List<Hunk> parseSingleFileDiff(Range from, Range to, List<String> hunkLines) {\n+        var hunks = new ArrayList<Hunk>();\n+\n+        var sourceStart = from.start();\n+        var targetStart = to.start();\n+\n+        var sourceLines = new ArrayList<String>();\n+        var targetLines = new ArrayList<String>();\n+\n+        int i = 0;\n+        while (i < hunkLines.size() && hunkLines.get(i).startsWith(\" \")) {\n+            i++;\n+            sourceStart++;\n+            targetStart++;\n+        }\n+\n+        while (i < hunkLines.size()) {\n+            var line = hunkLines.get(i);\n+            if (line.startsWith(\"-\")) {\n+                sourceLines.add(line.substring(1));\n+                i++;\n+                continue;\n+            } else if (line.startsWith(\"+\")) {\n+                targetLines.add(line.substring(1));\n+                i++;\n+                continue;\n+            }\n+\n+            if (line.startsWith(\" \")) {\n+                hunks.add(new Hunk(new Range(sourceStart, sourceLines.size()), sourceLines,\n+                                   new Range(targetStart, targetLines.size()), targetLines));\n+\n+                sourceStart += sourceLines.size();\n+                targetStart += targetLines.size();\n+\n+                sourceLines = new ArrayList<String>();\n+                targetLines = new ArrayList<String>();\n+\n+                while (i < hunkLines.size() && hunkLines.get(i).startsWith(\" \")) {\n+                    i++;\n+                    sourceStart++;\n+                    targetStart++;\n+                }\n+            }\n+        }\n+\n+        if (sourceLines.size() > 0 || targetLines.size() > 0) {\n+            hunks.add(new Hunk(new Range(sourceStart, sourceLines.size()), sourceLines,\n+                               new Range(targetStart, targetLines.size()), targetLines));\n+        }\n+\n+        return hunks;\n+    }\n+}\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/UnifiedDiffParser.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -99,1 +99,1 @@\n-                    sourceRangesPerParent.add(GitRange.fromCombinedString(words[i].substring(1))); \/\/ skip initial '-'\n+                    sourceRangesPerParent.add(Range.fromCombinedString(words[i].substring(1))); \/\/ skip initial '-'\n@@ -102,1 +102,1 @@\n-            var targetRange = GitRange.fromCombinedString(words[numParents + 1].substring(1)); \/\/ skip initial '+'\n+            var targetRange = Range.fromCombinedString(words[numParents + 1].substring(1)); \/\/ skip initial '+'\n@@ -140,1 +140,1 @@\n-                var hunks = UnifiedDiffParser.splitDiffWithContext(sourceRange, targetRange, lines);\n+                var hunks = UnifiedDiffParser.parseSingleFileDiff(sourceRange, targetRange, lines);\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/git\/GitCombinedDiffParser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-                var patches = UnifiedDiffParser.parseGitRaw(reader, commitDelimiter);\n+                var patches = GitRawDiffParser.parse(reader, commitDelimiter);\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/git\/GitCommitIterator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1101,1 +1101,1 @@\n-            var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());\n+            var patches = GitRawDiffParser.parse(p.getInputStream());\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/git\/GitRepository.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                var patches = UnifiedDiffParser.parseGitRaw(reader, commitDelimiter);\n+                var patches = GitRawDiffParser.parse(reader, commitDelimiter);\n@@ -74,2 +74,2 @@\n-                var p0 = UnifiedDiffParser.parseGitRaw(reader, commitDelimiter);\n-                var p1 = UnifiedDiffParser.parseGitRaw(reader, commitDelimiter);\n+                var p0 = GitRawDiffParser.parse(reader, commitDelimiter);\n+                var p1 = GitRawDiffParser.parse(reader, commitDelimiter);\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/hg\/HgCommitIterator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -919,1 +919,1 @@\n-            var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());\n+            var patches = GitRawDiffParser.parse(p.getInputStream());\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/hg\/HgRepository.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.skara.vcs.tools;\n-\n-import org.openjdk.skara.vcs.Range;\n-\n-public class GitRange {\n-    static Range fromString(String s) {\n-        var separatorIndex = s.indexOf(\",\");\n-\n-        if (separatorIndex == -1) {\n-            var start = Integer.parseInt(s);\n-            return new Range(start, 1);\n-        }\n-\n-        var start = Integer.parseInt(s.substring(0, separatorIndex));\n-\n-        \/\/ Need to work around a bug in git where git sometimes print -1\n-        \/\/ as an unsigned int for the count part of the range\n-        var countString = s.substring(separatorIndex + 1, s.length());\n-        var count =\n-            countString.equals(\"18446744073709551615\") ?  0 : Integer.parseInt(countString);\n-\n-        if (count == 0 && start != 0) {\n-            \/\/ start is off-by-one when count is 0.\n-            \/\/ but if start == 0, a file was added and we need a 0 here.\n-            start++;\n-        }\n-\n-        return new Range(start, count);\n-    }\n-\n-    public static Range fromCombinedString(String s) {\n-        var separatorIndex = s.indexOf(\",\");\n-\n-        if (separatorIndex == -1) {\n-            var start = Integer.parseInt(s);\n-            return new Range(start, 1);\n-        }\n-\n-        var start = Integer.parseInt(s.substring(0, separatorIndex));\n-\n-        \/\/ Need to work around a bug in git where git sometimes print -1\n-        \/\/ as an unsigned int for the count part of the range\n-        var countString = s.substring(separatorIndex + 1, s.length());\n-        var count =\n-            countString.equals(\"18446744073709551615\") ?  0 : Integer.parseInt(countString);\n-\n-        return new Range(start, count);\n-    }\n-}\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/tools\/GitRange.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.vcs.tools;\n+\n+import org.openjdk.skara.encoding.Base85;\n+import org.openjdk.skara.vcs.*;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.zip.Inflater;\n+import java.util.zip.DataFormatException;\n+\n+public class GitRawDiffParser {\n+    private static class Hunks {\n+        private final List<Hunk> textual;\n+        private final List<BinaryHunk> binary;\n+\n+        private Hunks(List<Hunk> textual, List<BinaryHunk> binary) {\n+            this.textual = textual;\n+            this.binary = binary;\n+        }\n+\n+        static Hunks ofTextual(List<Hunk> textual) {\n+            return new Hunks(textual, null);\n+        }\n+\n+        static Hunks ofBinary(List<BinaryHunk> binary) {\n+            return new Hunks(null, binary);\n+        }\n+\n+        boolean areBinary() {\n+            return binary != null;\n+        }\n+\n+        List<BinaryHunk> binary() {\n+            return binary;\n+        }\n+\n+        List<Hunk> textual() {\n+            return textual;\n+        }\n+    }\n+\n+    private final String delimiter;\n+    private String line = null;\n+\n+    private GitRawDiffParser(String delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    private List<PatchHeader> parseRawLines(InputStream stream) throws IOException {\n+        return parseRawLines(new UnixStreamReader(stream));\n+    }\n+\n+    private List<PatchHeader> parseRawLines(UnixStreamReader reader) throws IOException {\n+        var headers = new ArrayList<PatchHeader>();\n+\n+        line = reader.readLine();\n+        while (line != null && line.startsWith(\":\")) {\n+            headers.add(PatchHeader.fromRawLine(line));\n+            line = reader.readLine();\n+        }\n+\n+        return headers;\n+    }\n+\n+    private Hunks parseSingleFileBinaryHunks(UnixStreamReader reader) throws IOException {\n+        var hunks = new ArrayList<BinaryHunk>();\n+        while ((line = reader.readLine()) != null &&\n+                !line.startsWith(\"diff\") &&\n+                !line.equals(delimiter)) {\n+            var words = line.split(\" \");\n+            var format = words[0];\n+            var inflatedSize = Integer.parseInt(words[1]);\n+\n+            var data = new ArrayList<String>();\n+            while ((line = reader.readLine()) != null && !line.equals(\"\")) {\n+                data.add(line);\n+            }\n+\n+            if (format.equals(\"literal\")) {\n+                hunks.add(BinaryHunk.ofLiteral(inflatedSize, data));\n+            } else if (format.equals(\"delta\")) {\n+                hunks.add(BinaryHunk.ofDelta(inflatedSize, data));\n+            } else {\n+                throw new IllegalStateException(\"Unexpected binary diff format: \" + words[0]);\n+            }\n+        }\n+        return Hunks.ofBinary(hunks);\n+    }\n+\n+    private Hunks parseSingleFileTextualHunks(UnixStreamReader reader) throws IOException {\n+        var hunks = new ArrayList<Hunk>();\n+\n+        while (line != null && line.startsWith(\"@@\")) {\n+            var words = line.split(\"\\\\s\");\n+            if (!words[0].startsWith(\"@@\")) {\n+                throw new IllegalStateException(\"Unexpected diff line: \" + line);\n+            }\n+            var sourceRange = words[1].substring(1); \/\/ skip initial '-'\n+            var targetRange = words[2].substring(1); \/\/ skip initial '+'\n+\n+            var sourceLines = new ArrayList<String>();\n+            var sourceHasNewlineAtEndOfFile = true;\n+            var targetLines = new ArrayList<String>();\n+            var targetHasNewlineAtEndOfFile = true;\n+            var hasSeenLinesWithPlusPrefix = false;\n+            while ((line = reader.readLine()) != null &&\n+                   !line.startsWith(\"@@\") &&\n+                   !line.startsWith(\"diff\") &&\n+                   !line.equals(delimiter)) {\n+                if (line.equals(\"\\\\ No newline at end of file\")) {\n+                    if (!hasSeenLinesWithPlusPrefix) {\n+                        sourceHasNewlineAtEndOfFile = false;\n+                    } else {\n+                        targetHasNewlineAtEndOfFile = false;\n+                    }\n+                    continue;\n+                }\n+\n+                if (line.startsWith(\"-\")) {\n+                    sourceLines.add(line.substring(1)); \/\/ skip initial '-'\n+                } else if (line.startsWith(\"+\")) {\n+                    hasSeenLinesWithPlusPrefix = true;\n+                    targetLines.add(line.substring(1)); \/\/ skip initial '+'\n+                } else {\n+                    throw new IllegalStateException(\"Unexpected diff line: \" + line);\n+                }\n+            }\n+            hunks.add(new Hunk(Range.fromString(sourceRange), sourceLines, sourceHasNewlineAtEndOfFile,\n+                               Range.fromString(targetRange), targetLines, targetHasNewlineAtEndOfFile));\n+        }\n+\n+        return Hunks.ofTextual(hunks);\n+    }\n+\n+    private Hunks parseSingleFileHunks(UnixStreamReader reader) throws IOException {\n+        if (!line.startsWith(\"diff\")) {\n+            throw new IllegalStateException(\"Unexpected diff line: \" + line);\n+        }\n+\n+        while ((line = reader.readLine()) != null &&\n+                !line.startsWith(\"@@\") &&\n+                !line.startsWith(\"GIT binary patch\") &&\n+                !line.startsWith(\"diff\") &&\n+                !line.equals(delimiter)) {\n+            \/\/ ignore extended headers, we have the data via the 'raw' lines\n+        }\n+\n+        if (line != null && line.startsWith(\"GIT binary patch\")) {\n+            return parseSingleFileBinaryHunks(reader);\n+        } else {\n+            return parseSingleFileTextualHunks(reader);\n+        }\n+    }\n+\n+    private List<Hunks> parseHunks(InputStream stream) throws IOException {\n+        return parseHunks(new UnixStreamReader(stream));\n+    }\n+\n+    private List<Hunks> parseHunks(UnixStreamReader reader) throws IOException {\n+        var hunks = new ArrayList<Hunks>();\n+\n+        line = reader.readLine();\n+        while (line != null && !line.equals(delimiter)) {\n+            hunks.add(parseSingleFileHunks(reader));\n+        }\n+\n+        return hunks;\n+    }\n+\n+    public static List<Patch> parse(InputStream stream) throws IOException {\n+        return parse(new UnixStreamReader(stream));\n+    }\n+\n+    public static List<Patch> parse(InputStream stream, String delimiter) throws IOException {\n+        return parse(new UnixStreamReader(stream), delimiter);\n+    }\n+\n+    public static List<Patch> parse(UnixStreamReader reader) throws IOException {\n+        return parse(reader, null);\n+    }\n+\n+    public static List<Patch> parse(UnixStreamReader reader, String delimiter) throws IOException {\n+        var parser = new GitRawDiffParser(delimiter);\n+\n+        var headers = parser.parseRawLines(reader);\n+        var hunks = parser.parseHunks(reader);\n+\n+        if (headers.size() != hunks.size()) {\n+            throw new IOException(\"Num headers (\" + headers.size() + \") differ from num hunks (\" + hunks.size() + \")\");\n+        }\n+\n+        var patches = new ArrayList<Patch>();\n+        for (var i = 0; i < headers.size(); i++) {\n+            var headerForPatch = headers.get(i);\n+            var hunksForPatch = hunks.get(i);\n+\n+            if (hunksForPatch.areBinary()) {\n+                patches.add(new BinaryPatch(headerForPatch.sourcePath(), headerForPatch.sourceFileType(), headerForPatch.sourceHash(),\n+                                            headerForPatch.targetPath(), headerForPatch.targetFileType(), headerForPatch.targetHash(),\n+                                            headerForPatch.status(), hunksForPatch.binary()));\n+            } else {\n+                patches.add(new TextualPatch(headerForPatch.sourcePath(), headerForPatch.sourceFileType(), headerForPatch.sourceHash(),\n+                                             headerForPatch.targetPath(), headerForPatch.targetFileType(), headerForPatch.targetHash(),\n+                                             headerForPatch.status(), hunksForPatch.textual()));\n+            }\n+        }\n+\n+        return patches;\n+    }\n+}\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/tools\/GitRawDiffParser.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -1,288 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.skara.vcs.tools;\n-\n-import org.openjdk.skara.encoding.Base85;\n-import org.openjdk.skara.vcs.*;\n-\n-import java.io.*;\n-import java.nio.charset.StandardCharsets;\n-import java.util.*;\n-import java.util.zip.Inflater;\n-import java.util.zip.DataFormatException;\n-\n-public class UnifiedDiffParser {\n-    private static class Hunks {\n-        private final List<Hunk> textual;\n-        private final List<BinaryHunk> binary;\n-\n-        private Hunks(List<Hunk> textual, List<BinaryHunk> binary) {\n-            this.textual = textual;\n-            this.binary = binary;\n-        }\n-\n-        static Hunks ofTextual(List<Hunk> textual) {\n-            return new Hunks(textual, null);\n-        }\n-\n-        static Hunks ofBinary(List<BinaryHunk> binary) {\n-            return new Hunks(null, binary);\n-        }\n-\n-        boolean areBinary() {\n-            return binary != null;\n-        }\n-\n-        List<BinaryHunk> binary() {\n-            return binary;\n-        }\n-\n-        List<Hunk> textual() {\n-            return textual;\n-        }\n-    }\n-\n-    private final String delimiter;\n-    private String line = null;\n-\n-    private UnifiedDiffParser(String delimiter) {\n-        this.delimiter = delimiter;\n-    }\n-\n-    private List<PatchHeader> parseRawLines(InputStream stream) throws IOException {\n-        return parseRawLines(new UnixStreamReader(stream));\n-    }\n-\n-    private List<PatchHeader> parseRawLines(UnixStreamReader reader) throws IOException {\n-        var headers = new ArrayList<PatchHeader>();\n-\n-        line = reader.readLine();\n-        while (line != null && line.startsWith(\":\")) {\n-            headers.add(PatchHeader.fromRawLine(line));\n-            line = reader.readLine();\n-        }\n-\n-        return headers;\n-    }\n-\n-    private Hunks parseSingleFileBinaryHunks(UnixStreamReader reader) throws IOException {\n-        var hunks = new ArrayList<BinaryHunk>();\n-        while ((line = reader.readLine()) != null &&\n-                !line.startsWith(\"diff\") &&\n-                !line.equals(delimiter)) {\n-            var words = line.split(\" \");\n-            var format = words[0];\n-            var inflatedSize = Integer.parseInt(words[1]);\n-\n-            var data = new ArrayList<String>();\n-            while ((line = reader.readLine()) != null && !line.equals(\"\")) {\n-                data.add(line);\n-            }\n-\n-            if (format.equals(\"literal\")) {\n-                hunks.add(BinaryHunk.ofLiteral(inflatedSize, data));\n-            } else if (format.equals(\"delta\")) {\n-                hunks.add(BinaryHunk.ofDelta(inflatedSize, data));\n-            } else {\n-                throw new IllegalStateException(\"Unexpected binary diff format: \" + words[0]);\n-            }\n-        }\n-        return Hunks.ofBinary(hunks);\n-    }\n-\n-    private Hunks parseSingleFileTextualHunks(UnixStreamReader reader) throws IOException {\n-        var hunks = new ArrayList<Hunk>();\n-\n-        while (line != null && line.startsWith(\"@@\")) {\n-            var words = line.split(\"\\\\s\");\n-            if (!words[0].startsWith(\"@@\")) {\n-                throw new IllegalStateException(\"Unexpected diff line: \" + line);\n-            }\n-\n-            var sourceRange = words[1].substring(1); \/\/ skip initial '-'\n-            var targetRange = words[2].substring(1); \/\/ skip initial '+'\n-\n-            var sourceLines = new ArrayList<String>();\n-            var sourceHasNewlineAtEndOfFile = true;\n-            var targetLines = new ArrayList<String>();\n-            var targetHasNewlineAtEndOfFile = true;\n-            var hasSeenLinesWithPlusPrefix = false;\n-            while ((line = reader.readLine()) != null &&\n-                   !line.startsWith(\"@@\") &&\n-                   !line.startsWith(\"diff\") &&\n-                   !line.equals(delimiter)) {\n-                if (line.equals(\"\\\\ No newline at end of file\")) {\n-                    if (!hasSeenLinesWithPlusPrefix) {\n-                        sourceHasNewlineAtEndOfFile = false;\n-                    } else {\n-                        targetHasNewlineAtEndOfFile = false;\n-                    }\n-                    continue;\n-                }\n-\n-                if (line.startsWith(\"-\")) {\n-                    sourceLines.add(line.substring(1)); \/\/ skip initial '-'\n-                } else if (line.startsWith(\"+\")) {\n-                    hasSeenLinesWithPlusPrefix = true;\n-                    targetLines.add(line.substring(1)); \/\/ skip initial '+'\n-                } else {\n-                    throw new IllegalStateException(\"Unexpected diff line: \" + line);\n-                }\n-            }\n-            hunks.add(new Hunk(GitRange.fromString(sourceRange), sourceLines, sourceHasNewlineAtEndOfFile,\n-                               GitRange.fromString(targetRange), targetLines, targetHasNewlineAtEndOfFile));\n-        }\n-\n-        return Hunks.ofTextual(hunks);\n-    }\n-\n-    private Hunks parseSingleFileHunks(UnixStreamReader reader) throws IOException {\n-        if (!line.startsWith(\"diff\")) {\n-            throw new IllegalStateException(\"Unexpected diff line: \" + line);\n-        }\n-\n-        while ((line = reader.readLine()) != null &&\n-                !line.startsWith(\"@@\") &&\n-                !line.startsWith(\"GIT binary patch\") &&\n-                !line.startsWith(\"diff\") &&\n-                !line.equals(delimiter)) {\n-            \/\/ ignore extended headers, we have the data via the 'raw' lines\n-        }\n-\n-        if (line != null && line.startsWith(\"GIT binary patch\")) {\n-            return parseSingleFileBinaryHunks(reader);\n-        } else {\n-            return parseSingleFileTextualHunks(reader);\n-        }\n-    }\n-\n-    private List<Hunks> parseHunks(InputStream stream) throws IOException {\n-        return parseHunks(new UnixStreamReader(stream));\n-    }\n-\n-    private List<Hunks> parseHunks(UnixStreamReader reader) throws IOException {\n-        var hunks = new ArrayList<Hunks>();\n-\n-        line = reader.readLine();\n-        while (line != null && !line.equals(delimiter)) {\n-            hunks.add(parseSingleFileHunks(reader));\n-        }\n-\n-        return hunks;\n-    }\n-\n-    public static List<Patch> parseGitRaw(InputStream stream) throws IOException {\n-        return parseGitRaw(new UnixStreamReader(stream));\n-    }\n-\n-    public static List<Patch> parseGitRaw(InputStream stream, String delimiter) throws IOException {\n-        return parseGitRaw(new UnixStreamReader(stream), delimiter);\n-    }\n-\n-    public static List<Patch> parseGitRaw(UnixStreamReader reader) throws IOException {\n-        return parseGitRaw(reader, null);\n-    }\n-\n-    public static List<Patch> parseGitRaw(UnixStreamReader reader, String delimiter) throws IOException {\n-        var parser = new UnifiedDiffParser(delimiter);\n-\n-        var headers = parser.parseRawLines(reader);\n-        var hunks = parser.parseHunks(reader);\n-\n-        if (headers.size() != hunks.size()) {\n-            throw new IOException(\"Num headers (\" + headers.size() + \") differ from num hunks (\" + hunks.size() + \")\");\n-        }\n-\n-        var patches = new ArrayList<Patch>();\n-        for (var i = 0; i < headers.size(); i++) {\n-            var headerForPatch = headers.get(i);\n-            var hunksForPatch = hunks.get(i);\n-\n-            if (hunksForPatch.areBinary()) {\n-                patches.add(new BinaryPatch(headerForPatch.sourcePath(), headerForPatch.sourceFileType(), headerForPatch.sourceHash(),\n-                                            headerForPatch.targetPath(), headerForPatch.targetFileType(), headerForPatch.targetHash(),\n-                                            headerForPatch.status(), hunksForPatch.binary()));\n-            } else {\n-                patches.add(new TextualPatch(headerForPatch.sourcePath(), headerForPatch.sourceFileType(), headerForPatch.sourceHash(),\n-                                             headerForPatch.targetPath(), headerForPatch.targetFileType(), headerForPatch.targetHash(),\n-                                             headerForPatch.status(), hunksForPatch.textual()));\n-            }\n-        }\n-\n-        return patches;\n-    }\n-\n-    public static List<Hunk> splitDiffWithContext(Range from, Range to, List<String> lines) {\n-        var hunks = new ArrayList<Hunk>();\n-\n-        var sourceStart = from.start();\n-        var targetStart = to.start();\n-\n-        var sourceLines = new ArrayList<String>();\n-        var targetLines = new ArrayList<String>();\n-\n-        int i = 0;\n-        while (i < lines.size() && lines.get(i).startsWith(\" \")) {\n-            i++;\n-            sourceStart++;\n-            targetStart++;\n-        }\n-\n-        while (i < lines.size()) {\n-            var line = lines.get(i);\n-            if (line.startsWith(\"-\")) {\n-                sourceLines.add(line.substring(1));\n-                i++;\n-                continue;\n-            } else if (line.startsWith(\"+\")) {\n-                targetLines.add(line.substring(1));\n-                i++;\n-                continue;\n-            }\n-\n-            if (line.startsWith(\" \")) {\n-                hunks.add(new Hunk(new Range(sourceStart, sourceLines.size()), sourceLines,\n-                                   new Range(targetStart, targetLines.size()), targetLines));\n-\n-                sourceStart += sourceLines.size();\n-                targetStart += targetLines.size();\n-\n-                sourceLines = new ArrayList<String>();\n-                targetLines = new ArrayList<String>();\n-\n-                while (i < lines.size() && lines.get(i).startsWith(\" \")) {\n-                    i++;\n-                    sourceStart++;\n-                    targetStart++;\n-                }\n-            }\n-        }\n-\n-        if (sourceLines.size() > 0 || targetLines.size() > 0) {\n-            hunks.add(new Hunk(new Range(sourceStart, sourceLines.size()), sourceLines,\n-                               new Range(targetStart, targetLines.size()), targetLines));\n-        }\n-\n-        return hunks;\n-    }\n-}\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/tools\/UnifiedDiffParser.java","additions":0,"deletions":288,"binary":false,"changes":288,"status":"deleted"}]}