{"files":[{"patch":"@@ -71,1 +71,2 @@\n-        'git-hg-export': 'org.openjdk.skara.cli\/org.openjdk.skara.cli.GitHgExport'\n+        'git-hg-export': 'org.openjdk.skara.cli\/org.openjdk.skara.cli.GitHgExport',\n+        'git-backport': 'org.openjdk.skara.cli\/org.openjdk.skara.cli.GitBackport'\n","filename":"cli\/build.gradle","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.cli;\n+\n+import org.openjdk.skara.args.*;\n+import org.openjdk.skara.vcs.*;\n+import org.openjdk.skara.forge.*;\n+import org.openjdk.skara.issuetracker.Comment;\n+import org.openjdk.skara.host.Credential;\n+import org.openjdk.skara.version.Version;\n+import org.openjdk.skara.proxy.HttpProxy;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+\n+public class GitBackport {\n+    private static String getOption(String name, Arguments arguments, ReadOnlyRepository repo) throws IOException {\n+        if (arguments.contains(name)) {\n+            return arguments.get(name).asString();\n+        }\n+\n+        var lines = repo.config(\"backport.\" + name);\n+        return lines.size() == 1 ? lines.get(0) : null;\n+    }\n+\n+    static final List<Flag> flags = List.of(\n+        Option.shortcut(\"u\")\n+              .fullname(\"username\")\n+              .describe(\"NAME\")\n+              .helptext(\"Username on host\")\n+              .optional(),\n+        Option.shortcut(\"\")\n+              .fullname(\"from\")\n+              .describe(\"REPO\")\n+              .helptext(\"Repository to backport from\")\n+              .optional(),\n+        Option.shortcut(\"\")\n+              .fullname(\"to\")\n+              .describe(\"REPO\")\n+              .helptext(\"Repository to backport to\")\n+              .optional(),\n+        Option.shortcut(\"\")\n+              .fullname(\"branch\")\n+              .describe(\"NAME\")\n+              .helptext(\"Name of branch to backport to (default to 'master')\")\n+              .optional(),\n+        Switch.shortcut(\"\")\n+              .fullname(\"verbose\")\n+              .helptext(\"Turn on verbose output\")\n+              .optional(),\n+        Switch.shortcut(\"\")\n+              .fullname(\"debug\")\n+              .helptext(\"Turn on debugging output\")\n+              .optional(),\n+        Switch.shortcut(\"\")\n+              .fullname(\"version\")\n+              .helptext(\"Print the version of this tool\")\n+              .optional()\n+    );\n+\n+    static final List<Input> inputs = List.of(\n+        Input.position(0)\n+             .describe(\"HASH\")\n+             .singular()\n+             .required()\n+    );\n+\n+    public static void main(String[] args) throws IOException, InterruptedException {\n+        var parser = new ArgumentParser(\"git-backport\", flags, inputs);\n+        var arguments = parser.parse(args);\n+\n+        if (arguments.contains(\"version\")) {\n+            System.out.println(\"git-backport version: \" + Version.fromManifest().orElse(\"unknown\"));\n+            System.exit(0);\n+        }\n+\n+        if (arguments.contains(\"verbose\") || arguments.contains(\"debug\")) {\n+            var level = arguments.contains(\"debug\") ? Level.FINER : Level.FINE;\n+            Logging.setup(level);\n+        }\n+\n+        HttpProxy.setup();\n+\n+        var cwd = Paths.get(\"\").toAbsolutePath();\n+        var repository = Repository.get(cwd);\n+        if (repository.isEmpty()) {\n+            System.err.println(\"error: no repository found at \" + cwd.toString());\n+            System.exit(1);\n+        }\n+        var repo = repository.get();\n+\n+        var from = getOption(\"from\", arguments, repo);\n+        var to = getOption(\"to\", arguments, repo);\n+\n+        if (from != null && to != null) {\n+            System.err.println(\"error: cannot specify both --from and --to\");\n+            System.exit(1);\n+        }\n+\n+        if (from == null && to == null) {\n+            System.err.println(\"error: must use either --from or --to\");\n+            System.exit(1);\n+        }\n+\n+        var hash = new Hash(arguments.at(0).asString());\n+        var resolved = repo.resolve(hash.hex());\n+        if (resolved.isPresent()) {\n+            hash = resolved.get();\n+        }\n+\n+        var origin = Remote.toWebURI(Remote.toURI(repo.pullPath(\"origin\"), true).toString());\n+        var username = getOption(\"username\", arguments, repo);\n+        var token = System.getenv(\"GIT_TOKEN\");\n+        var credentials = GitCredentials.fill(origin.getHost(), origin.getPath(), username, token, origin.getScheme());\n+        var forgeURI = URI.create(origin.getScheme() + \":\/\/\" + origin.getHost());\n+        var forge = Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));\n+        if (forge.isEmpty()) {\n+            System.err.println(\"error: could not find forge for \" + forgeURI.getHost());\n+            System.exit(1);\n+        }\n+\n+        var branch = getOption(\"branch\", arguments, repo);\n+\n+        HostedRepository hostedRepo = null;\n+        Comment comment = null;\n+        if (from != null) {\n+            var originName = origin.getPath().substring(1);\n+            var originRepo = forge.get().repository(originName);\n+            if (!originRepo.isPresent()) {\n+                System.err.println(\"error: repository named \" + originName + \" not present on \" + forge.get().name());\n+                System.exit(1);\n+            }\n+            var upstreamRepo = originRepo.get().parent().isPresent() ?\n+                originRepo.get().parent().get() : originRepo.get();\n+            var upstreamGroup = upstreamRepo.name().split(\"\/\")[0];\n+            var repoName = from.startsWith(\"http\") ? URI.create(from).getPath().substring(1) : from;\n+            if (!repoName.contains(\"\/\")) {\n+                repoName = upstreamGroup + \"\/\" + repoName;\n+            }\n+            var maybeHostedRepo = forge.get().repository(repoName);\n+            if (!maybeHostedRepo.isPresent()) {\n+                System.err.println(\"error: repository named \" + repoName + \" not present on \" + forge.get().name());\n+                System.exit(1);\n+            }\n+            hostedRepo = maybeHostedRepo.get();\n+            var targetName = upstreamRepo.name().split(\"\/\")[1];\n+            var message = \"\/backport \" + targetName;\n+            if (branch != null) {\n+                message += \" \" + branch;\n+            }\n+            comment = hostedRepo.addCommitComment(hash, message);\n+        } else if (to != null ) {\n+            var repoName = origin.getPath().substring(1);\n+            var maybeHostedRepo = forge.get().repository(repoName);\n+            if (!maybeHostedRepo.isPresent()) {\n+                System.err.println(\"error: repository named \" + repoName + \" not present on \" + forge.get().name());\n+                System.exit(1);\n+            }\n+            hostedRepo = maybeHostedRepo.get();\n+            var parent = hostedRepo.parent();\n+            if (parent.isPresent()) {\n+                hostedRepo = parent.get();\n+            }\n+            var targetName = to.startsWith(\"http\") ? URI.create(to).getPath().substring(1) : to;\n+            var message = \"\/backport \" + targetName;\n+            if (branch != null) {\n+                message += \" \" + branch;\n+            }\n+            comment = hostedRepo.addCommitComment(hash, message);\n+        } else {\n+            throw new IllegalStateException(\"Should not be here, both 'from' and 'to' are null\");\n+        }\n+\n+        var seenReply = false;\n+        var expected = \"<!-- Jmerge command reply message (\" + comment.id() + \") -->\";\n+        for (var i = 0; i < 90; i++) {\n+            var comments = hostedRepo.commitComments(hash);\n+            for (var c : comments) {\n+                var lines = c.body().split(\"\\n\");\n+                if (lines.length > 0 && lines[0].equals(expected)) {\n+                    for (var j = 1; j < lines.length; j++) {\n+                        System.out.println(lines[j]);\n+                    }\n+                    System.exit(0);\n+                }\n+            }\n+            Thread.sleep(2000);\n+        }\n+\n+        System.err.println(\"error: timed out waiting for response to \/backport command\");\n+        System.exit(1);\n+    }\n+}\n","filename":"cli\/src\/main\/java\/org\/openjdk\/skara\/cli\/GitBackport.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"}]}