{"files":[{"patch":"@@ -1,235 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.skara.bots.csr;\n-\n-import org.openjdk.skara.bot.*;\n-import org.openjdk.skara.forge.HostedRepository;\n-import org.openjdk.skara.forge.PullRequest;\n-import org.openjdk.skara.issuetracker.IssueProject;\n-import org.openjdk.skara.issuetracker.Issue;\n-import org.openjdk.skara.jbs.Backports;\n-import org.openjdk.skara.jbs.JdkVersion;\n-import org.openjdk.skara.jcheck.JCheckConfiguration;\n-\n-import java.nio.file.Path;\n-import java.util.*;\n-import java.util.logging.Logger;\n-\n-class CSRBot implements Bot, WorkItem {\n-    private final static String CSR_LABEL = \"csr\";\n-    private final static String CSR_UPDATE_MARKER = \"<!-- csr: 'update' -->\";\n-    private static final String PROGRESS_MARKER = \"<!-- Anything below this marker will be automatically updated, please do not edit manually! -->\";\n-    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots\");;\n-    private final HostedRepository repo;\n-    private final IssueProject project;\n-\n-    CSRBot(HostedRepository repo, IssueProject project) {\n-        this.repo = repo;\n-        this.project = project;\n-    }\n-\n-    @Override\n-    public boolean concurrentWith(WorkItem other) {\n-        if (!(other instanceof CSRBot)) {\n-            return true;\n-        }\n-\n-        return !repo.isSame(((CSRBot) other).repo);\n-    }\n-\n-    private String describe(PullRequest pr) {\n-        return repo.name() + \"#\" + pr.id();\n-    }\n-\n-    \/**\n-     * Get the fix version from the provided PR.\n-     *\/\n-    private static Optional<JdkVersion> getVersion(PullRequest pullRequest) {\n-        var confFile = pullRequest.repository().fileContents(\".jcheck\/conf\", pullRequest.targetRef());\n-        var configuration = JCheckConfiguration.parse(confFile.lines().toList());\n-        var version = configuration.general().version().orElse(null);\n-        if (version == null || \"\".equals(version)) {\n-            return Optional.empty();\n-        }\n-        return JdkVersion.parse(version);\n-    }\n-\n-    private boolean hasCsrIssueAndProgress(PullRequest pr, Issue csr) {\n-        var statusMessage = getStatusMessage(pr);\n-        return hasCsrIssue(statusMessage, csr) &&\n-               (statusMessage.contains(\"- [ ] Change requires a CSR request to be approved\") ||\n-                statusMessage.contains(\"- [x] Change requires a CSR request to be approved\"));\n-    }\n-\n-    private boolean hasCsrIssueAndProgressChecked(PullRequest pr, Issue csr) {\n-        var statusMessage = getStatusMessage(pr);\n-        return hasCsrIssue(statusMessage, csr) && statusMessage.contains(\"- [x] Change requires a CSR request to be approved\");\n-    }\n-\n-    private boolean hasCsrIssue(String statusMessage, Issue csr) {\n-        return statusMessage.contains(csr.id()) &&\n-               statusMessage.contains(csr.webUrl().toString()) &&\n-               statusMessage.contains(csr.title() + \" (**CSR**)\");\n-    }\n-\n-    private String getStatusMessage(PullRequest pr) {\n-        var lastIndex = pr.body().lastIndexOf(PROGRESS_MARKER);\n-        if (lastIndex == -1) {\n-            return \"\";\n-        } else {\n-            return pr.body().substring(lastIndex);\n-        }\n-    }\n-\n-    private void addUpdateMarker(PullRequest pr) {\n-        var statusMessage = getStatusMessage(pr);\n-        if (!statusMessage.contains(CSR_UPDATE_MARKER)) {\n-            pr.setBody(pr.body() + \"\\n\" + CSR_UPDATE_MARKER + \"\\n\");\n-        } else {\n-            log.info(\"The pull request \" + describe(pr) + \" has already had a csr update marker. Do not need to add it again.\");\n-        }\n-    }\n-\n-    @Override\n-    public Collection<WorkItem> run(Path scratchPath) {\n-        var prs = repo.pullRequests();\n-\n-        for (var pr : prs) {\n-            var issue = org.openjdk.skara.vcs.openjdk.Issue.fromStringRelaxed(pr.title());\n-            if (issue.isEmpty()) {\n-                log.info(\"No issue found in title for \" + describe(pr));\n-                continue;\n-            }\n-            var jbsIssueOpt = project.issue(issue.get().shortId());\n-            if (jbsIssueOpt.isEmpty()) {\n-                log.info(\"No issue found in JBS for \" + describe(pr));\n-                continue;\n-            }\n-\n-            var versionOpt = getVersion(pr);\n-            if (versionOpt.isEmpty()) {\n-                log.info(\"No fix version found in `.jcheck\/conf` for \" + describe(pr));\n-                continue;\n-            }\n-\n-            var csrOptional = Backports.findCsr(jbsIssueOpt.get(), versionOpt.get());\n-            if (csrOptional.isEmpty()) {\n-                log.info(\"No CSR found for \" + describe(pr));\n-                continue;\n-            }\n-            var csr = csrOptional.get();\n-\n-            log.info(\"Found CSR \" + csr.id() + \" for \" + describe(pr));\n-            if (!hasCsrIssueAndProgress(pr, csr)) {\n-                \/\/ If the PR body doesn't have the CSR issue or doesn't have the CSR progress,\n-                \/\/ this bot need to add the csr update marker so that the PR bot can update the message of the PR body.\n-                log.info(\"The PR body doesn't have the CSR issue or progress, adding the csr update marker for \" + describe(pr));\n-                addUpdateMarker(pr);\n-            }\n-\n-            var resolution = csr.properties().get(\"resolution\");\n-            if (resolution == null || resolution.isNull()) {\n-                if (!pr.labelNames().contains(CSR_LABEL)) {\n-                    log.info(\"CSR issue resolution is null for \" + describe(pr) + \", adding the CSR label\");\n-                    pr.addLabel(CSR_LABEL);\n-                } else {\n-                    log.info(\"CSR issue resolution is null for \" + describe(pr) + \", not removing the CSR label\");\n-                }\n-                continue;\n-            }\n-            var name = resolution.get(\"name\");\n-            if (name == null || name.isNull()) {\n-                if (!pr.labelNames().contains(CSR_LABEL)) {\n-                    log.info(\"CSR issue resolution name is null for \" + describe(pr) + \", adding the CSR label\");\n-                    pr.addLabel(CSR_LABEL);\n-                } else {\n-                    log.info(\"CSR issue resolution name is null for \" + describe(pr) + \", not removing the CSR label\");\n-                }\n-                continue;\n-            }\n-\n-            if (csr.state() != Issue.State.CLOSED) {\n-                if (!pr.labelNames().contains(CSR_LABEL)) {\n-                    log.info(\"CSR issue state is not closed for \" + describe(pr) + \", adding the CSR label\");\n-                    pr.addLabel(CSR_LABEL);\n-                } else {\n-                    log.info(\"CSR issue state is not closed for \" + describe(pr) + \", not removing the CSR label\");\n-                }\n-                continue;\n-            }\n-\n-            if (!name.asString().equals(\"Approved\")) {\n-                if (name.asString().equals(\"Withdrawn\")) {\n-                    \/\/ This condition is necessary to prevent the bot from adding the CSR label again.\n-                    \/\/ And the bot can't remove the CSR label automatically here.\n-                    \/\/ Because the PR author with the role of Committer may withdraw a CSR that\n-                    \/\/ a Reviewer had requested and integrate it without satisfying that requirement.\n-                    log.info(\"CSR closed and withdrawn for \" + describe(pr) + \", not revising (not adding and not removing) CSR label\");\n-                } else if (!pr.labelNames().contains(CSR_LABEL)) {\n-                    log.info(\"CSR issue resolution is not 'Approved' for \" + describe(pr) + \", adding the CSR label\");\n-                    pr.addLabel(CSR_LABEL);\n-                } else {\n-                    log.info(\"CSR issue resolution is not 'Approved' for \" + describe(pr) + \", not removing the CSR label\");\n-                }\n-                continue;\n-            }\n-\n-            if (pr.labelNames().contains(CSR_LABEL)) {\n-                log.info(\"CSR closed and approved for \" + describe(pr) + \", removing CSR label\");\n-                pr.removeLabel(CSR_LABEL);\n-            }\n-            if (!hasCsrIssueAndProgressChecked(pr, csr)) {\n-                \/\/ If the PR body doesn't have the CSR issue or doesn't have the CSR progress or the CSR progress checkbox is not selected,\n-                \/\/ this bot need to add the csr update marker so that the PR bot can update the message of the PR body.\n-                log.info(\"CSR closed and approved for \" + describe(pr) + \", adding the csr update marker\");\n-                addUpdateMarker(pr);\n-            }\n-        }\n-        return List.of();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"CSRBot@\" + repo.name();\n-    }\n-\n-    @Override\n-    public List<WorkItem> getPeriodicItems() {\n-        return List.of(this);\n-    }\n-\n-    @Override\n-    public String workItemName() {\n-        return botName();\n-    }\n-\n-    @Override\n-    public String botName() {\n-        return name();\n-    }\n-\n-    @Override\n-    public String name() {\n-        return CSRBotFactory.NAME;\n-    }\n-}\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/CSRBot.java","additions":0,"deletions":235,"binary":false,"changes":235,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.util.HashMap;\n+import java.util.HashSet;\n@@ -30,0 +32,2 @@\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.issuetracker.IssueProject;\n@@ -31,0 +35,4 @@\n+\/**\n+ * The factory creates a CSRPullRequestBot for every configured repository\n+ * and a CSRIssueBot for each unique IssueProject found.\n+ *\/\n@@ -32,1 +40,1 @@\n-    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots\");;\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.csr\");\n@@ -43,0 +51,1 @@\n+        var prBots = new ArrayList<Bot>();\n@@ -44,0 +53,2 @@\n+        var issueProjects = new HashSet<IssueProject>();\n+        var repositories = new HashMap<IssueProject, List<HostedRepository>>();\n@@ -47,1 +58,6 @@\n-            var issues = configuration.issueProject(project.get(\"issues\").asString());\n+            var issueProject = configuration.issueProject(project.get(\"issues\").asString());\n+            issueProjects.add(issueProject);\n+            if (!repositories.containsKey(issueProject)) {\n+                repositories.put(issueProject, new ArrayList<>());\n+            }\n+            repositories.get(issueProject).add(repo);\n@@ -49,1 +65,5 @@\n-            ret.add(new CSRBot(repo, issues));\n+            prBots.add(new CSRPullRequestBot(repo, issueProject));\n+        }\n+\n+        for (IssueProject issueProject : issueProjects) {\n+            ret.add(new CSRIssueBot(issueProject, repositories.get(issueProject)));\n@@ -51,0 +71,2 @@\n+        \/\/ Need to add the PR bots after the issue bots, so that issue bots are called first\n+        ret.addAll(prBots);\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/CSRBotFactory.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+package org.openjdk.skara.bots.csr;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+import org.openjdk.skara.bot.Bot;\n+import org.openjdk.skara.bot.WorkItem;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.issuetracker.Issue;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+\n+\/**\n+ * The CSRIssueBot polls an IssueProject for updated issues of CSR type. When\n+ * found, IssueWorkItems are created to figure out if any PR needs to be\n+ * re-evaluated.\n+ *\/\n+public class CSRIssueBot implements Bot {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.csr\");\n+\n+    private final IssueProject issueProject;\n+    private final List<HostedRepository> repositories;\n+    \/\/ Keeps track of updatedAt timestamps from the previous call to getPeriodicItems,\n+    \/\/ so we can avoid re-evaluating issues that are returned again without any actual\n+    \/\/ update.\n+    private Map<String, ZonedDateTime> issueUpdatedAt = new HashMap<>();\n+    \/\/ The last found updatedAt from any issue.\n+    private ZonedDateTime lastUpdatedAt;\n+\n+    public CSRIssueBot(IssueProject issueProject, List<HostedRepository> repositories) {\n+        this.issueProject = issueProject;\n+        this.repositories = repositories;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CSRIssueBot@\" + issueProject.name();\n+    }\n+\n+    @Override\n+    public List<WorkItem> getPeriodicItems() {\n+        var ret = new ArrayList<WorkItem>();\n+        \/\/ In the very first round, we just find the last updated issue to\n+        \/\/ initialize lastUpdatedAt.\n+        if (lastUpdatedAt == null) {\n+            var lastUpdatedIssue = issueProject.lastUpdatedIssue();\n+            if (lastUpdatedIssue.isPresent()) {\n+                Issue issue = lastUpdatedIssue.get();\n+                lastUpdatedAt = issue.updatedAt();\n+                issueUpdatedAt.put(issue.id(), issue.updatedAt());\n+                log.fine(\"Setting lastUpdatedAt from last updated issue \" + issue.id() + \" updated at \" + lastUpdatedAt);\n+            } else {\n+                \/\/ If no previous issue was found, initiate lastUpdatedAt to something far\n+                \/\/ enough back so that we are guaranteed to find any new CSR issues going\n+                \/\/ forward.\n+                lastUpdatedAt = ZonedDateTime.ofInstant(Instant.EPOCH, ZoneId.systemDefault());\n+                log.warning(\"No CSR issue found, setting lastUpdatedAt to \" + lastUpdatedAt);\n+            }\n+            return ret;\n+        }\n+\n+        var newIssuesUpdatedAt = new HashMap<String, ZonedDateTime>();\n+        var issues = issueProject.csrIssues(lastUpdatedAt);\n+        for (var issue : issues) {\n+            newIssuesUpdatedAt.put(issue.id(), issue.updatedAt());\n+            \/\/ Update the lastUpdatedAt value with the highest found value for next call\n+            if (issue.updatedAt().isAfter(lastUpdatedAt)) {\n+                lastUpdatedAt = issue.updatedAt();\n+            }\n+            var lastUpdate = issueUpdatedAt.get(issue.id());\n+            if (lastUpdate != null) {\n+                if (!issue.updatedAt().isAfter(lastUpdate)) {\n+                    continue;\n+                }\n+            }\n+            var issueWorkItem = new IssueWorkItem(this, issue);\n+            log.fine(\"Scheduling: \" + issueWorkItem);\n+            ret.add(issueWorkItem);\n+        }\n+        issueUpdatedAt = newIssuesUpdatedAt;\n+        return ret;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return CSRBotFactory.NAME;\n+    }\n+\n+    List<HostedRepository> repositories() {\n+        return repositories;\n+    }\n+}\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/CSRIssueBot.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.csr;\n+\n+import java.time.ZonedDateTime;\n+import org.openjdk.skara.bot.*;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+\n+import java.util.*;\n+import java.util.logging.Logger;\n+\n+\/**\n+ * The CSRPullRequestBot polls all PRs for a specific repository for updates.\n+ * When found, PullRequestWorkItems are created to re-evaluate CSR state for\n+ * the PR.\n+ *\/\n+class CSRPullRequestBot implements Bot {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.csr\");\n+    private final HostedRepository repo;\n+    private final IssueProject project;\n+    \/\/ Keeps track of updatedAt timestamps from the previous call to getPeriodicItems,\n+    \/\/ so we can avoid re-evaluating PRs that are returned again without any actual\n+    \/\/ update. This is needed because timestamp based searches aren't exact enough\n+    \/\/ to avoid sometimes receiving the same items multiple times.\n+    private Map<String, ZonedDateTime> prsUpdatedAt = new HashMap<>();\n+    \/\/ The last found updateAt in any returned PR. Used for limiting results on the\n+    \/\/ next call to the hosted repo. Should only contain timestamps originating\n+    \/\/ from the remote repo to avoid problems with mismatched clocks.\n+    private ZonedDateTime lastUpdatedAt;\n+\n+    CSRPullRequestBot(HostedRepository repo, IssueProject project) {\n+        this.repo = repo;\n+        this.project = project;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CSRPullRequestBot@\" + repo.name();\n+    }\n+\n+    @Override\n+    public List<WorkItem> getPeriodicItems() {\n+        var items = new ArrayList<WorkItem>();\n+        log.info(\"Fetching all open pull requests for \" + repo.name());\n+        Map<String, ZonedDateTime> newPrsUpdatedAt = new HashMap<>();\n+        \/\/ On the first run we have to re-evaluate all open PRs, after that, only\n+        \/\/ looking at PRs that have been updated should be enough.\n+        var prs = lastUpdatedAt != null ? repo.openPullRequestsAfter(lastUpdatedAt) : repo.pullRequests();\n+        for (PullRequest pr : prs) {\n+            newPrsUpdatedAt.put(pr.id(), pr.updatedAt());\n+            \/\/ Update lastUpdatedAt with the last found updatedAt for the next call\n+            if (lastUpdatedAt == null || pr.updatedAt().isAfter(lastUpdatedAt)) {\n+                lastUpdatedAt = pr.updatedAt();\n+            }\n+            var lastUpdate = prsUpdatedAt.get(pr.id());\n+            if (lastUpdate != null) {\n+                if (!pr.updatedAt().isAfter(lastUpdate)) {\n+                    continue;\n+                }\n+            }\n+            var pullRequestWorkItem = new PullRequestWorkItem(repo, pr.id(), project);\n+            log.fine(\"Scheduling: \" + pullRequestWorkItem);\n+            items.add(pullRequestWorkItem);\n+        }\n+        prsUpdatedAt = newPrsUpdatedAt;\n+        return items;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return CSRBotFactory.NAME;\n+    }\n+}\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/CSRPullRequestBot.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+package org.openjdk.skara.bots.csr;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+import org.openjdk.skara.bot.WorkItem;\n+import org.openjdk.skara.forge.PullRequestUtils;\n+import org.openjdk.skara.issuetracker.Issue;\n+import org.openjdk.skara.issuetracker.Link;\n+import org.openjdk.skara.jbs.Backports;\n+\n+\/**\n+ * The IssueWorkItem is read-only. Its purpose is to create PullRequestWorkItems for\n+ * every pull request found in the Backport hierarchy associated with a CSR issue.\n+ * It should only be triggered when a modified CSR issue has been found.\n+ *\/\n+class IssueWorkItem implements WorkItem {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.csr\");\n+\n+    private final CSRIssueBot bot;\n+    private final Issue csrIssue;\n+\n+    public IssueWorkItem(CSRIssueBot bot, Issue csrIssue) {\n+        this.bot = bot;\n+        this.csrIssue = csrIssue;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return botName() + \"\/IssueWorkItem@\" + csrIssue.id();\n+    }\n+\n+    @Override\n+    public boolean concurrentWith(WorkItem other) {\n+        if (!(other instanceof IssueWorkItem otherItem)) {\n+            return true;\n+        }\n+\n+        return !csrIssue.project().name().equals(otherItem.csrIssue.project().name());\n+    }\n+\n+    @Override\n+    public Collection<WorkItem> run(Path scratchPath) {\n+        var link = csrIssue.links().stream()\n+                .filter(l -> l.relationship().isPresent() && \"csr of\".equals(l.relationship().get())).findAny();\n+        var issue = link.flatMap(Link::issue);\n+        var mainIssue = issue.flatMap(Backports::findMainIssue);\n+        if (mainIssue.isEmpty()) {\n+            return List.of();\n+        }\n+        var backports = Backports.findBackports(mainIssue.get(), false);\n+        var ret = new ArrayList<WorkItem>();\n+        Stream.concat(mainIssue.stream(), backports.stream())\n+                .flatMap(i -> PullRequestUtils.pullRequestCommentLink(i).stream())\n+                .map(uri -> bot.repositories().stream()\n+                        .map(r -> r.parsePullRequestUrl(uri.toString()))\n+                        .flatMap(Optional::stream)\n+                        .findAny())\n+                .flatMap(Optional::stream)\n+                .map(pr -> new PullRequestWorkItem(pr.repository(), pr.id(), csrIssue.project()))\n+                .forEach(ret::add);\n+        ret.forEach(item -> log.fine(\"Scheduling: \" + item.toString() + \" due to update in \" + csrIssue.id()));\n+        return ret;\n+    }\n+\n+    @Override\n+    public String botName() {\n+        return CSRBotFactory.NAME;\n+    }\n+\n+    @Override\n+    public String workItemName() {\n+        return \"issue\";\n+    }\n+}\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/IssueWorkItem.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+package org.openjdk.skara.bots.csr;\n+\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+import org.openjdk.skara.bot.WorkItem;\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.Issue;\n+import org.openjdk.skara.issuetracker.IssueProject;\n+import org.openjdk.skara.jbs.Backports;\n+import org.openjdk.skara.jbs.JdkVersion;\n+import org.openjdk.skara.jcheck.JCheckConfiguration;\n+\n+\/**\n+ * The PullRequestWorkItem is the work horse of the CSRBot. It gets triggered when\n+ * either the pull request itself, or any CSR issue associated with it have been\n+ * updated. It operates on one single pull request and re-evaluates the CSR state\n+ * for it.\n+ *\/\n+class PullRequestWorkItem implements WorkItem {\n+    private final static String CSR_LABEL = \"csr\";\n+    private final static String CSR_UPDATE_MARKER = \"<!-- csr: 'update' -->\";\n+    private static final String PROGRESS_MARKER = \"<!-- Anything below this marker will be automatically updated, please do not edit manually! -->\";\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.csr\");\n+    private final HostedRepository repository;\n+    private final String prId;\n+    private final IssueProject project;\n+\n+    public PullRequestWorkItem(HostedRepository repository, String prId, IssueProject project) {\n+        this.repository = repository;\n+        this.prId = prId;\n+        this.project = project;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return botName()+ \"\/PullRequestWorkItem@\" + repository.name() + \"#\" + prId;\n+    }\n+\n+    @Override\n+    public boolean concurrentWith(WorkItem other) {\n+        if (!(other instanceof PullRequestWorkItem item)) {\n+            return true;\n+        }\n+\n+        return !(repository.isSame(item.repository) && prId.equals(item.prId));\n+    }\n+\n+    private String describe(PullRequest pr) {\n+        return pr.repository().name() + \"#\" + pr.id();\n+    }\n+\n+    \/**\n+     * Get the fix version from the provided PR.\n+     *\/\n+    private static Optional<JdkVersion> getVersion(PullRequest pullRequest) {\n+        var confFile = pullRequest.repository().fileContents(\".jcheck\/conf\", pullRequest.targetRef());\n+        var configuration = JCheckConfiguration.parse(confFile.lines().toList());\n+        var version = configuration.general().version().orElse(null);\n+        if (version == null || \"\".equals(version)) {\n+            return Optional.empty();\n+        }\n+        return JdkVersion.parse(version);\n+    }\n+\n+    private boolean hasCsrIssueAndProgress(PullRequest pr, Issue csr) {\n+        var statusMessage = getStatusMessage(pr);\n+        return hasCsrIssue(statusMessage, csr) &&\n+                (statusMessage.contains(\"- [ ] Change requires a CSR request to be approved\") ||\n+                        statusMessage.contains(\"- [x] Change requires a CSR request to be approved\"));\n+    }\n+\n+    private boolean hasCsrIssueAndProgressChecked(PullRequest pr, Issue csr) {\n+        var statusMessage = getStatusMessage(pr);\n+        return hasCsrIssue(statusMessage, csr) && statusMessage.contains(\"- [x] Change requires a CSR request to be approved\");\n+    }\n+\n+    private boolean hasCsrIssue(String statusMessage, Issue csr) {\n+        return statusMessage.contains(csr.id()) &&\n+                statusMessage.contains(csr.webUrl().toString()) &&\n+                statusMessage.contains(csr.title() + \" (**CSR**)\");\n+    }\n+\n+    private String getStatusMessage(PullRequest pr) {\n+        var lastIndex = pr.body().lastIndexOf(PROGRESS_MARKER);\n+        if (lastIndex == -1) {\n+            return \"\";\n+        } else {\n+            return pr.body().substring(lastIndex);\n+        }\n+    }\n+\n+    private void addUpdateMarker(PullRequest pr) {\n+        var statusMessage = getStatusMessage(pr);\n+        if (!statusMessage.contains(CSR_UPDATE_MARKER)) {\n+            pr.setBody(pr.body() + \"\\n\" + CSR_UPDATE_MARKER + \"\\n\");\n+        } else {\n+            log.info(\"The pull request \" + describe(pr) + \" has already had a csr update marker. Do not need to add it again.\");\n+        }\n+    }\n+\n+    @Override\n+    public Collection<WorkItem> run(Path scratchPath) {\n+        var pr = repository.pullRequest(prId);\n+\n+        var issue = org.openjdk.skara.vcs.openjdk.Issue.fromStringRelaxed(pr.title());\n+        if (issue.isEmpty()) {\n+            log.info(\"No issue found in title for \" + describe(pr));\n+            return List.of();\n+        }\n+        var jbsIssueOpt = project.issue(issue.get().shortId());\n+        if (jbsIssueOpt.isEmpty()) {\n+            log.info(\"No issue found in JBS for \" + describe(pr));\n+            return List.of();\n+        }\n+\n+        var versionOpt = getVersion(pr);\n+        if (versionOpt.isEmpty()) {\n+            log.info(\"No fix version found in `.jcheck\/conf` for \" + describe(pr));\n+            return List.of();\n+        }\n+\n+        var csrOptional = Backports.findCsr(jbsIssueOpt.get(), versionOpt.get());\n+        if (csrOptional.isEmpty()) {\n+            log.info(\"No CSR found for \" + describe(pr));\n+            return List.of();\n+        }\n+        var csr = csrOptional.get();\n+\n+        log.info(\"Found CSR \" + csr.id() + \" for \" + describe(pr));\n+        if (!hasCsrIssueAndProgress(pr, csr)) {\n+            \/\/ If the PR body doesn't have the CSR issue or doesn't have the CSR progress,\n+            \/\/ this bot need to add the csr update marker so that the PR bot can update the message of the PR body.\n+            log.info(\"The PR body doesn't have the CSR issue or progress, adding the csr update marker for \" + describe(pr));\n+            addUpdateMarker(pr);\n+        }\n+\n+        var resolution = csr.properties().get(\"resolution\");\n+        if (resolution == null || resolution.isNull()) {\n+            if (!pr.labelNames().contains(CSR_LABEL)) {\n+                log.info(\"CSR issue resolution is null for \" + describe(pr) + \", adding the CSR label\");\n+                pr.addLabel(CSR_LABEL);\n+            } else {\n+                log.info(\"CSR issue resolution is null for \" + describe(pr) + \", not removing the CSR label\");\n+            }\n+            return List.of();\n+        }\n+        var name = resolution.get(\"name\");\n+        if (name == null || name.isNull()) {\n+            if (!pr.labelNames().contains(CSR_LABEL)) {\n+                log.info(\"CSR issue resolution name is null for \" + describe(pr) + \", adding the CSR label\");\n+                pr.addLabel(CSR_LABEL);\n+            } else {\n+                log.info(\"CSR issue resolution name is null for \" + describe(pr) + \", not removing the CSR label\");\n+            }\n+            return List.of();\n+        }\n+\n+        if (csr.state() != Issue.State.CLOSED) {\n+            if (!pr.labelNames().contains(CSR_LABEL)) {\n+                log.info(\"CSR issue state is not closed for \" + describe(pr) + \", adding the CSR label\");\n+                pr.addLabel(CSR_LABEL);\n+            } else {\n+                log.info(\"CSR issue state is not closed for \" + describe(pr) + \", not removing the CSR label\");\n+            }\n+            return List.of();\n+        }\n+\n+        if (!name.asString().equals(\"Approved\")) {\n+            if (name.asString().equals(\"Withdrawn\")) {\n+                \/\/ This condition is necessary to prevent the bot from adding the CSR label again.\n+                \/\/ And the bot can't remove the CSR label automatically here.\n+                \/\/ Because the PR author with the role of Committer may withdraw a CSR that\n+                \/\/ a Reviewer had requested and integrate it without satisfying that requirement.\n+                log.info(\"CSR closed and withdrawn for \" + describe(pr) + \", not revising (not adding and not removing) CSR label\");\n+            } else if (!pr.labelNames().contains(CSR_LABEL)) {\n+                log.info(\"CSR issue resolution is not 'Approved' for \" + describe(pr) + \", adding the CSR label\");\n+                pr.addLabel(CSR_LABEL);\n+            } else {\n+                log.info(\"CSR issue resolution is not 'Approved' for \" + describe(pr) + \", not removing the CSR label\");\n+            }\n+            return List.of();\n+        }\n+\n+        if (pr.labelNames().contains(CSR_LABEL)) {\n+            log.info(\"CSR closed and approved for \" + describe(pr) + \", removing CSR label\");\n+            pr.removeLabel(CSR_LABEL);\n+        }\n+        if (!hasCsrIssueAndProgressChecked(pr, csr)) {\n+            \/\/ If the PR body doesn't have the CSR issue or doesn't have the CSR progress or the CSR progress checkbox is not selected,\n+            \/\/ this bot need to add the csr update marker so that the PR bot can update the message of the PR body.\n+            log.info(\"CSR closed and approved for \" + describe(pr) + \", adding the csr update marker\");\n+            addUpdateMarker(pr);\n+        }\n+        return List.of();\n+    }\n+\n+    @Override\n+    public String botName() {\n+        return CSRBotFactory.NAME;\n+    }\n+\n+    @Override\n+    public String workItemName() {\n+        return \"pr\";\n+    }\n+}\n","filename":"bots\/csr\/src\/main\/java\/org\/openjdk\/skara\/bots\/csr\/PullRequestWorkItem.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import org.openjdk.skara.forge.PullRequestUtils;\n@@ -53,1 +54,1 @@\n-            var bot = new CSRBot(repo, issues);\n+            var bot = new CSRPullRequestBot(repo, issues);\n@@ -84,1 +85,1 @@\n-            var bot = new CSRBot(repo, issues);\n+            var bot = new CSRPullRequestBot(repo, issues);\n@@ -115,1 +116,1 @@\n-            var bot = new CSRBot(repo, issues);\n+            var bot = new CSRPullRequestBot(repo, issues);\n@@ -153,1 +154,1 @@\n-            var bot = new CSRBot(repo, issues);\n+            var bot = new CSRPullRequestBot(repo, issues);\n@@ -193,1 +194,1 @@\n-            var bot = new CSRBot(repo, issues);\n+            var bot = new CSRPullRequestBot(repo, issues);\n@@ -234,1 +235,1 @@\n-            var bot = new CSRBot(repo, issues);\n+            var bot = new CSRPullRequestBot(repo, issues);\n@@ -268,1 +269,5 @@\n-            var bot = new CSRBot(repo, issueProject);\n+            var csrPullRequestBot = new CSRPullRequestBot(repo, issueProject);\n+            var csrIssueBot = new CSRIssueBot(issueProject, List.of(repo));\n+\n+            \/\/ Run issue bot once to initialize lastUpdatedAt\n+            TestBotRunner.runPeriodicItems(csrIssueBot);\n@@ -309,0 +314,3 @@\n+            \/\/ Add the notification link to the PR in the issue. This is needed for the CSRIssueBot to\n+            \/\/ be able to trigger on CSR issue updates\n+            PullRequestUtils.postPullRequestLinkComment(issue, pr);\n@@ -320,1 +328,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n@@ -333,1 +341,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n@@ -346,1 +354,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n@@ -352,2 +360,3 @@\n-            \/\/ Run bot. The primary CSR has the fix version `17`, so it would be used and the `csr` label would be added.\n-            TestBotRunner.runPeriodicItems(bot);\n+            \/\/ Run csr issue bot to trigger on updates to the CSR issue. The primary CSR has\n+            \/\/ the fix version `17`, so it would be used and the `csr` label would be added.\n+            TestBotRunner.runPeriodicItems(csrIssueBot);\n@@ -368,1 +377,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n@@ -378,2 +387,2 @@\n-            \/\/ Run bot. The bot can find a backport issue and a backport CSR.\n-            TestBotRunner.runPeriodicItems(bot);\n+            \/\/ Run csr issue bot. The bot can find a backport issue and a backport CSR.\n+            TestBotRunner.runPeriodicItems(csrIssueBot);\n@@ -396,1 +405,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n@@ -404,1 +413,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n@@ -419,1 +428,6 @@\n-            var bot = new CSRBot(repo, issueProject);\n+            issue.setProperty(\"issuetype\", JSON.of(\"Bug\"));\n+            var csrPullRequestBot = new CSRPullRequestBot(repo, issueProject);\n+            var csrIssueBot = new CSRIssueBot(issueProject, List.of(repo));\n+\n+            \/\/ Run issue bot once to initialize lastUpdatedAt\n+            TestBotRunner.runPeriodicItems(csrIssueBot);\n@@ -432,0 +446,3 @@\n+            \/\/ Add the notification link to the PR in the issue. This is needed for the CSRIssueBot to\n+            \/\/ be able to trigger on CSR issue updates\n+            PullRequestUtils.postPullRequestLinkComment(issue, pr);\n@@ -433,1 +450,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n@@ -439,0 +456,1 @@\n+            csr.setProperty(\"issuetype\", JSON.of(\"CSR\"));\n@@ -441,2 +459,6 @@\n-            \/\/ Run bot\n-            TestBotRunner.runPeriodicItems(bot);\n+            \/\/ Run just the pull request bot\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n+            \/\/ Nothing should have happened\n+            assertFalse(pr.body().contains(csrUpdateMarker));\n+            \/\/ Run csr issue bot to trigger updates on the CSR issue\n+            TestBotRunner.runPeriodicItems(csrIssueBot);\n@@ -450,1 +472,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n@@ -457,2 +479,2 @@\n-            \/\/ Run bot\n-            TestBotRunner.runPeriodicItems(bot);\n+            \/\/ un csr issue bot to trigger updates on the CSR issue\n+            TestBotRunner.runPeriodicItems(csrIssueBot);\n@@ -466,1 +488,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n@@ -474,1 +496,1 @@\n-            TestBotRunner.runPeriodicItems(bot);\n+            TestBotRunner.runPeriodicItems(csrPullRequestBot);\n","filename":"bots\/csr\/src\/test\/java\/org\/openjdk\/skara\/bots\/csr\/CSRBotTests.java","additions":48,"deletions":26,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.time.format.DateTimeFormatter;\n@@ -79,2 +78,0 @@\n-    private static final String pullRequestTip = \"A pull request was submitted for review.\";\n-\n@@ -231,6 +228,1 @@\n-        var alreadyPostedComment = realIssue.get().comments().stream()\n-                .filter(comment -> comment.author().equals(issueProject.issueTracker().currentUser()))\n-                .anyMatch(comment -> comment.body().contains(pullRequestTip) && comment.body().contains(pr.webUrl().toString()));\n-        if (!alreadyPostedComment) {\n-            realIssue.get().addComment(pullRequestToTextBrief(pr));\n-        }\n+        PullRequestUtils.postPullRequestLinkComment(realIssue.get(), pr);\n@@ -250,13 +242,1 @@\n-        var postedComment = realIssue.get().comments().stream()\n-                .filter(comment -> comment.author().equals(issueProject.issueTracker().currentUser()))\n-                .filter(comment -> comment.body().contains(pullRequestTip) && comment.body().contains(pr.webUrl().toString()))\n-                .findAny();\n-        postedComment.ifPresent(comment -> realIssue.get().removeComment(comment));\n-    }\n-\n-    private String pullRequestToTextBrief(PullRequest pr) {\n-        var builder = new StringBuilder();\n-        builder.append(pullRequestTip).append(\"\\n\");\n-        builder.append(\"URL: \").append(pr.webUrl().toString()).append(\"\\n\");\n-        builder.append(\"Date: \").append(pr.createdAt().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss +0000\")));\n-        return builder.toString();\n+        PullRequestUtils.removePullRequestLinkComment(realIssue.get(), pr);\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/issue\/IssueNotifier.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,5 @@\n+    @Override\n+    public List<PullRequest> openPullRequestsAfter(ZonedDateTime updatedAfter) {\n+        return null;\n+    }\n+\n","filename":"bots\/tester\/src\/test\/java\/org\/openjdk\/skara\/bots\/tester\/InMemoryHostedRepository.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,5 @@\n+\n+    \/**\n+     * Returns a list of all open pull requests that have been updated after the given time.\n+     *\/\n+    List<PullRequest> openPullRequestsAfter(ZonedDateTime updatedAfter);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/HostedRepository.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,0 +25,5 @@\n+import java.time.format.DateTimeFormatter;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import org.openjdk.skara.issuetracker.Comment;\n+import org.openjdk.skara.issuetracker.Issue;\n@@ -36,0 +41,2 @@\n+    private static final Logger log = Logger.getLogger(\"org.openjdk.skara.forge\");\n+\n@@ -217,0 +224,65 @@\n+\n+    private static final String pullRequestMessage = \"A pull request was submitted for review.\";\n+\n+    \/**\n+     * Adds a link to a pull request as a formatted comment to an issue.\n+     * @param issue Issue to add comment to\n+     * @param pr PR to link to\n+     *\/\n+    public static void postPullRequestLinkComment(Issue issue, PullRequest pr) {\n+        var alreadyPostedComment = issue.comments().stream()\n+                .filter(comment -> comment.author().equals(issue.project().issueTracker().currentUser()))\n+                .anyMatch(comment -> comment.body().contains(pullRequestMessage) && comment.body().contains(pr.webUrl().toString()));\n+        if (!alreadyPostedComment) {\n+            String builder = pullRequestMessage + \"\\n\" +\n+                    \"URL: \" + pr.webUrl().toString() + \"\\n\" +\n+                    \"Date: \" + pr.createdAt().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss +0000\"));\n+            issue.addComment(builder);\n+        }\n+    }\n+\n+    \/**\n+     * Removes a previously added comment with a link to a pull request from an issue.\n+     * @param issue Issue to remove comment from\n+     * @param pr PR that the comment linked to\n+     *\/\n+    public static void removePullRequestLinkComment(Issue issue, PullRequest pr) {\n+        var postedComment = issue.comments().stream()\n+                .filter(comment -> comment.author().equals(issue.project().issueTracker().currentUser()))\n+                .filter(comment -> comment.body().contains(pullRequestMessage) && comment.body().contains(pr.webUrl().toString()))\n+                .findAny();\n+        postedComment.ifPresent(issue::removeComment);\n+    }\n+\n+    \/**\n+     * Searches the comments of an issue for a pull request link.\n+     * @param issue Issue to search\n+     * @return List of all Web URI links to pull requests found in all the comments\n+     *\/\n+    public static List<URI> pullRequestCommentLink(Issue issue) {\n+        return issue.comments().stream()\n+                .filter(comment -> comment.author().equals(issue.project().issueTracker().currentUser()))\n+                .map(PullRequestUtils::parsePullRequestComment)\n+                .flatMap(Optional::stream)\n+                .toList();\n+\n+    }\n+\n+    private static final Pattern PR_URL_PATTERN = Pattern.compile(\"^URL: (.*)\");\n+\n+    private static Optional<URI> parsePullRequestComment(Comment comment) {\n+        var lines = comment.body().lines().toList();\n+        if (!lines.get(0).equals(pullRequestMessage)) {\n+            return Optional.empty();\n+        }\n+        var urlMatcher = PR_URL_PATTERN.matcher(lines.get(1));\n+        if (urlMatcher.matches()) {\n+            var url = urlMatcher.group(1);\n+            try {\n+                return Optional.of(URI.create(url));\n+            } catch (IllegalArgumentException e) {\n+                log.log(Level.WARNING, \"Invalid link in pull request link comment: \" + url, e);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequestUtils.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -166,0 +166,10 @@\n+    @Override\n+    public List<PullRequest> openPullRequestsAfter(ZonedDateTime updatedAfter) {\n+        return request.get(\"pulls\")\n+                .param(\"state\", \"open\")\n+                .execute().asArray().stream()\n+                .map(jsonValue -> new GitHubPullRequest(this, jsonValue, request))\n+                .filter(pr -> pr.updatedAt().isAfter(updatedAfter))\n+                .collect(Collectors.toList());\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubRepository.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,0 +154,11 @@\n+    @Override\n+    public List<PullRequest> openPullRequestsAfter(ZonedDateTime updatedAfter) {\n+        return request.get(\"merge_requests\")\n+                .param(\"state\", \"opened\")\n+                .param(\"updated_after\", updatedAfter.format(DateTimeFormatter.ISO_DATE_TIME))\n+                .execute().stream()\n+                .filter(this::hasHeadHash)\n+                .map(value -> new GitLabMergeRequest(this, gitLabHost, value, request))\n+                .collect(Collectors.toList());\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabRepository.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+package org.openjdk.skara.forge;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.test.CheckableRepository;\n+import org.openjdk.skara.test.HostCredentials;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+\n+public class PullRequestUtilsTests {\n+\n+    @Test\n+    void pullRequestLinkComment(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var repo = credentials.getHostedRepository();\n+            var repoFolder = tempFolder.path().resolve(\"repo\");\n+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());\n+            credentials.commitLock(localRepo);\n+            localRepo.pushAll(repo.url());\n+\n+            var issueProject = credentials.getIssueProject();\n+            var issue = issueProject.createIssue(\"This is an issue\", List.of(\"Indeed\"), Map.of(\"issuetype\", JSON.of(\"Enhancement\")));\n+            var editHash = CheckableRepository.appendAndCommit(localRepo, \"Another line\", issue.id() + \": Fix that issue\");\n+            localRepo.push(editHash, repo.url(), \"master\");\n+            var pr1 = credentials.createPullRequest(repo, \"master\", \"master\", issue.id() + \": Fix that issue\");\n+\n+            {\n+                assertEquals(0, issue.comments().size());\n+\n+                PullRequestUtils.postPullRequestLinkComment(issue, pr1);\n+                assertEquals(1, issue.comments().size());\n+\n+                var prLinks = PullRequestUtils.pullRequestCommentLink(issue);\n+                assertEquals(pr1.webUrl(), prLinks.get(0));\n+\n+                PullRequestUtils.removePullRequestLinkComment(issue, pr1);\n+                assertEquals(0, issue.comments().size());\n+            }\n+            {\n+                var pr2 = credentials.createPullRequest(repo, \"master\", \"master\", issue.id() + \": Fix that issue\");\n+\n+                PullRequestUtils.postPullRequestLinkComment(issue, pr1);\n+                PullRequestUtils.postPullRequestLinkComment(issue, pr2);\n+                assertEquals(2, issue.comments().size());\n+\n+                var prLinks = PullRequestUtils.pullRequestCommentLink(issue);\n+                assertEquals(pr1.webUrl(), prLinks.get(0));\n+                assertEquals(pr2.webUrl(), prLinks.get(1));\n+\n+                PullRequestUtils.removePullRequestLinkComment(issue, pr1);\n+                assertEquals(1, issue.comments().size());\n+\n+                prLinks = PullRequestUtils.pullRequestCommentLink(issue);\n+                assertEquals(pr2.webUrl(), prLinks.get(0));\n+            }\n+        }\n+    }\n+}\n","filename":"forge\/src\/test\/java\/org\/openjdk\/skara\/forge\/PullRequestUtilsTests.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -46,0 +46,14 @@\n+\n+    \/**\n+     * Find all issues of CSR type updated after the given timestamp.\n+     * Note that time queries in Jira are only on minute resolution.\n+     * @param updatedAfter Timestamp\n+     * @return List of issues found\n+     *\/\n+    List<Issue> csrIssues(ZonedDateTime updatedAfter);\n+\n+    \/**\n+     * Find the last updated issue.\n+     * @return The last updated issue, or empty if none exist\n+     *\/\n+    Optional<Issue> lastUpdatedIssue();\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/IssueProject.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.time.ZoneId;\n@@ -40,0 +41,1 @@\n+    private ZoneId timeZone;\n@@ -142,0 +144,8 @@\n+    public ZoneId timeZone() {\n+        if (timeZone == null) {\n+            var data = request.get(\"myself\").execute();\n+            timeZone = ZoneId.of(data.get(\"timeZone\").asString());\n+        }\n+        return timeZone;\n+    }\n+\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/jira\/JiraHost.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+        return id(json);\n+    }\n+\n+    static String id(JSONValue json) {\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/jira\/JiraIssue.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.time.format.DateTimeFormatter;\n@@ -417,0 +418,8 @@\n+    private RestRequest generateIssueRequest(String id) {\n+        return request.restrict(\"issue\/\" + id);\n+    }\n+\n+    private RestRequest generateIssueRequest(JSONValue json) {\n+        return generateIssueRequest(JiraIssue.id(json));\n+    }\n+\n@@ -422,1 +431,1 @@\n-        var issueRequest = request.restrict(\"issue\/\" + id);\n+        var issueRequest = generateIssueRequest(id);\n@@ -445,1 +454,2 @@\n-            return Optional.of(new JiraIssue(this, request, issues.get(\"issues\").asArray().get(0)));\n+            var json = issues.get(\"issues\").asArray().get(0);\n+            return Optional.of(new JiraIssue(this, generateIssueRequest(json), json));\n@@ -456,1 +466,1 @@\n-            ret.add(new JiraIssue(this, request, issue));\n+            ret.add(new JiraIssue(this, generateIssueRequest(issue), issue));\n@@ -463,0 +473,35 @@\n+        var timeString = toTimeString(updatedAfter);\n+        var jql = \"project = \" + projectName + \" AND updated >= '\" + timeString + \"'\";\n+        return queryIssues(jql);\n+    }\n+\n+\n+    @Override\n+    public List<Issue> csrIssues(ZonedDateTime updatedAfter) {\n+        var timeString = toTimeString(updatedAfter);\n+        var jql = \"project = \" + projectName + \" AND updated >= '\" + timeString + \"' AND issuetype = CSR\";\n+        return queryIssues(jql);\n+    }\n+\n+    @Override\n+    public Optional<Issue> lastUpdatedIssue() {\n+        var jql = \"project = \" + projectName + \" ORDER BY updated DESC\";\n+        var issues = request.get(\"search\")\n+                .param(\"jql\", jql)\n+                .param(\"maxResults\", \"1\")\n+                .execute();\n+        var issuesArray = issues.get(\"issues\").asArray();\n+        if (issuesArray.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            var json = issuesArray.get(0);\n+            return Optional.of(new JiraIssue(this, generateIssueRequest(json), json));\n+        }\n+    }\n+\n+    private String toTimeString(ZonedDateTime time) {\n+        var timeZoned = time.withZoneSameInstant(jiraHost.timeZone());\n+        return timeZoned.format(DateTimeFormatter.ofPattern(\"yyyy\/MM\/dd HH:mm\"));\n+    }\n+\n+    private ArrayList<Issue> queryIssues(String jql) {\n@@ -464,1 +509,0 @@\n-        var jql = \"project = \" + projectName + \" AND updated >= '-\" + Duration.between(updatedAfter, ZonedDateTime.now()).toMinutes() + \"m'\";\n@@ -466,2 +510,2 @@\n-                            .param(\"jql\", jql)\n-                            .execute();\n+                .param(\"jql\", jql)\n+                .execute();\n@@ -471,1 +515,1 @@\n-                ret.add(new JiraIssue(this, request, issue));\n+                ret.add(new JiraIssue(this, generateIssueRequest(issue), issue));\n@@ -477,3 +521,3 @@\n-                                .param(\"jql\", jql)\n-                                .param(\"startAt\", String.valueOf(startAt))\n-                                .execute();\n+                        .param(\"jql\", jql)\n+                        .param(\"startAt\", String.valueOf(startAt))\n+                        .execute();\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/jira\/JiraProject.java","additions":54,"deletions":10,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -254,0 +254,17 @@\n+    List<TestIssue> getCsrIssues(TestIssueProject issueProject, ZonedDateTime updatedAfter) {\n+        return data.issues.entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .map(issue -> getIssue(issueProject, issue.getKey()))\n+                .filter(i -> {\n+                    var type = i.properties().get(\"issuetype\");\n+                    return type != null && \"CSR\".equals(type.asString());\n+                })\n+                .filter(i -> i.updatedAt().isAfter(updatedAfter))\n+                .collect(Collectors.toList());\n+    }\n+\n+    Optional<TestIssue> getLastUpdatedIssue(TestIssueProject issueProject) {\n+        return data.issues.keySet().stream()\n+                .map(testIssue -> getIssue(issueProject, testIssue))\n+                .max(Comparator.comparing(TestIssue::updatedAt));\n+    }\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestHost.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,8 @@\n+    @Override\n+    public List<PullRequest> openPullRequestsAfter(ZonedDateTime updatedAfter) {\n+        return host.getPullRequests(this).stream()\n+                .filter(pr -> pr.state().equals(Issue.State.OPEN))\n+                .filter(pr -> pr.updatedAt().isAfter(updatedAfter))\n+                .collect(Collectors.toList());\n+    }\n+\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestHostedRepository.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,0 +85,10 @@\n+    @Override\n+    public List<Issue> csrIssues(ZonedDateTime updatedAfter) {\n+        return new ArrayList<>(host.getCsrIssues(this, updatedAfter));\n+    }\n+\n+    @Override\n+    public Optional<Issue> lastUpdatedIssue() {\n+        return Optional.ofNullable(host.getLastUpdatedIssue(this).orElse(null));\n+    }\n+\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestIssueProject.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}