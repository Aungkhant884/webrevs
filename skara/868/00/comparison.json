{"files":[{"patch":"@@ -812,1 +812,1 @@\n-                localHash = checkablePullRequest.commit(commitHash, censusInstance.namespace(), censusDomain, null);\n+                localHash = checkablePullRequest.commit(commitHash, censusInstance.namespace(), censusDomain, null, null);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import org.openjdk.skara.vcs.Hash;\n+import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;\n@@ -40,0 +42,1 @@\n+import java.util.stream.Stream;\n@@ -45,0 +48,1 @@\n+    private static final Pattern BACKPORT_TITLE_PATTERN = Pattern.compile(\"^Backport ([0-9a-z]{40})$\");\n@@ -172,0 +176,49 @@\n+            var m = BACKPORT_TITLE_PATTERN.matcher(pr.title());\n+            if (m.matches()) {\n+                var hash = new Hash(m.group(1));\n+                var metadata = pr.repository().forge().search(hash);\n+                if (metadata.isPresent()) {\n+                    var message = CommitMessageParsers.v1.parse(metadata.get().message());\n+                    var issues = message.issues();\n+                    if (!issues.isEmpty()) {\n+                        pr.setTitle(issues.get(0).toString());\n+                    }\n+\n+                    var comment = new ArrayList<String>();\n+                    comment.add(\"<!-- backport \" + hash.hex() + \" -->\\n\");\n+                    for (var issue : issues.subList(1, issues.size())) {\n+                        comment.add(SolvesTracker.setSolvesMarker(issue));\n+                    }\n+                    var summary = message.summaries();\n+                    if (!summary.isEmpty()) {\n+                        comment.add(Summary.setSummaryMarker(String.join(\"\\n\", summary)));\n+                    }\n+\n+                    var text = \"This backport pull request has now been updated with issue\";\n+                    if (issues.size() > 1) {\n+                        text += \"s\";\n+                    }\n+                    if (!summary.isEmpty()) {\n+                        text += \" and summary\";\n+                    }\n+                    text += \" from the original [commit](\" + metadata.get().url() + \").\";\n+                    comment.add(text);\n+                    pr.addComment(String.join(\"\\n\", comment));\n+                    return List.of(new CheckWorkItem(bot, pr.repository().pullRequest(pr.id()), errorHandler));\n+                } else {\n+                    var botUser = pr.repository().forge().currentUser();\n+                    var isErrorPresent = pr.comments()\n+                                           .stream()\n+                                           .filter(c -> c.author().equals(botUser))\n+                                           .flatMap(c -> Stream.of(c.body().split(\"\\n\")))\n+                                           .anyMatch(l -> l.equals(\"<!-- backport error -->\"));\n+                    if (!isErrorPresent) {\n+                        var text = \"<!-- backport error -->\\n\" +\n+                                   \":warning: @\" + pr.author().userName() + \" could not find any commit with hash `\" +\n+                                   hash.hex() + \"`. Please update the title with the hash for an existing commit.\";\n+                        pr.addComment(text);\n+                    }\n+                    return List.of();\n+                }\n+            }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckWorkItem.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -57,0 +57,3 @@\n+        return commitMessage(activeReviews, namespace, manualReviewers, null);\n+    }\n+    private String commitMessage(List<Review> activeReviews, Namespace namespace, boolean manualReviewers, Hash original) throws IOException {\n@@ -89,0 +92,3 @@\n+        if (original != null) {\n+            commitMessageBuilder.original(original);\n+        }\n@@ -108,1 +114,1 @@\n-    Hash commit(Hash finalHead, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {\n+    Hash commit(Hash finalHead, Namespace namespace, String censusDomain, String sponsorId, Hash original) throws IOException, CommitFailure {\n@@ -132,1 +138,1 @@\n-        var commitMessage = commitMessage(activeReviews, namespace, false);\n+        var commitMessage = commitMessage(activeReviews, namespace, false, original);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckablePullRequest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n@@ -34,0 +36,2 @@\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n@@ -37,0 +41,1 @@\n+    private static final Pattern BACKPORT_PATTERN = Pattern.compile(\"<!-- backport ([0-9a-z]{40}) -->\");\n@@ -125,1 +130,10 @@\n-            var localHash = checkablePr.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(), null);\n+            var botUser = pr.repository().forge().currentUser();\n+            var backportLines = pr.comments()\n+                                  .stream()\n+                                  .filter(c -> c.author().equals(botUser))\n+                                  .flatMap(c -> Stream.of(c.body().split(\"\\n\")))\n+                                  .map(l -> BACKPORT_PATTERN.matcher(l))\n+                                  .filter(Matcher::find)\n+                                  .collect(Collectors.toList());\n+            var original = backportLines.isEmpty() ? null : new Hash(backportLines.get(0).group(1));\n+            var localHash = checkablePr.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(), null, original);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+    static String addReviewerMarker(String username) {\n+        return String.format(addMarker, username);\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/Reviewers.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n@@ -34,0 +36,2 @@\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n@@ -37,0 +41,1 @@\n+    private static final Pattern BACKPORT_PATTERN = Pattern.compile(\"<-- backport ([0-9a-z]{40}) -->\");\n@@ -110,0 +115,9 @@\n+            var botUser = pr.repository().forge().currentUser();\n+            var backportLines = pr.comments()\n+                                  .stream()\n+                                  .filter(c -> c.author().equals(botUser))\n+                                  .flatMap(c -> Stream.of(c.body().split(\"\\n\")))\n+                                  .map(l -> BACKPORT_PATTERN.matcher(l))\n+                                  .filter(Matcher::find)\n+                                  .collect(Collectors.toList());\n+            var original = backportLines.isEmpty() ? null : new Hash(backportLines.get(0).group(1));\n@@ -111,1 +125,1 @@\n-                    command.user().id());\n+                    command.user().id(), original);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,393 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import org.junit.jupiter.api.*;\n+import org.openjdk.skara.forge.*;\n+import org.openjdk.skara.test.*;\n+import org.openjdk.skara.vcs.*;\n+import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.openjdk.skara.bots.pr.PullRequestAsserts.assertLastCommentContains;\n+\n+class BackportTests {\n+    @Test\n+    void simple(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory();\n+             var pushedFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"hello\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var releaseHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+            localRepo.push(releaseHash, author.url(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.java.net\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + releaseHash.hex());\n+\n+            \/\/ The bot should reply with a backport message\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertLastCommentContains(pr, \"This backport pull request has now been updated with issue\");\n+            assertLastCommentContains(pr, \"<!-- backport \" + releaseHash.hex() + \" -->\");\n+            assertEquals(issue1Number + \": An issue\", pr.title());\n+\n+            \/\/ Approve PR and re-run bot\n+            var prAsReviewer = reviewer.pullRequest(pr.id());\n+            prAsReviewer.addReview(Review.Verdict.APPROVED, \"Looks good\");\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertLastCommentContains(pr, \"This change now passes all *automated* pre-integration checks\");\n+\n+            \/\/ Integrate\n+            var prAsCommitter = author.pullRequest(pr.id());\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Find the commit\n+            assertLastCommentContains(pr, \"Pushed as commit\");\n+\n+            String hex = null;\n+            var comment = pr.comments().get(pr.comments().size() - 1);\n+            var lines = comment.body().split(\"\\n\");\n+            var pattern = Pattern.compile(\".* Pushed as commit ([0-9a-z]{40}).*\");\n+            for (var line : lines) {\n+                var m = pattern.matcher(line);\n+                if (m.matches()) {\n+                    hex = m.group(1);\n+                    break;\n+                }\n+            }\n+            assertNotNull(hex);\n+            assertEquals(40, hex.length());\n+            localRepo.checkout(localRepo.defaultBranch());\n+            localRepo.pull(author.url().toString(), \"master\", false);\n+            var commit = localRepo.lookup(new Hash(hex)).orElseThrow();\n+\n+            var message = CommitMessageParsers.v1.parse(commit);\n+            for (var c : pr.comments()) {\n+                System.out.println(c.body());\n+                System.out.println(\"-------------------------------\");\n+            }\n+            assertEquals(1, message.issues().size());\n+            assertEquals(\"An issue\", message.issues().get(0).description());\n+            assertEquals(List.of(\"integrationreviewer3\"), message.reviewers());\n+            assertEquals(Optional.of(releaseHash), message.original());\n+            assertEquals(List.of(), message.contributors());\n+            assertEquals(List.of(), message.summaries());\n+            assertEquals(List.of(), message.additional());\n+        }\n+    }\n+\n+    @Test\n+    void withSummary(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory();\n+             var pushedFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"hello\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"This is a summary\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var releaseHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+            localRepo.push(releaseHash, author.url(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.java.net\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + releaseHash.hex());\n+\n+            \/\/ The bot should reply with a backport message\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertLastCommentContains(pr, \"This backport pull request has now been updated with issue and summary\");\n+            assertLastCommentContains(pr, \"<!-- backport \" + releaseHash.hex() + \" -->\");\n+            assertEquals(issue1Number + \": An issue\", pr.title());\n+\n+            \/\/ Approve PR and re-run bot\n+            var prAsReviewer = reviewer.pullRequest(pr.id());\n+            prAsReviewer.addReview(Review.Verdict.APPROVED, \"Looks good\");\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertLastCommentContains(pr, \"This change now passes all *automated* pre-integration checks\");\n+\n+            \/\/ Integrate\n+            var prAsCommitter = author.pullRequest(pr.id());\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Find the commit\n+            assertLastCommentContains(pr, \"Pushed as commit\");\n+\n+            String hex = null;\n+            var comment = pr.comments().get(pr.comments().size() - 1);\n+            var lines = comment.body().split(\"\\n\");\n+            var pattern = Pattern.compile(\".* Pushed as commit ([0-9a-z]{40}).*\");\n+            for (var line : lines) {\n+                var m = pattern.matcher(line);\n+                if (m.matches()) {\n+                    hex = m.group(1);\n+                    break;\n+                }\n+            }\n+            assertNotNull(hex);\n+            assertEquals(40, hex.length());\n+            localRepo.checkout(localRepo.defaultBranch());\n+            localRepo.pull(author.url().toString(), \"master\", false);\n+            var commit = localRepo.lookup(new Hash(hex)).orElseThrow();\n+\n+            var message = CommitMessageParsers.v1.parse(commit);\n+            for (var c : pr.comments()) {\n+                System.out.println(c.body());\n+                System.out.println(\"-------------------------------\");\n+            }\n+            assertEquals(1, message.issues().size());\n+            assertEquals(\"An issue\", message.issues().get(0).description());\n+            assertEquals(List.of(\"integrationreviewer3\"), message.reviewers());\n+            assertEquals(Optional.of(releaseHash), message.original());\n+            assertEquals(List.of(\"This is a summary\"), message.summaries());\n+            assertEquals(List.of(), message.contributors());\n+            assertEquals(List.of(), message.additional());\n+        }\n+    }\n+\n+    @Test\n+    void withMultipleIssues(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory();\n+             var pushedFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"hello\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue2 = credentials.createIssue(issues, \"Another issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var issue2Number = issue2.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                                  issue2Number + \": Another issue\\n\" +\n+                                  \"\\n\" +\n+                                  \"This is a summary\\n\" +\n+                                  \"\\n\" +\n+                                  \"Reviewed-by: integrationreviewer2\";\n+            var releaseHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.java.net\");\n+            localRepo.push(releaseHash, author.url(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.java.net\");\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + releaseHash.hex());\n+\n+            \/\/ The bot should reply with a backport message\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertLastCommentContains(pr, \"This backport pull request has now been updated with issues and summary\");\n+            assertLastCommentContains(pr, \"<!-- backport \" + releaseHash.hex() + \" -->\");\n+            assertEquals(issue1Number + \": An issue\", pr.title());\n+\n+            \/\/ Approve PR and re-run bot\n+            var prAsReviewer = reviewer.pullRequest(pr.id());\n+            prAsReviewer.addReview(Review.Verdict.APPROVED, \"Looks good\");\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertLastCommentContains(pr, \"This change now passes all *automated* pre-integration checks\");\n+\n+            \/\/ Integrate\n+            var prAsCommitter = author.pullRequest(pr.id());\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Find the commit\n+            assertLastCommentContains(pr, \"Pushed as commit\");\n+\n+            String hex = null;\n+            var comment = pr.comments().get(pr.comments().size() - 1);\n+            var lines = comment.body().split(\"\\n\");\n+            var pattern = Pattern.compile(\".* Pushed as commit ([0-9a-z]{40}).*\");\n+            for (var line : lines) {\n+                var m = pattern.matcher(line);\n+                if (m.matches()) {\n+                    hex = m.group(1);\n+                    break;\n+                }\n+            }\n+            assertNotNull(hex);\n+            assertEquals(40, hex.length());\n+            localRepo.checkout(localRepo.defaultBranch());\n+            localRepo.pull(author.url().toString(), \"master\", false);\n+            var commit = localRepo.lookup(new Hash(hex)).orElseThrow();\n+\n+            var message = CommitMessageParsers.v1.parse(commit);\n+            for (var c : pr.comments()) {\n+                System.out.println(c.body());\n+                System.out.println(\"-------------------------------\");\n+            }\n+            assertEquals(2, message.issues().size());\n+            assertEquals(\"An issue\", message.issues().get(0).description());\n+            assertEquals(\"Another issue\", message.issues().get(1).description());\n+            assertEquals(List.of(\"integrationreviewer3\"), message.reviewers());\n+            assertEquals(Optional.of(releaseHash), message.original());\n+            assertEquals(List.of(\"This is a summary\"), message.summaries());\n+            assertEquals(List.of(), message.contributors());\n+            assertEquals(List.of(), message.additional());\n+        }\n+    }\n+\n+    @Test\n+    void nonExitingCommit(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory();\n+             var pushedFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .issueProject(issues)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make a change with a corresponding backport PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport 0123456789012345678901234567890123456789\");\n+\n+            \/\/ The bot should reply with a backport error\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertLastCommentContains(pr, \"<!-- backport error -->\");\n+            assertLastCommentContains(pr, \":warning:\");\n+            assertLastCommentContains(pr, \"could not find any commit with hash `0123456789012345678901234567890123456789`\");\n+\n+            \/\/ Re-running the bot should not cause any more error comments\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertEquals(1, pr.comments().size());\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/BackportTests.java","additions":393,"deletions":0,"binary":false,"changes":393,"status":"added"}]}