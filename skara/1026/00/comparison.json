{"files":[{"patch":"@@ -130,0 +130,148 @@\n+\n+    @Test\n+    void hashMerge(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make more changes in another branch\n+            var otherHash1 = CheckableRepository.appendAndCommit(localRepo, \"First change in other\",\n+                                                                 \"First other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash1, author.url(), \"other\", true);\n+            var otherHash2 = CheckableRepository.appendAndCommit(localRepo, \"Second change in other\",\n+                                                                 \"Second other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash2, author.url(), \"other\");\n+\n+            \/\/ Go back to the original master\n+            localRepo.checkout(masterHash, true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var unrelated = Files.writeString(localRepo.root().resolve(\"unrelated.txt\"), \"Unrelated\", StandardCharsets.UTF_8);\n+            localRepo.add(unrelated);\n+            var updatedMaster = localRepo.commit(\"Unrelated\", \"some\", \"some@one\");\n+            localRepo.merge(otherHash2);\n+            localRepo.push(updatedMaster, author.url(), \"master\");\n+\n+            var mergeHash = localRepo.commit(\"Merge commit\", \"some\", \"some@one\");\n+            localRepo.push(mergeHash, author.url(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Merge \" + otherHash2.hex());\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ Let the bot check the status\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Push it\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with an ok message\n+            var pushed = pr.comments().stream()\n+                           .filter(comment -> comment.body().contains(\"Pushed as commit\"))\n+                           .count();\n+            assertEquals(1, pushed);\n+\n+            \/\/ The change should now be present on the master branch\n+            var pushedRepoFolder = tempFolder.path().resolve(\"pushedrepo\");\n+            var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), \"master\");\n+            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));\n+\n+            \/\/ The commits from the \"other\" branch should be preserved and not squashed (but not the merge commit)\n+            var headHash = pushedRepo.resolve(\"HEAD\").orElseThrow();\n+            Set<Hash> commits;\n+            try (var tempCommits = pushedRepo.commits(masterHash.hex() + \"..\" + headHash.hex())) {\n+                commits = tempCommits.stream()\n+                                     .map(Commit::hash)\n+                                     .collect(Collectors.toSet());\n+            }\n+            assertTrue(commits.contains(otherHash1));\n+            assertTrue(commits.contains(otherHash2));\n+            assertFalse(commits.contains(mergeHash));\n+\n+            \/\/ Author and committer should updated in the merge commit\n+            var headCommit = pushedRepo.commits(headHash.hex() + \"^..\" + headHash.hex()).asList().get(0);\n+            assertEquals(\"Merge \" + otherHash2.hex(), headCommit.message().get(0));\n+            assertEquals(\"Generated Committer 1\", headCommit.author().name());\n+            assertEquals(\"integrationcommitter1@openjdk.java.net\", headCommit.author().email());\n+            assertEquals(\"Generated Committer 1\", headCommit.committer().name());\n+            assertEquals(\"integrationcommitter1@openjdk.java.net\", headCommit.committer().email());\n+        }\n+    }\n+\n+    @Test\n+    void hashMergeExisting(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make more changes in another branch\n+            var otherHash1 = CheckableRepository.appendAndCommit(localRepo, \"First change in other\",\n+                                                                 \"First other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash1, author.url(), \"other\", true);\n+            var otherHash2 = CheckableRepository.appendAndCommit(localRepo, \"Second change in other\",\n+                                                                 \"Second other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash2, author.url(), \"other\");\n+\n+            \/\/ Push the new commits to master and then return to the original one\n+            localRepo.push(otherHash2, author.url(), \"master\");\n+            localRepo.checkout(masterHash, true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var unrelated = Files.writeString(localRepo.root().resolve(\"unrelated.txt\"), \"Unrelated\", StandardCharsets.UTF_8);\n+            localRepo.add(unrelated);\n+            var updatedMaster = localRepo.commit(\"Unrelated\", \"some\", \"some@one\");\n+            localRepo.merge(otherHash2);\n+            var mergeHash = localRepo.commit(\"Merge commit\", \"some\", \"some@one\");\n+            localRepo.push(mergeHash, author.url(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Merge \" + otherHash2.hex());\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ Let the bot check the status\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Push it\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with a failure message\n+            var error = pr.comments().stream()\n+                          .filter(comment -> comment.body().contains(\"did not complete successfully\"))\n+                          .count();\n+            assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining(\"\\n\\n\")));\n+\n+            var check = pr.checks(mergeHash).get(\"jcheck\");\n+            assertEquals(\"- A merge PR must contain at least one commit from the source branch that is not already present in the target.\", check.summary().orElseThrow());\n+        }\n+    }\n+\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/MergeTests.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+    private final static Pattern hashSourcePattern = Pattern.compile(\"[0-9a-fA-F]{6,40}\");\n@@ -68,1 +69,0 @@\n-\n@@ -70,0 +70,14 @@\n+\n+        \/\/ A hash in the PRs local history can also be a valid source\n+        var hashSourceMatcher = hashSourcePattern.matcher(source);\n+        if (hashSourceMatcher.matches()) {\n+            var hash = localRepo.resolve(source);\n+            if (hash.isPresent()) {\n+                \/\/ A valid merge source hash cannot be an ancestor of the target branch (if so it would not need to be merged)\n+                var prTargetHash = PullRequestUtils.targetHash(pr, localRepo);\n+                if (!localRepo.isAncestor(hash.get(), prTargetHash)) {\n+                    return hash.get();\n+                }\n+            }\n+        }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequestUtils.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"}]}