{"files":[{"patch":"@@ -51,0 +51,1 @@\n+    private final Set<String> integrators;\n@@ -72,1 +73,1 @@\n-                     CensusInstance censusInstance, boolean ignoreStaleReviews) throws IOException {\n+                     CensusInstance censusInstance, boolean ignoreStaleReviews, Set<String> integrators) throws IOException {\n@@ -83,0 +84,1 @@\n+        this.integrators = integrators;\n@@ -93,2 +95,2 @@\n-                        boolean ignoreStaleReviews) throws IOException {\n-        var run = new CheckRun(workItem, pr, localRepo, comments, allReviews, activeReviews, labels, censusInstance, ignoreStaleReviews);\n+                        boolean ignoreStaleReviews, Set<String> integrators) throws IOException {\n+        var run = new CheckRun(workItem, pr, localRepo, comments, allReviews, activeReviews, labels, censusInstance, ignoreStaleReviews, integrators);\n@@ -161,0 +163,5 @@\n+        if (!integrators.isEmpty() && PullRequestUtils.isMerge(pr) && !integrators.contains(pr.author().username())) {\n+            var error = \"Only the designated integrators for this repository are allowed to create merge-style pull requests.\";\n+            ret.add(error);\n+        }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-                var expiresAt = CheckRun.execute(this, pr, localRepo, comments, allReviews, activeReviews, labels, census, bot.ignoreStaleReviews());\n+                var expiresAt = CheckRun.execute(this, pr, localRepo, comments, allReviews, activeReviews, labels, census, bot.ignoreStaleReviews(), bot.integrators());\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckWorkItem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import org.openjdk.skara.host.HostUser;\n@@ -64,0 +63,1 @@\n+    private final Set<String> integrators;\n@@ -76,1 +76,2 @@\n-                   String confOverrideRef, String censusLink, Map<String, HostedRepository> forks) {\n+                   String confOverrideRef, String censusLink, Map<String, HostedRepository> forks,\n+                   Set<String> integrators) {\n@@ -95,1 +96,0 @@\n-\n@@ -97,0 +97,1 @@\n+        this.integrators = integrators;\n@@ -302,0 +303,4 @@\n+\n+    public Set<String> integrators() {\n+        return integrators;\n+    }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBot.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import org.openjdk.skara.host.HostUser;\n-import org.openjdk.skara.vcs.Branch;\n-import org.openjdk.skara.vcs.VCS;\n@@ -30,0 +27,1 @@\n+import org.openjdk.skara.vcs.*;\n@@ -55,0 +53,1 @@\n+    private Set<String> integrators = Set.of();\n@@ -154,0 +153,5 @@\n+    public PullRequestBotBuilder integrators(Set<String> integrators) {\n+        this.integrators = new HashSet<>(integrators);\n+        return this;\n+    }\n+\n@@ -159,1 +163,1 @@\n-                                  confOverrideRef, censusLink, forks);\n+                                  confOverrideRef, censusLink, forks, integrators);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotBuilder.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -130,0 +130,269 @@\n+    @Test\n+    void mergeAllowed(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder()\n+                                         .repo(integrator)\n+                                         .censusRepo(censusBuilder.build())\n+                                         .integrators(Set.of(author.forge().currentUser().username()))\n+                                         .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make more changes in another branch\n+            var otherHash1 = CheckableRepository.appendAndCommit(localRepo, \"First change in other\",\n+                                                                 \"First other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash1, author.url(), \"other\", true);\n+            var otherHash2 = CheckableRepository.appendAndCommit(localRepo, \"Second change in other\",\n+                                                                 \"Second other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash2, author.url(), \"other\");\n+\n+            \/\/ Go back to the original master\n+            localRepo.checkout(masterHash, true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var unrelated = Files.writeString(localRepo.root().resolve(\"unrelated.txt\"), \"Unrelated\", StandardCharsets.UTF_8);\n+            localRepo.add(unrelated);\n+            var updatedMaster = localRepo.commit(\"Unrelated\", \"some\", \"some@one\");\n+            localRepo.merge(otherHash2);\n+            localRepo.push(updatedMaster, author.url(), \"master\");\n+\n+            var mergeHash = localRepo.commit(\"Merge commit\", \"some\", \"some@one\");\n+            localRepo.push(mergeHash, author.url(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Merge \" + author.name() + \":other\");\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ Let the bot check the status\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Push it\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with an ok message\n+            assertLastCommentContains(pr, \"Pushed as commit\");\n+        }\n+    }\n+\n+    @Test\n+    void mergeDisallowed(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder()\n+                                         .repo(integrator)\n+                                         .censusRepo(censusBuilder.build())\n+                                         .integrators(Set.of(integrator.forge().currentUser().username()))\n+                                         .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make more changes in another branch\n+            var otherHash1 = CheckableRepository.appendAndCommit(localRepo, \"First change in other\",\n+                                                                 \"First other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash1, author.url(), \"other\", true);\n+            var otherHash2 = CheckableRepository.appendAndCommit(localRepo, \"Second change in other\",\n+                                                                 \"Second other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash2, author.url(), \"other\");\n+\n+            \/\/ Go back to the original master\n+            localRepo.checkout(masterHash, true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var unrelated = Files.writeString(localRepo.root().resolve(\"unrelated.txt\"), \"Unrelated\", StandardCharsets.UTF_8);\n+            localRepo.add(unrelated);\n+            var updatedMaster = localRepo.commit(\"Unrelated\", \"some\", \"some@one\");\n+            localRepo.merge(otherHash2);\n+            localRepo.push(updatedMaster, author.url(), \"master\");\n+\n+            var mergeHash = localRepo.commit(\"Merge commit\", \"some\", \"some@one\");\n+            localRepo.push(mergeHash, author.url(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Merge \" + author.name() + \":other\");\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ Let the bot check the status\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Push it\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with a failure message\n+            assertLastCommentContains(pr, \"Your integration request cannot be fulfilled at this time\");\n+        }\n+    }\n+\n+    @Test\n+    void hashMerge(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make more changes in another branch\n+            var otherHash1 = CheckableRepository.appendAndCommit(localRepo, \"First change in other\",\n+                                                                 \"First other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash1, author.url(), \"other\", true);\n+            var otherHash2 = CheckableRepository.appendAndCommit(localRepo, \"Second change in other\",\n+                                                                 \"Second other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash2, author.url(), \"other\");\n+\n+            \/\/ Go back to the original master\n+            localRepo.checkout(masterHash, true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var unrelated = Files.writeString(localRepo.root().resolve(\"unrelated.txt\"), \"Unrelated\", StandardCharsets.UTF_8);\n+            localRepo.add(unrelated);\n+            var updatedMaster = localRepo.commit(\"Unrelated\", \"some\", \"some@one\");\n+            localRepo.merge(otherHash2);\n+            localRepo.push(updatedMaster, author.url(), \"master\");\n+\n+            var mergeHash = localRepo.commit(\"Merge commit\", \"some\", \"some@one\");\n+            localRepo.push(mergeHash, author.url(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Merge \" + otherHash2.hex());\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ Let the bot check the status\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Push it\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with an ok message\n+            var pushed = pr.comments().stream()\n+                           .filter(comment -> comment.body().contains(\"Pushed as commit\"))\n+                           .count();\n+            assertEquals(1, pushed);\n+\n+            \/\/ The change should now be present on the master branch\n+            var pushedRepoFolder = tempFolder.path().resolve(\"pushedrepo\");\n+            var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), \"master\");\n+            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));\n+\n+            \/\/ The commits from the \"other\" branch should be preserved and not squashed (but not the merge commit)\n+            var headHash = pushedRepo.resolve(\"HEAD\").orElseThrow();\n+            Set<Hash> commits;\n+            try (var tempCommits = pushedRepo.commits(masterHash.hex() + \"..\" + headHash.hex())) {\n+                commits = tempCommits.stream()\n+                                     .map(Commit::hash)\n+                                     .collect(Collectors.toSet());\n+            }\n+            assertTrue(commits.contains(otherHash1));\n+            assertTrue(commits.contains(otherHash2));\n+            assertFalse(commits.contains(mergeHash));\n+\n+            \/\/ Author and committer should be updated in the merge commit\n+            var headCommit = pushedRepo.commits(headHash.hex() + \"^..\" + headHash.hex()).asList().get(0);\n+            assertEquals(\"Merge \" + otherHash2.hex(), headCommit.message().get(0));\n+            assertEquals(\"Generated Committer 1\", headCommit.author().name());\n+            assertEquals(\"integrationcommitter1@openjdk.java.net\", headCommit.author().email());\n+            assertEquals(\"Generated Committer 1\", headCommit.committer().name());\n+            assertEquals(\"integrationcommitter1@openjdk.java.net\", headCommit.committer().email());\n+        }\n+    }\n+\n+    @Test\n+    void hashMergeExisting(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(integrator.forge().currentUser().id());\n+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make more changes in another branch\n+            var otherHash1 = CheckableRepository.appendAndCommit(localRepo, \"First change in other\",\n+                                                                 \"First other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash1, author.url(), \"other\", true);\n+            var otherHash2 = CheckableRepository.appendAndCommit(localRepo, \"Second change in other\",\n+                                                                 \"Second other\\n\\nReviewed-by: integrationreviewer2\");\n+            localRepo.push(otherHash2, author.url(), \"other\");\n+\n+            \/\/ Push the new commits to master and then return to the original one\n+            localRepo.push(otherHash2, author.url(), \"master\");\n+            localRepo.checkout(masterHash, true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var unrelated = Files.writeString(localRepo.root().resolve(\"unrelated.txt\"), \"Unrelated\", StandardCharsets.UTF_8);\n+            localRepo.add(unrelated);\n+            var updatedMaster = localRepo.commit(\"Unrelated\", \"some\", \"some@one\");\n+            localRepo.merge(otherHash2);\n+            var mergeHash = localRepo.commit(\"Merge commit\", \"some\", \"some@one\");\n+            localRepo.push(mergeHash, author.url(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Merge \" + otherHash2.hex());\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = integrator.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ Let the bot check the status\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ Push it\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(mergeBot);\n+\n+            \/\/ The bot should reply with a failure message\n+            var error = pr.comments().stream()\n+                          .filter(comment -> comment.body().contains(\"did not complete successfully\"))\n+                          .count();\n+            assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining(\"\\n\\n\")));\n+\n+            var check = pr.checks(mergeHash).get(\"jcheck\");\n+            assertEquals(\"- A merge PR must contain at least one commit from the source branch that is not already present in the target.\", check.summary().orElseThrow());\n+        }\n+    }\n+\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/MergeTests.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+    private final static Pattern hashSourcePattern = Pattern.compile(\"[0-9a-fA-F]{6,40}\");\n@@ -68,1 +69,0 @@\n-\n@@ -70,0 +70,14 @@\n+\n+        \/\/ A hash in the PRs local history can also be a valid source\n+        var hashSourceMatcher = hashSourcePattern.matcher(source);\n+        if (hashSourceMatcher.matches()) {\n+            var hash = localRepo.resolve(source);\n+            if (hash.isPresent()) {\n+                \/\/ A valid merge source hash cannot be an ancestor of the target branch (if so it would not need to be merged)\n+                var prTargetHash = PullRequestUtils.targetHash(pr, localRepo);\n+                if (!localRepo.isAncestor(hash.get(), prTargetHash)) {\n+                    return hash.get();\n+                }\n+            }\n+        }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequestUtils.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"}]}