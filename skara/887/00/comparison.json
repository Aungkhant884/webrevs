{"files":[{"patch":"@@ -329,1 +329,1 @@\n-                    WordWrap.wrapBody(body.toString(), 120) +\n+                    body.toString().strip() +\n","filename":"bots\/mlbridge\/src\/main\/java\/org\/openjdk\/skara\/bots\/mlbridge\/ReviewArchive.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.skara.email;\n-\n-import java.util.*;\n-\n-public class WordWrap {\n-    private static boolean isIndentCharacter(char ch) {\n-        switch (ch) {\n-            case ' ':\n-            case '>':\n-            case '-':\n-            case '*':\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    private static Map.Entry<String, String> split(String line, int lineLength) {\n-        if (line.length() <= lineLength) {\n-            return new AbstractMap.SimpleEntry<>(line, \"\");\n-        }\n-        var splitAt = -1;\n-        for (int i = 0; i < line.length() - 1; ++i) {\n-            var cur = line.charAt(i);\n-            var next = line.charAt(i + 1);\n-            if (cur == ' ') {\n-                if (!isIndentCharacter(next)) {\n-                    if (i < lineLength) {\n-                        splitAt = i;\n-                    } else {\n-                        \/\/ We'll never find a better match - if we don't have any candidate we have to split here even if lineLength is exceeded\n-                        if (splitAt == -1) {\n-                            splitAt = i;\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        if (splitAt == -1) {\n-            return new AbstractMap.SimpleEntry<>(line, \"\");\n-        }\n-        return new AbstractMap.SimpleEntry<>(line.substring(0, splitAt), line.substring(splitAt + 1));\n-    }\n-\n-    private static String indentation(String line) {\n-        for (int i = 0; i < line.length(); ++i) {\n-            if (!isIndentCharacter(line.charAt(i))) {\n-                return line.substring(0, i);\n-            }\n-        }\n-        return line;\n-    }\n-\n-    private static String filterIndent(String indent) {\n-        return indent.replace('-', ' ').replace('*', ' ');\n-    }\n-\n-    public static String wrapBody(String body, int lineLength) {\n-        var ret = new StringBuilder();\n-\n-        var lines = new LinkedList<String>();\n-        body.lines().forEach(lines::add);\n-\n-        while (!lines.isEmpty()) {\n-            var line = lines.pollFirst();\n-            var indentation = indentation(line);\n-            var split = split(line.substring(indentation.length()), lineLength);\n-            if (!split.getValue().isBlank()) {\n-                var nextLine = lines.peekFirst();\n-                if (nextLine != null) {\n-                    var nextIndent = indentation(nextLine);\n-                    if (nextLine.isBlank() || !indentation.equals(filterIndent(nextIndent)) || !indentation.equals(nextIndent)) {\n-                        lines.addFirst(filterIndent(indentation) + split.getValue());\n-                    } else {\n-                        lines.removeFirst();\n-                        lines.addFirst(filterIndent(indentation) + split.getValue() + \" \" + nextLine.substring(indentation.length()));\n-                    }\n-                } else {\n-                    lines.addFirst(filterIndent(indentation) + split.getValue());\n-                }\n-            }\n-            if (ret.length() > 0) {\n-                ret.append(\"\\n\");\n-            }\n-            ret.append(indentation).append(split.getKey().stripTrailing());\n-        }\n-\n-        return ret.toString();\n-    }\n-}\n","filename":"email\/src\/main\/java\/org\/openjdk\/skara\/email\/WordWrap.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-package org.openjdk.skara.email;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-public class WordWrapTests {\n-    @Test\n-    void simple() {\n-        assertEquals(\"hello\\nthere\\nyou\", WordWrap.wrapBody(\"hello there you\", 2));\n-        assertEquals(\"hello\\nthere\", WordWrap.wrapBody(\"hello there\", 7));\n-        assertEquals(\"hello there\", WordWrap.wrapBody(\"hello there\", 20));\n-        assertEquals(\"hello\\nthere\", WordWrap.wrapBody(\"hello   there\", 7));\n-    }\n-\n-    @Test\n-    void indented() {\n-        assertEquals(\"  hello\\n  there\", WordWrap.wrapBody(\"  hello there\", 10));\n-        assertEquals(\"  hello\\n  there\\n you\", WordWrap.wrapBody(\"  hello there\\n you\", 10));\n-    }\n-\n-    @Test\n-    void quoted() {\n-        assertEquals(\"> hello\\n> there\", WordWrap.wrapBody(\"> hello there\", 10));\n-        assertEquals(\"> hello\\n> there\\n> you\", WordWrap.wrapBody(\"> hello there\\n> you\", 2));\n-        assertEquals(\">> hello\\n>> there\\n> you\", WordWrap.wrapBody(\">> hello there\\n> you\", 2));\n-    }\n-\n-    @Test\n-    void list() {\n-        assertEquals(\" - hello\\n   there\\n - you\", WordWrap.wrapBody(\" - hello there\\n - you\", 10));\n-        assertEquals(\" - hello\\n   there\", WordWrap.wrapBody(\" - hello there\", 10));\n-    }\n-\n-    @Test\n-    void notList() {\n-        assertEquals(\"this\\nis -\\njust -\\nnot\\na\\nlist\", WordWrap.wrapBody(\"this is - just - not a list\", 3));\n-    }\n-\n-    @Test\n-    void complex() {\n-        assertEquals(\"> I had a\\n\" +\n-                             \"> few\\n\" +\n-                             \"> comments\\n\" +\n-                             \"> - fix the\\n\" +\n-                             \">   spelling\\n\" +\n-                             \"> - remove\\n\" +\n-                             \">   trailing\\n\" +\n-                             \">   whitespace\\n\" +\n-                             \"Ok, I\\n\" +\n-                             \"will fix\\n\" +\n-                             \"that in a\\n\" +\n-                             \"new\\n\" +\n-                             \"commit!\", WordWrap.wrapBody(\"> I had a few comments\\n\" +\n-                                                                  \"> - fix the spelling\\n\" +\n-                                                                  \"> - remove trailing whitespace\\n\" +\n-                                                                  \"Ok, I will fix that in a new commit!\",\n-                                                          10));\n-    }\n-\n-    @Test\n-    void emptyLines() {\n-        assertEquals(\"hello\\nthere\\n\\nyou\", WordWrap.wrapBody(\"hello there\\n\\nyou\", 3));\n-    }\n-\n-    @Test\n-    void complexList() {\n-        assertEquals(\"Problems:\\n\" +\n-                             \"- G1 pre- and post-barriers used when (un-)packing arguments for the calling convention can call into the runtime which\\n\" +\n-                             \"  screws up argument registers. Save all registers until JDK-8232094 is fixed in mainline (it's the slow path anyway).\\n\" +\n-                             \"- SignatureStream::as_value_klass triggers a SystemDictionary lookup which acquires the ProtectionDomainSet_lock. When\\n\" +\n-                             \"  used from fieldDescriptor::print_on_for when some debug printing flags are enabled, this conflicts with the tty_lock.\\n\" +\n-                             \"  We should simply use get_value_field_klass instead. Also, we should handle null as a vale for non-flattened fields.\\n\" +\n-                             \"- TraceDeoptimization needs to handle re-allocation of the inline type return value.\\n\" +\n-                             \"\\n\" +\n-                             \"I've also added a new StressCC option to the ValueTypeTest suite to randomly restrict some compilation to C1 and\\n\" +\n-                             \"thereby stress test the calling convention.\",\n-                     WordWrap.wrapBody(\"Problems:\\n\" +\n-                                               \"- G1 pre- and post-barriers used when (un-)packing arguments for the calling convention can call into the runtime which screws up argument registers. Save all registers until JDK-8232094 is fixed in mainline (it's the slow path anyway).\\n\" +\n-                                               \"- SignatureStream::as_value_klass triggers a SystemDictionary lookup which acquires the ProtectionDomainSet_lock. When used from fieldDescriptor::print_on_for when some debug printing flags are enabled, this conflicts with the tty_lock. We should simply use get_value_field_klass instead. Also, we should handle null as a vale for non-flattened fields.\\n\" +\n-                                               \"- TraceDeoptimization needs to handle re-allocation of the inline type return value.\\n\" +\n-                                               \"\\n\" +\n-                                               \"I've also added a new StressCC option to the ValueTypeTest suite to randomly restrict some compilation to C1 and thereby stress test the calling convention.\", 120));\n-    }\n-}\n","filename":"email\/src\/test\/java\/org\/openjdk\/skara\/email\/WordWrapTests.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"}]}