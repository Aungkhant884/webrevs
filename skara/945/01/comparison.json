{"files":[{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import org.openjdk.skara.forge.HostedCommit;\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.issuetracker.Comment;\n+import org.openjdk.skara.vcs.*;\n+import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;\n+\n+import java.io.PrintWriter;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.time.format.DateTimeFormatter;\n+\n+public class BackportCommand implements CommandHandler {\n+    private void showHelp(PrintWriter reply) {\n+        reply.println(\"Usage: `\/backport <repository> [<branch>]`\");\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"Create a backport\";\n+    }\n+\n+    @Override\n+    public boolean allowedInCommit() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean allowedInPullRequest() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void handle(PullRequestBot bot, HostedCommit commit, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {\n+        var username = command.user().username();\n+        if (censusInstance.contributor(command.user()).isEmpty()) {\n+            reply.println(\"@\" + username + \" only OpenJDK [contributors](https:\/\/openjdk.java.net\/bylaws#contributor) can use the `\/backport` command\");\n+            return;\n+        }\n+\n+        var args = command.args();\n+        if (args.isBlank()) {\n+            showHelp(reply);\n+            return;\n+        }\n+\n+        var parts = args.split(\" \");\n+        if (parts.length > 2) {\n+            showHelp(reply);\n+            return;\n+        }\n+\n+        var forge = bot.repo().forge();\n+        var repoName = parts[0].replace(\"http:\/\/\", \"\")\n+                               .replace(\"https:\/\/\", \"\")\n+                               .replace(forge.hostname() + \"\/\", \"\");\n+        var currentRepoName = bot.repo().name();\n+        if (!currentRepoName.equals(repoName) && !repoName.contains(\"\/\")) {\n+            var group = bot.repo().name().split(\"\/\")[0];\n+            repoName = group + \"\/\" + repoName;\n+        }\n+\n+        var targetRepo = forge.repository(repoName);\n+        if (targetRepo.isEmpty()) {\n+            reply.println(\"@\" + username + \" the target repository `\" + repoName + \"` does not exist\");\n+            return;\n+        }\n+\n+        var branchName = parts.length == 2 ? parts[1] : \"master\";\n+        var targetBranches = targetRepo.get().branches();\n+        if (targetBranches.stream().noneMatch(b -> b.name().equals(branchName))) {\n+            reply.println(\"@\" + username + \" the target branch `\" + branchName + \"` does not exist\");\n+            return;\n+        }\n+\n+        try {\n+            var hash = commit.hash();\n+            var fork = bot.writeableForkOf(targetRepo.get());\n+            var localRepoDir = scratchPath.resolve(\"backport-command\")\n+                                          .resolve(repoName)\n+                                          .resolve(\"fork\");\n+            var localRepo = bot.hostedRepositoryPool()\n+                               .orElseThrow(() -> new IllegalStateException(\"Missing repository pool for PR bot\"))\n+                               .materialize(fork, localRepoDir);\n+            var fetchHead = localRepo.fetch(bot.repo().url(), hash.hex());\n+            localRepo.checkout(new Branch(branchName));\n+            var head = localRepo.head();\n+            var backportBranch = localRepo.branch(head, \"backport-\" + hash.abbreviate());\n+            localRepo.checkout(backportBranch);\n+            var didApply = localRepo.cherryPick(fetchHead);\n+            if (!didApply) {\n+                var lines = new ArrayList<String>();\n+                lines.add(\"@\" + username + \" :warning: could not backport `\" + hash.abbreviate() + \"` to \" +\n+                          \"[\" + repoName + \"](\" + targetRepo.get().webUrl() + \"] due to conflicts in the following files:\");\n+                lines.add(\"\");\n+                var unmerged = localRepo.status()\n+                                        .stream()\n+                                        .filter(e -> e.status().isUnmerged())\n+                                        .map(e -> e.target().path().orElseGet(() -> e.source().path().orElseThrow()))\n+                                        .collect(Collectors.toList());\n+                for (var path : unmerged) {\n+                    lines.add(\"- \" + path.toString());\n+                }\n+                lines.add(\"\");\n+                lines.add(\"To manually resolve these conflicts run the following commands in your personal fork of [\" + repoName + \"](\" + targetRepo.get().webUrl() + \"):\");\n+                lines.add(\"\");\n+                lines.add(\"```\");\n+                lines.add(\"$ git checkout -b \" + backportBranch.name());\n+                lines.add(\"$ git fetch \" + bot.repo().webUrl() + \" \" + hash.hex());\n+                lines.add(\"$ git cherry-pick --no-commit \" + hash.hex());\n+                lines.add(\"$ # Resolve conflicts\");\n+                lines.add(\"$ git add files\/with\/resolved\/conflicts\");\n+                lines.add(\"$ git commit -m 'Backport \" + hash.hex() + \"'\");\n+                lines.add(\"```\");\n+                lines.add(\"\");\n+                lines.add(\"Once you have resolved the conflicts as explained above continue with creating a pull request towards the [\" + repoName + \"](\" + targetRepo.get().webUrl() + \") with the title \\\"Backport \" + hash.hex() + \"\\\".\");\n+\n+                reply.println(String.join(\"\\n\", lines));\n+                localRepo.reset(head, true);\n+                return;\n+            }\n+\n+            var backportHash = localRepo.commit(\"Backport \" + hash.hex(), \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(backportHash, fork.url(), backportBranch.name(), true);\n+            var message = CommitMessageParsers.v1.parse(commit);\n+            var formatter = DateTimeFormatter.ofPattern(\"d MMM uuuu\");\n+            var lines = new ArrayList<String>();\n+            lines.add(\"Hi all,\");\n+            lines.add(\"\");\n+            lines.add(\"this is an _automatically_ generated pull request containing a backport of \" +\n+                      \"[\" + hash.abbreviate() + \"](\" + commit.url() + \") as requested by \" +\n+                      \"@\" + username);\n+            lines.add(\"\");\n+            var info = \"The commit being backported was authored by \" + commit.author().name() + \" on \" +\n+                        commit.committed().format(formatter);\n+            if (message.reviewers().isEmpty()) {\n+                info += \" and had no reviewers\";\n+            } else {\n+                var reviewers = message.reviewers()\n+                                       .stream()\n+                                       .map(r -> censusInstance.census().contributor(r))\n+                                       .map(c -> {\n+                                           var link = \"[\" + c.username() + \"](https:\/\/openjdk.java.net\/census#\" +\n+                                                      c.username() + \")\";\n+                                           return c.fullName().isPresent() ?\n+                                                    c.fullName() + \" (\" + link + \")\" :\n+                                                    link;\n+                                       })\n+                                       .collect(Collectors.toList());\n+                var numReviewers = reviewers.size();\n+                var listing = numReviewers == 1 ?\n+                    reviewers.get(0) :\n+                    String.join(\", \", reviewers.subList(0, numReviewers - 1));\n+                if (numReviewers > 1) {\n+                    listing += \" and \" + reviewers.get(numReviewers - 1);\n+                }\n+                info += \" and was reviewed by \" + listing;\n+            }\n+            info += \".\";\n+            lines.add(info);\n+            lines.add(\"\");\n+            lines.add(\"Thanks,\");\n+            lines.add(\"J. Duke\");\n+\n+            var prFromFork = fork.createPullRequest(targetRepo.get(),\n+                                                    \"master\",\n+                                                    backportBranch.name(),\n+                                                    \"Backport \" + hash.hex(),\n+                                                    lines);\n+            var prFromTarget = targetRepo.get().pullRequest(prFromFork.id());\n+            reply.println(\"@\" + command.user().username() + \" backport pull request [#\" + prFromTarget.id() + \"](\" + prFromFork.webUrl() + \") targeting repository [\" + targetRepo.get().name() + \"](\" + targetRepo.get().webUrl() + \") created successfully.\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/BackportCommand.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -46,1 +46,2 @@\n-            Map.entry(\"help\", new HelpCommand())\n+            Map.entry(\"help\", new HelpCommand()),\n+            Map.entry(\"backport\", new BackportCommand())\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CommitCommandWorkItem.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    private final Map<String, HostedRepository> forks;\n@@ -77,1 +78,2 @@\n-                   String confOverrideRef, String censusLink, List<HostUser> commitCommandUsers) {\n+                   String confOverrideRef, String censusLink, List<HostUser> commitCommandUsers,\n+                   Map<String, HostedRepository> forks) {\n@@ -100,0 +102,1 @@\n+        this.forks = forks;\n@@ -274,0 +277,4 @@\n+    Optional<HostedRepositoryPool> hostedRepositoryPool() {\n+        return seedStorage().map(path -> new HostedRepositoryPool(path));\n+    }\n+\n@@ -292,0 +299,8 @@\n+\n+    HostedRepository writeableForkOf(HostedRepository upstream) {\n+        var fork = forks.get(upstream.name());\n+        if (fork == null) {\n+            throw new IllegalArgumentException(\"No writeable fork for \" + upstream.name());\n+        }\n+        return fork;\n+    }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBot.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    private Map<String, HostedRepository> forks = Map.of();\n@@ -154,0 +155,5 @@\n+    public PullRequestBotBuilder forks(Map<String, HostedRepository> forks) {\n+        this.forks = forks;\n+        return this;\n+    }\n+\n@@ -159,1 +165,1 @@\n-                                  confOverrideRef, censusLink, commitCommandUsers);\n+                                  confOverrideRef, censusLink, commitCommandUsers, forks);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotBuilder.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,0 +59,8 @@\n+        var forks = new HashMap<String, HostedRepository>();\n+        if (specific.contains(\"forks\")) {\n+            for (var fork : specific.get(\"forks\").asArray()) {\n+                var repo = configuration.repository(fork.asString());\n+                forks.put(repo.name(), repo);\n+            }\n+        }\n+\n@@ -92,1 +100,2 @@\n-                                           .seedStorage(configuration.storageFolder().resolve(\"seeds\"));\n+                                           .seedStorage(configuration.storageFolder().resolve(\"seeds\"))\n+                                           .forks(forks);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotFactory.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import org.junit.jupiter.api.*;\n+import org.openjdk.skara.issuetracker.Issue;\n+import org.openjdk.skara.test.*;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class BackportCommitCommandTests {\n+    @Test\n+    void simple(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .commitCommandUsers(List.of(author.forge().currentUser()))\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make a change in another branch\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"edit\");\n+\n+            \/\/ Add a backport command\n+            author.addCommitComment(editHash, \"\/backport \" + author.name());\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\"backport\"));\n+            assertTrue(botReply.body().contains(\"created successfully.\"));\n+\n+            var pulls = author.pullRequests();\n+            assertEquals(1, pulls.size());\n+            var pr = pulls.get(0);\n+            assertEquals(\"Backport \" + editHash.hex(), pr.title());\n+            assertEquals(\"master\", pr.targetRef());\n+\n+            var prDiff = pr.diff();\n+            var commitDiff = localRepo.diff(masterHash, editHash);\n+            assertEquals(1, commitDiff.patches().size());\n+            assertEquals(1, prDiff.patches().size());\n+\n+            var commitPatch = commitDiff.patches().get(0);\n+            var prPatch = commitDiff.patches().get(0);\n+            assertEquals(commitPatch.status(), prPatch.status());\n+            assertEquals(commitPatch.target().path(), prPatch.target().path());\n+            assertEquals(commitPatch.source().path(), prPatch.source().path());\n+\n+            var commitHunks = commitPatch.asTextualPatch().hunks();\n+            var prHunks = prPatch.asTextualPatch().hunks();\n+            assertEquals(commitHunks.size(), prHunks.size());\n+            for (var i = 0; i < commitHunks.size(); i++) {\n+                var commitHunk = commitHunks.get(i);\n+                var prHunk = prHunks.get(i);\n+                assertEquals(commitHunk.target().lines(), prHunk.target().lines());\n+                assertEquals(commitHunk.source().lines(), prHunk.source().lines());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void unknownTargetRepo(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .commitCommandUsers(List.of(author.forge().currentUser()))\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make a change in another branch\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"edit\");\n+\n+            \/\/ Add a backport command\n+            author.addCommitComment(editHash, \"\/backport non-existing-repo\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\"target repository\"));\n+            assertTrue(botReply.body().contains(\"does not exist\"));\n+            assertEquals(List.of(), author.pullRequests());\n+        }\n+    }\n+\n+    @Test\n+    void unknownTargetBranch(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .commitCommandUsers(List.of(author.forge().currentUser()))\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make a change in another branch\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"edit\");\n+\n+            \/\/ Add a backport command\n+            author.addCommitComment(editHash, \"\/backport \" + author.name() + \" non-existing-branch\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\"target branch\"));\n+            assertTrue(botReply.body().contains(\"does not exist\"));\n+            assertEquals(List.of(), author.pullRequests());\n+        }\n+    }\n+\n+    @Test\n+    void backportDoesNotApply(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .commitCommandUsers(List.of(author.forge().currentUser()))\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Make a change push it to edit branch\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"edit\", true);\n+\n+            var masterHash2 = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash2, author.url(), \"master\", true);\n+\n+            \/\/ Add a backport command\n+            author.addCommitComment(editHash, \"\/backport \" + author.name() + \" master\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\":warning: could not backport\"));\n+            assertEquals(List.of(), author.pullRequests());\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/BackportCommitCommandTests.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -219,0 +219,1 @@\n+                             .sorted((c1, c2) -> c2.updatedAt().compareTo(c1.updatedAt()))\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestHostedRepository.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}