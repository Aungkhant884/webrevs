{"files":[{"patch":"@@ -288,0 +288,6 @@\n+\n+    @Override\n+    public void visit(JCheckConfIssue issue) {\n+        addFailureMessage(issue.check(), \".jcheck\/conf is invalid: \" + issue.getErrorMessage());\n+        readyForReview = false;\n+    }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestCheckIssueVisitor.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2227,0 +2227,118 @@\n+\n+    @Test\n+    void testJCheckConfCheck(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                    .addAuthor(author.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var checkBot = PullRequestBot.newBuilder()\n+                    .repo(author)\n+                    .censusRepo(censusBuilder.build())\n+                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                    .seedStorage(seedFolder)\n+                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+\n+            \/\/ Remove .jcheck\/conf\n+            localRepo.remove(localRepo.root().resolve(\".jcheck\/conf\"));\n+            localRepo.commit(\"no conf\", \"testauthor\", \"ta@none.none\");\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ write new conf\n+            Files.createDirectories(tempFolder.path().resolve(\".jcheck\"));\n+            var checkConf = tempFolder.path().resolve(\".jcheck\/conf\");\n+            try (var output = Files.newBufferedWriter(checkConf)) {\n+                output.append(\"[general]\\n\");\n+                output.append(\"project=test\\n\");\n+                output.append(\"jbs=tstprj\\n\");\n+                output.append(\"\\n\");\n+                output.append(\"[checks]\\n\");\n+                output.append(\"error=\");\n+                output.append(String.join(\",\", Set.of(\"author\", \"reviewers\", \"whitespace\", \"jcheckconf\")));\n+                output.append(\"\\n\\n\");\n+                output.append(\"[census]\\n\");\n+                output.append(\"version=0\\n\");\n+                output.append(\"domain=openjdk.org\\n\");\n+                output.append(\"\\n\");\n+                output.append(\"[checks \\\"whitespace\\\"]\\n\");\n+                output.append(\"files=.*\\\\.txt\\n\");\n+                output.append(\"\\n\");\n+                output.append(\"[checks \\\"reviewers\\\"]\\n\");\n+                output.append(\"reviewers=1\\n\");\n+            }\n+            localRepo.add(checkConf);\n+            masterHash = localRepo.commit(\"add conf to master\", \"testauthor\", \"ta@none.none\");\n+            localRepo.push(masterHash, author.url(), \"master\", true);\n+\n+            \/\/ Create a new branch\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.url(), \"edit\", true);\n+\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"This is a pull request\");\n+\n+            \/\/ Check the status\n+            TestBotRunner.runPeriodicItems(checkBot);\n+            var checks = pr.checks(editHash);\n+            assertEquals(1, checks.size());\n+            var check = checks.get(\"jcheck\");\n+            assertEquals(CheckStatus.SUCCESS, check.status());\n+            assertTrue(pr.store().labelNames().contains(\"rfr\"));\n+\n+            \/\/ Make .jcheck\/conf invalid\n+            try (var output = new FileWriter(checkConf.toFile(), true)) {\n+                output.append(\"\\nRandomCharacters\");\n+            }\n+            localRepo.add(checkConf);\n+            var invalidHash = localRepo.commit(\"add conf to master\", \"testauthor\", \"ta@none.none\");\n+            localRepo.push(invalidHash, author.url(), \"edit\", true);\n+\n+            TestBotRunner.runPeriodicItems(checkBot);\n+            checks = pr.checks(invalidHash);\n+            assertEquals(1, checks.size());\n+            check = checks.get(\"jcheck\");\n+            assertEquals(CheckStatus.FAILURE, check.status());\n+            assertTrue(pr.store().body().contains(\".jcheck\/conf is invalid: line 17: entry must be of form 'key = value'\"));\n+            assertFalse(pr.store().labelNames().contains(\"rfr\"));\n+\n+            \/\/ Restore .jcheck\/conf\n+            try (var output = Files.newBufferedWriter(checkConf)) {\n+                output.append(\"[general]\\n\");\n+                output.append(\"project=test\\n\");\n+                output.append(\"jbs=tstprj\\n\");\n+                output.append(\"\\n\");\n+                output.append(\"[checks]\\n\");\n+                output.append(\"error=\");\n+                output.append(String.join(\",\", Set.of(\"author\", \"reviewers\", \"whitespace\", \"jcheckconf\")));\n+                output.append(\"\\n\\n\");\n+                output.append(\"[census]\\n\");\n+                output.append(\"version=0\\n\");\n+                output.append(\"domain=openjdk.org\\n\");\n+                output.append(\"\\n\");\n+                output.append(\"[checks \\\"whitespace\\\"]\\n\");\n+                output.append(\"files=.*\\\\.txt\\n\");\n+                output.append(\"\\n\");\n+                output.append(\"[checks \\\"reviewers\\\"]\\n\");\n+                output.append(\"reviewers=1\\n\");\n+            }\n+            localRepo.add(checkConf);\n+            var restoreHash = localRepo.commit(\"restore .jcheck\/conf\", \"testauthor\", \"ta@none.none\");\n+            localRepo.push(restoreHash, author.url(), \"edit\", true);\n+\n+            TestBotRunner.runPeriodicItems(checkBot);\n+            checks = pr.checks(restoreHash);\n+            assertEquals(1, checks.size());\n+            check = checks.get(\"jcheck\");\n+            assertEquals(CheckStatus.SUCCESS, check.status());\n+            assertTrue(pr.store().labelNames().contains(\"rfr\"));\n+        }\n+    }\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/CheckTests.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -311,0 +311,8 @@\n+\n+    @Override\n+    public void visit(JCheckConfIssue i) {\n+        if (!ignore.contains(i.check().name())) {\n+            println(i, \".jcheck\/conf is invalid: \" + i.getErrorMessage());\n+            hasDisplayedErrors = true;\n+        }\n+    }\n","filename":"cli\/src\/main\/java\/org\/openjdk\/skara\/cli\/JCheckCLIVisitor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    void visit(JCheckConfIssue issue);\n","filename":"jcheck\/src\/main\/java\/org\/openjdk\/skara\/jcheck\/IssueVisitor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,2 @@\n-            new ProblemListsCheck(repository)\n+            new ProblemListsCheck(repository),\n+            new JCheckConfCheck(repository)\n","filename":"jcheck\/src\/main\/java\/org\/openjdk\/skara\/jcheck\/JCheck.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.jcheck;\n+\n+import org.openjdk.skara.census.Census;\n+import org.openjdk.skara.vcs.Commit;\n+import org.openjdk.skara.vcs.ReadOnlyRepository;\n+import org.openjdk.skara.vcs.openjdk.CommitMessage;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+public class JCheckConfCheck extends CommitCheck {\n+    private final Logger log = Logger.getLogger(\"org.openjdk.skara.jcheck.jcheckconf\");\n+\n+    private final ReadOnlyRepository repo;\n+\n+    public JCheckConfCheck(ReadOnlyRepository repo) {\n+        this.repo = repo;\n+    }\n+\n+    @Override\n+    Iterator<Issue> check(Commit commit, CommitMessage message, JCheckConfiguration conf, Census census) {\n+        var metadata = CommitIssue.metadata(commit, message, conf, this);\n+        var hash = commit.hash();\n+\n+        Optional<List<String>> lines;\n+        try {\n+            lines = repo.lines(Path.of(\".jcheck\/conf\"), hash);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        if (lines.isEmpty()) {\n+            log.finer(\".jcheck\/conf is missing\");\n+            return iterator(new JCheckConfIssue(metadata, \".jcheck\/conf is missing\"));\n+        }\n+        try {\n+            JCheckConfiguration.parse(lines.get());\n+        } catch (RuntimeException e) {\n+            log.finer(\".jcheck\/conf is not valid\");\n+            return iterator(new JCheckConfIssue(metadata, e.getMessage()));\n+        }\n+        return iterator();\n+    }\n+\n+    @Override\n+    public String name() {\n+        return \"jcheckconf\";\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"Change must contain valid jcheck configuration\";\n+    }\n+}\n","filename":"jcheck\/src\/main\/java\/org\/openjdk\/skara\/jcheck\/JCheckConfCheck.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.jcheck;\n+\n+public class JCheckConfIssue extends CommitIssue {\n+    String errorMessage;\n+\n+    public JCheckConfIssue(Metadata metadata, String errorMessage) {\n+        super(metadata);\n+        this.errorMessage = errorMessage;\n+    }\n+\n+    @Override\n+    public void accept(IssueVisitor v) {\n+        v.visit(this);\n+    }\n+\n+    public String getErrorMessage() {\n+        return errorMessage;\n+    }\n+}\n","filename":"jcheck\/src\/main\/java\/org\/openjdk\/skara\/jcheck\/JCheckConfIssue.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+package org.openjdk.skara.jcheck;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openjdk.skara.vcs.*;\n+import org.openjdk.skara.vcs.openjdk.CommitMessage;\n+import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class JCheckConfCheckTests {\n+\n+    private class JCheckConfTestRepository extends TestRepository {\n+        List<String> conf;\n+\n+        public JCheckConfTestRepository(List<String> text) {\n+            conf = List.copyOf(text);\n+        }\n+\n+        @Override\n+        public Optional<List<String>> lines(Path p, Hash h) throws IOException {\n+            if (p.toString().equals(\".jcheck\/conf\")) {\n+                return Optional.of(conf);\n+            }\n+            return super.lines(p, h);\n+        }\n+\n+        public void setConf(List<String> text) {\n+            conf = List.copyOf(text);\n+        }\n+    }\n+\n+    private static final List<String> CONFIGURATION = List.of(\n+            \"[general]\",\n+            \"project = test\",\n+            \"[checks]\",\n+            \"error = jcheckconf\"\n+    );\n+\n+    private static final JCheckConfiguration conf = JCheckConfiguration.parse(CONFIGURATION);\n+\n+    private ReadOnlyRepository repo = new JCheckConfTestRepository(CONFIGURATION);\n+\n+    private List<Issue> toList(Iterator<Issue> i) {\n+        var list = new ArrayList<Issue>();\n+        while (i.hasNext()) {\n+            list.add(i.next());\n+        }\n+        return list;\n+    }\n+\n+    private static Commit commit(int id, String... message) {\n+        var author = new Author(\"foo\", \"foo@host.org\");\n+        var hash = new Hash((\"\" + id).repeat(40));\n+        var parents = List.of(Hash.zero());\n+        var authored = ZonedDateTime.now();\n+        var metadata = new CommitMetadata(hash, parents, author, authored, author, authored, List.of(message));\n+        return new Commit(metadata, List.of());\n+    }\n+\n+    private static CommitMessage message(Commit c) {\n+        return CommitMessageParsers.v1.parse(c);\n+    }\n+\n+    @Test\n+    void validJCheckConfTest() {\n+        var commit = commit(0, \"Bugfix\");\n+        var message = message(commit);\n+        var check = new JCheckConfCheck(repo);\n+        var issues = toList(check.check(commit, message, conf, null));\n+        assertEquals(0, issues.size());\n+    }\n+\n+    @Test\n+    void invalidJCheckConfTest() {\n+        var commit = commit(0, \"Bugfix\");\n+        var message = message(commit);\n+        var check = new JCheckConfCheck(repo);\n+\n+        ((JCheckConfTestRepository) repo).setConf(List.of(\n+                \"[general] 36542\",\n+                \"project = test\",\n+                \"[checks]\",\n+                \"error = jcheckconf\"\n+        ));\n+        var issues = toList(check.check(commit, message, conf, null));\n+        assertEquals(1, issues.size());\n+        assertEquals(\"line 0: section header must end with ']'\", ((JCheckConfIssue) issues.get(0)).getErrorMessage());\n+\n+        ((JCheckConfTestRepository) repo).setConf(List.of(\n+                \"[general]\",\n+                \"project = test\",\n+                \"[checks]\",\n+                \"error = jcheckconf\",\n+                \"randomrandom\"\n+        ));\n+        issues = toList(check.check(commit, message, conf, null));\n+        assertEquals(1, issues.size());\n+        assertEquals(\"line 4: entry must be of form 'key = value'\", ((JCheckConfIssue) issues.get(0)).getErrorMessage());\n+    }\n+}\n","filename":"jcheck\/src\/test\/java\/org\/openjdk\/skara\/jcheck\/JCheckConfCheckTests.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -241,0 +241,5 @@\n+        @Override\n+        public void visit(JCheckConfIssue e) {\n+            issues.add(e);\n+        }\n+\n","filename":"jcheck\/src\/test\/java\/org\/openjdk\/skara\/jcheck\/JCheckTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}