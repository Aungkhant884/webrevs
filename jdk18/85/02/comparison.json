{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,2 @@\n-                c.members_field = new Scope.ErrorScope(c); \/\/ make sure it's always defined\n+                Scope.ErrorScope members = new Scope.ErrorScope(c);\n+                c.members_field = members; \/\/ make sure it's always defined\n@@ -298,1 +299,6 @@\n-                fillIn(c);\n+                \/\/if an enclosing class is completed from the source,\n+                \/\/this class might have been completed already as well,\n+                \/\/avoid attempts to re-complete it:\n+                if (c.members_field == members) {\n+                    fillIn(c);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278930\n+ * @summary Check that when a package has Elements listed from both from classes and sources,\n+ *          and then a nested class is completed, it is not first completed from source via\n+ *          its enclosing class, and then again for itself.\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ * @run main TestListPackageFromAPI\n+ *\/\n+\n+import com.sun.source.util.JavacTask;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.PackageElement;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.JavaFileObject.Kind;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+public class TestListPackageFromAPI {\n+\n+    public static void main(String... args) throws IOException, URISyntaxException, InterruptedException {\n+        try (JavaFileManager fm = ToolProvider.getSystemJavaCompiler().getStandardFileManager(null, null, null)) {\n+            List<JavaFileObject> testClasses = List.of(\n+                new TestFileObject(\"Test\"),\n+                new TestFileObject(\"Test$Nested\")\n+            );\n+            List<JavaFileObject> testSources = List.of(\n+                    new TestFileObject(\"Test\",\n+                                       \"\"\"\n+                                       class Test {\n+                                           public static class Nested {}\n+                                       }\n+                                       \"\"\")\n+            );\n+            JavaFileManager testFM = new ForwardingJavaFileManagerImpl(fm, testClasses, testSources);\n+            DiagnosticListener<JavaFileObject> noErrors = d -> { throw new AssertionError(\"Should not happen: \" + d); };\n+            JavacTask task = (JavacTask) ToolProvider.getSystemJavaCompiler().getTask(null, testFM, noErrors, null, null, List.of(new TestFileObject(\"Input\", \"\")));\n+            PackageElement pack = task.getElements().getPackageElement(\"\");\n+            pack.getEnclosedElements().forEach(e -> System.err.println(e));\n+        }\n+    }\n+\n+    private static class TestFileObject extends SimpleJavaFileObject {\n+\n+        private final String className;\n+        private final String code;\n+\n+        public TestFileObject(String className) throws URISyntaxException {\n+            super(new URI(\"mem:\/\/\" + className + \".class\"), Kind.CLASS);\n+            this.className = className;\n+            this.code = null;\n+        }\n+\n+        public TestFileObject(String className, String code) throws URISyntaxException {\n+            super(new URI(\"mem:\/\/\" + className + \".java\"), Kind.SOURCE);\n+            this.className = className;\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+            if (code == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+            return code;\n+        }\n+\n+        @Override\n+        public long getLastModified() {\n+            return getKind() == Kind.CLASS ? 0 : 1000;\n+        }\n+\n+    }\n+\n+    private static class ForwardingJavaFileManagerImpl extends ForwardingJavaFileManager<JavaFileManager> {\n+\n+        private final List<JavaFileObject> testClasses;\n+        private final List<JavaFileObject> testSources;\n+\n+        public ForwardingJavaFileManagerImpl(JavaFileManager fileManager, List<JavaFileObject> testClasses, List<JavaFileObject> testSources) {\n+            super(fileManager);\n+            this.testClasses = testClasses;\n+            this.testSources = testSources;\n+        }\n+\n+        @Override\n+        public Iterable<JavaFileObject> list(JavaFileManager.Location location, String packageName, Set<JavaFileObject.Kind> kinds, boolean recurse) throws IOException {\n+            if (packageName.isEmpty()) {\n+                List<JavaFileObject> result = new ArrayList<>();\n+                if (location == StandardLocation.CLASS_PATH && kinds.contains(Kind.CLASS)) {\n+                    result.addAll(testClasses);\n+                } else if (location == StandardLocation.SOURCE_PATH && kinds.contains(Kind.SOURCE)) {\n+                    result.addAll(testSources);\n+                }\n+                return result;\n+            }\n+            return super.list(location, packageName, kinds, recurse);\n+        }\n+\n+        @Override\n+        public boolean hasLocation(Location location) {\n+            return location == StandardLocation.CLASS_PATH ||\n+                   location == StandardLocation.SOURCE_PATH ||\n+                   super.hasLocation(location);\n+        }\n+\n+        @Override\n+        public String inferBinaryName(JavaFileManager.Location location, JavaFileObject file) {\n+            if (file instanceof TestFileObject testFO) {\n+                return testFO.className;\n+            }\n+            return super.inferBinaryName(location, file);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestListPackageFromAPI.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"}]}