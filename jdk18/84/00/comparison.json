{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -283,1 +283,0 @@\n-        awaitUniqueTimestamp();\n@@ -285,1 +284,5 @@\n-        long nanos = jvm.getChunkStartNanos();\n+        \/\/ Each chunk needs a unique start timestamp and\n+        \/\/ if the clock resolution is low, two chunks may\n+        \/\/ get the same timestamp. Utils.getChunkStartNanos()\n+        \/\/ ensures the timestamp is unique for the next chunk\n+        long chunkStart = Utils.getChunkStartNanos();\n@@ -296,23 +299,1 @@\n-        return Utils.epochNanosToInstant(nanos);\n-    }\n-\n-    \/\/ Each chunk needs a unique start timestamp and\n-    \/\/ if the clock resolution is low, two chunks may\n-    \/\/ get the same timestamp.\n-    private void awaitUniqueTimestamp() {\n-        if (outputChange == null) {\n-            outputChange = Instant.now();\n-            return;\n-        }\n-        while (true) {\n-            Instant time = Instant.now();\n-            if (!time.equals(outputChange)) {\n-                outputChange = time;\n-                return;\n-            }\n-            try {\n-                Thread.sleep(0, 100);\n-            } catch (InterruptedException iex) {\n-                \/\/ ignore\n-            }\n-        }\n+        return Utils.epochNanosToInstant(chunkStart);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":7,"deletions":26,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-            startNanos = jvm.getChunkStartNanos();\n+            startNanos = Utils.getChunkStartNanos();\n@@ -272,1 +272,1 @@\n-            startNanos = jvm.getChunkStartNanos();\n+            startNanos = Utils.getChunkStartNanos();\n@@ -319,1 +319,1 @@\n-        recording.setFinalStartnanos(jvm.getChunkStartNanos());\n+        recording.setFinalStartnanos(Utils.getChunkStartNanos());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,1 @@\n+    private static Instant lastTimestamp;\n@@ -869,0 +870,26 @@\n+\n+    public static long getChunkStartNanos() {\n+        long nanos = JVM.getJVM().getChunkStartNanos();\n+        \/\/ JVM::getChunkStartNanos() may return a bumped timestamp, +1 ns or +2 ns.\n+        \/\/ Spin here to give Instant.now() a chance to catch up.\n+        awaitUniqueTimestamp();\n+        return nanos;\n+    }\n+\n+    private static void awaitUniqueTimestamp() {\n+        if (lastTimestamp == null) {\n+            lastTimestamp = Instant.now(); \/\/ lazy initialization\n+        }\n+        while (true) {\n+            Instant time = Instant.now();\n+            if (!time.equals(lastTimestamp)) {\n+                lastTimestamp = time;\n+                return;\n+            }\n+            try {\n+                Thread.sleep(0, 100);\n+            } catch (InterruptedException iex) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"}]}