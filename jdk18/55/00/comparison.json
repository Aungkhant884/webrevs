{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -526,4 +525,9 @@\n-     * The filter is created as if {@link #createFilter(String) createFilter} is called;\n-     * if the filter string is invalid, an {@link ExceptionInInitializerError} is thrown.\n-     * Otherwise, the filter is not configured during initialization and\n-     * can be set with {@link #setSerialFilter(ObjectInputFilter) Config.setSerialFilter}.\n+     * The filter is created as if {@link #createFilter(String) createFilter} is called,\n+     * if the filter string is invalid the initialization fails and subsequent attempts to\n+     * {@linkplain Config#getSerialFilter() get the filter}, {@linkplain Config#setSerialFilter set a filter},\n+     * or create an {@linkplain ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream}\n+     * throw {@link IllegalStateException}. Deserialization is not possible with an\n+     * invalid serial filter.\n+     * If the system property {@code jdk.serialFilter} or the {@link java.security.Security}\n+     * property {@code jdk.serialFilter} is not set the filter can be set with\n+     * {@link #setSerialFilter(ObjectInputFilter) Config.setSerialFilter}.\n@@ -548,3 +552,6 @@\n-     * If the filter factory constructor is not invoked successfully, an {@link ExceptionInInitializerError}\n-     * is thrown and subsequent use of the filter factory for deserialization fails with\n-     * {@link IllegalStateException}.\n+     * If the filter factory constructor is not invoked successfully subsequent attempts to\n+     * {@linkplain Config#getSerialFilterFactory() get the factory},\n+     * {@linkplain Config#setSerialFilterFactory(BinaryOperator) set the factory}, or create an\n+     * {@link ObjectInputStream#ObjectInputStream(InputStream) ObjectInputStream}\n+     * throw {@link IllegalStateException}. Deserialization is not possible with an\n+     * invalid serial filter factory.\n@@ -585,0 +592,5 @@\n+        \/**\n+         * Saved message if the jdk.serialFilter property is invalid.\n+         *\/\n+        private static final String invalidFilterMessage;\n+\n@@ -591,0 +603,5 @@\n+        \/**\n+         * Saved message if the jdk.serialFilterFactory property is invalid.\n+         *\/\n+        private static final String invalidFactoryMessage;\n+\n@@ -633,1 +650,1 @@\n-            ObjectInputFilter filter = null;\n+            String filterMessage = null;\n@@ -638,1 +655,1 @@\n-                    filter = createFilter(filterString);\n+                    serialFilter = createFilter(filterString);\n@@ -642,2 +659,2 @@\n-                    \/\/ Do not continue if configuration not initialized\n-                    throw re;\n+                    \/\/ serialFilter remains null\n+                    filterMessage = \"Invalid jdk.serialFilter: \" +  re.getMessage();\n@@ -646,1 +663,1 @@\n-            serialFilter = filter;\n+            invalidFilterMessage = filterMessage;\n@@ -650,0 +667,1 @@\n+            String factoryMessage = null;\n@@ -674,2 +692,4 @@\n-                    \/\/ Do not continue if configuration not initialized\n-                    throw new ExceptionInInitializerError(th);\n+                    \/\/ Configuration not initialized\n+                    \/\/ serialFilterFactory remains null and filterFactoryNoReplace == true;\n+                    factoryMessage = \"invalid jdk.serialFilterFactory: \" +\n+                            factoryClassName + \": \" + th.getClass().getName() + \": \" + th.getMessage();\n@@ -678,0 +698,1 @@\n+            invalidFactoryMessage = factoryMessage;\n@@ -699,0 +720,3 @@\n+         * @throws IllegalStateException if the initialization of the filter from the\n+         *      system property {@code jdk.serialFilter} or\n+         *      the security property {@code jdk.serialFilter} fails.\n@@ -701,0 +725,3 @@\n+            if (invalidFilterMessage != null) {\n+                throw new IllegalStateException(invalidFilterMessage);\n+            }\n@@ -710,1 +737,3 @@\n-         * @throws IllegalStateException if the filter has already been set\n+         * @throws IllegalStateException if the filter has already been set or the initialization\n+         *       of the filter from the system property {@code jdk.serialFilter} or\n+         *       the security property {@code jdk.serialFilter} fails.\n@@ -719,0 +748,3 @@\n+            if (invalidFilterMessage != null) {\n+                throw new IllegalStateException(invalidFilterMessage);\n+            }\n@@ -752,2 +784,4 @@\n-            if (serialFilterFactory == null)\n-                throw new IllegalStateException(\"Serial filter factory initialization incomplete\");\n+            if (serialFilterFactory == null) {\n+                \/\/ If initializing the factory failed or not yet complete, throw with the message\n+                throw new IllegalStateException(invalidFilterFactoryMessage());\n+            }\n@@ -815,3 +849,3 @@\n-                        ? serialFilterFactory.getClass().getName()\n-                        : \"initialization incomplete\";\n-                throw new IllegalStateException(\"Cannot replace filter factory: \" + msg);\n+                        ? \"Cannot replace filter factory: \" + serialFilterFactory.getClass().getName()\n+                        : invalidFilterFactoryMessage();\n+                throw new IllegalStateException(msg);\n@@ -824,0 +858,11 @@\n+        \/*\n+         * Return message for an invalid filter factory configuration saved from the static init.\n+         * It can be called before the static initializer is complete and has set the message\/null.\n+         *\/\n+        private static String invalidFilterFactoryMessage() {\n+            assert serialFilterFactory == null;     \/\/ undefined if a filter factory has been set\n+            return (invalidFactoryMessage != null)\n+                ? invalidFactoryMessage\n+                : \"Serial filter factory initialization incomplete\";\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputFilter.java","additions":66,"deletions":21,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -387,0 +387,2 @@\n+     * If the serial filter or serial filter factory properties are invalid\n+     * an {@link IllegalStateException} is thrown.\n@@ -399,0 +401,2 @@\n+     * @throws  IllegalStateException if the initialization of {@link ObjectInputFilter.Config}\n+     *          fails due to invalid serial filter or serial filter factory properties.\n@@ -424,0 +428,2 @@\n+     * If the serial filter or serial filter factory properties are invalid\n+     * an {@link IllegalStateException} is thrown.\n@@ -434,0 +440,2 @@\n+     * @throws  IllegalStateException if the initialization of {@link ObjectInputFilter.Config}\n+     *      fails due to invalid serial filter or serial filter factory properties.\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,2 +24,3 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n@@ -27,1 +28,2 @@\n-import java.io.File;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n@@ -29,0 +31,2 @@\n+import java.io.ObjectInputStream;\n+import java.util.Map;\n@@ -32,1 +36,1 @@\n- * @bug 8269336\n+ * @bug 8278087\n@@ -34,3 +38,6 @@\n- * exception to be thrown in the class initialization of java.io.ObjectInputFilter.Config class\n- * @library \/test\/lib\n- * @run driver InvalidGlobalFilterTest\n+ * exception to be thrown when an attempt is made to use the filter or deserialize.\n+ * A subset of invalid filter patterns is tested.\n+ * @run testng\/othervm -Djdk.serialFilter=.* InvalidGlobalFilterTest\n+ * @run testng\/othervm -Djdk.serialFilter=! InvalidGlobalFilterTest\n+ * @run testng\/othervm -Djdk.serialFilter=\/ InvalidGlobalFilterTest\n+ *\n@@ -38,0 +45,1 @@\n+@Test\n@@ -40,0 +48,7 @@\n+    private static final String serialFilter = System.getProperty(serialPropName);\n+\n+    static {\n+        \/\/ Enable logging\n+        System.setProperty(\"java.util.logging.config.file\",\n+                System.getProperty(\"test.src\", \".\") + \"\/logging.properties\");\n+    }\n@@ -42,6 +57,1 @@\n-     * Launches multiple instances of a Java program by passing each instance an invalid value\n-     * for the {@code jdk.serialFilter} system property. The launched program then triggers the\n-     * class initialization of {@code ObjectInputFilter.Config} class to have it parse the (invalid)\n-     * value of the system property. The launched program is expected to propagate the exception\n-     * raised by the {@code ObjectInputFilter.Config} initialization and the test asserts that the\n-     * launched program did indeed fail with this expected exception.\n+     * Map of invalid patterns to the expected exception message.\n@@ -49,22 +59,31 @@\n-    public static void main(final String[] args) throws Exception {\n-        final String[] invalidPatterns = {\".*\", \".**\", \"!\", \"\/java.util.Hashtable\", \"java.base\/\", \"\/\"};\n-        for (final String invalidPattern : invalidPatterns) {\n-            final ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(\n-                    \"-D\" + serialPropName + \"=\" + invalidPattern,\n-                    \"-Djava.util.logging.config.file=\" + System.getProperty(\"test.src\")\n-                            + File.separator + \"logging.properties\",\n-                    ObjectInputFilterConfigLoader.class.getName());\n-            \/\/ launch a process by passing it an invalid value for -Djdk.serialFilter\n-            final OutputAnalyzer outputAnalyzer = ProcessTools.executeProcess(processBuilder);\n-            try {\n-                \/\/ we expect the JVM launch to fail\n-                outputAnalyzer.shouldNotHaveExitValue(0);\n-                \/\/ do an additional check to be sure it failed for the right reason\n-                outputAnalyzer.stderrShouldContain(\"java.lang.ExceptionInInitializerError\");\n-            } finally {\n-                \/\/ fail or pass, we print out the generated output from the launched program\n-                \/\/ for any debugging\n-                System.err.println(\"Diagnostics from process \" + outputAnalyzer.pid() + \":\");\n-                \/\/ print out any stdout\/err that was generated in the launched program\n-                outputAnalyzer.reportDiagnosticSummary();\n-            }\n+    private static final Map<String, String> invalidMessages =\n+            Map.of(\".*\", \"Invalid jdk.serialFilter: package missing in: \\\".*\\\"\",\n+                    \".**\", \"Invalid jdk.serialFilter: package missing in: \\\".**\\\"\",\n+                    \"!\", \"Invalid jdk.serialFilter: class or package missing in: \\\"!\\\"\",\n+                    \"\/java.util.Hashtable\", \"Invalid jdk.serialFilter: module name is missing in: \\\"\/java.util.Hashtable\\\"\",\n+                    \"java.base\/\", \"Invalid jdk.serialFilter: class or package missing in: \\\"java.base\/\\\"\",\n+                    \"\/\", \"Invalid jdk.serialFilter: module name is missing in: \\\"\/\\\"\");\n+\n+    @DataProvider(name = \"MethodsToCall\")\n+    private Object[][] cases() {\n+        return new Object[][] {\n+                {serialFilter, \"getSerialFilter\", (Assert.ThrowingRunnable) () -> ObjectInputFilter.Config.getSerialFilter()},\n+                {serialFilter, \"setSerialFilter\", (Assert.ThrowingRunnable) () -> ObjectInputFilter.Config.setSerialFilter(new NoopFilter())},\n+                {serialFilter, \"new ObjectInputStream(is)\", (Assert.ThrowingRunnable) () -> new ObjectInputStream(new ByteArrayInputStream(new byte[0]))},\n+                {serialFilter, \"new OISSubclass()\", (Assert.ThrowingRunnable) () -> new OISSubclass()},\n+        };\n+    }\n+\n+    \/**\n+     * Test each method that should throw IllegalStateException based on\n+     * the invalid arguments it was launched with.\n+     *\/\n+    @Test(dataProvider = \"MethodsToCall\")\n+    public void initFaultTest(String pattern, String method, Assert.ThrowingRunnable runnable) {\n+\n+        IllegalStateException ex = Assert.expectThrows(IllegalStateException.class,\n+                runnable);\n+\n+        String expected = invalidMessages.get(serialFilter);\n+        if (expected == null) {\n+            Assert.fail(\"No expected message for filter: \" + serialFilter);\n@@ -72,0 +91,2 @@\n+        System.out.println(ex.getMessage());\n+        Assert.assertEquals(ex.getMessage(), expected, \"wrong message\");\n@@ -74,2 +95,10 @@\n-    \/\/ A main() class which just triggers the class initialization of ObjectInputFilter.Config\n-    private static final class ObjectInputFilterConfigLoader {\n+    private static class NoopFilter implements ObjectInputFilter {\n+        \/**\n+         * Returns UNDECIDED.\n+         *\n+         * @param filter the FilterInfo\n+         * @return Status.UNDECIDED\n+         *\/\n+        public ObjectInputFilter.Status checkInput(FilterInfo filter) {\n+             return ObjectInputFilter.Status.UNDECIDED;\n+        }\n@@ -77,8 +106,2 @@\n-        public static void main(final String[] args) throws Exception {\n-            System.out.println(\"JVM was launched with \" + serialPropName\n-                    + \" system property set to \" + System.getProperty(serialPropName));\n-            \/\/ this call is expected to fail and we aren't interested in the result.\n-            \/\/ we just let the exception propagate out of this call and fail the\n-            \/\/ launched program. The test which launched this main, then asserts\n-            \/\/ that the exception was indeed thrown.\n-            ObjectInputFilter.Config.getSerialFilter();\n+        public String toString() {\n+            return \"NoopFilter\";\n@@ -87,0 +110,10 @@\n+\n+    \/**\n+     * Subclass of ObjectInputStream to test subclassing constructor.\n+     *\/\n+    private static class OISSubclass extends ObjectInputStream {\n+\n+        protected OISSubclass() throws IOException {\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/InvalidGlobalFilterTest.java","additions":78,"deletions":45,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -27,0 +28,2 @@\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n@@ -29,0 +32,1 @@\n+import java.io.ObjectInputStream;\n@@ -42,0 +46,3 @@\n+    \/\/ Sample the serial factory class name\n+    private static final String factoryName = System.getProperty(\"jdk.serialFilterFactory\");\n+\n@@ -48,5 +55,19 @@\n-    public void initFaultTest() {\n-        String factoryName = System.getProperty(\"jdk.serialFilterFactory\");\n-        ExceptionInInitializerError ex = Assert.expectThrows(ExceptionInInitializerError.class,\n-                () -> Config.getSerialFilterFactory());\n-        Throwable cause = ex.getCause();\n+    @DataProvider(name = \"MethodsToCall\")\n+    private Object[][] cases() {\n+        return new Object[][] {\n+                {\"getSerialFilterFactory\", (Assert.ThrowingRunnable) () -> Config.getSerialFilterFactory()},\n+                {\"setSerialFilterFactory\", (Assert.ThrowingRunnable) () -> Config.setSerialFilterFactory(new NoopFactory())},\n+                {\"new ObjectInputStream(is)\", (Assert.ThrowingRunnable) () -> new ObjectInputStream(new ByteArrayInputStream(new byte[0]))},\n+                {\"new OISSubclass()\", (Assert.ThrowingRunnable) () -> new OISSubclass()},\n+        };\n+    }\n+\n+    \/**\n+     * Test each method that should throw IllegalStateException based on\n+     * the invalid arguments it was launched with.\n+     *\/\n+    @Test(dataProvider = \"MethodsToCall\")\n+    public void initFaultTest(String name, Assert.ThrowingRunnable runnable) {\n+        IllegalStateException ex = Assert.expectThrows(IllegalStateException.class,\n+                runnable);\n+        final String msg = ex.getMessage();\n@@ -55,2 +76,2 @@\n-            Assert.assertEquals(cause.getClass(),\n-                    ClassNotFoundException.class, \"wrong exception\");\n+            Assert.assertEquals(msg,\n+                    \"invalid jdk.serialFilterFactory: ForcedError_NoSuchClass: java.lang.ClassNotFoundException: ForcedError_NoSuchClass\", \"wrong exception\");\n@@ -58,2 +79,2 @@\n-            Assert.assertEquals(cause.getClass(),\n-                    NoSuchMethodException.class, \"wrong exception\");\n+            Assert.assertEquals(msg,\n+                    \"invalid jdk.serialFilterFactory: SerialFactoryFaults$NoPublicConstructor: java.lang.NoSuchMethodException: SerialFactoryFaults$NoPublicConstructor.<init>()\", \"wrong exception\");\n@@ -61,2 +82,2 @@\n-            Assert.assertEquals(cause.getClass(),\n-                    IllegalStateException.class, \"wrong exception\");\n+            Assert.assertEquals(msg,\n+                    \"invalid jdk.serialFilterFactory: SerialFactoryFaults$ConstructorThrows: java.lang.RuntimeException: constructor throwing a runtime exception\", \"wrong exception\");\n@@ -64,5 +85,2 @@\n-            Assert.assertEquals(cause.getClass(),\n-                    IllegalStateException.class, \"wrong exception\");\n-            Assert.assertEquals(cause.getMessage(),\n-                    \"Cannot replace filter factory: initialization incomplete\",\n-                    \"wrong message\");\n+            Assert.assertEquals(msg,\n+                    \"invalid jdk.serialFilterFactory: SerialFactoryFaults$FactorySetsFactory: java.lang.IllegalStateException: Serial filter factory initialization incomplete\", \"wrong exception\");\n@@ -93,1 +111,1 @@\n-            throw new IllegalStateException(\"SerialFactoryFaults$ConstructorThrows\");\n+            throw new RuntimeException(\"constructor throwing a runtime exception\");\n@@ -115,0 +133,17 @@\n+    public static final class NoopFactory implements BinaryOperator<ObjectInputFilter> {\n+        public NoopFactory() {}\n+\n+        public ObjectInputFilter apply(ObjectInputFilter curr, ObjectInputFilter next) {\n+            throw new RuntimeException(\"NYI\");\n+        }\n+    }\n+\n+    \/**\n+     * Subclass of ObjectInputStream to test subclassing constructor.\n+     *\/\n+    private static class OISSubclass extends ObjectInputStream {\n+\n+        protected OISSubclass() throws IOException {\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryFaults.java","additions":52,"deletions":17,"binary":false,"changes":69,"status":"modified"}]}