{"files":[{"patch":"@@ -770,1 +770,5 @@\n-            scope.checkValidState();\n+            try {\n+                scope.checkValidState();\n+            } catch (ScopedMemoryAccess.Scope.ScopedAccessError e) {\n+                throw new IllegalStateException(\"This segment is already closed\");\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -367,5 +367,1 @@\n-        try {\n-            scope.checkValidState();\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n-            throw new IllegalStateException(\"This segment is already closed\");\n-        }\n+        scope.checkValidStateSlow();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-    private boolean closed; \/\/ = false\n-    private int lockCount = 0;\n@@ -45,1 +43,0 @@\n-    private final Thread owner;\n@@ -58,12 +55,1 @@\n-        super(new ConfinedResourceList(), cleaner);\n-        this.owner = owner;\n-    }\n-\n-    @ForceInline\n-    public final void checkValidState() {\n-        if (owner != Thread.currentThread()) {\n-            throw new IllegalStateException(\"Attempted access outside owning thread\");\n-        }\n-        if (closed) {\n-            throw new IllegalStateException(\"Already closed\");\n-        }\n+        super(owner, new ConfinedResourceList(), cleaner);\n@@ -74,1 +60,1 @@\n-        return !closed;\n+        return state != CLOSED;\n@@ -80,2 +66,2 @@\n-        checkValidState();\n-        if (lockCount == MAX_FORKS) {\n+        checkValidStateSlow();\n+        if (state == MAX_FORKS) {\n@@ -84,1 +70,1 @@\n-        lockCount++;\n+        state++;\n@@ -91,1 +77,1 @@\n-            lockCount--;\n+            state--;\n@@ -102,3 +88,3 @@\n-        this.checkValidState();\n-        if (lockCount == 0 || lockCount - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n-            closed = true;\n+        checkValidStateSlow();\n+        if (state == 0 || state - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n+            state = CLOSED;\n@@ -106,1 +92,1 @@\n-            throw new IllegalStateException(\"Scope is kept alive by \" + lockCount + \" scopes\");\n+            throw new IllegalStateException(\"Scope is kept alive by \" + state + \" scopes\");\n@@ -110,5 +96,0 @@\n-    @Override\n-    public Thread ownerThread() {\n-        return owner;\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":10,"deletions":29,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -35,1 +36,1 @@\n-        ((ResourceScopeImpl)scope).checkValidState();\n+        ((ResourceScopeImpl)scope).checkValidStateSlow();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -56,0 +58,17 @@\n+    final Thread owner;\n+\n+    static final int ALIVE = 0;\n+    static final int CLOSING = -1;\n+    static final int CLOSED = -2;\n+\n+    int state = ALIVE;\n+\n+    static final VarHandle STATE;\n+\n+    static {\n+        try {\n+            STATE = MethodHandles.lookup().findVarHandle(ResourceScopeImpl.class, \"state\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n@@ -92,1 +111,2 @@\n-    protected ResourceScopeImpl(ResourceList resourceList, Cleaner cleaner) {\n+    protected ResourceScopeImpl(Thread owner, ResourceList resourceList, Cleaner cleaner) {\n+        this.owner = owner;\n@@ -150,1 +170,3 @@\n-    public abstract Thread ownerThread();\n+    public final Thread ownerThread() {\n+        return owner;\n+    }\n@@ -158,1 +180,0 @@\n-\n@@ -161,3 +182,5 @@\n-     * relies on invariants associated with the memory scope implementations (typically, volatile access\n-     * to the closed state bit is replaced with plain access, and ownership check is removed where not needed.\n-     * Should be used with care.\n+     * relies on invariants associated with the memory scope implementations (volatile access\n+     * to the closed state bit is replaced with plain access). This method should be monomorphic,\n+     * to avoid virtual calls in the memory access hot path. This method is not intended as general purpose method\n+     * and should only be used in the memory access handle hot path; for liveness checks triggered by other API methods,\n+     * please use {@link #checkValidStateSlow()}.\n@@ -165,1 +188,9 @@\n-    public abstract void checkValidState();\n+    @ForceInline\n+    public final void checkValidState() {\n+        if (owner != null && owner != Thread.currentThread()) {\n+            throw new IllegalStateException(\"Attempted access outside owning thread\");\n+        }\n+        if (state < ALIVE) {\n+            throw ScopedAccessError.INSTANCE;\n+        }\n+    }\n@@ -173,1 +204,1 @@\n-        if (ownerThread() != null && Thread.currentThread() != ownerThread()) {\n+        if (owner != null && Thread.currentThread() != owner) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":39,"deletions":8,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -48,16 +48,0 @@\n-    private static final int ALIVE = 0;\n-    private static final int CLOSING = -1;\n-    private static final int CLOSED = -2;\n-\n-    private int state = ALIVE;\n-\n-    private static final VarHandle STATE;\n-\n-    static {\n-        try {\n-            STATE = MethodHandles.lookup().findVarHandle(jdk.internal.foreign.SharedScope.class, \"state\", int.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n@@ -65,13 +49,1 @@\n-        super(new SharedResourceList(), cleaner);\n-    }\n-\n-    @Override\n-    public Thread ownerThread() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void checkValidState() {\n-        if (state < ALIVE) {\n-            throw ScopedAccessError.INSTANCE;\n-        }\n+        super(null, new SharedResourceList(), cleaner);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-                assertTrue(ex.getCause().getMessage().contains(\"Already closed\"));\n+                assertTrue(ex.getCause().getMessage().contains(\"already closed\"));\n@@ -409,1 +409,1 @@\n-                assertTrue(ex.getMessage().contains(\"Already closed\"));\n+                assertTrue(ex.getMessage().contains(\"already closed\"));\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    MemorySegment nativeSegment, heapSegmentBytes, heapSegmentFloats;\n+    MemorySegment nativeSegment, nativeSharedSegment, heapSegmentBytes, heapSegmentFloats;\n@@ -76,0 +76,1 @@\n+        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newSharedScope());\n@@ -84,0 +85,2 @@\n+                nativeSharedSegment.setAtIndex(JAVA_INT, i, i);\n+                nativeSharedSegment.setAtIndex(JAVA_FLOAT, i, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}