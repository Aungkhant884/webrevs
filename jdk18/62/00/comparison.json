{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import jdk.jfr.internal.consumer.ParserState;\n@@ -64,0 +65,1 @@\n+    private final ParserState parserState = new ParserState();\n@@ -250,1 +252,1 @@\n-                chunkParser = new ChunkParser(input);\n+                chunkParser = new ChunkParser(input, parserState);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingFile.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    private volatile boolean closed;\n+    protected final ParserState parserState = new ParserState();\n@@ -218,2 +218,2 @@\n-    protected final void setClosed(boolean closed) {\n-        this.closed = closed;\n+    protected final void closeParser() {\n+        parserState.close();\n@@ -223,1 +223,1 @@\n-        return closed;\n+        return parserState.isClosed();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-\n+    private final ParserState parserState;\n@@ -108,1 +108,0 @@\n-    private volatile boolean closed;\n@@ -113,2 +112,2 @@\n-    public ChunkParser(RecordingInput input) throws IOException {\n-        this(input, new ParserConfiguration());\n+    public ChunkParser(RecordingInput input, ParserState ps) throws IOException {\n+        this(input, new ParserConfiguration(), ps);\n@@ -117,2 +116,2 @@\n-    ChunkParser(RecordingInput input, ParserConfiguration pc) throws IOException {\n-       this(new ChunkHeader(input), null, pc);\n+    ChunkParser(RecordingInput input, ParserConfiguration pc, ParserState ps) throws IOException {\n+       this(new ChunkHeader(input), null, pc, ps);\n@@ -121,2 +120,2 @@\n-    private ChunkParser(ChunkParser previous) throws IOException {\n-        this(new ChunkHeader(previous.input), previous, new ParserConfiguration());\n+    private ChunkParser(ChunkParser previous, ParserState ps) throws IOException {\n+        this(new ChunkHeader(previous.input), previous, new ParserConfiguration(), ps);\n@@ -125,1 +124,2 @@\n-    private ChunkParser(ChunkHeader header, ChunkParser previous, ParserConfiguration pc) throws IOException {\n+    private ChunkParser(ChunkHeader header, ChunkParser previous, ParserConfiguration pc, ParserState ps) throws IOException {\n+        this.parserState = ps;\n@@ -158,1 +158,1 @@\n-        return new ChunkParser(chunkHeader.nextHeader(), this, configuration);\n+        return new ChunkParser(chunkHeader.nextHeader(), this, configuration, parserState);\n@@ -283,1 +283,1 @@\n-            if (closed) {\n+            if (parserState.isClosed()) {\n@@ -440,1 +440,1 @@\n-        return new ChunkParser(this);\n+        return new ChunkParser(this, parserState);\n@@ -460,1 +460,1 @@\n-        this.closed = true;\n+        parserState.close();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        setClosed(true);\n+        closeParser();\n@@ -151,1 +151,1 @@\n-            currentParser = new ChunkParser(input, disp.parserConfiguration);\n+            currentParser = new ChunkParser(input, disp.parserConfiguration, parserState);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        setClosed(true);\n+        closeParser();\n@@ -88,1 +88,1 @@\n-        currentParser = new ChunkParser(input, disp.parserConfiguration);\n+        currentParser = new ChunkParser(input, disp.parserConfiguration, parserState);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventFileStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.consumer;\n+\n+public final class ParserState {\n+    private volatile boolean closed;\n+\n+    public boolean isClosed() {\n+        return closed;\n+    }\n+\n+    public void close() {\n+        closed = true;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ParserState.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}