{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,13 +138,27 @@\n-  if (next_node == NULL) {\n-    \/\/ A concurrent try_pop already claimed what was the last entry.  That\n-    \/\/ operation may not have cleared queue head yet, but we should still\n-    \/\/ treat the queue as empty until a push\/append operation changes head\n-    \/\/ to an entry with a non-NULL next value.\n-    *node_ptr = NULL;\n-    return true;\n-\n-  } else if (!is_end(next_node)) {\n-    \/\/ The next_node is not at the end of the queue's list.  Use the \"usual\"\n-    \/\/ lock-free pop from the head of a singly linked list to try to take it.\n-    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n-      \/\/ Former head successfully taken.\n+  if (!is_end(next_node)) {\n+    \/\/ [Clause 1]\n+    \/\/ Attempt to advance the list, moving next_node to the head and\n+    \/\/ shifting result out of the list.  There are several cases.\n+    \/\/ (1) next_node is the extension of the queue's list.\n+    \/\/ (2) next_node is NULL, because a competing try_pop took result.\n+    \/\/ (3) next_node is the extension of some unrelated list, because a\n+    \/\/ competing try_pop took result.\n+    \/\/ Cases (1) and (3) are distinguished by whether the advancement succeeds.\n+    if (result != Atomic::cmpxchg(&_head, result, next_node)) {\n+      \/\/ [Clause 1a]\n+      \/\/ The cmpxchg to advance the list failed; a concurrent try_pop won\n+      \/\/ the race.  There may further entries.\n+      return false;\n+    } else if (next_node == NULL) {\n+      \/\/ [Clause 1b]\n+      \/\/ The cmpxchg to advance the list succeeded, but a concurrent try_pop\n+      \/\/ has already claimed result (which was the last entry in the list)\n+      \/\/ by nulling result's next field.  The advance set _head to NULL,\n+      \/\/ \"helping\" the competing try_pop.  _head will remain NULL until a\n+      \/\/ subsequent push\/append.  This is a lost race, and we report it as\n+      \/\/ such for consistency, though we could report the queue was empty.\n+      return false;\n+    } else {\n+      \/\/ [Clause 1c]\n+      \/\/ Successfully advanced the list and claimed result.  Return the\n+      \/\/ result after unlinking it from the remainder of the list.\n@@ -154,3 +168,0 @@\n-    } else {\n-      \/\/ Lost race to take result from the head of the list.\n-      return false;\n@@ -159,1 +170,2 @@\n-  } else if (is_end(Atomic::cmpxchg(next_ptr(*result), end_marker(), (T*)NULL))) {\n+  } else if (is_end(Atomic::cmpxchg(next_ptr(*result), next_node, (T*)NULL))) {\n+    \/\/ [Clause 2]\n@@ -173,1 +185,2 @@\n-    \/\/ cmpxchg indicates a concurrent push\/append updated the head first.\n+    \/\/ cmpxchg indicates a concurrent operation updated _head first.  That\n+    \/\/ could be either a push\/extend or a try_pop in [Clause 1b].\n@@ -181,3 +194,4 @@\n-    \/\/ Result was the last entry in the list, but either a concurrent pop\n-    \/\/ claimed it first or a concurrent push\/append extended the list from\n-    \/\/ it.  Either way, we lost the race.\n+    \/\/ [Clause 3]\n+    \/\/ Result was the last entry in the list, but either a concurrent\n+    \/\/ try_pop claimed it first or a concurrent push\/append extended the\n+    \/\/ list from it.  Either way, we lost the race to claim it.\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":36,"deletions":22,"binary":false,"changes":58,"status":"modified"}]}