{"files":[{"patch":"@@ -2011,2 +2011,10 @@\n-  if (!cm_thread()->in_progress() || _has_aborted) {\n-    \/\/ We haven't started a concurrent cycle or we have already aborted it. No need to do anything.\n+  \/\/ We haven't started a concurrent cycle no need to do anything; we might have\n+  \/\/ aborted the marking because of shutting down though. In this case the marking\n+  \/\/ might have already completed the abort (leading to in_progress() below to\n+  \/\/ return false), however this still left marking state particularly in the\n+  \/\/ shared marking bitmap that must be cleaned up.\n+  \/\/ If there are multiple full gcs during shutdown we do this work repeatedly for\n+  \/\/ nothing, but this situation should be extremely rare (a full gc after shutdown\n+  \/\/ has been signalled is alredy rare), and this work should be negligible compared\n+  \/\/ to actual full gc work.\n+  if (!cm_thread()->in_progress() && !_g1h->concurrent_mark_is_terminating()) {\n@@ -2016,2 +2024,2 @@\n-  \/\/ Clear all marks in the next bitmap for the next marking cycle. This will allow us to skip the next\n-  \/\/ concurrent bitmap clearing.\n+  \/\/ Clear all marks in the next bitmap for this full gc as it has been used by the\n+  \/\/ marking that is interrupted by this full gc.\n@@ -2031,3 +2039,2 @@\n-  _first_overflow_barrier_sync.abort();\n-  _second_overflow_barrier_sync.abort();\n-  _has_aborted = true;\n+\n+  abort_marking_threads();\n@@ -2044,0 +2051,7 @@\n+void G1ConcurrentMark::abort_marking_threads() {\n+  assert(!_root_regions.scan_in_progress(), \"still doing root region scan\");\n+  _has_aborted = true;\n+  _first_overflow_barrier_sync.abort();\n+  _second_overflow_barrier_sync.abort();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -499,0 +499,5 @@\n+  \/\/ Notifies marking threads to abort. This is a best-effort notification. Does not\n+  \/\/ guarantee or update any state after the call. Root region scan must not be\n+  \/\/ running.\n+  void abort_marking_threads();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -162,0 +162,9 @@\n+  if (in_progress()) {\n+    \/\/ We are not allowed to abort the marking threads during root region scan.\n+    \/\/ Needs to be done separately.\n+    _cm->root_regions()->abort();\n+    _cm->root_regions()->wait_until_scan_finished();\n+\n+    _cm->abort_marking_threads();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}