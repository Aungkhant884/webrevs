{"files":[{"patch":"@@ -1498,1 +1498,9 @@\n-        assert(!n->is_Store() && !n->is_LoadStore(), \"no node with a side effect\");\n+        if (n->is_Store()) {\n+          \/\/ In some rare cases, a store could only have uses outside the loop. This happens, for example, if a single\n+          \/\/ inside the loop memory output node dies after loop peeling: A CastII node of a range check gets an updated\n+          \/\/ type from its iv input in IGVN which could be negative after peeling (e.g. init value of iv = i >= 0,\n+          \/\/ stride: x < -i). C2, however, is not able to remove the dead loop completely. This only leaves outside the\n+          \/\/ loop uses which eventually end in uncommon traps. Do not bother with these stores and bail out.\n+          return;\n+        }\n+        assert(!n->is_LoadStore(), \"no node with a side effect\");\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278420\n+ * @requires vm.compiler2.enabled\n+ * @summary Sinking a store node is not allowed and misses a bail out.\n+ * @run main\/othervm -Xbatch -XX:LoopMaxUnroll=0 -XX:-LoopUnswitching\n+ *                   -XX:CompileCommand=compileonly,compiler.loopopts.TestSinkingBadStore::* compiler.loopopts.TestSinkingBadStore\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.loopopts.TestSinkingBadStore::* compiler.loopopts.TestSinkingBadStore\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestSinkingBadStore {\n+    static int iArrFld2[];\n+    int iFld;\n+    int iArrFld1[];\n+\n+    public static void main(String[] args) {\n+        TestSinkingBadStore obj = new TestSinkingBadStore();\n+        obj.test();\n+        obj.test2();\n+    }\n+\n+    void test() {\n+        int x = 197, y = 3, innerLimit = 45;\n+        boolean b = false;\n+        long lArr[] = new long[10];\n+        for (int i = 4; i < 500000; i++) { \/\/ OSR-entry -> LoadI for innerLimit, unknown value\n+            \/\/ Mem Phi P1\n+\n+            \/\/ (1) Before loop opts: Memory phis P1-P3 in place\n+            \/\/ (2) After loop predication, peeling the inner loop and IGVN we have this structure:\n+            \/\/ Range check predicate P for iArrFld2[j = 1] (not folded because j >= 0)\n+            \/\/ Peeled iteration\n+            \/\/ Inner loop with corrected init value for j after peeling and IGVN:\n+            \/\/ for (j = -1; j > LoadI; j -= 2)\n+            \/\/ (3) The store iArrFld1[1] = 6 is tried to be sunk out of the loop in split-if because\n+            \/\/ it has only outside the loop uses which hits the assertion to forbid store nodes.\n+            for (int j = 1; j > innerLimit; j -= 2) {\n+                \/\/ Mem Phi P2: Merge iArrFld2[j] = 8 and P1\n+                if (x == 43) {\n+                    \/\/ Mem output for iArrFld1:\n+                    \/\/ In (1):\n+                    \/\/ - Outside loop: MergeMem for:\n+                    \/\/                 lArr null check, lArr[6] range check,\n+                    \/\/ - Inside loop:  P3\n+                    \/\/ In (2):\n+                    \/\/ - Outside loop: Phis merging peeled version and inner loop version of this store for:\n+                    \/\/                 lArr null check, lArr[6] range check,\n+                    \/\/ - Inside loop:  <none>\n+                    \/\/   P3 was removed because the type of the inner loop phi was updated to <=-1\n+                    \/\/   in IGVN due to peeling. This type info propagated to the CastII node of the\n+                    \/\/   address of the iArrFld2[j] = 8 store below whose type was 0..1 before. Since\n+                    \/\/   -1 is out of this range, the CastII is replaced by top. As a consequence,\n+                    \/\/   the store iArrFld2[j] = 8 is removed which lets P3 die (no output anymore).\n+                    iArrFld1[1] = 6;\n+                    lArr[6] = 5;\n+                } else {\n+                    y = 7;\n+                }\n+                \/\/ Mem Phi P3: Merge iArrFld1[1] = 6 and P2\n+                iArrFld2[j] = 8; \/\/ Invariant -> moved out with range check predicate P\n+                if (b) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Different test with same explanation..\n+    void test2() {\n+        int x = 197, y = 3, innerLimit = 45;\n+        boolean b = false;\n+        long lArr[] = new long[10];\n+        for (int i = 4; i < 100000; i++) {\n+            for (int j = 1; j > innerLimit; j -= 3) {\n+                switch (x) {\n+                    case 43:\n+                        iArrFld1[1] = 5;\n+                        lArr[2] = 6;\n+                    case 8:\n+                        y = 5;\n+                }\n+                iArrFld2[j] = iFld;\n+                if (b) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSinkingBadStore.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}