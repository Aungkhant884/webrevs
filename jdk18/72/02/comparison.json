{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.awt.geom.AffineTransform;\n@@ -481,0 +482,5 @@\n+        GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                .getDefaultScreenDevice().getDefaultConfiguration();\n+        gc = AccessibilityGraphicsEnvironment.getGraphicsConfigurationAtPoint(gc, x, y);\n+        x = AccessibilityGraphicsEnvironment.toUserSpaceX(gc, x);\n+        y = AccessibilityGraphicsEnvironment.toUserSpaceY(gc, y);\n@@ -1596,0 +1602,2 @@\n+\n+                                r = AccessibilityGraphicsEnvironment.toDeviceSpaceAbs(r);\n@@ -2260,0 +2268,1 @@\n+                            rect = AccessibilityGraphicsEnvironment.toDeviceSpaceAbs(rect);\n@@ -7341,0 +7350,117 @@\n+\n+    \/**\n+     * A helper class to handle coordinate conversion between screen and user spaces.\n+     * See {@link sun.java2d.SunGraphicsEnvironment}\n+     *\/\n+    private static abstract class AccessibilityGraphicsEnvironment extends GraphicsEnvironment {\n+        \/**\n+         * Returns the graphics configuration which bounds contain the given point.\n+         *\n+         * See {@link sun.java2d.SunGraphicsEnvironment#getGraphicsConfigurationAtPoint(GraphicsConfiguration, double, double)}\n+         *\n+         * @param  current the default configuration which is checked in the first\n+         *         place\n+         * @param  x the x coordinate of the given point\n+         * @param  y the y coordinate of the given point\n+         * @return the graphics configuration\n+         *\/\n+        public static GraphicsConfiguration getGraphicsConfigurationAtPoint(\n+                GraphicsConfiguration current, double x, double y) {\n+            if (current.getBounds().contains(x, y)) {\n+                return current;\n+            }\n+            GraphicsEnvironment env = getLocalGraphicsEnvironment();\n+            for (GraphicsDevice device : env.getScreenDevices()) {\n+                GraphicsConfiguration config = device.getDefaultConfiguration();\n+                Rectangle bounds = config.getBounds();\n+                bounds = toDeviceSpaceAbs(config, bounds.x, bounds.y, bounds.width, bounds.height);\n+                if (bounds.contains(x, y)) {\n+                    return config;\n+                }\n+            }\n+            return current;\n+        }\n+\n+        \/**\n+         * Converts absolute x coordinate from the device\n+         * space to the user's space using passed graphics configuration.\n+         *\n+         * @param  gc the graphics configuration to be used for transformation\n+         * @param  x absolute coordinate in the device's space\n+         * @return the corresponding x coordinate in user's space\n+         *\/\n+        public static int toUserSpaceX(GraphicsConfiguration gc, int x) {\n+            AffineTransform tx = gc.getDefaultTransform();\n+            Rectangle screen = gc.getBounds();\n+            return screen.x + clipRound((x - screen.x) \/ tx.getScaleX());\n+        }\n+\n+        \/**\n+         * Converts absolute y coordinate from the device\n+         * space to the user's space using passed graphics configuration.\n+         *\n+         * @param  gc the graphics configuration to be used for transformation\n+         * @param  y absolute coordinate in the device's space\n+         * @return the corresponding y coordinate in user's space\n+         *\/\n+        public static int toUserSpaceY(GraphicsConfiguration gc, int y) {\n+            AffineTransform tx = gc.getDefaultTransform();\n+            Rectangle screen = gc.getBounds();\n+            return screen.y + clipRound((y - screen.y) \/ tx.getScaleY());\n+        }\n+\n+        \/**\n+         * Converts the rectangle from the user's space to the device space using\n+         * appropriate device transformation.\n+         *\n+         * See {@link sun.java2d.SunGraphicsEnvironment#toDeviceSpaceAbs(Rectangle)}\n+         *\n+         * @param  rect the rectangle in the user's space\n+         * @return the rectangle which uses device space (pixels)\n+         *\/\n+        public static Rectangle toDeviceSpaceAbs(Rectangle rect) {\n+            GraphicsConfiguration gc = getLocalGraphicsEnvironment()\n+                    .getDefaultScreenDevice().getDefaultConfiguration();\n+            gc = getGraphicsConfigurationAtPoint(gc, rect.x, rect.y);\n+            return toDeviceSpaceAbs(gc, rect.x, rect.y, rect.width, rect.height);\n+        }\n+\n+        \/**\n+         * Converts absolute coordinates (x, y) and the size (w, h) from the user's\n+         * space to the device space using passed graphics configuration.\n+         *\n+         * See {@link sun.java2d.SunGraphicsEnvironment#toDeviceSpaceAbs(GraphicsConfiguration, int, int, int, int)}\n+         *\n+         * @param  gc the graphics configuration to be used for transformation\n+         * @param  x absolute coordinate in the user's space\n+         * @param  y absolute coordinate in the user's space\n+         * @param  w the width in the user's space\n+         * @param  h the height in the user's space\n+         * @return the rectangle which uses device space (pixels)\n+         *\/\n+        public static Rectangle toDeviceSpaceAbs(GraphicsConfiguration gc,\n+                                                 int x, int y, int w, int h) {\n+            AffineTransform tx = gc.getDefaultTransform();\n+            Rectangle screen = gc.getBounds();\n+            return new Rectangle(\n+                    screen.x + clipRound((x - screen.x) * tx.getScaleX()),\n+                    screen.y + clipRound((y - screen.y) * tx.getScaleY()),\n+                    clipRound(w * tx.getScaleX()),\n+                    clipRound(h * tx.getScaleY())\n+            );\n+        }\n+\n+        \/**\n+         * See {@link sun.java2d.pipe.Region#clipRound}\n+         *\/\n+        private static int clipRound(final double coordinate) {\n+            final double newv = coordinate - 0.5;\n+            if (newv < Integer.MIN_VALUE) {\n+                return Integer.MIN_VALUE;\n+            }\n+            if (newv > Integer.MAX_VALUE) {\n+                return Integer.MAX_VALUE;\n+            }\n+            return (int) Math.ceil(newv);\n+        }\n+    }\n","filename":"src\/jdk.accessibility\/windows\/classes\/com\/sun\/java\/accessibility\/internal\/AccessBridge.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"modified"}]}