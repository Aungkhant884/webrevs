{"files":[{"patch":"@@ -77,6 +77,2 @@\n-  if (list != nullptr) {\n-    \/\/ Add to existing list from the hash table:\n-    list->add(om);\n-    _om_count++;\n-  } else {\n-    \/\/ Create new list, add the ObjectMonitor* to it, and add the list to the hash table:\n+  if (list == nullptr) {\n+    \/\/ Create new list and add it to the hash table:\n@@ -84,2 +80,0 @@\n-    list->add(om);\n-    _om_count++;\n@@ -88,0 +82,2 @@\n+  list->add(om);  \/\/ Add the ObjectMonitor to the list.\n+  _om_count++;\n@@ -1033,0 +1029,3 @@\n+\/\/ Iterate ObjectMonitors where the owner == thread; this does NOT include\n+\/\/ ObjectMonitors where owner is set to a stack lock address in thread.\n+\/\/\n@@ -1040,0 +1039,2 @@\n+      \/\/ Not owned by the target thread and intentionally skips when owner\n+      \/\/ is set to a stack lock address in the target thread.\n@@ -1062,1 +1063,1 @@\n-  ObjectMonitorIterator iter = ObjectMonitorIterator(list->head());\n+  ObjectMonitorIterator iter(list->head());\n@@ -1065,0 +1066,1 @@\n+    \/\/ Owner set to a stack lock address in thread should never be seen here:\n@@ -1405,0 +1407,8 @@\n+\/\/\n+\/\/ If table != nullptr, we gather owned ObjectMonitors indexed by the\n+\/\/ owner in the table. Please note that ObjectMonitors where the owner\n+\/\/ is set to a stack lock address are NOT associated with the JavaThread\n+\/\/ that holds that stack lock. All of the current consumers of\n+\/\/ ObjectMonitorsHashtable info only care about JNI locked monitors and\n+\/\/ those do not have the owner set to a stack lock address.\n+\/\/\n@@ -1419,4 +1429,4 @@\n-      \/\/ The caller is interested in the owned ObjectMonitors. This does not capture\n-      \/\/ unowned ObjectMonitors that cannot be deflated because of a waiter. Since\n-      \/\/ deflate_idle_monitors() and deflate_monitor_list() can be called more than\n-      \/\/ once, we have to make sure the entry has not already been added.\n+      \/\/ The caller is interested in the owned ObjectMonitors. This does\n+      \/\/ not include when owner is set to a stack lock address in thread.\n+      \/\/ This also does not capture unowned ObjectMonitors that cannot be\n+      \/\/ deflated because of a waiter.\n@@ -1424,0 +1434,3 @@\n+      \/\/ Since deflate_idle_monitors() and deflate_monitor_list() can be\n+      \/\/ called more than once, we have to make sure the entry has not\n+      \/\/ already been added.\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -193,0 +193,4 @@\n+\n+  \/\/ Iterate ObjectMonitors where the owner == thread; this does NOT include\n+  \/\/ ObjectMonitors where owner is set to a stack lock address in thread:\n+  \/\/\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -686,1 +686,1 @@\n-    \/\/ and not found in the stack:\n+    \/\/ that are not found in the stack, e.g. JNI locked monitors:\n@@ -689,1 +689,3 @@\n-      \/\/ Get the ObjectMonitors locked by this thread (if any):\n+      \/\/ Get the ObjectMonitors locked by the target thread, if any,\n+      \/\/ and does not include any where owner is set to a stack lock\n+      \/\/ address in the target thread:\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}