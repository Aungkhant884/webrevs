{"files":[{"patch":"@@ -36,1 +36,1 @@\n- * A memory address models a reference into a memory location. Memory addresses are typically obtained in onw of the following ways:\n+ * A memory address models a reference into a memory location. Memory addresses are typically obtained in one of the following ways:\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-     * Reads the next value as an {@code int} and advances this variable argument list's position.\n+     * Reads the next value as an {@code int} and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function.\n@@ -72,1 +73,2 @@\n-     * Reads the next value as a {@code long} and advances this variable argument list's position.\n+     * Reads the next value as a {@code long} and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function.\n@@ -82,1 +84,2 @@\n-     * Reads the next value as a {@code double} and advances this variable argument list's position.\n+     * Reads the next value as a {@code double} and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function.\n@@ -92,1 +95,2 @@\n-     * Reads the next value as a {@code MemoryAddress} and advances this variable argument list's position.\n+     * Reads the next value as a {@code MemoryAddress} and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function.\n@@ -102,1 +106,7 @@\n-     * Reads the next value as a {@code MemorySegment}, and advances this variable argument list's position.\n+     * Reads the next value as a {@code MemorySegment}, and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function. The provided group layout must correspond to a C struct or union\n+     * type.\n+     * <p>\n+     * How the value is read in the returned segment is ABI-dependent: calling this method on a group layout\n+     * with member layouts {@code L_1, L_2, ... L_n} is not guaranteed to be semantically equivalent to perform distinct\n+     * calls to {@code nextVarg} for each of the layouts in {@code L_1, L_2, ... L_n}.\n@@ -132,3 +142,6 @@\n-     * with the same scope as this variable argument list. Copying is useful to\n-     * traverse the variable argument list elements, starting from the current position, without affecting the state\n-     * of the original variable argument list, essentially allowing the elements to be traversed multiple times.\n+     * with the same scope as this variable argument list. The behavior of this method is equivalent to the C\n+     * {@code va_copy} function.\n+     * <p>\n+     * Copying is useful to traverse the variable argument list elements, starting from the current position,\n+     * without affecting the state of the original variable argument list, essentially allowing the elements to be\n+     * traversed multiple times.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"}]}