{"files":[{"patch":"@@ -58,1 +58,1 @@\n- * The Java {@link java.lang.invoke.MethodType method type} associated with the returned method handle is\n+ * The Java {@linkplain java.lang.invoke.MethodType method type} associated with the returned method handle is\n@@ -72,1 +72,2 @@\n- * The downcall method handle type, derived as above, might be decorated by additional leading parameters:\n+ * The downcall method handle type, derived as above, might be decorated by additional leading parameters,\n+ * in the given order if both are present:\n@@ -94,1 +95,1 @@\n- * The type of the provided method handle has to match the Java {@link java.lang.invoke.MethodType method type}\n+ * The type of the provided method handle has to match the Java {@linkplain java.lang.invoke.MethodType method type}\n@@ -112,1 +113,1 @@\n- * This class implements the {@link SymbolLookup} interface; as such clients can {@linkplain #lookup(String) lookup} symbols\n+ * This class implements the {@link SymbolLookup} interface; as such clients can {@linkplain #lookup(String) look up} symbols\n@@ -166,1 +167,1 @@\n-     * Lookup a symbol in the standard libraries associated with this linker.\n+     * Look up a symbol in the standard libraries associated with this linker.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -35,1 +36,1 @@\n- * A memory address models a reference into a memory location. Memory addresses are typically obtained in three ways:\n+ * A memory address models a reference into a memory location. Memory addresses are typically obtained in one of the following ways:\n@@ -40,0 +41,1 @@\n+ *     <li>By the invocation of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub} which accepts a pointer.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n- * operations on a segment cannot occur after the resource scope associated with a memory segment has been closed (see {@link ResourceScope#close()}).\n+ * operations on a segment cannot occur <em>after<\/em> the resource scope associated with a memory segment has been closed (see {@link ResourceScope#close()}).\n@@ -160,1 +160,1 @@\n- * and can be considered as <em>always alive<\/em>.\n+ * and segments associated with it can be considered as <em>always alive<\/em>.\n@@ -220,2 +220,2 @@\n-     * this segment. As such, splitting is possible as long as {@code S\/N >= 2}. The spliterator returns segments that feature the same\n-     * scope as this given segment.\n+     * this segment. As such, splitting is possible as long as {@code S\/N >= 2}. The spliterator returns segments that\n+     * are associated with the same scope as this segment.\n@@ -223,2 +223,2 @@\n-     * The returned spliterator effectively allows to slice this segment into disjoint sub-segments, which can then\n-     * be processed in parallel by multiple threads.\n+     * The returned spliterator effectively allows to slice this segment into disjoint {@linkplain #asSlice(long, long) slices},\n+     * which can then be processed in parallel by multiple threads.\n@@ -682,1 +682,1 @@\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -693,1 +693,1 @@\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -704,1 +704,1 @@\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -715,1 +715,1 @@\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -726,1 +726,1 @@\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -737,1 +737,1 @@\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -748,1 +748,1 @@\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * The returned segment is associated with the {@linkplain ResourceScope#globalScope() global} resource scope.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -459,1 +459,0 @@\n-     * ResourceScope scope = ...\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-     * Reads the next value as an {@code int} and advances this variable argument list's position.\n+     * Reads the next value as an {@code int} and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function.\n@@ -72,1 +73,2 @@\n-     * Reads the next value as a {@code long} and advances this variable argument list's position.\n+     * Reads the next value as a {@code long} and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function.\n@@ -82,1 +84,2 @@\n-     * Reads the next value as a {@code double} and advances this variable argument list's position.\n+     * Reads the next value as a {@code double} and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function.\n@@ -92,1 +95,2 @@\n-     * Reads the next value as a {@code MemoryAddress} and advances this variable argument list's position.\n+     * Reads the next value as a {@code MemoryAddress} and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function.\n@@ -102,1 +106,7 @@\n-     * Reads the next value as a {@code MemorySegment}, and advances this variable argument list's position.\n+     * Reads the next value as a {@code MemorySegment}, and advances this variable argument list's position. The behavior of this\n+     * method is equivalent to the C {@code va_arg} function. The provided group layout must correspond to a C struct or union\n+     * type.\n+     * <p>\n+     * How the value is read in the returned segment is ABI-dependent: calling this method on a group layout\n+     * with member layouts {@code L_1, L_2, ... L_n} is not guaranteed to be semantically equivalent to perform distinct\n+     * calls to {@code nextVarg} for each of the layouts in {@code L_1, L_2, ... L_n}.\n@@ -132,3 +142,6 @@\n-     * with the same scope as this variable argument list. Copying is useful to\n-     * traverse the variable argument list elements, starting from the current position, without affecting the state\n-     * of the original variable argument list, essentially allowing the elements to be traversed multiple times.\n+     * with the same scope as this variable argument list. The behavior of this method is equivalent to the C\n+     * {@code va_copy} function.\n+     * <p>\n+     * Copying is useful to traverse the variable argument list elements, starting from the current position,\n+     * without affecting the state of the original variable argument list, essentially allowing the elements to be\n+     * traversed multiple times.\n@@ -190,2 +203,2 @@\n-     * @throws IllegalStateException if the scope associated with {@code allocator} has been already closed,\n-     * or if access occurs from a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, a {@linkplain ByteOrder byte order})\n+ * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, an alignment, a {@linkplain ByteOrder byte order})\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n- * the access coordinates are validated (upon access), to make sure that access does not occur at an address which resides\n+ * the access coordinates are validated (upon access), to make sure that access does not occur at any address which resides\n@@ -102,1 +102,1 @@\n- * The first is used to lookup symbols inside native libraries; the second is used to model native addresses (more on that later),\n+ * The first is used to look up symbols inside native libraries; the second is used to model native addresses (more on that later),\n@@ -105,1 +105,1 @@\n- * code (as it's the case with the <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">Java Native Interface (JNI)<\/a>).\n+ * code (as is the case with the <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">Java Native Interface (JNI)<\/a>).\n@@ -125,1 +125,1 @@\n- * to {@linkplain jdk.incubator.foreign.CLinker#lookup(java.lang.String) lookup} the {@code strlen} symbol in the\n+ * to {@linkplain jdk.incubator.foreign.CLinker#lookup(java.lang.String) look up} the {@code strlen} symbol in the\n@@ -141,3 +141,3 @@\n- * are fully known at segment creation. But when interacting with native libraries, clients will often receive <em>raw<\/em> pointers;\n- * such pointers have no spatial bounds (example: does the C type {@code char*} refer to a single {@code char} value,\n- * or an array of {@code char} values, of given size?), no notion of temporal bounds, nor thread-confinement.\n+ * are fully known at segment creation. But when interacting with native libraries, clients will often receive <em>raw<\/em> pointers.\n+ * Such pointers have no spatial bounds. For example, the C type {@code char*} can refer to a single {@code char} value,\n+ * or an array of {@code char} values, of given size. Nor do said pointers have any notion of temporal bounds or thread-confinement.\n@@ -170,1 +170,1 @@\n- * The {@link jdk.incubator.foreign.CLinker} interface also allows to turn an existing method handle (which might point\n+ * The {@link jdk.incubator.foreign.CLinker} interface also allows clients to turn an existing method handle (which might point\n@@ -196,1 +196,1 @@\n- * that can be used to lookup the method handle for {@code IntComparator.intCompare}.\n+ * that can be used to look up the method handle for {@code IntComparator.intCompare}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}