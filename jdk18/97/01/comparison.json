{"files":[{"patch":"@@ -269,1 +269,1 @@\n-     * approximately {@code S\/N\/2} elements (depending on whether N is even or not), where {@code S} is the size of\n+     * approximately {@code S\/N} elements (depending on whether N is even or not), where {@code S} is the size of\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * Implementation for heap memory segments. An heap memory segment is composed by an offset and\n+ * Implementation for heap memory segments. A heap memory segment is composed by an offset and\n@@ -43,1 +43,5 @@\n- * {@link HeapMemorySegmentImpl#base()} method so that it returns an array of the correct (sharp) type.\n+ * {@link HeapMemorySegmentImpl#base()} method so that it returns an array of the correct (sharp) type. Note that\n+ * the field type storing the 'base' coordinate is just Object; similarly, all the constructor in the subclasses\n+ * accept an Object 'base' parameter instead of a sharper type (e.g. {@code byte[]}). This is deliberate, as\n+ * using sharper types would require use of type-conversions, which in turn would inhibit some C2 optimizations,\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, int, ResourceScopeImpl)}.\n@@ -45,1 +49,1 @@\n-public abstract class HeapMemorySegmentImpl<H> extends AbstractMemorySegmentImpl {\n+public abstract class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n@@ -56,1 +60,1 @@\n-    final H base;\n+    final Object base;\n@@ -59,1 +63,1 @@\n-    HeapMemorySegmentImpl(long offset, H base, long length, int mask) {\n+    HeapMemorySegmentImpl(long offset, Object base, long length, int mask) {\n@@ -66,1 +70,1 @@\n-    abstract H base();\n+    abstract Object base();\n@@ -74,1 +78,1 @@\n-    abstract HeapMemorySegmentImpl<H> dup(long offset, long size, int mask, ResourceScopeImpl scope);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope);\n@@ -87,1 +91,1 @@\n-    public static class OfByte extends HeapMemorySegmentImpl<byte[]> {\n+    public static class OfByte extends HeapMemorySegmentImpl {\n@@ -89,1 +93,1 @@\n-        OfByte(long offset, byte[] base, long length, int mask) {\n+        OfByte(long offset, Object base, long length, int mask) {\n@@ -100,1 +104,1 @@\n-            return Objects.requireNonNull(base);\n+            return (byte[])Objects.requireNonNull(base);\n@@ -115,1 +119,1 @@\n-    public static class OfChar extends HeapMemorySegmentImpl<char[]> {\n+    public static class OfChar extends HeapMemorySegmentImpl {\n@@ -117,1 +121,1 @@\n-        OfChar(long offset, char[] base, long length, int mask) {\n+        OfChar(long offset, Object base, long length, int mask) {\n@@ -128,1 +132,1 @@\n-            return Objects.requireNonNull(base);\n+            return (char[])Objects.requireNonNull(base);\n@@ -143,1 +147,1 @@\n-    public static class OfShort extends HeapMemorySegmentImpl<short[]> {\n+    public static class OfShort extends HeapMemorySegmentImpl {\n@@ -145,1 +149,1 @@\n-        OfShort(long offset, short[] base, long length, int mask) {\n+        OfShort(long offset, Object base, long length, int mask) {\n@@ -156,1 +160,1 @@\n-            return Objects.requireNonNull(base);\n+            return (short[])Objects.requireNonNull(base);\n@@ -171,1 +175,1 @@\n-    public static class OfInt extends HeapMemorySegmentImpl<int[]> {\n+    public static class OfInt extends HeapMemorySegmentImpl {\n@@ -173,1 +177,1 @@\n-        OfInt(long offset, int[] base, long length, int mask) {\n+        OfInt(long offset, Object base, long length, int mask) {\n@@ -184,1 +188,1 @@\n-            return Objects.requireNonNull(base);\n+            return (int[])Objects.requireNonNull(base);\n@@ -199,1 +203,1 @@\n-    public static class OfLong extends HeapMemorySegmentImpl<long[]> {\n+    public static class OfLong extends HeapMemorySegmentImpl {\n@@ -201,1 +205,1 @@\n-        OfLong(long offset, long[] base, long length, int mask) {\n+        OfLong(long offset, Object base, long length, int mask) {\n@@ -212,1 +216,1 @@\n-            return Objects.requireNonNull(base);\n+            return (long[])Objects.requireNonNull(base);\n@@ -227,1 +231,1 @@\n-    public static class OfFloat extends HeapMemorySegmentImpl<float[]> {\n+    public static class OfFloat extends HeapMemorySegmentImpl {\n@@ -229,1 +233,1 @@\n-        OfFloat(long offset, float[] base, long length, int mask) {\n+        OfFloat(long offset, Object base, long length, int mask) {\n@@ -240,1 +244,1 @@\n-            return Objects.requireNonNull(base);\n+            return (float[])Objects.requireNonNull(base);\n@@ -255,1 +259,1 @@\n-    public static class OfDouble extends HeapMemorySegmentImpl<double[]> {\n+    public static class OfDouble extends HeapMemorySegmentImpl {\n@@ -257,1 +261,1 @@\n-        OfDouble(long offset, double[] base, long length, int mask) {\n+        OfDouble(long offset, Object base, long length, int mask) {\n@@ -268,1 +272,1 @@\n-            return Objects.requireNonNull(base);\n+            return (double[])Objects.requireNonNull(base);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+\n+public class LoopOverSlice {\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n+\n+    MemorySegment nativeSegment, heapSegment;\n+    ResourceScope scope;\n+\n+    @Setup\n+    public void setup() {\n+        scope = ResourceScope.newConfinedScope();\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, scope);\n+        heapSegment = MemorySegment.ofArray(new float[ELEM_SIZE]);\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n+    @Benchmark\n+    public void native_slice_loop() {\n+        new NativeWrapper(nativeSegment).forEach(NativeWrapper.Element::get);\n+    }\n+\n+    @Benchmark\n+    public void heap_slice_loop() {\n+        new HeapWrapper(heapSegment).forEach(HeapWrapper.Element::get);\n+    }\n+\n+    class HeapWrapper implements Iterable<HeapWrapper.Element> {\n+        final MemorySegment segment;\n+\n+        public HeapWrapper(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public Iterator<Element> iterator() {\n+            return new Iterator<Element>() {\n+\n+                MemorySegment current = segment;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return current.byteSize() > 4;\n+                }\n+\n+                @Override\n+                public Element next() {\n+                    Element element = new Element(current);\n+                    current = current.asSlice(4);\n+                    return element;\n+                }\n+            };\n+        }\n+\n+        static class Element {\n+            final MemorySegment segment;\n+\n+            public Element(MemorySegment segment) {\n+                this.segment = segment;\n+            }\n+\n+            int get() {\n+                return segment.getAtIndex(JAVA_INT, 0);\n+            }\n+        }\n+    }\n+\n+    class NativeWrapper implements Iterable<NativeWrapper.Element> {\n+        final MemorySegment segment;\n+\n+        public NativeWrapper(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        int get() {\n+            return segment.getAtIndex(JAVA_INT, 0);\n+        }\n+\n+        @Override\n+        public Iterator<Element> iterator() {\n+            return new Iterator<Element>() {\n+\n+                MemorySegment current = segment;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return current.byteSize() > 4;\n+                }\n+\n+                @Override\n+                public Element next() {\n+                    Element element = new Element(current);\n+                    current = current.asSlice(4);\n+                    return element;\n+                }\n+            };\n+        }\n+\n+        static class Element {\n+            final MemorySegment segment;\n+\n+            public Element(MemorySegment segment) {\n+                this.segment = segment;\n+            }\n+\n+            int get() {\n+                return segment.getAtIndex(JAVA_INT, 0);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverSlice.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"}]}