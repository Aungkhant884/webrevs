{"files":[{"patch":"@@ -58,3 +58,0 @@\n-  \/\/ No support for 48 extra htbl entries in aes-gcm intrinsic\n-  static const int htbl_entries = 0;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3097,2 +3097,1 @@\n-  \/\/ subkeyHtbl_48_entries = c_rarg7 (not used)\n-  \/\/ counter = [sp, #0] pointer to 16 bytes of CTR\n+  \/\/ counter = c_rarg7 - 16 bytes of CTR\n@@ -3124,2 +3123,0 @@\n-    \/\/ Pointer to CTR is passed on the stack before the (fp, lr) pair.\n-    const Address counter_mem(sp, 2 * wordSize);\n@@ -3127,1 +3124,0 @@\n-    __ ldr(counter, counter_mem);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,3 +59,0 @@\n-  \/\/ No support for 48 extra htbl entries in aes-gcm intrinsic\n-  static const int htbl_entries = -1;\n-\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,3 +60,0 @@\n-  \/\/ No support for 48 extra htbl entries in aes-gcm intrinsic\n-  static const int htbl_entries = -1;\n-\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,3 +60,0 @@\n-  \/\/ No support for 48 extra htbl entries in aes-gcm intrinsic\n-  static const int htbl_entries = -1;\n-\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -151,2 +151,0 @@\n-  \/\/ Number of htbl entries for aes-gcm intrinsic\n-  static const int htbl_entries = 96;\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4417,1 +4417,0 @@\n-    const Address avx512_subkeyH_mem(rbp, 3 * wordSize);\n@@ -4419,1 +4418,1 @@\n-    const Address counter_mem(rbp, 4 * wordSize);\n+    const Address counter_mem(rbp, 3 * wordSize);\n@@ -4428,1 +4427,0 @@\n-    const Address avx512_subkeyH_mem(rbp, 9 * wordSize);\n@@ -4430,1 +4428,1 @@\n-    const Address counter_mem(rbp, 10 * wordSize);\n+    const Address counter_mem(rbp, 9 * wordSize);\n@@ -4446,0 +4444,1 @@\n+    __ subptr(rsp, 96 * longSize); \/\/ Create space on the stack for htbl entries\n@@ -4447,1 +4446,1 @@\n-    __ movptr(avx512_subkeyHtbl, avx512_subkeyH_mem);\n+    __ movptr(avx512_subkeyHtbl, rsp);\n@@ -4452,0 +4451,2 @@\n+    __ addptr(rsp, 96 * longSize);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2491,2 +2491,1 @@\n-                                  Node* parm6, Node* parm7,\n-                                  Node* parm8) {\n+                                  Node* parm6, Node* parm7) {\n@@ -2539,2 +2538,1 @@\n-  if (parm8 != NULL) { call->init_req(TypeFunc::Parms+8, parm8);\n-  \/* close each nested if ===> *\/  } } } } } } } } }\n+  \/* close each nested if ===> *\/  } } } } } } } }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -805,2 +805,1 @@\n-                          Node* parm6 = NULL, Node* parm7 = NULL,\n-                          Node* parm8 = NULL);\n+                          Node* parm6 = NULL, Node* parm7 = NULL);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6766,10 +6766,21 @@\n-  \/\/ (1) in, ct and out are arrays.\n-  const Type* in_type = in->Value(&_gvn);\n-  const Type* ct_type = ct->Value(&_gvn);\n-  const Type* out_type = out->Value(&_gvn);\n-  const TypeAryPtr* top_in = in_type->isa_aryptr();\n-  const TypeAryPtr* top_ct = ct_type->isa_aryptr();\n-  const TypeAryPtr* top_out = out_type->isa_aryptr();\n-  assert(top_in != NULL && top_in->klass() != NULL &&\n-         top_ct != NULL && top_ct->klass() != NULL &&\n-         top_out != NULL && top_out->klass() != NULL, \"args are strange\");\n+    \/\/ (1) in, ct and out are arrays.\n+    const Type* in_type = in->Value(&_gvn);\n+    const Type* ct_type = ct->Value(&_gvn);\n+    const Type* out_type = out->Value(&_gvn);\n+    const TypeAryPtr* top_in = in_type->isa_aryptr();\n+    const TypeAryPtr* top_ct = ct_type->isa_aryptr();\n+    const TypeAryPtr* top_out = out_type->isa_aryptr();\n+    assert(top_in != NULL && top_in->klass() != NULL &&\n+           top_ct != NULL && top_ct->klass() != NULL &&\n+           top_out != NULL && top_out->klass() != NULL, \"args are strange\");\n+\n+    \/\/ checks are the responsibility of the caller\n+    Node* in_start = in;\n+    Node* ct_start = ct;\n+    Node* out_start = out;\n+    if (inOfs != NULL || ctOfs != NULL || outOfs != NULL) {\n+      assert(inOfs != NULL && ctOfs != NULL && outOfs != NULL, \"\");\n+      in_start = array_element_address(in, inOfs, T_BYTE);\n+      ct_start = array_element_address(ct, ctOfs, T_BYTE);\n+      out_start = array_element_address(out, outOfs, T_BYTE);\n+    }\n@@ -6777,10 +6788,8 @@\n-  \/\/ checks are the responsibility of the caller\n-  Node* in_start = in;\n-  Node* ct_start = ct;\n-  Node* out_start = out;\n-  if (inOfs != NULL || ctOfs != NULL || outOfs != NULL) {\n-    assert(inOfs != NULL && ctOfs != NULL && outOfs != NULL, \"\");\n-    in_start = array_element_address(in, inOfs, T_BYTE);\n-    ct_start = array_element_address(ct, ctOfs, T_BYTE);\n-    out_start = array_element_address(out, outOfs, T_BYTE);\n-  }\n+    \/\/ if we are in this set of code, we \"know\" the embeddedCipher is an AESCrypt object\n+    \/\/ (because of the predicated logic executed earlier).\n+    \/\/ so we cast it here safely.\n+    \/\/ this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java\n+    Node* embeddedCipherObj = load_field_from_object(gctr_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n+    Node* counter = load_field_from_object(gctr_object, \"counter\", \"[B\");\n+    Node* subkeyHtbl = load_field_from_object(ghash_object, \"subkeyHtbl\", \"[J\");\n+    Node* state = load_field_from_object(ghash_object, \"state\", \"[J\");\n@@ -6788,48 +6797,29 @@\n-  \/\/ if we are in this set of code, we \"know\" the embeddedCipher is an AESCrypt object\n-  \/\/ (because of the predicated logic executed earlier).\n-  \/\/ so we cast it here safely.\n-  \/\/ this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java\n-  Node* embeddedCipherObj = load_field_from_object(gctr_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n-  Node* counter = load_field_from_object(gctr_object, \"counter\", \"[B\");\n-  Node* subkeyHtbl = load_field_from_object(ghash_object, \"subkeyHtbl\", \"[J\");\n-  Node* state = load_field_from_object(ghash_object, \"state\", \"[J\");\n-\n-  if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n-      return false;\n-  }\n-  \/\/ cast it to what we know it will be at runtime\n-  const TypeInstPtr* tinst = _gvn.type(gctr_object)->isa_instptr();\n-  assert(tinst != NULL, \"GCTR obj is null\");\n-  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n-  assert(klass_AESCrypt->is_loaded(), \"predicate checks that this class is loaded\");\n-  ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n-  const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);\n-  const TypeOopPtr* xtype = aklass->as_instance_type();\n-  Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);\n-  aescrypt_object = _gvn.transform(aescrypt_object);\n-  \/\/ we need to get the start of the aescrypt_object's expanded key array\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n-  if (k_start == NULL) return false;\n-\n-  \/\/ similarly, get the start address of the r vector\n-  Node* cnt_start = array_element_address(counter, intcon(0), T_BYTE);\n-  Node* state_start = array_element_address(state, intcon(0), T_LONG);\n-  Node* subkeyHtbl_start = array_element_address(subkeyHtbl, intcon(0), T_LONG);\n-\n-  ciKlass* klass = ciTypeArrayKlass::make(T_LONG);\n-  Node* klass_node = makecon(TypeKlassPtr::make(klass));\n-\n-  \/\/ Does this target support this intrinsic?\n-  if (Matcher::htbl_entries == -1) return false;\n-\n-  Node* subkeyHtbl_48_entries_start;\n-  if (Matcher::htbl_entries != 0) {\n-    \/\/ new array to hold 48 computed htbl entries\n-    Node* subkeyHtbl_48_entries = new_array(klass_node, intcon(Matcher::htbl_entries), 0);\n-    if (subkeyHtbl_48_entries == NULL) return false;\n-    subkeyHtbl_48_entries_start = array_element_address(subkeyHtbl_48_entries, intcon(0), T_LONG);\n-  } else {\n-    \/\/ This target doesn't need the extra-large Htbl.\n-    subkeyHtbl_48_entries_start = ConvL2X(intcon(0));\n-  }\n+    if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n+        return false;\n+    }\n+    \/\/ cast it to what we know it will be at runtime\n+    const TypeInstPtr* tinst = _gvn.type(gctr_object)->isa_instptr();\n+    assert(tinst != NULL, \"GCTR obj is null\");\n+    assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n+    ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+    assert(klass_AESCrypt->is_loaded(), \"predicate checks that this class is loaded\");\n+    ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n+    const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);\n+    const TypeOopPtr* xtype = aklass->as_instance_type();\n+    Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);\n+    aescrypt_object = _gvn.transform(aescrypt_object);\n+    \/\/ we need to get the start of the aescrypt_object's expanded key array\n+    Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+    if (k_start == NULL) return false;\n+\n+    \/\/ similarly, get the start address of the r vector\n+    Node* cnt_start = array_element_address(counter, intcon(0), T_BYTE);\n+    Node* state_start = array_element_address(state, intcon(0), T_LONG);\n+    Node* subkeyHtbl_start = array_element_address(subkeyHtbl, intcon(0), T_LONG);\n+\n+\n+    \/\/ Call the stub, passing params\n+    Node* gcmCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                 OptoRuntime::galoisCounterMode_aescrypt_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, cnt_start);\n@@ -6837,5 +6827,3 @@\n-  \/\/ Call the stub, passing params\n-  Node* gcmCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n-                               OptoRuntime::galoisCounterMode_aescrypt_Type(),\n-                               stubAddr, stubName, TypePtr::BOTTOM,\n-                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, subkeyHtbl_48_entries_start, cnt_start);\n+    \/\/ return cipher length (int)\n+    Node* retvalue = _gvn.transform(new ProjNode(gcmCrypt, TypeFunc::Parms));\n+    set_result(retvalue);\n@@ -6843,3 +6831,0 @@\n-  \/\/ return cipher length (int)\n-  Node* retvalue = _gvn.transform(new ProjNode(gcmCrypt, TypeFunc::Parms));\n-  set_result(retvalue);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":61,"deletions":76,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -961,1 +961,1 @@\n-  int num_args = 9;\n+  int num_args = 8;\n@@ -972,1 +972,0 @@\n-  fields[argp++] = TypePtr::NOTNULL; \/\/ long[] avx512_subkeyHtbl newly created\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-compiler\/codegen\/aes\/TestAESMain.java 8274323 linux-x64,windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}