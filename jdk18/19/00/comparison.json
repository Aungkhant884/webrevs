{"files":[{"patch":"@@ -6766,10 +6766,4 @@\n-  \/\/ (1) in, ct and out are arrays.\n-  const Type* in_type = in->Value(&_gvn);\n-  const Type* ct_type = ct->Value(&_gvn);\n-  const Type* out_type = out->Value(&_gvn);\n-  const TypeAryPtr* top_in = in_type->isa_aryptr();\n-  const TypeAryPtr* top_ct = ct_type->isa_aryptr();\n-  const TypeAryPtr* top_out = out_type->isa_aryptr();\n-  assert(top_in != NULL && top_in->klass() != NULL &&\n-         top_ct != NULL && top_ct->klass() != NULL &&\n-         top_out != NULL && top_out->klass() != NULL, \"args are strange\");\n+  \/\/ Set the original stack and the reexecute bit for the interpreter to reexecute\n+  \/\/ implGCMCrypt0 if deoptimization happens.\n+  { PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n@@ -6777,10 +6771,21 @@\n-  \/\/ checks are the responsibility of the caller\n-  Node* in_start = in;\n-  Node* ct_start = ct;\n-  Node* out_start = out;\n-  if (inOfs != NULL || ctOfs != NULL || outOfs != NULL) {\n-    assert(inOfs != NULL && ctOfs != NULL && outOfs != NULL, \"\");\n-    in_start = array_element_address(in, inOfs, T_BYTE);\n-    ct_start = array_element_address(ct, ctOfs, T_BYTE);\n-    out_start = array_element_address(out, outOfs, T_BYTE);\n-  }\n+    \/\/ (1) in, ct and out are arrays.\n+    const Type* in_type = in->Value(&_gvn);\n+    const Type* ct_type = ct->Value(&_gvn);\n+    const Type* out_type = out->Value(&_gvn);\n+    const TypeAryPtr* top_in = in_type->isa_aryptr();\n+    const TypeAryPtr* top_ct = ct_type->isa_aryptr();\n+    const TypeAryPtr* top_out = out_type->isa_aryptr();\n+    assert(top_in != NULL && top_in->klass() != NULL &&\n+           top_ct != NULL && top_ct->klass() != NULL &&\n+           top_out != NULL && top_out->klass() != NULL, \"args are strange\");\n+\n+    \/\/ checks are the responsibility of the caller\n+    Node* in_start = in;\n+    Node* ct_start = ct;\n+    Node* out_start = out;\n+    if (inOfs != NULL || ctOfs != NULL || outOfs != NULL) {\n+      assert(inOfs != NULL && ctOfs != NULL && outOfs != NULL, \"\");\n+      in_start = array_element_address(in, inOfs, T_BYTE);\n+      ct_start = array_element_address(ct, ctOfs, T_BYTE);\n+      out_start = array_element_address(out, outOfs, T_BYTE);\n+    }\n@@ -6788,8 +6793,8 @@\n-  \/\/ if we are in this set of code, we \"know\" the embeddedCipher is an AESCrypt object\n-  \/\/ (because of the predicated logic executed earlier).\n-  \/\/ so we cast it here safely.\n-  \/\/ this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java\n-  Node* embeddedCipherObj = load_field_from_object(gctr_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n-  Node* counter = load_field_from_object(gctr_object, \"counter\", \"[B\");\n-  Node* subkeyHtbl = load_field_from_object(ghash_object, \"subkeyHtbl\", \"[J\");\n-  Node* state = load_field_from_object(ghash_object, \"state\", \"[J\");\n+    \/\/ if we are in this set of code, we \"know\" the embeddedCipher is an AESCrypt object\n+    \/\/ (because of the predicated logic executed earlier).\n+    \/\/ so we cast it here safely.\n+    \/\/ this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java\n+    Node* embeddedCipherObj = load_field_from_object(gctr_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n+    Node* counter = load_field_from_object(gctr_object, \"counter\", \"[B\");\n+    Node* subkeyHtbl = load_field_from_object(ghash_object, \"subkeyHtbl\", \"[J\");\n+    Node* state = load_field_from_object(ghash_object, \"state\", \"[J\");\n@@ -6797,17 +6802,25 @@\n-  if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n-      return false;\n-  }\n-  \/\/ cast it to what we know it will be at runtime\n-  const TypeInstPtr* tinst = _gvn.type(gctr_object)->isa_instptr();\n-  assert(tinst != NULL, \"GCTR obj is null\");\n-  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n-  assert(klass_AESCrypt->is_loaded(), \"predicate checks that this class is loaded\");\n-  ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n-  const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);\n-  const TypeOopPtr* xtype = aklass->as_instance_type();\n-  Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);\n-  aescrypt_object = _gvn.transform(aescrypt_object);\n-  \/\/ we need to get the start of the aescrypt_object's expanded key array\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n-  if (k_start == NULL) return false;\n+    if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n+        return false;\n+    }\n+    \/\/ cast it to what we know it will be at runtime\n+    const TypeInstPtr* tinst = _gvn.type(gctr_object)->isa_instptr();\n+    assert(tinst != NULL, \"GCTR obj is null\");\n+    assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n+    ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+    assert(klass_AESCrypt->is_loaded(), \"predicate checks that this class is loaded\");\n+    ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n+    const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);\n+    const TypeOopPtr* xtype = aklass->as_instance_type();\n+    Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);\n+    aescrypt_object = _gvn.transform(aescrypt_object);\n+    \/\/ we need to get the start of the aescrypt_object's expanded key array\n+    Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+    if (k_start == NULL) return false;\n+\n+    \/\/ similarly, get the start address of the r vector\n+    Node* cnt_start = array_element_address(counter, intcon(0), T_BYTE);\n+    Node* state_start = array_element_address(state, intcon(0), T_LONG);\n+    Node* subkeyHtbl_start = array_element_address(subkeyHtbl, intcon(0), T_LONG);\n+\n+    ciKlass* klass = ciTypeArrayKlass::make(T_LONG);\n+    Node* klass_node = makecon(TypeKlassPtr::make(klass));\n@@ -6815,21 +6828,2 @@\n-  \/\/ similarly, get the start address of the r vector\n-  Node* cnt_start = array_element_address(counter, intcon(0), T_BYTE);\n-  Node* state_start = array_element_address(state, intcon(0), T_LONG);\n-  Node* subkeyHtbl_start = array_element_address(subkeyHtbl, intcon(0), T_LONG);\n-\n-  ciKlass* klass = ciTypeArrayKlass::make(T_LONG);\n-  Node* klass_node = makecon(TypeKlassPtr::make(klass));\n-\n-  \/\/ Does this target support this intrinsic?\n-  if (Matcher::htbl_entries == -1) return false;\n-\n-  Node* subkeyHtbl_48_entries_start;\n-  if (Matcher::htbl_entries != 0) {\n-    \/\/ new array to hold 48 computed htbl entries\n-    Node* subkeyHtbl_48_entries = new_array(klass_node, intcon(Matcher::htbl_entries), 0);\n-    if (subkeyHtbl_48_entries == NULL) return false;\n-    subkeyHtbl_48_entries_start = array_element_address(subkeyHtbl_48_entries, intcon(0), T_LONG);\n-  } else {\n-    \/\/ This target doesn't need the extra-large Htbl.\n-    subkeyHtbl_48_entries_start = ConvL2X(intcon(0));\n-  }\n+    \/\/ Does this target support this intrinsic?\n+    if (Matcher::htbl_entries == -1) return false;\n@@ -6837,5 +6831,10 @@\n-  \/\/ Call the stub, passing params\n-  Node* gcmCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n-                               OptoRuntime::galoisCounterMode_aescrypt_Type(),\n-                               stubAddr, stubName, TypePtr::BOTTOM,\n-                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, subkeyHtbl_48_entries_start, cnt_start);\n+    Node* subkeyHtbl_48_entries_start;\n+    if (Matcher::htbl_entries != 0) {\n+      \/\/ new array to hold 48 computed htbl entries\n+      Node* subkeyHtbl_48_entries = new_array(klass_node, intcon(Matcher::htbl_entries), 0);\n+      if (subkeyHtbl_48_entries == NULL) return false;\n+      subkeyHtbl_48_entries_start = array_element_address(subkeyHtbl_48_entries, intcon(0), T_LONG);\n+    } else {\n+      \/\/ This target doesn't need the extra-large Htbl.\n+      subkeyHtbl_48_entries_start = ConvL2X(intcon(0));\n+    }\n@@ -6843,3 +6842,10 @@\n-  \/\/ return cipher length (int)\n-  Node* retvalue = _gvn.transform(new ProjNode(gcmCrypt, TypeFunc::Parms));\n-  set_result(retvalue);\n+    \/\/ Call the stub, passing params\n+    Node* gcmCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                 OptoRuntime::galoisCounterMode_aescrypt_Type(),\n+                                 stubAddr, stubName, TypePtr::BOTTOM,\n+                                 in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, subkeyHtbl_48_entries_start, cnt_start);\n+\n+    \/\/ return cipher length (int)\n+    Node* retvalue = _gvn.transform(new ProjNode(gcmCrypt, TypeFunc::Parms));\n+    set_result(retvalue);\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":80,"deletions":74,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-compiler\/codegen\/aes\/TestAESMain.java 8274323 linux-x64,windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}