{"files":[{"patch":"@@ -4444,1 +4444,0 @@\n-    __ subptr(rsp, 96 * longSize); \/\/ Create space on the stack for htbl entries\n@@ -4446,1 +4445,0 @@\n-    __ movptr(avx512_subkeyHtbl, rsp);\n@@ -4448,0 +4446,7 @@\n+\/\/ Save rbp and rsp\n+    __ push(rbp);\n+    __ movq(rbp, rsp);\n+\/\/ Align stack\n+    __ andq(rsp, -64);\n+    __ subptr(rsp, 96 * longSize); \/\/ Create space on the stack for htbl entries\n+    __ movptr(avx512_subkeyHtbl, rsp);\n@@ -4452,0 +4457,2 @@\n+    __ movq(rsp, rbp);\n+    __ pop(rbp);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -6766,21 +6766,10 @@\n-    \/\/ (1) in, ct and out are arrays.\n-    const Type* in_type = in->Value(&_gvn);\n-    const Type* ct_type = ct->Value(&_gvn);\n-    const Type* out_type = out->Value(&_gvn);\n-    const TypeAryPtr* top_in = in_type->isa_aryptr();\n-    const TypeAryPtr* top_ct = ct_type->isa_aryptr();\n-    const TypeAryPtr* top_out = out_type->isa_aryptr();\n-    assert(top_in != NULL && top_in->klass() != NULL &&\n-           top_ct != NULL && top_ct->klass() != NULL &&\n-           top_out != NULL && top_out->klass() != NULL, \"args are strange\");\n-\n-    \/\/ checks are the responsibility of the caller\n-    Node* in_start = in;\n-    Node* ct_start = ct;\n-    Node* out_start = out;\n-    if (inOfs != NULL || ctOfs != NULL || outOfs != NULL) {\n-      assert(inOfs != NULL && ctOfs != NULL && outOfs != NULL, \"\");\n-      in_start = array_element_address(in, inOfs, T_BYTE);\n-      ct_start = array_element_address(ct, ctOfs, T_BYTE);\n-      out_start = array_element_address(out, outOfs, T_BYTE);\n-    }\n+  \/\/ (1) in, ct and out are arrays.\n+  const Type* in_type = in->Value(&_gvn);\n+  const Type* ct_type = ct->Value(&_gvn);\n+  const Type* out_type = out->Value(&_gvn);\n+  const TypeAryPtr* top_in = in_type->isa_aryptr();\n+  const TypeAryPtr* top_ct = ct_type->isa_aryptr();\n+  const TypeAryPtr* top_out = out_type->isa_aryptr();\n+  assert(top_in != NULL && top_in->klass() != NULL &&\n+         top_ct != NULL && top_ct->klass() != NULL &&\n+         top_out != NULL && top_out->klass() != NULL, \"args are strange\");\n@@ -6788,8 +6777,10 @@\n-    \/\/ if we are in this set of code, we \"know\" the embeddedCipher is an AESCrypt object\n-    \/\/ (because of the predicated logic executed earlier).\n-    \/\/ so we cast it here safely.\n-    \/\/ this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java\n-    Node* embeddedCipherObj = load_field_from_object(gctr_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n-    Node* counter = load_field_from_object(gctr_object, \"counter\", \"[B\");\n-    Node* subkeyHtbl = load_field_from_object(ghash_object, \"subkeyHtbl\", \"[J\");\n-    Node* state = load_field_from_object(ghash_object, \"state\", \"[J\");\n+  \/\/ checks are the responsibility of the caller\n+  Node* in_start = in;\n+  Node* ct_start = ct;\n+  Node* out_start = out;\n+  if (inOfs != NULL || ctOfs != NULL || outOfs != NULL) {\n+    assert(inOfs != NULL && ctOfs != NULL && outOfs != NULL, \"\");\n+    in_start = array_element_address(in, inOfs, T_BYTE);\n+    ct_start = array_element_address(ct, ctOfs, T_BYTE);\n+    out_start = array_element_address(out, outOfs, T_BYTE);\n+  }\n@@ -6797,29 +6788,30 @@\n-    if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n-        return false;\n-    }\n-    \/\/ cast it to what we know it will be at runtime\n-    const TypeInstPtr* tinst = _gvn.type(gctr_object)->isa_instptr();\n-    assert(tinst != NULL, \"GCTR obj is null\");\n-    assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n-    ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n-    assert(klass_AESCrypt->is_loaded(), \"predicate checks that this class is loaded\");\n-    ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n-    const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);\n-    const TypeOopPtr* xtype = aklass->as_instance_type();\n-    Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);\n-    aescrypt_object = _gvn.transform(aescrypt_object);\n-    \/\/ we need to get the start of the aescrypt_object's expanded key array\n-    Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n-    if (k_start == NULL) return false;\n-\n-    \/\/ similarly, get the start address of the r vector\n-    Node* cnt_start = array_element_address(counter, intcon(0), T_BYTE);\n-    Node* state_start = array_element_address(state, intcon(0), T_LONG);\n-    Node* subkeyHtbl_start = array_element_address(subkeyHtbl, intcon(0), T_LONG);\n-\n-\n-    \/\/ Call the stub, passing params\n-    Node* gcmCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n-                                 OptoRuntime::galoisCounterMode_aescrypt_Type(),\n-                                 stubAddr, stubName, TypePtr::BOTTOM,\n-                                 in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, cnt_start);\n+  \/\/ if we are in this set of code, we \"know\" the embeddedCipher is an AESCrypt object\n+  \/\/ (because of the predicated logic executed earlier).\n+  \/\/ so we cast it here safely.\n+  \/\/ this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java\n+  Node* embeddedCipherObj = load_field_from_object(gctr_object, \"embeddedCipher\", \"Lcom\/sun\/crypto\/provider\/SymmetricCipher;\");\n+  Node* counter = load_field_from_object(gctr_object, \"counter\", \"[B\");\n+  Node* subkeyHtbl = load_field_from_object(ghash_object, \"subkeyHtbl\", \"[J\");\n+  Node* state = load_field_from_object(ghash_object, \"state\", \"[J\");\n+\n+  if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n+    return false;\n+  }\n+  \/\/ cast it to what we know it will be at runtime\n+  const TypeInstPtr* tinst = _gvn.type(gctr_object)->isa_instptr();\n+  assert(tinst != NULL, \"GCTR obj is null\");\n+  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n+  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  assert(klass_AESCrypt->is_loaded(), \"predicate checks that this class is loaded\");\n+  ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt->as_instance_klass();\n+  const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);\n+  const TypeOopPtr* xtype = aklass->as_instance_type();\n+  Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);\n+  aescrypt_object = _gvn.transform(aescrypt_object);\n+  \/\/ we need to get the start of the aescrypt_object's expanded key array\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  if (k_start == NULL) return false;\n+  \/\/ similarly, get the start address of the r vector\n+  Node* cnt_start = array_element_address(counter, intcon(0), T_BYTE);\n+  Node* state_start = array_element_address(state, intcon(0), T_LONG);\n+  Node* subkeyHtbl_start = array_element_address(subkeyHtbl, intcon(0), T_LONG);\n@@ -6827,3 +6819,10 @@\n-    \/\/ return cipher length (int)\n-    Node* retvalue = _gvn.transform(new ProjNode(gcmCrypt, TypeFunc::Parms));\n-    set_result(retvalue);\n+\n+  \/\/ Call the stub, passing params\n+  Node* gcmCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                               OptoRuntime::galoisCounterMode_aescrypt_Type(),\n+                               stubAddr, stubName, TypePtr::BOTTOM,\n+                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, cnt_start);\n+\n+  \/\/ return cipher length (int)\n+  Node* retvalue = _gvn.transform(new ProjNode(gcmCrypt, TypeFunc::Parms));\n+  set_result(retvalue);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":60,"deletions":61,"binary":false,"changes":121,"status":"modified"}]}