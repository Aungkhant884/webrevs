{"files":[{"patch":"@@ -70,4 +70,6 @@\n-  ciMethod*       caller   = jvms->method();\n-  int             bci      = jvms->bci();\n-  Bytecodes::Code bytecode = caller->java_code_at_bci(bci);\n-  guarantee(callee != NULL, \"failed method resolution\");\n+  assert(callee != NULL, \"failed method resolution\");\n+\n+  ciMethod*       caller      = jvms->method();\n+  int             bci         = jvms->bci();\n+  Bytecodes::Code bytecode    = caller->java_code_at_bci(bci);\n+  ciMethod*       orig_callee = caller->get_method_at_bci(bci);\n@@ -76,1 +78,3 @@\n-                                       (bytecode == Bytecodes::_invokeinterface);\n+                                       (bytecode == Bytecodes::_invokeinterface) ||\n+                                       (orig_callee->intrinsic_id() == vmIntrinsics::_linkToVirtual) ||\n+                                       (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n@@ -59,0 +62,8 @@\n+\n+        \/\/ Implementation limitation: CHA is not performed by C1 during inlining through MH linkers.\n+        if (!sun.hotspot.code.Compiler.isC1Enabled()) {\n+            run(AbstractClass.TestMH.class, AbstractClass.class);\n+            run(AbstractInterface.TestMH.class, AbstractInterface.class);\n+        }\n+\n+        System.out.println(\"TEST PASSED\");\n@@ -127,0 +138,13 @@\n+\n+        public static class TestMH extends AbstractClass {\n+            static final MethodHandle TEST_MH = findVirtualHelper(C.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public Object test(C obj) {\n+                try {\n+                    return TEST_MH.invokeExact(obj); \/\/ invokevirtual C.m()\n+                } catch (Throwable e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        }\n@@ -128,0 +152,1 @@\n+\n@@ -196,0 +221,13 @@\n+\n+        public static class TestMH extends AbstractInterface {\n+            static final MethodHandle TEST_MH = findVirtualHelper(C.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public Object test(C obj) {\n+                try {\n+                    return TEST_MH.invokeExact(obj); \/\/ invokevirtual C.m()\n+                } catch (Throwable e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/AbstractRootMethod.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n@@ -59,0 +62,7 @@\n+\n+        \/\/ Implementation limitation: CHA is not performed by C1 during inlining through MH linkers.\n+        if (!sun.hotspot.code.Compiler.isC1Enabled()) {\n+            run(DefaultRoot.TestMH.class, DefaultRoot.class);\n+            run(InheritedDefault.TestMH.class, InheritedDefault.class);\n+        }\n+\n@@ -86,1 +96,1 @@\n-        public Object test(C obj) {\n+        public Object test(C obj) throws Throwable {\n@@ -125,0 +135,9 @@\n+\n+        public static class TestMH extends DefaultRoot {\n+            static final MethodHandle TEST_MH = findVirtualHelper(C.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public Object test(C obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokevirtual C.m()\n+            }\n+        }\n@@ -154,1 +173,1 @@\n-        public Object test(C obj) {\n+        public Object test(C obj) throws Throwable {\n@@ -193,0 +212,9 @@\n+\n+        public static class TestMH extends InheritedDefault {\n+            static final MethodHandle TEST_MH = findVirtualHelper(C.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public Object test(C obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokevirtual C.m()\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.invoke.MethodType;\n@@ -48,0 +49,1 @@\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n@@ -102,2 +104,0 @@\n-        public static final WhiteBox WB = WhiteBox.getWhiteBox();\n-\n@@ -120,1 +120,1 @@\n-        public abstract Object test(T i);\n+        public abstract Object test(T i) throws Throwable;\n@@ -136,1 +136,0 @@\n-\n@@ -164,1 +163,17 @@\n-            assertTrue(test(i) != WRONG);\n+            try {\n+                assertTrue(test(i) != WRONG);\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        public static <T> T compute(Callable<T> c) {\n+            try {\n+                return c.call();\n+            } catch (Exception e) {\n+                throw new Error(e);\n+            }\n+        }\n+\n+        public static MethodHandle findVirtualHelper(Class<?> refc, String name, Class<?> returnType, MethodHandles.Lookup lookup) {\n+            return compute(() -> lookup.findVirtual(refc, name, MethodType.methodType(returnType)));\n@@ -171,1 +186,1 @@\n-    static void run(Class<?> test) {\n+    static void run(Class<?> test, Class<?> enclosed) {\n@@ -173,1 +188,1 @@\n-            for (Method m : test.getDeclaredMethods()) {\n+            for (Method m : test.getMethods()) {\n@@ -176,1 +191,1 @@\n-                    ClassLoader cl = new MyClassLoader(test);\n+                    ClassLoader cl = new MyClassLoader(enclosed);\n@@ -186,0 +201,4 @@\n+    static void run(Class<?> test) {\n+        run(test, test);\n+    }\n+\n@@ -306,1 +325,1 @@\n-        } catch(Throwable e) {\n+        } catch (Throwable e) {\n@@ -323,8 +342,0 @@\n-\n-    static <T> T compute(Callable<T> c) {\n-        try {\n-            return c.call();\n-        } catch (Exception e) {\n-            throw new Error(e);\n-        }\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/Utils.java","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"}]}