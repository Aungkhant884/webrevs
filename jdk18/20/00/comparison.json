{"files":[{"patch":"@@ -17021,1 +17021,2 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4,\n+         USE_KILL src, USE_KILL dst, USE len, KILL cr);\n@@ -17023,1 +17024,1 @@\n-  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL R1, R2, R3, R4\" %}\n+  format %{ \"String Compress $src,$dst,$len -> $result  \/\/ KILL $src,$dst\" %}\n@@ -17026,0 +17027,1 @@\n+                           $result$$Register,\n@@ -17027,2 +17029,1 @@\n-                           $tmp3$$FloatRegister, $tmp4$$FloatRegister,\n-                           $result$$Register);\n+                           $tmp3$$FloatRegister, $tmp4$$FloatRegister);\n@@ -17030,1 +17031,1 @@\n-  ins_pipe( pipe_slow );\n+  ins_pipe(pipe_slow);\n@@ -17055,2 +17056,2 @@\n-                          vRegD_V0 Vtmp1, vRegD_V1 Vtmp2,\n-                          vRegD_V2 Vtmp3, vRegD_V3 Vtmp4,\n+                          vRegD_V0 vtmp0, vRegD_V1 vtmp1,\n+                          vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n@@ -17061,2 +17062,2 @@\n-  effect(USE_KILL src, USE_KILL dst, USE_KILL len,\n-         KILL Vtmp1, KILL Vtmp2, KILL Vtmp3, KILL Vtmp4, KILL cr);\n+  effect(USE_KILL src, USE_KILL dst, USE len,\n+         KILL vtmp0, KILL vtmp1, KILL vtmp2, KILL vtmp3, KILL cr);\n@@ -17064,1 +17065,1 @@\n-  format %{ \"Encode array $src,$dst,$len -> $result\" %}\n+  format %{ \"Encode ISO array $src,$dst,$len -> $result\" %}\n@@ -17067,2 +17068,3 @@\n-         $result$$Register, $Vtmp1$$FloatRegister,  $Vtmp2$$FloatRegister,\n-         $Vtmp3$$FloatRegister,  $Vtmp4$$FloatRegister);\n+                        $result$$Register, false,\n+                        $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                        $vtmp2$$FloatRegister, $vtmp3$$FloatRegister);\n@@ -17070,1 +17072,21 @@\n-  ins_pipe( pipe_class_memory );\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct encode_ascii_array(iRegP_R2 src, iRegP_R1 dst, iRegI_R3 len,\n+                            vRegD_V0 vtmp0, vRegD_V1 vtmp1,\n+                            vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n+                            iRegI_R0 result, rFlagsReg cr)\n+%{\n+  predicate(((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(USE_KILL src, USE_KILL dst, USE len,\n+         KILL vtmp0, KILL vtmp1, KILL vtmp2, KILL vtmp3, KILL cr);\n+\n+  format %{ \"Encode ASCII array $src,$dst,$len -> $result\" %}\n+  ins_encode %{\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n+                        $result$$Register, true,\n+                        $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                        $vtmp2$$FloatRegister, $vtmp3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_memory);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":35,"deletions":13,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2427,0 +2427,6 @@\n+  \/\/ Zero compare.\n+  INSN(cmeq,   0, 0b100000100110, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n+  INSN(cmge,   1, 0b100000100010, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n+  INSN(cmgt,   0, 0b100000100010, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n+  INSN(cmle,   1, 0b100000100110, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n+  INSN(cmlt,   0, 0b100000101010, 3); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4926,2 +4926,18 @@\n-\/\/ Intrinsic for sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray and\n-\/\/ java\/lang\/StringUTF16.compress.\n+\/\/ Intrinsic for\n+\/\/\n+\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n+\/\/     return the number of characters copied.\n+\/\/ - java\/lang\/StringUTF16.compress\n+\/\/     return zero (0) if copy fails, otherwise 'len'.\n+\/\/\n+\/\/ This version always returns the number of characters copied, and does not\n+\/\/ clobber the 'len' register. A successful copy will complete with the post-\n+\/\/ condition: 'res' == 'len', while an unsuccessful copy will exit with the\n+\/\/ post-condition: 0 <= 'res' < 'len'.\n+\/\/\n+\/\/ NOTE: Attempts to use 'ld2' (and 'umaxv' in the ISO part) has proven to\n+\/\/       degrade performance (on Ampere Altra - Neoverse N1), to an extent\n+\/\/       beyond the acceptable, even though the footprint would be smaller.\n+\/\/       Using 'umaxv' in the Ascii-case is considered acceptable and does\n+\/\/       avoid additional bloat.\n+\/\/\n@@ -4929,3 +4945,3 @@\n-                      Register len, Register result,\n-                      FloatRegister Vtmp1, FloatRegister Vtmp2,\n-                      FloatRegister Vtmp3, FloatRegister Vtmp4)\n+                                      Register len, Register res, bool ascii,\n+                                      FloatRegister vtmp0, FloatRegister vtmp1,\n+                                      FloatRegister vtmp2, FloatRegister vtmp3)\n@@ -4933,97 +4949,8 @@\n-    Label DONE, SET_RESULT, NEXT_32, NEXT_32_PRFM, LOOP_8, NEXT_8, LOOP_1, NEXT_1,\n-        NEXT_32_START, NEXT_32_PRFM_START;\n-    Register tmp1 = rscratch1, tmp2 = rscratch2;\n-\n-      mov(result, len); \/\/ Save initial len\n-\n-      cmp(len, (u1)8); \/\/ handle shortest strings first\n-      br(LT, LOOP_1);\n-      cmp(len, (u1)32);\n-      br(LT, NEXT_8);\n-      \/\/ The following code uses the SIMD 'uzp1' and 'uzp2' instructions\n-      \/\/ to convert chars to bytes\n-      if (SoftwarePrefetchHintDistance >= 0) {\n-        ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-        subs(tmp2, len, SoftwarePrefetchHintDistance\/2 + 16);\n-        br(LE, NEXT_32_START);\n-        b(NEXT_32_PRFM_START);\n-        BIND(NEXT_32_PRFM);\n-          ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-        BIND(NEXT_32_PRFM_START);\n-          prfm(Address(src, SoftwarePrefetchHintDistance));\n-          orr(v4, T16B, Vtmp1, Vtmp2);\n-          orr(v5, T16B, Vtmp3, Vtmp4);\n-          uzp1(Vtmp1, T16B, Vtmp1, Vtmp2);\n-          uzp1(Vtmp3, T16B, Vtmp3, Vtmp4);\n-          uzp2(v5, T16B, v4, v5); \/\/ high bytes\n-          umov(tmp2, v5, D, 1);\n-          fmovd(tmp1, v5);\n-          orr(tmp1, tmp1, tmp2);\n-          cbnz(tmp1, LOOP_8);\n-          stpq(Vtmp1, Vtmp3, dst);\n-          sub(len, len, 32);\n-          add(dst, dst, 32);\n-          add(src, src, 64);\n-          subs(tmp2, len, SoftwarePrefetchHintDistance\/2 + 16);\n-          br(GE, NEXT_32_PRFM);\n-          cmp(len, (u1)32);\n-          br(LT, LOOP_8);\n-        BIND(NEXT_32);\n-          ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-        BIND(NEXT_32_START);\n-      } else {\n-        BIND(NEXT_32);\n-          ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-      }\n-      prfm(Address(src, SoftwarePrefetchHintDistance));\n-      uzp1(v4, T16B, Vtmp1, Vtmp2);\n-      uzp1(v5, T16B, Vtmp3, Vtmp4);\n-      orr(Vtmp1, T16B, Vtmp1, Vtmp2);\n-      orr(Vtmp3, T16B, Vtmp3, Vtmp4);\n-      uzp2(Vtmp1, T16B, Vtmp1, Vtmp3); \/\/ high bytes\n-      umov(tmp2, Vtmp1, D, 1);\n-      fmovd(tmp1, Vtmp1);\n-      orr(tmp1, tmp1, tmp2);\n-      cbnz(tmp1, LOOP_8);\n-      stpq(v4, v5, dst);\n-      sub(len, len, 32);\n-      add(dst, dst, 32);\n-      add(src, src, 64);\n-      cmp(len, (u1)32);\n-      br(GE, NEXT_32);\n-      cbz(len, DONE);\n-\n-    BIND(LOOP_8);\n-      cmp(len, (u1)8);\n-      br(LT, LOOP_1);\n-    BIND(NEXT_8);\n-      ld1(Vtmp1, T8H, src);\n-      uzp1(Vtmp2, T16B, Vtmp1, Vtmp1); \/\/ low bytes\n-      uzp2(Vtmp3, T16B, Vtmp1, Vtmp1); \/\/ high bytes\n-      fmovd(tmp1, Vtmp3);\n-      cbnz(tmp1, NEXT_1);\n-      strd(Vtmp2, dst);\n-\n-      sub(len, len, 8);\n-      add(dst, dst, 8);\n-      add(src, src, 16);\n-      cmp(len, (u1)8);\n-      br(GE, NEXT_8);\n-\n-    BIND(LOOP_1);\n-\n-    cbz(len, DONE);\n-    BIND(NEXT_1);\n-      ldrh(tmp1, Address(post(src, 2)));\n-      tst(tmp1, 0xff00);\n-      br(NE, SET_RESULT);\n-      strb(tmp1, Address(post(dst, 1)));\n-      subs(len, len, 1);\n-      br(GT, NEXT_1);\n-\n-    BIND(SET_RESULT);\n-      sub(result, result, len); \/\/ Return index where we stopped\n-                                \/\/ Return len == 0 if we processed all\n-                                \/\/ characters\n-    BIND(DONE);\n-}\n+  Register cnt = res;\n+  Register max = rscratch1;\n+  Register chk = rscratch2;\n+\n+  prfm(Address(src), PLDL1STRM);\n+  movw(cnt, len);\n+\n+#define ASCII(insn) if (ascii) { insn; }\n@@ -5031,0 +4958,80 @@\n+  Label LOOP_32, DONE_32, FAIL_32;\n+\n+  BIND(LOOP_32);\n+  {\n+    cmpw(cnt, 32);\n+    br(LT, DONE_32);\n+    ld1(vtmp0, vtmp1, vtmp2, vtmp3, T8H, Address(post(src, 64)));\n+    \/\/ Extract lower bytes.\n+    FloatRegister vlo0 = v4;\n+    FloatRegister vlo1 = v5;\n+    uzp1(vlo0, T16B, vtmp0, vtmp1);\n+    uzp1(vlo1, T16B, vtmp2, vtmp3);\n+    \/\/ Merge bits...\n+    orr(vtmp0, T16B, vtmp0, vtmp1);\n+    orr(vtmp2, T16B, vtmp2, vtmp3);\n+    \/\/ Extract merged upper bytes.\n+    FloatRegister vhix = vtmp0;\n+    uzp2(vhix, T16B, vtmp0, vtmp2);\n+    \/\/ ISO-check on hi-parts (all zero).\n+    \/\/                          Ascii-check on lo-parts (no sign).\n+    FloatRegister vlox = vtmp1; \/\/ Merge lower bytes.\n+                                ASCII(orr(vlox, T16B, vlo0, vlo1));\n+    umov(chk, vhix, D, 1);      ASCII(cmlt(vlox, T16B, vlox));\n+    fmovd(max, vhix);           ASCII(umaxv(vlox, T16B, vlox));\n+    orr(chk, chk, max);         ASCII(umov(max, vlox, B, 0));\n+                                ASCII(orr(chk, chk, max));\n+    cbnz(chk, FAIL_32);\n+    subw(cnt, cnt, 32);\n+    st1(vlo0, vlo1, T16B, Address(post(dst, 32)));\n+    b(LOOP_32);\n+  }\n+  BIND(FAIL_32);\n+  sub(src, src, 64);\n+  BIND(DONE_32);\n+\n+  Label LOOP_8, SKIP_8;\n+\n+  BIND(LOOP_8);\n+  {\n+    cmpw(cnt, 8);\n+    br(LT, SKIP_8);\n+    FloatRegister vhi = vtmp0;\n+    FloatRegister vlo = vtmp1;\n+    ld1(vtmp3, T8H, src);\n+    uzp1(vlo, T16B, vtmp3, vtmp3);\n+    uzp2(vhi, T16B, vtmp3, vtmp3);\n+    \/\/ ISO-check on hi-parts (all zero).\n+    \/\/                          Ascii-check on lo-parts (no sign).\n+                                ASCII(cmlt(vtmp2, T16B, vlo));\n+    fmovd(chk, vhi);            ASCII(umaxv(vtmp2, T16B, vtmp2));\n+                                ASCII(umov(max, vtmp2, B, 0));\n+                                ASCII(orr(chk, chk, max));\n+    cbnz(chk, SKIP_8);\n+\n+    strd(vlo, Address(post(dst, 8)));\n+    subw(cnt, cnt, 8);\n+    add(src, src, 16);\n+    b(LOOP_8);\n+  }\n+  BIND(SKIP_8);\n+\n+#undef ASCII\n+\n+  Label LOOP, DONE;\n+\n+  cbz(cnt, DONE);\n+  BIND(LOOP);\n+  {\n+    Register chr = rscratch1;\n+    ldrh(chr, Address(post(src, 2)));\n+    tst(chr, ascii ? 0xff80 : 0xff00);\n+    br(NE, DONE);\n+    strb(chr, Address(post(dst, 1)));\n+    subs(cnt, cnt, 1);\n+    br(GT, LOOP);\n+  }\n+  BIND(DONE);\n+  \/\/ Return index where we stopped.\n+  subw(res, len, cnt);\n+}\n@@ -5139,7 +5146,7 @@\n-                                         FloatRegister tmp1Reg, FloatRegister tmp2Reg,\n-                                         FloatRegister tmp3Reg, FloatRegister tmp4Reg,\n-                                         Register result) {\n-  encode_iso_array(src, dst, len, result,\n-                   tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg);\n-  cmp(len, zr);\n-  csel(result, result, zr, EQ);\n+                                         Register res,\n+                                         FloatRegister tmp0, FloatRegister tmp1,\n+                                         FloatRegister tmp2, FloatRegister tmp3) {\n+  encode_iso_array(src, dst, len, res, false, tmp0, tmp1, tmp2, tmp3);\n+  \/\/ Adjust result: res == len ? len : 0\n+  cmp(len, res);\n+  csel(res, res, zr, EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":116,"deletions":109,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -1258,3 +1258,3 @@\n-                           FloatRegister tmp1Reg, FloatRegister tmp2Reg,\n-                           FloatRegister tmp3Reg, FloatRegister tmp4Reg,\n-                           Register result);\n+                           Register res,\n+                           FloatRegister vtmp0, FloatRegister vtmp1,\n+                           FloatRegister vtmp2, FloatRegister vtmp3);\n@@ -1263,3 +1263,4 @@\n-                        Register len, Register result,\n-                        FloatRegister Vtmp1, FloatRegister Vtmp2,\n-                        FloatRegister Vtmp3, FloatRegister Vtmp4);\n+                        Register len, Register res, bool ascii,\n+                        FloatRegister vtmp0, FloatRegister vtmp1,\n+                        FloatRegister vtmp2, FloatRegister vtmp3);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  static const bool supports_encode_ascii_array = false;\n+  static const bool supports_encode_ascii_array = true;\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    @Param({\"UTF-8\", \"BIG5\", \"ISO-8859-15\", \"ASCII\", \"UTF-16\"})\n+    @Param({\"UTF-8\", \"BIG5\", \"ISO-8859-15\", \"ISO-8859-1\", \"ASCII\", \"UTF-16\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/CharsetEncodeDecode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}