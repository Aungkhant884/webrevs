{"files":[{"patch":"@@ -1,23 +0,0 @@\n-name: Publish\n-on: [push, workflow_dispatch]\n-\n-jobs:\n-  build:\n-    runs-on: ubuntu-20.04\n-    steps:\n-      - name: checkout\n-        uses: actions\/checkout@v2\n-\n-      - name: install-pandoc\n-        run: sudo apt install pandoc -y --no-install-recommends\n-\n-      - name: make\n-        run: make\n-\n-      - name: publish\n-        uses: peaceiris\/actions-gh-pages@068dc23d9710f1ba62e86896f84735d869951305\n-        with:\n-          github_token: ${{ secrets.GITHUB_TOKEN }}\n-          publish_dir: .\/web\n-          force_orphan: true\n-\n","filename":".github\/workflows\/publish.yaml","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,1 +1,2 @@\n-web\n+\/build\/\n+\/ojweb-generate\/\n","filename":".gitignore","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n","filename":".nojeckyll","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,56 +1,1 @@\n-OUT_DIR = web\n-IN_DIR = site\n-CSS = etc\/style.css\n-\n-IN_DIR_FILES := $(shell find $(IN_DIR) -type f)\n-WILDCARD = $(patsubst $(IN_DIR)\/%, %, $(filter %.$(1), $(IN_DIR_FILES)))\n-\n-ASSET_EXTS = html jpg jpg gif svg png pdf\n-\n-MD_SOURCES = $(call WILDCARD,md)\n-ASSET_SOURCES = $(foreach X, $(ASSET_EXTS), $(call WILDCARD,$(X)))\n-\n-GENERATED_FILES = $(patsubst %.md, $(OUT_DIR)\/%.html, $(MD_SOURCES))\n-COPIED_FILES = $(filter-out $(GENERATED_FILES), $(patsubst %,$(OUT_DIR)\/%, $(ASSET_SOURCES)))\n-AUTO_SITE_MAP = $(OUT_DIR)\/README.html\n-\n-site: $(GENERATED_FILES) $(COPIED_FILES) $(AUTO_SITE_MAP)\n-\ttar czf site.tar.gz -C $(OUT_DIR) `cd $(OUT_DIR); ls`\n-# (do not use tar --xform; some platforms do not have it)\n-\n-$(GENERATED_FILES) : $(OUT_DIR)\/%.html : $(IN_DIR)\/%.md\n-\t@mkdir -p \"$(@D)\"\n-\tpandoc -f markdown \"$<\" -o \"$@\" $(call PANDOC_OPTIONS, \"$<\")\n-\n-$(COPIED_FILES) : $(OUT_DIR)\/% : $(IN_DIR)\/%\n-\t@mkdir -p \"$(@D)\"\n-\tcp \"$<\" \"$@\"\n-\n-# Tweak the options to pandoc.\n-PANDOC_OPTIONS = \\\n-\t--standalone \\\n-\t--include-after-body=etc\/footer.html \\\n-\t$(if $(call HAS_STYLE, $(1)),,-H \"$(CSS)\") \\\n-\t$(if $(call HAS_PAGETITLE, $(1)),,--metadata pagetitle=\"$(basename $(notdir $(1)))\") \\\n-\t$(call HAS_PANDOC_FLAGS, $(1))\n-\n-# Specify -H $(CSS) if we do not already have embedded style.\n-HAS_STYLE = $(shell sed -n < $(1) '\/^ *<style[ >]\/{p;q;};999q')\n-# Avoid pandoc warning by specifying a default page title.\n-HAS_PAGETITLE = $(shell sed -n < $(1) '1s\/^% \/<title>\/;\/^ *<title[ >]\/{p;q;};999q')\n-# Allow document to embed misc. pandoc flags, such as <meta pandoc-flags=\"--toc\">.\n-HAS_PANDOC_FLAGS = $(shell sed -n < $(1) '\/^<meta pandoc-flags=\"\\(.*\\)\">\/s\/\/\\1\/p;999q')\n-\n-\n-$(AUTO_SITE_MAP) : $(GENERATED_FILES) $(COPIED_FILES) Makefile\n-\t( cd $(OUT_DIR); \\\n-\t  echo \"<h3>Site map:<\/h3><ul>\"; \\\n-\t  find * -type f -name \\*.html ! -name README.html \\\n-\t  | sort | sed 's|.*|<li><a href=\"&\">&<\/a><\/li>|'; \\\n-\t  echo \"<\/ul>\"; \\\n-\t) > \"$@\"\n-\n-clean:\n-\trm -rf $(OUT_DIR)\n-\n-.PHONY: all site clean\n+include ojweb-generate\/Makefile\n","filename":"Makefile","additions":1,"deletions":56,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1,2 +1,3 @@\n-# Deconstruction patterns for records and classes\n-#### Brian Goetz, Aug 2020\n+# Deconstruction Patterns for Records and Classes\n+#### Brian Goetz {.author}\n+#### August 2020 {.date}\n@@ -4,1 +5,1 @@\n-This document describes a possible approach for a future phase of _pattern\n+> This document describes a possible approach for a future phase of _pattern\n@@ -7,1 +8,1 @@\n-switch](type-patterns-in-switch.html).  _This is an exploratory document only\n+switch](..\/site\/design-notes\/patterns\/type-patterns-in-switch).  _This is an exploratory document only\n@@ -52,1 +53,1 @@\n-#### Deconstruction patterns\n+### Deconstruction patterns\n@@ -78,1 +79,1 @@\n-#### Nested patterns\n+### Nested patterns\n@@ -115,1 +116,1 @@\n-#### Match statements\n+### Match statements\n@@ -208,1 +209,1 @@\n-#### Overloading\n+### Overloading\n@@ -221,1 +222,1 @@\n-#### Varargs\n+### Varargs\n@@ -234,1 +235,1 @@\n-#### Composition\n+### Composition\n@@ -314,1 +315,1 @@\n-#### Translation\n+### Translation\n@@ -357,1 +358,1 @@\n-#### Relationship to accessors\n+### Relationship to accessors\n@@ -368,1 +369,1 @@\n-#### Records\n+### Records\n@@ -377,1 +378,1 @@\n-#### Switch miscellany\n+### Switch miscellany\n","filename":"eg-drafts\/deconstruction-patterns-records-and-classes.md","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,2 +1,3 @@\n-# Functional transformation of immutable objects\r\n-#### Brian Goetz, Aug 2020\r\n+# Functional Transformation of Immutable Objects\r\n+#### Brian Goetz {.author}\r\n+#### August 2020 {.date}\r\n@@ -4,1 +5,1 @@\n-This document is an _early stage draft_ outlining a possible direction for supporting _functional transformation_ in the Java Language. This is an exploratory document only and does not constitute a plan for any specific feature in any specific version of the Java Language. This document also may reference other features under exploration; this is purely for illustrative purposes, and does not constitute any sort of plan or commitment to deliver any of these features.\r\n+> This document is an _early stage draft_ outlining a possible direction for supporting _functional transformation_ in the Java Language. This is an exploratory document only and does not constitute a plan for any specific feature in any specific version of the Java Language. This document also may reference other features under exploration; this is purely for illustrative purposes, and does not constitute any sort of plan or commitment to deliver any of these features.\r\n@@ -62,1 +63,1 @@\n-#### Digression: learning from C#\r\n+### Digression: learning from C\\#\r\n@@ -101,1 +102,1 @@\n-#### With expressions in Java\r\n+### With expressions in Java\r\n@@ -243,1 +244,1 @@\n-#### Making names significant\r\n+### Making names significant\r\n@@ -276,1 +277,1 @@\n-#### Refining overloading\r\n+### Refining overloading\r\n@@ -320,1 +321,1 @@\n-#### Teasers\r\n+### Teasers\r\n@@ -329,1 +330,1 @@\n-#### Factories\r\n+### Factories\r\n@@ -360,1 +361,3 @@\n-**Bonus round: interfaces?**   We already allow static factories in interfaces,\r\n+#### Bonus round: interfaces?\r\n+\r\n+We already allow static factories in interfaces,\r\n","filename":"eg-drafts\/reconstruction-records-and-classes.md","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,8 +0,0 @@\n-<div class=\"footer\" id=\"footer\">\n-<img src=\"http:\/\/openjdk.java.net\/images\/openjdk-small.png\">\n-<br>© 2021 Oracle Corporation and\/or its affiliates\n-<br><a href=\"http:\/\/openjdk.java.net\/legal\/tou\/\">Terms of Use<\/a>\n-· License: <a href=\"http:\/\/openjdk.java.net\/legal\/gplv2+ce.html\">GPLv2<\/a>\n-· <a href=\"http:\/\/www.oracle.com\/us\/legal\/privacy\/\">Privacy<\/a>\n-· <a href=\"http:\/\/www.oracle.com\/us\/legal\/third-party-trademarks\/third-party-trademarks-078568.html\">Trademarks<\/a>\n-<\/div>\n","filename":"etc\/footer.html","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-    <style type=\"text\/css\">\n-      A IMG { border-width: 0px; }\n-\n-      BODY {\n-          background: white;\n-          margin: 2em;\n-        font-size: medium;\n-        max-width: 60em;\n-        margin-bottom: 100%;\n-        font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;\n-      }\n-\n-      code, pre, tt {\n-\tfont-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;\n-\tfont-size: medium\n-      }\n-\n-      code {\n-          display: inline-block;\n-          padding: .1em .2em;\n-        font-size: 90%;\n-        border-radius: 6px;\n-\tbackground-color: #f6f8fa;\n-        box-sizing: border-box;\n-      }\n-\n-      h1 {\n-\t  font-size: 32px;\n-      }\n-\n-      h1,\n-      h2 {\n-\t  font-weight: 600;\n-          border-bottom: 1px solid #e8e8e8;\n-      }\n-      \n-      h2 {\n-\t  font-size: 24px\n-      }\n-      \n-      h3 {\n-\t  font-size: 20px\n-      }\n-      \n-      h3,\n-      h4 {\n-\t  font-weight: 600\n-      }\n-      \n-      h4 {\n-\t  font-size: 20px\n-      }\n-\n-      P { margin: 1ex 0em; }\n-      P.subsection { margin-top: 2ex; }\n-      P.subsection:first-child { margin-top: 1ex; }\n-      P SPAN.title { font-weight: bold; padding-right: 1em; }\n-\n-      PRE {\n-        margin: 1.5ex 2em;\n-        padding: 1px 1ex;\n-        background: #f6f8fa;\n-      }\n-\n-      .sidebar {\n-        margin: 1.5ex 2em;\n-        padding: 1px 1ex;\n-        background: #e8e8e8;\n-      }\n-\n-      .control-character {\n-          color: #bbb;\n-          font-style: italic;\n-      }\n-\n-      \/* added for ```{.jvm} support *\/\n-      PRE.jvm { font-style: italic; }\n-\n-      BLOCKQUOTE { margin: 1.5ex 2em; font-style: italic; border-left: 0.2em solid gray; padding-left: 1em; }\n-      LI BLOCKQUOTE { margin-left: 0em; }\n-      LI { margin: 0ex 0em; }\n-\n-      TABLE, TH, TD { border: 1px solid #e8e8e8;\n-                      padding: 6px 12px; }\n-      TR:nth-child(2n) {\n-          background-color: #f6f8fa;\n-      }\n-      TH { font-weight: 600 }\n-      TABLE { border-collapse: collapse; }\n-      TD { vertical-align: top; }\n-\n-      UL LI { list-style-type: square; }\n-\n-      DIV.summary { margin: 2ex 2em; }\n-\n-      DIV.head { margin-bottom: 2em; }\n-      DIV.doctitle { font-size: x-large; font-weight: bold; }\n-      DIV.twarn { color: #cc0000; font-size: smaller; font-weight: bold;\n-                  margin-bottom: 1.5ex; }\n-      DIV.authors { margin-top: 1ex; font-size: large; }\n-      DIV.author A { font-style: italic; }\n-      DIV.version { font-size: medium; margin-top: 1ex; }\n-      DIV.copyright, DIV.comments { font-size: small; }\n-      DIV.version SPAN.modified { color: green; font-weight: bold; }\n-      DIV.head DIV.notes { margin-top: 1ex; }\n-      DIV.qa { margin-top: 2ex; }\n-      DIV.footer { padding-top: 4em; text-align: center; font-size: 7pt; }\n-      \n-      \/* added because pandoc syntax highlighting always uses scroll bars *\/\n-      DIV.sourceCode {\n-          overflow: visible;\n-      }\n-\n-      HR { border: 0px; border-top: 1px solid black; margin: 2ex 0em; }\n-   <\/style>\n","filename":"etc\/style.css","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -0,0 +1,78 @@\n+# Project Amber\n+\n+The goal of Project Amber is to explore and incubate smaller,\n+productivity-oriented Java language features that have been accepted\n+as candidate JEPs in\n+the [OpenJDK JEP Process](http:\/\/openjdk.java.net\/jeps\/1). This\n+Project is sponsored by\n+the [Compiler Group](http:\/\/openjdk.java.net\/groups\/compiler).\n+\n+Most Project Amber features go through at least two rounds\n+of [_preview_](http:\/\/openjdk.java.net\/jeps\/12) before becoming an\n+official part of the Java Platform.  For a given feature, there are separate\n+JEPs for each round of preview and for final standardization.  This\n+page links only to the most recent JEP for a feature. Such JEPs may\n+have links to earlier JEPs for the feature, as appropriate.\n+\n+## Status of JEPs\n+\n+Currently in progress:\n+\n+  - [409: Sealed Classes](http:\/\/openjdk.java.net\/jeps\/409)\n+  - [406: Pattern Matching for <code>switch<\/code> (Preview)](http:\/\/openjdk.java.net\/jeps\/406)\n+  - [405: Record Patterns and Array Patterns (Preview)](http:\/\/openjdk.java.net\/jeps\/405)\n+\n+<p>Delivered:<\/p>\n+\n+  - [395: Records](http:\/\/openjdk.java.net\/jeps\/395)\n+  - [394: Pattern Matching for <code>instanceof<\/code>](http:\/\/openjdk.java.net\/jeps\/394)\n+  - [378: Text Blocks](http:\/\/openjdk.java.net\/jeps\/378)\n+    - [Programmer's Guide](guides\/text-blocks-guide)\n+  - [361: Switch Expressions](http:\/\/openjdk.java.net\/jeps\/361)\n+  - [323: Local-Variable Syntax for Lambda Parameters](http:\/\/openjdk.java.net\/jeps\/323)\n+  - [286: Local-Variable Type Inference (<code>var<\/code>)](http:\/\/openjdk.java.net\/jeps\/286)\n+    - [Style Guidelines](guides\/lvti-style-guide)\n+    - [FAQ](guides\/lvti-faq)\n+\n+On hold:\n+\n+ - [301: Enhanced Enums](http:\/\/openjdk.java.net\/jeps\/301) (see [here](http:\/\/mail.openjdk.java.net\/pipermail\/amber-spec-experts\/2017-May\/000041.html) for explanation)\n+ - [302: Lambda Leftovers](http:\/\/openjdk.java.net\/jeps\/302)\n+ - [348: Java Compiler Intrinsics for JDK APIs](http:\/\/openjdk.java.net\/jeps\/348)\n+\n+Withdrawn:\n+\n+ - [326: Raw String Literals](http:\/\/openjdk.java.net\/jeps\/326), dropped in favor of Text Blocks (see [here](https:\/\/mail.openjdk.java.net\/pipermail\/jdk-dev\/2018-December\/002402.html) for explanation)\n+\n+## Documents\n+\n+  - Guides\n+    - [Local Variable Type Inference Style Guide](guides\/lvti-style-guide) (March 2018)\n+    - [Local Variable Type Inference FAQ](guides\/lvti-faq) (Oct 2018)\n+    - [Programmer's Guide to Text Blocks](guides\/text-blocks-guide) (Aug 2019)\n+\n+  - Design notes\n+    - [Symbolic References for Constants](design-notes\/constables) (March 2018)\n+    - [Data Classes and Sealed Types for Java](design-notes\/records-and-sealed-classes) (February 2019)\n+    - [Towards Better Serialization](design-notes\/towards-better-serialization) (June 2019)\n+    - Pattern matching\n+      - [Pattern Matching for Java](design-notes\/patterns\/pattern-matching-for-java) (September 2018)\n+      - [Pattern Matching in the Java Object Model](design-notes\/patterns\/pattern-match-object-model) (December 2020)\n+      - [Pattern Matching for Java -- Semantics](design-notes\/patterns\/pattern-match-semantics) (August 2020)\n+      - [Pattern Matching for Java -- Runtime and Translation](design-notes\/patterns\/pattern-match-translation) (June 2017)\n+      - [Extending `switch` for Pattern Matching](design-notes\/patterns\/extending-switch-for-patterns) (April 2017)\n+      - [Type Patterns in `switch`](design-notes\/patterns\/type-patterns-in-switch) (September 2020)\n+    - [String Tapas Redux: Beyond Mere String Interpolation](design-notes\/templated-strings) (September 2021)\n+\n+  - Historical notes\n+    - [Data Classes for Java](design-notes\/data-classes-historical-1) (October 2017)\n+    - [Data Classes for Java](design-notes\/data-classes-historical-2) (February 2018)\n+\n+## Community\n+\n+  - [Members](http:\/\/openjdk.java.net\/census#amber)\n+  - Mailing Lists\n+    - [amber-dev](http:\/\/mail.openjdk.java.net\/mailman\/listinfo\/amber-dev) --- For technical discussion related to Project Amber\n+    - [amber-spec-experts](http:\/\/mail.openjdk.java.net\/mailman\/listinfo\/amber-spec-experts) --- For Expert Group members only\n+    - [amber-spec-observers](http:\/\/mail.openjdk.java.net\/mailman\/listinfo\/amber-spec-observers) --- A read-only clone of amber-spec-experts\n+    - [amber-spec-comments](http:\/\/mail.openjdk.java.net\/mailman\/listinfo\/amber-spec-comments) --- For submitting comments on the official specs\n","filename":"site\/_index.md","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -2,1 +2,2 @@\n-#### Brian Goetz, March 2018\n+#### Brian Goetz {.author}\n+#### March 2018 {.date}\n@@ -53,1 +54,1 @@\n-#### Symbolic references\n+### Symbolic references\n@@ -95,1 +96,1 @@\n-#### ClassRef\n+### ClassRef\n@@ -130,1 +131,1 @@\n-#### MethodTypeRef\n+### MethodTypeRef\n@@ -161,1 +162,1 @@\n-#### MethodHandleRef\n+### MethodHandleRef\n@@ -204,1 +205,1 @@\n-#### DynamicConstantRef\n+### DynamicConstantRef\n@@ -236,1 +237,1 @@\n-#### Bytecode writing and reading\n+### Bytecode writing and reading\n@@ -259,1 +260,1 @@\n-#### Extensibility\n+### Extensibility\n@@ -269,1 +270,1 @@\n-#### Representing invokedynamic sites\n+### Representing invokedynamic sites\n@@ -345,1 +346,1 @@\n-#### Examples\n+### Examples\n@@ -427,1 +428,1 @@\n-#### Tracking\n+### Tracking\n@@ -465,1 +466,1 @@\n-#### Constant propagation\n+### Constant propagation\n@@ -495,1 +496,1 @@\n-#### Foldable\n+### Foldable\n@@ -520,1 +521,1 @@\n-#### Intrinsification\n+### Intrinsification\n@@ -537,1 +538,1 @@\n-#### Constable\n+### Constable\n@@ -565,1 +566,1 @@\n-#### Constant folding\n+### Constant folding\n@@ -596,1 +597,1 @@\n-#### Dead code elimination\n+### Dead code elimination\n@@ -616,1 +617,1 @@\n-#### Path optimization\n+### Path optimization\n@@ -635,1 +636,1 @@\n-#### String folding\n+### String folding\n@@ -664,1 +665,1 @@\n-#### De-capturing of lambdas\n+### De-capturing of lambdas\n","filename":"site\/design-notes\/constables.md","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,822 +1,282 @@\n-From: <Saved by Blink>\r\n-Snapshot-Content-Location: http:\/\/cr.openjdk.java.net\/~briangoetz\/amber\/datum_1.html\r\n-Subject: \r\n-Date: Wed, 5 Aug 2020 17:31:24 -0000\r\n-MIME-Version: 1.0\r\n-Content-Type: multipart\/related;\r\n-\ttype=\"text\/html\";\r\n-\tboundary=\"----MultipartBoundary--jiLwVqYekGDIUiF4larjHK4zCL8rSBJV7q2jwUQbvt----\"\r\n-\r\n-\r\n-------MultipartBoundary--jiLwVqYekGDIUiF4larjHK4zCL8rSBJV7q2jwUQbvt----\r\n-Content-Type: text\/html\r\n-Content-ID: <frame-26512C69423E5D53F8256489FC97CC8A@mhtml.blink>\r\n-Content-Transfer-Encoding: quoted-printable\r\n-Content-Location: http:\/\/cr.openjdk.java.net\/~briangoetz\/amber\/datum_1.html\r\n-\r\n-<!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\" \"http:\/\/www.=\r\n-w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\"><html xmlns=3D\"http:\/\/www.w3.=\r\n-org\/1999\/xhtml\"><head><meta http-equiv=3D\"Content-Type\" content=3D\"text\/htm=\r\n-l; charset=3DUTF-8\"><link rel=3D\"stylesheet\" type=3D\"text\/css\" href=3D\"cid:=\r\n-css-e0158a3a-f3a5-43c6-94e0-06ecafcf18b4@mhtml.blink\" \/><link rel=3D\"styles=\r\n-heet\" type=3D\"text\/css\" href=3D\"cid:css-1bdf0aa7-4770-484a-b235-9a8f642dd18=\r\n-f@mhtml.blink\" \/>\r\n- =20\r\n-  <meta http-equiv=3D\"Content-Style-Type\" content=3D\"text\/css\">\r\n-  <meta name=3D\"generator\" content=3D\"pandoc\">\r\n-  <title><\/title>\r\n- =20\r\n-     =20\r\n-<\/head>\r\n-<body>\r\n-<h1 id=3D\"data-classes-for-java\">Data Classes for Java<\/h1>\r\n-<h4 id=3D\"brian-goetz-october-2017\">Brian Goetz, October 2017<\/h4>\r\n-<br>\r\n-<h3>THIS DOCUMENT HAS BEEN SUPERSEDED AND IS PROVIDED FOR HISTORICAL CONTEX=\r\n-T ONLY<\/h3>\r\n-\r\n-<p>This document explores possible directions for <em>data classes<\/em> in =\r\n-the Java Language. This is an exploratory document only and does not consti=\r\n-tute a plan for any specific feature in any specific version of the Java La=\r\n-nguage.<\/p>\r\n-<h2 id=3D\"background\">Background<\/h2>\r\n-<p>It is a common (and often deserved) complaint that \"Java is too verbose\"=\r\n- or has too much \"ceremony.\" A significant contributor to this is that whil=\r\n-e classes can flexibly model a variety of programming paradigms, this invar=\r\n-iably comes with modeling overheads -- and in the case of classes that are =\r\n-nothing more than \"plain data carriers\", the modeling overhead can be subst=\r\n-antial. To write such a class responsibly, one has to write a lot of low-va=\r\n-lue, repetitive code: constructors, accessors, <code>equals()<\/code>, <code=\r\n->hashCode()<\/code>, <code>toString()<\/code>, and possibly others, such as <=\r\n-code>compareTo()<\/code>. And because this is burdensome, developers may be =\r\n-tempted to cut corners such as omitting these important methods, leading to=\r\n- surprising behavior or poor debuggability, or press an alternate but not e=\r\n-ntirely appropriate class into service because it has the \"right shape\" and=\r\n- they don't want to define yet another class.<\/p>\r\n-<p>There's no doubt that writing the usual boilerplate code for these membe=\r\n-rs is annoying (especially as it seems so unnecessary.) Even though IDEs wi=\r\n-ll generate much of this for you, it's still irritating -- a class with onl=\r\n-y a few lines of real semantic content takes dozens of lines of code -- but=\r\n- more importantly, the IDEs don't help the <em>reader<\/em> to distill the d=\r\n-esign intent of \"I'm a plain vanilla data holder with fields <code>x<\/code>=\r\n-, <code>y<\/code>, and <code>z<\/code>\" from the code. And, more importantly =\r\n-still, repetitive code is error-prone; boilerplate code gives bugs a place =\r\n-to hide.<\/p>\r\n-<h4 id=3D\"data-classes\">Data classes<\/h4>\r\n-<p>Other OO languages have explored syntactic forms for more compact class =\r\n-declaration: <code>case<\/code> classes in <a href=3D\"https:\/\/docs.scala-lan=\r\n-g.org\/tour\/case-classes.html\">Scala<\/a>, <code>data<\/code> classes in <a hr=\r\n-ef=3D\"https:\/\/kotlinlang.org\/docs\/reference\/data-classes.html\">Kotlin<\/a>, =\r\n-and soon, <code>record<\/code> classes in <a href=3D\"https:\/\/github.com\/dotn=\r\n-et\/roslyn\/blob\/features\/records\/docs\/features\/records.md\">C#<\/a>. These hav=\r\n-e in common that the some or all of the state of a class can be described d=\r\n-irectly directly in the class header (though they vary in their semantics, =\r\n-such as constraints on the mutability or accessibility of fields, extensibi=\r\n-lity of the class, and other restrictions.) Committing in the class declara=\r\n-tion to the relationship between state and interface enables suitable defau=\r\n-lts to be generated for various state-related members. All of these mechani=\r\n-sms (let's call them \"data classes\") seek to bring us closer to the goal of=\r\n- being able to define a plain XY <code>Point<\/code> class as:<\/p>\r\n-<pre><code>__data class Point(int x, int y) { }<\/code><\/pre>\r\n-<p>The clarity and compactness here is surely attractive -- this says that =\r\n-a <code>Point<\/code> is a carrier for two integer components <code>x<\/code>=\r\n- and <code>y<\/code>, and from that, the reader immediately knows that there=\r\n- are sensible <em>and correct<\/em> implementations for the core <code>Objec=\r\n-t<\/code> methods, and doesn't have to wade through a page of boilerplate to=\r\n- be able to confidently reason about their semantics. Most developers are g=\r\n-oing to say \"Well, of course I want <em>that<\/em>.\"<\/p>\r\n-<h4 id=3D\"meet-the-elephant\">Meet the elephant<\/h4>\r\n-<p>Unfortunately, such universal consensus is only syntax-deep; almost imme=\r\n-diately after we finish celebrating the concision, come the arguments about=\r\n- the natural semantics of such a construct, and what restrictions we are wi=\r\n-lling to accept. Are they extensible? Are the fields mutable? Can I control=\r\n- the behavior of the generated methods, or the accessibility of the fields?=\r\n- Can I have additional fields and constructors?<\/p>\r\n-<p>Just like the story of the blind men and the elephant, different develop=\r\n-ers are likely to bring very different assumptions about the \"obvious\" sema=\r\n-ntics of a data class. To bring these implicit assumptions into the open, l=\r\n-et's name the various positions.<\/p>\r\n-<p><em>Algebraic Annie<\/em> will say \"a data class is just an algebraic pro=\r\n-duct type.\" Like Scala's case classes, they come paired with pattern matchi=\r\n-ng, and are best served immutable. (And for dessert, Annie would order seal=\r\n-ed interfaces.)<\/p>\r\n-<p><em>Boilerplate Billy<\/em> will say \"a data class is just an ordinary cl=\r\n-ass with better syntax\", and will likely bristle at constraints on mutabili=\r\n-ty, extension, or encapsulation. (Billy's brother, JavaBean Jerry, will say=\r\n- \"these must be for JavaBeans -- so of course I get getters and setters too=\r\n-.\" And his sister, POJO Patty, remarks that she is drowning in enterprise P=\r\n-OJOs, and reminds us that she'd like these to be proxyable by frameworks li=\r\n-ke Hibernate.)<\/p>\r\n-<p><em>Tuple Tommy<\/em> will say \"a data class is just a nominal tuple\" -- =\r\n-and may not even be even expecting them to have methods other than the core=\r\n- <code>Object<\/code> methods -- they're just the simplest of aggregates. (H=\r\n-e might even expect the names to be erased, so that two data classes of the=\r\n- same \"shape\" can be freely converted.)<\/p>\r\n-<p><em>Values Victor<\/em> will say \"a data class is really just a more tran=\r\n-sparent value type.\"<\/p>\r\n-<p>All of these personae are united in favor of \"data classes\" -- but have =\r\n-different ideas of what data classes are, and there may not be any one solu=\r\n-tion that makes them all happy.<\/p>\r\n-<h4 id=3D\"understanding-the-problem\">Understanding the problem<\/h4>\r\n-<p>It is superficially tempting to treat this feature as being primarily ab=\r\n-out boilerplate reduction; after all, we're painfully aware of the state-re=\r\n-lated boilerplate we deal with every day. However, boilerplate is just a sy=\r\n-mptom of a deeper problem. Our main tool for data abstraction is classes, w=\r\n-hich are indeed a versatile tool. And the primary hammer of classes is <em>=\r\n-encapsulation<\/em>. Encapsulating our state (so it can't be manipulated dir=\r\n-ectly) and our representation (so we can change representation freely while=\r\n- maintaining the same API contract) gives us a lot of flexibility, and it e=\r\n-nables us to write code that can operate safely and robustly across a varie=\r\n-ty of <em>boundaries<\/em>:<\/p>\r\n-<ul>\r\n-<li>Maintenance boundaries -- when our clients are working in a different s=\r\n-ourcebase or organization;<\/li>\r\n-<li>Security and trust boundaries -- where we do not want to expose our sta=\r\n-te to clients because we do not fully trust them to not deliberately modify=\r\n- or use it in malicious ways;<\/li>\r\n-<li>Integrity boundaries -- where we do not want to expose our state to cli=\r\n-ents because, while we may trust their intent and are willing to share our =\r\n-data with them, we do not trust them to ensure that key invariants are main=\r\n-tained (or do not want to burden them with these concerns);<\/li>\r\n-<li>Versioning boundaries -- where we want to ensure that clients compiled =\r\n-against one version of a library continue to work when run against a subseq=\r\n-uent version.<\/li>\r\n-<\/ul>\r\n-<p>These benefits are significant -- indeed, essential -- for classes like =\r\n-<code>SocketInputStream<\/code>, but often less so for classes like <code>Po=\r\n-int<\/code>. Many classes are not concerned with defending any of these boun=\r\n-daries -- maybe it is private to a package or module and co-compiled with a=\r\n-ll its clients, trusts its clients, and has no complex invariants that we n=\r\n-eed to protect. Sadly, the cost of flexibility -- the need to spell everyth=\r\n-ing out explicitly (how to map constructor arguments to state, how to deriv=\r\n-e the equality contract from state, etc) -- is borne by all classes, but th=\r\n-e benefit is not shared so equally, pushing the cost-benefit balance out of=\r\n- line for classes that are less concerned with defending their boundaries. =\r\n-This is what Java developers mean by \"too much ceremony\" -- not that the ce=\r\n-remony has no value, but that they're forced to invoke it even when it does=\r\n- not offer sufficient value, and imposes additional costs (both machine and=\r\n- human.)<\/p>\r\n-<p>If we could say that a class was a <em>plain data carrier<\/em> for a giv=\r\n-en state vector, then we could provide sensible and correct defaults for st=\r\n-ate-related members like constructors, accessors, and <code>Object<\/code> m=\r\n-ethods. Since there's currently no way to say what we really mean, our only=\r\n- alternative is to get out our imperative hammer and start bashing. But \"pl=\r\n-ain\" domain classes are so common that it would be nice to capture this des=\r\n-ign decision directly in the code -- where readers and compilers alike coul=\r\n-d take advantage of it -- rather than simulating it imperatively (and there=\r\n-by obfuscating our design intent). So while boilerplate may be the symptom,=\r\n- the disease is that our code cannot directly capture our design intent, an=\r\n-d if we cure the disease, the boilerplate goes away. For these reasons, we =\r\n-believe it is better to treat this feature as being about <em>modeling pure=\r\n- data aggregates<\/em>, rather than about concision or boilerplate.<\/p>\r\n-<h2 id=3D\"digression----enums\">Digression -- enums<\/h2>\r\n-<p>If the problem is that we're modeling something simple with something ov=\r\n-erly general, simplification is going to come from constraint; by letting g=\r\n-o of some degrees of freedom, we hope to be freed of the obligation to spec=\r\n-ify everything explicitly.<\/p>\r\n-<p>The <code>enum<\/code> facility, added in Java 5, is an excellent example=\r\n- of such a tradeoff. The type-safe enum pattern was well understood, and ea=\r\n-sy to express (albeit verbosely), prior to Java 5 (see <a href=3D\"https:\/\/w=\r\n-ww.amazon.com\/gp\/product\/0321356683?ie=3DUTF8&amp;tag=3Dbriangoetz-20&amp;c=\r\n-amp=3D1789&amp;linkCode=3Dxm2&amp;creativeASIN=3D0321356683\">Effective Java=\r\n-, 1st Edition<\/a>, item 21.) The initial motivation to add enums to the lan=\r\n-guage might have been irritation at the boilerplate required for this idiom=\r\n-, but the real benefit is semantic.<\/p>\r\n-<p>The key simplification of enums was to constrain the lifecycle of enum i=\r\n-nstances -- enum constants are singletons, and the requisite instance contr=\r\n-ol is managed by the runtime. By baking singleton-awareness into the langua=\r\n-ge model, the compiler can safely and correctly generate the boilerplate ne=\r\n-eded for the type-safe enum pattern. And because enums started with a seman=\r\n-tic goal, rather than a syntactic one, it was possible for enums to interac=\r\n-t positively with other features, such as the ability to <code>switch<\/code=\r\n-> on enums.<\/p>\r\n-<p>Perhaps surprisingly, enums delivered their syntactic and semantic benef=\r\n-its without requiring us to give up most other degrees of freedom that clas=\r\n-ses enjoy; Java's enums are not mere enumerations of integers, as they are =\r\n-in many other languages, but instead are full-fledged classes, with unconst=\r\n-rained state and behavior, and even subtyping (though this is constrained t=\r\n-o interface inheritance only.)<\/p>\r\n-<h4 id=3D\"why-not-just-do-tuples\">Why not \"just\" do tuples?<\/h4>\r\n-<p>Some readers may feel at this point that if we \"just\" had tuples, we wou=\r\n-ldn't need data classes. And while tuples might offer a lighter-weight mean=\r\n-s to express some aggregates, the result is often inferior aggregates. A ce=\r\n-ntral aspect of the Java philosophy is that <em>names matter<\/em>; a <code>=\r\n-Person<\/code> with properties <code>firstName<\/code> and <code>lastName<\/co=\r\n-de> is clearer and safer than a tuple of <code>String<\/code> and <code>Stri=\r\n-ng<\/code>. The major pain of using named classes for aggregates is the synt=\r\n-actic overhead of declaring them; if we reduce this overhead, the temptatio=\r\n-n to reach for more weakly typed mechanisms is greatly reduced.<\/p>\r\n-<h2 id=3D\"towards-requirements-for-data-classes\">Towards requirements for d=\r\n-ata classes<\/h2>\r\n-<p>It's easy to claim a class is \"just a plain data carrier\", but what do w=\r\n-e mean by that? What degrees of freedom that classes enjoy do \"plain\" data =\r\n-aggregates not need, that we can eliminate and thereby simplify the model?<=\r\n-\/p>\r\n-<p>At one extreme, nobody thinks that <code>SocketInputStream<\/code> is \"ju=\r\n-st\" its data; it fully encapsulates some complex and unspecified state (inc=\r\n-luding a native resource) and exposes an interface contract that likely loo=\r\n-ks nothing like its internal representation.<\/p>\r\n-<p>At the other extreme, a class like<\/p>\r\n-<pre><code>final class Point {\r\n-    public final int x;\r\n-    public final int y;\r\n-\r\n-    public Point(int x, int y) {\r\n-        this.x =3D x;\r\n-        this.y =3D y;\r\n-    }\r\n-\r\n-    \/\/ state-based implementations of equals, hashCode, toString\r\n-    \/\/ nothing else<\/code><\/pre>\r\n-<p>}<\/p>\r\n-<p>is clearly \"just\" the data <code>(x, y)<\/code>. Its representation is <c=\r\n-ode>(x, y)<\/code>, its construction protocol accepts an <code>(x, y)<\/code>=\r\n- pair and stores it directly, and it provide unmediated access to its data.=\r\n- The combination of transparency and state-based equality means that a clie=\r\n-nt can extract the data carried by a <code>Point<\/code> and instantiate ano=\r\n-ther <code>Point<\/code> which is known to be valid and substitutible for th=\r\n-e original.<\/p>\r\n-<p>Let's formalize this notion of \"plain data carrier\" a bit, so we can use=\r\n- this to evaluate design decisions for a data class feature. We say a class=\r\n- <code>C<\/code> is a <em>transparent carrier<\/em> for a state vector <code>=\r\n-S<\/code> if:<\/p>\r\n-<ul>\r\n-<li>There is a function <em>ctor : S -&gt; C<\/em> which maps an instance of=\r\n- the state vector to an instance of <em>C<\/em>. (This function may be parti=\r\n-al; <em>ctor<\/em> may reject some state vectors as invalid, such as rationa=\r\n-l numbers whose denominator is zero.)<\/li>\r\n-<li>There is a total function <em>dtor : C -&gt; S<\/em> which maps an insta=\r\n-nce of <em>C<\/em> to a state vector <em>S<\/em> in the domain of <em>ctor<\/e=\r\n-m>.<\/li>\r\n-<li>For any instance <em>c<\/em> of <em>C<\/em>, <em>ctor(dtor(c)) equals c<\/=\r\n-em>, according to the <code>equals()<\/code> contract for <em>C<\/em>, and fu=\r\n-rther, that the composition <em>ctor(dtor(x))<\/em> is an <em>identity<\/em> =\r\n-on the codomain of <em>ctor<\/em>.<\/li>\r\n-<li>For two state vectors <em>s1<\/em> and <em>s2<\/em> in the domain of <em>=\r\n-ctor<\/em>, if each of their components is equal to the corresponding compon=\r\n-ent of the other (according to the component's <code>equals()<\/code> contra=\r\n-ct), then <em>ctor(s1) equals ctor(s2)<\/em>.<\/li>\r\n-<li>For any mutative operations of <em>C<\/em>, performing the same operatio=\r\n-n on equal instances of <em>C<\/em> results in equal instances of <em>C<\/em>=\r\n-.<\/li>\r\n-<\/ul>\r\n-<p>This means that <code>C<\/code> has a constructor (or factory) which acce=\r\n-pts the state vector <code>S<\/code>, and accessors (or a deconstruction pat=\r\n-tern) which produces the components of <code>S<\/code>, and that for any val=\r\n-id instance, extracting the state vector and then reconstructing an instanc=\r\n-e from that state vector produces an instance that is equivalent to the ori=\r\n-ginal. Similarly, constructing instances from equivalent state vectors prod=\r\n-uces equivalent instances, and applying the same mutative operation to equi=\r\n-valent instances preserves their equivalence. Such carriers are <em>transpa=\r\n-rent<\/em> -- their state can be freely from the outside (because clients ca=\r\n-n call the <em>dtor<\/em> function).<\/p>\r\n-<p>Together, these requirements say that there is a very simple relationshi=\r\n-p between the classes representation, its construction, and its destructuri=\r\n-ng. In other words, the API <em>is<\/em> the representation -- and both clie=\r\n-nt and compiler can safely assume this. A class that is a plain data carrie=\r\n-r is <em>the data, the whole data, and nothing but the data<\/em>.<\/p>\r\n-<p>Note that so far, we haven't said anything about syntax or boilerplate; =\r\n-we've only talked about constraining the semantics of the class to be a sim=\r\n-ple carrier for a specified state vector. But these constraints allow us to=\r\n- safely and mechanically generate the boilerplate for constructors, pattern=\r\n- extractors, accessors, <code>equals()<\/code>, <code>hashCode()<\/code>, and=\r\n- <code>toString()<\/code> -- and more.<\/p>\r\n-<h4 id=3D\"data-classes-and-pattern-matching\">Data classes and pattern match=\r\n-ing<\/h4>\r\n-<p>By saying that a data class is a transparent carrier for a publicly-spec=\r\n-ified state vector, rather than just a boilerplate-reduced class, we gain t=\r\n-he ability to freely convert a data class instance back and forth between i=\r\n-ts aggregate form and its state vector. This has a natural connection with =\r\n-<em>pattern matching<\/em>; by committing that a class is merely a carrier f=\r\n-or a state vector, there is an obvious deconstruction pattern -- whose sign=\r\n-ature is the dual of the constructor's -- which can be mechanically generat=\r\n-ed.<\/p>\r\n-<p>For example, suppose we have data classes as follows:<\/p>\r\n-<pre><code>interface Shape { }\r\n-__data class Point(int x, int y) { }\r\n-__data class Rect(Point p1, Point p2) implements Shape { }\r\n-__data class Circle(Point center, int radius) implements Shape { }<\/code><\/=\r\n-pre>\r\n-<p>A client can deconstruct a shape as follows:<\/p>\r\n-<pre><code>switch (shape) {\r\n-     case Rect(Point(var x1, var y1), Point(var x2, var y2)): ...\r\n-     case Circle(Point(var x, var y), int r): ...\r\n-     ....\r\n-}<\/code><\/pre>\r\n-<p>with the mechanically generated pattern extractors. This synergy between=\r\n- data classes and pattern matching makes each feature more expressive. Howe=\r\n-ver, a not-entirely-obvious consequence of this is that there is no such th=\r\n-ing as truly <code>private<\/code> fields in a data class; even if the field=\r\n-s were to be declared private, their values would still be implicitly reada=\r\n-ble via the destructuring pattern. This would be surprising if our design c=\r\n-enter for data class was that they are merely a boilerplate reduction tool =\r\n--- but is consistent with data classes being transparent carriers for their=\r\n- data.<\/p>\r\n-<h4 id=3D\"data-classes-and-externalization\">Data classes and externalizatio=\r\n-n<\/h4>\r\n-<p>Data classes are also a natural fit for safe, mechanical externalization=\r\n- (serialization, marshaling to and from JSON or XML, mapping to database ro=\r\n-ws, etc). If a class is a transparent carrier for a state vector, and the c=\r\n-omponents of that state vector can be externalized in the desired encoding,=\r\n- then the carrier can be safely and mechanically marshaled and unmarshaled =\r\n-with guaranteed fidelity, and without the security and integrity risks of b=\r\n-ypassing the constructor (as built-in serialization does). In fact, a trans=\r\n-parent carrier need not do anything special to support externalization; the=\r\n- externalization framework can deconstruct the object using its principal d=\r\n-econstructor, and reconstruct it using its principal constructor, which are=\r\n- already public.<\/p>\r\n-<h2 id=3D\"refining-the-design-space\">Refining the design space<\/h2>\r\n-<p>The requirements for being a \"plain data carrier\" represent a sensible t=\r\n-rade-off; by agreeing to transparently expose our representation and state,=\r\n- we gain safe and predictable implementations of constructors, <code>Object=\r\n-<\/code> methods, destructuring patterns, and externalization. Let's take th=\r\n-is as our starting point, and explore some other natural questions that com=\r\n-e up in the context of designing such a feature.<\/p>\r\n-<h4 id=3D\"overriding-default-members\">Overriding default members<\/h4>\r\n-<p>The default implementations of constructors and <code>Object<\/code> meth=\r\n-ods is likely to be what is desired in a lot of cases, but there may be cas=\r\n-es where we want to refine these further, such as a constructor that enforc=\r\n-es additional invariants, or an <code>equals()<\/code> method that compares =\r\n-array components by content rather than delegating to <code>Object.equals()=\r\n-<\/code>. (Allowing refined implementations expands the range of useful data=\r\n- classes, but also exposes us to the risk that the the explicit implementat=\r\n-ions won't conform to the requirements of a plain data carrier.)<\/p>\r\n-<h4 id=3D\"constructors\">Constructors<\/h4>\r\n-<p>In our definition, we said that construction could be a partial function=\r\n-, to allow constructors to enforce domain invariants (such as a \"range\" typ=\r\n-e ensuring that the lower bound doesn't exceed the upper bound). Data class=\r\n-es without representational invariants should not require an explicit const=\r\n-ructor, but ideally it should be possible to specify an explicit constructo=\r\n-r that enforces invariants -- without having to write out all the construct=\r\n-or boilerplate out by hand.<\/p>\r\n-<p>Data classes clearly need a constructor whose signature matches that of =\r\n-the state vector (call this the <em>principal constructor<\/em>); otherwise,=\r\n- the class would not be merely a carrier for its state vector, as we couldn=\r\n-'t freely deconstruct and reconstruct it. Can a data class have additional =\r\n-constructors too? This seems reasonable -- if they are merely convenience i=\r\n-mplementations that delegate to the principal constructor.<\/p>\r\n-<h4 id=3D\"ancillary-fields\">Ancillary fields<\/h4>\r\n-<p>Related to the previous item is the question of whether the state vector=\r\n- describes <em>all<\/em> the state of the class, or merely some distinguishe=\r\n-d subset of it. While at first it might seem reasonable to allow additional=\r\n- fields, these also constitute a slippery slope away from the design center=\r\n- of \"plain data carrier.\" If there were ancillary fields that affect the be=\r\n-havior of <code>equals()<\/code> or <code>hashCode()<\/code>, then this will =\r\n-almost certainly violate the requirement that deconstructing a carrier and =\r\n-reconstructing it yields an equivalent instance.<\/p>\r\n-<p>Similarly, if they affected the behavior of mutative methods, this would=\r\n- undermine the requirement that performing identical actions on equal carri=\r\n-ers results in equal carriers. So while there are legitimate uses for ancil=\r\n-lary variables (primarily caching state derived from the state vector), anc=\r\n-illary fields come with the risk of violating the spirit of \"the state, the=\r\n- whole state, and nothing but the state.\"<\/p>\r\n-<h4 id=3D\"extension\">Extension<\/h4>\r\n-<p>Can a data class extend an ordinary class? Can a data class extend anoth=\r\n-er data class? Can a non-data class extend a data class? Again, let's evalu=\r\n-ate these through our definition of plain data carrier.<\/p>\r\n-<p>Extension between data classes and non-data classes, or between concrete=\r\n- data classes, seems immediately problematic. If a data class extends an or=\r\n-dinary class, we would have no control over the <code>equals()<\/code> contr=\r\n-act of the superclass, and therefore no reason to believe that the desired =\r\n-invariants hold.<\/p>\r\n-<p>Similarly, if another class (data or not) were to extend a data class, w=\r\n-e'd almost certainly violate the desired invariants. Consider:<\/p>\r\n-<pre><code>__data class C(STATE_VECTOR) { }\r\n-class D extends C { ... }\r\n-\r\n-D d =3D ...\r\n-switch (d) {=20\r\n-    case C(var STATE_VECTOR): assert d.equals(new C(STATE_VECTOR));\r\n-    ...\r\n-}<\/code><\/pre>\r\n-<p>Deconstructing a <code>C<\/code> into its state and then reconstructing i=\r\n-t into a carrier should yield an equivalent instance -- but in this case, i=\r\n-t will not. D is not a plain carrier for C's state vector, as it has at lea=\r\n-st some additional typestate, and perhaps some additional state and behavio=\r\n-r as well, which may cause the equality check to fail.<\/p>\r\n-<h4 id=3D\"mutability\">Mutability<\/h4>\r\n-<p>One of the thorniest problems is whether we allow mutability, and how we=\r\n- handle the consequences if we do. The simplest solution -- and surely a te=\r\n-mpting one -- is to insist that state components of data classes be <code>f=\r\n-inal<\/code>. While this is an attractive opening position, this may ultimat=\r\n-ely be too limiting; while immutable data is surely better-behaved than mut=\r\n-able data, mutable data certainly qualifies as \"data\", and there are many l=\r\n-egitimate uses for mutable \"plain data\" aggregates. (And, even if we requir=\r\n-ed that data class fields always be <code>final<\/code>, this only gives us =\r\n-shallow immutability -- we still have to deal with the possibility that the=\r\n- contents are more deeply mutable.)<\/p>\r\n-<p>It is worth noting that similar languages that went down the data-class =\r\n-path -- including Scala, Kotlin, and C# -- all settled on not forcing data =\r\n-classes to be immutable, though its almost certain that their designers ini=\r\n-tially considered doing so. (Even if we allow mutability, we still have the=\r\n- option of nudging users towards finality, say by making the default for da=\r\n-ta class fields <code>final<\/code>, and providing a way to opt out of final=\r\n-ity for individual fields.)<\/p>\r\n-<h4 id=3D\"field-encapsulation\">Field encapsulation<\/h4>\r\n-<p>Related to the problem of mutability is whether fields can be individual=\r\n-ly encapsulated. There are several reasons why one might want to encapsulat=\r\n-e fields, even if we've given up on decoupling the representation from the =\r\n-API:<\/p>\r\n-<ul>\r\n-<li>To protect integrity boundaries (rejecting writes that would violate re=\r\n-presentational invariants);<\/li>\r\n-<li>To detect when writes have happened, so that listeners can be notified =\r\n-or cached state can be adjusted;<\/li>\r\n-<li>To make defensive copies on reads, such as for array components.<\/li>\r\n-<\/ul>\r\n-<p>All are related, directly or indirectly, to mutability. If data class fi=\r\n-elds are <code>final<\/code>, once the constructor establishes the invariant=\r\n-s, they cannot be undermined, and if there are no writes, there's no need t=\r\n-o take any action on writes. Similarly, only if data class state is deeply =\r\n-mutable (such as for array components) would we need to consider defensive =\r\n-copies. Absent any concern about deep mutability, if data class fields are =\r\n-<code>final<\/code>, there's no reason for them to not also be <code>public<=\r\n-\/code> (since we've already given up on the ability to compatibly change th=\r\n-e representation across maintenance boundaries.) And, even if fields are mu=\r\n-table, if they do not participate in any invariants (no integrity boundarie=\r\n-s) and are confined to a package or module (no maintenance or trust boundar=\r\n-ies), then it might well be reasonable for mutable fields to be public as w=\r\n-ell.<\/p>\r\n-<p>The primary remaining motivation for encapsulating fields, then, is to l=\r\n-imit writes to those fields when sharing instances across trust or integrit=\r\n-y boundaries. Any support for state encapsulation should focus on these asp=\r\n-ects alone.<\/p>\r\n-<h4 id=3D\"accessors\">Accessors<\/h4>\r\n-<p>No discussion involving boilerplate (or any question of Java language ev=\r\n-olution, for that matter) can be complete without the subject of field acce=\r\n-ssors (and properties) coming up. On the one hand, accessors constitute a s=\r\n-ignificant portion of boilerplate in existing code; on the other hand, the =\r\n-JavaBean-style getter\/setter conventions are already badly overused. (Immut=\r\n-able classes could forgo accessors in favor of public final fields, as long=\r\n- as they're not worried about maintenance boundaries. Even mutable classes =\r\n-without state invariants could get away with public mutable fields instead =\r\n-of accessors -- again as long as they're not worried about maintenance boun=\r\n-daries. These two cases already cover a large proportion of the candidates =\r\n-for data classes.)<\/p>\r\n-<p>If it turns out to make sense to support mutable fields, it probably als=\r\n-o make sense to support write-encapsulation of those fields to defend integ=\r\n-rity boundaries. But we should be mindful of the purpose of these accessors=\r\n-; it is not to abstract the representation from the API, but merely to enab=\r\n-le rejection of bad values, and provide syntactic uniformity of access.<\/p>\r\n-<p>Without rehashing the properties debate, one fundamental objection to au=\r\n-tomating JavaBean-style field accessors is that it would take what is at be=\r\n-st a questionable (and certainly overused) API naming convention and burn i=\r\n-t into the language. Unlike the core methods like <code>Object.equals()<\/co=\r\n-de>, field accessors do not have any special treatment in the language, and=\r\n- so names of the form <code>getSize()<\/code> should not either. (Also, whil=\r\n-e tedious, writing (and reading) accessor declarations are not nearly as er=\r\n-ror-prone as <code>equals()<\/code>.)<\/p>\r\n-<h4 id=3D\"arrays-and-defensive-copies\">Arrays and defensive copies<\/h4>\r\n-<p>Array-valued fields are particularly problematic, as there is no way to =\r\n-make them deeply immutable. But they're really just a special case of mutab=\r\n-le objects which do not provide unmodifiable views. APIs that encapsulate a=\r\n-rrays frequently make defensive copies when they're on the other side of a =\r\n-trust boundary from their users. Should data classes support this? Unfortun=\r\n-ately, this also falls afoul of our requirements for data classes.<\/p>\r\n-<p>Because the <code>equals()<\/code> method of arrays is inherited from <co=\r\n-de>Object<\/code>, which compares instances by identity, making defensive co=\r\n-pies of array components in read accessors would violate the invariant that=\r\n- destructuring an instance of a data class and reconstructing it yields an =\r\n-equivalent instance -- the defensive copy and the original array will not b=\r\n-e equal to each other. (Arrays are simply a bad fit for data classes, as th=\r\n-ey are mutable, but unlike <code>List<\/code> their <code>equals()<\/code> me=\r\n-thod is based on identity.) We'd rather not distort data classes to accomod=\r\n-ate arrays, especially as there are ample alternatives available.<\/p>\r\n-<h4 id=3D\"thread-safety\">Thread-safety<\/h4>\r\n-<p>Allowing mutable state in data classes raises the question of whether, a=\r\n-nd how, they can be made thread-safe. (Note that thread-safety is not a req=\r\n-uirement for mutable classes; many useful classes, such as <code>ArrayList<=\r\n-\/code>, are not thread-safe.) Thread-safe classes encapsulate a protocol fo=\r\n-r coordinating access to their shared mutable state. But, data classes disa=\r\n-vow most forms of encapsulation. (Immutable objects are implicitly thread-s=\r\n-afe, because there is no shared mutable state to which access need be coord=\r\n-inated.)<\/p>\r\n-<p>Like most non-thread-safe classes, instances of mutable data classes can=\r\n- still be used safely in concurrent environments through <em>confinement<\/e=\r\n-m>, where the data class instance is encapsulated within a thread-safe clas=\r\n-s. While it might be possible to nibble around the edges to support a few u=\r\n-se cases, ultimately data classes are not going to be the right tool for cr=\r\n-eating thread-safe mutable classes, and rather than reinventing all the fle=\r\n-xibility of classes in a new syntax, we should probably just guide people t=\r\n-o writing ordinary classes in these cases.<\/p>\r\n-<h4 id=3D\"data-classes-and-value-types\">Data classes and value types<\/h4>\r\n-<p>With <em>value types<\/em> coming down the road through <a href=3D\"http:\/=\r\n-\/openjdk.java.net\/projects\/valhalla\/\">Project Valhalla<\/a>, it is reasonabl=\r\n-e to ask about the overlap between immutable data classes and value types, =\r\n-as well as whether the intersection of data-ness and value-ness is a useful=\r\n- space to inhabit.<\/p>\r\n-<p>Value types are primarily about enabling <em>flat<\/em> and <em>dense<\/em=\r\n-> layout of object in memory. The central sacrifice of value types is <em>o=\r\n-bject identity<\/em>; in exchange for giving up object identity (which means=\r\n- giving up mutability and layout polymorphism), we can elide object headers=\r\n- and can inline values directly into the layout of other values, objects, a=\r\n-nd arrays, and freely hoist values out of the heap and onto the stack or in=\r\n-to registers. The lack of layout polymorphism means we have to give up some=\r\n-thing else: self-reference. A value type <code>V<\/code> cannot refer, direc=\r\n-tly or indirectly, to another unboxed <code>V<\/code>. But value classes nee=\r\n-d not give up any encapsulation, and in fact encapsulation is essential for=\r\n- some applications of value types (such as references to native resources.)=\r\n-<\/p>\r\n-<p>On the other hand, data classes instances have identity, which supports =\r\n-mutability (maybe) but also supports self-reference. Unlike value types, da=\r\n-ta class instances are entirely suited to representing self-referential gra=\r\n-phs.<\/p>\r\n-<p>Each of these simplified class forms -- values and data classes -- invol=\r\n-ves accepting certain restrictions in exchange for certain benefits. If we'=\r\n-re willing to accept both sets of restrictions, we get both sets of benefit=\r\n-s; the notion of a \"value data class\" is perfectly sensible for things like=\r\n- extended numerics or tuples.<\/p>\r\n-<h4 id=3D\"compatibility-and-migration\">Compatibility and migration<\/h4>\r\n-<p>It is important that existing classes that meet the requirements for dat=\r\n-a classes (or are willing to do so) should be able to be compatibly migrate=\r\n-d to data classes, so that the many existing classes that are candidate for=\r\n- being data classes can benefit from the semantic transparency and syntacti=\r\n-c concision of data classes. Similarly, it is important to be able to do th=\r\n-e reverse, so that data classes can be compatibly refactored into regular c=\r\n-lasses if they evolve to outgrow the constraints of data classes.<\/p>\r\n-<p>If an existing class which meets the requirements wants to migrate to be=\r\n- a data class, it should be able to do so by simply exposing its state thro=\r\n-ugh the class header and removing redundant field, constructor, and <code>O=\r\n-bject<\/code> method declarations. Similarly, if a data class wants to migra=\r\n-te to be a full-blown class, it should be able to do so by providing explic=\r\n-it declarations of its fields, constructors, and <code>Object<\/code> method=\r\n-s (and, when explicit pattern extractors are supported, pattern extractors)=\r\n-. Both of these migrations should be source- and binary-compatible; it is t=\r\n-he responsibility of the developer to ensure that they are behaviorally com=\r\n-patible.<\/p>\r\n-<p>Once a data class is published, however, changing the state description =\r\n-will have compatibility consequences for clients that are outside the maint=\r\n-enance boundary. The binary- and source- compatibility impact of such chang=\r\n-es can be partially mitigated by declaring new constructors and pattern mat=\r\n-ch extractors that follow the old state description (so that existing clien=\r\n-ts can construct and deconstruct them), but depending on existing usage, it=\r\n- may be hard to mitigate the behavioral compatibility issues, as the result=\r\n-ing class may well fall afoul of the various invariants of plain data carri=\r\n-ers from the perspective of legacy clients, such as the deconstructing and =\r\n-reconstructing a data class using an old state vector. For data classes ope=\r\n-rating within a maintenance boundary, it may be practical to compatibly ref=\r\n-actor both a data class and its clients when changing the state description=\r\n-.<\/p>\r\n-<h2 id=3D\"a-concrete-proposal\">A concrete proposal<\/h2>\r\n-<p>Now that we have a good idea of what it is to \"just\" be a data carrier, =\r\n-what is it that we give up? Primarily, we are disavowing several key uses o=\r\n-f encapsulation: the ability to decouple a classes interface from its repre=\r\n-sentation, and to hide state from curious readers. (The main form of encaps=\r\n-ulation we retain is the ability to control modifications to the state.) Fu=\r\n-rther, we are committing to a state-based interpretation of the core <code>=\r\n-Object<\/code> methods, and that any methods on the data class be a pure fun=\r\n-ction of its arguments and the class state.<\/p>\r\n-<p>What <em>don't<\/em> we have to give up to get this? Quite a lot. Data cl=\r\n-asses can be generic, can implement interfaces, can have static fields, and=\r\n- can have constructors and methods, all without compromising this committme=\r\n-nts. To start, let's say that<\/p>\r\n-<pre><code>__data class Point(int x, int y) { }<\/code><\/pre>\r\n-<p>desugars to<\/p>\r\n-<pre><code>final class Point extends java.lang.DataClass {\r\n-    final int x;\r\n-    final int y;\r\n-   =20\r\n-    public Point(int x, int y) {\r\n-        this.x =3D x;\r\n-        this.y =3D y;\r\n-    }\r\n-\r\n-    \/\/ destructuring pattern for Point(int x, int y)\r\n-    \/\/ state-based equals, hashCode, and toString\r\n-    \/\/ public read accessors for x and y\r\n-}<\/code><\/pre>\r\n-<p>Any interfaces implemented by the data class are lifted onto the desugar=\r\n-ed class in the obvious way, as are any type variables, static fields, stat=\r\n-ic methods, and instance methods. If the data class provides an explicit im=\r\n-plementation of any of the implicit members (constructor, pattern extractor=\r\n-, <code>equals()<\/code>, <code>hashCode()<\/code>, <code>toString()<\/code>),=\r\n- it is used in place of the implicit member (but the explicit member must o=\r\n-bey the stronger contract of these members for data classes, which will be =\r\n-specified in the <code>DataClass<\/code> superclass.)<\/p>\r\n-<p><strong>Constructors.<\/strong> If the data class imposes no invariants, =\r\n-no constructor declaration is needed, and the class acquires a constructor =\r\n-whose signature is that of the data class (the principal constructor). Addi=\r\n-tional constructors may be explicitly declared -- but they must delegate to=\r\n- the principal constructor. The principal constructor may also be explicitl=\r\n-y declared, but it too must delegate to the default principal constructor, =\r\n-as in:<\/p>\r\n-<pre><code>__data class Range(int lo, int hi) {\r\n-\r\n-    \/\/ Explicit principal constructor\r\n-    public Range(int lo, int hi) {\r\n-        \/\/ validation logic\r\n-        if (lo &gt; hi)\r\n-            throw new IllegalArgumentException(...);\r\n-           =20\r\n-        \/\/ delegate to default constructor\r\n-        default(lo, hi);\r\n-    }\r\n-}<\/code><\/pre>\r\n-<p>The <code>default()<\/code> call invokes the default constructor that wou=\r\n-ld otherwise have been auto-generated for this data class (including the de=\r\n-fault <code>super<\/code> constructor); this avoids the need to write out th=\r\n-e tedious and error-inviting sequence of <code>this.x =3D x<\/code> assignme=\r\n-nts. Similarly, the explicit constructor may mutate its arguments to saniti=\r\n-ze \/ normalize \/ copy them, and pass the copies to the default constructor.=\r\n- (The rules about statements preceding calls to <code>super<\/code> or <code=\r\n->this<\/code> constructors can be relaxed, and the <code>this<\/code> referen=\r\n-ce treated as <em>definitely unassigned<\/em> for statements preceding the <=\r\n-code>default<\/code> or <code>this<\/code> call.)<\/p>\r\n-<p><strong>Fields.<\/strong> Given a data class<\/p>\r\n-<pre><code>__data class Foo(int x, int y) { ... }<\/code><\/pre>\r\n-<p>we will lift the state components <code>(int x, int y)<\/code> onto field=\r\n-s of <code>Foo<\/code> -- along with any annotations specified on the state =\r\n-components. The Javadoc for data classes will allow class parameters to be =\r\n-documented with the <code>@param<\/code> tag, as method parameters are now.<=\r\n-\/p>\r\n-<p>The most restrictive approach would be that fields are always final; we =\r\n-could also consider making them final by default, but allowing mutability t=\r\n-o be supported by opting in via a mutability modifier (<code>non-final<\/cod=\r\n-e>, <code>unfinal<\/code>, <code>mutable<\/code> -- bikeshed to be painted la=\r\n-ter.) Similarly, the most restrictive approach would be for them to always =\r\n-have <code>package<\/code> accessibility (or <code>protected<\/code> for fiel=\r\n-ds of abstract data class); a less restrictive approach would be to treat t=\r\n-hese as defaults, but allow them to optionally be declared <code>public<\/co=\r\n-de>.<\/p>\r\n-<p>With respect to additional fields beyond those in the state description,=\r\n- the most restrictive approach would be to prohibit them. While there are s=\r\n-ome legitimate use cases for encapsulated private fields that do not violat=\r\n-e the requirements (mostly having to do with caching derived properties of =\r\n-the state vector), the risk that this state flows into equality or other se=\r\n-mantics is high, bringing us away from the design center of \"plain carrier =\r\n-for the state vector.\"<\/p>\r\n-<p><strong>Extension.<\/strong> We've already noted that arbitrary extension=\r\n- is problematic, but it should be practical to maintain inheritance from ab=\r\n-stract data classes to other data classes. A sensible balance regarding ext=\r\n-ension is:<\/p>\r\n-<ul>\r\n-<li>Non-abstract data classes are final;<\/li>\r\n-<li>Data classes can be abstract (in which case they acquire no <code>equal=\r\n-s()<\/code>, <code>hashCode()<\/code>, or <code>toString()<\/code> methods, an=\r\n-d all constructors must be <code>protected<\/code>);<\/li>\r\n-<li>Data classes can extend abstract data classes;<\/li>\r\n-<li>No restrictions on what interfaces a data class could implement.<\/li>\r\n-<\/ul>\r\n-<p>This allows us to declare families of algebraic data types, such as the =\r\n-following partial hierarchy describing an arithmetic expression:<\/p>\r\n-<pre><code>interface Node { }\r\n-\r\n-abstract __data class BinaryOpNode(Node left,=20\r\n-                                   Node right)=20\r\n-    implements Node { }\r\n-\r\n-__data class PlusNode(Node left, Node right)=20\r\n-      extends BinaryOperatorNode(left, right) { }\r\n-\r\n-__data class MulNode(Node left, Node right)=20\r\n-      extends BinaryOperatorNode(left, right) { }\r\n-     =20\r\n-__data class IntNode(int constant) implements Node { }<\/code><\/pre>\r\n-<p>When a data class extends an abstract data class, the state description =\r\n-of the superclass must be a prefix of the state description of the subclass=\r\n-:<\/p>\r\n-<pre><code>abstract __data class Base(int x) { }\r\n-__data class Sub(int x, int y) extends Base(x) { }<\/code><\/pre>\r\n-<p>The arguments to the <code>extends Base()<\/code> clause is a list of <em=\r\n->names<\/em> of state components of <code>Sub<\/code>, not arbitrary expressi=\r\n-ons, must be a prefix of the state description of <code>Sub<\/code>, and mus=\r\n-t match the state description of <code>Base<\/code>; this suppresses the loc=\r\n-al declaration of inherited fields, and also plays into the generation of t=\r\n-he default principal constructor (which arguments are passed up to which su=\r\n-perclass constructor, vs. which are used to initialize local fields.) These=\r\n- rules are sufficient for implementing algebraic data type hierarchies like=\r\n- the <code>Node<\/code> example above.<\/p>\r\n-<p><strong>Accessors.<\/strong> Data classes are transparent; they readily g=\r\n-ive up their state through the destructuring pattern. To make this explicit=\r\n-, and to support the <em>uniform access principle<\/em> for state, data clas=\r\n-ses implicitly acquire public read accessors for all state components, whos=\r\n-e name is the same as the state component. (We will separately explore a mo=\r\n-re general mechanism for accessors which can be used by arbitrary classes; =\r\n-when such a mechanism is available, data classes will be able to customize =\r\n-the name to suit the conventions they prefer by explicitly using this mecha=\r\n-nism.) If write accessors are desired, they can be provided explicitly -- d=\r\n-ata classes will not bring these automatically.<\/p>\r\n-<p><strong>Reflection.<\/strong> While our implementation is essentially a d=\r\n-esugaring into a mostly ordinary class with fields and methods, we don't ac=\r\n-tually want to erase the data-ness completely; compilers need to be able to=\r\n- identify which classes are data classes, and what their state descriptions=\r\n- are, so they can enforce any restrictions on how they interact with other =\r\n-classes -- so this information must be present in the class file. This can =\r\n-be reflected on <code>Class<\/code> with methods such as <code>isDataClass()=\r\n-<\/code> and a method to return the ordered list of fields that are the clas=\r\n-ses state vector.<\/p>\r\n-<h2 id=3D\"summary\">Summary<\/h2>\r\n-<p>The key question in designing a facility for \"plain data aggregates\" in =\r\n-Java is identifying which degrees of freedom we are willing to give up. If =\r\n-we try to model all the degrees of freedom of classes, we just move the com=\r\n-plexity around; to gain some benefit, we must accept some constraints. We t=\r\n-hink that the sensible constraints to accept are disavowing the use of enca=\r\n-psulation for decoupling representation from API, and for mediating read ac=\r\n-cess to state.<\/p>\r\n-\r\n-\r\n-<\/body><\/html>\r\n-------MultipartBoundary--jiLwVqYekGDIUiF4larjHK4zCL8rSBJV7q2jwUQbvt----\r\n-Content-Type: text\/css\r\n-Content-Transfer-Encoding: quoted-printable\r\n-Content-Location: cid:css-e0158a3a-f3a5-43c6-94e0-06ecafcf18b4@mhtml.blink\r\n-\r\n-@charset \"utf-8\";\r\n-\r\n-code { white-space: pre; }\r\n-------MultipartBoundary--jiLwVqYekGDIUiF4larjHK4zCL8rSBJV7q2jwUQbvt----\r\n-Content-Type: text\/css\r\n-Content-Transfer-Encoding: quoted-printable\r\n-Content-Location: cid:css-1bdf0aa7-4770-484a-b235-9a8f642dd18f@mhtml.blink\r\n-\r\n-@charset \"utf-8\";\r\n-\r\n-a { text-decoration: none; }\r\n-\r\n-a:link, a:visited { color: rgb(67, 114, 145); }\r\n-\r\n-a:visited { color: rgb(102, 102, 102); }\r\n-\r\n-a[href]:hover { color: rgb(231, 111, 0); }\r\n-\r\n-a img { border-width: 0px; }\r\n-\r\n-img { background: white; }\r\n-\r\n-a.internal { color: rgb(187, 0, 0); }\r\n-\r\n-a[name] { color: black; }\r\n-\r\n-body { background: white; margin: 2em 2em 100%; font-size: medium; width: 4=\r\n-0em; }\r\n-\r\n-body { font-family: \"Bitstream Vera Sans\", Verdana, \"sans serif\"; }\r\n-\r\n-pre { font-family: monospace; }\r\n-\r\n-code { font-family: \"courier new\", monospace; font-size: medium; font-weigh=\r\n-t: bold; }\r\n-\r\n-p { margin: 1ex 0em; }\r\n-\r\n-pre { margin: 1.5ex 2em; }\r\n-\r\n-blockquote { margin: 1.5ex 2em; }\r\n-\r\n-li blockquote { margin-left: 0em; }\r\n-\r\n-li { margin: 0ex 0em; }\r\n-\r\n-.todo { color: darkred; text-align: right; }\r\n-\r\n-table, th, td { border: 2px solid gray; padding: 2px; }\r\n-\r\n-table { border-collapse: collapse; }\r\n-\r\n-td { vertical-align: top; }\r\n-\r\n-ul li { list-style-type: square; }\r\n-\r\n-div.summary { margin: 2ex 2em; }\r\n-\r\n-div.head { margin-bottom: 2em; }\r\n-\r\n-div.doctitle { font-size: x-large; font-weight: bold; }\r\n-\r\n-div.twarn { color: rgb(204, 0, 0); font-size: smaller; font-weight: bold; m=\r\n-argin-bottom: 1.5ex; }\r\n-\r\n-div.authors { margin-top: 1ex; font-size: large; }\r\n-\r\n-div.author a { font-style: italic; }\r\n-\r\n-div.version { font-size: medium; margin-top: 1ex; }\r\n-\r\n-div.copyright, div.comments { font-size: small; }\r\n-\r\n-div.version span.modified { color: green; font-weight: bold; }\r\n-\r\n-div.head div.notes { margin-top: 1ex; }\r\n-\r\n-p.subsection { margin-top: 2ex; }\r\n-\r\n-p.subsection:first-child { margin-top: 1ex; }\r\n-\r\n-p span.title { font-weight: bold; padding-right: 1em; }\r\n-\r\n-hr { border-width: 1px 0px 0px; border-right-style: initial; border-bottom-=\r\n-style: initial; border-left-style: initial; border-right-color: initial; bo=\r\n-rder-bottom-color: initial; border-left-color: initial; border-image: initi=\r\n-al; border-top-style: solid; border-top-color: black; margin: 2ex 0em; }\r\n-\r\n-div.qa { margin-top: 2ex; }\r\n-\r\n-h1 { font-size: x-large; }\r\n-\r\n-h2 { font-size: large; margin-top: 3ex; margin-bottom: 0ex; }\r\n-\r\n-pre { width: 60em; padding: 1px 1ex; background: rgb(232, 232, 232); font-s=\r\n-ize: smaller; }\r\n-\r\n-pre.jvm { font-style: italic; }\r\n-------MultipartBoundary--jiLwVqYekGDIUiF4larjHK4zCL8rSBJV7q2jwUQbvt------\r\n+<!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\" \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\">\n+<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\">\n+<head>\n+  <meta http-equiv=\"Content-Type\" content=\"text\/html; charset=utf-8\" \/>\n+  <meta http-equiv=\"Content-Style-Type\" content=\"text\/css\" \/>\n+  <meta name=\"generator\" content=\"pandoc\" \/>\n+  <title><\/title>\n+  <style type=\"text\/css\">code{white-space: pre;}<\/style>\n+      <style type=\"text\/css\">\n+        @import url('\/.fonts\/dejavu.css');\n+        A { text-decoration: none; }\n+        A:link, A:visited { color: #437291; }\n+        A:visited { color: #666666; }\n+        A[href]:hover { color: #e76f00; }\n+        A IMG { border-width: 0px; }\n+        IMG { background: white; }\n+        A.internal { color: #b00; }\n+        A[name] { color: black; }\n+  \n+        BODY {\n+          background: white;\n+          margin: 2em;\n+          font-size: medium;\n+          width: 40em;\n+          margin-bottom: 100%;\n+        }\n+        BODY { font-family: DejaVu Sans, Bitstream Vera Sans, Verdana, sans serif; }\n+        PRE { font-family: monospace; }\n+        CODE { font-family: DejaVu Sans Mono, Bitstream Vera Sans Mono, Monaco,\n+               courier new, monospace; font-size: medium; }\n+  \n+        P { margin: 1ex 0em; }\n+        PRE { margin: 1.5ex 2em; }\n+        BLOCKQUOTE { margin: 1.5ex 2em; }\n+        LI BLOCKQUOTE { margin-left: 0em; }\n+        LI { margin: 0ex 0em; }\n+        .todo { color: darkred; text-align: right; }\n+  \n+        TABLE, TH, TD { border: 2px solid gray; padding: 2px; }\n+        TABLE { border-collapse: collapse; }\n+        TD { vertical-align: top; }\n+  \n+        UL LI { list-style-type: square; }\n+  \n+        DIV.summary { margin: 2ex 2em; }\n+  \n+        DIV.head { margin-bottom: 2em; }\n+        DIV.doctitle { font-size: x-large; font-weight: bold; }\n+        DIV.twarn { color: #cc0000; font-size: smaller; font-weight: bold;\n+                    margin-bottom: 1.5ex; }\n+        DIV.authors { margin-top: 1ex; font-size: large; }\n+        DIV.author A { font-style: italic; }\n+        DIV.version { font-size: medium; margin-top: 1ex; }\n+        DIV.copyright, DIV.comments { font-size: small; }\n+        DIV.version SPAN.modified { color: green; font-weight: bold; }\n+        DIV.head DIV.notes { margin-top: 1ex; }\n+  \n+        P.subsection { margin-top: 2ex; }\n+        P.subsection:first-child { margin-top: 1ex; }\n+        P SPAN.title { font-weight: bold; padding-right: 1em; }\n+  \n+        HR { border: 0px; border-top: 1px solid black; margin: 2ex 0em; }\n+  \n+        DIV.qa { margin-top: 2ex; }\n+  \n+        H1 { font-size: x-large; }\n+        H2 { font-size: large; margin-top: 3ex; margin-bottom: 0ex; }\n+  \n+        PRE {\n+          width: 60em;\n+          padding: 1px 1ex;\n+          font-size: smaller;\n+          ZZdisplay: none;\n+        }\n+  \n+        PRE.jvm { font-style: italic; }\n+     <\/style>\n+<\/head>\n+<body>\n+  <h2>THIS DOCUMENT HAS BEEN SUPERSEDED AND IS PROVIDED FOR HISTORICAL CONTEXT ONLY<\/h2>\n+<h1 id=\"data-classes-for-java\">Data Classes for Java<\/h1>\n+<h4 id=\"brian-goetz-october-2017\">Brian Goetz, October 2017<\/h4>\n+<p>This document explores possible directions for <em>data classes<\/em> in the Java Language. This is an exploratory document only and does not constitute a plan for any specific feature in any specific version of the Java Language.<\/p>\n+<h2 id=\"background\">Background<\/h2>\n+<p>It is a common (and often deserved) complaint that &quot;Java is too verbose&quot; or has too much &quot;ceremony.&quot; A significant contributor to this is that while classes can flexibly model a variety of programming paradigms, this invariably comes with modeling overheads -- and in the case of classes that are nothing more than &quot;plain data carriers&quot;, the modeling overhead can be substantial. To write such a class responsibly, one has to write a lot of low-value, repetitive code: constructors, accessors, <code>equals()<\/code>, <code>hashCode()<\/code>, <code>toString()<\/code>, and possibly others, such as <code>compareTo()<\/code>. And because this is burdensome, developers may be tempted to cut corners such as omitting these important methods, leading to surprising behavior or poor debuggability, or press an alternate but not entirely appropriate class into service because it has the &quot;right shape&quot; and they don't want to define yet another class.<\/p>\n+<p>There's no doubt that writing the usual boilerplate code for these members is annoying (especially as it seems so unnecessary.) Even though IDEs will generate much of this for you, it's still irritating -- a class with only a few lines of real semantic content takes dozens of lines of code -- but more importantly, the IDEs don't help the <em>reader<\/em> to distill the design intent of &quot;I'm a plain vanilla data holder with fields <code>x<\/code>, <code>y<\/code>, and <code>z<\/code>&quot; from the code. And, more importantly still, repetitive code is error-prone; boilerplate code gives bugs a place to hide.<\/p>\n+<h4 id=\"data-classes\">Data classes<\/h4>\n+<p>Other OO languages have explored syntactic forms for more compact class declaration: <code>case<\/code> classes in <a href=\"https:\/\/docs.scala-lang.org\/tour\/case-classes.html\">Scala<\/a>, <code>data<\/code> classes in <a href=\"https:\/\/kotlinlang.org\/docs\/reference\/data-classes.html\">Kotlin<\/a>, and soon, <code>record<\/code> classes in <a href=\"https:\/\/github.com\/dotnet\/roslyn\/blob\/features\/records\/docs\/features\/records.md\">C#<\/a>. These have in common that the some or all of the state of a class can be described directly directly in the class header (though they vary in their semantics, such as constraints on the mutability or accessibility of fields, extensibility of the class, and other restrictions.) Committing in the class declaration to the relationship between state and interface enables suitable defaults to be generated for various state-related members. All of these mechanisms (let's call them &quot;data classes&quot;) seek to bring us closer to the goal of being able to define a plain XY <code>Point<\/code> class as:<\/p>\n+<pre><code>__data class Point(int x, int y) { }<\/code><\/pre>\n+<p>The clarity and compactness here is surely attractive -- this says that a <code>Point<\/code> is a carrier for two integer components <code>x<\/code> and <code>y<\/code>, and from that, the reader immediately knows that there are sensible <em>and correct<\/em> implementations for the core <code>Object<\/code> methods, and doesn't have to wade through a page of boilerplate to be able to confidently reason about their semantics. Most developers are going to say &quot;Well, of course I want <em>that<\/em>.&quot;<\/p>\n+<h4 id=\"meet-the-elephant\">Meet the elephant<\/h4>\n+<p>Unfortunately, such universal consensus is only syntax-deep; almost immediately after we finish celebrating the concision, come the arguments about the natural semantics of such a construct, and what restrictions we are willing to accept. Are they extensible? Are the fields mutable? Can I control the behavior of the generated methods, or the accessibility of the fields? Can I have additional fields and constructors?<\/p>\n+<p>Just like the story of the blind men and the elephant, different developers are likely to bring very different assumptions about the &quot;obvious&quot; semantics of a data class. To bring these implicit assumptions into the open, let's name the various positions.<\/p>\n+<p><em>Algebraic Annie<\/em> will say &quot;a data class is just an algebraic product type.&quot; Like Scala's case classes, they come paired with pattern matching, and are best served immutable. (And for dessert, Annie would order sealed interfaces.)<\/p>\n+<p><em>Boilerplate Billy<\/em> will say &quot;a data class is just an ordinary class with better syntax&quot;, and will likely bristle at constraints on mutability, extension, or encapsulation. (Billy's brother, JavaBean Jerry, will say &quot;these must be for JavaBeans -- so of course I get getters and setters too.&quot; And his sister, POJO Patty, remarks that she is drowning in enterprise POJOs, and reminds us that she'd like these to be proxyable by frameworks like Hibernate.)<\/p>\n+<p><em>Tuple Tommy<\/em> will say &quot;a data class is just a nominal tuple&quot; -- and may not even be even expecting them to have methods other than the core <code>Object<\/code> methods -- they're just the simplest of aggregates. (He might even expect the names to be erased, so that two data classes of the same &quot;shape&quot; can be freely converted.)<\/p>\n+<p><em>Values Victor<\/em> will say &quot;a data class is really just a more transparent value type.&quot;<\/p>\n+<p>All of these personae are united in favor of &quot;data classes&quot; -- but have different ideas of what data classes are, and there may not be any one solution that makes them all happy.<\/p>\n+<h4 id=\"understanding-the-problem\">Understanding the problem<\/h4>\n+<p>It is superficially tempting to treat this feature as being primarily about boilerplate reduction; after all, we're painfully aware of the state-related boilerplate we deal with every day. However, boilerplate is just a symptom of a deeper problem. Our main tool for data abstraction is classes, which are indeed a versatile tool. And the primary hammer of classes is <em>encapsulation<\/em>. Encapsulating our state (so it can't be manipulated directly) and our representation (so we can change representation freely while maintaining the same API contract) gives us a lot of flexibility, and it enables us to write code that can operate safely and robustly across a variety of <em>boundaries<\/em>:<\/p>\n+<ul>\n+<li>Maintenance boundaries -- when our clients are working in a different sourcebase or organization;<\/li>\n+<li>Security and trust boundaries -- where we do not want to expose our state to clients because we do not fully trust them to not deliberately modify or use it in malicious ways;<\/li>\n+<li>Integrity boundaries -- where we do not want to expose our state to clients because, while we may trust their intent and are willing to share our data with them, we do not trust them to ensure that key invariants are maintained (or do not want to burden them with these concerns);<\/li>\n+<li>Versioning boundaries -- where we want to ensure that clients compiled against one version of a library continue to work when run against a subsequent version.<\/li>\n+<\/ul>\n+<p>These benefits are significant -- indeed, essential -- for classes like <code>SocketInputStream<\/code>, but often less so for classes like <code>Point<\/code>. Many classes are not concerned with defending any of these boundaries -- maybe it is private to a package or module and co-compiled with all its clients, trusts its clients, and has no complex invariants that we need to protect. Sadly, the cost of flexibility -- the need to spell everything out explicitly (how to map constructor arguments to state, how to derive the equality contract from state, etc) -- is borne by all classes, but the benefit is not shared so equally, pushing the cost-benefit balance out of line for classes that are less concerned with defending their boundaries. This is what Java developers mean by &quot;too much ceremony&quot; -- not that the ceremony has no value, but that they're forced to invoke it even when it does not offer sufficient value, and imposes additional costs (both machine and human.)<\/p>\n+<p>If we could say that a class was a <em>plain data carrier<\/em> for a given state vector, then we could provide sensible and correct defaults for state-related members like constructors, accessors, and <code>Object<\/code> methods. Since there's currently no way to say what we really mean, our only alternative is to get out our imperative hammer and start bashing. But &quot;plain&quot; domain classes are so common that it would be nice to capture this design decision directly in the code -- where readers and compilers alike could take advantage of it -- rather than simulating it imperatively (and thereby obfuscating our design intent). So while boilerplate may be the symptom, the disease is that our code cannot directly capture our design intent, and if we cure the disease, the boilerplate goes away. For these reasons, we believe it is better to treat this feature as being about <em>modeling pure data aggregates<\/em>, rather than about concision or boilerplate.<\/p>\n+<h2 id=\"digression----enums\">Digression -- enums<\/h2>\n+<p>If the problem is that we're modeling something simple with something overly general, simplification is going to come from constraint; by letting go of some degrees of freedom, we hope to be freed of the obligation to specify everything explicitly.<\/p>\n+<p>The <code>enum<\/code> facility, added in Java 5, is an excellent example of such a tradeoff. The type-safe enum pattern was well understood, and easy to express (albeit verbosely), prior to Java 5 (see <a href=\"https:\/\/www.amazon.com\/gp\/product\/0321356683?ie=UTF8&amp;tag=briangoetz-20&amp;camp=1789&amp;linkCode=xm2&amp;creativeASIN=0321356683\">Effective Java, 1st Edition<\/a>, item 21.) The initial motivation to add enums to the language might have been irritation at the boilerplate required for this idiom, but the real benefit is semantic.<\/p>\n+<p>The key simplification of enums was to constrain the lifecycle of enum instances -- enum constants are singletons, and the requisite instance control is managed by the runtime. By baking singleton-awareness into the language model, the compiler can safely and correctly generate the boilerplate needed for the type-safe enum pattern. And because enums started with a semantic goal, rather than a syntactic one, it was possible for enums to interact positively with other features, such as the ability to <code>switch<\/code> on enums.<\/p>\n+<p>Perhaps surprisingly, enums delivered their syntactic and semantic benefits without requiring us to give up most other degrees of freedom that classes enjoy; Java's enums are not mere enumerations of integers, as they are in many other languages, but instead are full-fledged classes, with unconstrained state and behavior, and even subtyping (though this is constrained to interface inheritance only.)<\/p>\n+<h4 id=\"why-not-just-do-tuples\">Why not &quot;just&quot; do tuples?<\/h4>\n+<p>Some readers may feel at this point that if we &quot;just&quot; had tuples, we wouldn't need data classes. And while tuples might offer a lighter-weight means to express some aggregates, the result is often inferior aggregates. A central aspect of the Java philosophy is that <em>names matter<\/em>; a <code>Person<\/code> with properties <code>firstName<\/code> and <code>lastName<\/code> is clearer and safer than a tuple of <code>String<\/code> and <code>String<\/code>. The major pain of using named classes for aggregates is the syntactic overhead of declaring them; if we reduce this overhead, the temptation to reach for more weakly typed mechanisms is greatly reduced.<\/p>\n+<h2 id=\"towards-requirements-for-data-classes\">Towards requirements for data classes<\/h2>\n+<p>It's easy to claim a class is &quot;just a plain data carrier&quot;, but what do we mean by that? What degrees of freedom that classes enjoy do &quot;plain&quot; data aggregates not need, that we can eliminate and thereby simplify the model?<\/p>\n+<p>At one extreme, nobody thinks that <code>SocketInputStream<\/code> is &quot;just&quot; its data; it fully encapsulates some complex and unspecified state (including a native resource) and exposes an interface contract that likely looks nothing like its internal representation.<\/p>\n+<p>At the other extreme, a class like<\/p>\n+<pre><code>final class Point {\n+    public final int x;\n+    public final int y;\n+\n+    public Point(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    \/\/ state-based implementations of equals, hashCode, toString\n+    \/\/ nothing else<\/code><\/pre>\n+<p>}<\/p>\n+<p>is clearly &quot;just&quot; the data <code>(x, y)<\/code>. Its representation is <code>(x, y)<\/code>, its construction protocol accepts an <code>(x, y)<\/code> pair and stores it directly, and it provide unmediated access to its data. The combination of transparency and state-based equality means that a client can extract the data carried by a <code>Point<\/code> and instantiate another <code>Point<\/code> which is known to be valid and substitutible for the original.<\/p>\n+<p>Let's formalize this notion of &quot;plain data carrier&quot; a bit, so we can use this to evaluate design decisions for a data class feature. We say a class <code>C<\/code> is a <em>transparent carrier<\/em> for a state vector <code>S<\/code> if:<\/p>\n+<ul>\n+<li>There is a function <em>ctor : S -&gt; C<\/em> which maps an instance of the state vector to an instance of <em>C<\/em>. (This function may be partial; <em>ctor<\/em> may reject some state vectors as invalid, such as rational numbers whose denominator is zero.)<\/li>\n+<li>There is a total function <em>dtor : C -&gt; S<\/em> which maps an instance of <em>C<\/em> to a state vector <em>S<\/em> in the domain of <em>ctor<\/em>.<\/li>\n+<li>For any instance <em>c<\/em> of <em>C<\/em>, <em>ctor(dtor(c)) equals c<\/em>, according to the <code>equals()<\/code> contract for <em>C<\/em>, and further, that the composition <em>ctor(dtor(x))<\/em> is an <em>identity<\/em> on the codomain of <em>ctor<\/em>.<\/li>\n+<li>For two state vectors <em>s1<\/em> and <em>s2<\/em> in the domain of <em>ctor<\/em>, if each of their components is equal to the corresponding component of the other (according to the component's <code>equals()<\/code> contract), then <em>ctor(s1) equals ctor(s2)<\/em>.<\/li>\n+<li>For any mutative operations of <em>C<\/em>, performing the same operation on equal instances of <em>C<\/em> results in equal instances of <em>C<\/em>.<\/li>\n+<\/ul>\n+<p>This means that <code>C<\/code> has a constructor (or factory) which accepts the state vector <code>S<\/code>, and accessors (or a deconstruction pattern) which produces the components of <code>S<\/code>, and that for any valid instance, extracting the state vector and then reconstructing an instance from that state vector produces an instance that is equivalent to the original. Similarly, constructing instances from equivalent state vectors produces equivalent instances, and applying the same mutative operation to equivalent instances preserves their equivalence. Such carriers are <em>transparent<\/em> -- their state can be freely from the outside (because clients can call the <em>dtor<\/em> function).<\/p>\n+<p>Together, these requirements say that there is a very simple relationship between the classes representation, its construction, and its destructuring. In other words, the API <em>is<\/em> the representation -- and both client and compiler can safely assume this. A class that is a plain data carrier is <em>the data, the whole data, and nothing but the data<\/em>.<\/p>\n+<p>Note that so far, we haven't said anything about syntax or boilerplate; we've only talked about constraining the semantics of the class to be a simple carrier for a specified state vector. But these constraints allow us to safely and mechanically generate the boilerplate for constructors, pattern extractors, accessors, <code>equals()<\/code>, <code>hashCode()<\/code>, and <code>toString()<\/code> -- and more.<\/p>\n+<h4 id=\"data-classes-and-pattern-matching\">Data classes and pattern matching<\/h4>\n+<p>By saying that a data class is a transparent carrier for a publicly-specified state vector, rather than just a boilerplate-reduced class, we gain the ability to freely convert a data class instance back and forth between its aggregate form and its state vector. This has a natural connection with <em>pattern matching<\/em>; by committing that a class is merely a carrier for a state vector, there is an obvious deconstruction pattern -- whose signature is the dual of the constructor's -- which can be mechanically generated.<\/p>\n+<p>For example, suppose we have data classes as follows:<\/p>\n+<pre><code>interface Shape { }\n+__data class Point(int x, int y) { }\n+__data class Rect(Point p1, Point p2) implements Shape { }\n+__data class Circle(Point center, int radius) implements Shape { }<\/code><\/pre>\n+<p>A client can deconstruct a shape as follows:<\/p>\n+<pre><code>switch (shape) {\n+     case Rect(Point(var x1, var y1), Point(var x2, var y2)): ...\n+     case Circle(Point(var x, var y), int r): ...\n+     ....\n+}<\/code><\/pre>\n+<p>with the mechanically generated pattern extractors. This synergy between data classes and pattern matching makes each feature more expressive. However, a not-entirely-obvious consequence of this is that there is no such thing as truly <code>private<\/code> fields in a data class; even if the fields were to be declared private, their values would still be implicitly readable via the destructuring pattern. This would be surprising if our design center for data class was that they are merely a boilerplate reduction tool -- but is consistent with data classes being transparent carriers for their data.<\/p>\n+<h4 id=\"data-classes-and-externalization\">Data classes and externalization<\/h4>\n+<p>Data classes are also a natural fit for safe, mechanical externalization (serialization, marshaling to and from JSON or XML, mapping to database rows, etc). If a class is a transparent carrier for a state vector, and the components of that state vector can be externalized in the desired encoding, then the carrier can be safely and mechanically marshaled and unmarshaled with guaranteed fidelity, and without the security and integrity risks of bypassing the constructor (as built-in serialization does). In fact, a transparent carrier need not do anything special to support externalization; the externalization framework can deconstruct the object using its principal deconstructor, and reconstruct it using its principal constructor, which are already public.<\/p>\n+<h2 id=\"refining-the-design-space\">Refining the design space<\/h2>\n+<p>The requirements for being a &quot;plain data carrier&quot; represent a sensible trade-off; by agreeing to transparently expose our representation and state, we gain safe and predictable implementations of constructors, <code>Object<\/code> methods, destructuring patterns, and externalization. Let's take this as our starting point, and explore some other natural questions that come up in the context of designing such a feature.<\/p>\n+<h4 id=\"overriding-default-members\">Overriding default members<\/h4>\n+<p>The default implementations of constructors and <code>Object<\/code> methods is likely to be what is desired in a lot of cases, but there may be cases where we want to refine these further, such as a constructor that enforces additional invariants, or an <code>equals()<\/code> method that compares array components by content rather than delegating to <code>Object.equals()<\/code>. (Allowing refined implementations expands the range of useful data classes, but also exposes us to the risk that the the explicit implementations won't conform to the requirements of a plain data carrier.)<\/p>\n+<h4 id=\"constructors\">Constructors<\/h4>\n+<p>In our definition, we said that construction could be a partial function, to allow constructors to enforce domain invariants (such as a &quot;range&quot; type ensuring that the lower bound doesn't exceed the upper bound). Data classes without representational invariants should not require an explicit constructor, but ideally it should be possible to specify an explicit constructor that enforces invariants -- without having to write out all the constructor boilerplate out by hand.<\/p>\n+<p>Data classes clearly need a constructor whose signature matches that of the state vector (call this the <em>principal constructor<\/em>); otherwise, the class would not be merely a carrier for its state vector, as we couldn't freely deconstruct and reconstruct it. Can a data class have additional constructors too? This seems reasonable -- if they are merely convenience implementations that delegate to the principal constructor.<\/p>\n+<h4 id=\"ancillary-fields\">Ancillary fields<\/h4>\n+<p>Related to the previous item is the question of whether the state vector describes <em>all<\/em> the state of the class, or merely some distinguished subset of it. While at first it might seem reasonable to allow additional fields, these also constitute a slippery slope away from the design center of &quot;plain data carrier.&quot; If there were ancillary fields that affect the behavior of <code>equals()<\/code> or <code>hashCode()<\/code>, then this will almost certainly violate the requirement that deconstructing a carrier and reconstructing it yields an equivalent instance.<\/p>\n+<p>Similarly, if they affected the behavior of mutative methods, this would undermine the requirement that performing identical actions on equal carriers results in equal carriers. So while there are legitimate uses for ancillary variables (primarily caching state derived from the state vector), ancillary fields come with the risk of violating the spirit of &quot;the state, the whole state, and nothing but the state.&quot;<\/p>\n+<h4 id=\"extension\">Extension<\/h4>\n+<p>Can a data class extend an ordinary class? Can a data class extend another data class? Can a non-data class extend a data class? Again, let's evaluate these through our definition of plain data carrier.<\/p>\n+<p>Extension between data classes and non-data classes, or between concrete data classes, seems immediately problematic. If a data class extends an ordinary class, we would have no control over the <code>equals()<\/code> contract of the superclass, and therefore no reason to believe that the desired invariants hold.<\/p>\n+<p>Similarly, if another class (data or not) were to extend a data class, we'd almost certainly violate the desired invariants. Consider:<\/p>\n+<pre><code>__data class C(STATE_VECTOR) { }\n+class D extends C { ... }\n+\n+D d = ...\n+switch (d) { \n+    case C(var STATE_VECTOR): assert d.equals(new C(STATE_VECTOR));\n+    ...\n+}<\/code><\/pre>\n+<p>Deconstructing a <code>C<\/code> into its state and then reconstructing it into a carrier should yield an equivalent instance -- but in this case, it will not. D is not a plain carrier for C's state vector, as it has at least some additional typestate, and perhaps some additional state and behavior as well, which may cause the equality check to fail.<\/p>\n+<h4 id=\"mutability\">Mutability<\/h4>\n+<p>One of the thorniest problems is whether we allow mutability, and how we handle the consequences if we do. The simplest solution -- and surely a tempting one -- is to insist that state components of data classes be <code>final<\/code>. While this is an attractive opening position, this may ultimately be too limiting; while immutable data is surely better-behaved than mutable data, mutable data certainly qualifies as &quot;data&quot;, and there are many legitimate uses for mutable &quot;plain data&quot; aggregates. (And, even if we required that data class fields always be <code>final<\/code>, this only gives us shallow immutability -- we still have to deal with the possibility that the contents are more deeply mutable.)<\/p>\n+<p>It is worth noting that similar languages that went down the data-class path -- including Scala, Kotlin, and C# -- all settled on not forcing data classes to be immutable, though its almost certain that their designers initially considered doing so. (Even if we allow mutability, we still have the option of nudging users towards finality, say by making the default for data class fields <code>final<\/code>, and providing a way to opt out of finality for individual fields.)<\/p>\n+<h4 id=\"field-encapsulation\">Field encapsulation<\/h4>\n+<p>Related to the problem of mutability is whether fields can be individually encapsulated. There are several reasons why one might want to encapsulate fields, even if we've given up on decoupling the representation from the API:<\/p>\n+<ul>\n+<li>To protect integrity boundaries (rejecting writes that would violate representational invariants);<\/li>\n+<li>To detect when writes have happened, so that listeners can be notified or cached state can be adjusted;<\/li>\n+<li>To make defensive copies on reads, such as for array components.<\/li>\n+<\/ul>\n+<p>All are related, directly or indirectly, to mutability. If data class fields are <code>final<\/code>, once the constructor establishes the invariants, they cannot be undermined, and if there are no writes, there's no need to take any action on writes. Similarly, only if data class state is deeply mutable (such as for array components) would we need to consider defensive copies. Absent any concern about deep mutability, if data class fields are <code>final<\/code>, there's no reason for them to not also be <code>public<\/code> (since we've already given up on the ability to compatibly change the representation across maintenance boundaries.) And, even if fields are mutable, if they do not participate in any invariants (no integrity boundaries) and are confined to a package or module (no maintenance or trust boundaries), then it might well be reasonable for mutable fields to be public as well.<\/p>\n+<p>The primary remaining motivation for encapsulating fields, then, is to limit writes to those fields when sharing instances across trust or integrity boundaries. Any support for state encapsulation should focus on these aspects alone.<\/p>\n+<h4 id=\"accessors\">Accessors<\/h4>\n+<p>No discussion involving boilerplate (or any question of Java language evolution, for that matter) can be complete without the subject of field accessors (and properties) coming up. On the one hand, accessors constitute a significant portion of boilerplate in existing code; on the other hand, the JavaBean-style getter\/setter conventions are already badly overused. (Immutable classes could forgo accessors in favor of public final fields, as long as they're not worried about maintenance boundaries. Even mutable classes without state invariants could get away with public mutable fields instead of accessors -- again as long as they're not worried about maintenance boundaries. These two cases already cover a large proportion of the candidates for data classes.)<\/p>\n+<p>If it turns out to make sense to support mutable fields, it probably also make sense to support write-encapsulation of those fields to defend integrity boundaries. But we should be mindful of the purpose of these accessors; it is not to abstract the representation from the API, but merely to enable rejection of bad values, and provide syntactic uniformity of access.<\/p>\n+<p>Without rehashing the properties debate, one fundamental objection to automating JavaBean-style field accessors is that it would take what is at best a questionable (and certainly overused) API naming convention and burn it into the language. Unlike the core methods like <code>Object.equals()<\/code>, field accessors do not have any special treatment in the language, and so names of the form <code>getSize()<\/code> should not either. (Also, while tedious, writing (and reading) accessor declarations are not nearly as error-prone as <code>equals()<\/code>.)<\/p>\n+<h4 id=\"arrays-and-defensive-copies\">Arrays and defensive copies<\/h4>\n+<p>Array-valued fields are particularly problematic, as there is no way to make them deeply immutable. But they're really just a special case of mutable objects which do not provide unmodifiable views. APIs that encapsulate arrays frequently make defensive copies when they're on the other side of a trust boundary from their users. Should data classes support this? Unfortunately, this also falls afoul of our requirements for data classes.<\/p>\n+<p>Because the <code>equals()<\/code> method of arrays is inherited from <code>Object<\/code>, which compares instances by identity, making defensive copies of array components in read accessors would violate the invariant that destructuring an instance of a data class and reconstructing it yields an equivalent instance -- the defensive copy and the original array will not be equal to each other. (Arrays are simply a bad fit for data classes, as they are mutable, but unlike <code>List<\/code> their <code>equals()<\/code> method is based on identity.) We'd rather not distort data classes to accomodate arrays, especially as there are ample alternatives available.<\/p>\n+<h4 id=\"thread-safety\">Thread-safety<\/h4>\n+<p>Allowing mutable state in data classes raises the question of whether, and how, they can be made thread-safe. (Note that thread-safety is not a requirement for mutable classes; many useful classes, such as <code>ArrayList<\/code>, are not thread-safe.) Thread-safe classes encapsulate a protocol for coordinating access to their shared mutable state. But, data classes disavow most forms of encapsulation. (Immutable objects are implicitly thread-safe, because there is no shared mutable state to which access need be coordinated.)<\/p>\n+<p>Like most non-thread-safe classes, instances of mutable data classes can still be used safely in concurrent environments through <em>confinement<\/em>, where the data class instance is encapsulated within a thread-safe class. While it might be possible to nibble around the edges to support a few use cases, ultimately data classes are not going to be the right tool for creating thread-safe mutable classes, and rather than reinventing all the flexibility of classes in a new syntax, we should probably just guide people to writing ordinary classes in these cases.<\/p>\n+<h4 id=\"data-classes-and-value-types\">Data classes and value types<\/h4>\n+<p>With <em>value types<\/em> coming down the road through <a href=\"http:\/\/openjdk.java.net\/projects\/valhalla\/\">Project Valhalla<\/a>, it is reasonable to ask about the overlap between immutable data classes and value types, as well as whether the intersection of data-ness and value-ness is a useful space to inhabit.<\/p>\n+<p>Value types are primarily about enabling <em>flat<\/em> and <em>dense<\/em> layout of object in memory. The central sacrifice of value types is <em>object identity<\/em>; in exchange for giving up object identity (which means giving up mutability and layout polymorphism), we can elide object headers and can inline values directly into the layout of other values, objects, and arrays, and freely hoist values out of the heap and onto the stack or into registers. The lack of layout polymorphism means we have to give up something else: self-reference. A value type <code>V<\/code> cannot refer, directly or indirectly, to another unboxed <code>V<\/code>. But value classes need not give up any encapsulation, and in fact encapsulation is essential for some applications of value types (such as references to native resources.)<\/p>\n+<p>On the other hand, data classes instances have identity, which supports mutability (maybe) but also supports self-reference. Unlike value types, data class instances are entirely suited to representing self-referential graphs.<\/p>\n+<p>Each of these simplified class forms -- values and data classes -- involves accepting certain restrictions in exchange for certain benefits. If we're willing to accept both sets of restrictions, we get both sets of benefits; the notion of a &quot;value data class&quot; is perfectly sensible for things like extended numerics or tuples.<\/p>\n+<h4 id=\"compatibility-and-migration\">Compatibility and migration<\/h4>\n+<p>It is important that existing classes that meet the requirements for data classes (or are willing to do so) should be able to be compatibly migrated to data classes, so that the many existing classes that are candidate for being data classes can benefit from the semantic transparency and syntactic concision of data classes. Similarly, it is important to be able to do the reverse, so that data classes can be compatibly refactored into regular classes if they evolve to outgrow the constraints of data classes.<\/p>\n+<p>If an existing class which meets the requirements wants to migrate to be a data class, it should be able to do so by simply exposing its state through the class header and removing redundant field, constructor, and <code>Object<\/code> method declarations. Similarly, if a data class wants to migrate to be a full-blown class, it should be able to do so by providing explicit declarations of its fields, constructors, and <code>Object<\/code> methods (and, when explicit pattern extractors are supported, pattern extractors). Both of these migrations should be source- and binary-compatible; it is the responsibility of the developer to ensure that they are behaviorally compatible.<\/p>\n+<p>Once a data class is published, however, changing the state description will have compatibility consequences for clients that are outside the maintenance boundary. The binary- and source- compatibility impact of such changes can be partially mitigated by declaring new constructors and pattern match extractors that follow the old state description (so that existing clients can construct and deconstruct them), but depending on existing usage, it may be hard to mitigate the behavioral compatibility issues, as the resulting class may well fall afoul of the various invariants of plain data carriers from the perspective of legacy clients, such as the deconstructing and reconstructing a data class using an old state vector. For data classes operating within a maintenance boundary, it may be practical to compatibly refactor both a data class and its clients when changing the state description.<\/p>\n+<h2 id=\"a-concrete-proposal\">A concrete proposal<\/h2>\n+<p>Now that we have a good idea of what it is to &quot;just&quot; be a data carrier, what is it that we give up? Primarily, we are disavowing several key uses of encapsulation: the ability to decouple a classes interface from its representation, and to hide state from curious readers. (The main form of encapsulation we retain is the ability to control modifications to the state.) Further, we are committing to a state-based interpretation of the core <code>Object<\/code> methods, and that any methods on the data class be a pure function of its arguments and the class state.<\/p>\n+<p>What <em>don't<\/em> we have to give up to get this? Quite a lot. Data classes can be generic, can implement interfaces, can have static fields, and can have constructors and methods, all without compromising this committments. To start, let's say that<\/p>\n+<pre><code>__data class Point(int x, int y) { }<\/code><\/pre>\n+<p>desugars to<\/p>\n+<pre><code>final class Point extends java.lang.DataClass {\n+    final int x;\n+    final int y;\n+    \n+    public Point(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    \/\/ destructuring pattern for Point(int x, int y)\n+    \/\/ state-based equals, hashCode, and toString\n+    \/\/ public read accessors for x and y\n+}<\/code><\/pre>\n+<p>Any interfaces implemented by the data class are lifted onto the desugared class in the obvious way, as are any type variables, static fields, static methods, and instance methods. If the data class provides an explicit implementation of any of the implicit members (constructor, pattern extractor, <code>equals()<\/code>, <code>hashCode()<\/code>, <code>toString()<\/code>), it is used in place of the implicit member (but the explicit member must obey the stronger contract of these members for data classes, which will be specified in the <code>DataClass<\/code> superclass.)<\/p>\n+<p><strong>Constructors.<\/strong> If the data class imposes no invariants, no constructor declaration is needed, and the class acquires a constructor whose signature is that of the data class (the principal constructor). Additional constructors may be explicitly declared -- but they must delegate to the principal constructor. The principal constructor may also be explicitly declared, but it too must delegate to the default principal constructor, as in:<\/p>\n+<pre><code>__data class Range(int lo, int hi) {\n+\n+    \/\/ Explicit principal constructor\n+    public Range(int lo, int hi) {\n+        \/\/ validation logic\n+        if (lo &gt; hi)\n+            throw new IllegalArgumentException(...);\n+            \n+        \/\/ delegate to default constructor\n+        default(lo, hi);\n+    }\n+}<\/code><\/pre>\n+<p>The <code>default()<\/code> call invokes the default constructor that would otherwise have been auto-generated for this data class (including the default <code>super<\/code> constructor); this avoids the need to write out the tedious and error-inviting sequence of <code>this.x = x<\/code> assignments. Similarly, the explicit constructor may mutate its arguments to sanitize \/ normalize \/ copy them, and pass the copies to the default constructor. (The rules about statements preceding calls to <code>super<\/code> or <code>this<\/code> constructors can be relaxed, and the <code>this<\/code> reference treated as <em>definitely unassigned<\/em> for statements preceding the <code>default<\/code> or <code>this<\/code> call.)<\/p>\n+<p><strong>Fields.<\/strong> Given a data class<\/p>\n+<pre><code>__data class Foo(int x, int y) { ... }<\/code><\/pre>\n+<p>we will lift the state components <code>(int x, int y)<\/code> onto fields of <code>Foo<\/code> -- along with any annotations specified on the state components. The Javadoc for data classes will allow class parameters to be documented with the <code>@param<\/code> tag, as method parameters are now.<\/p>\n+<p>The most restrictive approach would be that fields are always final; we could also consider making them final by default, but allowing mutability to be supported by opting in via a mutability modifier (<code>non-final<\/code>, <code>unfinal<\/code>, <code>mutable<\/code> -- bikeshed to be painted later.) Similarly, the most restrictive approach would be for them to always have <code>package<\/code> accessibility (or <code>protected<\/code> for fields of abstract data class); a less restrictive approach would be to treat these as defaults, but allow them to optionally be declared <code>public<\/code>.<\/p>\n+<p>With respect to additional fields beyond those in the state description, the most restrictive approach would be to prohibit them. While there are some legitimate use cases for encapsulated private fields that do not violate the requirements (mostly having to do with caching derived properties of the state vector), the risk that this state flows into equality or other semantics is high, bringing us away from the design center of &quot;plain carrier for the state vector.&quot;<\/p>\n+<p><strong>Extension.<\/strong> We've already noted that arbitrary extension is problematic, but it should be practical to maintain inheritance from abstract data classes to other data classes. A sensible balance regarding extension is:<\/p>\n+<ul>\n+<li>Non-abstract data classes are final;<\/li>\n+<li>Data classes can be abstract (in which case they acquire no <code>equals()<\/code>, <code>hashCode()<\/code>, or <code>toString()<\/code> methods, and all constructors must be <code>protected<\/code>);<\/li>\n+<li>Data classes can extend abstract data classes;<\/li>\n+<li>No restrictions on what interfaces a data class could implement.<\/li>\n+<\/ul>\n+<p>This allows us to declare families of algebraic data types, such as the following partial hierarchy describing an arithmetic expression:<\/p>\n+<pre><code>interface Node { }\n+\n+abstract __data class BinaryOpNode(Node left, \n+                                   Node right) \n+    implements Node { }\n+\n+__data class PlusNode(Node left, Node right) \n+      extends BinaryOperatorNode(left, right) { }\n+\n+__data class MulNode(Node left, Node right) \n+      extends BinaryOperatorNode(left, right) { }\n+      \n+__data class IntNode(int constant) implements Node { }<\/code><\/pre>\n+<p>When a data class extends an abstract data class, the state description of the superclass must be a prefix of the state description of the subclass:<\/p>\n+<pre><code>abstract __data class Base(int x) { }\n+__data class Sub(int x, int y) extends Base(x) { }<\/code><\/pre>\n+<p>The arguments to the <code>extends Base()<\/code> clause is a list of <em>names<\/em> of state components of <code>Sub<\/code>, not arbitrary expressions, must be a prefix of the state description of <code>Sub<\/code>, and must match the state description of <code>Base<\/code>; this suppresses the local declaration of inherited fields, and also plays into the generation of the default principal constructor (which arguments are passed up to which superclass constructor, vs. which are used to initialize local fields.) These rules are sufficient for implementing algebraic data type hierarchies like the <code>Node<\/code> example above.<\/p>\n+<p><strong>Accessors.<\/strong> Data classes are transparent; they readily give up their state through the destructuring pattern. To make this explicit, and to support the <em>uniform access principle<\/em> for state, data classes implicitly acquire public read accessors for all state components, whose name is the same as the state component. (We will separately explore a more general mechanism for accessors which can be used by arbitrary classes; when such a mechanism is available, data classes will be able to customize the name to suit the conventions they prefer by explicitly using this mechanism.) If write accessors are desired, they can be provided explicitly -- data classes will not bring these automatically.<\/p>\n+<p><strong>Reflection.<\/strong> While our implementation is essentially a desugaring into a mostly ordinary class with fields and methods, we don't actually want to erase the data-ness completely; compilers need to be able to identify which classes are data classes, and what their state descriptions are, so they can enforce any restrictions on how they interact with other classes -- so this information must be present in the class file. This can be reflected on <code>Class<\/code> with methods such as <code>isDataClass()<\/code> and a method to return the ordered list of fields that are the classes state vector.<\/p>\n+<h2 id=\"summary\">Summary<\/h2>\n+<p>The key question in designing a facility for &quot;plain data aggregates&quot; in Java is identifying which degrees of freedom we are willing to give up. If we try to model all the degrees of freedom of classes, we just move the complexity around; to gain some benefit, we must accept some constraints. We think that the sensible constraints to accept are disavowing the use of encapsulation for decoupling representation from API, and for mediating read access to state.<\/p>\n+<\/body>\n+<\/html>\n","filename":"site\/design-notes\/data-classes-historical-1.html","additions":282,"deletions":822,"binary":false,"changes":1104,"status":"modified"},{"patch":"@@ -1,912 +1,320 @@\n-From: <Saved by Blink>\r\n-Snapshot-Content-Location: http:\/\/cr.openjdk.java.net\/~briangoetz\/amber\/datum_2.html\r\n-Subject: \r\n-Date: Wed, 5 Aug 2020 17:31:05 -0000\r\n-MIME-Version: 1.0\r\n-Content-Type: multipart\/related;\r\n-\ttype=\"text\/html\";\r\n-\tboundary=\"----MultipartBoundary--KLTDMv0tJesJiCAvkXYWazKyyj38VNAKc9WNAZla4E----\"\r\n-\r\n-\r\n-------MultipartBoundary--KLTDMv0tJesJiCAvkXYWazKyyj38VNAKc9WNAZla4E----\r\n-Content-Type: text\/html\r\n-Content-ID: <frame-26512C69423E5D53F8256489FC97CC8A@mhtml.blink>\r\n-Content-Transfer-Encoding: quoted-printable\r\n-Content-Location: http:\/\/cr.openjdk.java.net\/~briangoetz\/amber\/datum_2.html\r\n-\r\n-<!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\" \"http:\/\/www.=\r\n-w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\"><html xmlns=3D\"http:\/\/www.w3.=\r\n-org\/1999\/xhtml\"><head><meta http-equiv=3D\"Content-Type\" content=3D\"text\/htm=\r\n-l; charset=3DUTF-8\"><link rel=3D\"stylesheet\" type=3D\"text\/css\" href=3D\"cid:=\r\n-css-dcc4f8eb-b066-410e-89e1-ce99d1c9aae5@mhtml.blink\" \/><link rel=3D\"styles=\r\n-heet\" type=3D\"text\/css\" href=3D\"cid:css-b6a59dd3-11c8-4fca-a4cb-4fb7233b2bf=\r\n-2@mhtml.blink\" \/>\r\n- =20\r\n-  <meta http-equiv=3D\"Content-Style-Type\" content=3D\"text\/css\">\r\n-  <meta name=3D\"generator\" content=3D\"pandoc\">\r\n-  <title><\/title>\r\n- =20\r\n-     =20\r\n-<\/head>\r\n-<body>\r\n-\r\n-  <h2>THIS DOCUMENT HAS BEEN SUPERSEDED AND IS PROVIDED FOR HISTORICAL CONT=\r\n-EXT ONLY<\/h2>\r\n-<h1 id=3D\"data-classes-for-java\">Data Classes for Java<\/h1>\r\n-<h4 id=3D\"brian-goetz-february-2018\">Brian Goetz, February 2018<\/h4>\r\n-<p>This document explores possible directions for <em>data classes<\/em> in =\r\n-the Java Language. This is an exploratory document only and does not consti=\r\n-tute a plan for any specific feature in any specific version of the Java La=\r\n-nguage.<\/p>\r\n-<h2 id=3D\"background\">Background<\/h2>\r\n-<p>It is a common (and often deserved) complaint that \"Java is too verbose\"=\r\n- or has too much \"ceremony.\" A significant contributor to this is that whil=\r\n-e classes can flexibly model a variety of programming paradigms, this invar=\r\n-iably comes with modeling overheads -- and in the case of classes that are =\r\n-nothing more than \"plain data carriers\", these modeling overhead can be out=\r\n- of line with their value. To write a simple data carrier class responsibly=\r\n-, we have to write a lot of low-value, repetitive code: constructors, acces=\r\n-sors, <code>equals()<\/code>, <code>hashCode()<\/code>, <code>toString()<\/cod=\r\n-e>, etc. And developers are sometimes tempted to cut corners such as omitti=\r\n-ng these important methods, leading to surprising behavior or poor debuggab=\r\n-ility, or pressing an alternate but not entirely appropriate class into ser=\r\n-vice because it has the \"right shape\" and they don't want to define yet ano=\r\n-ther class.<\/p>\r\n-<p>IDEs will help you <em>write<\/em> most of this code, but writing code is=\r\n- only a small part of the problem. IDEs don't do anything to help the <em>r=\r\n-eader<\/em> distill the design intent of \"I'm a plain data carrier for <code=\r\n->x<\/code>, <code>y<\/code>, and <code>z<\/code>\" from the dozens of lines of =\r\n-boilerplate code. And repetitive code is a good place for bugs to hide; if =\r\n-we can, it is best to eliminate their hiding spots outright.<\/p>\r\n-<p>We don't yet have a formal definition of \"plain data carrier\", but we pr=\r\n-obably \"know it when we see it\". Nobody thinks that <code>SocketInputStream=\r\n-<\/code> is just a carrier for some data; it fully encapsulates some complex=\r\n- and unspecified state (including a native resource) and exposes an interfa=\r\n-ce contract that likely looks nothing like its internal representation.<\/p>\r\n-<p>At the other extreme, its pretty clear that:<\/p>\r\n-<pre><code>final class Point {\r\n-    public final int x;\r\n-    public final int y;\r\n-\r\n-    public Point(int x, int y) {\r\n-        this.x =3D x;\r\n-        this.y =3D y;\r\n-    }\r\n-\r\n-    \/\/ state-based implementations of equals, hashCode, toString\r\n-    \/\/ nothing else<\/code><\/pre>\r\n-<p>}<\/p>\r\n-<p>is \"just\" the data <code>(x, y)<\/code>. Its representation is <code>(x, =\r\n-y)<\/code>, its construction protocol accepts an <code>(x, y)<\/code> pair an=\r\n-d stores it directly into the representation, provides unmediated access to=\r\n- that representation, and derives the core <code>Object<\/code> methods from=\r\n- that representation.<\/p>\r\n-<h4 id=3D\"data-classes-in-other-oo-languages\">Data classes in other OO lang=\r\n-uages<\/h4>\r\n-<p>Other OO languages have explored compact syntactic forms for modeling da=\r\n-ta-oriented classes: <code>case<\/code> classes in <a href=3D\"https:\/\/docs.s=\r\n-cala-lang.org\/tour\/case-classes.html\">Scala<\/a>, <code>data<\/code> classes =\r\n-in <a href=3D\"https:\/\/kotlinlang.org\/docs\/reference\/data-classes.html\">Kotl=\r\n-in<\/a>, and soon, <code>record<\/code> classes in <a href=3D\"https:\/\/github.=\r\n-com\/dotnet\/roslyn\/blob\/features\/records\/docs\/features\/records.md\">C#<\/a>. T=\r\n-hese have in common that some or all of the state of a class can be describ=\r\n-ed directly directly in the class header (though they vary considerably in =\r\n-their semantics, such as constraints on the mutability or accessibility of =\r\n-fields, extensibility of the class, and other restrictions.) Committing in =\r\n-the class declaration to at least part of the relationship between state an=\r\n-d interface enables suitable defaults to be provided for various state-rela=\r\n-ted members such as constructors or <code>Object<\/code> methods. All of the=\r\n-se mechanisms (let's call them \"data classes\") seek to bring us closer to t=\r\n-he goal of being able to define <code>Point<\/code> as:<\/p>\r\n-<pre><code>record Point(int x, int y) { }<\/code><\/pre>\r\n-<p>The clarity and compactness here is surely attractive -- a <code>Point<\/=\r\n-code> is just a carrier for two integer components <code>x<\/code> and <code=\r\n->y<\/code>, and from that, the reader immediately knows that there are sensi=\r\n-ble <em>and correct<\/em> implementations for the core <code>Object<\/code> m=\r\n-ethods, and doesn't have to wade through a page of boilerplate to be able t=\r\n-o confidently reason about their semantics. Most developers are going to sa=\r\n-y \"Well, of course I want <em>that<\/em>.\"<\/p>\r\n-<h4 id=3D\"meet-the-elephant\">Meet the elephant<\/h4>\r\n-<p>Unfortunately, such universal consensus is only syntax-deep; almost imme=\r\n-diately after we finish celebrating the concision, comes the debate over th=\r\n-e natural semantics of such a construct, and what restrictions we are willi=\r\n-ng to accept. Are they extensible? Are the fields mutable? Can I control th=\r\n-e behavior of the generated methods, or the accessibility of the fields? Ca=\r\n-n I have additional fields and constructors?<\/p>\r\n-<p>Just like the story of the blind men and the elephant, developers are li=\r\n-kely to bring very different assumptions about the \"obvious\" semantics of a=\r\n- data class. To bring these implicit assumptions into the open, let's name =\r\n-the various positions.<\/p>\r\n-<p><em>Algebraic Annie<\/em> will say \"a data class is just an algebraic pro=\r\n-duct type.\" Like Scala's case classes, they come paired with pattern matchi=\r\n-ng, and are best served immutable. (And for dessert, Annie would order seal=\r\n-ed interfaces.)<\/p>\r\n-<p><em>Boilerplate Billy<\/em> will say \"a data class is just an ordinary cl=\r\n-ass with better syntax\", and will likely bristle at constraints on mutabili=\r\n-ty, extension, or encapsulation. (Billy's brother, JavaBean Jerry, will say=\r\n- \"these must be for JavaBeans -- so of course I get getters and setters too=\r\n-.\" And his sister, POJO Patty, remarks that she is drowning in enterprise P=\r\n-OJOs, and hopes they are proxyable by frameworks like Hibernate.)<\/p>\r\n-<p><em>Tuple Tommy<\/em> will say \"a data class is just a nominal tuple\" -- =\r\n-and may not even be expecting them to have methods other than the core <cod=\r\n-e>Object<\/code> methods -- they're just the simplest of aggregates. (He mig=\r\n-ht even expect the names to be erased, so that two data classes of the same=\r\n- \"shape\" can be freely converted.)<\/p>\r\n-<p><em>Values Victor<\/em> will say \"a data class is really just a more tran=\r\n-sparent value type.\"<\/p>\r\n-<p>All of these personae are united in favor of \"data classes\" -- but have =\r\n-different ideas of what data classes are, and there may not be any one solu=\r\n-tion that makes them all happy.<\/p>\r\n-<h4 id=3D\"encapsulation-and-boundaries\">Encapsulation and boundaries<\/h4>\r\n-<p>While we're painfully aware of the state-related boilerplate we deal wit=\r\n-h every day, the boilerplate is just a symptom of a deeper problem, which i=\r\n-s that Java asks all classes are asked to pay equally for the cost of encap=\r\n-sulation -- but not all classes benefit equally from it.<\/p>\r\n-<p>To be sure, encapsulation is essential; encapsulating our state (so it c=\r\n-an't be manipulated without our oversight) and our representation (so it ca=\r\n-n be evolved without affecting the API contract) enables us to write code t=\r\n-hat can operate safely and robustly across a variety of <em>boundaries<\/em>=\r\n-:<\/p>\r\n-<ul>\r\n-<li>Maintenance boundaries -- when our clients are working in a different s=\r\n-ourcebase or organization;<\/li>\r\n-<li>Security and trust boundaries -- where we do not want to expose our sta=\r\n-te to clients because we do not fully trust them to not deliberately modify=\r\n- or use it in malicious ways;<\/li>\r\n-<li>Integrity boundaries -- where we do not want to expose our state to cli=\r\n-ents because, while we may trust their intent and are willing to share our =\r\n-data with them, do not wish to burden them with the task of maintaining our=\r\n- own representational invariants;<\/li>\r\n-<li>Versioning boundaries -- where we want to ensure that clients compiled =\r\n-against one version of a library continue to work when run against a subseq=\r\n-uent version.<\/li>\r\n-<\/ul>\r\n-<p>But, not all classes value their boundaries equally. Defending these bou=\r\n-ndaries is essential for a class like <code>KeyStore<\/code> or <code>Socket=\r\n-InputStream<\/code>, but is of far less value for a class like <code>Point<\/=\r\n-code> or <code>Person<\/code>. Many classes are not concerned at all with de=\r\n-fending their boundaries; perhaps they are private to a package or module a=\r\n-nd co-compiled with their clients, trust their clients, and have no complex=\r\n- invariants that need protecting. Since the cost of establishing and defend=\r\n-ing these boundaries (how constructor arguments map to state, how to derive=\r\n- the equality contract from state, etc) is constant across classes, but the=\r\n- benefit is not, the cost may sometimes be out of line with the benefit. Th=\r\n-is is what Java developers mean by \"too much ceremony\" -- not that the cere=\r\n-mony has no value, but that they're forced to invoke it even when it does n=\r\n-ot offer sufficient value.<\/p>\r\n-<p>The encapsulation model that Java provides -- where the representation i=\r\n-s entirely decoupled from construction, state access, and equality -- is ju=\r\n-st more than many classes need. Classes that have a simpler relationship wi=\r\n-th their boundaries can benefit from a simpler model where we can define a =\r\n-class as a thin wrapper around its state, and derive the relationship betwe=\r\n-en state, construction, equality, and state access from that.<\/p>\r\n-<p>Further, the costs of decoupling representation from API goes beyond the=\r\n- overhead of declaring boilerplate members; encapsulation is, by its nature=\r\n-, information-destroying. If you see a class with a constructor that takes =\r\n-an argument <code>x<\/code>, and an accessor called <code>x()<\/code>, we oft=\r\n-en have only convention to tell us that they probably refer to the same thi=\r\n-ng. Relying on this is a pretty safe guess, but its just a guess. It would =\r\n-be nicer if tools and library code could mechnically rely on this correspon=\r\n-dence -- without a human having to read the specs (if there even is one!) t=\r\n-o confirm this expectation.<\/p>\r\n-<h4 id=3D\"digression----enums\">Digression -- enums<\/h4>\r\n-<p>If the problem is that we're modeling something simple with something ov=\r\n-erly general, simplification is going to come from constraint; by letting g=\r\n-o of some degrees of freedom, we hope to be freed of the obligation to spec=\r\n-ify everything explicitly.<\/p>\r\n-<p>The <code>enum<\/code> facility, added in Java 5, is an excellent example=\r\n- of such a tradeoff. The type-safe enum pattern was well understood, and ea=\r\n-sy to express (albeit verbosely), prior to Java 5 (see <a href=3D\"https:\/\/w=\r\n-ww.amazon.com\/gp\/product\/0321356683?ie=3DUTF8&amp;tag=3Dbriangoetz-20&amp;c=\r\n-amp=3D1789&amp;linkCode=3Dxm2&amp;creativeASIN=3D0321356683\">Effective Java=\r\n-, 1st Edition<\/a>, item 21.) The initial motivation to add enums to the lan=\r\n-guage might have been irritation at the boilerplate required for this idiom=\r\n-, but the real benefit is semantic.<\/p>\r\n-<p>The key simplification of enums was to constrain the lifecycle of enum i=\r\n-nstances -- enum constants are singletons, and the requisite instance contr=\r\n-ol is managed by the runtime. By baking singleton-awareness into the langua=\r\n-ge model, the compiler can safely and correctly generate the boilerplate ne=\r\n-eded for the type-safe enum pattern. And because enums started with a seman=\r\n-tic goal, rather than a syntactic one, it was possible for enums to interac=\r\n-t positively with other features, such as the ability to <code>switch<\/code=\r\n-> on enums, or to get comparison and safe serialization for free.<\/p>\r\n-<p>Perhaps surprisingly, enums delivered their syntactic and semantic benef=\r\n-its without requiring us to give up most other degrees of freedom that clas=\r\n-ses enjoy; Java's enums are not mere enumerations of integers, as they are =\r\n-in many other languages, but instead are full-fledged classes, with unconst=\r\n-rained state and behavior, and even subtyping (constrained to interface inh=\r\n-eritance only.)<\/p>\r\n-<p>If we are looking to replicate the success of this approach with data cl=\r\n-asses, our first question must therefore be: what constraints will give us =\r\n-the semantic and syntactic benefits we want, and, are we willing to accept =\r\n-these constraints?<\/p>\r\n-<h4 id=3D\"why-not-just-do-tuples\">Why not \"just\" do tuples?<\/h4>\r\n-<p>Some readers may feel at this point that if we \"just\" had tuples, we wou=\r\n-ldn't need data classes. And while tuples might offer a lighter-weight mean=\r\n-s to express some aggregates, the result is often inferior aggregates.<\/p>\r\n-<p>Classes and their members have names; tuples and their members do not. A=\r\n- central aspect of Java's philosophy is that <em>names matter<\/em>; a <code=\r\n->Person<\/code> with properties <code>firstName<\/code> and <code>lastName<\/c=\r\n-ode> is clearer and safer than a tuple of <code>String<\/code> and <code>Str=\r\n-ing<\/code>. Classes support state validation through their constructors; tu=\r\n-ples do not. Some data aggregates (such as ranges) have invariants that, if=\r\n- enforced by the constructor, can thereafter be relied upon; tuples do not =\r\n-offer this ability. Classes can have behavior that is derived from their st=\r\n-ate; co-locating state and derived behavior makes it more discoverable and =\r\n-easier to access.<\/p>\r\n-<p>For all these reasons, we don't want to abandon classes for modeling dat=\r\n-a; we just want to make modeling data with classes simpler. The major pain =\r\n-of using named classes for aggregates is the overhead of declaring them; if=\r\n- we can reduce this, the temptation to reach for more weakly typed mechanis=\r\n-ms is greatly reduced.<\/p>\r\n-<h4 id=3D\"are-data-classes-the-same-as-value-types\">Are data classes the sa=\r\n-me as value types?<\/h4>\r\n-<p>With <em>value types<\/em> coming down the road through <a href=3D\"http:\/=\r\n-\/openjdk.java.net\/projects\/valhalla\/\">Project Valhalla<\/a>, it is reasonabl=\r\n-e to ask about the overlap between (immutable) data classes and value types=\r\n-, and as whether the intersection of data-ness and value-ness is a useful s=\r\n-pace to inhabit.<\/p>\r\n-<p>Value types are primarily about enabling <em>flat<\/em> and <em>dense<\/em=\r\n-> layout of objects in memory. The central sacrifice of value types is <em>=\r\n-object identity<\/em>; in exchange for giving up object identity (which enta=\r\n-ils giving up mutability and layout polymorphism), the runtime can elide ob=\r\n-ject headers, inline values directly into other values, objects, and arrays=\r\n-, and freely hoist values from the heap into registers or onto the stack. T=\r\n-he lack of layout polymorphism means we have to give up something else: sel=\r\n-f-reference. A value type <code>V<\/code> cannot refer, directly or indirect=\r\n-ly, to another <code>V<\/code>. But value classes need not give up any encap=\r\n-sulation, and in fact encapsulation is essential for some applications of v=\r\n-alue types (such as \"smart pointers\" or references to native resources.)<\/p=\r\n->\r\n-<p>On the other hand, data class instances have identity, which supports mu=\r\n-tability (maybe) but also supports self-reference. Unlike value types, data=\r\n- classes are well suited to representing tree and graph nodes.<\/p>\r\n-<p>Each of these simplified aggregate forms -- values and data classes -- i=\r\n-nvolves accepting certain restrictions in exchange for certain benefits. If=\r\n- we're willing to accept both sets of restrictions, we get both sets of ben=\r\n-efits; the notion of a \"value data class\" is perfectly sensible for things =\r\n-like extended numerics or tuples.<\/p>\r\n-<h2 id=3D\"towards-requirements-for-data-classes\">Towards requirements for d=\r\n-ata classes<\/h2>\r\n-<p>While it is superficially tempting to to treat data classes as primarily=\r\n- being about boilerplate reduction, we prefer to start with a semantic goal=\r\n-: <em>modeling data as data<\/em>. If we choose our goals correctly, the boi=\r\n-lerplate will take care of itself, and we will gain additional benefits asi=\r\n-de from concision.<\/p>\r\n-<p>So, what do we mean by \"modeling data as data\", and what are we going to=\r\n- have to give up? What degrees of freedom that classes enjoy do such \"plain=\r\n-\" data aggregates not need, that we can eliminate and thereby simplify the =\r\n-model? Java's object model is built around the assumption that we want the =\r\n-representation of an object to be completely decoupled from its API; the AP=\r\n-Is and behavior of constructors, accessor methods, and <code>Object<\/code> =\r\n-methods need not align directly with the object's state, or even with each =\r\n-other. However, in practice, they are frequently much more tightly coupled;=\r\n- a <code>Point<\/code> object has fields <code>x<\/code> and <code>y<\/code>, =\r\n-a constructor that takes <code>x<\/code> and <code>y<\/code>, accessors for <=\r\n-code>x<\/code> and <code>y<\/code> and initializes those fields, and <code>Ob=\r\n-ject<\/code> methods that characterize points solely by their <code>x<\/code>=\r\n- and <code>y<\/code> values. We claim that for a class to be \"just a plain c=\r\n-arrier for its data\", this coupling is something that can be counted upon -=\r\n-- that we're giving up the ability to decouple its (publicly declared) stat=\r\n-e from its API. The API for a data class models <em>the state, the whole st=\r\n-ate, and nothing but the state<\/em>.<\/p>\r\n-<p>Being able to count on this coupling drives a number of advantages. The =\r\n-compiler can generate sensible and correct implementations for standard cla=\r\n-ss members. Clients can freely deconstruct and reconstruct aggregates, or r=\r\n-estructure them into a more convenient form, without fear that they will di=\r\n-scard hidden data or undermine hidden assumptions. Frameworks can safely an=\r\n-d mechanically serialize or marshal them, without the need to provide compl=\r\n-ex mapping mechanisms. By giving up the flexibility to decouple a classes s=\r\n-tate from its API, we gain all of these benefits.<\/p>\r\n-<p>One consequence of this is that data classes are <em>transparent<\/em>; t=\r\n-hey give up their data freely to all requestors. Otherwise, their API doesn=\r\n-'t model their whole state, and we lose the ability to freely deconstruct a=\r\n-nd reconstruct them.<\/p>\r\n-<h4 id=3D\"use-cases-for-data-classes\">Use cases for data classes<\/h4>\r\n-<p>Applications are full of use cases for simple aggregates that are just w=\r\n-rappers for their data.<\/p>\r\n-<ul>\r\n-<li>Messages -- messages exchanged by actors or web services, or processed =\r\n-through a message fabric;<\/li>\r\n-<li>Document nodes -- compilers and word processors represent documents as =\r\n-trees of simple, structured nodes;<\/li>\r\n-<li>Disconnected entities -- to pass data entities across layers or service=\r\n-s, they are frequently represented as simple data aggregates with minimal b=\r\n-ehavior;<\/li>\r\n-<li>Low-overhead aggregates -- almost any nontrivial computation involves m=\r\n-aintaining tuples of related data as an intermediate result.<\/li>\r\n-<\/ul>\r\n-<p>All of these applications can benefit from the nominality of classes (bo=\r\n-th of the aggregate and of the components) and the co-location of data with=\r\n- behavior, but have no need to model them with the full generality of objec=\r\n-ts. A simpler aggregation mechanism will do -- because they're simple data =\r\n-aggregates, rather than models of stateful processes.<\/p>\r\n-<h4 id=3D\"data-classes-and-pattern-matching\">Data classes and pattern match=\r\n-ing<\/h4>\r\n-<p>One of the big advantages of defining data classes in terms of coupling =\r\n-their API to a publicly specified state description, rather than simply as =\r\n-boilerplate-reduced class, we gain the ability to freely convert a data cla=\r\n-ss instance back and forth between its aggregate form and its exploded stat=\r\n-e. This has a natural connection with <em>pattern matching<\/em>; by couplin=\r\n-g the API to the state description, there is an obvious deconstruction patt=\r\n-ern -- whose signature is the dual of the constructor's -- which can be mec=\r\n-hanically generated.<\/p>\r\n-<p>For example, suppose we have data classes as follows:<\/p>\r\n-<pre><code>interface Shape { }\r\n-record Point(int x, int y);\r\n-record Rect(Point p1, Point p2) implements Shape;\r\n-record Circle(Point center, int radius) implements Shape;<\/code><\/pre>\r\n-<p>A client can deconstruct a shape as follows:<\/p>\r\n-<pre><code>switch (shape) {\r\n-     case Rect(Point(var x1, var y1), Point(var x2, var y2)): ...\r\n-     case Circle(Point(var x, var y), int r): ...\r\n-     ....\r\n-}<\/code><\/pre>\r\n-<p>with the mechanically generated pattern extractors. This synergy between=\r\n- data classes and pattern matching makes each feature more expressive. Howe=\r\n-ver, a not-entirely-obvious consequence of this is that there is no such th=\r\n-ing as truly <code>private<\/code> fields in a data class; even if the field=\r\n-s were to be declared private, their values would still be implicitly reada=\r\n-ble via the destructuring pattern. This would be surprising if our design c=\r\n-enter for data class was that they are merely a boilerplate reduction tool =\r\n--- but is consistent with data classes being transparent carriers for their=\r\n- data.<\/p>\r\n-<h4 id=3D\"data-classes-and-externalization\">Data classes and externalizatio=\r\n-n<\/h4>\r\n-<p>Data classes are also a natural fit for safe, mechanical externalization=\r\n- (serialization, marshaling to and from JSON or XML, mapping to database ro=\r\n-ws, etc). If a class is a transparent carrier for a state vector, and the c=\r\n-omponents of that state vector can in turn be externalized in the desired e=\r\n-ncoding, then the carrier can be safely and mechanically marshaled and unma=\r\n-rshaled with guaranteed fidelity, without the security and integrity risks =\r\n-of bypassing the constructor (as built-in serialization does). In fact, a t=\r\n-ransparent carrier need not do anything special to support externalization;=\r\n- the externalization framework can deconstruct the object using its deconst=\r\n-ruction pattern, and reconstruct it using its constructor, which are alread=\r\n-y public.<\/p>\r\n-<h2 id=3D\"formalizing-the-requirements\">Formalizing the requirements<\/h2>\r\n-<p>Let's formalize this notion a bit, so we can use this to evaluate potent=\r\n-ial design choices. We say a class <code>C<\/code> is a transparent carrier =\r\n-for a state vector <code>S<\/code> if:<\/p>\r\n-<ul>\r\n-<li>There is a function <em>ctor<\/em> : <code>S<\/code> -&gt; <code>C<\/code>=\r\n- which maps an instance of the state vector to an instance of <code>C<\/code=\r\n->. (The constructor may reject some state vectors as invalid, such as ratio=\r\n-nal numbers whose denominator is zero.)<\/li>\r\n-<li>There is a total function <em>dtor<\/em> : <code>C<\/code> -&gt; <code>S<=\r\n-\/code> which maps an instance of <code>C<\/code> to a state vector <code>S<\/=\r\n-code> in the domain of <em>ctor<\/em>.<\/li>\r\n-<li>For any instance <em>c<\/em> of <code>C<\/code>, <em>ctor(dtor(c))<\/em> i=\r\n-s equal to <em>c<\/em>, according to the <code>equals()<\/code> contract for =\r\n-<code>C<\/code>.<\/li>\r\n-<li>For two state vectors <em>s1<\/em> and <em>s2<\/em>, if each of their com=\r\n-ponents is equal to the corresponding component of the other (according to =\r\n-the component's <code>equals()<\/code> contract), then either <em>ctor(s1)<\/=\r\n-em> and <em>ctor(s2)<\/em> are both undefined, or they are equals under the =\r\n-<code>equals()<\/code> contract for <code>C<\/code>.<\/li>\r\n-<li>For equivalent instances <code>c<\/code> and <code>d<\/code>, invoking th=\r\n-e same operation produces equivalent results: <code>c.m()<\/code> equals <co=\r\n-de>d.m()<\/code>. Moreover, after the operation, <code>c<\/code> and <code>d<=\r\n-\/code> should still be equivalent.<\/li>\r\n-<\/ul>\r\n-<p>This means that <code>C<\/code> has a constructor (or factory) which acce=\r\n-pts the state vector <code>S<\/code>, and accessors (or a deconstruction pat=\r\n-tern) which produces the components of <code>S<\/code>, and that for any val=\r\n-id instance, extracting the state vector and then reconstructing an instanc=\r\n-e from that state vector produces an instance equivalent to the original. S=\r\n-imilarly, constructing instances from equivalent state vectors produces equ=\r\n-ivalent instances. (Mathematically inclined readers will spot the embedding=\r\n--projection pair.) Moreover any additional operations on equivalent instanc=\r\n-es produce equivalent results and preserve the equivalence of the instances=\r\n-.<\/p>\r\n-<p>These invariants are an attempt to capture our requirements; that the ca=\r\n-rrier is transparent, and that there is a simple and predictable relationsh=\r\n-ip between the classes representation, its construction, and its destructur=\r\n-ing -- that the API <em>is<\/em> the representation.<\/p>\r\n-<p>Note that so far, we haven't said anything about syntax or boilerplate; =\r\n-we've only talked about constraining the semantics of the class to be a sim=\r\n-ple carrier for a specified state vector. But these constraints allow us to=\r\n- safely and mechanically generate the boilerplate for constructors, pattern=\r\n- extractors, accessors, <code>equals()<\/code>, <code>hashCode()<\/code>, and=\r\n- <code>toString()<\/code>, externalization, and more.<\/p>\r\n-<h2 id=3D\"a-starting-point\">A starting point<\/h2>\r\n-<p>The simplest -- and most draconian -- model for data classes is to say t=\r\n-hat a data class is a final class with public final fields for each state c=\r\n-omponent, a public constructor and deconstruction pattern whose signature m=\r\n-atches that of the state description, and state-based implementations of th=\r\n-e core <code>Object<\/code> methods, and further, that no other members (or =\r\n-explicit implementations of the implicit members) are allowed. This is esse=\r\n-ntially the strictest interpretation of a <em>nominal tuple<\/em>.<\/p>\r\n-<p>This starting point is simple and stable -- and nearly everyone will fin=\r\n-d something to object to about it. So, how much can we relax these constrai=\r\n-nts without giving up on the semantic benefits we want? Let's look at some =\r\n-directions in which the draconian starting point could be extended, and the=\r\n-ir interactions.<\/p>\r\n-<h4 id=3D\"interfaces-and-additional-methods\">Interfaces and additional meth=\r\n-ods<\/h4>\r\n-<p>One obvious direction for relaxing this model is to allow data classes t=\r\n-o implement interfaces or to declare methods that operate on their state. N=\r\n-o one could claim that the following class violates the spirit of data-clas=\r\n-s-ness:<\/p>\r\n-<pre><code>record Point(int x, int y) {\r\n-    boolean isOrigin() {\r\n-        return x =3D=3D 0 &amp;&amp; y =3D=3D 0;\r\n-    }\r\n-}<\/code><\/pre>\r\n-<p>The method <code>isOrigin()<\/code> merely computes a derived property of=\r\n- the state; the obvious place to put this is in the class that models the s=\r\n-tate. Similarly, no one could object to having <code>Point<\/code> implement=\r\n- <code>Comparable&lt;Point&gt;<\/code>.<\/p>\r\n-<p>However, even allowing additional methods is stepping onto a slippery sl=\r\n-ope; if the method's behavior depends on anything other than the state of t=\r\n-he object (including depending on the identity of the instance), then we've=\r\n- violated our \"nothing but the state\" rule.<\/p>\r\n-<h4 id=3D\"overriding-implicit-members\">Overriding implicit members<\/h4>\r\n-<p>The default implementations of constructors and <code>Object<\/code> meth=\r\n-ods is likely to be what is desired in a lot of cases, but there may be cas=\r\n-es where we want to refine these further, such as a constructor that enforc=\r\n-es validity constraints, or an <code>equals()<\/code> method that compares a=\r\n-rray components by content rather than delegating to <code>Object.equals()<=\r\n-\/code>. The natural way to denote this would be to declare explicit version=\r\n-s of these members, and have this suppress the generation of the implicit m=\r\n-ember.<\/p>\r\n-<p>Allowing refined implementations expands the range of useful data classe=\r\n-s, but again exposes us to the risk that the the explicit implementations w=\r\n-on't conform to the requirements of a plain data carrier.<\/p>\r\n-<p>The most common case of overriding an implicit member is likely to be ov=\r\n-erriding the constructor, to validate that the state conforms to its invari=\r\n-ants. Data classes without representational invariants should not require a=\r\n-n explicit constructor, but ideally it should be possible to specify an exp=\r\n-licit constructor that enforces invariants -- without having to write out a=\r\n-ll the constructor boilerplate out by hand.<\/p>\r\n-<h4 id=3D\"additional-constructors\">Additional constructors<\/h4>\r\n-<p>Related to additional methods is additional constructors. Data classes c=\r\n-learly need a constructor whose signature matches that of the state descrip=\r\n-tion (call this the <em>principal constructor<\/em>); otherwise, we couldn't=\r\n- freely deconstruct and reconstruct it. But it may also be desirable to off=\r\n-er additional constructors, which can derive the state from some alternate =\r\n-form. On the surface, this seems reasonable -- so long as the constructor i=\r\n-s not squirreling away data that is effectively part of the object state, b=\r\n-ut not part of the state description.<\/p>\r\n-<h4 id=3D\"additional-fields\">Additional fields<\/h4>\r\n-<p>Related to the previous item is the question of whether a data class can=\r\n- have additional fields beyond its state description. And again, there are =\r\n-cases when this is harmless, and cases when this completely violates our re=\r\n-quirements.<\/p>\r\n-<p>An additional field that merely caches a derived property of the state d=\r\n-escription (whether computed eagerly or lazily) is fine, because it is stil=\r\n-l logically \"nothing but the state\". For example:<\/p>\r\n-<pre><code>record Name(String first, String last) {\r\n-    private String firstAndLast;\r\n-   =20\r\n-    Name(String first, String last) {\r\n-        firstAndList =3D first + \" \" + last;\r\n-    }\r\n-   =20\r\n-    public String firstAndLast() { return firstAndLast; }\r\n-}<\/code><\/pre>\r\n-<p>is well within the spirit of the requirements; the existence of the <cod=\r\n-e>firstAndList<\/code> field is purely an implementation detail, but the beh=\r\n-avior of the <code>Name<\/code> class is derived solely from its state descr=\r\n-iption.<\/p>\r\n-<p>On the other hand, squirreling away additional state which is not derive=\r\n-d from the state description, and which affects the user-visible behavior o=\r\n-f its methods (especially <code>equals()<\/code> and <code>hashCode()<\/code>=\r\n-!), would totally violate the goal that a data class is \"just\" a carrier fo=\r\n-r its state. Similarly, if they affected the behavior of mutative methods, =\r\n-this would undermine the requirement that performing identical actions on e=\r\n-qual carriers results in equal carriers.<\/p>\r\n-<p>So, even more so that with explicit methods or constructors, additional =\r\n-fields are a significant risk item for undermining the goal that a data cla=\r\n-ss models \"the state, the whole state, and nothing but the state.\"<\/p>\r\n-<h4 id=3D\"extension\">Extension<\/h4>\r\n-<p>Can a data class extend an ordinary class? Can a data class extend anoth=\r\n-er data class? Can a non-data class extend a data class? Again, our model o=\r\n-f \"plain data carrier\" can help us evaluate these.<\/p>\r\n-<p>Extension between data classes and non-data classes, or between concrete=\r\n- data classes, seems immediately problematic. If a data class extends an or=\r\n-dinary class, we would have no control over the <code>equals()<\/code> contr=\r\n-act of the superclass, and therefore no reason to believe that the desired =\r\n-invariants hold.<\/p>\r\n-<p>Similarly, if another class (data or not) were to extend a data class, w=\r\n-e'd almost certainly violate the desired invariants. Consider:<\/p>\r\n-<pre><code>__data class C(STATE_DESCR) { }\r\n-\r\n-class D extends C {=20\r\n-   ...\r\n-}\r\n-\r\n-D d =3D ...\r\n-switch (d) {=20\r\n-    case C(var STATE_DESCR): assert d.equals(new C(STATE_DESCR));\r\n-    ...\r\n-}<\/code><\/pre>\r\n-<p>Deconstructing a <code>C<\/code> and reconstructing it should yield an eq=\r\n-uivalent instance -- but in this case, it will not. D is not a plain carrie=\r\n-r for C's state description, as it has at least some additional typestate, =\r\n-and perhaps some additional state, which may cause the equality check to fa=\r\n-il. The same argument can be made for a concrete data class extending anoth=\r\n-er concrete data class (though we may be able to rescue abstract data class=\r\n-es.)<\/p>\r\n-<h4 id=3D\"mutability\">Mutability<\/h4>\r\n-<p>One of the thorniest problems is whether we allow mutability, and how we=\r\n- handle the consequences if we do. The simplest solution -- and surely a te=\r\n-mpting one -- is to insist that state components of data classes be <code>f=\r\n-inal<\/code>. While this is an attractive opening position, this is likely t=\r\n-o be too limiting; while immutable data is surely better-behaved than mutab=\r\n-le data, mutable data certainly qualifies as \"data\", and there are many leg=\r\n-itimate uses for mutable \"plain data\" aggregates. (And, even if we required=\r\n- that data class fields always be <code>final<\/code>, this only gives us sh=\r\n-allow immutability -- we still have to deal with the possibility that the c=\r\n-ontents are more deeply mutable.)<\/p>\r\n-<p>It is worth noting that similar languages that went down the data-class =\r\n-path -- including Scala, Kotlin, and C# -- all settled on not forcing data =\r\n-classes to be immutable, though its almost certain that their designers ini=\r\n-tially considered doing so. (Even if we allow mutability, we still have the=\r\n- option of nudging users towards finality, say by making the default for da=\r\n-ta class fields <code>final<\/code>, and providing a way to opt out of final=\r\n-ity for individual fields.)<\/p>\r\n-<h4 id=3D\"field-encapsulation-and-accessors\">Field encapsulation and access=\r\n-ors<\/h4>\r\n-<p>Public fields make everyone nervous, even public final fields. If fields=\r\n- can be nonfinal, they certainly need some encapsulation support; even if t=\r\n-hey cannot, it still may be desirable to encapsulate the field and instead =\r\n-provide a read accessor, to support the <a href=3D\"https:\/\/en.wikipedia.org=\r\n-\/wiki\/Uniform_access_principle\">uniform access principle<\/a>.<\/p>\r\n-<p>Encapsulating fields and mediating access to state may serve to protect =\r\n-integrity boundaries (rejecting writes that would violate representational =\r\n-invariants), detect when when writes have happened so that listeners can be=\r\n- notified or cached state can be adjusted; or to make defensive copies on r=\r\n-eads for mutable components such as arrays. However, we must be careful to =\r\n-avoid undermining the transparency of data classes; each state component mu=\r\n-st be readable somehow.<\/p>\r\n-<p>No discussion involving boilerplate (or any question of Java language ev=\r\n-olution, for that matter) can be complete without the subject of field acce=\r\n-ssors (and properties) coming up. On the one hand, accessors constitute a s=\r\n-ignificant portion of the boilerplate in existing code; on the other hand, =\r\n-the JavaBean-style getter\/setter conventions are already badly overused. Mu=\r\n-tability may drag with it encapsulation, and encapsulation plus transparenc=\r\n-y may in turn drag accessors with them, but we should be mindful of the pur=\r\n-pose of these accessors; it is not to abstract the representation from the =\r\n-API, but at most to enable rejection of bad values and provide syntactic un=\r\n-iformity of access.<\/p>\r\n-<p>(Without rehashing the properties debate, one fundamental objection to a=\r\n-utomating JavaBean-style field accessors is that it would take what is at b=\r\n-est a questionable -- and certainly overused -- API naming convention and b=\r\n-urn it into the language. Unlike the core methods like <code>Object.equals(=\r\n-)<\/code>, field accessors do not have any special treatment in the language=\r\n-, and so names of the form <code>getSize()<\/code> should not either. Also, =\r\n-while equally tedious, writing (and reading) accessor declarations are not =\r\n-nearly as error-prone as <code>equals()<\/code>.)<\/p>\r\n-<h4 id=3D\"arrays-and-defensive-copies\">Arrays and defensive copies<\/h4>\r\n-<p>Array-valued fields are particularly problematic, as there is no way to =\r\n-make them deeply immutable. But they're really just a special case of mutab=\r\n-le objects which do not provide unmodifiable views. APIs that encapsulate a=\r\n-rrays frequently make defensive copies when they're on the other side of a =\r\n-trust boundary from their users. Should data classes support this? Unfortun=\r\n-ately, this also falls afoul of our requirements for data classes.<\/p>\r\n-<p>Because the <code>equals()<\/code> method of arrays is inherited from <co=\r\n-de>Object<\/code>, which compares instances by identity, making defensive co=\r\n-pies of array components in read accessors would violate the invariant that=\r\n- destructuring an instance of a data class and reconstructing it yields an =\r\n-equal instance -- the defensive copy and the original array will not be equ=\r\n-al to each other. (Arrays are simply a bad fit for data classes, as they ar=\r\n-e mutable, but unlike <code>List<\/code> their <code>equals()<\/code> method =\r\n-is based on identity.) We'd rather not distort data classes to accomodate a=\r\n-rrays, especially as there are ample alternatives available.<\/p>\r\n-<h4 id=3D\"thread-safety\">Thread-safety<\/h4>\r\n-<p>Allowing mutable state in data classes raises the question of whether, a=\r\n-nd how, they can be made thread-safe. (Note that thread-safety is not a req=\r\n-uirement for mutable classes; many useful classes, such as <code>ArrayList<=\r\n-\/code>, are not thread-safe.) Thread-safe classes encapsulate a protocol fo=\r\n-r coordinating access to their shared mutable state. But, data classes disa=\r\n-vow most forms of encapsulation. (Immutable objects are implicitly thread-s=\r\n-afe, because there is no shared mutable state to which access need be coord=\r\n-inated.)<\/p>\r\n-<p>Like most non-thread-safe classes, instances of mutable data classes can=\r\n- still be used safely in concurrent environments through <em>confinement<\/e=\r\n-m>, where the data class instance is encapsulated within a thread-safe clas=\r\n-s. While it might be possible to nibble around the edges to support a few u=\r\n-se cases, ultimately data classes are not going to be the right tool for cr=\r\n-eating thread-safe mutable classes, and rather than reinventing all the fle=\r\n-xibility of classes in a new syntax, we should probably just guide people t=\r\n-o writing ordinary classes in these cases.<\/p>\r\n-<h2 id=3D\"a-concrete-proposal\">A concrete proposal<\/h2>\r\n-<p>The central compromise we make for data classes is that we give up the a=\r\n-bility to decouple the API semantics from the state description, to define =\r\n-non-state-based semantics for equality and hashing, and to hide state from =\r\n-curious readers. In return, we gain the ability for the compiler to generat=\r\n-e key class members, as well as the ability to safely and mechanically copy=\r\n-, serialize, and externalize data classes.<\/p>\r\n-<p>What <em>don't<\/em> we have to give up to get this? Quite a lot. Data cl=\r\n-asses can be generic, can implement interfaces, can have static fields, and=\r\n- can have constructors and methods, all without compromising this commitmen=\r\n-ts. To start, let's say that<\/p>\r\n-<pre><code>record Point(int x, int y) { }<\/code><\/pre>\r\n-<p>desugars to<\/p>\r\n-<pre><code>final class Point extends java.lang.DataClass {\r\n-    final int x;\r\n-    final int y;\r\n-   =20\r\n-    public Point(int x, int y) {\r\n-        this.x =3D x;\r\n-        this.y =3D y;\r\n-    }\r\n-\r\n-    \/\/ destructuring pattern for Point(int x, int y)\r\n-    \/\/ state-based equals, hashCode, and toString\r\n-    \/\/ public read accessors x() and y()\r\n-}<\/code><\/pre>\r\n-<p>Any interfaces implemented by the data class are lifted onto the desugar=\r\n-ed class in the obvious way, as are any type variables, static fields, stat=\r\n-ic methods, and instance methods.<\/p>\r\n-<p><strong>Explicit implementations of implicit methods.<\/strong> Allowing =\r\n-explicit implementations of implicit members -- especially <code>equals()<\/=\r\n-code> and <code>hashCode()<\/code> -- is a tradeoff; they allow greater flex=\r\n-ibility in using data classes, but increase the risk that the invariants wi=\r\n-ll be violated. As a starting point, we propose that the user <em>not<\/em> =\r\n-be able to override <code>equals()<\/code> and <code>hashCode()<\/code>, that=\r\n- overrides of reader accessors are permitted but the returned value must be=\r\n- <code>equals()<\/code> to the appropriate field, and that <code>toString()<=\r\n-\/code> can be overridden as desired. If the data class provides an explicit=\r\n- implementation of any allowable implicit members, it is used in place of t=\r\n-he implicit member.<\/p>\r\n-<p><strong>Explicit constructors.<\/strong> If the data class imposes no inv=\r\n-ariants, no constructor declaration is needed, and the class acquires a def=\r\n-ault constructor whose signature matches the state description. An overridd=\r\n-en default constructor must delegate to the default principal constructor, =\r\n-as in:<\/p>\r\n-<pre><code>record Range(int lo, int hi) {\r\n-\r\n-    \/\/ Explicit default constructor\r\n-    @Override\r\n-    public Range(int lo, int hi) {\r\n-        \/\/ validation logic\r\n-        if (lo &gt; hi)\r\n-            throw new IllegalArgumentException(...);\r\n-           =20\r\n-        \/\/ delegate to default constructor\r\n-        default.this(lo, hi);\r\n-    }\r\n-}<\/code><\/pre>\r\n-<p>The <code>default.this()<\/code> call invokes the constructor that would =\r\n-otherwise have been auto-generated for this data class (including the defau=\r\n-lt <code>super<\/code> constructor); this avoids the need to write out the t=\r\n-edious and error-inviting sequence of <code>this.x =3D x<\/code> assignments=\r\n-. (The rules about statements preceding calls to <code>super<\/code> or <cod=\r\n-e>this<\/code> constructors can be relaxed, and the <code>this<\/code> refere=\r\n-nce treated as <em>definitely unassigned<\/em> for statements preceding the =\r\n-<code>default.this()<\/code> call.)<\/p>\r\n-<p>Additional constructors may be explicitly declared -- but they must dele=\r\n-gate to the default constructor (via the usual <code>this()<\/code> mechanis=\r\n-m.)<\/p>\r\n-<p><strong>Fields.<\/strong> Given a data class<\/p>\r\n-<pre><code>record Foo(int x, int y) { ... }<\/code><\/pre>\r\n-<p>we will lift the state components <code>(int x, int y)<\/code> onto field=\r\n-s of <code>Foo<\/code> -- along with any annotations specified on the state =\r\n-components. (The Javadoc for data classes will allow class parameters to be=\r\n- documented with the <code>@param<\/code> tag, as method parameters are now.=\r\n-)<\/p>\r\n-<p>The most restrictive approach would be that fields are always final; we =\r\n-could also consider making them final by default, but allowing mutability t=\r\n-o be supported by opting in via a mutability modifier (<code>non-final<\/cod=\r\n-e>, <code>unfinal<\/code>, <code>mutable<\/code> -- bikeshed to be painted la=\r\n-ter.) Similarly, the most restrictive approach would be for them to always =\r\n-have <code>package<\/code> accessibility (or <code>protected<\/code> for fiel=\r\n-ds of abstract data class); a less restrictive approach would be to treat t=\r\n-hese as defaults, but allow them to optionally be declared <code>public<\/co=\r\n-de>.<\/p>\r\n-<p>With respect to additional fields beyond those in the state description,=\r\n- the most restrictive approach would be to prohibit them; it seems inevitab=\r\n-le that such additional state would flow into equality or other essential b=\r\n-ehavior, undermining the invariants of data classes. Relaxing this constrai=\r\n-nt would likely require tightening others, such as prohibiting an explicit =\r\n-implementation of <code>equals()<\/code> and <code>hashCode()<\/code>, and ot=\r\n-her constraints on constructors (such as requiring that the call to the def=\r\n-ault constructor appear last.)<\/p>\r\n-<p>To leave room for evolution, as a starting point we will take the most r=\r\n-estrictive choices on all of these -- no additional fields, no override of =\r\n-<code>equals()<\/code> and <code>hashCode()<\/code>, and flow restrictions on=\r\n- constructors -- so that we have the flexibility to choose later which of t=\r\n-hese makes the most sense to relax.<\/p>\r\n-<p><strong>Extension.<\/strong> We've already noted that arbitrary extension=\r\n- is problematic, but it should be practical to maintain inheritance from ab=\r\n-stract data classes to other data classes. A sensible balance regarding ext=\r\n-ension is:<\/p>\r\n-<ul>\r\n-<li>Non-abstract data classes are final;<\/li>\r\n-<li>Data classes can be abstract (in which case they acquire no <code>equal=\r\n-s()<\/code>, <code>hashCode()<\/code>, or <code>toString()<\/code> methods, an=\r\n-d all constructors must be <code>protected<\/code>);<\/li>\r\n-<li>Data classes can extend abstract data classes;<\/li>\r\n-<li>No restrictions on what interfaces a data class could implement.<\/li>\r\n-<\/ul>\r\n-<p>This allows us to declare families of algebraic data types, such as the =\r\n-following partial hierarchy describing an arithmetic expression:<\/p>\r\n-<pre><code>interface Node { }\r\n-\r\n-abstract record BinaryOpNode(Node left, Node right)=20\r\n-    implements Node;\r\n-\r\n-record PlusNode(Node left, Node right)=20\r\n-      extends BinaryOperatorNode(left, right);\r\n-\r\n-record MulNode(Node left, Node right)=20\r\n-      extends BinaryOperatorNode(left, right);\r\n-     =20\r\n-record IntNode(int constant) implements Node;<\/code><\/pre>\r\n-<p>When a data class extends an abstract data class, the state description =\r\n-of the superclass must be a prefix of the state description of the subclass=\r\n-:<\/p>\r\n-<pre><code>abstract record Base(int x);\r\n-record Sub(int x, int y) extends Base(x);<\/code><\/pre>\r\n-<p>The arguments to the <code>extends Base()<\/code> clause is a list of <em=\r\n->names<\/em> of state components of <code>Sub<\/code>, not arbitrary expressi=\r\n-ons, must be a prefix of the state description of <code>Sub<\/code>, and mus=\r\n-t match the state description of <code>Base<\/code>; this suppresses the loc=\r\n-al declaration of inherited fields, and also plays into the generation of t=\r\n-he default principal constructor (which arguments are passed up to which su=\r\n-perclass constructor, vs. which are used to initialize local fields.) These=\r\n- rules are sufficient for implementing algebraic data type hierarchies like=\r\n- the <code>Node<\/code> example above.<\/p>\r\n-<p><strong>Accessors.<\/strong> Data classes are transparent; they readily g=\r\n-ive up their state through the destructuring pattern. To make this explicit=\r\n-, and to support the <em>uniform access principle<\/em> for state, data clas=\r\n-ses implicitly acquire public read accessors for all state components, whos=\r\n-e name is the same as the state component. (We will separately explore how =\r\n-arbitrary classes, that do not meet the requirements for data classes, migh=\r\n-t also benefit from accessor generation.) If write accessors are desired, t=\r\n-hey can be provided explicitly -- data classes will not bring these automat=\r\n-ically.<\/p>\r\n-<p><strong>Reflection.<\/strong> While our implementation is essentially a d=\r\n-esugaring into a mostly ordinary class with fields and methods, we don't ac=\r\n-tually want to erase the data-ness completely; compilers need to be able to=\r\n- identify which classes are data classes, and what their state descriptions=\r\n- are, so they can enforce any restrictions on how they interact with other =\r\n-classes -- so this information must be present in the class file. This can =\r\n-be reflected on <code>Class<\/code> with methods such as <code>isDataClass()=\r\n-<\/code> and a method to return the ordered list of fields that are the clas=\r\n-ses state description.<\/p>\r\n-<h4 id=3D\"compatibility-and-migration-requirements\">Compatibility and migra=\r\n-tion requirements<\/h4>\r\n-<p>It is important that existing classes that meet the requirements for dat=\r\n-a classes -- of which there are many -- should be able to be compatibly mig=\r\n-rated to data classes so that they can benefit from the semantic transparen=\r\n-cy and syntactic concision of data classes. If an existing class which meet=\r\n-s the requirements wants to migrate to be a data class, it should be able t=\r\n-o do so in a source- and binary-compatible manner by simply exposing its st=\r\n-ate through the class header and removing redundant field, constructor, and=\r\n- <code>Object<\/code> method declarations. The reverse migration is also pos=\r\n-sible; a class that is a data class can compatibly migrate to a regular cla=\r\n-ss by providing equivalent explicit implementations of the implicit members=\r\n-. However, to be behaviorally compatible, it must continue to conform to th=\r\n-e specification of <code>DataClass<\/code>.<\/p>\r\n-<p>Once a data class is published, changing its state description will have=\r\n- compatibility consequences for clients that are outside of the maintenance=\r\n- boundary. The binary- and source- compatibility impact of such changes can=\r\n- be partially mitigated by declaring new constructors and deconstruction pa=\r\n-tterns that follow the old state description (so that existing clients can =\r\n-construct and deconstruct them), but depending on existing usage, it may be=\r\n- hard to mitigate the behavioral compatibility issues, as the resulting cla=\r\n-ss may well fall afoul of the invariants of plain data carriers from the pe=\r\n-rspective of legacy clients, such as the deconstructing and reconstructing =\r\n-a data class using an old state description. For data classes operating ful=\r\n-ly within a maintenance boundary, it may be practical to compatibly refacto=\r\n-r both a data class and its clients when changing the state description.<\/p=\r\n->\r\n-<h2 id=3D\"summary\">Summary<\/h2>\r\n-<p>The key question in designing a facility for \"plain data aggregates\" in =\r\n-Java is identifying which degrees of freedom we are willing to give up. If =\r\n-we try to model all the degrees of freedom of classes, we just move the com=\r\n-plexity around; to gain some benefit, we must accept some constraints. We t=\r\n-hink that the sensible constraints to accept are disavowing the use of enca=\r\n-psulation for decoupling representation from API, and for mediating read ac=\r\n-cess to state; in turn, this provides significant syntactic and semantic be=\r\n-nefits for classes which can accept these constraints.<\/p>\r\n-\r\n-\r\n-<\/body><\/html>\r\n-------MultipartBoundary--KLTDMv0tJesJiCAvkXYWazKyyj38VNAKc9WNAZla4E----\r\n-Content-Type: text\/css\r\n-Content-Transfer-Encoding: quoted-printable\r\n-Content-Location: cid:css-dcc4f8eb-b066-410e-89e1-ce99d1c9aae5@mhtml.blink\r\n-\r\n-@charset \"utf-8\";\r\n-\r\n-code { white-space: pre; }\r\n-------MultipartBoundary--KLTDMv0tJesJiCAvkXYWazKyyj38VNAKc9WNAZla4E----\r\n-Content-Type: text\/css\r\n-Content-Transfer-Encoding: quoted-printable\r\n-Content-Location: cid:css-b6a59dd3-11c8-4fca-a4cb-4fb7233b2bf2@mhtml.blink\r\n-\r\n-@charset \"utf-8\";\r\n-\r\n-a { text-decoration: none; }\r\n-\r\n-a:link, a:visited { color: rgb(67, 114, 145); }\r\n-\r\n-a:visited { color: rgb(102, 102, 102); }\r\n-\r\n-a[href]:hover { color: rgb(231, 111, 0); }\r\n-\r\n-a img { border-width: 0px; }\r\n-\r\n-img { background: white; }\r\n-\r\n-a.internal { color: rgb(187, 0, 0); }\r\n-\r\n-a[name] { color: black; }\r\n-\r\n-body { background: white; margin: 2em 2em 100%; font-size: medium; width: 4=\r\n-0em; }\r\n-\r\n-body { font-family: \"Bitstream Vera Sans\", Verdana, \"sans serif\"; }\r\n-\r\n-pre { font-family: monospace; }\r\n-\r\n-code { font-family: \"courier new\", monospace; font-size: medium; font-weigh=\r\n-t: bold; }\r\n-\r\n-p { margin: 1ex 0em; }\r\n-\r\n-pre { margin: 1.5ex 2em; }\r\n-\r\n-blockquote { margin: 1.5ex 2em; }\r\n-\r\n-li blockquote { margin-left: 0em; }\r\n-\r\n-li { margin: 0ex 0em; }\r\n-\r\n-.todo { color: darkred; text-align: right; }\r\n-\r\n-table, th, td { border: 2px solid gray; padding: 2px; }\r\n-\r\n-table { border-collapse: collapse; }\r\n-\r\n-td { vertical-align: top; }\r\n-\r\n-ul li { list-style-type: square; }\r\n-\r\n-div.summary { margin: 2ex 2em; }\r\n-\r\n-div.head { margin-bottom: 2em; }\r\n-\r\n-div.doctitle { font-size: x-large; font-weight: bold; }\r\n-\r\n-div.twarn { color: rgb(204, 0, 0); font-size: smaller; font-weight: bold; m=\r\n-argin-bottom: 1.5ex; }\r\n-\r\n-div.authors { margin-top: 1ex; font-size: large; }\r\n-\r\n-div.author a { font-style: italic; }\r\n-\r\n-div.version { font-size: medium; margin-top: 1ex; }\r\n-\r\n-div.copyright, div.comments { font-size: small; }\r\n-\r\n-div.version span.modified { color: green; font-weight: bold; }\r\n-\r\n-div.head div.notes { margin-top: 1ex; }\r\n-\r\n-p.subsection { margin-top: 2ex; }\r\n-\r\n-p.subsection:first-child { margin-top: 1ex; }\r\n-\r\n-p span.title { font-weight: bold; padding-right: 1em; }\r\n-\r\n-hr { border-width: 1px 0px 0px; border-right-style: initial; border-bottom-=\r\n-style: initial; border-left-style: initial; border-right-color: initial; bo=\r\n-rder-bottom-color: initial; border-left-color: initial; border-image: initi=\r\n-al; border-top-style: solid; border-top-color: black; margin: 2ex 0em; }\r\n-\r\n-div.qa { margin-top: 2ex; }\r\n-\r\n-h1 { font-size: x-large; }\r\n-\r\n-h2 { font-size: large; margin-top: 3ex; margin-bottom: 0ex; }\r\n-\r\n-pre { width: 60em; padding: 1px 1ex; background: rgb(232, 232, 232); font-s=\r\n-ize: smaller; }\r\n-\r\n-pre.jvm { font-style: italic; }\r\n-------MultipartBoundary--KLTDMv0tJesJiCAvkXYWazKyyj38VNAKc9WNAZla4E------\r\n+<!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD XHTML 1.0 Transitional\/\/EN\" \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-transitional.dtd\">\n+<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\">\n+<head>\n+  <meta http-equiv=\"Content-Type\" content=\"text\/html; charset=utf-8\" \/>\n+  <meta http-equiv=\"Content-Style-Type\" content=\"text\/css\" \/>\n+  <meta name=\"generator\" content=\"pandoc\" \/>\n+  <title><\/title>\n+  <style type=\"text\/css\">code{white-space: pre;}<\/style>\n+      <style type=\"text\/css\">\n+        @import url('\/.fonts\/dejavu.css');\n+        A { text-decoration: none; }\n+        A:link, A:visited { color: #437291; }\n+        A:visited { color: #666666; }\n+        A[href]:hover { color: #e76f00; }\n+        A IMG { border-width: 0px; }\n+        IMG { background: white; }\n+        A.internal { color: #b00; }\n+        A[name] { color: black; }\n+  \n+        BODY {\n+          background: white;\n+          margin: 2em;\n+          font-size: medium;\n+          width: 40em;\n+          margin-bottom: 100%;\n+        }\n+        BODY { font-family: DejaVu Sans, Bitstream Vera Sans, Verdana, sans serif; }\n+        PRE { font-family: monospace; }\n+        CODE { font-family: DejaVu Sans Mono, Bitstream Vera Sans Mono, Monaco,\n+               courier new, monospace; font-size: medium; }\n+  \n+        P { margin: 1ex 0em; }\n+        PRE { margin: 1.5ex 2em; }\n+        BLOCKQUOTE { margin: 1.5ex 2em; }\n+        LI BLOCKQUOTE { margin-left: 0em; }\n+        LI { margin: 0ex 0em; }\n+        .todo { color: darkred; text-align: right; }\n+  \n+        TABLE, TH, TD { border: 2px solid gray; padding: 2px; }\n+        TABLE { border-collapse: collapse; }\n+        TD { vertical-align: top; }\n+  \n+        UL LI { list-style-type: square; }\n+  \n+        DIV.summary { margin: 2ex 2em; }\n+  \n+        DIV.head { margin-bottom: 2em; }\n+        DIV.doctitle { font-size: x-large; font-weight: bold; }\n+        DIV.twarn { color: #cc0000; font-size: smaller; font-weight: bold;\n+                    margin-bottom: 1.5ex; }\n+        DIV.authors { margin-top: 1ex; font-size: large; }\n+        DIV.author A { font-style: italic; }\n+        DIV.version { font-size: medium; margin-top: 1ex; }\n+        DIV.copyright, DIV.comments { font-size: small; }\n+        DIV.version SPAN.modified { color: green; font-weight: bold; }\n+        DIV.head DIV.notes { margin-top: 1ex; }\n+  \n+        P.subsection { margin-top: 2ex; }\n+        P.subsection:first-child { margin-top: 1ex; }\n+        P SPAN.title { font-weight: bold; padding-right: 1em; }\n+  \n+        HR { border: 0px; border-top: 1px solid black; margin: 2ex 0em; }\n+  \n+        DIV.qa { margin-top: 2ex; }\n+  \n+        H1 { font-size: x-large; }\n+        H2 { font-size: large; margin-top: 3ex; margin-bottom: 0ex; }\n+  \n+        PRE {\n+          width: 60em;\n+          padding: 1px 1ex;\n+          font-size: smaller;\n+          ZZdisplay: none;\n+        }\n+  \n+        PRE.jvm { font-style: italic; }\n+     <\/style>\n+<\/head>\n+<body>\n+  <h2>THIS DOCUMENT HAS BEEN SUPERSEDED AND IS PROVIDED FOR HISTORICAL CONTEXT ONLY<\/h2>\n+<h1 id=\"data-classes-for-java\">Data Classes for Java<\/h1>\n+<h4 id=\"brian-goetz-february-2018\">Brian Goetz, February 2018<\/h4>\n+<p>This document explores possible directions for <em>data classes<\/em> in the Java Language. This is an exploratory document only and does not constitute a plan for any specific feature in any specific version of the Java Language.<\/p>\n+<h2 id=\"background\">Background<\/h2>\n+<p>It is a common (and often deserved) complaint that &quot;Java is too verbose&quot; or has too much &quot;ceremony.&quot; A significant contributor to this is that while classes can flexibly model a variety of programming paradigms, this invariably comes with modeling overheads -- and in the case of classes that are nothing more than &quot;plain data carriers&quot;, these modeling overhead can be out of line with their value. To write a simple data carrier class responsibly, we have to write a lot of low-value, repetitive code: constructors, accessors, <code>equals()<\/code>, <code>hashCode()<\/code>, <code>toString()<\/code>, etc. And developers are sometimes tempted to cut corners such as omitting these important methods, leading to surprising behavior or poor debuggability, or pressing an alternate but not entirely appropriate class into service because it has the &quot;right shape&quot; and they don't want to define yet another class.<\/p>\n+<p>IDEs will help you <em>write<\/em> most of this code, but writing code is only a small part of the problem. IDEs don't do anything to help the <em>reader<\/em> distill the design intent of &quot;I'm a plain data carrier for <code>x<\/code>, <code>y<\/code>, and <code>z<\/code>&quot; from the dozens of lines of boilerplate code. And repetitive code is a good place for bugs to hide; if we can, it is best to eliminate their hiding spots outright.<\/p>\n+<p>We don't yet have a formal definition of &quot;plain data carrier&quot;, but we probably &quot;know it when we see it&quot;. Nobody thinks that <code>SocketInputStream<\/code> is just a carrier for some data; it fully encapsulates some complex and unspecified state (including a native resource) and exposes an interface contract that likely looks nothing like its internal representation.<\/p>\n+<p>At the other extreme, its pretty clear that:<\/p>\n+<pre><code>final class Point {\n+    public final int x;\n+    public final int y;\n+\n+    public Point(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    \/\/ state-based implementations of equals, hashCode, toString\n+    \/\/ nothing else<\/code><\/pre>\n+<p>}<\/p>\n+<p>is &quot;just&quot; the data <code>(x, y)<\/code>. Its representation is <code>(x, y)<\/code>, its construction protocol accepts an <code>(x, y)<\/code> pair and stores it directly into the representation, provides unmediated access to that representation, and derives the core <code>Object<\/code> methods from that representation.<\/p>\n+<h4 id=\"data-classes-in-other-oo-languages\">Data classes in other OO languages<\/h4>\n+<p>Other OO languages have explored compact syntactic forms for modeling data-oriented classes: <code>case<\/code> classes in <a href=\"https:\/\/docs.scala-lang.org\/tour\/case-classes.html\">Scala<\/a>, <code>data<\/code> classes in <a href=\"https:\/\/kotlinlang.org\/docs\/reference\/data-classes.html\">Kotlin<\/a>, and soon, <code>record<\/code> classes in <a href=\"https:\/\/github.com\/dotnet\/roslyn\/blob\/features\/records\/docs\/features\/records.md\">C#<\/a>. These have in common that some or all of the state of a class can be described directly directly in the class header (though they vary considerably in their semantics, such as constraints on the mutability or accessibility of fields, extensibility of the class, and other restrictions.) Committing in the class declaration to at least part of the relationship between state and interface enables suitable defaults to be provided for various state-related members such as constructors or <code>Object<\/code> methods. All of these mechanisms (let's call them &quot;data classes&quot;) seek to bring us closer to the goal of being able to define <code>Point<\/code> as:<\/p>\n+<pre><code>record Point(int x, int y) { }<\/code><\/pre>\n+<p>The clarity and compactness here is surely attractive -- a <code>Point<\/code> is just a carrier for two integer components <code>x<\/code> and <code>y<\/code>, and from that, the reader immediately knows that there are sensible <em>and correct<\/em> implementations for the core <code>Object<\/code> methods, and doesn't have to wade through a page of boilerplate to be able to confidently reason about their semantics. Most developers are going to say &quot;Well, of course I want <em>that<\/em>.&quot;<\/p>\n+<h4 id=\"meet-the-elephant\">Meet the elephant<\/h4>\n+<p>Unfortunately, such universal consensus is only syntax-deep; almost immediately after we finish celebrating the concision, comes the debate over the natural semantics of such a construct, and what restrictions we are willing to accept. Are they extensible? Are the fields mutable? Can I control the behavior of the generated methods, or the accessibility of the fields? Can I have additional fields and constructors?<\/p>\n+<p>Just like the story of the blind men and the elephant, developers are likely to bring very different assumptions about the &quot;obvious&quot; semantics of a data class. To bring these implicit assumptions into the open, let's name the various positions.<\/p>\n+<p><em>Algebraic Annie<\/em> will say &quot;a data class is just an algebraic product type.&quot; Like Scala's case classes, they come paired with pattern matching, and are best served immutable. (And for dessert, Annie would order sealed interfaces.)<\/p>\n+<p><em>Boilerplate Billy<\/em> will say &quot;a data class is just an ordinary class with better syntax&quot;, and will likely bristle at constraints on mutability, extension, or encapsulation. (Billy's brother, JavaBean Jerry, will say &quot;these must be for JavaBeans -- so of course I get getters and setters too.&quot; And his sister, POJO Patty, remarks that she is drowning in enterprise POJOs, and hopes they are proxyable by frameworks like Hibernate.)<\/p>\n+<p><em>Tuple Tommy<\/em> will say &quot;a data class is just a nominal tuple&quot; -- and may not even be expecting them to have methods other than the core <code>Object<\/code> methods -- they're just the simplest of aggregates. (He might even expect the names to be erased, so that two data classes of the same &quot;shape&quot; can be freely converted.)<\/p>\n+<p><em>Values Victor<\/em> will say &quot;a data class is really just a more transparent value type.&quot;<\/p>\n+<p>All of these personae are united in favor of &quot;data classes&quot; -- but have different ideas of what data classes are, and there may not be any one solution that makes them all happy.<\/p>\n+<h4 id=\"encapsulation-and-boundaries\">Encapsulation and boundaries<\/h4>\n+<p>While we're painfully aware of the state-related boilerplate we deal with every day, the boilerplate is just a symptom of a deeper problem, which is that Java asks all classes are asked to pay equally for the cost of encapsulation -- but not all classes benefit equally from it.<\/p>\n+<p>To be sure, encapsulation is essential; encapsulating our state (so it can't be manipulated without our oversight) and our representation (so it can be evolved without affecting the API contract) enables us to write code that can operate safely and robustly across a variety of <em>boundaries<\/em>:<\/p>\n+<ul>\n+<li>Maintenance boundaries -- when our clients are working in a different sourcebase or organization;<\/li>\n+<li>Security and trust boundaries -- where we do not want to expose our state to clients because we do not fully trust them to not deliberately modify or use it in malicious ways;<\/li>\n+<li>Integrity boundaries -- where we do not want to expose our state to clients because, while we may trust their intent and are willing to share our data with them, do not wish to burden them with the task of maintaining our own representational invariants;<\/li>\n+<li>Versioning boundaries -- where we want to ensure that clients compiled against one version of a library continue to work when run against a subsequent version.<\/li>\n+<\/ul>\n+<p>But, not all classes value their boundaries equally. Defending these boundaries is essential for a class like <code>KeyStore<\/code> or <code>SocketInputStream<\/code>, but is of far less value for a class like <code>Point<\/code> or <code>Person<\/code>. Many classes are not concerned at all with defending their boundaries; perhaps they are private to a package or module and co-compiled with their clients, trust their clients, and have no complex invariants that need protecting. Since the cost of establishing and defending these boundaries (how constructor arguments map to state, how to derive the equality contract from state, etc) is constant across classes, but the benefit is not, the cost may sometimes be out of line with the benefit. This is what Java developers mean by &quot;too much ceremony&quot; -- not that the ceremony has no value, but that they're forced to invoke it even when it does not offer sufficient value.<\/p>\n+<p>The encapsulation model that Java provides -- where the representation is entirely decoupled from construction, state access, and equality -- is just more than many classes need. Classes that have a simpler relationship with their boundaries can benefit from a simpler model where we can define a class as a thin wrapper around its state, and derive the relationship between state, construction, equality, and state access from that.<\/p>\n+<p>Further, the costs of decoupling representation from API goes beyond the overhead of declaring boilerplate members; encapsulation is, by its nature, information-destroying. If you see a class with a constructor that takes an argument <code>x<\/code>, and an accessor called <code>x()<\/code>, we often have only convention to tell us that they probably refer to the same thing. Relying on this is a pretty safe guess, but its just a guess. It would be nicer if tools and library code could mechnically rely on this correspondence -- without a human having to read the specs (if there even is one!) to confirm this expectation.<\/p>\n+<h4 id=\"digression----enums\">Digression -- enums<\/h4>\n+<p>If the problem is that we're modeling something simple with something overly general, simplification is going to come from constraint; by letting go of some degrees of freedom, we hope to be freed of the obligation to specify everything explicitly.<\/p>\n+<p>The <code>enum<\/code> facility, added in Java 5, is an excellent example of such a tradeoff. The type-safe enum pattern was well understood, and easy to express (albeit verbosely), prior to Java 5 (see <a href=\"https:\/\/www.amazon.com\/gp\/product\/0321356683?ie=UTF8&amp;tag=briangoetz-20&amp;camp=1789&amp;linkCode=xm2&amp;creativeASIN=0321356683\">Effective Java, 1st Edition<\/a>, item 21.) The initial motivation to add enums to the language might have been irritation at the boilerplate required for this idiom, but the real benefit is semantic.<\/p>\n+<p>The key simplification of enums was to constrain the lifecycle of enum instances -- enum constants are singletons, and the requisite instance control is managed by the runtime. By baking singleton-awareness into the language model, the compiler can safely and correctly generate the boilerplate needed for the type-safe enum pattern. And because enums started with a semantic goal, rather than a syntactic one, it was possible for enums to interact positively with other features, such as the ability to <code>switch<\/code> on enums, or to get comparison and safe serialization for free.<\/p>\n+<p>Perhaps surprisingly, enums delivered their syntactic and semantic benefits without requiring us to give up most other degrees of freedom that classes enjoy; Java's enums are not mere enumerations of integers, as they are in many other languages, but instead are full-fledged classes, with unconstrained state and behavior, and even subtyping (constrained to interface inheritance only.)<\/p>\n+<p>If we are looking to replicate the success of this approach with data classes, our first question must therefore be: what constraints will give us the semantic and syntactic benefits we want, and, are we willing to accept these constraints?<\/p>\n+<h4 id=\"why-not-just-do-tuples\">Why not &quot;just&quot; do tuples?<\/h4>\n+<p>Some readers may feel at this point that if we &quot;just&quot; had tuples, we wouldn't need data classes. And while tuples might offer a lighter-weight means to express some aggregates, the result is often inferior aggregates.<\/p>\n+<p>Classes and their members have names; tuples and their members do not. A central aspect of Java's philosophy is that <em>names matter<\/em>; a <code>Person<\/code> with properties <code>firstName<\/code> and <code>lastName<\/code> is clearer and safer than a tuple of <code>String<\/code> and <code>String<\/code>. Classes support state validation through their constructors; tuples do not. Some data aggregates (such as ranges) have invariants that, if enforced by the constructor, can thereafter be relied upon; tuples do not offer this ability. Classes can have behavior that is derived from their state; co-locating state and derived behavior makes it more discoverable and easier to access.<\/p>\n+<p>For all these reasons, we don't want to abandon classes for modeling data; we just want to make modeling data with classes simpler. The major pain of using named classes for aggregates is the overhead of declaring them; if we can reduce this, the temptation to reach for more weakly typed mechanisms is greatly reduced.<\/p>\n+<h4 id=\"are-data-classes-the-same-as-value-types\">Are data classes the same as value types?<\/h4>\n+<p>With <em>value types<\/em> coming down the road through <a href=\"http:\/\/openjdk.java.net\/projects\/valhalla\/\">Project Valhalla<\/a>, it is reasonable to ask about the overlap between (immutable) data classes and value types, and as whether the intersection of data-ness and value-ness is a useful space to inhabit.<\/p>\n+<p>Value types are primarily about enabling <em>flat<\/em> and <em>dense<\/em> layout of objects in memory. The central sacrifice of value types is <em>object identity<\/em>; in exchange for giving up object identity (which entails giving up mutability and layout polymorphism), the runtime can elide object headers, inline values directly into other values, objects, and arrays, and freely hoist values from the heap into registers or onto the stack. The lack of layout polymorphism means we have to give up something else: self-reference. A value type <code>V<\/code> cannot refer, directly or indirectly, to another <code>V<\/code>. But value classes need not give up any encapsulation, and in fact encapsulation is essential for some applications of value types (such as &quot;smart pointers&quot; or references to native resources.)<\/p>\n+<p>On the other hand, data class instances have identity, which supports mutability (maybe) but also supports self-reference. Unlike value types, data classes are well suited to representing tree and graph nodes.<\/p>\n+<p>Each of these simplified aggregate forms -- values and data classes -- involves accepting certain restrictions in exchange for certain benefits. If we're willing to accept both sets of restrictions, we get both sets of benefits; the notion of a &quot;value data class&quot; is perfectly sensible for things like extended numerics or tuples.<\/p>\n+<h2 id=\"towards-requirements-for-data-classes\">Towards requirements for data classes<\/h2>\n+<p>While it is superficially tempting to to treat data classes as primarily being about boilerplate reduction, we prefer to start with a semantic goal: <em>modeling data as data<\/em>. If we choose our goals correctly, the boilerplate will take care of itself, and we will gain additional benefits aside from concision.<\/p>\n+<p>So, what do we mean by &quot;modeling data as data&quot;, and what are we going to have to give up? What degrees of freedom that classes enjoy do such &quot;plain&quot; data aggregates not need, that we can eliminate and thereby simplify the model? Java's object model is built around the assumption that we want the representation of an object to be completely decoupled from its API; the APIs and behavior of constructors, accessor methods, and <code>Object<\/code> methods need not align directly with the object's state, or even with each other. However, in practice, they are frequently much more tightly coupled; a <code>Point<\/code> object has fields <code>x<\/code> and <code>y<\/code>, a constructor that takes <code>x<\/code> and <code>y<\/code>, accessors for <code>x<\/code> and <code>y<\/code> and initializes those fields, and <code>Object<\/code> methods that characterize points solely by their <code>x<\/code> and <code>y<\/code> values. We claim that for a class to be &quot;just a plain carrier for its data&quot;, this coupling is something that can be counted upon -- that we're giving up the ability to decouple its (publicly declared) state from its API. The API for a data class models <em>the state, the whole state, and nothing but the state<\/em>.<\/p>\n+<p>Being able to count on this coupling drives a number of advantages. The compiler can generate sensible and correct implementations for standard class members. Clients can freely deconstruct and reconstruct aggregates, or restructure them into a more convenient form, without fear that they will discard hidden data or undermine hidden assumptions. Frameworks can safely and mechanically serialize or marshal them, without the need to provide complex mapping mechanisms. By giving up the flexibility to decouple a classes state from its API, we gain all of these benefits.<\/p>\n+<p>One consequence of this is that data classes are <em>transparent<\/em>; they give up their data freely to all requestors. Otherwise, their API doesn't model their whole state, and we lose the ability to freely deconstruct and reconstruct them.<\/p>\n+<h4 id=\"use-cases-for-data-classes\">Use cases for data classes<\/h4>\n+<p>Applications are full of use cases for simple aggregates that are just wrappers for their data.<\/p>\n+<ul>\n+<li>Messages -- messages exchanged by actors or web services, or processed through a message fabric;<\/li>\n+<li>Document nodes -- compilers and word processors represent documents as trees of simple, structured nodes;<\/li>\n+<li>Disconnected entities -- to pass data entities across layers or services, they are frequently represented as simple data aggregates with minimal behavior;<\/li>\n+<li>Low-overhead aggregates -- almost any nontrivial computation involves maintaining tuples of related data as an intermediate result.<\/li>\n+<\/ul>\n+<p>All of these applications can benefit from the nominality of classes (both of the aggregate and of the components) and the co-location of data with behavior, but have no need to model them with the full generality of objects. A simpler aggregation mechanism will do -- because they're simple data aggregates, rather than models of stateful processes.<\/p>\n+<h4 id=\"data-classes-and-pattern-matching\">Data classes and pattern matching<\/h4>\n+<p>One of the big advantages of defining data classes in terms of coupling their API to a publicly specified state description, rather than simply as boilerplate-reduced class, we gain the ability to freely convert a data class instance back and forth between its aggregate form and its exploded state. This has a natural connection with <em>pattern matching<\/em>; by coupling the API to the state description, there is an obvious deconstruction pattern -- whose signature is the dual of the constructor's -- which can be mechanically generated.<\/p>\n+<p>For example, suppose we have data classes as follows:<\/p>\n+<pre><code>interface Shape { }\n+record Point(int x, int y);\n+record Rect(Point p1, Point p2) implements Shape;\n+record Circle(Point center, int radius) implements Shape;<\/code><\/pre>\n+<p>A client can deconstruct a shape as follows:<\/p>\n+<pre><code>switch (shape) {\n+     case Rect(Point(var x1, var y1), Point(var x2, var y2)): ...\n+     case Circle(Point(var x, var y), int r): ...\n+     ....\n+}<\/code><\/pre>\n+<p>with the mechanically generated pattern extractors. This synergy between data classes and pattern matching makes each feature more expressive. However, a not-entirely-obvious consequence of this is that there is no such thing as truly <code>private<\/code> fields in a data class; even if the fields were to be declared private, their values would still be implicitly readable via the destructuring pattern. This would be surprising if our design center for data class was that they are merely a boilerplate reduction tool -- but is consistent with data classes being transparent carriers for their data.<\/p>\n+<h4 id=\"data-classes-and-externalization\">Data classes and externalization<\/h4>\n+<p>Data classes are also a natural fit for safe, mechanical externalization (serialization, marshaling to and from JSON or XML, mapping to database rows, etc). If a class is a transparent carrier for a state vector, and the components of that state vector can in turn be externalized in the desired encoding, then the carrier can be safely and mechanically marshaled and unmarshaled with guaranteed fidelity, without the security and integrity risks of bypassing the constructor (as built-in serialization does). In fact, a transparent carrier need not do anything special to support externalization; the externalization framework can deconstruct the object using its deconstruction pattern, and reconstruct it using its constructor, which are already public.<\/p>\n+<h2 id=\"formalizing-the-requirements\">Formalizing the requirements<\/h2>\n+<p>Let's formalize this notion a bit, so we can use this to evaluate potential design choices. We say a class <code>C<\/code> is a transparent carrier for a state vector <code>S<\/code> if:<\/p>\n+<ul>\n+<li>There is a function <em>ctor<\/em> : <code>S<\/code> -&gt; <code>C<\/code> which maps an instance of the state vector to an instance of <code>C<\/code>. (The constructor may reject some state vectors as invalid, such as rational numbers whose denominator is zero.)<\/li>\n+<li>There is a total function <em>dtor<\/em> : <code>C<\/code> -&gt; <code>S<\/code> which maps an instance of <code>C<\/code> to a state vector <code>S<\/code> in the domain of <em>ctor<\/em>.<\/li>\n+<li>For any instance <em>c<\/em> of <code>C<\/code>, <em>ctor(dtor(c))<\/em> is equal to <em>c<\/em>, according to the <code>equals()<\/code> contract for <code>C<\/code>.<\/li>\n+<li>For two state vectors <em>s1<\/em> and <em>s2<\/em>, if each of their components is equal to the corresponding component of the other (according to the component's <code>equals()<\/code> contract), then either <em>ctor(s1)<\/em> and <em>ctor(s2)<\/em> are both undefined, or they are equals under the <code>equals()<\/code> contract for <code>C<\/code>.<\/li>\n+<li>For equivalent instances <code>c<\/code> and <code>d<\/code>, invoking the same operation produces equivalent results: <code>c.m()<\/code> equals <code>d.m()<\/code>. Moreover, after the operation, <code>c<\/code> and <code>d<\/code> should still be equivalent.<\/li>\n+<\/ul>\n+<p>This means that <code>C<\/code> has a constructor (or factory) which accepts the state vector <code>S<\/code>, and accessors (or a deconstruction pattern) which produces the components of <code>S<\/code>, and that for any valid instance, extracting the state vector and then reconstructing an instance from that state vector produces an instance equivalent to the original. Similarly, constructing instances from equivalent state vectors produces equivalent instances. (Mathematically inclined readers will spot the embedding-projection pair.) Moreover any additional operations on equivalent instances produce equivalent results and preserve the equivalence of the instances.<\/p>\n+<p>These invariants are an attempt to capture our requirements; that the carrier is transparent, and that there is a simple and predictable relationship between the classes representation, its construction, and its destructuring -- that the API <em>is<\/em> the representation.<\/p>\n+<p>Note that so far, we haven't said anything about syntax or boilerplate; we've only talked about constraining the semantics of the class to be a simple carrier for a specified state vector. But these constraints allow us to safely and mechanically generate the boilerplate for constructors, pattern extractors, accessors, <code>equals()<\/code>, <code>hashCode()<\/code>, and <code>toString()<\/code>, externalization, and more.<\/p>\n+<h2 id=\"a-starting-point\">A starting point<\/h2>\n+<p>The simplest -- and most draconian -- model for data classes is to say that a data class is a final class with public final fields for each state component, a public constructor and deconstruction pattern whose signature matches that of the state description, and state-based implementations of the core <code>Object<\/code> methods, and further, that no other members (or explicit implementations of the implicit members) are allowed. This is essentially the strictest interpretation of a <em>nominal tuple<\/em>.<\/p>\n+<p>This starting point is simple and stable -- and nearly everyone will find something to object to about it. So, how much can we relax these constraints without giving up on the semantic benefits we want? Let's look at some directions in which the draconian starting point could be extended, and their interactions.<\/p>\n+<h4 id=\"interfaces-and-additional-methods\">Interfaces and additional methods<\/h4>\n+<p>One obvious direction for relaxing this model is to allow data classes to implement interfaces or to declare methods that operate on their state. No one could claim that the following class violates the spirit of data-class-ness:<\/p>\n+<pre><code>record Point(int x, int y) {\n+    boolean isOrigin() {\n+        return x == 0 &amp;&amp; y == 0;\n+    }\n+}<\/code><\/pre>\n+<p>The method <code>isOrigin()<\/code> merely computes a derived property of the state; the obvious place to put this is in the class that models the state. Similarly, no one could object to having <code>Point<\/code> implement <code>Comparable&lt;Point&gt;<\/code>.<\/p>\n+<p>However, even allowing additional methods is stepping onto a slippery slope; if the method's behavior depends on anything other than the state of the object (including depending on the identity of the instance), then we've violated our &quot;nothing but the state&quot; rule.<\/p>\n+<h4 id=\"overriding-implicit-members\">Overriding implicit members<\/h4>\n+<p>The default implementations of constructors and <code>Object<\/code> methods is likely to be what is desired in a lot of cases, but there may be cases where we want to refine these further, such as a constructor that enforces validity constraints, or an <code>equals()<\/code> method that compares array components by content rather than delegating to <code>Object.equals()<\/code>. The natural way to denote this would be to declare explicit versions of these members, and have this suppress the generation of the implicit member.<\/p>\n+<p>Allowing refined implementations expands the range of useful data classes, but again exposes us to the risk that the the explicit implementations won't conform to the requirements of a plain data carrier.<\/p>\n+<p>The most common case of overriding an implicit member is likely to be overriding the constructor, to validate that the state conforms to its invariants. Data classes without representational invariants should not require an explicit constructor, but ideally it should be possible to specify an explicit constructor that enforces invariants -- without having to write out all the constructor boilerplate out by hand.<\/p>\n+<h4 id=\"additional-constructors\">Additional constructors<\/h4>\n+<p>Related to additional methods is additional constructors. Data classes clearly need a constructor whose signature matches that of the state description (call this the <em>principal constructor<\/em>); otherwise, we couldn't freely deconstruct and reconstruct it. But it may also be desirable to offer additional constructors, which can derive the state from some alternate form. On the surface, this seems reasonable -- so long as the constructor is not squirreling away data that is effectively part of the object state, but not part of the state description.<\/p>\n+<h4 id=\"additional-fields\">Additional fields<\/h4>\n+<p>Related to the previous item is the question of whether a data class can have additional fields beyond its state description. And again, there are cases when this is harmless, and cases when this completely violates our requirements.<\/p>\n+<p>An additional field that merely caches a derived property of the state description (whether computed eagerly or lazily) is fine, because it is still logically &quot;nothing but the state&quot;. For example:<\/p>\n+<pre><code>record Name(String first, String last) {\n+    private String firstAndLast;\n+    \n+    Name(String first, String last) {\n+        firstAndList = first + &quot; &quot; + last;\n+    }\n+    \n+    public String firstAndLast() { return firstAndLast; }\n+}<\/code><\/pre>\n+<p>is well within the spirit of the requirements; the existence of the <code>firstAndList<\/code> field is purely an implementation detail, but the behavior of the <code>Name<\/code> class is derived solely from its state description.<\/p>\n+<p>On the other hand, squirreling away additional state which is not derived from the state description, and which affects the user-visible behavior of its methods (especially <code>equals()<\/code> and <code>hashCode()<\/code>!), would totally violate the goal that a data class is &quot;just&quot; a carrier for its state. Similarly, if they affected the behavior of mutative methods, this would undermine the requirement that performing identical actions on equal carriers results in equal carriers.<\/p>\n+<p>So, even more so that with explicit methods or constructors, additional fields are a significant risk item for undermining the goal that a data class models &quot;the state, the whole state, and nothing but the state.&quot;<\/p>\n+<h4 id=\"extension\">Extension<\/h4>\n+<p>Can a data class extend an ordinary class? Can a data class extend another data class? Can a non-data class extend a data class? Again, our model of &quot;plain data carrier&quot; can help us evaluate these.<\/p>\n+<p>Extension between data classes and non-data classes, or between concrete data classes, seems immediately problematic. If a data class extends an ordinary class, we would have no control over the <code>equals()<\/code> contract of the superclass, and therefore no reason to believe that the desired invariants hold.<\/p>\n+<p>Similarly, if another class (data or not) were to extend a data class, we'd almost certainly violate the desired invariants. Consider:<\/p>\n+<pre><code>__data class C(STATE_DESCR) { }\n+\n+class D extends C { \n+   ...\n+}\n+\n+D d = ...\n+switch (d) { \n+    case C(var STATE_DESCR): assert d.equals(new C(STATE_DESCR));\n+    ...\n+}<\/code><\/pre>\n+<p>Deconstructing a <code>C<\/code> and reconstructing it should yield an equivalent instance -- but in this case, it will not. D is not a plain carrier for C's state description, as it has at least some additional typestate, and perhaps some additional state, which may cause the equality check to fail. The same argument can be made for a concrete data class extending another concrete data class (though we may be able to rescue abstract data classes.)<\/p>\n+<h4 id=\"mutability\">Mutability<\/h4>\n+<p>One of the thorniest problems is whether we allow mutability, and how we handle the consequences if we do. The simplest solution -- and surely a tempting one -- is to insist that state components of data classes be <code>final<\/code>. While this is an attractive opening position, this is likely to be too limiting; while immutable data is surely better-behaved than mutable data, mutable data certainly qualifies as &quot;data&quot;, and there are many legitimate uses for mutable &quot;plain data&quot; aggregates. (And, even if we required that data class fields always be <code>final<\/code>, this only gives us shallow immutability -- we still have to deal with the possibility that the contents are more deeply mutable.)<\/p>\n+<p>It is worth noting that similar languages that went down the data-class path -- including Scala, Kotlin, and C# -- all settled on not forcing data classes to be immutable, though its almost certain that their designers initially considered doing so. (Even if we allow mutability, we still have the option of nudging users towards finality, say by making the default for data class fields <code>final<\/code>, and providing a way to opt out of finality for individual fields.)<\/p>\n+<h4 id=\"field-encapsulation-and-accessors\">Field encapsulation and accessors<\/h4>\n+<p>Public fields make everyone nervous, even public final fields. If fields can be nonfinal, they certainly need some encapsulation support; even if they cannot, it still may be desirable to encapsulate the field and instead provide a read accessor, to support the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Uniform_access_principle\">uniform access principle<\/a>.<\/p>\n+<p>Encapsulating fields and mediating access to state may serve to protect integrity boundaries (rejecting writes that would violate representational invariants), detect when when writes have happened so that listeners can be notified or cached state can be adjusted; or to make defensive copies on reads for mutable components such as arrays. However, we must be careful to avoid undermining the transparency of data classes; each state component must be readable somehow.<\/p>\n+<p>No discussion involving boilerplate (or any question of Java language evolution, for that matter) can be complete without the subject of field accessors (and properties) coming up. On the one hand, accessors constitute a significant portion of the boilerplate in existing code; on the other hand, the JavaBean-style getter\/setter conventions are already badly overused. Mutability may drag with it encapsulation, and encapsulation plus transparency may in turn drag accessors with them, but we should be mindful of the purpose of these accessors; it is not to abstract the representation from the API, but at most to enable rejection of bad values and provide syntactic uniformity of access.<\/p>\n+<p>(Without rehashing the properties debate, one fundamental objection to automating JavaBean-style field accessors is that it would take what is at best a questionable -- and certainly overused -- API naming convention and burn it into the language. Unlike the core methods like <code>Object.equals()<\/code>, field accessors do not have any special treatment in the language, and so names of the form <code>getSize()<\/code> should not either. Also, while equally tedious, writing (and reading) accessor declarations are not nearly as error-prone as <code>equals()<\/code>.)<\/p>\n+<h4 id=\"arrays-and-defensive-copies\">Arrays and defensive copies<\/h4>\n+<p>Array-valued fields are particularly problematic, as there is no way to make them deeply immutable. But they're really just a special case of mutable objects which do not provide unmodifiable views. APIs that encapsulate arrays frequently make defensive copies when they're on the other side of a trust boundary from their users. Should data classes support this? Unfortunately, this also falls afoul of our requirements for data classes.<\/p>\n+<p>Because the <code>equals()<\/code> method of arrays is inherited from <code>Object<\/code>, which compares instances by identity, making defensive copies of array components in read accessors would violate the invariant that destructuring an instance of a data class and reconstructing it yields an equal instance -- the defensive copy and the original array will not be equal to each other. (Arrays are simply a bad fit for data classes, as they are mutable, but unlike <code>List<\/code> their <code>equals()<\/code> method is based on identity.) We'd rather not distort data classes to accomodate arrays, especially as there are ample alternatives available.<\/p>\n+<h4 id=\"thread-safety\">Thread-safety<\/h4>\n+<p>Allowing mutable state in data classes raises the question of whether, and how, they can be made thread-safe. (Note that thread-safety is not a requirement for mutable classes; many useful classes, such as <code>ArrayList<\/code>, are not thread-safe.) Thread-safe classes encapsulate a protocol for coordinating access to their shared mutable state. But, data classes disavow most forms of encapsulation. (Immutable objects are implicitly thread-safe, because there is no shared mutable state to which access need be coordinated.)<\/p>\n+<p>Like most non-thread-safe classes, instances of mutable data classes can still be used safely in concurrent environments through <em>confinement<\/em>, where the data class instance is encapsulated within a thread-safe class. While it might be possible to nibble around the edges to support a few use cases, ultimately data classes are not going to be the right tool for creating thread-safe mutable classes, and rather than reinventing all the flexibility of classes in a new syntax, we should probably just guide people to writing ordinary classes in these cases.<\/p>\n+<h2 id=\"a-concrete-proposal\">A concrete proposal<\/h2>\n+<p>The central compromise we make for data classes is that we give up the ability to decouple the API semantics from the state description, to define non-state-based semantics for equality and hashing, and to hide state from curious readers. In return, we gain the ability for the compiler to generate key class members, as well as the ability to safely and mechanically copy, serialize, and externalize data classes.<\/p>\n+<p>What <em>don't<\/em> we have to give up to get this? Quite a lot. Data classes can be generic, can implement interfaces, can have static fields, and can have constructors and methods, all without compromising this commitments. To start, let's say that<\/p>\n+<pre><code>record Point(int x, int y) { }<\/code><\/pre>\n+<p>desugars to<\/p>\n+<pre><code>final class Point extends java.lang.DataClass {\n+    final int x;\n+    final int y;\n+    \n+    public Point(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    \/\/ destructuring pattern for Point(int x, int y)\n+    \/\/ state-based equals, hashCode, and toString\n+    \/\/ public read accessors x() and y()\n+}<\/code><\/pre>\n+<p>Any interfaces implemented by the data class are lifted onto the desugared class in the obvious way, as are any type variables, static fields, static methods, and instance methods.<\/p>\n+<p><strong>Explicit implementations of implicit methods.<\/strong> Allowing explicit implementations of implicit members -- especially <code>equals()<\/code> and <code>hashCode()<\/code> -- is a tradeoff; they allow greater flexibility in using data classes, but increase the risk that the invariants will be violated. As a starting point, we propose that the user <em>not<\/em> be able to override <code>equals()<\/code> and <code>hashCode()<\/code>, that overrides of reader accessors are permitted but the returned value must be <code>equals()<\/code> to the appropriate field, and that <code>toString()<\/code> can be overridden as desired. If the data class provides an explicit implementation of any allowable implicit members, it is used in place of the implicit member.<\/p>\n+<p><strong>Explicit constructors.<\/strong> If the data class imposes no invariants, no constructor declaration is needed, and the class acquires a default constructor whose signature matches the state description. An overridden default constructor must delegate to the default principal constructor, as in:<\/p>\n+<pre><code>record Range(int lo, int hi) {\n+\n+    \/\/ Explicit default constructor\n+    @Override\n+    public Range(int lo, int hi) {\n+        \/\/ validation logic\n+        if (lo &gt; hi)\n+            throw new IllegalArgumentException(...);\n+            \n+        \/\/ delegate to default constructor\n+        default.this(lo, hi);\n+    }\n+}<\/code><\/pre>\n+<p>The <code>default.this()<\/code> call invokes the constructor that would otherwise have been auto-generated for this data class (including the default <code>super<\/code> constructor); this avoids the need to write out the tedious and error-inviting sequence of <code>this.x = x<\/code> assignments. (The rules about statements preceding calls to <code>super<\/code> or <code>this<\/code> constructors can be relaxed, and the <code>this<\/code> reference treated as <em>definitely unassigned<\/em> for statements preceding the <code>default.this()<\/code> call.)<\/p>\n+<p>Additional constructors may be explicitly declared -- but they must delegate to the default constructor (via the usual <code>this()<\/code> mechanism.)<\/p>\n+<p><strong>Fields.<\/strong> Given a data class<\/p>\n+<pre><code>record Foo(int x, int y) { ... }<\/code><\/pre>\n+<p>we will lift the state components <code>(int x, int y)<\/code> onto fields of <code>Foo<\/code> -- along with any annotations specified on the state components. (The Javadoc for data classes will allow class parameters to be documented with the <code>@param<\/code> tag, as method parameters are now.)<\/p>\n+<p>The most restrictive approach would be that fields are always final; we could also consider making them final by default, but allowing mutability to be supported by opting in via a mutability modifier (<code>non-final<\/code>, <code>unfinal<\/code>, <code>mutable<\/code> -- bikeshed to be painted later.) Similarly, the most restrictive approach would be for them to always have <code>package<\/code> accessibility (or <code>protected<\/code> for fields of abstract data class); a less restrictive approach would be to treat these as defaults, but allow them to optionally be declared <code>public<\/code>.<\/p>\n+<p>With respect to additional fields beyond those in the state description, the most restrictive approach would be to prohibit them; it seems inevitable that such additional state would flow into equality or other essential behavior, undermining the invariants of data classes. Relaxing this constraint would likely require tightening others, such as prohibiting an explicit implementation of <code>equals()<\/code> and <code>hashCode()<\/code>, and other constraints on constructors (such as requiring that the call to the default constructor appear last.)<\/p>\n+<p>To leave room for evolution, as a starting point we will take the most restrictive choices on all of these -- no additional fields, no override of <code>equals()<\/code> and <code>hashCode()<\/code>, and flow restrictions on constructors -- so that we have the flexibility to choose later which of these makes the most sense to relax.<\/p>\n+<p><strong>Extension.<\/strong> We've already noted that arbitrary extension is problematic, but it should be practical to maintain inheritance from abstract data classes to other data classes. A sensible balance regarding extension is:<\/p>\n+<ul>\n+<li>Non-abstract data classes are final;<\/li>\n+<li>Data classes can be abstract (in which case they acquire no <code>equals()<\/code>, <code>hashCode()<\/code>, or <code>toString()<\/code> methods, and all constructors must be <code>protected<\/code>);<\/li>\n+<li>Data classes can extend abstract data classes;<\/li>\n+<li>No restrictions on what interfaces a data class could implement.<\/li>\n+<\/ul>\n+<p>This allows us to declare families of algebraic data types, such as the following partial hierarchy describing an arithmetic expression:<\/p>\n+<pre><code>interface Node { }\n+\n+abstract record BinaryOpNode(Node left, Node right) \n+    implements Node;\n+\n+record PlusNode(Node left, Node right) \n+      extends BinaryOperatorNode(left, right);\n+\n+record MulNode(Node left, Node right) \n+      extends BinaryOperatorNode(left, right);\n+      \n+record IntNode(int constant) implements Node;<\/code><\/pre>\n+<p>When a data class extends an abstract data class, the state description of the superclass must be a prefix of the state description of the subclass:<\/p>\n+<pre><code>abstract record Base(int x);\n+record Sub(int x, int y) extends Base(x);<\/code><\/pre>\n+<p>The arguments to the <code>extends Base()<\/code> clause is a list of <em>names<\/em> of state components of <code>Sub<\/code>, not arbitrary expressions, must be a prefix of the state description of <code>Sub<\/code>, and must match the state description of <code>Base<\/code>; this suppresses the local declaration of inherited fields, and also plays into the generation of the default principal constructor (which arguments are passed up to which superclass constructor, vs. which are used to initialize local fields.) These rules are sufficient for implementing algebraic data type hierarchies like the <code>Node<\/code> example above.<\/p>\n+<p><strong>Accessors.<\/strong> Data classes are transparent; they readily give up their state through the destructuring pattern. To make this explicit, and to support the <em>uniform access principle<\/em> for state, data classes implicitly acquire public read accessors for all state components, whose name is the same as the state component. (We will separately explore how arbitrary classes, that do not meet the requirements for data classes, might also benefit from accessor generation.) If write accessors are desired, they can be provided explicitly -- data classes will not bring these automatically.<\/p>\n+<p><strong>Reflection.<\/strong> While our implementation is essentially a desugaring into a mostly ordinary class with fields and methods, we don't actually want to erase the data-ness completely; compilers need to be able to identify which classes are data classes, and what their state descriptions are, so they can enforce any restrictions on how they interact with other classes -- so this information must be present in the class file. This can be reflected on <code>Class<\/code> with methods such as <code>isDataClass()<\/code> and a method to return the ordered list of fields that are the classes state description.<\/p>\n+<h4 id=\"compatibility-and-migration-requirements\">Compatibility and migration requirements<\/h4>\n+<p>It is important that existing classes that meet the requirements for data classes -- of which there are many -- should be able to be compatibly migrated to data classes so that they can benefit from the semantic transparency and syntactic concision of data classes. If an existing class which meets the requirements wants to migrate to be a data class, it should be able to do so in a source- and binary-compatible manner by simply exposing its state through the class header and removing redundant field, constructor, and <code>Object<\/code> method declarations. The reverse migration is also possible; a class that is a data class can compatibly migrate to a regular class by providing equivalent explicit implementations of the implicit members. However, to be behaviorally compatible, it must continue to conform to the specification of <code>DataClass<\/code>.<\/p>\n+<p>Once a data class is published, changing its state description will have compatibility consequences for clients that are outside of the maintenance boundary. The binary- and source- compatibility impact of such changes can be partially mitigated by declaring new constructors and deconstruction patterns that follow the old state description (so that existing clients can construct and deconstruct them), but depending on existing usage, it may be hard to mitigate the behavioral compatibility issues, as the resulting class may well fall afoul of the invariants of plain data carriers from the perspective of legacy clients, such as the deconstructing and reconstructing a data class using an old state description. For data classes operating fully within a maintenance boundary, it may be practical to compatibly refactor both a data class and its clients when changing the state description.<\/p>\n+<h2 id=\"summary\">Summary<\/h2>\n+<p>The key question in designing a facility for &quot;plain data aggregates&quot; in Java is identifying which degrees of freedom we are willing to give up. If we try to model all the degrees of freedom of classes, we just move the complexity around; to gain some benefit, we must accept some constraints. We think that the sensible constraints to accept are disavowing the use of encapsulation for decoupling representation from API, and for mediating read access to state; in turn, this provides significant syntactic and semantic benefits for classes which can accept these constraints.<\/p>\n+<\/body>\n+<\/html>\n","filename":"site\/design-notes\/data-classes-historical-2.html","additions":320,"deletions":912,"binary":false,"changes":1232,"status":"modified"},{"patch":"@@ -1,387 +0,0 @@\n-# Extending switch for pattern matching\n-\n-#### Gavin Bierman and Brian Goetz, April 2017\n-\n-This document explores a possible direction for enhancements to\n-`switch` in the Java language, motivated by the desire to\n-support [_pattern matching_][pattern-match].  _This is an exploratory\n-document only and does not constitute a plan for any specific feature\n-in any specific version of the Java Language._\n-\n-#### Pattern matching documents\n-\n-- [Pattern Matching For Java](pattern-matching-for-java.html).  Overview of\n-  pattern matching concepts, and how they might be surfaced in Java.\n-- [Pattern Matching For Java -- Semantics](pattern-match-semantics.html).  More\n-  detailed notes on type checking, matching, and scoping of patterns and binding\n-  variables.\n-- [Extending Switch for Patterns](extending-switch-for-patterns.html) (this\n-  document).  An early exploration of the issues surrounding extending pattern\n-  matching to the `switch` statement.\n-- [Type Patterns in Switch](type-patterns-in-switch.html).  A more up-to-date\n-  treatment of extending pattern matching to `switch` statements, including\n-  treatment of nullity and totality.\n-- [Pattern Matching in the Java Object model](pattern-match-object-model.html).\n-  Explores how patterns fit into the Java object model, how they fill a hole we\n-  may not have realized existed, and how they might affect API design going\n-  forward.\n-\n-## Background\n-\n-Java inherited its `switch` construct nearly wholesale from C.  It was\n-designed as a limited mechanism for limited situations; one can only\n-switch on a small set of types, and one can only have case labels that\n-exactly match literal constants.  While its range was extended several\n-times (switching on enums in Java 5, and strings in Java 7), the basic\n-facility is largely unchanged from C.\n-\n-As we consider extending `switch` to support a wider variety of types,\n-and `case` labels to support patterns, it raises some new questions,\n-such as:\n-\n- - What is the scope of binding variables introduced in pattern `case`\n-   labels?\n- - Does fallthrough need to be restricted to make sense with pattern\n-   `case` labels?\n- - Can `switch` be smoothly extended to an expression, and if so, what\n-   changes need to be made?\n- - Do we need additional control flow constructs, like `break` or\n-   `continue`?\n- - Do we need \"guard\" conditions on patterns?\n- - Under what conditions might a `switch` expression without a\n-   `default` clause be considered exhaustive?\n-\n-It should be noted that there is a duality between `switch` statements\n-and a chain of `if-else` statements.  We can use this duality as a\n-lens through which to evaluate the regularity of extensions to\n-`switch`.\n-\n-## Scoping\n-\n-A `switch` statement today is one big scope; the \"arms\" of a `switch`\n-do not constitute individual scopes, unless scoping constructs (such\n-as introducing a new block) are explicitly used by the author.\n-\n-The situation of having variable declarations arise from expressions\n-is new, so it is a reasonable question to ask \"What is the scope of of\n-a binding variable of a pattern match?\"  There's also an obvious\n-answer -- the scope of the statement that encloses the pattern match;\n-we can just hoist variables into the scope which includes the\n-statement which includes the match expression:\n-\n-    if (x matches String s) { ... }\n-\n-becomes\n-\n-    String s;\n-    if (x matches String s) { ... }\n-\n-However, this seems like one of those \"obvious but wrong\" answers;\n-there are going to be places in that scope where the variable is still\n-not usable (because it is not definitely assigned), and it is likely\n-that users will want to reuse the same variable name for multiple\n-bindings in the same scope:\n-\n-    if (x matches Integer n) { ... }\n-    else if (x matches Float n) { ... }\n-    else if (x matches Double n) { ... }\n-\n-(or the equivalent in a `switch` statement.)  Having to come up with a\n-unique name for each binding variable, just because the variable has\n-been hoisted into a broader scope, will be unpopular (and as it turns\n-out, unnecessary.)\n-\n-#### Natural scoping for binding variables\n-\n-The following example illustrates the that \"natural\" scope of a\n-binding variables is complex and not necessarily contiguous:\n-\n-    if (x matches Foo(var y)) { .. y .. }                 \/\/ OK\n-    if (x matches Foo(var y)) { ... } else { .. y .. }    \/\/ not OK\n-    if (x matches Foo(var y) && .. y ..) { ... }          \/\/ OK\n-    if (x matches Foo(var y) || .. y ..) { ... }          \/\/ not OK\n-    if (!(x matches Foo(var y)) && .. y .. ) { ... }      \/\/ not OK\n-    if (!(x matches Foo(var y)) || .. y .. ) { ... }      \/\/ OK\n-    if (!(x matches Foo(var y))) { ... } else { .. y .. } \/\/ OK\n-    if (!(x matches Foo(var y))) { y } else { ... }       \/\/ not OK\n-\n-The above cases are derived from a standard application of _definite\n-assignment_ rules; we'd like for a binding variable to be in scope\n-wherever it is definitely assigned, to not be in scope wherever it is\n-not definitely assigned, and for a binding variable to always be\n-definitely unassigned at the point of its declaration.\n-\n-We can construct a set of rules for the natural scope of these\n-variables.  To start with, we say that each expression _e_ gives rise\n-to two sets of binding variables, `e.T` and `e.F`, along with rules\n-for when one or the other of these sets are included in the scope of a\n-statement or expression, over all the expression forms.  If not\n-otherwise defined, `e.T` = `e.F` = `{}` -- most expressions (including\n-all current expression forms) make available no new bindings.  We also\n-define a set of binding variables to additionally be in scope for\n-certain expressions or statements via the \"include in\" clauses below.\n-\n-If _e_ is `x matches P`:\n-\n-    e.T = { binding variables from P }\n-    e.F = { }\n-\n-If e is `x && y`:\n-\n-    e.T = union(x.T, y.T)\n-    e.F = intersection(x.F, y.F)\n-    include x.T in y\n-\n-If e is `x || y`:\n-\n-    e.T = intersection(x.T, y.T)\n-    e.F = union(x.F, y.F)\n-    include x.F in y\n-\n-If e is `x ? y : z`:\n-\n-    e.T = union(intersect(y.T, z.T), intersect(x.T, z.T), intersect(x.F, y.T))\n-    e.F = union(intersect(y.F, z.F), intersect(x.T, z.F), intersect(x.F, y.F))\n-    include x.T in y\n-    include x.F in z\n-\n-If e is `(x)`:\n-\n-    e.T = x.T\n-    e.F = x.F\n-\n-If e is `!x`:\n-\n-    e.T = x.F\n-    e.F = x.T\n-\n-We can do the same for statement forms:\n-\n-For `if (x) y else z`:\n-\n-    include x.T in y\n-    include x.F in z\n-\n-For `if (x) return\/throw; z`\n-\n-    include x.T in return\/throw\n-    include x.F in z\n-\n-For `while (x) y`:\n-\n-    include x.T in y\n-\n-For `for (a; b; c) d`:\n-\n-    include b.T in c\n-    include b.T in d\n-\n-For `switch (x) { ... case P: y; case Q: ... }`\n-\n-    include binding variables from P in y\n-\n-Further, union and intersection should be limited to avoid conflicts.\n-The `union` function should be a disjoint union: it is an error if any\n-binding varible is present in both sets -- otherwise, expressions like\n-`x matches Foo(var x) && y matches Bar(var x)` would include two\n-different variables called `x` in the same scope.  Similarly, for\n-`intersect`, it is an error if the same binding variable is present in\n-both sets but with different types.\n-\n-## Fallthrough and OR patterns\n-\n-While one could make an argument that fallthrough in `switch` was the\n-wrong default, the problem fallthrough aims to solve -- treating\n-multiple items similarly without duplicating the code -- were real,\n-and are still relevant when our `case` labels get richer.\n-\n-Patterns that generate binding variables require some refinements to the\n-above scoping rules.  For example:\n-\n-    case Foo(int x):\n-    case Bar(float x):\n-        s;\n-\n-would be an error, just as `x matches Foo(int x) || x.matches\n-Bar(float x)` would be.\n-\n-However, there's no reason why we can't make this work, with `x` in\n-scope in `s`:\n-\n-    case Foo(int x):\n-    case Bar(int x):\n-        s;\n-\n-This is analogous to the disjunction `y matches Foo(int x) || y\n-matches Bar(int x)`.\n-\n-Similarly, in:\n-\n-    case Foo(int x, int y):\n-    case Bar(int x):\n-        s;\n-\n-the binding variable `y` would not be available in `s`, because we\n-can't rely on it having a value on all control paths, but `x` can\n-still be available in `s`.  These restrictions are a straightforward\n-refinement of the scoping rules presented earlier.\n-\n-A more limited form of fallthrough is OR patterns:\n-\n-    case P1 || P2:\n-        s;\n-\n-Which is equivalent to:\n-\n-    case P1:\n-    case P2:\n-        s;\n-\n-We might consider prohibiting fallthrough but allowing OR patterns (in\n-which case we'd probably require that all OR patterns declare exactly\n-the same set of binding variables.)\n-\n-#### Guards, compound patterns, and continue\n-\n-Nested patterns, such as:\n-\n-    case Point(0, 0):\n-\n-express _compound conditions_; we're testing that the target is a\n-`Point`, and that both its `x` and `y` components match the constant\n-pattern `0`.  While nested patterns are powerful, they have their\n-limits; we can't easily test for whether a point is, say, on the\n-diagonal.  We could express this with a _guard_:\n-\n-    case Point(var x, var y) && x == y:\n-\n-Alternately, we could express compound conditions by pushing the\n-subordinate test into the body, and permitting the `continue` control\n-flow construct in switches, which would indicate we want to break out\n-of the existing `case` arm, and resume matching at the next `case`\n-label:\n-\n-    case Point(var x, var y):\n-        if (x != y)\n-            continue;\n-\n-(Note that nested patterns desugar to guards, and guards desugar to\n-`continue`, so we are likely to have to implement all these mechanisms\n-internally anyway.)\n-\n-#### Dead code\n-\n-In some cases, the compiler may be able to prove that a case is\n-unreachable, such as:\n-\n-    switch (x) {\n-        case Comparable c: ... break;\n-        case Integer i: \/\/ can't reach this\n-    }\n-\n-In these cases, the compiler will issue an error (just as with\n-unreachable `catch` clauses.)\n-\n-## Switch expressions\n-\n-The other major direction in which we would like to extend `switch` is\n-to given it an expression form:\n-\n-    float overtimeFactor = switch (day) {\n-        case SATURDAY -> 1.5;\n-        case SUNDAY -> 2;\n-        default -> 1;\n-    }\n-\n-While statement switches need not be exhaustive (just as `if`\n-statements need not have an `else`), expression switches must be (as\n-the expression must evaluate to something.)  Exhaustiveness can always\n-be provided via a `default` arm, but sometimes we may want to do\n-better.  The compiler can use class hierarchy information, as well as\n-sealing information, to prove exhaustiveness.  (Since the type\n-hiearchy can change between compile and run time, the compiler will\n-still want to insert a catch-all throwing `default` even if it deems\n-the analysis exhaustive.)\n-\n-Unrestricted fallthrough makes less sense in an expression `switch`,\n-but OR patterns still do:\n-\n-    int days = switch (month) {\n-        case JANUARY\n-             || MARCH\n-             || MAY\n-             || JULY\n-             || AUGUST\n-             || OCTOBER\n-             || DECEMBER -> 31;\n-         case FEBRUARY -> 28;\n-         case APRIL\n-             || JUNE\n-             || SEPTEMBER\n-             || NOVEMBER -> 30;\n-    };\n-\n-A switch expression is a _poly expression_, and pushes its target type\n-down into the switch arms (just as we do with conditional\n-expressions.)\n-\n-#### Mixing statements and expressions\n-\n-While the common case with a switch expression is that the RHS of a\n-case label is a single expression, occasionally the result may not be\n-constructible in this way (or construction of the result might require\n-side-effects, such as debugging output).  Other languages usually\n-handle this with _block expressions_; we can construct a limited form\n-of block expression for use in expression `switch` by coopting the\n-`break` keyword, as in these examples:\n-\n-    case String s -> {\n-        System.out.println(\"It's a string!\");\n-        break s.toUpperCase();\n-    }\n-\n-    case Flooble f -> {\n-        FloobleDescriptor fd = new FloobleDescriptor();\n-        fd.setFlooble(f);\n-        break fd;\n-    }\n-\n-There is some potential ambiguity between label-break and result-break\n-here, but working these out is practical.\n-\n-#### Throw expressions\n-\n-It is not uncommon that one or more arms of a switch expression will\n-result in a transfer-of-control operation, such as:\n-\n-    int size = switch (x) {\n-        case Collection c -> c.size();\n-        case String s -> s.length();\n-        default -> throw new IllegalArgumentException(...);\n-    }\n-\n-Even though `throw` is a statement, not an expression, the intent here\n-is clear, so we want to allow `throw` (and possibly other\n-transfer-of-control operations) in this context.\n-\n-#### Targetless switch\n-\n-In the theme of elevating `switch` as the generalization of the\n-ternary conditional operator, we may also wish to allow a simplified\n-form of `switch` where there is no switch target, and all case labels\n-are boolean expressions:\n-\n-    String fizzbuzz(int n) {\n-        boolean byThree = n % 3 == 0;\n-        boolean byFive = n % 5 == 0;\n-        return switch {\n-            case byThree && byFive -> \"fizzbuzz\";\n-            case byThree -> \"fizz\";\n-            case byFive -> \"buzz\";\n-            default -> Integer.toString(n);\n-        }\n-    }\n-\n-\n-\n-[pattern-match]: pattern-matching-for-java.html\n","filename":"site\/design-notes\/extending-switch-for-patterns.md","additions":0,"deletions":387,"binary":false,"changes":387,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-# Extending switch for pattern matching\n+# Extending `switch` for Pattern Matching\n@@ -3,1 +3,2 @@\n-#### Gavin Bierman and Brian Goetz, April 2017\n+#### Gavin Bierman and Brian Goetz {.author}\n+#### April 2017 {.date}\n@@ -11,1 +12,1 @@\n-#### Pattern matching documents\n+### Pattern matching documents\n@@ -13,1 +14,1 @@\n-- [Pattern Matching For Java](pattern-matching-for-java.html).  Overview of\n+- [Pattern Matching For Java](pattern-matching-for-java) --- Overview of\n@@ -15,1 +16,2 @@\n-- [Pattern Matching For Java -- Semantics](pattern-match-semantics.html).  More\n+\n+- [Pattern Matching For Java -- Semantics](pattern-match-semantics) --- More\n@@ -18,2 +20,3 @@\n-- [Extending Switch for Patterns](extending-switch-for-patterns.html) (this\n-  document).  An early exploration of the issues surrounding extending pattern\n+\n+- [Extending Switch for Patterns](extending-switch-for-patterns) (this\n+  document) ---  An early exploration of the issues surrounding extending pattern\n@@ -21,1 +24,2 @@\n-- [Type Patterns in Switch](type-patterns-in-switch.html).  A more up-to-date\n+\n+- [Type Patterns in Switch](type-patterns-in-switch) --- A more up-to-date\n@@ -24,2 +28,3 @@\n-- [Pattern Matching in the Java Object model](pattern-match-object-model.html).\n-  Explores how patterns fit into the Java object model, how they fill a hole we\n+\n+- [Pattern Matching in the Java Object model](pattern-match-object-model)\n+  --- Explores how patterns fit into the Java object model, how they fill a hole we\n@@ -44,0 +49,1 @@\n+\n@@ -46,0 +52,1 @@\n+\n@@ -48,0 +55,1 @@\n+\n@@ -50,0 +58,1 @@\n+\n@@ -51,0 +60,1 @@\n+\n@@ -94,1 +104,1 @@\n-#### Natural scoping for binding variables\n+### Natural scoping for binding variables\n@@ -124,1 +134,1 @@\n-If _e_ is `x matches P`:\n+- If _e_ is `x matches P`:\n@@ -126,2 +136,2 @@\n-    e.T = { binding variables from P }\n-    e.F = { }\n+      e.T = { binding variables from P }\n+      e.F = { }\n@@ -129,1 +139,1 @@\n-If e is `x && y`:\n+- If e is `x && y`:\n@@ -131,3 +141,3 @@\n-    e.T = union(x.T, y.T)\n-    e.F = intersection(x.F, y.F)\n-    include x.T in y\n+      e.T = union(x.T, y.T)\n+      e.F = intersection(x.F, y.F)\n+      include x.T in y\n@@ -135,1 +145,1 @@\n-If e is `x || y`:\n+- If e is `x || y`:\n@@ -137,3 +147,3 @@\n-    e.T = intersection(x.T, y.T)\n-    e.F = union(x.F, y.F)\n-    include x.F in y\n+      e.T = intersection(x.T, y.T)\n+      e.F = union(x.F, y.F)\n+      include x.F in y\n@@ -141,1 +151,1 @@\n-If e is `x ? y : z`:\n+- If e is `x ? y : z`:\n@@ -143,4 +153,8 @@\n-    e.T = union(intersect(y.T, z.T), intersect(x.T, z.T), intersect(x.F, y.T))\n-    e.F = union(intersect(y.F, z.F), intersect(x.T, z.F), intersect(x.F, y.F))\n-    include x.T in y\n-    include x.F in z\n+      e.T = union(intersect(y.T, z.T),\n+                  intersect(x.T, z.T),\n+                  intersect(x.F, y.T))\n+      e.F = union(intersect(y.F, z.F),\n+                  intersect(x.T, z.F),\n+                  intersect(x.F, y.F))\n+      include x.T in y\n+      include x.F in z\n@@ -148,1 +162,1 @@\n-If e is `(x)`:\n+- If e is `(x)`:\n@@ -150,2 +164,2 @@\n-    e.T = x.T\n-    e.F = x.F\n+      e.T = x.T\n+      e.F = x.F\n@@ -153,1 +167,1 @@\n-If e is `!x`:\n+- If e is `!x`:\n@@ -155,2 +169,2 @@\n-    e.T = x.F\n-    e.F = x.T\n+      e.T = x.F\n+      e.F = x.T\n@@ -160,1 +174,1 @@\n-For `if (x) y else z`:\n+- For `if (x) y else z`:\n@@ -162,2 +176,2 @@\n-    include x.T in y\n-    include x.F in z\n+      include x.T in y\n+      include x.F in z\n@@ -165,1 +179,1 @@\n-For `if (x) return\/throw; z`\n+- For `if (x) return\/throw; z`\n@@ -167,2 +181,2 @@\n-    include x.T in return\/throw\n-    include x.F in z\n+      include x.T in return\/throw\n+      include x.F in z\n@@ -170,1 +184,1 @@\n-For `while (x) y`:\n+- For `while (x) y`:\n@@ -172,1 +186,1 @@\n-    include x.T in y\n+      include x.T in y\n@@ -174,1 +188,1 @@\n-For `for (a; b; c) d`:\n+- For `for (a; b; c) d`:\n@@ -176,2 +190,2 @@\n-    include b.T in c\n-    include b.T in d\n+      include b.T in c\n+      include b.T in d\n@@ -179,1 +193,1 @@\n-For `switch (x) { ... case P: y; case Q: ... }`\n+- For `switch (x) { ... case P: y; case Q: ... }`\n@@ -181,1 +195,1 @@\n-    include binding variables from P in y\n+      include binding variables from P in y\n@@ -244,1 +258,1 @@\n-#### Guards, compound patterns, and continue\n+### Guards, compound patterns, and continue\n@@ -272,1 +286,1 @@\n-#### Dead code\n+### Dead code\n@@ -328,1 +342,1 @@\n-#### Mixing statements and expressions\n+### Mixing statements and expressions\n@@ -352,1 +366,1 @@\n-#### Throw expressions\n+### Throw expressions\n@@ -367,1 +381,1 @@\n-#### Targetless switch\n+### Targetless switch\n@@ -387,1 +401,1 @@\n-[pattern-match]: pattern-matching-for-java.html\n+[pattern-match]: pattern-matching-for-java\n","filename":"site\/design-notes\/patterns\/extending-switch-for-patterns.md","additions":66,"deletions":52,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-#### Brian Goetz and Gavin Bierman\r\n-#### December 2020\r\n+#### Brian Goetz and Gavin Bierman {.author}\r\n+#### December 2020 {.date}\r\n@@ -11,1 +11,1 @@\n-#### Pattern matching documents\r\n+### Pattern matching documents\r\n@@ -13,1 +13,1 @@\n-- [Pattern Matching For Java](pattern-matching-for-java.html).  Overview of\r\n+- [Pattern Matching For Java](pattern-matching-for-java) --- Overview of\r\n@@ -15,1 +15,2 @@\n-- [Pattern Matching For Java -- Semantics](pattern-match-semantics.html).  More\r\n+\r\n+- [Pattern Matching For Java -- Semantics](pattern-match-semantics) --- More\r\n@@ -18,1 +19,2 @@\n-- [Extending Switch for Patterns](extending-switch-for-patterns.html).  An early\r\n+\r\n+- [Extending Switch for Patterns](extending-switch-for-patterns) --- An early\r\n@@ -21,1 +23,2 @@\n-- [Type Patterns in Switch](type-patterns-in-switch.html).  A more up-to-date\r\n+\r\n+- [Type Patterns in Switch](type-patterns-in-switch) --- A more up-to-date\r\n@@ -24,2 +27,3 @@\n-- [Pattern Matching in the Java Object model](pattern-match-object-model.html)\r\n-  (this document).  Explores how patterns fit into the Java object model, how\r\n+\r\n+- [Pattern Matching in the Java Object model](pattern-match-object-model)\r\n+  (this document) --- Explores how patterns fit into the Java object model, how\r\n@@ -38,1 +42,1 @@\n-#### Recap -- what is pattern matching?\r\n+### Recap -- what is pattern matching?\r\n@@ -54,1 +58,1 @@\n-#### Aggregation and destructuring\r\n+### Aggregation and destructuring\r\n@@ -86,1 +90,1 @@\n-> Destructuring is the dual of aggregation.\r\n+> _Destructuring is the dual of aggregation._\r\n@@ -111,1 +115,1 @@\n-> Enabling API designers to provide complementary destructuring operations for\r\n+> _Enabling API designers to provide complementary destructuring operations for\r\n@@ -113,1 +117,1 @@\n-the API to mediate access to encapsulated state.\r\n+the API to mediate access to encapsulated state._\r\n@@ -121,1 +125,1 @@\n-#### Object creation in Java\r\n+### Object creation in Java\r\n@@ -179,1 +183,1 @@\n-#### Composition\r\n+### Composition\r\n@@ -218,1 +222,1 @@\n-> First-class destructuring leads to composable APIs.\r\n+> _First-class destructuring leads to composable APIs._\r\n@@ -248,1 +252,1 @@\n-#### Isn't this just multiple return?\r\n+### Isn't this just multiple return?\r\n@@ -269,1 +273,1 @@\n-#### Patterns as API points\r\n+### Patterns as API points\r\n@@ -299,1 +303,1 @@\n-> First-class destructuring leads to APIs that are harder to misuse.\r\n+> _First-class destructuring leads to APIs that are harder to misuse._\r\n@@ -301,1 +305,1 @@\n-#### Data-driven polymorphism\r\n+### Data-driven polymorphism\r\n@@ -346,1 +350,1 @@\n-> Patterns are executable class members.\r\n+> _Patterns are executable class members._\r\n@@ -348,1 +352,1 @@\n-#### Anatomy of a pattern\r\n+### Anatomy of a pattern\r\n@@ -363,1 +367,1 @@\n-#### Deconstruction patterns\r\n+### Deconstruction patterns\r\n@@ -416,1 +420,1 @@\n-#### Method patterns\r\n+### Method patterns\r\n@@ -424,1 +428,1 @@\n-**Does it make sense to have accessibility modifiers on pattern declarations?**\r\n+- **Does it make sense to have accessibility modifiers on pattern declarations?**\r\n@@ -432,1 +436,1 @@\n-**Does pattern overloading make sense?**  Yes!  Just as we may want to provide\r\n+- **Does pattern overloading make sense?**  Yes!  Just as we may want to provide\r\n@@ -437,1 +441,1 @@\n-**Do static patterns make sense?**  Yes!  Just as some APIs expose static\r\n+- **Do static patterns make sense?**  Yes!  Just as some APIs expose static\r\n@@ -445,1 +449,1 @@\n-Static methods have another advantage, which is that they can be declared\r\n+  Static methods have another advantage, which is that they can be declared\r\n@@ -455,1 +459,1 @@\n-**Do generic patterns make sense?**  Yes!  Static factories are often generic\r\n+- **Do generic patterns make sense?**  Yes!  Static factories are often generic\r\n@@ -459,1 +463,1 @@\n-**Do instance patterns make sense?**  Yes!  Just as instance methods allow a\r\n+- **Do instance patterns make sense?**  Yes!  Just as instance methods allow a\r\n@@ -466,1 +470,1 @@\n-An API idiom that might make use of instance patterns are the dual of\r\n+  An API idiom that might make use of instance patterns are the dual of\r\n@@ -475,1 +479,1 @@\n-**Do abstract patterns make sense?**  Yes!  An interface such as `Map` may\r\n+- **Do abstract patterns make sense?**  Yes!  An interface such as `Map` may\r\n@@ -480,1 +484,1 @@\n-**Does overriding patterns make sense?**  Yes!  A skeletal implementation\r\n+- **Does overriding patterns make sense?**  Yes!  A skeletal implementation\r\n@@ -484,1 +488,1 @@\n-**Do varargs patterns make sense?**  Yes!  Consider a method like\r\n+- **Do varargs patterns make sense?**  Yes!  Consider a method like\r\n@@ -488,1 +492,1 @@\n-    String s = String.format(\"%s is %d years old\", name, age);\r\n+      String s = String.format(\"%s is %d years old\", name, age);\r\n@@ -490,1 +494,1 @@\n-To reverse the encoding from data to string, we might want to expose a\r\n+  To reverse the encoding from data to string, we might want to expose a\r\n@@ -494,4 +498,4 @@\n-    if (s instanceof String.format(\"%s is %d years old\",\r\n-                                   String name, Integer.valueOf(int age))) {\r\n-        ...\r\n-    }\r\n+      if (s instanceof String.format(\"%s is %d years old\",\r\n+                                     String name, Integer.valueOf(int age))) {\r\n+          ...\r\n+      }\r\n@@ -499,1 +503,1 @@\n-**Does it make sense for patterns to delegate to other patterns?**  Yes!  Just\r\n+- **Does it make sense for patterns to delegate to other patterns?**  Yes!  Just\r\n@@ -508,1 +512,1 @@\n-#### Additional degrees of freedom\r\n+### Additional degrees of freedom\r\n@@ -514,1 +518,1 @@\n-**Targets and applicability.**  Patterns have a _target_ operand, which is the\r\n+- **Targets and applicability.**  Patterns have a _target_ operand, which is the\r\n@@ -524,1 +528,1 @@\n-**Totality vs partiality.**  Some patterns are _total_ on their target type,\r\n+- **Totality vs partiality.**  Some patterns are _total_ on their target type,\r\n@@ -538,1 +542,1 @@\n-**Input and output arguments.**  The patterns we've seen so far have a target\r\n+- **Input and output arguments.**  The patterns we've seen so far have a target\r\n@@ -545,1 +549,1 @@\n-**Exhaustiveness.**  In some cases, groups of patterns (such as `Optional::of`\r\n+- **Exhaustiveness.**  In some cases, groups of patterns (such as `Optional::of`\r\n@@ -550,8 +554,8 @@\n-```\r\n-Optional<Foo> o = ...;\r\n-switch (o) {\r\n-    case Optional.empty(): ...\r\n-    case Optional.of(var foo): ...\r\n-    \/\/ Ideally, no default would be needed\r\n-}\r\n-```\r\n+  ```\r\n+  Optional<Foo> o = ...;\r\n+  switch (o) {\r\n+      case Optional.empty(): ...\r\n+      case Optional.of(var foo): ...\r\n+      \/\/ Ideally, no default would be needed\r\n+  }\r\n+  ```\r\n@@ -612,1 +616,1 @@\n-#### A possible approach for parsing APIs\r\n+### A possible approach for parsing APIs\r\n@@ -675,1 +679,1 @@\n-#### Down the road: structured patterns?\r\n+### Down the road: structured patterns?\r\n@@ -717,1 +721,1 @@\n-#### Flatter APIs\r\n+### Flatter APIs\r\n@@ -729,2 +733,2 @@\n-[patternmatch]: pattern-matching-for-java.html\r\n-[patternsem]: pattern-match-semantics.html\r\n+[patternmatch]: pattern-matching-for-java\r\n+[patternsem]: pattern-match-semantics\r\n@@ -732,1 +736,1 @@\n-[records]: ..\/records-and-sealed-classes.html\r\n+[records]: ..\/records-and-sealed-classes\r\n","filename":"site\/design-notes\/patterns\/pattern-match-object-model.md","additions":65,"deletions":61,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -1,2 +1,3 @@\n-# Pattern Matching for Java -- Semantics\n-#### Gavin Bierman and Brian Goetz (Updated August 2020)\n+# Pattern Matching for Java --- Semantics\n+#### Gavin Bierman and Brian Goetz {.author}\n+#### August 2020 {.date}\n@@ -12,1 +13,1 @@\n-#### Pattern matching documents\n+### Pattern matching documents\n@@ -14,1 +15,1 @@\n- - [Pattern Matching For Java](pattern-matching-for-java.html).  Overview of\n+ - [Pattern Matching For Java](pattern-matching-for-java) --- Overview of\n@@ -16,2 +17,3 @@\n- - [Pattern Matching For Java -- Semantics](pattern-match-semantics.html)  (this\n-   document).  More detailed notes on type checking, matching, and scoping of\n+\n+ - [Pattern Matching For Java -- Semantics](pattern-match-semantics)  (this\n+   document) --- More detailed notes on type checking, matching, and scoping of\n@@ -19,1 +21,2 @@\n- - [Extending Switch for Patterns](extending-switch-for-patterns.html).  An early\n+\n+ - [Extending Switch for Patterns](extending-switch-for-patterns) --- An early\n@@ -22,1 +25,2 @@\n- - [Type Patterns in Switch](type-patterns-in-switch.html).  A more up-to-date\n+\n+ - [Type Patterns in Switch](type-patterns-in-switch) --- A more up-to-date\n@@ -25,2 +29,3 @@\n- - [Pattern Matching in the Java Object model](pattern-match-object-model.html).\n-   Explores how patterns fit into the Java object model, how they fill a hole we\n+\n+ - [Pattern Matching in the Java Object model](pattern-match-object-model)\n+   --- Explores how patterns fit into the Java object model, how they fill a hole we\n@@ -39,0 +44,1 @@\n+\n@@ -40,0 +46,1 @@\n+\n@@ -41,0 +48,1 @@\n+\n@@ -44,0 +52,1 @@\n+\n@@ -46,0 +55,1 @@\n+\n@@ -53,1 +63,1 @@\n-#### Type checking\n+### Type checking\n@@ -74,0 +84,1 @@\n+\n@@ -75,0 +86,1 @@\n+\n@@ -78,0 +90,1 @@\n+\n@@ -80,0 +93,1 @@\n+\n@@ -82,0 +96,1 @@\n+\n@@ -83,0 +98,1 @@\n+\n@@ -85,0 +101,1 @@\n+\n@@ -87,0 +104,1 @@\n+\n@@ -135,1 +153,1 @@\n-#### Matching\n+### Matching\n@@ -146,0 +164,1 @@\n+\n@@ -148,0 +167,1 @@\n+\n@@ -149,0 +169,1 @@\n+\n@@ -154,0 +175,1 @@\n+\n@@ -155,0 +177,1 @@\n+\n@@ -168,1 +191,1 @@\n-#### Binding variables\n+### Binding variables\n@@ -175,0 +198,1 @@\n+\n@@ -177,0 +201,1 @@\n+\n@@ -318,1 +343,1 @@\n-#### Scoping and statements\n+### Scoping and statements\n@@ -434,1 +459,1 @@\n-#### Shadowing\n+### Shadowing\n@@ -557,1 +582,1 @@\n-#### Nullity -- some false starts\n+### Nullity --- some false starts\n@@ -617,0 +642,1 @@\n+\n@@ -619,0 +645,1 @@\n+\n@@ -640,0 +667,1 @@\n+\n@@ -642,0 +670,1 @@\n+\n@@ -645,0 +674,1 @@\n+\n@@ -647,0 +677,1 @@\n+\n@@ -648,0 +679,1 @@\n+\n@@ -649,0 +681,1 @@\n+\n@@ -650,0 +683,1 @@\n+\n","filename":"site\/design-notes\/patterns\/pattern-match-semantics.md","additions":50,"deletions":16,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# Pattern Matching for Java -- Runtime and Translation\n+# Pattern Matching for Java --- Runtime and Translation\n@@ -3,1 +3,2 @@\n-#### Brian Goetz and John Rose, June 2017\n+#### Brian Goetz and John Rose {.author}\n+#### June 2017 {.date}\n@@ -25,1 +26,1 @@\n-#### What is a pattern?\n+### What is a pattern?\n@@ -46,1 +47,1 @@\n-#### Encoding patterns as methods\n+### Encoding patterns as methods\n@@ -78,1 +79,1 @@\n-#### Further performance considerations\n+### Further performance considerations\n@@ -145,1 +146,1 @@\n-#### Intermediate carriers\n+### Intermediate carriers\n@@ -181,1 +182,1 @@\n-#### Combinators\n+### Combinators\n@@ -193,0 +194,1 @@\n+\n@@ -196,0 +198,1 @@\n+\n@@ -198,0 +201,1 @@\n+\n@@ -200,0 +204,1 @@\n+\n@@ -244,1 +249,1 @@\n-#### Method naming\n+### Method naming\n@@ -296,1 +301,1 @@\n-#### Additional optimizations\n+### Additional optimizations\n@@ -314,1 +319,1 @@\n-#### Data classes\n+### Data classes\n@@ -321,1 +326,1 @@\n-#### Reflection\n+### Reflection\n@@ -532,0 +537,1 @@\n+\n@@ -544,1 +550,1 @@\n-[pattern-match]: pattern-matching-for-java.html\n+[pattern-match]: pattern-matching-for-java\n","filename":"site\/design-notes\/patterns\/pattern-match-translation.md","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n-#### Gavin Bierman and Brian Goetz, September 2018\n+#### Gavin Bierman and Brian Goetz {.author}\n+#### September 2018 {.date}\n@@ -13,1 +14,1 @@\n-#### Pattern matching documents\n+### Pattern matching documents\n@@ -15,3 +16,4 @@\n- - [Pattern Matching For Java](pattern-matching-for-java.html) (this document).\n-   Overview of pattern matching concepts, and how they might be surfaced in Java.\n- - [Pattern Matching For Java -- Semantics](pattern-match-semantics.html).  More\n+ - [Pattern Matching For Java](pattern-matching-for-java) (this document)\n+   --- Overview of pattern matching concepts, and how they might be surfaced in Java.\n+\n+ - [Pattern Matching For Java -- Semantics](pattern-match-semantics) --- More\n@@ -20,1 +22,2 @@\n- - [Extending Switch for Patterns](extending-switch-for-patterns.html).  An early\n+\n+ - [Extending Switch for Patterns](extending-switch-for-patterns) --- An early\n@@ -23,1 +26,2 @@\n- - [Type Patterns in Switch](type-patterns-in-switch.html).  A more up-to-date\n+\n+ - [Type Patterns in Switch](type-patterns-in-switch) --- A more up-to-date\n@@ -26,2 +30,3 @@\n- - [Pattern Matching in the Java Object model](pattern-match-object-model.html).\n-   Explores how patterns fit into the Java object model, how they fill a hole we\n+\n+ - [Pattern Matching in the Java Object model](pattern-match-object-model)\n+   --- Explores how patterns fit into the Java object model, how they fill a hole we\n@@ -111,1 +116,1 @@\n-#### Patterns\n+### Patterns\n@@ -197,1 +202,1 @@\n-#### Patterns in multi-way conditionals\n+### Patterns in multi-way conditionals\n@@ -239,1 +244,1 @@\n-#### Constant patterns\n+### Constant patterns\n@@ -327,1 +332,1 @@\n-#### The Visitor pattern\n+### The Visitor pattern\n@@ -442,1 +447,1 @@\n-#### Sidebar: Data-driven polymorphism with patterns\n+### Sidebar: Data-driven polymorphism with patterns\n@@ -504,1 +509,1 @@\n-#### Exhaustiveness\n+### Exhaustiveness\n@@ -536,1 +541,1 @@\n-#### Patterns and type inference\n+### Patterns and type inference\n@@ -569,1 +574,1 @@\n-#### Nesting constant patterns\n+### Nesting constant patterns\n@@ -617,1 +622,1 @@\n-#### Any patterns\n+### Any patterns\n@@ -649,1 +654,1 @@\n-#### Static patterns\n+### Static patterns\n@@ -754,1 +759,1 @@\n-#### Summary of patterns and control flow constructs\n+### Summary of patterns and control flow constructs\n","filename":"site\/design-notes\/patterns\/pattern-matching-for-java.md","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1,2 +1,3 @@\n-# Type patterns in switch\n-#### Brian Goetz, Sept 2020\n+# Type Patterns in `switch`\n+#### Brian Goetz {.author}\n+#### September 2020 {.date}\n@@ -10,1 +11,1 @@\n-#### Pattern matching documents\n+### Pattern matching documents\n@@ -12,1 +13,1 @@\n-- [Pattern Matching For Java](pattern-matching-for-java.html).  Overview of\n+- [Pattern Matching For Java](pattern-matching-for-java) --- Overview of\n@@ -14,1 +15,2 @@\n-- [Pattern Matching For Java -- Semantics](pattern-match-semantics.html).  More\n+\n+- [Pattern Matching For Java -- Semantics](pattern-match-semantics) --- More\n@@ -17,1 +19,2 @@\n-- [Extending Switch for Patterns](extending-switch-for-patterns.html).  An early\n+\n+- [Extending Switch for Patterns](extending-switch-for-patterns) --- An early\n@@ -20,1 +23,2 @@\n-- [Type Patterns in Switch](type-patterns-in-switch.html)  (this document).  A\n+\n+- [Type Patterns in Switch](type-patterns-in-switch)  (this document) --- A\n@@ -23,2 +27,3 @@\n-- [Pattern Matching in the Java Object model](pattern-match-object-model.html).\n-  Explores how patterns fit into the Java object model, how they fill a hole we\n+\n+- [Pattern Matching in the Java Object model](pattern-match-object-model)\n+  --- Explores how patterns fit into the Java object model, how they fill a hole we\n@@ -47,1 +52,1 @@\n-**Typing.**  Currently, the operand of a `switch` may only be one of the\n+- **Typing.**  Currently, the operand of a `switch` may only be one of the\n@@ -57,1 +62,1 @@\n-**Parsing.**  The grammar currently specifies that the operand of a `case` label\n+- **Parsing.**  The grammar currently specifies that the operand of a `case` label\n@@ -65,1 +70,1 @@\n-**Nullity.**  In the limited forms where `switch` can be used on reference types\n+- **Nullity.**  In the limited forms where `switch` can be used on reference types\n@@ -73,1 +78,1 @@\n-**Exhaustiveness.**  For switches over the permitted subtypes of sealed types,\n+- **Exhaustiveness.**  For switches over the permitted subtypes of sealed types,\n@@ -80,1 +85,1 @@\n-**Fallthrough.**  Fallthrough is everyone's least favorite feature of `switch`,\n+- **Fallthrough.**  Fallthrough is everyone's least favorite feature of `switch`,\n@@ -86,5 +91,5 @@\n-```\n-case Box(int x):\n-case Bag(int x):\n-    \/\/ use x\n-```\n+  ```\n+  case Box(int x):\n+  case Bag(int x):\n+      \/\/ use x\n+  ```\n@@ -92,1 +97,1 @@\n-However, it is likely that we will, at least initially, disallow falling out\n+  However, it is likely that we will, at least initially, disallow falling out\n@@ -121,0 +126,1 @@\n+\n@@ -124,0 +130,1 @@\n+\n@@ -126,0 +133,1 @@\n+\n@@ -127,0 +135,1 @@\n+\n@@ -129,0 +138,1 @@\n+\n@@ -132,0 +142,1 @@\n+\n@@ -134,0 +145,1 @@\n+\n@@ -135,0 +147,1 @@\n+\n@@ -148,0 +161,1 @@\n+\n@@ -152,0 +166,1 @@\n+\n@@ -159,0 +174,1 @@\n+\n@@ -183,1 +199,1 @@\n-#### Translation\n+### Translation\n@@ -224,1 +240,1 @@\n-#### Guards\n+### Guards\n@@ -274,1 +290,1 @@\n-#### Do we need constant patterns?\n+### Do we need constant patterns?\n@@ -306,1 +322,1 @@\n-#### Missing primitive types\n+### Missing primitive types\n@@ -383,1 +399,1 @@\n-#### Switch totality\n+### Switch totality\n@@ -429,1 +445,1 @@\n-#### Refining totality\n+### Refining totality\n@@ -442,0 +458,1 @@\n+\n@@ -443,0 +460,1 @@\n+\n@@ -507,1 +525,1 @@\n-#### Patching the legacy holes\n+### Patching the legacy holes\n@@ -525,1 +543,1 @@\n-#### Looking ahead: pattern assignment\n+### Looking ahead: pattern assignment\n@@ -549,1 +567,1 @@\n-#### Total patterns in instanceof\n+### Total patterns in instanceof\n@@ -587,1 +605,1 @@\n-#### Refactoring switches\n+### Refactoring switches\n@@ -637,1 +655,1 @@\n-#### Some intuitions about totality and nullity\n+### Some intuitions about totality and nullity\n@@ -796,1 +814,1 @@\n-[patternmatch]: pattern-matching-for-java.html\n+[patternmatch]: pattern-matching-for-java\n","filename":"site\/design-notes\/patterns\/type-patterns-in-switch.md","additions":50,"deletions":32,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n-#### Brian Goetz, February 2019\n+#### Brian Goetz {.author}\n+#### February 2019 {.date}\n@@ -7,1 +8,1 @@\n-to [Data Classes in Java](data-classes-historical-2.html).  This is an\n+to [Data Classes in Java](data-classes-historical-2).  This is an\n@@ -41,1 +42,1 @@\n-At the other extreme, its pretty clear that:\n+At the other extreme, it's pretty clear that:\n@@ -91,1 +92,1 @@\n-#### Meet the elephant\n+### Meet the elephant\n@@ -132,1 +133,1 @@\n-#### Encapsulation and boundaries\n+### Encapsulation and boundaries\n@@ -145,1 +146,1 @@\n- - Maintenance boundaries -- when our clients are in a different\n+ - Maintenance boundaries --- when our clients are in a different\n@@ -147,1 +148,2 @@\n- - Security and trust boundaries -- where we do not want to expose our\n+\n+ - Security and trust boundaries --- where we do not want to expose our\n@@ -150,1 +152,2 @@\n- - Integrity boundaries -- where we do not want to expose our state to\n+\n+ - Integrity boundaries --- where we do not want to expose our state to\n@@ -154,1 +157,2 @@\n- - Versioning boundaries -- where we want to ensure that clients\n+\n+ - Versioning boundaries --- where we want to ensure that clients\n@@ -191,1 +195,1 @@\n-#### Digression -- enums\n+### Digression --- enums\n@@ -227,1 +231,1 @@\n-#### Priorities and goals\n+### Priorities and goals\n@@ -265,1 +269,1 @@\n-#### Records and sealed types\n+### Records and sealed types\n@@ -309,1 +313,1 @@\n-#### Records and pattern matching\n+### Records and pattern matching\n@@ -342,1 +346,1 @@\n-#### Records and externalization\n+### Records and externalization\n@@ -357,1 +361,1 @@\n-#### Why not \"just\" do tuples?\n+### Why not \"just\" do tuples?\n@@ -383,1 +387,1 @@\n-#### Are records the same as value types?\n+### Are records the same as value types?\n@@ -411,1 +415,1 @@\n-#### Digression: algebraic data types\n+### Digression: algebraic data types\n@@ -443,1 +447,1 @@\n-**Tree nodes.** The `Expr` example earlier shows how records can make\n+- **Tree nodes.** The `Expr` example earlier shows how records can make\n@@ -450,1 +454,1 @@\n-**Multiple return values.** It is often desirable for a method to\n+- **Multiple return values.** It is often desirable for a method to\n@@ -456,1 +460,1 @@\n-For example, say we want to extract both the minimal and maximal value\n+  For example, say we want to extract both the minimal and maximal value\n@@ -463,2 +467,2 @@\n-```{.java}\n-record MinMax(int min, int max);\n+  ```{.java}\n+  record MinMax(int min, int max);\n@@ -466,2 +470,2 @@\n-public MinMax minmax(int[] elements) { ... }\n-```\n+  public MinMax minmax(int[] elements) { ... }\n+  ```\n@@ -469,1 +473,1 @@\n-As noted earlier, some users would surely prefer we expose this\n+  As noted earlier, some users would surely prefer we expose this\n@@ -480,1 +484,1 @@\n-**Data transfer objects.**   A _data transfer object_ is an aggregate\n+- **Data transfer objects.**   A _data transfer object_ is an aggregate\n@@ -486,1 +490,1 @@\n-**Joins in stream operations.**  Suppose we have a derived quantity,\n+- **Joins in stream operations.**  Suppose we have a derived quantity,\n@@ -494,19 +498,19 @@\n-```{.java}\n-List<Person> topThreePeople(List<Person> list) {\n-    \/\/ local records are OK too!\n-    record PersonX(Person person, int hash) {\n-        PersonX(Person person) {\n-            this(person, person.name().toUpperCase().hashCode());\n-        }\n-    }\n-\n-    return list.stream()\n-               .map(PersonX::new)\n-               .sorted(Comparator.comparingInt(PersonX::hash))\n-               .limit(3)\n-               .map(PersonX::person)\n-               .collect(toList());\n-}\n-```\n-\n-Here, we start by adjoining the `Person` with the derived quantity,\n+  ```{.java}\n+  List<Person> topThreePeople(List<Person> list) {\n+      \/\/ local records are OK too!\n+      record PersonX(Person person, int hash) {\n+          PersonX(Person person) {\n+              this(person, person.name().toUpperCase().hashCode());\n+          }\n+      }\n+\n+      return list.stream()\n+                 .map(PersonX::new)\n+                 .sorted(Comparator.comparingInt(PersonX::hash))\n+                 .limit(3)\n+                 .map(PersonX::person)\n+                 .collect(toList());\n+  }\n+  ```\n+\n+  Here, we start by adjoining the `Person` with the derived quantity,\n@@ -516,1 +520,1 @@\n-We could have done this without materializing an extra object, but\n+  We could have done this without materializing an extra object, but\n@@ -520,1 +524,1 @@\n-**Compound map keys.** Sometimes we want to have a `Map` that is keyed\n+- **Compound map keys.** Sometimes we want to have a `Map` that is keyed\n@@ -531,7 +535,7 @@\n-```{.java}\n-record PersonPlace(Person person, Place place) { }\n-Map<PersonPlace, LocalDateTime> lastSeen = ...\n-...\n-LocalDateTime date = lastSeen.get(new PersonPlace(person, place));\n-...\n-```\n+  ```{.java}\n+  record PersonPlace(Person person, Place place) { }\n+  Map<PersonPlace, LocalDateTime> lastSeen = ...\n+  ...\n+  LocalDateTime date = lastSeen.get(new PersonPlace(person, place));\n+  ...\n+  ```\n@@ -539,1 +543,1 @@\n-**Messages.** Records and sums of records are commonly useful for\n+- **Messages.** Records and sums of records are commonly useful for\n@@ -547,1 +551,1 @@\n-**Value wrappers.**  The `Optional` class is an algebraic data type in\n+- **Value wrappers.**  The `Optional` class is an algebraic data type in\n@@ -556,1 +560,1 @@\n-**Discriminated entities.** A more sophisticated example is an API\n+- **Discriminated entities.** A more sophisticated example is an API\n@@ -567,2 +571,2 @@\n-```{.java}\n-interface IntrinsicProcessor {\n+  ```{.java}\n+  interface IntrinsicProcessor {\n@@ -570,6 +574,6 @@\n-    sealed interface Result {\n-        record None() implements Result;\n-        record Ldc(ConstantDesc constant) implements Result;\n-        record Indy(DynamicCallSiteDesc site, Object[] args)\n-            implements Result;\n-    }\n+      sealed interface Result {\n+          record None() implements Result;\n+          record Ldc(ConstantDesc constant) implements Result;\n+          record Indy(DynamicCallSiteDesc site, Object[] args)\n+              implements Result;\n+      }\n@@ -577,3 +581,3 @@\n-    public Result tryIntrinsify(...);\n-}\n-```\n+      public Result tryIntrinsify(...);\n+  }\n+  ```\n@@ -581,1 +585,1 @@\n-In this model, an intrinsic processor receives information about the\n+  In this model, an intrinsic processor receives information about the\n@@ -604,0 +608,1 @@\n+\n@@ -606,0 +611,1 @@\n+\n@@ -609,0 +615,1 @@\n+\n@@ -612,0 +619,1 @@\n+\n@@ -614,0 +622,1 @@\n+\n@@ -621,1 +630,1 @@\n-#### Customizing records\n+### Customizing records\n@@ -663,1 +672,1 @@\n-#### Odds and ends\n+### Odds and ends\n@@ -668,1 +677,1 @@\n-**Javadoc.** Since the fields and accessor methods are declared as\n+- **Javadoc.** Since the fields and accessor methods are declared as\n@@ -674,1 +683,1 @@\n-**Annotations.** Record components constitute a new place to put\n+- **Annotations.** Record components constitute a new place to put\n@@ -678,1 +687,1 @@\n-**Reflection.** Since being a record is a semantic statement,\n+- **Reflection.** Since being a record is a semantic statement,\n@@ -684,1 +693,1 @@\n-**Serialization.** One of the advantages of records is that we can\n+- **Serialization.** One of the advantages of records is that we can\n@@ -691,1 +700,1 @@\n-**Extension.** It would be possible to permit records to extend\n+- **Extension.** It would be possible to permit records to extend\n@@ -695,1 +704,1 @@\n-**Compatibility.** Since the arity, names, and types of the components\n+- **Compatibility.** Since the arity, names, and types of the components\n@@ -700,1 +709,1 @@\n-**Named invocation.** Because the names of the components form part of\n+- **Named invocation.** Because the names of the components form part of\n@@ -708,1 +717,1 @@\n-#### Restrictions\n+### Restrictions\n@@ -720,1 +729,1 @@\n-**Extension.** If our mantra is that the record's state description is\n+- **Extension.** If our mantra is that the record's state description is\n@@ -729,1 +738,1 @@\n-**Mutability.** The stricture against mutability is more complex,\n+- **Mutability.** The stricture against mutability is more complex,\n@@ -746,1 +755,1 @@\n-As much as it would be nice to automate away the boilerplate of\n+  As much as it would be nice to automate away the boilerplate of\n@@ -755,1 +764,1 @@\n-Nominal tuples with clearly defined semantics is something that can\n+  Nominal tuples with clearly defined semantics is something that can\n@@ -764,1 +773,1 @@\n-**Additional fields.** A related tension is whether a record can\n+- **Additional fields.** A related tension is whether a record can\n@@ -814,1 +823,1 @@\n-#### Exhaustiveness\n+### Exhaustiveness\n@@ -837,1 +846,1 @@\n-#### Inheritance\n+### Inheritance\n@@ -853,1 +862,1 @@\n-useful can be found in the JEP-334 API:\n+useful can be found in the JEP 334 API:\n@@ -899,0 +908,1 @@\n+[jep348]: https:\/\/openjdk.java.net\/jeps\/348\n","filename":"site\/design-notes\/records-and-sealed-classes.md","additions":98,"deletions":88,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-### String Tapas Redux: Beyond mere string interpolation\n@@ -3,1 +2,4 @@\n-#### Jim Laskey and Brian Goetz September 2021\n+# String Tapas Redux\n+## Beyond Mere String Interpolation {.subtitle}\n+#### Jim Laskey and Brian Goetz {.author}\n+#### September 2021 {.date}\n@@ -17,1 +19,1 @@\n- - **Ceremony**.  Writing string interpolation expressions, rather than calls to\n+ - _Ceremony_ --- Writing string interpolation expressions, rather than calls to\n@@ -19,1 +21,2 @@\n- - **Readability**.  In many cases (though not all) a string interpolation\n+\n+ - _Readability_ --- In many cases (though not all) a string interpolation\n@@ -23,1 +26,2 @@\n- - **Safety**.  A long format string or a long list of interpolants invites\n+\n+ - _Safety_ --- A long format string or a long list of interpolants invites\n@@ -30,1 +34,1 @@\n-  - **Injection attacks**.  Constructing SQL queries or JSON expressions with string\n+  - _Injection attacks_ --- Constructing SQL queries or JSON expressions with string\n@@ -36,1 +40,2 @@\n-  - **Localization**.  Java has a strong commitment to internationalization;\n+\n+  - _Localization_ --- Java has a strong commitment to internationalization;\n@@ -40,1 +45,2 @@\n-  - **Formatting**.  A naive interpretation of string interpolation deprives us of\n+\n+  - _Formatting_ --- A naive interpretation of string interpolation deprives us of\n@@ -66,1 +72,1 @@\n-#### What's wrong with string interpolation?\n+## What's wrong with string interpolation?\n@@ -90,1 +96,1 @@\n-separate features (this is one reason \"raw string literals\" was withdrawn.)  We\n+separate features (this is one reason \"raw string literals\" was withdrawn).  We\n@@ -94,1 +100,1 @@\n-#### Another level of indirection\n+## Another level of indirection\n@@ -141,1 +147,1 @@\n-#### Examples\n+## Examples\n@@ -146,1 +152,3 @@\n-**String formatting.**  Formatting libraries like `String::format` offer more\n+#### String formatting\n+\n+Formatting libraries like `String::format` offer more\n@@ -184,1 +192,3 @@\n-**Validation and normalization.**  SQL statements are often parameterized by\n+#### Validation and normalization\n+\n+SQL statements are often parameterized by\n@@ -236,1 +246,3 @@\n-**Non-string results.**  One could easily imagine a JSON or XML library\n+#### Non-string results\n+\n+One could easily imagine a JSON or XML library\n@@ -280,1 +292,3 @@\n-**Localization.**  The examples so far have been about interpolation enhanced\n+#### Localization\n+\n+The examples so far have been about interpolation enhanced\n","filename":"site\/design-notes\/templated-strings.md","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n-**Brian Goetz, June 2019**\n+#### Brian Goetz {.author}\n+#### June 2019 {.date}\n@@ -13,1 +14,1 @@\n-it was probably critical to Java's success --- Java would probably not\n+it was probably critical to Java's success -- Java would probably not\n@@ -34,1 +35,1 @@\n-pretends to be a library feature --- you opt in by implementing the\n+pretends to be a library feature -- you opt in by implementing the\n@@ -69,1 +70,1 @@\n-cannot easily read the code and deduce the serial form --- it's\n+cannot easily read the code and deduce the serial form -- it's\n@@ -77,1 +78,1 @@\n-constructor does in `readObject` --- and keep the two in sync.\n+constructor does in `readObject` -- and keep the two in sync.\n@@ -93,1 +94,1 @@\n-carefully before publishing a serializable class --- as doing so\n+carefully before publishing a serializable class -- as doing so\n@@ -133,1 +134,1 @@\n-just too hard to secure serialization for trusted code --- because\n+just too hard to secure serialization for trusted code -- because\n@@ -155,1 +156,1 @@\n-design effort for Lambdas involved interaction with serialization ---\n+design effort for Lambdas involved interaction with serialization --\n@@ -158,1 +159,1 @@\n-requiring the need to express intersection types in casts --- purely to\n+requiring the need to express intersection types in casts -- purely to\n@@ -165,1 +166,1 @@\n-Many of the design errors listed above stem from a common source ---\n+Many of the design errors listed above stem from a common source --\n@@ -176,1 +177,1 @@\n-warning us \"Dark magic here!\" --- at least we might stop and think\n+warning us \"Dark magic here!\" -- at least we might stop and think\n@@ -211,1 +212,1 @@\n-serializing _data_ --- which is a far easier problem.  (This mistake is\n+serializing _data_ -- which is a far easier problem.  (This mistake is\n@@ -256,1 +257,1 @@\n-address the fundamental programming-model or security concerns --- they\n+address the fundamental programming-model or security concerns -- they\n@@ -279,1 +280,1 @@\n-that it tries to do too much --- to ensure that an arbitrary object\n+that it tries to do too much -- to ensure that an arbitrary object\n@@ -292,1 +293,1 @@\n-documents --- which cannot even represent the notion of object\n+documents -- which cannot even represent the notion of object\n@@ -301,1 +302,1 @@\n-rely on exploiting backreferences --- which comes from the desire to\n+rely on exploiting backreferences -- which comes from the desire to\n@@ -317,1 +318,1 @@\n-clients --- ordinary Java code that will access or extend our class,\n+clients -- ordinary Java code that will access or extend our class,\n@@ -320,1 +321,1 @@\n-are for a different category of clients --- frameworks such as\n+are for a different category of clients -- frameworks such as\n@@ -331,1 +332,1 @@\n-> \"front door\" API --- and ideally we would do so with the same\n+> \"front door\" API -- and ideally we would do so with the same\n@@ -347,1 +348,1 @@\n-it too easy for classes to be serializable without realizing it ---\n+it too easy for classes to be serializable without realizing it --\n@@ -474,3 +475,3 @@\n-reconstruction of an object from its serialized form --- a constructor\n-or factory method.  To represent the other direction --- state\n-extraction --- we need to borrow some machinery from an upcoming\n+reconstruction of an object from its serialized form -- a constructor\n+or factory method.  To represent the other direction -- state\n+extraction -- we need to borrow some machinery from an upcoming\n@@ -479,1 +480,1 @@\n-destructuring logic as part of a class's API --- which is exactly what\n+destructuring logic as part of a class's API -- which is exactly what\n@@ -555,0 +556,1 @@\n+\n@@ -556,0 +558,1 @@\n+\n@@ -557,1 +560,1 @@\n-   representation --- one can take a serializable object and serialize\n+   representation -- one can take a serializable object and serialize\n@@ -560,0 +563,1 @@\n+\n@@ -562,0 +566,1 @@\n+\n@@ -570,1 +575,1 @@\n-most need that defensiveness --- and when we currently use it the\n+most need that defensiveness -- and when we currently use it the\n@@ -833,1 +838,1 @@\n-restricted --- whether because the member itself is inaccessible, or\n+restricted -- whether because the member itself is inaccessible, or\n@@ -909,1 +914,1 @@\n-list --- these can be serialized by extracting a more abstract,\n+list -- these can be serialized by extracting a more abstract,\n@@ -922,1 +927,1 @@\n-This limitation is also, in some way, a benefit --- it is far more\n+This limitation is also, in some way, a benefit -- it is far more\n@@ -934,0 +939,1 @@\n+\n@@ -936,0 +942,1 @@\n+\n@@ -940,0 +947,1 @@\n+\n@@ -960,2 +968,2 @@\n-[records]: records-and-sealed-classes-classes.html\n-[patterns]: pattern-matching-for-java.html\n+[records]: records-and-sealed-classes\n+[patterns]: patterns\/pattern-matching-for-java\n","filename":"site\/design-notes\/towards-better-serialization.md","additions":39,"deletions":31,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-# Local Variable Type Inference: Frequently Asked Questions\n@@ -3,2 +2,4 @@\n-#### Brian Goetz and Stuart Marks\\\n-August 2019\n+# Local Variable Type Inference\n+## Frequently Asked Questions {.subtitle}\n+#### Brian Goetz and Stuart Marks {.author}\n+#### August 2019 {.date}\n@@ -6,1 +7,1 @@\n-## Why have `var` in Java?\n+## Q1. Why have `var` in Java? {#Q1}\n@@ -25,1 +26,1 @@\n-## Does this make Java dynamically typed? Is this like `var` in JavaScript?\n+## Q2. Does this make Java dynamically typed? Is this like `var` in JavaScript? {#Q2}\n@@ -51,1 +52,1 @@\n-## Is a `var` variable final?\n+## Q3. Is a `var` variable final? {#Q3}\n@@ -88,1 +89,1 @@\n-## Won't bad developers misuse this feature to write terrible code?\n+## Q4. Won't bad developers misuse this feature to write terrible code? {#Q4}\n@@ -118,1 +119,1 @@\n-## Where can `var` be used?\n+## Q5. Where can `var` be used? {#Q5}\n@@ -158,1 +159,1 @@\n-## Why is an initializer required on the right-hand side of `var`?\n+## Q6. Why is an initializer required on the right-hand side of `var`? {#Q6}\n@@ -201,1 +202,1 @@\n-## Why can't you use `var` with `null`?\n+## Q7. Why can't you use `var` with `null`? {#Q7}\n@@ -224,1 +225,1 @@\n-## Can you use `var` with a diamond on the right-hand side?\n+## Q8. Can you use `var` with a diamond on the right-hand side? {#Q8}\n@@ -233,4 +234,2 @@\n-right. See the [LVTI Style Guidelines][1], guideline G6, for further\n-information.\n-\n-[1]: lvti-style-guide.html\n+right. See the [LVTI Style Guidelines][1], [guideline G6][1G6], for\n+further information.\n@@ -238,0 +237,2 @@\n+[1]: lvti-style-guide\n+[1G6]: lvti-style-guide#G6\n","filename":"site\/guides\/lvti-faq.md","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-# Local Variable Type Inference: Style Guidelines\n@@ -3,2 +2,4 @@\n-#### Stuart W. Marks\\\n-March 2018\n+# Local Variable Type Inference\n+## Style Guidelines {.subtitle}\n+#### Stuart W. Marks {.author}\n+#### March 2018 {.date}\n@@ -8,1 +9,1 @@\n-Java SE 10 introduced type inference for local variables. Previously,\n+Java SE 10 introduced [type inference for local variables][jep286]. Previously,\n@@ -34,1 +35,1 @@\n-### P1. Reading code is more important than writing code.\n+### P1. Reading code is more important than writing code. {#P1}\n@@ -52,1 +53,1 @@\n-### P2. Code should be clear from local reasoning.\n+### P2. Code should be clear from local reasoning. {#P2}\n@@ -62,1 +63,1 @@\n-### P3. Code readability shouldn't depend on IDEs.\n+### P3. Code readability shouldn't depend on IDEs. {#P3}\n@@ -85,1 +86,1 @@\n-### P4. Explicit types are a tradeoff.\n+### P4. Explicit types are a tradeoff. {#P4}\n@@ -102,1 +103,1 @@\n-### G1. Choose variable names that provide useful information.\n+### G1. Choose variable names that provide useful information. {#G1}\n@@ -121,1 +122,1 @@\n-conclusion, results in \"Hungarian Notation\". Just as with explicit\n+conclusion, results in \"[Hungarian Notation]\". Just as with explicit\n@@ -142,1 +143,1 @@\n-### G2. Minimize the scope of local variables.\n+### G2. Minimize the scope of local variables. {#G2}\n@@ -145,1 +146,1 @@\n-general. This practice is described in *Effective Java (3rd Edition)*,\n+general. This practice is described in [*Effective Java (3rd Edition)*][Bloch],\n@@ -196,1 +197,1 @@\n-### G3. Consider `var` when the initializer provides sufficient information to the reader.\n+### G3. Consider `var` when the initializer provides sufficient information to the reader. {#G3}\n@@ -223,1 +224,1 @@\n-### G4. Use `var` to break up chained or nested expressions with local variables.\n+### G4. Use `var` to break up chained or nested expressions with local variables. {#G4}\n@@ -272,1 +273,1 @@\n-### G5. Don't worry too much about \"programming to the interface\" with local variables.\n+### G5. Don't worry too much about \"programming to the interface\" with local variables. {#G5}\n@@ -312,1 +313,1 @@\n-### G6. Take care when using `var` with diamond or generic methods.\n+### G6. Take care when using `var` with diamond or generic methods. {#G6}\n@@ -368,1 +369,1 @@\n-### G7. Take care when using `var` with literals.\n+### G7. Take care when using `var` with literals. {#G7}\n@@ -510,1 +511,0 @@\n-## References\n@@ -512,6 +512,3 @@\n-[JEP 286: Local-Variable Type Inference](http:\/\/openjdk.java.net\/jeps\/286)\n-\n-[Wikipedia: Hungarian Notation](https:\/\/en.wikipedia.org\/wiki\/Hungarian_notation)\n-\n-[Bloch, Joshua. Effective Java, 3rd Edition. Addison-Wesley\n-Professional, 2018.](https:\/\/www.pearson.com\/us\/higher-education\/program\/Bloch-Effective-Java-3rd-Edition\/PGM1763855.html)\n+[jep286]: https:\/\/openjdk.java.net\/jeps\/286\n+[Hungarian Notation]: https:\/\/en.wikipedia.org\/wiki\/Hungarian_notation\n+[Bloch]: https:\/\/www.pearson.com\/us\/higher-education\/program\/Bloch-Effective-Java-3rd-Edition\/PGM1763855.html\n","filename":"site\/guides\/lvti-style-guide.md","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+<head>\n+  <style>\n+    .control { color: #e76f00; font-weight: bold; }\n+  <\/style>\n+  <script>\n+    function highlightControls() {\n+      const controls = \/[\\u21a6\\u2190\\u2193\\u00B7]+\/g;\n+      document.querySelectorAll(\"code\").forEach((code) => {\n+        code.innerHTML = code.textContent\n+              .replace(controls, (match) => `<span class=\"control\">${match}<\/span>`);\n+      });\n+    }\n+    document.addEventListener(\"DOMContentLoaded\", (event) => highlightControls());\n+  <\/script>\n+<\/head>\n","filename":"site\/guides\/text-blocks-guide.head","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -1,23 +0,0 @@\n-<script>\n-function highlightControls() {\n-    const map = {\n-      \"&\": \"&#x26;\",\n-      \"<\": \"&#x3C;\",\n-      \">\": \"&#x3E;\",\n-      \"\\\"\": \"&#x22;\",\n-      \"'\": \"&#x27;\",\n-      \"\/\": \"&#x2F;\"\n-    };\n-    const escapes = \/[&<>\"'\\\/]\/g;\n-    const controls = \/[\\u2409\\u240A\\u240D\\u00B7]+\/g;\n-\n-    document.querySelectorAll(\"code\").forEach((code) => {\n-        const text = code.textContent;\n-        const escapedText = text.replace(escapes, (match) => map[match]);\n-        const mappedText = escapedText.replace(controls, (match) => `<span class=\"control-character\">${match}<\/span>`);\n-        code.innerHTML = mappedText;\n-    });\n-}\n-\n-document.addEventListener(\"DOMContentLoaded\", (event) => highlightControls());\n-<\/script>\n@@ -27,2 +4,2 @@\n-#### Jim Laskey and Stuart Marks\\\n-Version 11 (August 2020)\n+#### Jim Laskey and Stuart Marks {.author}\n+#### Version 11 (August 2020) {.date}\n@@ -36,0 +13,4 @@\n+#### Contents\n+\n+<div class=\"table-of-contents\"\/>\n+\n@@ -120,1 +101,1 @@\n-#### Preview Feature in Java SE 13 and 14\n+### Preview Feature in Java SE 13 and 14\n@@ -145,1 +126,1 @@\n-#### Standard Feature in Java SE 15 and Beyond\n+### Standard Feature in Java SE 15 and Beyond\n@@ -167,1 +148,1 @@\n-#### Text Block Syntax\n+### Text Block Syntax\n@@ -212,1 +193,1 @@\n-#### That Final New Line\n+### That Final New Line\n@@ -232,1 +213,1 @@\n-last `\\n`. However, as described in guideline G12 below,\n+last `\\n`. However, as described in [guideline G12](#G12) below,\n@@ -236,1 +217,1 @@\n-#### Incidental White Space\n+### Incidental White Space\n@@ -375,1 +356,1 @@\n-#### Trailing White Space\n+### Trailing White Space\n@@ -419,1 +400,1 @@\n-#### Detecting Potential Issues with White Space\n+### Detecting Potential Issues with White Space\n@@ -433,1 +414,1 @@\n-`␉`):\n+`↦`):\n@@ -437,1 +418,1 @@\n-    ␉   ␉   ␉   ␉   ␉   green\n+    ↦   ↦   ↦   ↦   ↦   green\n@@ -459,1 +440,1 @@\n-#### Normalization Of Line Terminators\n+### Normalization Of Line Terminators\n@@ -471,2 +452,2 @@\n-appear in the source file. The following text block (where `␊` and\n-`␍` represent `\\n` and `\\r`):\n+appear in the source file. The following text block (where `↓` and\n+`←` represent `\\n` and `\\r`):\n@@ -475,3 +456,3 @@\n-        red␊\n-        green␍\n-        blue␍␊\n+        red↓\n+        green←\n+        blue←↓\n@@ -487,1 +468,1 @@\n-#### Translation Of Escape Sequences\n+### Translation Of Escape Sequences\n@@ -494,1 +475,1 @@\n-text block (where `␉` and `␊` represent  `\\t` and `\\n`):\n+text block (where `↦` and `↓` represent  `\\t` and `\\n`):\n@@ -497,4 +478,4 @@\n-        Color␉   Shape␊\n-        Red␉ ␉   Circle␊\n-        Green␉   Square␊\n-        Blue␉␉   Triangle␊\n+        Color↦   Shape↓\n+        Red↦ ↦   Circle↓\n+        Green↦   Square↓\n+        Blue↦↦   Triangle↓\n@@ -505,4 +486,4 @@\n-    Color␉  Shape␊\n-    Red␉ ␉  Circle␊\n-    Green␉  Square␊\n-    Blue␉␉  Triangle␊\n+    Color↦  Shape↓\n+    Red↦ ↦  Circle↓\n+    Green↦  Square↓\n+    Blue↦↦  Triangle↓\n@@ -541,1 +522,1 @@\n-#### New Escape Sequences\n+### New&nbsp;Escape Sequences\n@@ -575,1 +556,1 @@\n-## Style Guidelines For Text Blocks\n+## Style Guidelines for Text Blocks {toc=omit-children}\n@@ -577,2 +558,1 @@\n-**_G1. You should use a text block when it improves the clarity of the\n-code, particularly with multi-line strings._**\n+### G1. You should use a text block when it improves the clarity of the code, particularly with multi-line strings. {#G1}\n@@ -598,3 +578,1 @@\n-**_G2. If a string fits on a single line, without concatenation and\n-escaped newlines, you should probably continue to use a string\n-literal._**\n+### G2. If a string fits on a single line, without concatenation and escaped newlines, you should probably continue to use a string literal. {#G2}\n@@ -609,1 +587,1 @@\n-**_G3. Use embedded escape sequences when they maintain readability._**\n+### G3. Use embedded escape sequences when they maintain readability. {#G3}\n@@ -617,3 +595,1 @@\n-**_G4. For most multi-line strings, place the opening delimiter at the\n-right end of the previous line, and place the closing delimiter on its\n-own line, at the left margin of the text block._**\n+### G4. For most multi-line strings, place the opening delimiter at the right end of the previous line, and place the closing delimiter on its own line, at the left margin of the text block. {#G4}\n@@ -627,3 +603,1 @@\n-**_G5. Avoid aligning the opening and closing delimiters and the text\n-block's left margin. This requires reindentation of the text block if\n-the variable name or modifiers are changed._**\n+### G5. Avoid aligning the opening and closing delimiters and the text block's left margin. This requires reindentation of the text block if the variable name or modifiers are changed. {#G5}\n@@ -659,3 +633,1 @@\n-**_G6. Avoid in-line text blocks within complex expressions, as doing so\n-can distort readability. Consider refactoring to a local variable or to\n-a static final field._**\n+### G6. Avoid in-line text blocks within complex expressions, as doing so can distort readability. Consider refactoring to a local variable or to a static final field. {#G6}\n@@ -688,3 +660,1 @@\n-**_G7. Either use only spaces or only tabs for the indentation of a text\n-block. Mixing white space will lead to a result with irregular\n-indentation._**\n+### G7. Either use only spaces or only tabs for the indentation of a text block. Mixing white space will lead to a result with irregular indentation. {#G7}\n@@ -695,1 +665,1 @@\n-    ␉       green\n+    ↦       green\n@@ -704,3 +674,1 @@\n-**_G8. When a text block contains sequences of three or more double\n-quotes, escape the first double quote of every run of three double\n-quotes._**\n+### G8. When a text block contains sequences of three or more double quotes, escape the first double quote of every run of three double quotes. {#G8}\n@@ -724,2 +692,1 @@\n-**_G9. Most text blocks should be indented to align with neighbouring\n-Java code._**\n+### G9. Most text blocks should be indented to align with neighbouring Java code. {#G9}\n@@ -749,2 +716,1 @@\n-**_G10. It is recommended to fully left justify a wide string in order to\n-avoid horizontal scrolling or line wrapping._**\n+### G10. It is recommended to fully left justify a wide string in order to avoid horizontal scrolling or line wrapping. {#G10}\n@@ -790,5 +756,1 @@\n-**_G11. Similarly, it is also reasonable to fully left justify a text\n-block when a high line count causes the closing delimiter is likely to\n-vertically scroll out of view. This allows the reader to track\n-indentation with the left margin when the closing delimiter is out of\n-view._**\n+### G11. Similarly, it is also reasonable to fully left justify a text block when a high line count causes the closing delimiter is likely to vertically scroll out of view. This allows the reader to track indentation with the left margin when the closing delimiter is out of view. {#G11}\n@@ -837,3 +799,1 @@\n-**_G12. The `\\<line-terminator>` escape sequence should be used when a text\n-block's final new line needs to be excluded. This better frames the text block\n-and allows the closing delimiter to manage indentation._**\n+### G12. The `\\<line-terminator>` escape sequence should be used when a text block's final new line needs to be excluded. This better frames the text block and allows the closing delimiter to manage indentation. {#G12}\n@@ -864,1 +824,1 @@\n-#### `String formatted(Object... args)`\n+### `String formatted(Object... args)`\n@@ -877,1 +837,1 @@\n-#### `String stripIndent()`\n+### `String stripIndent()`\n@@ -885,1 +845,1 @@\n-#### `String translateEscapes()`\n+### `String&nbsp;translateEscapes()`\n@@ -899,1 +859,0 @@\n-<p>\n@@ -903,1 +862,0 @@\n-<p>\n","filename":"site\/guides\/text-blocks-guide.md","additions":50,"deletions":92,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -1,65 +0,0 @@\n-# Project Amber\n-\n-The goal of Project Amber is to explore and incubate smaller,\n-productivity-oriented Java language features that have been accepted\n-as candidate JEPs under\n-the [OpenJDK JEP Process](http:\/\/openjdk.java.net\/jeps\/1). This\n-Project is sponsored by\n-the [Compiler Group](http:\/\/openjdk.java.net\/groups\/compiler).\n-\n-Most Project Amber features go through at least two rounds\n-of [_Preview_](http:\/\/openjdk.java.net\/jeps\/12) before becoming an\n-official part of Java SE.  For a given feature, there are separate\n-JEPs for each round of preview and for final standardization.  This\n-page links only to the most recent JEP for a feature. Such JEPs may\n-have links to earlier JEPs for the feature, as appropriate.\n-\n-## Status of JEPs\n-\n-Currently in progress:\n-\n-  - [Sealed Classes](http:\/\/openjdk.java.net\/jeps\/409)\n-  - [Pattern Matching for <code>switch<\/code> (Preview)](http:\/\/openjdk.java.net\/jeps\/406)\n-  - [Record Patterns and Array Patterns (Preview)](http:\/\/openjdk.java.net\/jeps\/405)\n-<\/ul>\n-\n-<p>Delivered:<\/p>\n-\n-  - [Records](http:\/\/openjdk.java.net\/jeps\/395)\n-  - [Pattern Matching for <code>instanceof<\/code>](http:\/\/openjdk.java.net\/jeps\/394)\n-  - [Text Blocks](http:\/\/openjdk.java.net\/jeps\/378)\n-    - [Style Guidelines](guides\/lvti-style-guide.html)\n-    - [FAQ](guides\/lvti-faq.html)\n-  - [Switch Expressions](http:\/\/openjdk.java.net\/jeps\/361)\n-  - [Local-Variable Syntax for Lambda Parameters](http:\/\/openjdk.java.net\/jeps\/323)\n-  - [Local-Variable Type Inference (<code>var<\/code>)](http:\/\/openjdk.java.net\/jeps\/286)\n-\n-On hold:\n-\n- - [Enhanced Enums](http:\/\/openjdk.java.net\/jeps\/301) (see [here](http:\/\/mail.openjdk.java.net\/pipermail\/amber-spec-experts\/2017-May\/000041.html) for explanation)\n- - [Lambda Leftovers](http:\/\/openjdk.java.net\/jeps\/302)\n- - [Java Compiler Intrinsics for JDK APIs](http:\/\/openjdk.java.net\/jeps\/348)\n-\n-Withdrawn:\n-\n- - [Raw String Literals](http:\/\/openjdk.java.net\/jeps\/326), dropped in favor of Text Blocks (see [here](https:\/\/mail.openjdk.java.net\/pipermail\/jdk-dev\/2018-December\/002402.html) for explanation)\n-\n-## Documents\n-\n- - [Local Variable Type Inference Style Guide](guides\/lvti-style-guide.html) (March 2018)\n- - [Local Variable Type Inference FAQ](guides\/lvti-faq.html) (Oct 2018)\n- - [Programmer's Guide to Text Blocks](guides\/text-blocks-guide.html) (Aug 2019)\n- - [Pattern Matching for Java](design-notes\/patterns\/pattern-matching-for-java.html) (Sept 2018)\n- - [Pattern Matching for Java -- Semantics](design-notes\/patterns\/pattern-match-semantics.html) (Sept 2018)\n- - [Data Classes and Sealed Types for Java](design-notes\/records-and-sealed-classes.html) (Feb 2019)\n- - [Towards Better Serialization](design-notes\/towards-better-serialization.html) (June 2019)\n-\n-## Community\n-\n-  - [Members](http:\/\/openjdk.java.net\/census#amber)\n-  - Mailing Lists\n-    - [amber-dev](http:\/\/mail.openjdk.java.net\/mailman\/listinfo\/amber-dev) -- For technical discussion related to Project Amber\n-    - [amber-spec-experts](http:\/\/mail.openjdk.java.net\/mailman\/listinfo\/amber-spec-experts) -- For Expert Group members only\n-    - [amber-spec-observers](http:\/\/mail.openjdk.java.net\/mailman\/listinfo\/amber-spec-observers) -- A read-only clone of amber-spec-experts\n-    - [amber-spec-comments](http:\/\/mail.openjdk.java.net\/mailman\/listinfo\/amber-spec-comments) -- For submitting comments on the official specs\n-\n","filename":"site\/index.md","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"}]}