{"files":[{"patch":"@@ -1,1 +1,1 @@\n-# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,3 @@\n-asm.checksum = 3f5199523fb95304b44563f5d56d9f5a07270669\n-asm.tree.checksum = dfcad5abbcff36f8bdad5647fe6f4972e958ad59\n-asm.util.checksum = a8f978fbad00c565210bebedb28e5d6f73327134\n+asm.checksum = 11ae50d25b0fec4cff74a2c6b217280d9c727b52\n+asm.tree.checksum = b7eceb80554b955d73cea443f143d945f87755a5\n+asm.util.checksum = 9a3fb3a5cd6364dc5ca86d832093d7bcaa4ac927\n@@ -30,3 +30,3 @@\n-asm.jar = asm-8.0.1.jar\n-asm.tree.jar = asm-tree-8.0.1.jar\n-asm.util.jar = asm-util-8.0.1.jar\n+asm.jar = asm-9.1.jar\n+asm.tree.jar = asm-tree-9.1.jar\n+asm.util.jar = asm-util-9.1.jar\n@@ -40,0 +40,3 @@\n+# path to JCommander library\n+jcommanderjar = jcommander.jar\n+\n","filename":"build\/build.properties","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n-                <path path=\"${testngjar}:${build.dir}\/jcov.jar:${result.dir}\/test\/classes\"\/>\n+                <path path=\"${testngjar}:${build.dir}\/jcov.jar:${result.dir}\/test\/classes:${jcommanderjar}\"\/>\n","filename":"build\/build.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-build.number = 7\n+build.number = 9\n","filename":"build\/release.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions.InstrumentationMode;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions.MERGE;\n@@ -33,0 +30,1 @@\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -35,1 +33,0 @@\n-import com.sun.tdk.jcov.tools.LoggingFormatter;\n@@ -38,0 +35,1 @@\n+\n@@ -40,0 +38,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -44,0 +43,3 @@\n+import static com.sun.tdk.jcov.instrument.InstrumentationOptions.*;\n+import static com.sun.tdk.jcov.util.Utils.CheckOptions.*;\n+\n@@ -67,1 +69,1 @@\n-    private boolean genabstract = false;\n+    private boolean genAbstract = false;\n@@ -85,0 +87,1 @@\n+    private InstrumentationPlugin plugin;\n@@ -213,1 +216,1 @@\n-        if (gennative || genabstract) {\n+        if (gennative || genAbstract) {\n@@ -238,1 +241,16 @@\n-            InstrumentationParams params = new InstrumentationParams(innerinvocations, false, false, gennative, genfield, false, genabstract ? InstrumentationOptions.ABSTRACTMODE.DIRECT : InstrumentationOptions.ABSTRACTMODE.NONE, include, exclude, callerInclude, callerExclude, m_include, m_exclude, mode, save_beg, save_end)\n+            InstrumentationParams params = new InstrumentationParams(innerinvocations,\n+                    false,\n+                    false,\n+                    gennative,\n+                    genfield,\n+                    false,\n+                    genAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE,\n+                    include,\n+                    exclude,\n+                    callerInclude,\n+                    callerExclude,\n+                    m_include,\n+                    m_exclude,\n+                    mode,\n+                    save_beg,\n+                    save_end)\n@@ -243,1 +261,2 @@\n-                    .setInnerExcludes(innerExclude);\n+                    .setInnerExcludes(innerExclude)\n+                    .setInstrumentationPlugin(plugin);\n@@ -269,1 +288,1 @@\n-                            if (mpath.indexOf(\"\/\") != -1){\n+                            if (mpath.contains(\"\/\")){\n@@ -296,1 +315,1 @@\n-    public void finishWork() {\n+    public void finishWork() throws Exception {\n@@ -301,0 +320,1 @@\n+        if(plugin != null) plugin.instrumentationComplete();\n@@ -309,1 +329,1 @@\n-    public void finishWork(String outTemplate) {\n+    public void finishWork(String outTemplate) throws Exception {\n@@ -317,0 +337,1 @@\n+        if(plugin != null) plugin.instrumentationComplete();\n@@ -334,1 +355,1 @@\n-        return \"java com.sun.tdk.jcov.Instr [-option value] source1 sourceN\";\n+        return \"java -cp jcov.jar:source1:sourceN com.sun.tdk.jcov.Instr [-option value] source1 sourceN\";\n@@ -346,1 +367,0 @@\n-\n@@ -348,2 +368,2 @@\n-        return \"java -cp jcov.jar:source1:source2 com.sun.tdk.jcov.Instr -include java.lang.* \" +\n-                \"-type block -output instrumented_classes source1 source2\";\n+        return \"java -cp jcov.jar:source1:sourceN com.sun.tdk.jcov.Instr -include java.lang.* \" +\n+                \"-type block -output instrumented_classes source1 sourceN\";\n@@ -378,1 +398,1 @@\n-        return genabstract;\n+        return genAbstract;\n@@ -381,2 +401,2 @@\n-    public void setGenAbstract(boolean abstact) {\n-        this.genabstract = abstact;\n+    public void setGenAbstract(boolean genAbstract) {\n+        this.genAbstract = genAbstract;\n@@ -454,0 +474,4 @@\n+    public void setPlugin(InstrumentationPlugin plugin) {\n+        this.plugin = plugin;\n+    }\n+\n@@ -521,2 +545,1 @@\n-            LoggingFormatter.printStackTrace = true;\n-            throw new Exception(\"Critical exception: \", ex);\n+            throw new EnvHandlingException(\"Critical exception: \" + ex);\n@@ -532,12 +555,12 @@\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TYPE,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_INCLUDE,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_EXCLUDE,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SAVE_BEGIN,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SAVE_AT_END,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TEMPLATE,\n+                DSC_TYPE,\n+                DSC_INCLUDE,\n+                DSC_INCLUDE_LIST,\n+                DSC_EXCLUDE,\n+                DSC_CALLER_INCLUDE,\n+                DSC_CALLER_EXCLUDE,\n+                DSC_EXCLUDE_LIST,\n+                DSC_MINCLUDE,\n+                DSC_MEXCLUDE,\n+                DSC_SAVE_BEGIN,\n+                DSC_SAVE_AT_END,\n+                DSC_TEMPLATE,\n@@ -545,6 +568,7 @@\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ABSTRACT,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_NATIVE,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FIELD,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SYNTHETIC,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ANONYM,\n-                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INNERINVOCATION,\n+                DSC_ABSTRACT,\n+                DSC_NATIVE,\n+                DSC_FIELD,\n+                DSC_SYNTHETIC,\n+                DSC_ANONYM,\n+                DSC_INNERINVOCATION,\n+                DSC_INSTR_PLUGIN,\n@@ -564,1 +588,1 @@\n-            Utils.checkFile(outDir, \"output directory\", Utils.CheckOptions.FILE_NOTISFILE);\n+            Utils.checkFile(outDir, \"output directory\", FILE_NOTISFILE);\n@@ -571,2 +595,2 @@\n-        save_beg = opts.getValues(InstrumentationOptions.DSC_SAVE_BEGIN);\n-        save_end = opts.getValues(InstrumentationOptions.DSC_SAVE_AT_END);\n+        save_beg = opts.getValues(DSC_SAVE_BEGIN);\n+        save_end = opts.getValues(DSC_SAVE_AT_END);\n@@ -574,1 +598,1 @@\n-        String abstractValue = opts.getValue(InstrumentationOptions.DSC_ABSTRACT);\n+        String abstractValue = opts.getValue(DSC_ABSTRACT);\n@@ -576,1 +600,1 @@\n-            genabstract = false;\n+            genAbstract = false;\n@@ -578,1 +602,1 @@\n-            genabstract = true;\n+            genAbstract = true;\n@@ -580,1 +604,2 @@\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_ABSTRACT.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + abstractValue + \"'\");\n+            throw new EnvHandlingException(\"'\" + DSC_ABSTRACT.name +\n+                    \"' parameter value error: expected 'on' or 'off'; found: '\" + abstractValue + \"'\");\n@@ -583,1 +608,1 @@\n-        String nativeValue = opts.getValue(InstrumentationOptions.DSC_NATIVE);\n+        String nativeValue = opts.getValue(DSC_NATIVE);\n@@ -589,1 +614,2 @@\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_NATIVE.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + nativeValue + \"'\");\n+            throw new EnvHandlingException(\"'\" + DSC_NATIVE.name +\n+                    \"' parameter value error: expected 'on' or 'off'; found: '\" + nativeValue + \"'\");\n@@ -592,1 +618,1 @@\n-        String fieldValue = opts.getValue(InstrumentationOptions.DSC_FIELD);\n+        String fieldValue = opts.getValue(DSC_FIELD);\n@@ -599,1 +625,2 @@\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_FIELD.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + fieldValue + \"'\");\n+            throw new EnvHandlingException(\"'\" + DSC_FIELD.name +\n+                    \"' parameter value error: expected 'on' or 'off'; found: '\" + fieldValue + \"'\");\n@@ -602,6 +629,2 @@\n-        String anonym = opts.getValue(InstrumentationOptions.DSC_ANONYM);\n-        if (anonym.equals(\"on\")) {\n-            genanonymous = true;\n-        } else { \/\/ off\n-            genanonymous = false;\n-        }\n+        String anonym = opts.getValue(DSC_ANONYM);\n+        genanonymous = anonym.equals(\"on\");\n@@ -609,6 +632,2 @@\n-        String synthetic = opts.getValue(InstrumentationOptions.DSC_SYNTHETIC);\n-        if (synthetic.equals(\"on\")) {\n-            gensynthetic = true;\n-        } else { \/\/ if (fieldValue.equals(\"off\"))\n-            gensynthetic = false;\n-        }\n+        String synthetic = opts.getValue(DSC_SYNTHETIC);\n+        gensynthetic = synthetic.equals(\"on\");\n@@ -616,6 +635,2 @@\n-        String innerInvocation = opts.getValue(InstrumentationOptions.DSC_INNERINVOCATION);\n-        if (\"off\".equals(innerInvocation)) {\n-            innerinvocations = false;\n-        } else {\n-            innerinvocations = true;\n-        }\n+        String innerInvocation = opts.getValue(DSC_INNERINVOCATION);\n+        innerinvocations = ! \"off\".equals(innerInvocation);\n@@ -623,2 +638,2 @@\n-        callerInclude = opts.getValues(InstrumentationOptions.DSC_CALLER_INCLUDE);\n-        callerExclude = opts.getValues(InstrumentationOptions.DSC_CALLER_EXCLUDE);\n+        callerInclude = opts.getValues(DSC_CALLER_INCLUDE);\n+        callerExclude = opts.getValues(DSC_CALLER_EXCLUDE);\n@@ -628,3 +643,3 @@\n-        mode = InstrumentationOptions.InstrumentationMode.fromString(opts.getValue(InstrumentationOptions.DSC_TYPE));\n-        template = opts.getValue(InstrumentationOptions.DSC_TEMPLATE);\n-        Utils.checkFileNotNull(template, \"template filename\", Utils.CheckOptions.FILE_NOTISDIR, Utils.CheckOptions.FILE_PARENTEXISTS);\n+        mode = InstrumentationMode.fromString(opts.getValue(DSC_TYPE));\n+        template = opts.getValue(DSC_TEMPLATE);\n+        Utils.checkFileNotNull(template, \"template filename\", FILE_NOTISDIR, FILE_PARENTEXISTS);\n@@ -634,2 +649,2 @@\n-        include = InstrumentationOptions.handleInclude(opts);\n-        exclude = InstrumentationOptions.handleExclude(opts);\n+        include = handleInclude(opts);\n+        exclude = handleExclude(opts);\n@@ -637,2 +652,2 @@\n-        m_include = InstrumentationOptions.handleMInclude(opts);\n-        m_exclude = InstrumentationOptions.handleMExclude(opts);\n+        m_include = handleMInclude(opts);\n+        m_exclude = handleMExclude(opts);\n@@ -645,1 +660,11 @@\n-        Utils.checkFileCanBeNull(include_rt, \"JCovRT library jarfile\", Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_ISFILE, Utils.CheckOptions.FILE_CANREAD);\n+        Utils.checkFileCanBeNull(include_rt, \"JCovRT library jarfile\", FILE_EXISTS, FILE_ISFILE, FILE_CANREAD);\n+\n+        try {\n+            String pluginClass = opts.getValue(DSC_INSTR_PLUGIN);\n+            if(pluginClass != null && !pluginClass.isEmpty())\n+                plugin = (InstrumentationPlugin) Class.forName(opts.getValue(DSC_INSTR_PLUGIN))\n+                        .getDeclaredConstructor().newInstance();\n+        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n+                NoSuchMethodException | InvocationTargetException e) {\n+            throw new EnvHandlingException(\"'\" + DSC_INSTR_PLUGIN.name + \"' parameter error: '\" + e + \"'\");\n+        }\n@@ -656,1 +681,0 @@\n-\n@@ -659,0 +683,1 @@\n+\n@@ -662,2 +687,3 @@\n-                    \"Specifies output directory, default directory is current. Instr command could process different dirs and different jars: \\n \"\n-                            + \"all classes from input dirs and all jars will be placed in output directory.\");\n+                    \"Specifies output directory, default directory is current. \" +\n+                            \"Instr command could process different dirs and different jars: \\n \" +\n+                            \"all classes from input dirs and all jars will be placed in output directory.\");\n@@ -667,1 +693,2 @@\n-            new OptionDescr(\"implantrt\", new String[]{\"rt\"}, \"Runtime management\", OptionDescr.VAL_SINGLE, \"Allows to implant needed for runtime files into instrumented data: -includert jcov_rt.jar\");\n+            new OptionDescr(\"implantrt\", new String[]{\"rt\"}, \"Runtime management\", OptionDescr.VAL_SINGLE,\n+                    \"Allows to implant needed for runtime files into instrumented data: -includert jcov_rt.jar\");\n@@ -669,1 +696,3 @@\n-            new OptionDescr(\"subsequent\", \"\", OptionDescr.VAL_NONE, \"Template would be used to decide what should not be instrumented - all existing in template would be treated as already instrumented\");\n+            new OptionDescr(\"subsequent\", \"\", OptionDescr.VAL_NONE,\n+                    \"Template would be used to decide what should not be instrumented - \" +\n+                            \"all existing in template would be treated as already instrumented\");\n@@ -671,1 +700,3 @@\n-            new OptionDescr(\"recursive\", \"\", OptionDescr.VAL_NONE, \"Recurse through specified directories instrumenting everything inside. With -flush option it will be able to instrument duplicate classes. \");\n+            new OptionDescr(\"recursive\", \"\", OptionDescr.VAL_NONE,\n+                    \"Recurse through specified directories instrumenting everything inside. \" +\n+                            \"With -flush option it will be able to instrument duplicate classes\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":114,"deletions":83,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -474,0 +475,1 @@\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INSTR_PLUGIN,\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/JREInstr.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tdk.jcov.runtime.PropertyFinder;\n@@ -51,0 +50,4 @@\n+import static com.sun.tdk.jcov.util.Utils.FILE_TYPE;\n+import static com.sun.tdk.jcov.util.Utils.FILE_TYPE.*;\n+import static com.sun.tdk.jcov.util.Utils.isClassFile;\n+\n@@ -57,14 +60,0 @@\n-    private static final String ZIP_EXT = \".zip\";\n-    private static final String JAR_EXT = \".jar\";\n-    private static final String WAR_EXT = \".war\";\n-    private static final String CLASS_EXT = \".class\";\n-    private static final String CUST_CLASS_EXTS[];\n-\n-    static {\n-        String t = PropertyFinder.findValue(\"clext\", null);\n-        if (t == null) {\n-            CUST_CLASS_EXTS = new String[]{};\n-        } else {\n-            CUST_CLASS_EXTS = t.split(\":\");\n-        }\n-    }\n@@ -75,2 +64,1 @@\n-\/\/    protected Log log; \/\/ where to print messages to\n-\/\/\n+\n@@ -185,1 +173,2 @@\n-                    logger.log(Level.SEVERE, \"  Error reading data from ''{0}'': File is empty\\n - skipped\", fname);\n+                    logger.log(Level.SEVERE, \"  Error reading data from ''{0}'': File is empty\\n - skipped\",\n+                            fname);\n@@ -188,1 +177,2 @@\n-                    logger.log(Level.SEVERE, \"  Error reading data from ''{0}'': File is too small ({1}) - skipped\", new Object[]{fname, f.length()});\n+                    logger.log(Level.SEVERE, \"  Error reading data from ''{0}'': File is too small ({1}) - skipped\",\n+                            new Object[]{fname, f.length()});\n@@ -206,1 +196,1 @@\n-            \/\/ class is not instrumentable or is already instrumented\n+            \/\/ class can't be\/is already instrumented\n@@ -220,1 +210,0 @@\n-\n@@ -247,1 +236,0 @@\n-\/\/            this.root = dir;\n@@ -253,1 +241,1 @@\n-                if (f.getPath().endsWith(CLASS_EXT)) {\n+                if (FILE_TYPE.hasExtension(f.getPath(), CLASS)) {\n@@ -271,1 +259,2 @@\n-        String outFilename = outArc == null ? makeInstrumentedFileName(arc.getPath()) : outArc.getPath() + File.separator + arc.getName();\n+        String outFilename = outArc == null ? makeInstrumentedFileName(arc.getPath()) :\n+                outArc.getPath() + File.separator + arc.getName();\n@@ -277,1 +266,1 @@\n-        ZipInputStream in = null;\n+        ZipInputStream in;\n@@ -339,3 +328,2 @@\n-\n-            byte[] res = null;\n-            boolean isClass = ename.endsWith(CLASS_EXT) && !isDir;\n+            byte[] res;\n+            boolean isClass = ename.endsWith(CLASS.getExtension()) && !isDir;\n@@ -421,1 +409,1 @@\n-                logger.log(Level.INFO, \"  Adding saver libray...\");\n+                logger.log(Level.INFO, \"  Adding saver library...\");\n@@ -426,1 +414,1 @@\n-                if (!rt.isFile() || (!rt.getName().endsWith(JAR_EXT) && !rt.getName().endsWith(ZIP_EXT))) {\n+                if (!rt.isFile() || !FILE_TYPE.hasExtension(rt.getName(), JAR, ZIP)) {\n@@ -483,1 +471,2 @@\n-                                    \/\/ logger.log(Level.WARNING, \"Output jar contains file {0} that was found in runtime jar but files sizes differ, skipping\", checking.getName());\n+                                    \/\/ logger.log(Level.WARNING, \"Output jar contains file {0} that was found in runtime jar but files sizes differ, skipping\",\n+                                    \/\/ checking.getName());\n@@ -485,1 +474,2 @@\n-                                    \/\/ logger.log(Level.INFO, \"Output jar contains file {0} that was found in runtime jar, skipping\", checking.getName());\n+                                    \/\/ logger.log(Level.INFO, \"Output jar contains file {0} that was found in runtime jar, skipping\",\n+                                    \/\/ checking.getName());\n@@ -523,1 +513,2 @@\n-                logger.log(Level.WARNING, \" Can''t remove initial JAR file ''{0}''\", arc.getAbsolutePath());\n+                logger.log(Level.WARNING, \" Can''t remove initial JAR file ''{0}''\",\n+                        arc.getAbsolutePath());\n@@ -526,1 +517,2 @@\n-                logger.log(Level.WARNING, \" Can''t rename result JAR file ''{0}' to ''{1}''. Please move manually\", new Object[]{outFile.getAbsolutePath(), arc.getAbsolutePath()});\n+                logger.log(Level.WARNING, \" Can''t rename result JAR file ''{0}' to ''{1}''. Please move manually\",\n+                        new Object[]{outFile.getAbsolutePath(), arc.getAbsolutePath()});\n@@ -565,1 +557,3 @@\n-    public void instrument(File instrumentingPath, File destinationPath, String rtPath, ArrayList<String> rtClassDirTargets, boolean recursive) throws IOException {\n+    public void instrument(File instrumentingPath, File destinationPath,\n+                           String rtPath, ArrayList<String> rtClassDirTargets,\n+                           boolean recursive) throws IOException {\n@@ -591,1 +585,0 @@\n-\/\/                this.root = instrumentingPath;\n@@ -602,1 +595,1 @@\n-        } else if (instrumentingPath.getName().endsWith(JAR_EXT) || instrumentingPath.getName().endsWith(ZIP_EXT) || instrumentingPath.getName().endsWith(WAR_EXT)) {\n+        } else if ( FILE_TYPE.hasExtension(instrumentingPath.getName(), JAR, ZIP, WAR) ) {\n@@ -633,1 +626,2 @@\n-            logger.log(Level.INFO, \"Summary for ''{0}'': files total={1}, classes total={2}, instrumented classes total={3}\", new Object[]{instrumentingPath, fileCount, classCount, iClassCount});\n+            logger.log(Level.INFO, \"Summary for ''{0}'': files total={1}, classes total={2}, instrumented classes total={3}\",\n+                    new Object[]{instrumentingPath, fileCount, classCount, iClassCount});\n@@ -729,7 +723,0 @@\n-\/\/    \/**\n-\/\/     * sets the log where all messages will be printed to\n-\/\/     *\/\n-\/\/    public void setLog(Log log) {\n-\/\/        this.log = log;\n-\/\/    }\n-\/\/\n@@ -752,1 +739,1 @@\n-        if (!rt.isFile() || (!rt.getName().endsWith(JAR_EXT) && !rt.getName().endsWith(ZIP_EXT))) {\n+        if (!rt.isFile() || !FILE_TYPE.hasExtension(rt.getName(), JAR, ZIP)) {\n@@ -792,1 +779,2 @@\n-                    \/\/ logger.log(Level.WARNING, \"Output classfile directory contains file {0} that was found in runtime jar, skipping without contains checking\", e0.getName());\n+                    \/\/ logger.log(Level.WARNING, \"Output classfile directory contains file {0} that was found in runtime jar,\n+                    \/\/ skipping without contains checking\", e0.getName());\n@@ -795,1 +783,2 @@\n-                    \/\/ logger.log(Level.INFO, \"Adding runtime file {0} to output directory {1}\", new Object[]{e1.getName, outDir.getName()})\n+                    \/\/ logger.log(Level.INFO, \"Adding runtime file {0} to output directory {1}\",\n+                    \/\/ new Object[]{e1.getName, outDir.getName()})\n@@ -810,5 +799,0 @@\n-    }\n-\n-    private boolean isClassFile(String fileName) {\n-        if (fileName.endsWith(CLASS_EXT)) {\n-            return true;\n@@ -816,7 +800,0 @@\n-        for (String s : CUST_CLASS_EXTS) {\n-            if (fileName.endsWith(s)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/insert\/AbstractUniversalInstrumenter.java","additions":37,"deletions":60,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -220,1 +220,4 @@\n-        return mv;\n+\n+        InstrumentationPlugin plugin = params.getInstrumentationPlugin();\n+        if(plugin != null)\n+            mv = plugin.methodVisitor(access, k.getFullname(), name, desc, mv);        return mv;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DeferringMethodClassAdapter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-     * Constructs a new {@link MethodAdapter} object.\n+     * Constructs a new {@link ForkingMethodAdapter} object.\n@@ -88,1 +88,2 @@\n-     * @param mv the code visitor to which this adapter must delegate calls.\n+     * @param mv1 the first code visitor to which this adapter must delegate calls.\n+     * @param mv2 the second code visitor to which this adapter must delegate calls.\n@@ -168,7 +169,4 @@\n-    public void visitMethodInsn(\n-            final int opcode,\n-            final String owner,\n-            final String name,\n-            final String desc) {\n-        mv1.visitMethodInsn(opcode, owner, name, desc);\n-        mv2.visitMethodInsn(opcode, owner, name, desc);\n+    public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc,\n+                                final boolean isInterface) {\n+        mv1.visitMethodInsn(opcode, owner, name, desc, isInterface);\n+        mv2.visitMethodInsn(opcode, owner, name, desc, isInterface);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/ForkingMethodAdapter.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-            \"Specify included classes by regular expression for adding inner invocations instrumentaion\\n\" +\n+            \"Specify included classes by regular expression for adding inner invocations instrumentation\\n\" +\n@@ -157,1 +157,1 @@\n-            \"Specify excluded classes by regular expression, no inner invocations instrumentaion will be\\n\" +\n+            \"Specify excluded classes by regular expression, no inner invocations instrumentation will be\\n\" +\n@@ -160,0 +160,4 @@\n+    public final static OptionDescr DSC_INSTR_PLUGIN =\n+            new OptionDescr(\"instr_plugin\", new String[0], \"Instrumentation plugin\", OptionDescr.VAL_SINGLE,\n+                    \"Defines instrumentation to be performed additionaly to already performed by JCov\");\n+\n@@ -343,1 +347,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationOptions.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+\n@@ -37,0 +38,1 @@\n+import java.util.Collection;\n@@ -70,36 +72,87 @@\n-    private boolean innerInvocations = true;\n-\n-    public InstrumentationParams(boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, InstrumentationMode mode) {\n-        this(dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, mode, null, null);\n-    }\n-\n-    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract, String[] includes, String[] excludes, InstrumentationMode mode) {\n-        this(false, instrumentNative, instrumentFields, false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes, null, null, mode, null, null);\n-    }\n-\n-    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,  String[] includes, String[] excludes, String[] m_includes, String[] m_excludes, InstrumentationMode mode) {\n-        this(false, false, false, instrumentNative, instrumentFields, false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes, null, null, m_includes, m_excludes, mode, null, null);\n-    }\n-\n-    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract, String[] includes, String[] excludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(false, instrumentNative, instrumentFields, false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes, null, null, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract, String[] includes, String[] excludes, String[] callerincludes, String[] callersexcludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(false, instrumentNative, instrumentFields, false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes, callerincludes, callersexcludes, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(false, dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean classesReload, boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(true, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(innerInvocations, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, null, null, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, String[] m_includes, String[] m_excludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-\n+    private boolean innerInvocations;\n+    private InstrumentationPlugin plugin;\n+\n+    \/\/TODO replace by a builder!!!\n+    public InstrumentationParams(boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields,\n+                                 boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes,\n+                                 String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 InstrumentationMode mode) {\n+        this(dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract,\n+                includes, excludes, callerIncludes, callerExcludes, mode, null, null);\n+    }\n+\n+    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,\n+                                 String[] includes, String[] excludes, InstrumentationMode mode) {\n+        this(false, instrumentNative, instrumentFields, false,\n+                instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes,\n+                null, null, mode, null, null);\n+    }\n+\n+    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] m_includes, String[] m_excludes,\n+                                 InstrumentationMode mode) {\n+        this(false, false, false, instrumentNative, instrumentFields,\n+                false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes,\n+                null, null, m_includes, m_excludes, mode, null, null);\n+    }\n+\n+    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,\n+                                 String[] includes, String[] excludes, InstrumentationMode mode,\n+                                 String[] saveBegin, String[] saveEnd) {\n+        this(false, instrumentNative, instrumentFields, false,\n+                instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes,\n+                null, null, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,\n+                                 String[] includes, String[] excludes,\n+                                 String[] callerincludes, String[] callersexcludes,\n+                                 InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n+        this(false, instrumentNative, instrumentFields, false,\n+                instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE,\n+                includes, excludes, callerincludes, callersexcludes, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields,\n+                                 boolean detectInternal, ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n+        this(false, dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract,\n+                includes, excludes, callerIncludes, callerExcludes, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean classesReload, boolean dynamicCollect, boolean instrumentNative,\n+                                 boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n+        this(true, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal,\n+                instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect,\n+                                 boolean instrumentNative, boolean instrumentFields, boolean detectInternal,\n+                                 ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n+        this(innerInvocations, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal,\n+                instrumentAbstract, includes, excludes, callerIncludes, callerExcludes,\n+                null, null, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect,\n+                                 boolean instrumentNative, boolean instrumentFields, boolean detectInternal,\n+                                 ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 String[] m_includes, String[] m_excludes, InstrumentationMode mode,\n+                                 String[] saveBegin, String[] saveEnd) {\n+        this(innerInvocations, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal,\n+                instrumentAbstract, includes, excludes, callerIncludes, callerExcludes,\n+                null, null, mode, saveBegin, saveEnd, null);\n+    }\n+\n+    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect,\n+                                 boolean instrumentNative, boolean instrumentFields, boolean detectInternal,\n+                                 ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 String[] m_includes, String[] m_excludes, InstrumentationMode mode,\n+                                 String[] saveBegin, String[] saveEnd, InstrumentationPlugin plugin) {\n@@ -146,0 +199,1 @@\n+        this.plugin = plugin;\n@@ -176,0 +230,4 @@\n+    public InstrumentationPlugin getInstrumentationPlugin() {\n+        return plugin;\n+    }\n+\n@@ -332,0 +390,5 @@\n+    public InstrumentationParams setInstrumentationPlugin(InstrumentationPlugin plugin) {\n+        this.plugin = plugin;\n+        return this;\n+    }\n+\n@@ -364,0 +427,1 @@\n+        this.plugin = null;\n@@ -365,1 +429,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationParams.java","additions":101,"deletions":37,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument;\n+\n+import org.objectweb.asm.MethodVisitor;\n+\n+\/**\n+ * SPI class which allows to do additional instrumentation, in addition to instrumentation performed by JCov by default.\n+ * @author Alexander (Shura) Ilin.\n+ *\/\n+public interface InstrumentationPlugin {\n+    \/**\n+     * Supplies a MethodVisitor to perform additional instrumentation.\n+     *\/\n+    MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor);\n+\n+    \/**\n+     * Called after all instrumentation is complete.\n+     * @throws Exception should some\n+     *\/\n+    void instrumentationComplete() throws Exception;\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationPlugin.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-            mv.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/Collect\", \"saveResults\", \"()V\");\n+            mv.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/Collect\", \"saveResults\", \"()V\", false);\n@@ -68,1 +68,1 @@\n-                    mv.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/Collect\", \"saveResults\", \"()V\");\n+                    mv.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/Collect\", \"saveResults\", \"()V\", false);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/SavePointsMethodAdapter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-    static int invokeCount = 0;\n@@ -53,0 +52,1 @@\n+    \/\/ method attributes\n@@ -54,0 +54,1 @@\n+    private int methAccess;\n@@ -69,1 +70,1 @@\n-    public static final Map<String, Integer> map = new HashMap<String, Integer>();\n+    public static final Map<String, Integer> map = new HashMap<>();\n@@ -71,1 +72,3 @@\n-    public StaticInvokeMethodAdapter(MethodVisitor mv, String className, String methName, int access, final InstrumentationParams params) {\n+    public StaticInvokeMethodAdapter(MethodVisitor mv, String className,\n+                                     String methName, int methAccess,\n+                                     final InstrumentationParams params) {\n@@ -74,1 +77,0 @@\n-        this.params = params;\n@@ -76,0 +78,2 @@\n+        this.methAccess = methAccess;\n+        this.params = params;\n@@ -111,0 +115,1 @@\n+\n@@ -120,2 +125,2 @@\n-            if (!owner.equals(\"java\/lang\/Object\")) {\n-                int id = params.isInnerInstrumentationIncludes(className) ? 0 : -1;\n+            if (!owner.equals(\"java\/lang\/Object\") && params.isInnerInstrumentationIncludes(className)) {\n+              int id =  ( (this.methAccess & ACC_BRIDGE) == 0x0) ? -1 : 0;\n@@ -131,1 +136,0 @@\n-\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/StaticInvokeMethodAdapter.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014,2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    private ArrayList<JavapLine> lines = new ArrayList<JavapLine>();\n+    private final ArrayList<JavapLine> lines = new ArrayList<>();\n@@ -52,1 +52,1 @@\n-    private HashMap<String, ArrayList<Integer>> methods = new HashMap<String, ArrayList<Integer>>();\n+    private final HashMap<String, ArrayList<Integer>> methods = new HashMap<>();\n@@ -70,1 +70,0 @@\n-\n@@ -96,1 +95,1 @@\n-            BufferedReader inStream = null;\n+            BufferedReader inStream;\n@@ -118,2 +117,1 @@\n-                    parseClassName(textLine);\n-                    parsePackageName(textLine);\n+                    parsePackageAndClassNames(textLine);\n@@ -129,1 +127,1 @@\n-                    methods.put(lastMethodString, new ArrayList<Integer>());\n+                    methods.put(lastMethodString, new ArrayList<>());\n@@ -133,1 +131,1 @@\n-                        methods.put(lastMethodString, new ArrayList<Integer>());\n+                        methods.put(lastMethodString, new ArrayList<>());\n@@ -157,1 +155,1 @@\n-    private void parseClassName(String textLine) {\n+    final private static String[] JavaClassTokens = new String[] {\"implements\", \"extends\", \"{\"};\n@@ -159,3 +157,1 @@\n-        if (textLine.contains(\"implements\")) {\n-            textLine = textLine.substring(0, textLine.indexOf(\"implements\"));\n-        }\n+    private void parsePackageAndClassNames(String textLine) {\n@@ -163,2 +159,4 @@\n-        if (textLine.contains(\"extends\")) {\n-            textLine = textLine.substring(0, textLine.indexOf(\"extends\"));\n+         for( String s :  JavaClassTokens) {\n+             if (textLine.contains(s)) {\n+                 textLine = textLine.substring(0, textLine.indexOf(s));\n+            }\n@@ -166,1 +164,0 @@\n-        textLine = textLine + \"{\";\n@@ -168,4 +165,1 @@\n-        className = substringBetween(textLine, \"\\\\.\", \"\\\\ \", false);\n-        if(className != null && className.contains(\"<\") && className.contains(\">\")){\n-            className = className.substring(0, className.indexOf('<'));\n-        }\n+         textLine = textLine.substring(textLine.indexOf(\"class\")+5).trim();\n@@ -173,3 +167,3 @@\n-        if (className.startsWith(\"class\")){\n-            className = className.substring(6, className.length());\n-        }\n+         int ind = textLine.indexOf('<');\n+         if(ind != -1){\n+             textLine = textLine.substring(0, ind);\n@@ -178,8 +172,7 @@\n-    private void parsePackageName(String textLine) {\n-\n-        if (textLine.contains(\"implements\")) {\n-            textLine = textLine.substring(0, textLine.indexOf(\"implements\"));\n-        }\n-\n-        if (textLine.contains(\"extends\")) {\n-            textLine = textLine.substring(0, textLine.indexOf(\"extends\"));\n+         ind = textLine.lastIndexOf('.');\n+         if( ind > 0 ) {\n+             packageName = textLine.substring(0,ind);\n+             className = textLine.substring(ind+1);\n+         } else {\n+             className = textLine;\n+             packageName = \"\";\n@@ -187,3 +180,0 @@\n-        textLine = textLine + \"{\";\n-\n-        packageName = substringBetween(textLine, \"\\\\ \", \"\\\\.\", false);\n@@ -193,2 +183,1 @@\n-        String nameAndVMSig = \"<clinit>()V\";\n-        return nameAndVMSig;\n+        return \"<clinit>()V\";\n@@ -200,2 +189,1 @@\n-        String nameAndVMSig = \"<init>\" + vmSig;\n-        return nameAndVMSig;\n+        return \"<init>\" + vmSig;\n@@ -218,1 +206,1 @@\n-            s = className.substring(className.lastIndexOf(\".\"), className.length());\n+            s = className.substring(className.lastIndexOf(\".\"));\n@@ -221,21 +209,41 @@\n-        String newType = \"\";\n-        if (\"boolean\".equals(s) || \"Boolean\".equals(s)) {\n-            newType = \"Z\";\n-        } else if (\"void\".equals(s) || \"Void\".equals(s)) {\n-            newType = \"V\";\n-        } else if (\"int\".equals(s) || \"Integer\".equals(s)) {\n-            newType = \"I\";\n-        } else if (\"long\".equals(s) || \"Long\".equals(s)) {\n-            newType = \"J\";\n-        } else if (\"char\".equals(s) || \"Character\".equals(s)) {\n-            newType = \"C\";\n-        } else if (\"byte\".equals(s) || \"Byte\".equals(s)) {\n-            newType = \"B\";\n-        } else if (\"double\".equals(s) || \"Double\".equals(s)) {\n-            newType = \"D\";\n-        } else if (\"short\".equals(s) || \"Short\".equals(s)) {\n-            newType = \"S\";\n-        } else if (\"float\".equals(s) || \"Number\".equals(s)) {\n-            newType = \"F\";\n-        } else {\n-            newType = \"L\";\n+        String newType;\n+        switch (s) {\n+            case \"boolean\":\n+            case \"Boolean\":\n+                newType = \"Z\";\n+                break;\n+            case \"void\":\n+            case \"Void\":\n+                newType = \"V\";\n+                break;\n+            case \"int\":\n+            case \"Integer\":\n+                newType = \"I\";\n+                break;\n+            case \"long\":\n+            case \"Long\":\n+                newType = \"J\";\n+                break;\n+            case \"char\":\n+            case \"Character\":\n+                newType = \"C\";\n+                break;\n+            case \"byte\":\n+            case \"Byte\":\n+                newType = \"B\";\n+                break;\n+            case \"double\":\n+            case \"Double\":\n+                newType = \"D\";\n+                break;\n+            case \"short\":\n+            case \"Short\":\n+                newType = \"S\";\n+                break;\n+            case \"float\":\n+            case \"Number\":\n+                newType = \"F\";\n+                break;\n+            default:\n+                newType = \"L\";\n+                break;\n@@ -243,1 +251,1 @@\n-        String prefix = \"\";\n+        StringBuilder prefix = new StringBuilder();\n@@ -245,1 +253,1 @@\n-            prefix += \"[\";\n+            prefix.append(\"[\");\n@@ -269,1 +277,1 @@\n-        String vmSig = \"\";\n+        StringBuilder vmSig = new StringBuilder();\n@@ -274,1 +282,1 @@\n-                    vmSig += encodeVmType(p);\n+                    vmSig.append(encodeVmType(p));\n@@ -277,1 +285,1 @@\n-                vmSig += encodeVmType(params);\n+                vmSig.append(encodeVmType(params));\n@@ -320,2 +328,1 @@\n-        String regexStringFirst = \"([^\" + open + \"]+)(?=\" + close + \")\";\n-        String regexString = regexStringFirst;\n+        String regexString = \"([^\" + open + \"]+)(?=\" + close + \")\";\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/javap\/JavapClass.java","additions":74,"deletions":67,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,2 @@\n+        \/\/ Note: if the RepGen is being started by JDK 9 and above then\n+        \/\/ the option \"--add-exports jdk.jdeps\/com.sun.tools.javap=ALL-UNNAMED\" should be added to the JVM command-line.\n@@ -70,1 +72,1 @@\n-                            instance = classToLoad.newInstance();\n+                            instance = classToLoad.getDeclaredConstructor().newInstance();\n@@ -72,1 +74,1 @@\n-                            String[] params = null;\n+                            String[] params;\n@@ -101,1 +103,1 @@\n-                String[] params = null;\n+                String[] params;\n@@ -109,1 +111,1 @@\n-                    Object result = method.invoke(instance, params, pw);\n+                    method.invoke(instance, params, pw);\n@@ -115,1 +117,0 @@\n-\n@@ -119,1 +120,1 @@\n-        System.err.println(\"cannot execute javap, perhaps jdk7+\/lib\/tools.jar is missing from the classpath and from java.home\");\n+        System.err.println(\"cannot execute javap, perhaps jdk8\/lib\/tools.jar is missing from the classpath and from java.home\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/javap\/JavapClassReader.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+\n@@ -47,0 +48,2 @@\n+import static java.lang.String.format;\n+\n@@ -54,1 +57,3 @@\n-    private RepGen repGen;\n+    private final RepGen repGen;\n+\n+    private static String strMsg = \"\";\n@@ -84,2 +89,1 @@\n-     * @param templatePath - path to the result.xml (xml file for creating\n-     * report)\n+     * @param templatePath - path to the result.xml (xml file for creating report)\n@@ -91,1 +95,1 @@\n-        DataRoot file_image = null;\n+        DataRoot file_image;\n@@ -97,0 +101,1 @@\n+            return;\n@@ -100,1 +105,1 @@\n-            System.out.println(\"no input classes specified\");\n+            JavapRepGen.printErrorMsg(\"no input classes specified\");\n@@ -104,2 +109,2 @@\n-        ArrayList<File> classFiles = new ArrayList<File>();\n-        ArrayList<String> classFilesInJar = new ArrayList<String>();\n+        ArrayList<File> classFiles = new ArrayList<>();\n+        ArrayList<String> classFilesInJar = new ArrayList<>();\n@@ -107,1 +112,1 @@\n-        HashMap<String, JavapClass> classes = new HashMap<String, JavapClass>();\n+        HashMap<String, JavapClass> classes = new HashMap<>();\n@@ -122,1 +127,1 @@\n-                    Enumeration entries = jarFile.entries();\n+                    Enumeration<JarEntry> entries = jarFile.entries();\n@@ -125,1 +130,1 @@\n-                        JarEntry entry = (JarEntry) entries.nextElement();\n+                        JarEntry entry = entries.nextElement();\n@@ -138,1 +143,1 @@\n-            System.out.println(\"no .class files found at the specified path: \" + classesPath);\n+            JavapRepGen.printErrorMsg(\"no .class files found at the specified path: \" + classesPath);\n@@ -161,1 +166,1 @@\n-                ArrayList<Integer> visitedBlocksNumbers = new ArrayList<Integer>();\n+                ArrayList<Integer> visitedBlocksNumbers = new ArrayList<>();\n@@ -179,1 +184,1 @@\n-                List<JavapLine> methodLines = null;\n+                List<JavapLine> methodLines;\n@@ -181,1 +186,0 @@\n-\n@@ -184,2 +188,0 @@\n-                }\n-\n@@ -187,1 +189,0 @@\n-\n@@ -189,1 +190,0 @@\n-\n@@ -195,1 +195,6 @@\n-\n+                } else {\n+                    JavapRepGen.printErrorMsg(format(\"Can't get javap output for %s.class (%s) at the specified path: %s\",\n+                            dataClass.getName(),\n+                            templatePath,\n+                            classesPath));\n+                }\n@@ -203,1 +208,1 @@\n-            System.err.println(\"error in report generation: \" + e);\n+            JavapRepGen.printErrorMsg(\"error in report generation: \" + e);\n@@ -208,0 +213,7 @@\n+    private static void printErrorMsg(String msg) {\n+        if ( strMsg.hashCode() != msg.hashCode() ) {\n+            strMsg = msg;\n+            System.err.println(msg);\n+        }\n+    }\n+\n@@ -210,1 +222,1 @@\n-        ArrayList<File> newFiles = new ArrayList<File>();\n+        ArrayList<File> newFiles = new ArrayList<>();\n@@ -238,1 +250,1 @@\n-        ArrayList<String> newFilesInJar = new ArrayList<String>();\n+        ArrayList<String> newFilesInJar = new ArrayList<>();\n@@ -241,1 +253,0 @@\n-\n@@ -245,1 +256,0 @@\n-\n@@ -247,1 +257,0 @@\n-\n@@ -250,1 +259,0 @@\n-\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/javap\/JavapRepGen.java","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Arrays;\n@@ -317,1 +318,0 @@\n-                    PropertyFinder.addAutoShutdownSave();\n@@ -319,0 +319,1 @@\n+                PropertyFinder.addAutoShutdownSave();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/runtime\/Collect.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    private static boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n+    \/\/ private final static boolean isWindows = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n@@ -141,1 +141,0 @@\n-\n@@ -146,1 +145,0 @@\n-                PrintStream ps = System.out;\n@@ -148,1 +146,1 @@\n-                    Merger.innerMain(new String[]{\"-output\", dest, \"-scale\", \"-compress\", tmpFileName, src}, ps);\n+                    Merger.main(new String[]{\"-output\", dest, \"-scale\", \"-compress\", tmpFileName, src});\n@@ -150,1 +148,1 @@\n-                    Merger.innerMain(new String[]{\"-output\", dest, tmpFileName, src}, ps);\n+                    Merger.main(new String[]{\"-output\", dest, tmpFileName, src});\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/runtime\/JCovXMLFileSaver.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -136,2 +137,4 @@\n-                } else if (ch == 'F') { \/\/ field\n-                    String className = patt.substring(2, patt.lastIndexOf('.'));\n+                } else if (ch == 'F') { \/\/ static field\n+                    int ind = patt.lastIndexOf('.');\n+                    String className = patt.substring(2, ind );\n+\n@@ -140,1 +143,1 @@\n-                        Field f = c.getDeclaredField(patt.substring(patt.lastIndexOf('.') + 1, patt.length()));\n+                        Field f = c.getDeclaredField(patt.substring(ind + 1));\n@@ -162,2 +165,3 @@\n-                } else if (ch == 'M') { \/\/ method\n-                    String className = patt.substring(2, patt.lastIndexOf('.'));\n+                } else if (ch == 'M') { \/\/ static method\n+                    int ind = patt.lastIndexOf('.');\n+                    String className = patt.substring(2, ind);\n@@ -166,1 +170,1 @@\n-                        Method m = c.getDeclaredMethod(patt.substring(patt.lastIndexOf('.') + 1, patt.length()), (Class[]) null);\n+                        Method m = c.getDeclaredMethod(patt.substring(ind + 1), (Class[]) null);\n@@ -472,0 +476,12 @@\n+                        String s = PropertyFinder.findValue(\"data-saver\", null);\n+                        if(s != null) {\n+                            try {\n+                                Class clz = Class.forName(s);\n+                                Object saver = clz.getConstructor().newInstance();\n+                                Method mthd = clz.getMethod(\"saveResults\", new Class[] {});\n+                                mthd.invoke(saver);\n+                            } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException |\n+                                    InvocationTargetException | InstantiationException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n@@ -476,0 +492,1 @@\n+                ignore.printStackTrace();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/runtime\/PropertyFinder.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Arrays;\n@@ -105,1 +106,3 @@\n-            handler.getOut().println(\"Use \\\"java -jar jcov.jar \" + name.substring(name.lastIndexOf(\".\") + 1) + \" -h\\\" for command-line help or \\\"java -jar jcov.jar \" + name.substring(name.lastIndexOf(\".\") + 1) + \" -hv\\\" for wider description\");\n+            handler.getOut().println(\"Use \\\"java -jar jcov.jar \" + name.substring(name.lastIndexOf(\".\") + 1) +\n+                    \" -h\\\" for command-line help or \\\"java -jar jcov.jar \" + name.substring(name.lastIndexOf(\".\") + 1) +\n+                    \" -hv\\\" for wider description\");\n@@ -142,1 +145,3 @@\n-            handler.getOut().println(\"Use \\\"java -jar jcov.jar \" + name.substring(name.lastIndexOf(\".\") + 1) + \" -h\\\" for command-line help or \\\"java -jar jcov.jar \" + name.substring(name.lastIndexOf(\".\") + 1) + \" -hv\\\" for wider description\");\n+            handler.getOut().println(\"Use \\\"java -jar jcov.jar \" + name.substring(name.lastIndexOf(\".\") + 1) +\n+                    \" -h\\\" for command-line help or \\\"java -jar jcov.jar \" + name.substring(name.lastIndexOf(\".\") + 1) +\n+                    \" -hv\\\" for wider description\");\n@@ -161,3 +166,6 @@\n-            System.out.println(\"Execution error: \" + e.getMessage());\n-            if (PropertyFinder.findValue(\"stacktrace\", \"false\").equals(\"true\")) {\n-                e.printStackTrace(System.out);\n+            if( ! e.getMessage().isEmpty()  ) {\n+                System.err.println(e.getMessage());\n+            }\n+            if ( e.getMessage().isEmpty() ||\n+                    PropertyFinder.findValue(\"stacktrace\", \"\").equals(\"true\")) {\n+                e.printStackTrace(System.err);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/tools\/JCovCMDTool.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.tdk.jcov.runtime.PropertyFinder;\n@@ -40,0 +41,1 @@\n+import java.nio.file.Paths;\n@@ -46,1 +48,0 @@\n-import java.util.stream.Stream;\n@@ -90,0 +91,29 @@\n+    public enum FILE_TYPE {\n+        ZIP, JAR, WAR, CLASS;\n+        public String getExtension() {\n+            return \".\" + this.name().toLowerCase();\n+        }\n+\n+        public static boolean hasExtension(String fileName, FILE_TYPE... fTypes) {\n+           for(FILE_TYPE ftype : fTypes) {\n+               if( fileName.endsWith(ftype.getExtension()) ) {\n+                   return true;\n+               }\n+           }\n+           return false;\n+        }\n+    }\n+\n+    \/**\n+     * It's possible to set custom classfile extension by \"clext\" property (through jcov.clext system property, JCOV_CLEXT\n+     * environment variable and so on) - for example \"clazz:.klass\".\n+     *\/\n+    public static final List<String>  CUSTOM_CLASS_FILE_EXTENSIONS =\n+            Arrays.asList(PropertyFinder.findValue(\"clext\", \"\").split(\":\").clone());\n+\n+    public static boolean isClassFile(String fileName) {\n+        if(FILE_TYPE.hasExtension(fileName, FILE_TYPE.CLASS)) {\n+            return true;\n+        }\n+        return CUSTOM_CLASS_FILE_EXTENSIONS.stream().anyMatch(ext->fileName.endsWith(ext));\n+    }\n@@ -104,1 +134,1 @@\n-            for(int i=1; i<=15; i++) {\n+            for(int i=1; i<=20; i++) {\n@@ -515,1 +545,1 @@\n-    public static void addToClasspath(String[] paths) {\n+    public static void addToClasspath(String[] sourcePaths) {\n@@ -523,3 +553,3 @@\n-                URL[] urls = new URL[paths.length];\n-                for (int i = 0; i < paths.length; i++) {\n-                    urls[i] = new File(paths[i]).toURI().toURL();\n+                URL[] urls = new URL[sourcePaths.length];\n+                for (int i = 0; i < sourcePaths.length; i++) {\n+                    urls[i] = new File(sourcePaths[i]).toURI().toURL();\n@@ -534,2 +564,21 @@\n-            for (int i = 0; i < paths.length; i++) {\n-                String path = paths[i];\n+            \/\/ eliminate paths that could be missed in classpath\n+            \/\/1. For class files in a(n) (un)named package, the class path ends\n+            \/\/   with the directory that contains the class files. (should be in classpath)\n+            \/\/2. jar,zip,war should be a part of classpath (should be in classpath)\n+            List<String> paths = new ArrayList<>();\n+            Arrays.stream(sourcePaths).\n+                    forEach(\n+                            path -> {\n+                                File file = Paths.get(path).toFile();\n+                                if (file.isDirectory()) {\n+                                    if(!file.getName().equalsIgnoreCase(\"jmods\")) {\n+                                        paths.add(path);\n+                                    }\n+                                } else if (file.isFile()) {\n+                                    if( FILE_TYPE.hasExtension(path, FILE_TYPE.ZIP, FILE_TYPE.JAR, FILE_TYPE.WAR) ) {\n+                                        paths.add(path);\n+                                    }\n+                                }\n+                            }\n+                    );\n+            for (String path : paths) {\n@@ -537,1 +586,1 @@\n-                    String cps = Arrays.stream(paths).collect(Collectors.joining(\"#\"));\n+                    String cps = paths.stream().collect(Collectors.joining(\"#\"));\n@@ -541,1 +590,1 @@\n-                                    \"Example: java -cp jcov.jar:%s com.sun.tdk.jcov.Instr -t <template> -o <output> %s%n\",\n+                                    \"Example: java -cp jcov.jar:%s ToolName -t <template> -o <output> %s%n\",\n@@ -558,1 +607,1 @@\n-            Utils.addToClasspath(classes.toArray(new String[0]));\n+            Utils.addToClasspath(classes.toArray(new String[]{}));\n@@ -567,1 +616,1 @@\n-                if (f.getAbsolutePath().endsWith(\".jar\") || f.getAbsolutePath().endsWith(\".class\")) {\n+                if (FILE_TYPE.hasExtension(f.getAbsolutePath(), FILE_TYPE.JAR, FILE_TYPE.CLASS) ) {\n@@ -1047,5 +1096,13 @@\n-    public static enum CheckOptions {\n-\n-        FILE_EXISTS, FILE_NOTEXISTS, FILE_ISFILE, FILE_ISDIR, FILE_NOTISDIR,\n-        FILE_PARENTEXISTS, FILE_CANREAD, FILE_CANWRITE, INT_NONNEGATIVE,\n-        INT_POSITIVE, INT_NOT_NULL, FILE_NOTISFILE\n+    public enum CheckOptions {\n+        FILE_EXISTS,\n+        FILE_NOTEXISTS,\n+        FILE_ISFILE,\n+        FILE_ISDIR,\n+        FILE_NOTISDIR,\n+        FILE_PARENTEXISTS,\n+        FILE_CANREAD,\n+        FILE_CANWRITE,\n+        INT_NONNEGATIVE,\n+        INT_POSITIVE,\n+        INT_NOT_NULL,\n+        FILE_NOTISFILE\n@@ -1108,1 +1165,1 @@\n-     * <p> Checks a file for some criterias <\/p>\n+     * <p> Checks a file for some criteria <\/p>\n@@ -1112,1 +1169,1 @@\n-     * @param opts criterias to check\n+     * @param opts criteria to check\n@@ -1133,5 +1190,5 @@\n-\/\/                case FILE_CANWRITE:\n-\/\/                    if (!file.canWrite()) {\n-\/\/                        throw new EnvHandlingException(\"Incorrect \" + message + \" (\" + file.getPath() + \") - can't write\");\n-\/\/                    }\n-\/\/                    break;\n+                case FILE_CANWRITE:\n+                    if (!file.canWrite()) {\n+                        throw new EnvHandlingException(\"Incorrect \" + description + \" (\" + file.getPath() + \") - can't write\");\n+                    }\n+                    break;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/util\/Utils.java","additions":81,"deletions":24,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin;\n+\n+\/**\n+ * This is a test class which is instrumented during the test.\n+ *\/\n+public class FieldsClass {\n+    int field1;\n+    String field2 = \"\";\n+\n+    public void setField1(int field1) {\n+        this.field1 = field1;\n+    }\n+\n+    public void setField2(String field2) {\n+        this.field2 = field2;\n+    }\n+\n+    public static void main(String[] args) {\n+        FieldsClass ac = new FieldsClass();\n+        ac.field1 = 1;\n+        ac.field2 = \"one\";\n+        ac.setField1(2);\n+        ac.setField2(\"two\");\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/FieldsClass.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.runtime.JCovSaver;\n+import org.objectweb.asm.MethodVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static java.lang.String.format;\n+import static org.objectweb.asm.Opcodes.*;\n+\n+\/**\n+ * An instrumentation plugin which saves some information about fields and methods used during execution.\n+ * This plugin inserts calls to specific mathod after every PUTFIELD bytecode instruction.\n+ * This plugin only supports Object and int data types.\n+ * This class also defines the logic to be used at runtime to save the collected data by printing it into the output.\n+ *\/\n+public class FieldsPlugin implements InstrumentationPlugin, JCovSaver {\n+\n+    public static final Map<String, Set<Object>> values = new HashMap<>();\n+    public static final String INSTRUMENTATION_COMPLETE = \"Instrumentation complete: \";\n+\n+    public static void recordFieldValue(Object value, String field) {\n+        Set<Object> fieldValues = values.getOrDefault(field, new HashSet<>());\n+        if(values.containsKey(field)) {\n+            fieldValues = values.get(field);\n+        } else {\n+            fieldValues = new HashSet<>();\n+            values.put(field, fieldValues);\n+        }\n+        fieldValues.add(value);\n+    }\n+\n+\/\/    @Override\n+    public MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor) {\n+        return new MethodVisitor(ASM6, visitor) {\n+            @Override\n+            public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {\n+                if(opcode == PUTFIELD) {\n+                    super.visitInsn(DUP);\n+                    if(!descriptor.startsWith(\"L\")) {\n+                        switch (descriptor) {\n+                            case \"I\":\n+                                super.visitMethodInsn(INVOKESTATIC, Integer.class.getName().replace(\".\", \"\/\"),\n+                                        \"valueOf\", \"(I)Ljava\/lang\/Integer;\", false);\n+                                break;\n+                        }\n+                    }\n+                    super.visitLdcInsn(format(\"%s.%s\", owner, name));\n+                    super.visitMethodInsn(INVOKESTATIC, FieldsPlugin.class.getName().replace('.', '\/'),\n+                            \"recordFieldValue\", \"(Ljava\/lang\/Object;Ljava\/lang\/String;)V\", false);\n+                }\n+                super.visitFieldInsn(opcode, owner, name, descriptor);\n+            }\n+        };\n+    }\n+\n+    final static AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @Override\n+    public void instrumentationComplete() throws Exception {\n+        completeCount.incrementAndGet();\n+        System.out.println(INSTRUMENTATION_COMPLETE + completeCount);\n+    }\n+\n+    @Override\n+    public void saveResults() {\n+        values.entrySet().forEach(e ->\n+                e.getValue().forEach(v -> System.out.println(e.getKey() + \"=\" + v)));\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/FieldsPlugin.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin;\n+\n+import com.sun.tdk.jcov.lib.InstrProxy;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.sun.tdk.jcov.instrument.plugin.FieldsPlugin.INSTRUMENTATION_COMPLETE;\n+import static java.lang.Integer.parseInt;\n+import static java.util.stream.Collectors.joining;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * Tests that it is possible to use instrumentation plugin and a corresponding data saver.\n+ *\/\n+public class FieldsTest {\n+    Path test_dir;\n+    InstrProxy instr;\n+\n+    \/**\n+     * Perform the instrumentation.\n+     *\/\n+    @Test\n+    public void instrument() throws IOException, InterruptedException {\n+        test_dir = Paths.get(System.getProperty(\"user.dir\")).resolve(\"plugin_test\");\n+        instr = new InstrProxy(test_dir);\n+        instr.copyBytecode(FieldsClass.class.getName());\n+        System.getProperties().setProperty(\"jcov.selftest\", \"true\");\n+        int[] instrumentationCompleteTimes = new int[1];\n+        instr.instr(new String[]{\"-instr_plugin\", FieldsPlugin.class.getName()},\n+                line -> {\n+                    if(line.startsWith(INSTRUMENTATION_COMPLETE))\n+                        instrumentationCompleteTimes[0] =\n+                                parseInt(line.substring(INSTRUMENTATION_COMPLETE.length()));\n+                }, null,\n+                FieldsClass.class.getName());\n+        assertEquals(instrumentationCompleteTimes[0], 1);\n+        \/\/this does not work because\n+        \/\/Warning: Add input source(s) to the classpath: -cp jcov.jar:...\n+        \/\/see InstrProxy class for more info\n+        \/\/assertEquals(FieldsPlugin.completeCount.intValue(), 1);\n+    }\n+\n+    \/**\n+     * Check collected field values at runtime in the same VM.\n+     *\/\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void fields() throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        instr.runClass(FieldsClass.class.getName(), new String[0]);\n+        Set<Object> set = new HashSet<Object>(){{ add(1); add(2);  }};\n+        testFieldValuesSameVM(\"field1\", set);\n+        set = new HashSet<Object>(){{ add(\"\"); add(\"two\"); add(\"one\");  }};\n+        testFieldValuesSameVM(\"field2\", set);\n+    }\n+    private void testFieldValuesSameVM(String field, Set<Object> values) {\n+        String fullName = FieldsClass.class.getName().replace('.','\/') + \".\" + field;\n+        testFieldValues(fullName, field, values, FieldsPlugin.values.get(fullName));\n+    }\n+\n+    \/**\n+     * Test that data saver is called.\n+     *\/\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void testSaver() throws IOException, InterruptedException {\n+        List<String> command = new ArrayList<>();\n+        command.add(System.getProperty(\"java.home\") + \"\/bin\/java\");\n+        command.add(\"-Djcov.data-saver=\"+FieldsPlugin.class.getName());\n+        command.add(\"-cp\");\n+        command.add(test_dir\n+                + File.pathSeparator + System.getProperty(\"java.class.path\"));\n+        command.add(FieldsClass.class.getName());\n+        System.out.println(command.stream().collect(joining(\" \")));\n+        Process p = new ProcessBuilder().command(command.toArray(new String[0]))\n+                .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                .start();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            List<String> lines = in.lines().collect(Collectors.toList());\n+            Set<Object> set = new HashSet<Object>(){{ add(1); add(2);  }};\n+            testFieldValuesOtherVM(\"field1\", set, lines);\n+            set = new HashSet<Object>(){{ add(\"\"); add(\"two\"); add(\"one\");  }};\n+            testFieldValuesOtherVM(\"field2\", set, lines);\n+        }\n+        assertEquals(p.waitFor(), 0);\n+    }\n+    private void testFieldValuesOtherVM(String field, Set<Object> values, List<String> lines) {\n+        String fullName = FieldsClass.class.getName().replace('.','\/') + \".\" + field;\n+        testFieldValues(fullName, field,\n+                values.stream().map(Object::toString).collect(Collectors.toSet()),\n+                lines.stream().filter(l -> l.startsWith(fullName + \"=\"))\n+                        .map(l -> l.substring(fullName.length() + 1))\n+                        .collect(Collectors.toSet()));\n+    }\n+    private void testFieldValues(String fullName, String field, Set<Object> values, Set<Object> actual) {\n+        if(values.size() == 0) {\n+            assertFalse(FieldsPlugin.values.containsKey(fullName), \"No values for field \" + fullName);\n+        } else {\n+            assertNotNull(actual);\n+            System.out.printf(\"Comparing [%s] with [%s]\\n\",\n+                    values.stream().map(Object::toString).collect(joining(\",\")),\n+                    actual.stream().map(Object::toString).collect(joining(\",\")));\n+            assertEquals(values.size(), actual.size(), \"size\");\n+            assertTrue(values.stream().allMatch(actual::contains), \"content is the same\");\n+        }\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/FieldsTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin;\n+\n+import com.sun.tdk.jcov.JREInstr;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.runtime.Collect;\n+import org.objectweb.asm.MethodVisitor;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class JREInstrTest {\n+\n+    public static final String TIMES_SAVED = \"TIMES SAVED \";\n+    public static final String TIMES_CALLED = \"TIMES CALLED \";\n+\n+    Path rtJar;\n+    Path jre;\n+\n+    private Path copyJRE(Path src) throws IOException {\n+        Path dest = Files.createTempDirectory(\"JDK\");\n+        Files.walk(src).forEach(s -> {\n+            try {\n+                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        return dest;\n+    }\n+\n+    private void removeJRE(Path jre) throws IOException {\n+        Files.walkFileTree(jre, new FileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    private Path createJCovRtJar() throws IOException {\n+        Path dest = Files.createTempFile(\"jcov-rt-\", \".jar\");\n+        System.out.println(\"rt jar: \" + dest);\n+        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n+            jar.putNextEntry(new JarEntry(Collect.class.getName().replace(\".\", File.separator) + \".class\"));\n+        }\n+        return dest;\n+    }\n+\n+    @BeforeClass\n+    public void setup() throws IOException {\n+        String testJRE = System.getProperty(\"test.jre\");\n+        if(testJRE == null) {\n+            testJRE = System.getProperty(\"java.home\");\n+        }\n+        rtJar = createJCovRtJar();\n+        jre = copyJRE(Paths.get(testJRE));\n+    }\n+\n+    @Test\n+    public void testJREInstr() throws IOException, InterruptedException {\n+        VoidPlugin.reset();\n+        String[] params = new String[] {\n+                \"-implantrt\", rtJar.toString(),\n+                \"-instr_plugin\", VoidPlugin.class.getName(), jre.toString()};\n+        System.out.println(params);\n+        new JREInstr().run(params);\n+        assertEquals(VoidPlugin.savedTimes.intValue(), 1);\n+        assertTrue(VoidPlugin.calledTimes.get() > 0);\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(jre != null && Files.exists(jre)) removeJRE(jre);\n+        if(rtJar != null && Files.exists(rtJar)) Files.delete(rtJar);\n+    }\n+\n+    public static class VoidPlugin implements InstrumentationPlugin {\n+\n+        public static AtomicInteger calledTimes = new AtomicInteger(0);\n+        public static AtomicInteger savedTimes = new AtomicInteger(0);\n+\n+        public static void reset() {\n+            calledTimes.set(0);\n+            savedTimes.set(0);\n+        }\n+\n+        @Override\n+        public MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor) {\n+            calledTimes.incrementAndGet();\n+            return null;\n+        }\n+\n+        @Override\n+        public void instrumentationComplete() throws Exception {\n+            savedTimes.incrementAndGet();\n+        }\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/JREInstrTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.lib;\n+\n+import com.sun.tdk.jcov.Instr;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.MalformedURLException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.io.File.pathSeparator;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+public class InstrProxy {\n+    private final Path outputDir;\n+\n+    public InstrProxy(Path outputDir) {\n+        this.outputDir = outputDir;\n+    }\n+\n+    public void copyBytecode(String... classes) throws IOException {\n+        byte[] buf = new byte[1024];\n+        for(String c : classes) {\n+            String classFile = classFile(c);\n+            try(InputStream in = InstrProxy.class.getClassLoader().getResourceAsStream(classFile)) {\n+                Path o = outputDir.resolve(classFile);\n+                if(!Files.exists(o.getParent())) Files.createDirectories(o.getParent());\n+                try(OutputStream out = Files.newOutputStream(o)) {\n+                    int read;\n+                    while((read = in.read(buf)) > 0)\n+                        out.write(buf, 0, read);\n+                }\n+            }\n+        };\n+    }\n+\n+    public int instr(String[] options, Consumer<String> outConsumer, Consumer<String> errConsumer, String... classes) throws IOException, InterruptedException {\n+        if(!Files.exists(outputDir) || !Files.isDirectory(outputDir)) {\n+            Files.createDirectories(outputDir);\n+        }\n+        \/\/this does not work because\n+        \/\/Warning: Add input source(s) to the classpath: -cp jcov.jar:...\n+\/\/        List<String> params = new ArrayList<>();\n+\/\/        params.addAll(List.of(options));\n+\/\/        params.addAll(Arrays.stream(classes).map(c -> outputDir.resolve(classFile(c)).toString()).collect(toList()));\n+\/\/        System.out.println(params.stream().collect(Collectors.joining(\" \")));\n+\/\/        new Instr().run(params.toArray(new String[0]));\n+        List<String> files = Arrays.stream(classes).map(this::classFile)\n+                .map(outputDir::resolve)\n+                .map(Path::toString)\n+                .collect(toList());\n+        List<String> command = new ArrayList<>();\n+        command.add(System.getProperty(\"java.home\") + \"\/bin\/java\");\n+        command.add(\"-Djcov.selftest=true\");\n+        command.add(\"-Djcov.stacktrace=true\");\n+        command.add(\"-cp\");\n+        command.add(System.getProperty(\"java.class.path\") +\n+                        pathSeparator + files.stream()\n+                        .collect(joining(pathSeparator)));\n+        command.add(Instr.class.getName());\n+        command.addAll(Arrays.asList(options));\n+        command.addAll(files);\n+        System.out.println(command.stream().collect(joining(\" \")));\n+        ProcessBuilder pb = new ProcessBuilder().command(command.toArray(new String[0]));\n+        if(outConsumer == null)\n+            pb = pb.redirectOutput(ProcessBuilder.Redirect.INHERIT);\n+        if(errConsumer == null)\n+            pb = pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        Process p = pb.start();\n+        if(outConsumer != null) {\n+            try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+                String line;\n+                while((line = in.readLine()) != null)\n+                    outConsumer.accept(line);\n+            }\n+        }\n+        if(errConsumer != null) {\n+            try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getErrorStream()))) {\n+                String line;\n+                while((line = in.readLine()) != null)\n+                    errConsumer.accept(line);\n+            }\n+        }\n+        return p.waitFor();\n+    }\n+\n+    public String classFile(String className) {\n+        return className.replace('.', '\/') + \".class\";\n+    }\n+\n+    public Class runClass(String className, String[] argv)\n+            throws ClassNotFoundException, NoSuchMethodException,\n+            InvocationTargetException, IllegalAccessException {\n+        ClassLoader offOutputDir = new InstrumentedClassLoader();\n+        Class cls = offOutputDir.loadClass(className);\n+        Method m = cls.getMethod(\"main\", new String[0].getClass());\n+        m.invoke(null, (Object)argv);\n+        return cls;\n+    }\n+\n+    private class InstrumentedClassLoader extends ClassLoader {\n+        protected InstrumentedClassLoader() {\n+            super(InstrProxy.class.getClassLoader());\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            Path classFile = outputDir.resolve(classFile(name));\n+            if(Files.exists(classFile)) {\n+                byte[] buf = new byte[1024];\n+                try(InputStream in = Files.newInputStream(classFile)) {\n+                    try(ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                        int read;\n+                        while((read = in.read(buf)) > 0)\n+                            out.write(buf, 0, read);\n+                        return defineClass(name, out.toByteArray(), 0, out.size());\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return super.loadClass(name);\n+        }\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/lib\/InstrProxy.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"}]}