{"files":[{"patch":"@@ -344,0 +344,3 @@\n+        <copy todir=\"${result.dir}\/test\/classes\">\n+            <fileset dir=\"${test.src.dir}\" includes=\"**\/*.xml\"\/>\n+        <\/copy>\n","filename":"build\/build.xml","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n@@ -60,1 +60,1 @@\n-public class Plugin implements InstrumentationPlugin {\n+public class Plugin implements ASMInstrumentationPlugin {\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/instrument\/Plugin.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -20,0 +20,1 @@\n+import java.util.Arrays;\n@@ -54,0 +55,2 @@\n+        String runtime = Arrays.stream(System.getProperty(\"java.class.path\").split(File.pathSeparator))\n+                .filter(s -> s.endsWith(\"jcov_file_saver.jar\")).findAny().get();\n@@ -61,1 +64,1 @@\n-                .jcovRuntime(System.getProperty(\"jcov.file.saver.jar\"))\n+                .jcovRuntime(runtime)\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Test.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n@@ -8,1 +8,1 @@\n-public class VoidPlugin implements InstrumentationPlugin {\n+public class VoidPlugin implements ASMInstrumentationPlugin {\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/VoidPlugin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Agent.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -359,1 +358,1 @@\n-     * @param saveAtReceive true = save data when it's coming from Client\n+     * @param saveAtRecieve true = save data when it's coming from Client\n@@ -699,1 +698,1 @@\n-     * @param data received clients data to handle\n+     * @param root received clients data to handle\n@@ -833,1 +832,1 @@\n-                                    if ((dm.isAbstract() || (dm.getAccess() & Opcodes.ACC_NATIVE) != 0)\n+                                    if ((dm.getModifiers().isAbstract() || dm.getModifiers().isNative())\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Grabber.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.tdk.jcov.instrument.ClassMorph;\n@@ -30,0 +29,2 @@\n+import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n@@ -31,0 +32,1 @@\n+import com.sun.tdk.jcov.runtime.FileSaver;\n@@ -37,0 +39,2 @@\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n@@ -38,0 +42,1 @@\n+import java.io.UncheckedIOException;\n@@ -39,0 +44,1 @@\n+import java.nio.file.Files;\n@@ -40,0 +46,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -42,0 +50,1 @@\n+import java.util.stream.Collectors;\n@@ -87,1 +96,2 @@\n-    private InstrumentationPlugin plugin;\n+    private InstrumentationPlugin plugin = new ASMInstrumentationPlugin();\n+    private InstrumentationParams params;\n@@ -94,0 +104,6 @@\n+    private boolean needToFixJavaBase = false;\n+\n+    public void fixJavaBase() {\n+        needToFixJavaBase = true;\n+    }\n+\n@@ -176,0 +192,21 @@\n+            if(needToFixJavaBase && \"java.base\".equals(moduleName)) {\n+                File moduleInfo = new File(file + File.separator +  \"module-info.class\");\n+                if(!moduleInfo.exists()) throw new IllegalStateException(moduleInfo + \" does not exist!\");\n+                try(FileInputStream fi = new FileInputStream(moduleInfo)) {\n+                    byte[] noHashes = morph.clearHashes(fi.readAllBytes(), cl);\n+                    List<String> packages = new ArrayList<>();\n+                    packages.add(\"com\/sun\/tdk\/jcov\/runtime\");\n+\/\/                    if(plugin != null) {\n+\/\/                        String pluginRuntimePackage = plugin.collectorPackage();\n+\/\/                        if (pluginRuntimePackage != null) {\n+\/\/                            pluginRuntimePackage = pluginRuntimePackage.replace('.', '\/');\n+\/\/                            packages.add(pluginRuntimePackage);\n+\/\/                        }\n+\/\/                    }\n+                    byte[] withExports = morph.addExports(noHashes, packages, cl);\n+                    try (FileOutputStream fo = new FileOutputStream(((outDir == null) ? file : outDir) +\n+                            File.separator +  \"module-info.class\")) {\n+                        fo.write(withExports);\n+                    }\n+                }\n+            }\n@@ -207,1 +244,2 @@\n-    public void instrumentFiles(String[] files, File outDir, String implantRT) throws IOException {\n+    public void instrumentFiles(String[] files, File outDir, String implantRT) throws Exception {\n+        \/\/TODO rename\n@@ -210,1 +248,23 @@\n-            instrumenter.instrument(new File(file), outDir, implantRT, recurse);\n+            Path in = Path.of(file);\n+            Path out = (outDir != null) ? outDir.toPath() : in;\n+            List<String> classes = Files.find(in, Integer.MAX_VALUE,\n+                            (f, a) -> f.getFileName().toString().endsWith(\".class\"))\n+                    .map(f -> in.relativize(f))\n+                    .map(Path::toString)\n+                    .map(s -> s.substring(0, s.length() - \".class\".length()))\n+                    .collect(Collectors.toList());\n+            params.isIncluded(\"UserCode\");\n+            plugin.instrument(classes, f -> {\n+\/\/            params.filter(plugin).instrument(classes, f -> {\n+                try {\n+                    return Files.readAllBytes(in.resolve(f + \".class\"));\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }, (c, d) -> {\n+                try {\n+                    Files.write(out.resolve(c + \".class\"), d);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }, params);\n@@ -239,3 +299,2 @@\n-\n-        if (morph == null) {\n-            InstrumentationParams params = new InstrumentationParams(innerinvocations,\n+        if(params == null) {\n+            params = new InstrumentationParams(innerinvocations,\n@@ -263,0 +322,2 @@\n+        }\n+        if (morph == null) {\n@@ -283,1 +344,1 @@\n-                public void processClassFileInModules(Path filePath, File outDir){\n+                 public void processClassFileInModules(Path filePath, File outDir){\n@@ -296,1 +357,0 @@\n-\n@@ -298,0 +358,1 @@\n+            instrumenter.setParams(params);\n@@ -306,3 +367,3 @@\n-    public void setInstrumenter(AbstractUniversalInstrumenter instrumenter) {\n-        this.instrumenter = instrumenter;\n-    }\n+\/\/    public void setInstrumenter(AbstractUniversalInstrumenter instrumenter) {\n+\/\/        this.instrumenter = instrumenter;\n+\/\/    }\n@@ -316,2 +377,2 @@\n-        if (instrumenter != null) {\n-            instrumenter.finishWork();\n+\/\/        if (instrumenter != null) {\n+\/\/            instrumenter.finishWork();\n@@ -319,2 +380,2 @@\n-        }\n-        if(plugin != null) plugin.instrumentationComplete();\n+\/\/        }\n+\/\/        if(plugin != null) plugin.instrumentationComplete();\n@@ -330,5 +391,13 @@\n-        if (instrumenter != null) {\n-            if (subsequentInstr) {\n-                morph.saveData(outTemplate, MERGE.MERGE); \/\/ template should be initialized\n-            } else {\n-                morph.saveData(outTemplate, null, MERGE.OVERWRITE); \/\/ template should be initialized\n+\/\/        if (instrumenter != null) {\n+\/\/            if (subsequentInstr) {\n+\/\/                morph.saveData(outTemplate, MERGE.MERGE); \/\/ template should be initialized\n+\/\/            } else {\n+\/\/                morph.saveData(outTemplate, null, MERGE.OVERWRITE); \/\/ template should be initialized\n+\/\/            }\n+\/\/        }\n+\/\/        if(plugin != null) plugin.instrumentationComplete();\n+        plugin.complete(() -> {\n+            try {\n+                return Files.newOutputStream(Path.of(template));\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n@@ -336,2 +405,1 @@\n-        }\n-        if(plugin != null) plugin.instrumentationComplete();\n+        });\n@@ -707,0 +775,1 @@\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":93,"deletions":24,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import com.sun.tdk.jcov.instrument.ClassMorph;\n-import com.sun.tdk.jcov.instrument.ClassMorph2;\n+import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n+import com.sun.tdk.jcov.instrument.asm.ClassMorph2;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.tdk.jcov.instrument.OverriddenClassWriter;\n@@ -34,1 +33,0 @@\n-import org.objectweb.asm.*;\n@@ -41,1 +39,0 @@\n-import java.util.Collections;\n@@ -44,1 +41,0 @@\n-import java.util.function.Function;\n@@ -112,0 +108,2 @@\n+        instr.fixJavaBase();\n+\n@@ -134,5 +132,0 @@\n-                        if (\"java.base\".equals(mod.getName())) {\n-                            File mInfo = new File(modClasses, \"module-info.class\");\n-                            addJCovRuntimeToJavaBase(mInfo, cl);\n-                            updateHashes(mInfo, cl);\n-                        }\n@@ -140,3 +133,1 @@\n-                        createJMod(mod, jdk, implant.getAbsolutePath(),\n-                                (instr.getPlugin() != null && instr.getPlugin().runtime() != null) ?\n-                                    instr.getPlugin().runtime().toString() : null);\n+                        createJMod(mod, jdk, implant.getAbsolutePath(), null);\n@@ -145,1 +136,0 @@\n-\n@@ -179,59 +169,60 @@\n-            ArrayList<File> jdkImages = new ArrayList<>();\n-            jdkImages.add(toInstrument);\n-            if (addJimages != null) {\n-                Collections.addAll(jdkImages, addJimages);\n-            }\n-\n-            for (File jimageInstr : jdkImages) {\n-                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n-\n-                expandJimage(jimageInstr, tempDirName);\n-\n-                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n-                \/\/still need it\n-                Utils.addToClasspath(new String[]{dirtoInstrument.getAbsolutePath()});\n-                for (File file : getListFiles(dirtoInstrument)) {\n-                    if (file.isDirectory()) {\n-                        Utils.addToClasspath(new String[]{file.getAbsolutePath()});\n-                    }\n-                }\n-\n-                if (jimageInstr.equals(toInstrument)) {\n-                    for (File mod : getListFiles(dirtoInstrument)) {\n-                        if (mod != null && mod.isDirectory()) {\n-\n-                            if (\"java.base\".equals(mod.getName())) {\n-                                instr.instrumentFile(mod.getAbsolutePath(), null, implant.getAbsolutePath(), mod.getName());\n-                            } else {\n-                                instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    for (File mod : getListFiles(dirtoInstrument)) {\n-                        if (mod != null && mod.isDirectory()) {\n-                            instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n-                        }\n-                    }\n-                }\n-                createJimage(dirtoInstrument, jimageInstr.getAbsolutePath() + \"i\");\n-\n-            }\n-            for (File jimageInstr : jdkImages) {\n-\n-                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n-                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n-                if (!Utils.deleteDirectory(dirtoInstrument)) {\n-                    logger.log(Level.SEVERE, \"please, delete \" + tempDirName + \" jimage dir manually\");\n-                }\n-\n-                Utils.copyFile(jimageInstr, new File(jimageInstr.getParent(), jimageInstr.getName() + \".bak\"));\n-\n-                if (!jimageInstr.delete()) {\n-                    logger.log(Level.SEVERE, \"please, delete original jimage manually: \" + jimageInstr);\n-                } else {\n-                    Utils.copyFile(new File(jimageInstr.getAbsolutePath() + \"i\"), jimageInstr);\n-                    new File(jimageInstr.getAbsolutePath() + \"i\").delete();\n-                }\n-\n-            }\n+            throw new RuntimeException(\"This functionality has not yet been implemented\");\n+\/\/            ArrayList<File> jdkImages = new ArrayList<>();\n+\/\/            jdkImages.add(toInstrument);\n+\/\/            if (addJimages != null) {\n+\/\/                Collections.addAll(jdkImages, addJimages);\n+\/\/            }\n+\/\/\n+\/\/            for (File jimageInstr : jdkImages) {\n+\/\/                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n+\/\/\n+\/\/                expandJimage(jimageInstr, tempDirName);\n+\/\/\n+\/\/                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n+\/\/\/\/                still need it\n+\/\/                Utils.addToClasspath(new String[]{dirtoInstrument.getAbsolutePath()});\n+\/\/                for (File file : getListFiles(dirtoInstrument)) {\n+\/\/                    if (file.isDirectory()) {\n+\/\/                        Utils.addToClasspath(new String[]{file.getAbsolutePath()});\n+\/\/                    }\n+\/\/                }\n+\/\/\n+\/\/                if (jimageInstr.equals(toInstrument)) {\n+\/\/                    for (File mod : getListFiles(dirtoInstrument)) {\n+\/\/                        if (mod != null && mod.isDirectory()) {\n+\/\/\n+\/\/                            if (\"java.base\".equals(mod.getName())) {\n+\/\/                                instr.instrumentFile(mod.getAbsolutePath(), null, implant.getAbsolutePath(), mod.getName());\n+\/\/                            } else {\n+\/\/                                instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n+\/\/                            }\n+\/\/                        }\n+\/\/                    }\n+\/\/                } else {\n+\/\/                    for (File mod : getListFiles(dirtoInstrument)) {\n+\/\/                        if (mod != null && mod.isDirectory()) {\n+\/\/                            instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n+\/\/                        }\n+\/\/                    }\n+\/\/                }\n+\/\/                createJimage(dirtoInstrument, jimageInstr.getAbsolutePath() + \"i\");\n+\n+\/\/            }\n+\/\/            for (File jimageInstr : jdkImages) {\n+\/\/\n+\/\/                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n+\/\/                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n+\/\/                if (!Utils.deleteDirectory(dirtoInstrument)) {\n+\/\/                    logger.log(Level.SEVERE, \"please, delete \" + tempDirName + \" jimage dir manually\");\n+\/\/                }\n+\/\/\n+\/\/                Utils.copyFile(jimageInstr, new File(jimageInstr.getParent(), jimageInstr.getName() + \".bak\"));\n+\/\/\n+\/\/                if (!jimageInstr.delete()) {\n+\/\/                    logger.log(Level.SEVERE, \"please, delete original jimage manually: \" + jimageInstr);\n+\/\/                } else {\n+\/\/                    Utils.copyFile(new File(jimageInstr.getAbsolutePath() + \"i\"), jimageInstr);\n+\/\/                    new File(jimageInstr.getAbsolutePath() + \"i\").delete();\n+\/\/                }\n+\/\/\n+\/\/            }\n@@ -240,1 +231,2 @@\n-            instr.instrumentFile(toInstrument.getAbsolutePath(), null, implant.getAbsolutePath());\n+            throw new RuntimeException(\"This functionality has not yet been implemented\");\n+\/\/            instr.instrumentFile(toInstrument.getAbsolutePath(), null, implant.getAbsolutePath());\n@@ -265,2 +257,0 @@\n-        return SUCCESS_EXIT_CODE;\n-    }\n@@ -268,63 +258,1 @@\n-    \/**\n-     * Add com\/sun\/tdk\/jcov\/runtime to the module exports to be visible externally\n-     *\n-     * @param file  module-info.class file of java.base\n-     * @param cl    class loader\n-     *\/\n-    private void addJCovRuntimeToJavaBase(File file, ClassLoader cl) {\n-        try {\n-            updateModuleInfoFile(file, cl, classWriter ->\n-                    new ClassVisitor(Utils.ASM_API_VERSION, classWriter) {\n-                        @Override\n-                        public ModuleVisitor visitModule(String name, int access, String version) {\n-                            ModuleVisitor mv = super.visitModule(name, access, version);\n-                            mv.visitPackage(\"com\/sun\/tdk\/jcov\/runtime\");\n-                            mv.visitExport(\"com\/sun\/tdk\/jcov\/runtime\", 0);\n-                            if(instr.getPlugin() != null) {\n-                                String pluginRuntimePackage = instr.getPlugin().collectorPackage();\n-                                if(pluginRuntimePackage != null) {\n-                                    pluginRuntimePackage = pluginRuntimePackage.replace('.', '\/');\n-                                    mv.visitPackage(pluginRuntimePackage);\n-                                    mv.visitExport(pluginRuntimePackage, 0);\n-                                }\n-                            }\n-                            return mv;\n-                        }\n-                    });\n-        } catch (Exception ex) {\n-            logger.log(Level.SEVERE, \"Can't update java.base\/module-info\", ex);\n-        }\n-    }\n-\n-    \/**\n-     * Remove ModuleHashes attribute to skip a check that there are no qualified exports to upgradeable modules\n-     *\n-     * @param file  module-info.class file of java.base\n-     * @param cl    class loader\n-     *\/\n-    private void updateHashes(File file, ClassLoader cl) {\n-        try {\n-            updateModuleInfoFile(file, cl, classWriter ->\n-                    new ClassVisitor(Utils.ASM_API_VERSION, classWriter) {\n-                        @Override\n-                        public void visitAttribute(final Attribute attribute) {\n-                            if (!attribute.type.equals(\"ModuleHashes\")) {\n-                                super.visitAttribute(attribute);\n-                            }\n-                        }\n-                    });\n-        } catch (Exception ex) {\n-            logger.log(Level.SEVERE, \"Can't remove module hashes from java.base\/module-info\", ex);\n-        }\n-    }\n-\n-    private void updateModuleInfoFile(File file, ClassLoader cl, Function<ClassWriter, ClassVisitor> func) throws Exception {\n-        try( InputStream inputStream = new FileInputStream(file.getCanonicalPath()) ) {\n-            ClassReader cr = new ClassReader(inputStream);\n-            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, cl);\n-            cr.accept(func.apply(cw), 0);\n-            try(DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(file.getCanonicalPath())) ) {\n-                outputStream.write(cw.toByteArray());\n-                outputStream.flush();\n-            }\n-        }\n+        return SUCCESS_EXIT_CODE;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/JREInstr.java","additions":67,"deletions":139,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import com.sun.tdk.jcov.instrument.ClassMorph;\n+import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n@@ -71,1 +71,1 @@\n-    public void instrumentProduct() throws IOException {\n+    public void instrumentProduct() throws Exception {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/ProductInstr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -822,1 +821,1 @@\n-            ancMethod = ((m.getAccess() & Opcodes.ACC_SYNTHETIC) != 0);\n+            ancMethod = m.getModifiers().isSynthetic();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/RepGen.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.tdk.jcov.instrument.ClassMorph;\n+import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n@@ -37,1 +37,0 @@\n-import java.io.FileNotFoundException;\n@@ -40,1 +39,0 @@\n-import java.util.*;\n@@ -129,1 +127,1 @@\n-    public void generateAndSave(String[] files) throws IOException {\n+    public void generateAndSave(String[] files) throws Exception {\n@@ -199,1 +197,1 @@\n-    public void finishWork() {\n+    public void finishWork() throws Exception {\n@@ -209,19 +207,21 @@\n-            instrumenter = new AbstractUniversalInstrumenter(true, true) {\n-                ClassMorph morph = new ClassMorph(\n-                        new InstrumentationParams(instrumentNative, instrumentField, instrumentAbstract, include, exclude, m_include, m_exclude, mode)\n-                        .setInstrumentAnonymous(instrumentAnonymous)\n-                        .setInstrumentSynthetic(instrumentSynthetic), template);\n-\n-                protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n-\/\/                    byte[] res = Arrays.copyOf(classData, classLen);\n-                    byte[] res = new byte[classLen];\n-                    System.arraycopy(classData, 0, res, 0, classLen);\n-                    morph.setCurrentModuleName(currentModule);\n-                    morph.morph(res, null, flushPath); \/\/ jdk1.5 support\n-                    return res;\n-                }\n-\n-                public void finishWork() {\n-                    morph.saveData(template, InstrumentationOptions.MERGE.MERGE);\n-                }\n-            };\n+            \/\/TODO\n+            instrumenter = null;\n+\/\/            instrumenter = new AbstractUniversalInstrumenter(true, true, plugin) {\n+\/\/                ClassMorph morph = new ClassMorph(\n+\/\/                        new InstrumentationParams(instrumentNative, instrumentField, instrumentAbstract, include, exclude, m_include, m_exclude, mode)\n+\/\/                        .setInstrumentAnonymous(instrumentAnonymous)\n+\/\/                        .setInstrumentSynthetic(instrumentSynthetic), template);\n+\/\/\n+\/\/                protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n+\/\/\/\/                    byte[] res = Arrays.copyOf(classData, classLen);\n+\/\/                    byte[] res = new byte[classLen];\n+\/\/                    System.arraycopy(classData, 0, res, 0, classLen);\n+\/\/                    morph.setCurrentModuleName(currentModule);\n+\/\/                    morph.morph(res, null, flushPath); \/\/ jdk1.5 support\n+\/\/                    return res;\n+\/\/                }\n+\/\/\n+\/\/                public void finishWork() {\n+\/\/                    morph.saveData(template, InstrumentationOptions.MERGE.MERGE);\n+\/\/                }\n+\/\/            };\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/TmplGen.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,4 @@\n-import com.sun.tdk.jcov.instrument.OverriddenClassWriter;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.OverriddenClassWriter;\n@@ -37,0 +40,1 @@\n+import java.io.UncheckedIOException;\n@@ -42,0 +46,1 @@\n+import java.util.List;\n@@ -44,0 +49,1 @@\n+import java.util.stream.Collectors;\n@@ -55,0 +61,4 @@\n+ * The class is resposible to deal with class files and hierarchies of files, such as directories, jars, zips, modules.\n+ * The actual logic of bytecode instrumentation is left for subclasses of this class.\n+ * @see #instrument(byte[], int)\n+ * @see #finishWork()\n@@ -67,0 +77,3 @@\n+    private InstrumentationPlugin plugin = new ASMInstrumentationPlugin();\n+    private InstrumentationParams params;\n+\n@@ -101,0 +114,4 @@\n+    public void setParams(InstrumentationParams params) {\n+        this.params = params;\n+    }\n+\n@@ -560,3 +577,3 @@\n-        fileCount = 0;\n-        classCount = 0;\n-        iClassCount = 0;\n+\/\/        fileCount = 0;\n+\/\/        classCount = 0;\n+\/\/        iClassCount = 0;\n@@ -573,19 +590,13 @@\n-            if (recursive) {\n-\n-                Utils.addToClasspath(instrumentingPath);\n-\n-                logger.log(Level.FINE, \"Scanning directory ''{0}''...\", instrumentingPath);\n-                File[] entries = instrumentingPath.listFiles();\n-                Arrays.sort(entries);\n-                for (int i = 0; i < entries.length; i++) {\n-                    destinationPath.mkdir();\n-                    instrument(entries[i], new File(destinationPath, entries[i].getName()), rtPath, rtClassDirTargets, recursive);\n-                }\n-            } else {\n-                logger.log(Level.INFO, \"Instrumenting directory ''{0}''...\", instrumentingPath);\n-                processClassDir(instrumentingPath, destinationPath);\n-                if (rtPath != null) {\n-                    if (destinationPath != null) {\n-                        unjarRT(rtPath, destinationPath);\n-                    } else {\n-                        unjarRT(rtPath, instrumentingPath);\n+            Path in = Path.of(instrumentingPath.getAbsolutePath());\n+            Path out = Path.of(destinationPath.getAbsolutePath());\n+            List<String> classes = Files.find(in, Integer.MAX_VALUE,\n+                            (f, a) -> f.getFileName().toString().endsWith(\".class\"))\n+                    .map(f -> in.relativize(f))\n+                    .map(Path::toString)\n+                    .collect(Collectors.toList());\n+            try {\n+                plugin.instrument(classes, f -> {\n+                    try {\n+                        return Files.readAllBytes(in.resolve(f));\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n@@ -593,1 +604,9 @@\n-                }\n+                }, (c, d) -> {\n+                    try {\n+                        Files.write(out.resolve(c), d);\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }, params);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n@@ -595,0 +614,23 @@\n+            \/\/TODO what about recursive?\n+\/\/            if (recursive) {\n+\/\/\n+\/\/                Utils.addToClasspath(instrumentingPath);\n+\/\/\n+\/\/                logger.log(Level.FINE, \"Scanning directory ''{0}''...\", instrumentingPath);\n+\/\/                File[] entries = instrumentingPath.listFiles();\n+\/\/                Arrays.sort(entries);\n+\/\/                for (int i = 0; i < entries.length; i++) {\n+\/\/                    destinationPath.mkdir();\n+\/\/                    instrument(entries[i], new File(destinationPath, entries[i].getName()), rtPath, rtClassDirTargets, recursive);\n+\/\/                }\n+\/\/            } else {\n+\/\/                logger.log(Level.INFO, \"Instrumenting directory ''{0}''...\", instrumentingPath);\n+\/\/                processClassDir(instrumentingPath, destinationPath);\n+\/\/                if (rtPath != null) {\n+\/\/                    if (destinationPath != null) {\n+\/\/                        unjarRT(rtPath, destinationPath);\n+\/\/                    } else {\n+\/\/                        unjarRT(rtPath, instrumentingPath);\n+\/\/                    }\n+\/\/                }\n+\/\/            }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/insert\/AbstractUniversalInstrumenter.java","additions":66,"deletions":24,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+\n@@ -31,3 +32,0 @@\n-import java.util.Set;\n-import java.util.Map;\n-import java.util.IdentityHashMap;\n@@ -35,1 +33,2 @@\n-\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n@@ -37,1 +36,1 @@\n-import org.objectweb.asm.tree.LabelNode;\n+import java.util.Set;\n@@ -56,1 +55,1 @@\n-    public final Map<DataBlock, LabelNode> blockMap;\n+    private final Set<DataBlock> blocks;\n@@ -62,1 +61,1 @@\n-    BasicBlock(int rootId, int startBCI) {\n+    public BasicBlock(int rootId, int startBCI) {\n@@ -64,1 +63,1 @@\n-        blockMap = new IdentityHashMap<DataBlock, LabelNode>();\n+        blocks = Collections.newSetFromMap(new IdentityHashMap<>());\n@@ -72,1 +71,1 @@\n-        blockMap = new IdentityHashMap<DataBlock, LabelNode>();\n+        blocks = Collections.newSetFromMap(new IdentityHashMap<>());\n@@ -79,2 +78,2 @@\n-    void add(DataBlock blk, LabelNode label) {\n-        blockMap.put(blk, label);\n+    public void add(DataBlock blk) {\n+        blocks.add(blk);\n@@ -87,8 +86,0 @@\n-    public void add(DataBlock blk) {\n-        add(blk, null);\n-    }\n-\n-    LabelNode getLabel(DataBlock blk) {\n-        return blockMap.get(blk);\n-    }\n-\n@@ -96,1 +87,1 @@\n-        return blockMap.containsKey(blk);\n+        return blocks.contains(blk);\n@@ -99,1 +90,1 @@\n-    DataBlock fallenInto() {\n+    public DataBlock fallenInto() {\n@@ -107,6 +98,2 @@\n-    Collection<DataBlock> blocks() {\n-        return blockMap.keySet();\n-    }\n-\n-    Set<Map.Entry<DataBlock, LabelNode>> blockLabelSet() {\n-        return blockMap.entrySet();\n+    public Collection<DataBlock> blocks() {\n+        return blocks;\n@@ -133,2 +120,2 @@\n-        if (ctx.showNonNested && blockMap != null) {\/\/BRANCH only\n-            for (DataBlock block : blockMap.keySet()) {\n+        if (ctx.showNonNested && blocks != null) {\/\/BRANCH only\n+            for (DataBlock block : blocks) {\n@@ -146,1 +133,1 @@\n-        if (blockMap.keySet().size() != other.blocks().size()) {\n+        if (blocks.size() != other.blocks().size()) {\n@@ -148,1 +135,1 @@\n-                    + \"it's merging copy, expected \" + blockMap.keySet().size() + \"; found \" + other.blocks().size(),\n+                    + \"it's merging copy, expected \" + blocks.size() + \"; found \" + other.blocks().size(),\n@@ -163,1 +150,1 @@\n-                        + \"it's merging copy, expected \" + blockMap.keySet().size() + \"; found \" + other.blocks().size(),\n+                        + \"it's merging copy, expected \" + blocks.size() + \"; found \" + other.blocks().size(),\n@@ -172,1 +159,1 @@\n-        mergeDataBlocks(blockMap.keySet(), other.blocks(), dynamicCollected);\n+        mergeDataBlocks(blocks, other.blocks(), dynamicCollected);\n@@ -215,1 +202,1 @@\n-                    return blockMap.keySet().iterator();\n+                    return blocks.iterator();\n@@ -279,1 +266,1 @@\n-        blockMap = new IdentityHashMap<DataBlock, LabelNode>(blockNum);\n+        blocks = Collections.newSetFromMap(new IdentityHashMap<>());\n@@ -285,1 +272,1 @@\n-                    blockMap.put(new DataBlockCatch(rootId, in), null);\n+                    blocks.add(new DataBlockCatch(rootId, in));\n@@ -288,1 +275,1 @@\n-                    blockMap.put(new DataBlockFallThrough(rootId, in), null);\n+                    blocks.add(new DataBlockFallThrough(rootId, in));\n@@ -291,1 +278,1 @@\n-                    blockMap.put(new DataBlockMethEnter(rootId, in), null);\n+                    blocks.add(new DataBlockMethEnter(rootId, in));\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/BasicBlock.java","additions":26,"deletions":39,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1,589 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov.instrument;\n-\n-import com.sun.tdk.jcov.instrument.CharacterRangeTableAttribute.CRTEntry;\n-import java.util.*;\n-\n-import static org.objectweb.asm.Opcodes.*;\n-\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Attribute;\n-\n-import org.objectweb.asm.tree.*;\n-import static org.objectweb.asm.tree.AbstractInsnNode.*;\n-\n-\/**\n- * @author Dmitry Fazunenko\n- * @author Alexey Fedorchenko\n- *\/\n-class BranchCodeMethodAdapter extends OffsetRecordingMethodAdapter {\n-\n-    private final MethodVisitor nextVisitor;\n-    private final List<DataExit> exits;\n-    private final List<DataBlock> src;\n-    private final Map<AbstractInsnNode, BasicBlock> insnToBB;\n-    private final InstrumentationParams params;\n-\n-    public BranchCodeMethodAdapter(final MethodVisitor mv,\n-            final DataMethodWithBlocks method, InstrumentationParams params) {\n-        super(new MethodNode(method.getAccess(), method.getName(), method.getVmSignature(), method.getSignature(), method.getExceptions()),\n-                method);\n-        this.nextVisitor = mv;\n-        this.insnToBB = new IdentityHashMap<AbstractInsnNode, BasicBlock>();\n-        this.exits = new ArrayList<DataExit>();\n-        this.src = new ArrayList<DataBlock>();\n-        this.params = params;\n-    }\n-\n-    private BasicBlock getBB(AbstractInsnNode insn, int startBCI) {\n-        BasicBlock bb = insnToBB.get(insn);\n-        if (bb == null) {\n-            bb = new BasicBlock(method.rootId, startBCI);\n-            insnToBB.put(insn, bb);\n-        } else if (startBCI >= 0) {\n-            bb.setStartBCI(startBCI);\n-        }\n-        return bb;\n-    }\n-\n-    private BasicBlock getBB(AbstractInsnNode insn) {\n-        return getBB(insn, -1);\n-    }\n-\n-    private AbstractInsnNode peek(ListIterator iit) {\n-        \/\/ Do a next() to get the next instruction..\n-        \/\/ Then immediately do a previous to restore our position.\n-        if (iit.hasNext()) {\n-            AbstractInsnNode insn = (AbstractInsnNode) iit.next();\n-            iit.previous();\n-            return insn;\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Do fix ups so that: There are unique CodeLabelNodes at the beginning of\n-     * each basic block; All branch-mode blocks hang off CodeLabelNodes Misc\n-     * info, like case values, are attached Fall throughs from one block to\n-     * another are computed\n-     *\n-     *\/\n-    private BasicBlock[] completeComputationOfCodeLabelNodes() {\n-        MethodNode methodNode = (MethodNode) mv;\n-        InsnList instructions = methodNode.instructions;\n-        int[] allToReal = new int[instructions.size()];\n-        int allIdx = 0;\n-        int insnIdx = 0;\n-        ListIterator iit = instructions.iterator();\n-\n-        \/\/ Create the method entry block and basic block\n-        AbstractInsnNode insnFirst = peek(iit);\n-        BasicBlock bbFirst = getBB(insnFirst, 0);\n-        DataBlock blockFirst = new DataBlockMethEnter(bbFirst.rootId());\n-        bbFirst.add(blockFirst);\n-\n-        while (iit.hasNext()) {\n-            AbstractInsnNode insn = (AbstractInsnNode) iit.next();\n-            allToReal[allIdx++] = insnIdx;\n-            int bci = bcis[insnIdx];\n-            int opcode = insn.getOpcode();\n-            if (opcode < 0) {\n-                \/\/ a pseudo-instruction\n-                if (insn.getType() == AbstractInsnNode.LINE) {\n-                    LineNumberNode lineNode = (LineNumberNode) insn;\n-                    method().addLineEntry(bci, lineNode.line);\n-                }\n-            } else {\n-                \/\/ a real instruction\n-                ++insnIdx; \/\/ advance the real instruction index\n-\n-                \/\/System.out.println( \"#\" + (insnIdx - 1) +\n-                \/\/        \" bci: \" + bci + \"  \" +\n-                \/\/        instr.toString().replace(\"org.objectweb.asm.tree.\", \"\").replace(\"@\", \" @ \") +\n-                \/\/        \" [\" + (opcode>=0? Constants.opcNames[opcode] : \" pseudo\") +\"]\");\n-                switch (opcode) {\n-                    case IFEQ:\n-                    case IFNE:\n-                    case IFLT:\n-                    case IFGE:\n-                    case IFGT:\n-                    case IFLE:\n-                    case IF_ICMPEQ:\n-                    case IF_ICMPNE:\n-                    case IF_ICMPLT:\n-                    case IF_ICMPGE:\n-                    case IF_ICMPGT:\n-                    case IF_ICMPLE:\n-                    case IF_ACMPEQ:\n-                    case IF_ACMPNE:\n-                    case IFNULL:\n-                    case IFNONNULL: \/\/case JSR:\n-                    {\n-                        JumpInsnNode jumpInsn = (JumpInsnNode) insn;\n-                        LabelNode insnTrue = jumpInsn.label;\n-                        int bciFalse = bcis[insnIdx]; \/\/ fall-through\n-\n-                        DataBranchCond branch = new DataBranchCond(method.rootId, bci, bciFalse - 1);\n-                        DataBlockTarget blockTrue = new DataBlockTargetCond(branch.rootId(), true);\n-                        DataBlockTarget blockFalse = new DataBlockTargetCond(branch.rootId(), false);\n-                        branch.addTarget(blockTrue);\n-                        branch.addTarget(blockFalse);\n-\n-                        AbstractInsnNode insnFalse = peek(iit);\n-                        assert (insnFalse != null); \/\/ must be fall-through code\n-                        BasicBlock bbTrue = getBB(insnTrue);\n-                        BasicBlock bbFalse = getBB(insnFalse, bciFalse);\n-\n-                        exits.add(branch);\n-\n-                        \/\/ assign a new label for branch counting\n-                        LabelNode nlab = new LabelNode();\n-                        jumpInsn.label = nlab;  \/\/ branch to new label\n-                        bbTrue.add(blockTrue, nlab);\n-\n-                        bbFalse.add(blockFalse);\n-                        break;\n-                    }\n-\n-                    case TABLESWITCH: {\n-                        TableSwitchInsnNode switchInsn = (TableSwitchInsnNode) insn;\n-\n-                        \/\/ Create a block and basic-block the \"default:\" case\n-                        LabelNode insnDflt = switchInsn.dflt;\n-                        BasicBlock bbDefault = getBB(insnDflt);\n-                        DataBlockTargetDefault blockDefault = new DataBlockTargetDefault(bbDefault.rootId());\n-\n-                        \/\/ assign a new default label for branch counting\n-                        LabelNode nlab = new LabelNode();\n-                        switchInsn.dflt = nlab;  \/\/ branch to new label\n-                        bbDefault.add(blockDefault, nlab);\n-\n-                        \/\/ Create the branch information\n-                        int bciEnd = bcis[insnIdx] - 1; \/\/ end of the switch\n-                        DataBranchSwitch branch = new DataBranchSwitch(method.rootId, bci, bciEnd, blockDefault);\n-                        branch.addTarget(blockDefault);\n-                        exits.add(branch);\n-\n-                        \/\/ Process the other cases\n-                        ListIterator lit = switchInsn.labels.listIterator();\n-                        int key = switchInsn.min;\n-                        while (lit.hasNext()) {\n-                            \/\/ Create a block and basic-block the case\n-                            LabelNode labCase = (LabelNode) lit.next();\n-                            BasicBlock bbCase = getBB(labCase);\n-                            DataBlockTargetCase blockCase = new DataBlockTargetCase(bbCase.rootId(), key++);\n-                            branch.addTarget(blockCase);\n-\n-                            \/\/ assign a new label to the case for branch counting\n-                            nlab = new LabelNode();\n-                            lit.set(nlab);\n-                            bbCase.add(blockCase, nlab);\n-                        }\n-                        break;\n-                    }\n-\n-                    case LOOKUPSWITCH: {\n-                        LookupSwitchInsnNode switchInsn = (LookupSwitchInsnNode) insn;\n-\n-                        \/\/ Create a block and basic-block the \"default:\" case\n-                        LabelNode insnDflt = switchInsn.dflt;\n-                        BasicBlock bbDefault = getBB(insnDflt);\n-                        DataBlockTargetDefault blockDefault = new DataBlockTargetDefault(bbDefault.rootId());\n-\n-                        \/\/ assign a new default label for branch counting\n-                        LabelNode nlab = new LabelNode();\n-                        switchInsn.dflt = nlab;  \/\/ branch to new label\n-                        bbDefault.add(blockDefault, nlab);\n-\n-                        \/\/ Create the branch information\n-                        int bciEnd = bcis[insnIdx] - 1; \/\/ end of the switch\n-                        DataBranchSwitch branch = new DataBranchSwitch(method.rootId, bci, bciEnd, blockDefault);\n-                        branch.addTarget(blockDefault);\n-                        exits.add(branch);\n-\n-                        \/\/ Process the other cases\n-                        ListIterator kit = switchInsn.keys.listIterator();\n-                        ListIterator lit = switchInsn.labels.listIterator();\n-                        while (lit.hasNext()) {\n-                            \/\/ Create a block and basic-block the case\n-                            LabelNode labCase = (LabelNode) lit.next();\n-                            BasicBlock bbCase = getBB(labCase);\n-                            Integer key = (Integer) kit.next();\n-                            DataBlockTargetCase blockCase = new DataBlockTargetCase(branch.rootId(), key.intValue());\n-                            branch.addTarget(blockCase);\n-\n-                            \/\/ assign a new label to the case for branch counting\n-                            nlab = new LabelNode();\n-                            lit.set(nlab);\n-                            bbCase.add(blockCase, nlab);\n-                        }\n-                        break;\n-                    }\n-\n-                    case GOTO: {\n-                        JumpInsnNode jumpInsn = (JumpInsnNode) insn;\n-\n-                        \/\/ Create origin info, a branch\n-                        int bciEnd = bcis[insnIdx] - 1;\n-                        DataBranchGoto branch = new DataBranchGoto(method.rootId, bci, bciEnd);\n-                        exits.add(branch);\n-\n-                        \/\/ Create destination info, a block target\n-                        LabelNode insnTarget = jumpInsn.label;\n-                        BasicBlock bbTarget = getBB(insnTarget);\n-                        DataBlockTarget blockTarget = new DataBlockTargetGoto(bbTarget.rootId());\n-                        branch.addTarget(blockTarget);\n-\n-                        \/\/ assign a new label for branch counting\n-                        LabelNode nlab = new LabelNode();\n-                        jumpInsn.label = nlab;  \/\/ branch to new label\n-                        bbTarget.add(blockTarget, nlab);\n-                        break;\n-                    }\n-                    case ATHROW:\n-                    case RET:\n-                    case IRETURN:\n-                    case LRETURN:\n-                    case FRETURN:\n-                    case DRETURN:\n-                    case ARETURN:\n-                    case RETURN: {\n-                        int bciNext = bcis[insnIdx];\n-                        DataExit exit = new DataExitSimple(method.rootId, bci, bciNext - 1, insn.getOpcode());\n-                        exits.add(exit);\n-\n-                        AbstractInsnNode insnNext = peek(iit);\n-                        if (insnNext != null) {\n-                            \/\/ If there is code after this, it has to be the start of a\n-                            \/\/ new basic block\n-                            getBB(insnNext, bciNext);\n-                        }\n-                        break;\n-                    }\n-                    default:\n-                        break;\n-                }\n-                \/\/ try add src block\n-            }\n-        }\n-\n-        \/\/ Now go through the try-catch blocks\n-        LabelNode previousHandler = null;\n-        for (Iterator tbit = methodNode.tryCatchBlocks.iterator(); tbit.hasNext();) {\n-            TryCatchBlockNode tcbn = (TryCatchBlockNode) tbit.next();\n-            LabelNode insnHandler = tcbn.handler;\n-            if (insnHandler != previousHandler) {\n-                previousHandler = insnHandler;\n-\n-                \/\/ Create destination info, a block target\n-                BasicBlock bbCatch = getBB(insnHandler);\n-                DataBlockCatch blockCatch = new DataBlockCatch(bbCatch.rootId());\n-\n-                \/\/ assign a new label for catch counting\n-                LabelNode nlab = new LabelNode();\n-                tcbn.handler = nlab;  \/\/ change handler\n-                bbCatch.add(blockCatch, nlab);\n-            }\n-        }\n-        if (method().getCharacterRangeTable() != null) {\n-            boolean newBlock = true;\n-            int skip = 0;\n-            iit = instructions.iterator();\n-            while (iit.hasNext()) {\n-                AbstractInsnNode insn = (AbstractInsnNode) iit.next();\n-                int index = instructions.indexOf(insn);\n-                int bci = bcis[allToReal[index]];\n-                if (bci == skip) {\n-                    continue;\n-                }\n-\n-                if (insnToBB.get(insn) != null) {\n-                    skip = bcis[allToReal[ instructions.indexOf(insn)]];\n-                }\n-\n-                if (insn.getOpcode() < 0) {\n-                    continue;\n-                }\n-\n-                for (CharacterRangeTableAttribute.CRTEntry entry : method().getCharacterRangeTable().getEntries()) {\n-                    if (entry.startBCI() == bci) {\n-\n-                        if ((entry.flags & CRTEntry.CRT_STATEMENT) != 0 \/*& newBlock*\/) {\n-                            newBlock = false;\n-                            if (insnToBB.get(insn) == null) {\n-                                \/\/System.out.println(\"Should add block at: \" + bci + \" in \" + method().name +\n-                                \/\/       \" for \" + Constants.opcNames[insn.getOpcode()]);\n-                                getBB(insn);\n-                                break;\n-                            }\n-                        }\n-                    } else {\n-                        if (entry.endBCI() == index && (entry.flags & CRTEntry.CRT_FLOW_TARGET) != 0) {\n-                            newBlock = true;\n-                        }\n-                    }\n-\n-                }\n-            }\n-\n-        }\n-\n-        \/\/ Compute the startBCI for any basic blocks that don't have it'\n-        BasicBlock[] basicBlocks = new BasicBlock[insnToBB.size()];\n-        int i = 0;\n-        for (Map.Entry<AbstractInsnNode, BasicBlock> entry : insnToBB.entrySet()) {\n-            BasicBlock bb = entry.getValue();\n-\n-            if (bb.startBCI() < 0) {\n-                AbstractInsnNode insn = entry.getKey();\n-                int index = instructions.indexOf(insn);\n-                int bci = bcis[allToReal[index]];\n-                bb.setStartBCI(bci);\n-            }\n-            basicBlocks[i++] = bb;\n-        }\n-        Arrays.sort(basicBlocks);\n-\n-        return basicBlocks;\n-    }\n-\n-    \/**\n-     * Compute end BCIs for basic blocks, then set this info into detail blocks.\n-     * Assumes the basic blocks are sorted\n-     *\/\n-    private void computeEndBCIsAndFoldInExits(BasicBlock[] basicBlocks) {\n-        int ei = 0;  \/\/ exit index\n-        BasicBlock prev = basicBlocks[0];\n-        for (int bi = 1; bi <= basicBlocks.length; ++bi) {\n-            BasicBlock curr = null;\n-            int start;\n-            if (bi == basicBlocks.length) {\n-                start = method().getBytecodeLength();\n-            } else {\n-                curr = basicBlocks[bi];\n-                start = curr.startBCI();\n-            }\n-\n-            int prevStart = prev.startBCI();\n-            \/\/ Set the previous block to end just before the current starts\n-            int prevEnd = start - 1;\n-            prev.setEndBCI(prevEnd);\n-\n-            \/\/ Now that we know the endBCI, we can determine if\n-            \/\/ any exits reside in this range\n-            DataExit exit = null;\n-            int exitStart;\n-            if (ei < exits.size()) {\n-                exit = exits.get(ei);\n-                exitStart = exit.startBCI();\n-            } else {\n-                exitStart = -1; \/\/ always go to the fall-into code\n-            }\n-            if (exitStart >= prevStart && exitStart <= prevEnd) {\n-                \/\/ The exit is in the prev block attach it\n-                prev.setExit(exit);\n-                \/\/ System.out.println(\"found \" + ei + \" BB: \" + prev + \" exit: \" + exit);\n-                ++ei;  \/\/ set-up to handle the next exit\n-            } else {\n-                \/\/ There is no exit from the prev block, so we fall\n-                \/\/ into the curr block (if any)\n-                if (curr != null) {\n-                    DataBlock fall = new DataBlockFallThrough(curr.rootId());\n-                    curr.add(fall);\n-                }\n-            }\n-\n-            prev = curr;\n-        }\n-        \/\/ System.out.println(\"ei: \" + ei + \" \/ \" + exits.size());\n-        assert (ei == exits.size());\n-    }\n-\n-    private void insertInstrumentation() {\n-        MethodNode methodNode = (MethodNode) mv;\n-        InsnList instructions = methodNode.instructions;\n-\n-        for (Map.Entry<AbstractInsnNode, BasicBlock> entry : insnToBB.entrySet()) {\n-            \/\/ Basic block 'bb' starts at instruction 'insn'\n-            AbstractInsnNode insn = entry.getKey();\n-            BasicBlock bb = entry.getValue();\n-\n-            \/\/ Get the entry blocks for this basic block\n-            Set<Map.Entry<DataBlock, LabelNode>> pairs = bb.blockLabelSet();\n-            int remaining = pairs.size();\n-            LabelNode realStuff = null;\n-            if (remaining > 1) {\n-                \/\/ There are two or more entries to this block.\n-                \/\/ We will need a label to jump over the other entries.\n-                realStuff = new LabelNode();\n-            }\n-            \/\/ any fallen into entry blocks must be instrumented first (no label\n-            \/\/ switching was done for them.\n-            DataBlock fallenInto = bb.fallenInto();\n-            if (fallenInto != null) {\n-                assert (bb.getLabel(fallenInto) == null);\n-                instructions.insertBefore(insn, Instrumenter.instrumentation(fallenInto, params.isDetectInternal()));\n-                if (--remaining > 0) {\n-                    \/\/ jump over the next instrumentation of this basic block\n-                    instructions.insertBefore(insn, new JumpInsnNode(GOTO, realStuff));\n-                }\n-            }\n-\n-            \/\/ Process the other entry blocks\n-            for (Map.Entry<DataBlock, LabelNode> pair : pairs) {\n-                DataBlock block = pair.getKey();\n-                if (!block.isFallenInto()) {\n-                    \/\/ insert the label\n-                    LabelNode lnode = pair.getValue();\n-                    assert (lnode != null);\n-\n-                    \/\/ insert created label\n-                    instructions.insertBefore(insn, lnode);\n-\n-                    \/\/ insert the instrumentation\n-                    instructions.insertBefore(insn, Instrumenter.instrumentation(block, params.isDetectInternal()));\n-                    if (--remaining > 0) {\n-                        \/\/ jump over the next instrumentation of this basic block\n-                        instructions.insertBefore(insn, new JumpInsnNode(GOTO, realStuff));\n-                    }\n-                }\n-            }\n-            if (realStuff != null) {\n-                \/\/ insert label for the real code\n-                instructions.insertBefore(insn, realStuff);\n-            }\n-\n-            assert (remaining == 0);\n-        }\n-    }\n-\n-    @Override\n-    public void visitAttribute(Attribute attr) {\n-        super.visitAttribute(attr);\n-        if (attr instanceof CharacterRangeTableAttribute) {\n-            method().setCharacterRangeTable((CharacterRangeTableAttribute) attr);\n-        }\n-    }\n-\n-\/\/ the instruction list has been built, insert the instrumentation\n-    @Override\n-    public void visitEnd() {\n-        super.visitEnd();\n-\n-        BasicBlock[] basicBlocks = completeComputationOfCodeLabelNodes();\n-        computeEndBCIsAndFoldInExits(basicBlocks);\n-        \/\/debugDump();\n-        insertInstrumentation();\n-        method().setBasicBlocks(basicBlocks);\n-\n-        \/\/ push the result to the writer\n-        MethodNode methodNode = (MethodNode) mv;\n-        methodNode.accept(nextVisitor);\n-    }\n-\n-    private void debugDump() {\n-        \/* Opcode Names *\/\n-\n-        MethodNode methodNode = (MethodNode) mv;\n-        InsnList instructions = methodNode.instructions;\n-        ListIterator iit = instructions.iterator();\n-\n-        System.out.println(methodNode.name + \"  ----\");\n-        while (iit.hasNext()) {\n-            AbstractInsnNode instr = (AbstractInsnNode) iit.next();\n-            int opcode = instr.getOpcode();\n-            if (opcode >= 0) {\n-                System.out.print(\"        \");\n-                System.out.print(Constants.opcNames[opcode]);\n-                System.out.print(\"  \");\n-            }\n-            switch (instr.getType()) {\n-                case LINE:\n-                    System.out.print(((LineNumberNode) instr).line);\n-                    System.out.print(\"#\");\n-                    break;\n-                case LABEL:\n-                    System.out.print(labelString(((LabelNode) instr)));\n-                    System.out.print(\":\");\n-                    break;\n-                case FRAME:\n-                    System.out.print(\"frame-\");\n-                    break;\n-                case JUMP_INSN:\n-                    System.out.print(labelString(((JumpInsnNode) instr).label));\n-                    break;\n-                case LOOKUPSWITCH: {\n-                    LookupSwitchInsnNode node = (LookupSwitchInsnNode) instr;\n-                    System.out.println();\n-                    System.out.print(\"            default: \");\n-                    System.out.print(labelString(node.dflt));\n-                    int len = node.labels.size();\n-                    for (int i = 0; i < len; ++i) {\n-                        LabelNode lnode = (LabelNode) (node.labels.get(i));\n-                        Integer key = (Integer) (node.keys.get(i));\n-                        System.out.println();\n-                        System.out.print(\"            \");\n-                        System.out.print(key);\n-                        System.out.print(\": \");\n-                        System.out.print(labelString(lnode));\n-                    }\n-                    break;\n-                }\n-                case TABLESWITCH_INSN: {\n-                    TableSwitchInsnNode node = (TableSwitchInsnNode) instr;\n-                    System.out.println();\n-                    System.out.print(\"            default: \");\n-                    System.out.print(labelString(node.dflt));\n-                    int len = node.labels.size();\n-                    int key = node.min;\n-                    for (int i = 0; i < len; ++i) {\n-                        LabelNode lnode = (LabelNode) (node.labels.get(i));\n-                        System.out.println();\n-                        System.out.print(\"            \");\n-                        System.out.print(key++);\n-                        System.out.print(\": \");\n-                        System.out.print(labelString(lnode));\n-                    }\n-                    break;\n-                }\n-                default:\n-                    break;\n-            }\n-            if (insnToBB.get(instr) != null) {\n-                System.out.println(\"  block [\" + insnToBB.get(instr).startBCI()\n-                        + \", \" + insnToBB.get(instr).endBCI() + \"]\");\n-            } else {\n-                System.out.println();\n-            }\n-        }\n-    }\n-\n-    private String labelString(LabelNode lnode) {\n-        Label lab = lnode.getLabel();\n-        return lab.toString();\n-    }\n-}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/BranchCodeMethodAdapter.java","additions":0,"deletions":589,"binary":false,"changes":589,"status":"deleted"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument;\n+\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.reader.Reader;\n+import com.sun.tdk.jcov.instrument.reader.ReaderFactory;\n+\n+\/**\n+ * CharacterRangeTableAttribute\n+ *\n+ *\n+ *\n+ * @author Robert Field\n+ *\/\n+public class CharacterRangeTable {\n+\n+    public static class CRTEntry extends LocationConcrete {\n+\n+        public final int char_start;\n+        public final int char_end;\n+        public final int flags;\n+        public static final int CRT_STATEMENT = 0x0001;\n+        public static final int CRT_BLOCK = 0x0002;\n+        public static final int CRT_ASSIGNMENT = 0x0004;\n+        public static final int CRT_FLOW_CONTROLLER = 0x0008;\n+        public static final int CRT_FLOW_TARGET = 0x0010;\n+        public static final int CRT_INVOKE = 0x0020;\n+        public static final int CRT_CREATE = 0x0040;\n+        public static final int CRT_BRANCH_TRUE = 0x0080;\n+        public static final int CRT_BRANCH_FALSE = 0x0100;\n+\n+        public CRTEntry(final int rootId,\n+                final int start_pc,\n+                final int end_pc,\n+                final int char_start,\n+                final int char_end,\n+                final int flags) {\n+            super(rootId, start_pc, end_pc);\n+            this.char_start = char_start;\n+            this.char_end = char_end;\n+            this.flags = flags;\n+        }\n+\n+        \/**\n+         * XML Generation\n+         *\/\n+        public String kind() {\n+            return XmlNames.RANGE;\n+        }\n+\n+        public void xmlAttrs(XmlContext ctx) {\n+            super.xmlAttrs(ctx);\n+            if ((flags & CRT_STATEMENT) != 0) {\n+                ctx.attr(XmlNames.A_STATEMENT, true);\n+            }\n+            if ((flags & CRT_BLOCK) != 0) {\n+                ctx.attr(XmlNames.A_BLOCK, true);\n+            }\n+            if ((flags & CRT_ASSIGNMENT) != 0) {\n+                ctx.attr(XmlNames.A_ASSIGNMENT, true);\n+            }\n+            if ((flags & CRT_FLOW_CONTROLLER) != 0) {\n+                ctx.attr(XmlNames.A_CONTROLLER, true);\n+            }\n+            if ((flags & CRT_FLOW_TARGET) != 0) {\n+                ctx.attr(XmlNames.A_TARGET, true);\n+            }\n+            if ((flags & CRT_INVOKE) != 0) {\n+                ctx.attr(XmlNames.A_INVOKE, true);\n+            }\n+            if ((flags & CRT_CREATE) != 0) {\n+                ctx.attr(XmlNames.A_CREATE, true);\n+            }\n+            if ((flags & CRT_BRANCH_TRUE) != 0) {\n+                ctx.attr(XmlNames.A_BRANCHTRUE, true);\n+            }\n+            if ((flags & CRT_BRANCH_FALSE) != 0) {\n+                ctx.attr(XmlNames.A_BRANCHFALSE, true);\n+            }\n+        }\n+\n+        private void xmlPos(XmlContext ctx, int char_pos) {\n+            ctx.indent();\n+            ctx.format(\"<\" + XmlNames.CRT_POS + \" \" + XmlNames.CRT_LINE + \"='%d' \"\n+                    + XmlNames.CRT_COL + \"='%d'\/>\", char_pos >> 10, char_pos & 0x3FF);\n+            ctx.println();\n+        }\n+\n+        void xmlBody(XmlContext ctx) {\n+            xmlPos(ctx, char_start);\n+            xmlPos(ctx, char_end);\n+        }\n+    }\n+    public int length;\n+    public CRTEntry[] entries;\n+    private int rootId;\n+\n+    public int getRootId() {\n+        return rootId;\n+    }\n+\n+    public void setRootId(int rootId) {\n+        this.rootId = rootId;\n+    }\n+\n+    \/**\n+     * Creates a new instance of CharacterRangeTableAttribute\n+     *\/\n+    public CharacterRangeTable(int rootId) {\n+        this(rootId, 0, new CRTEntry[0]);\n+    }\n+\n+    public CharacterRangeTable(int rootId, int length, CRTEntry[] entries) {\n+        this.length = length;\n+        this.entries = entries;\n+        this.rootId = rootId;\n+    }\n+\n+    public CRTEntry[] getEntries() {\n+        return entries;\n+    }\n+\n+    public void setEntries(CRTEntry[] entries) {\n+        this.entries = entries;\n+    }\n+\n+    \/*\n+     * return entry with given pc and flag set,\n+     * if there are more then one found , return first in source code\n+     *\/\n+    CRTEntry getEntry(int pc, int flag) {\n+        CRTEntry result = null;\n+        for (CRTEntry entry : getEntries()) {\n+            if (entry.startBCI() == pc\n+                    && (entry.flags & flag) != 0) {\n+                result = (result == null) ? entry\n+                        : entry.char_start < result.char_start ? entry : result;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * XML Generation\n+     *\n+     * Since there is no multiple inheritance, we aren't a DataAbstract, but\n+     * we'll fake it\n+     *\/\n+    public void xmlGen(XmlContext ctx) {\n+        ctx.indent();\n+        ctx.println(\"<\" + XmlNames.CRT + \">\");\n+        ctx.incIndent();\n+        for (CRTEntry entry : entries) {\n+            entry.xmlGen(ctx);\n+        }\n+        ctx.decIndent();\n+        ctx.indent();\n+        ctx.println(\"<\/\" + XmlNames.CRT + \">\");\n+    }\n+\n+    public void readDataFrom() throws FileFormatException {\n+        ReaderFactory rf = DataRoot.getInstance(rootId).getReaderFactory();\n+        Reader r = rf.getReaderFor(this);\n+        r.readData(this);\n+    }\n+\n+\n+    public int getPos(int line, int col) {\n+        return line << 10 | col;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/CharacterRangeTable.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -1,241 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov.instrument;\n-\n-import com.sun.tdk.jcov.data.FileFormatException;\n-import com.sun.tdk.jcov.instrument.reader.Reader;\n-import com.sun.tdk.jcov.instrument.reader.ReaderFactory;\n-import org.objectweb.asm.Attribute;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.ByteVector;\n-import org.objectweb.asm.Label;\n-\n-\/**\n- * CharacterRangeTableAttribute\n- *\n- *\n- *\n- * @author Robert Field\n- *\/\n-public class CharacterRangeTableAttribute extends Attribute {\n-\n-    public static class CRTEntry extends LocationConcrete {\n-\n-        public final int char_start;\n-        public final int char_end;\n-        public final int flags;\n-        public static final int CRT_STATEMENT = 0x0001;\n-        public static final int CRT_BLOCK = 0x0002;\n-        public static final int CRT_ASSIGNMENT = 0x0004;\n-        public static final int CRT_FLOW_CONTROLLER = 0x0008;\n-        public static final int CRT_FLOW_TARGET = 0x0010;\n-        public static final int CRT_INVOKE = 0x0020;\n-        public static final int CRT_CREATE = 0x0040;\n-        public static final int CRT_BRANCH_TRUE = 0x0080;\n-        public static final int CRT_BRANCH_FALSE = 0x0100;\n-\n-        public CRTEntry(final int rootId,\n-                final int start_pc,\n-                final int end_pc,\n-                final int char_start,\n-                final int char_end,\n-                final int flags) {\n-            super(rootId, start_pc, end_pc);\n-            this.char_start = char_start;\n-            this.char_end = char_end;\n-            this.flags = flags;\n-        }\n-\n-        void put(ByteVector bv) {\n-            bv.putShort(startBCI());\n-            bv.putShort(endBCI());\n-            bv.putInt(char_start);\n-            bv.putInt(char_end);\n-            bv.putShort(flags);\n-        }\n-\n-        \/**\n-         * XML Generation\n-         *\/\n-        public String kind() {\n-            return XmlNames.RANGE;\n-        }\n-\n-        void xmlAttrs(XmlContext ctx) {\n-            super.xmlAttrs(ctx);\n-            if ((flags & CRT_STATEMENT) != 0) {\n-                ctx.attr(XmlNames.A_STATEMENT, true);\n-            }\n-            if ((flags & CRT_BLOCK) != 0) {\n-                ctx.attr(XmlNames.A_BLOCK, true);\n-            }\n-            if ((flags & CRT_ASSIGNMENT) != 0) {\n-                ctx.attr(XmlNames.A_ASSIGNMENT, true);\n-            }\n-            if ((flags & CRT_FLOW_CONTROLLER) != 0) {\n-                ctx.attr(XmlNames.A_CONTROLLER, true);\n-            }\n-            if ((flags & CRT_FLOW_TARGET) != 0) {\n-                ctx.attr(XmlNames.A_TARGET, true);\n-            }\n-            if ((flags & CRT_INVOKE) != 0) {\n-                ctx.attr(XmlNames.A_INVOKE, true);\n-            }\n-            if ((flags & CRT_CREATE) != 0) {\n-                ctx.attr(XmlNames.A_CREATE, true);\n-            }\n-            if ((flags & CRT_BRANCH_TRUE) != 0) {\n-                ctx.attr(XmlNames.A_BRANCHTRUE, true);\n-            }\n-            if ((flags & CRT_BRANCH_FALSE) != 0) {\n-                ctx.attr(XmlNames.A_BRANCHFALSE, true);\n-            }\n-        }\n-\n-        private void xmlPos(XmlContext ctx, int char_pos) {\n-            ctx.indent();\n-            ctx.format(\"<\" + XmlNames.CRT_POS + \" \" + XmlNames.CRT_LINE + \"='%d' \"\n-                    + XmlNames.CRT_COL + \"='%d'\/>\", char_pos >> 10, char_pos & 0x3FF);\n-            ctx.println();\n-        }\n-\n-        void xmlBody(XmlContext ctx) {\n-            xmlPos(ctx, char_start);\n-            xmlPos(ctx, char_end);\n-        }\n-    }\n-    public int length;\n-    public CRTEntry[] entries;\n-    private int rootId;\n-\n-    public int getRootId() {\n-        return rootId;\n-    }\n-\n-    public void setRootId(int rootId) {\n-        this.rootId = rootId;\n-    }\n-\n-    \/**\n-     * Creates a new instance of CharacterRangeTableAttribute\n-     *\/\n-    public CharacterRangeTableAttribute(int rootId) {\n-        this(rootId, 0, new CRTEntry[0]);\n-    }\n-\n-    CharacterRangeTableAttribute(int rootId, int length, CRTEntry[] entries) {\n-        super(\"CharacterRangeTable\");\n-        this.length = length;\n-        this.entries = entries;\n-        this.rootId = rootId;\n-    }\n-\n-    CRTEntry[] getEntries() {\n-        return entries;\n-    }\n-\n-    public void setEntries(CRTEntry[] entries) {\n-        this.entries = entries;\n-    }\n-\n-    @Override\n-    public boolean isUnknown() {\n-        return false;\n-    }\n-\n-    \/*\n-     * return entry with given pc and flag set,\n-     * if there are more then one found , return first in source code\n-     *\/\n-    CRTEntry getEntry(int pc, int flag) {\n-        CRTEntry result = null;\n-        for (CRTEntry entry : getEntries()) {\n-            if (entry.startBCI() == pc\n-                    && (entry.flags & flag) != 0) {\n-                result = (result == null) ? entry\n-                        : entry.char_start < result.char_start ? entry : result;\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    protected Attribute read(ClassReader cr, int off, int len,\n-            char[] buf, int codeOff, Label[] labels) {\n-        int length = cr.readShort(off);\n-        CRTEntry[] entries = new CRTEntry[length];\n-        for (int i = 0; i < length; ++i) {\n-            int eoff = off + 2 + (i * 14);\n-            int start_pc = cr.readShort(eoff + 0);\n-            int end_pc = cr.readShort(eoff + 2);\n-            int char_start = cr.readInt(eoff + 4);\n-            int char_end = cr.readInt(eoff + 8);\n-            int flags = cr.readShort(eoff + 12);\n-            entries[i] = new CRTEntry(rootId, start_pc, end_pc, char_start, char_end, flags);\n-        }\n-        return new CharacterRangeTableAttribute(rootId, length, entries);\n-    }\n-\n-    @Override\n-    protected ByteVector write(ClassWriter cw, byte[] code, int len,\n-            int maxStack, int maxLocals) {\n-        ByteVector bv = new ByteVector();\n-        bv.putShort(length);\n-        for (CRTEntry entry : entries) {\n-            entry.put(bv);\n-        }\n-        return bv;\n-    }\n-\n-    \/**\n-     * XML Generation\n-     *\n-     * Since there is no multiple inheritance, we aren't a DataAbstract, but\n-     * we'll fake it\n-     *\/\n-    void xmlGen(XmlContext ctx) {\n-        ctx.indent();\n-        ctx.println(\"<\" + XmlNames.CRT + \">\");\n-        ctx.incIndent();\n-        for (CRTEntry entry : entries) {\n-            entry.xmlGen(ctx);\n-        }\n-        ctx.decIndent();\n-        ctx.indent();\n-        ctx.println(\"<\/\" + XmlNames.CRT + \">\");\n-    }\n-\n-    public void readDataFrom() throws FileFormatException {\n-        ReaderFactory rf = DataRoot.getInstance(rootId).getReaderFactory();\n-        Reader r = rf.getReaderFor(this);\n-        r.readData(this);\n-    }\n-\n-\n-    public int getPos(int line, int col) {\n-        return line << 10 | col;\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/CharacterRangeTableAttribute.java","additions":0,"deletions":241,"binary":false,"changes":241,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-    static final String opcNames[] = {\n+    public static final String[] opcNames = {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/Constants.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.tdk.jcov.instrument.asm.ASMModifiers;\n@@ -34,0 +35,2 @@\n+import java.util.Collections;\n+import java.util.HashMap;\n@@ -35,2 +38,1 @@\n-\n-import static org.objectweb.asm.Opcodes.*;\n+import java.util.Map;\n@@ -46,0 +48,24 @@\n+    final private static Map<String, Integer> map =\n+            Collections.synchronizedMap(new HashMap<String, Integer>());\n+    static volatile int invokeCount = 0;\n+\n+    public static int getInvokeID(String owner, String name, String descr) {\n+        String sig = owner + \".\" + name + descr;\n+        synchronized (map) {\n+            Integer id = map.get(sig);\n+            if (id != null) {\n+                return id;\n+            }\n+            \/\/return 0;\n+            id = invokeCount++;\n+            map.put(sig, id);\n+            return id;\n+        }\n+    }\n+\n+    \/\/never used\n+    public static void addID(String className, String name, String descr, int id) {\n+        String sig = className + \".\" + name + descr;\n+        map.put(sig, id);\n+    }\n+\n@@ -99,1 +125,1 @@\n-    void xmlGen(XmlContext ctx) {\n+    public void xmlGen(XmlContext ctx) {\n@@ -111,1 +137,1 @@\n-    void xmlAccessFlags(XmlContext ctx, int access) {\n+    void xmlAccessFlags(XmlContext ctx, Modifiers access) {\n@@ -129,1 +155,1 @@\n-    String[] accessFlags(int access) {\n+    String[] accessFlags(Modifiers access) {\n@@ -131,1 +157,1 @@\n-        if ((access & ACC_PUBLIC) != 0) {\n+        if (access.isPublic()) {\n@@ -134,1 +160,1 @@\n-        if ((access & ACC_PRIVATE) != 0) {\n+        if (access.isPrivate()) {\n@@ -137,1 +163,1 @@\n-        if ((access & ACC_PROTECTED) != 0) {\n+        if (access.isProtected()) {\n@@ -140,1 +166,1 @@\n-        if ((access & ACC_STATIC) != 0) {\n+        if (access.isStatic()) {\n@@ -143,1 +169,1 @@\n-        if ((access & ACC_FINAL) != 0) {\n+        if (access.isFinal()) {\n@@ -146,1 +172,1 @@\n-        if ((access & ACC_SYNCHRONIZED) != 0) {\n+        if (access.isSynchronized()) {\n@@ -149,1 +175,1 @@\n-        if ((access & ACC_VOLATILE) != 0) {\n+        if (access.isVolatile()) {\n@@ -152,1 +178,1 @@\n-        if ((access & ACC_BRIDGE) != 0) {\n+        if (access.isBridge()) {\n@@ -155,1 +181,1 @@\n-        if ((access & ACC_VARARGS) != 0) {\n+        if (access.isVarargs()) {\n@@ -158,1 +184,1 @@\n-        if ((access & ACC_TRANSIENT) != 0) {\n+        if (access.isTransient()) {\n@@ -161,1 +187,1 @@\n-        if ((access & ACC_NATIVE) != 0) {\n+        if (access.isNative()) {\n@@ -164,1 +190,1 @@\n-        if ((access & ACC_INTERFACE) != 0) {\n+        if (access.isInterface()) {\n@@ -167,1 +193,1 @@\n-        if ((access & ACC_ABSTRACT) != 0) {\n+        if (access.isAbstract()) {\n@@ -170,1 +196,1 @@\n-        if ((access & ACC_STRICT) != 0) {\n+        if (access.isStrict()) {\n@@ -173,1 +199,1 @@\n-        if ((access & ACC_ANNOTATION) != 0) {\n+        if (access.isAnnotation()) {\n@@ -176,1 +202,1 @@\n-        if ((access & ACC_ENUM) != 0) {\n+        if (access.isEnum()) {\n@@ -179,1 +205,1 @@\n-        if ((access & ACC_SYNTHETIC) != 0) {\n+        if (access.isSynthetic()) {\n@@ -185,57 +211,2 @@\n-    public int access(String[] accessFlags) {\n-        int access = 0;\n-        for (String flag : accessFlags) {\n-            if (flag.contains(XmlNames.A_PUBLIC)) {\n-                access |= ACC_PUBLIC;\n-            }\n-            if (flag.contains(XmlNames.A_PRIVATE)) {\n-                access |= ACC_PRIVATE;\n-            }\n-            if (flag.contains(XmlNames.A_PROTECTED)) {\n-                access |= ACC_PROTECTED;\n-            }\n-            if (flag.contains(XmlNames.A_STATIC)) {\n-                access |= ACC_STATIC;\n-            }\n-            if (flag.contains(XmlNames.A_FINAL)) {\n-                access |= ACC_FINAL;\n-            }\n-            if (flag.contains(XmlNames.A_VOLATILE)) {\n-                access |= ACC_VOLATILE;\n-            }\n-            if (flag.contains(XmlNames.A_BRIDGE)) {\n-                access |= ACC_BRIDGE;\n-            }\n-            if (flag.contains(XmlNames.A_VARARGS)) {\n-                access |= ACC_VARARGS;\n-            }\n-            if (flag.contains(XmlNames.A_TRANSIENT)) {\n-                access |= ACC_TRANSIENT;\n-            }\n-            if (flag.contains(XmlNames.A_NATIVE)) {\n-                access |= ACC_NATIVE;\n-            }\n-            if (flag.contains(XmlNames.A_INTERFACE) || flag.contains(XmlNames.A_DEFENDER_METH)) {\n-                access |= ACC_INTERFACE;\n-            }\n-            if (flag.contains(XmlNames.A_ABSTRACT)) {\n-                access |= ACC_ABSTRACT;\n-            }\n-            if (flag.contains(XmlNames.A_STRICT)) {\n-                access |= ACC_STRICT;\n-            }\n-            if (flag.contains(XmlNames.A_ANNOTATION)) {\n-                access |= ACC_ANNOTATION;\n-            }\n-            if (flag.contains(XmlNames.A_ENUM)) {\n-                access |= ACC_ENUM;\n-            }\n-            if (flag.contains(XmlNames.A_SYNTHETIC)) {\n-                access |= ACC_SYNTHETIC;\n-            }\n-            if (flag.contains(XmlNames.A_SYNCHRONIZED)) {\n-                access |= ACC_SYNCHRONIZED;\n-            }\n-\n-        }\n-        return access;\n+    public Modifiers access(String[] accessFlags) {\n+        return ASMModifiers.parse(accessFlags);\n@@ -244,1 +215,1 @@\n-    public String access(int access) {\n+    public String access(Modifiers access) {\n@@ -298,3 +269,0 @@\n-    public static final int ACCESS_MASK = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_FINAL | ACC_STATIC | ACC_SYNCHRONIZED\n-            | ACC_VOLATILE | ACC_BRIDGE | ACC_VARARGS | ACC_TRANSIENT | ACC_NATIVE | ACC_ABSTRACT | ACC_INTERFACE\n-            | ACC_STRICT | ACC_ANNOTATION | ACC_ENUM | ACC_SYNTHETIC;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataAbstract.java","additions":52,"deletions":84,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    void addAnnotation(String anno) {\n+    public void addAnnotation(String anno) {\n@@ -60,1 +60,1 @@\n-    protected List<String> getAnnotations() {\n+    public List<String> getAnnotations() {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataAnnotated.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,1 @@\n-    boolean isFallenInto() {\n+    public boolean isFallenInto() {\n@@ -173,1 +173,1 @@\n-    void xmlAttrs(XmlContext ctx) {\n+    protected void xmlAttrs(XmlContext ctx) {\n@@ -201,1 +201,1 @@\n-    void xmlGen(XmlContext ctx) {\n+    public void xmlGen(XmlContext ctx) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBlock.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-    DataBlockCatch(int rootId) {\n+    public DataBlockCatch(int rootId) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBlockCatch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    DataBlockFallThrough(int rootId) {\n+    public DataBlockFallThrough(int rootId) {\n@@ -49,1 +49,1 @@\n-    boolean isFallenInto() {\n+    public boolean isFallenInto() {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBlockFallThrough.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    DataBlockMethEnter(int rootId) {\n+    public DataBlockMethEnter(int rootId) {\n@@ -50,1 +50,1 @@\n-    boolean isFallenInto() {\n+    public boolean isFallenInto() {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBlockMethEnter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-    void xmlAttrs(XmlContext ctx) {\n+    protected void xmlAttrs(XmlContext ctx) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBlockTarget.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    DataBlockTargetCase(int rootId, int value) {\n+    public DataBlockTargetCase(int rootId, int value) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBlockTargetCase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-    DataBlockTargetCond(int rootId, boolean side) {\n+    public DataBlockTargetCond(int rootId, boolean side) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBlockTargetCond.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    DataBlockTargetDefault(int rootId) {\n+    public DataBlockTargetDefault(int rootId) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBlockTargetDefault.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    DataBlockTargetGoto(int rootId) {\n+    public DataBlockTargetGoto(int rootId) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBlockTargetGoto.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    DataBranchSwitch(int rootId, int bciStart, int bciEnd, DataBlockTargetDefault blockDefault) {\n+    public DataBranchSwitch(int rootId, int bciStart, int bciEnd, DataBlockTargetDefault blockDefault) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataBranchSwitch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.tdk.jcov.instrument.asm.ASMModifiers;\n@@ -34,1 +35,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -83,3 +83,1 @@\n-     * Access code of this class\n-     *\n-     * @see org.objectweb.asm.Opcodes\n+     * Container for access code of this class\n@@ -87,1 +85,1 @@\n-    private int access;\n+    private Modifiers access;\n@@ -163,1 +161,0 @@\n-        int acc = access(accessFlags);\n@@ -169,1 +166,1 @@\n-        setInfo(acc, signature, superName, sInterfaces);\n+        setInfo(access(accessFlags), signature, superName, sInterfaces);\n@@ -181,1 +178,1 @@\n-    public void setInfo(int access, String signature, String superName, String[] interfaces) {\n+    public void setInfo(Modifiers access, String signature, String superName, String[] interfaces) {\n@@ -271,1 +268,0 @@\n-     * @see org.objectweb.asm.Opcodes\n@@ -275,1 +271,1 @@\n-        this.access = access;\n+        this.access = new ASMModifiers(access);\n@@ -281,1 +277,0 @@\n-     * @see org.objectweb.asm.Opcodes\n@@ -285,1 +280,1 @@\n-        return access;\n+        return access.access();\n@@ -288,0 +283,1 @@\n+    public Modifiers getModifiers() { return access; }\n@@ -372,1 +368,0 @@\n-     * @see org.objectweb.asm.Opcodes\n@@ -376,3 +371,1 @@\n-    public boolean isPublic() {\n-        return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED)) != 0;\n-    }\n+    public boolean isPublic() { return isPublicAPI(); }\n@@ -384,1 +377,0 @@\n-     * @see org.objectweb.asm.Opcodes\n@@ -388,1 +380,1 @@\n-        return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED)) != 0;\n+        return access.isPublic() || access.isProtected();\n@@ -396,0 +388,1 @@\n+    @Deprecated\n@@ -397,1 +390,1 @@\n-        return (access & Opcodes.ACC_PRIVATE) != 0;\n+        return access.isPrivate();\n@@ -405,0 +398,1 @@\n+    @Deprecated\n@@ -406,1 +400,1 @@\n-        return (access & Opcodes.ACC_PUBLIC) != 0;\n+        return access.isPublic();\n@@ -414,0 +408,1 @@\n+    @Deprecated\n@@ -415,1 +410,1 @@\n-        return (access & Opcodes.ACC_PROTECTED) != 0;\n+        return access.isProtected();\n@@ -423,0 +418,1 @@\n+    @Deprecated\n@@ -424,1 +420,1 @@\n-        return (access & Opcodes.ACC_ABSTRACT) != 0;\n+        return access.isAbstract();\n@@ -432,0 +428,1 @@\n+    @Deprecated\n@@ -433,1 +430,1 @@\n-        return (access & Opcodes.ACC_STATIC) != 0;\n+        return access.isStatic();\n@@ -437,1 +434,1 @@\n-     * Checks whether this class has specified modifier (by Opcodes)\n+     * Checks whether this class has specified modifier\n@@ -440,1 +437,0 @@\n-     * @see Opcodes\n@@ -443,3 +439,2 @@\n-    public boolean hasModifier(int modifierCode) {\n-        return (access & modifierCode) != 0;\n-    }\n+    @Deprecated\n+    public boolean hasModifier(int modifierCode) { return access.is(modifierCode); }\n@@ -591,1 +586,1 @@\n-            return (access & Opcodes.ACC_INTERFACE) == 0 ? XmlNames.CLASS : XmlNames.INTERFACE;\n+            return access.isInterface() ? XmlNames.INTERFACE : XmlNames.CLASS;\n@@ -601,1 +596,1 @@\n-    void xmlGen(XmlContext ctx) {\n+    public void xmlGen(XmlContext ctx) {\n@@ -608,1 +603,1 @@\n-            } else if ((access & Opcodes.ACC_INTERFACE) == 0) {\n+            } else if (!access.isInterface()) {\n@@ -615,1 +610,1 @@\n-                    if ((method.getAccess() & Opcodes.ACC_ABSTRACT) == 0) {\n+                    if (!method.getModifiers().isAbstract()) {\n@@ -639,1 +634,1 @@\n-        if (!differentiateClass && (access & Opcodes.ACC_INTERFACE) != 0) {\n+        if (!differentiateClass && !access.isInterface()) {\n@@ -682,1 +677,1 @@\n-    String[] accessFlags(int access) {\n+    String[] accessFlags(Modifiers access) {\n@@ -932,1 +927,0 @@\n-     * @param errorSeverity - error severity\n@@ -987,1 +981,1 @@\n-        if ((access | Opcodes.ACC_SUPER) != (other.access | Opcodes.ACC_SUPER)) {\n+        if (access.isSuper() != other.access.isSuper()) {\n@@ -989,1 +983,1 @@\n-                    \"Access mismatch: expected '\" + access + \"'; found '\" + other.access + \"'\",\n+                    \"Access mismatch: expected '\" + access.access() + \"'; found '\" + other.access.access() + \"'\",\n@@ -1078,1 +1072,1 @@\n-        out.writeInt(access & ACCESS_MASK); \/\/ we don't save ALL the codes in XML, we shouldn't save all codes in net\n+        out.writeInt(access.access());\n@@ -1089,1 +1083,1 @@\n-                if ((m.access & (Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT)) != 0) {\n+                if (m.access.isNative() || m.access.isAbstract()) {\n@@ -1095,1 +1089,1 @@\n-                if ((m.access & (Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT)) != 0) {\n+                if (m.access.isNative() || m.access.isAbstract()) {\n@@ -1122,1 +1116,1 @@\n-        access = in.readInt();\n+        access = new ASMModifiers(in.readInt());\n@@ -1169,0 +1163,1 @@\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataClass.java","additions":37,"deletions":42,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    void xmlGen(XmlContext cxt) {\n+    public void xmlGen(XmlContext cxt) {\n@@ -67,1 +67,1 @@\n-    void xmlAttrs(XmlContext ctx) {\n+    protected void xmlAttrs(XmlContext ctx) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataExitSimple.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.tdk.jcov.instrument.asm.ASMModifiers;\n@@ -40,1 +41,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -56,3 +56,1 @@\n-     * Field access code\n-     *\n-     * @see org.objectweb.asm.Opcodes\n+     * Container for field access code\n@@ -60,1 +58,1 @@\n-    private final int access;\n+    private final Modifiers access;\n@@ -122,1 +120,1 @@\n-        this.access = access;\n+        this.access = new ASMModifiers(access);\n@@ -137,1 +135,1 @@\n-                return CollectDetect.wasInvokeHit(InvokeMethodAdapter.getInvokeID(k.getFullname(), name, desc));\n+                return CollectDetect.wasInvokeHit(DataAbstract.getInvokeID(k.getFullname(), name, desc));\n@@ -142,1 +140,1 @@\n-                return CollectDetect.invokeCountFor(InvokeMethodAdapter.getInvokeID(k.getFullname(), name, desc));\n+                return CollectDetect.invokeCountFor(DataAbstract.getInvokeID(k.getFullname(), name, desc));\n@@ -147,1 +145,1 @@\n-                CollectDetect.setInvokeCountFor(InvokeMethodAdapter.getInvokeID(k.getFullname(), name, desc), count);\n+                CollectDetect.setInvokeCountFor(DataAbstract.getInvokeID(k.getFullname(), name, desc), count);\n@@ -228,1 +226,1 @@\n-        return access;\n+        return access.access();\n@@ -231,0 +229,2 @@\n+    public Modifiers getModifiers() { return access; }\n+\n@@ -263,1 +263,0 @@\n-     * @see org.objectweb.asm.Opcodes\n@@ -268,1 +267,1 @@\n-        return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED)) != 0;\n+        return isPublicAPI();\n@@ -275,1 +274,0 @@\n-     * @see org.objectweb.asm.Opcodes\n@@ -279,1 +277,1 @@\n-        return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED)) != 0;\n+        return access.isPublic() || access.isProtected();\n@@ -287,0 +285,1 @@\n+    @Deprecated\n@@ -288,1 +287,1 @@\n-        return (access & Opcodes.ACC_PRIVATE) != 0;\n+        return access.isPrivate();\n@@ -296,0 +295,1 @@\n+    @Deprecated\n@@ -297,1 +297,1 @@\n-        return (access & Opcodes.ACC_PUBLIC) != 0;\n+        return access.isPublic();\n@@ -305,0 +305,1 @@\n+    @Deprecated\n@@ -306,1 +307,1 @@\n-        return (access & Opcodes.ACC_PROTECTED) != 0;\n+        return access.isProtected();\n@@ -314,0 +315,1 @@\n+    @Deprecated\n@@ -315,1 +317,1 @@\n-        return (access & Opcodes.ACC_STATIC) != 0;\n+        return access.isStatic();\n@@ -319,1 +321,1 @@\n-     * Checks whether this field has specified modifier (by Opcodes)\n+     * Checks whether this field has specified modifier\n@@ -322,1 +324,0 @@\n-     * @see Opcodes\n@@ -325,0 +326,1 @@\n+    @Deprecated\n@@ -326,1 +328,1 @@\n-        return (access & modifierCode) != 0;\n+        return access.is(modifierCode);\n@@ -366,1 +368,1 @@\n-    void xmlGen(XmlContext ctx) {\n+    public void xmlGen(XmlContext ctx) {\n@@ -382,1 +384,1 @@\n-        ctx.attr(XmlNames.ACCESS, access);\n+        ctx.attr(XmlNames.ACCESS, access.access());\n@@ -477,1 +479,1 @@\n-    String[] accessFlags(int access) {\n+    String[] accessFlags(Modifiers access) {\n@@ -494,1 +496,1 @@\n-        out.writeInt(access & ACCESS_MASK); \/\/ we don't save ALL the codes in XML, we shouldn't save all codes in net\n+        out.writeInt(access.access());\n@@ -511,1 +513,1 @@\n-        access = in.readInt();\n+        access = new ASMModifiers(in.readInt());\n@@ -524,1 +526,1 @@\n-                return CollectDetect.wasInvokeHit(InvokeMethodAdapter.getInvokeID(c.getFullname(), name, vmSig));\n+                return CollectDetect.wasInvokeHit(DataAbstract.getInvokeID(c.getFullname(), name, vmSig));\n@@ -529,1 +531,1 @@\n-                return CollectDetect.invokeCountFor(InvokeMethodAdapter.getInvokeID(c.getFullname(), name, vmSig));\n+                return CollectDetect.invokeCountFor(DataAbstract.getInvokeID(c.getFullname(), name, vmSig));\n@@ -534,1 +536,1 @@\n-                CollectDetect.setInvokeCountFor(InvokeMethodAdapter.getInvokeID(c.getFullname(), name, vmSig), count);\n+                CollectDetect.setInvokeCountFor(DataAbstract.getInvokeID(c.getFullname(), name, vmSig), count);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataField.java","additions":32,"deletions":30,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.tdk.jcov.instrument.asm.ASMModifiers;\n@@ -35,1 +36,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -52,3 +52,1 @@\n-     * Method access code\n-     *\n-     * @see org.objectweb.asm.Opcodes\n+     * Container for method access code\n@@ -56,1 +54,1 @@\n-    protected final int access;\n+    protected final Modifiers access;\n@@ -106,1 +104,1 @@\n-        this.access = access;\n+        this.access = new ASMModifiers(access);\n@@ -120,7 +118,0 @@\n-     * @param k\n-     * @param access\n-     * @param name\n-     * @param desc\n-     * @param signature\n-     * @param exceptions\n-     * @param differentiateMethods\n@@ -193,2 +184,0 @@\n-     *\n-     * @see org.objectweb.asm.Opcodes\n@@ -198,1 +187,1 @@\n-        return access;\n+        return access.access();\n@@ -201,0 +190,2 @@\n+    public Modifiers getModifiers() { return access; }\n+\n@@ -214,1 +205,0 @@\n-     * @see org.objectweb.asm.Opcodes\n@@ -219,1 +209,1 @@\n-        return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED)) != 0;\n+        return isPublicAPI();\n@@ -226,1 +216,0 @@\n-     * @see org.objectweb.asm.Opcodes\n@@ -230,1 +219,1 @@\n-        return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED)) != 0;\n+        return access.isPublic() || access.isProtected();\n@@ -237,1 +226,0 @@\n-     * @see org.objectweb.asm.Opcodes\n@@ -240,0 +228,1 @@\n+    @Deprecated\n@@ -241,1 +230,1 @@\n-        return (access & Opcodes.ACC_ABSTRACT) != 0;\n+        return access.isAbstract();\n@@ -249,0 +238,1 @@\n+    @Deprecated\n@@ -250,1 +240,1 @@\n-        return (access & Opcodes.ACC_PRIVATE) != 0;\n+        return access.isPrivate();\n@@ -258,0 +248,1 @@\n+    @Deprecated\n@@ -259,1 +250,1 @@\n-        return (access & Opcodes.ACC_PUBLIC) != 0;\n+        return access.isPublic();\n@@ -267,0 +258,1 @@\n+    @Deprecated\n@@ -268,1 +260,1 @@\n-        return (access & Opcodes.ACC_PROTECTED) != 0;\n+        return access.isProtected();\n@@ -276,0 +268,1 @@\n+    @Deprecated\n@@ -277,1 +270,1 @@\n-        return (access & Opcodes.ACC_ABSTRACT) != 0;\n+        return access.isAbstract();\n@@ -285,0 +278,1 @@\n+    @Deprecated\n@@ -286,1 +280,1 @@\n-        return (access & Opcodes.ACC_STATIC) != 0;\n+        return access.isStatic();\n@@ -294,0 +288,1 @@\n+    @Deprecated\n@@ -295,1 +290,1 @@\n-        return (access & Opcodes.ACC_NATIVE) != 0;\n+        return access.isNative();\n@@ -299,1 +294,1 @@\n-     * Checks whether this method has specified modifier (by Opcodes)\n+     * Checks whether this method has specified modifier\n@@ -302,1 +297,0 @@\n-     * @see Opcodes\n@@ -305,0 +299,1 @@\n+    @Deprecated\n@@ -306,1 +301,1 @@\n-        return (access & modifierCode) != 0;\n+        return access.is(modifierCode);\n@@ -412,2 +407,2 @@\n-    void xmlGen(XmlContext ctx) {\n-        if (ctx.showAbstract || (access & Opcodes.ACC_ABSTRACT) == 0) {\n+    public void xmlGen(XmlContext ctx) {\n+        if (ctx.showAbstract || !access.isAbstract()) {\n@@ -427,1 +422,1 @@\n-        ctx.attr(XmlNames.ACCESS, access);\n+        ctx.attr(XmlNames.ACCESS, access.access());\n@@ -538,1 +533,1 @@\n-    String[] accessFlags(int access) {\n+    String[] accessFlags(Modifiers access) {\n@@ -586,1 +581,1 @@\n-        out.writeInt(access & ACCESS_MASK); \/\/ we don't save ALL the codes in XML, we shouldn't save all codes in net\n+        out.writeInt(access.access());\n@@ -606,1 +601,1 @@\n-        access = in.readInt();\n+        access = new ASMModifiers(in.readInt());\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataMethod.java","additions":33,"deletions":38,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-            void xmlAttrs(XmlContext ctx) {\n+            protected void xmlAttrs(XmlContext ctx) {\n@@ -139,1 +139,1 @@\n-            void xmlAttrs(XmlContext ctx) {\n+            protected void xmlAttrs(XmlContext ctx) {\n@@ -174,1 +174,1 @@\n-            void xmlAttrs(XmlContext ctx) {\n+            protected void xmlAttrs(XmlContext ctx) {\n@@ -252,1 +252,1 @@\n-    void xmlGen(XmlContext ctx) {\n+    public void xmlGen(XmlContext ctx) {\n@@ -320,1 +320,1 @@\n-            void xmlAttrs(XmlContext ctx) {\n+            protected void xmlAttrs(XmlContext ctx) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataMethodEntryOnly.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-                return CollectDetect.wasInvokeHit(InvokeMethodAdapter.getInvokeID(k.getFullname(), name, desc));\n+                return CollectDetect.wasInvokeHit(DataAbstract.getInvokeID(k.getFullname(), name, desc));\n@@ -118,1 +118,1 @@\n-                return CollectDetect.invokeCountFor(InvokeMethodAdapter.getInvokeID(k.getFullname(), name, desc));\n+                return CollectDetect.invokeCountFor(DataAbstract.getInvokeID(k.getFullname(), name, desc));\n@@ -123,1 +123,1 @@\n-                CollectDetect.setInvokeCountFor(InvokeMethodAdapter.getInvokeID(k.getFullname(), name, desc), count);\n+                CollectDetect.setInvokeCountFor(DataAbstract.getInvokeID(k.getFullname(), name, desc), count);\n@@ -127,1 +127,1 @@\n-            void xmlAttrs(XmlContext ctx) {\n+            protected void xmlAttrs(XmlContext ctx) {\n@@ -191,1 +191,1 @@\n-    void xmlGen(XmlContext ctx) {\n+    public void xmlGen(XmlContext ctx) {\n@@ -264,1 +264,1 @@\n-                return CollectDetect.wasInvokeHit(InvokeMethodAdapter.getInvokeID(parent.getFullname(), name, vmSig));\n+                return CollectDetect.wasInvokeHit(DataAbstract.getInvokeID(parent.getFullname(), name, vmSig));\n@@ -269,1 +269,1 @@\n-                return CollectDetect.invokeCountFor(InvokeMethodAdapter.getInvokeID(parent.getFullname(), name, vmSig));\n+                return CollectDetect.invokeCountFor(DataAbstract.getInvokeID(parent.getFullname(), name, vmSig));\n@@ -274,1 +274,1 @@\n-                CollectDetect.setInvokeCountFor(InvokeMethodAdapter.getInvokeID(parent.getFullname(), name, vmSig), count);\n+                CollectDetect.setInvokeCountFor(DataAbstract.getInvokeID(parent.getFullname(), name, vmSig), count);\n@@ -278,1 +278,1 @@\n-            void xmlAttrs(XmlContext ctx) {\n+            protected void xmlAttrs(XmlContext ctx) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataMethodInvoked.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    private CharacterRangeTableAttribute characterRangeTable = null;\n+    private CharacterRangeTable characterRangeTable = null;\n@@ -123,1 +123,1 @@\n-    public void setCharacterRangeTable(CharacterRangeTableAttribute crt) {\n+    public void setCharacterRangeTable(CharacterRangeTable crt) {\n@@ -132,1 +132,1 @@\n-    public CharacterRangeTableAttribute getCharacterRangeTable() {\n+    public CharacterRangeTable getCharacterRangeTable() {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataMethodWithBlocks.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -142,0 +142,4 @@\n+    public DataRoot() {\n+        this(\"\", true, null);\n+    }\n+\n@@ -1357,1 +1361,1 @@\n-                            for (DataBlock db : bb.blockMap.keySet()) {\n+                            for (DataBlock db : bb.blocks()) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataRoot.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -74,0 +75,2 @@\n+    private String input;\n+    private String output;\n@@ -202,0 +205,11 @@\n+    public InstrumentationPlugin filter(InstrumentationPlugin plugin) {\n+        \/\/TODO is it possible to optimize to return the original plugin\n+        \/\/in case for filtering options are provided?\n+        return new InstrumentationPlugin.FilteringPlugin(plugin) {\n+            @Override\n+            protected boolean filter(String cls) {\n+                return isIncluded(cls);\n+            }\n+        };\n+    }\n+\n@@ -230,3 +244,1 @@\n-    public InstrumentationPlugin getInstrumentationPlugin() {\n-        return plugin;\n-    }\n+    public InstrumentationPlugin getInstrumentationPlugin() { return plugin; }\n@@ -395,0 +407,10 @@\n+    public InstrumentationParams setInput(String input) {\n+        this.input = input;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setOutput(String output) {\n+        this.output = output;\n+        return this;\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationParams.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,7 @@\n-import org.objectweb.asm.MethodVisitor;\n-\n-import java.nio.file.Path;\n+import java.io.OutputStream;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n@@ -32,2 +36,1 @@\n- * SPI class which allows to do additional instrumentation, in addition to instrumentation performed by JCov by default.\n- * @author Alexander (Shura) Ilin.\n+ * TODO describe the lifecycle\n@@ -36,26 +39,102 @@\n-    \/**\n-     * Supplies a MethodVisitor to perform additional instrumentation.\n-     * @return A valid method visitor. If no instrumentation needed, must return <code>visitor<\/code> argument.\n-     *\/\n-    MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor);\n-\n-    \/**\n-     * Called after all instrumentation is complete.\n-     * @throws Exception should some\n-     *\/\n-    void instrumentationComplete() throws Exception;\n-\n-    \/**\n-     * For the instrumented code to work independently (i.e. without adding additional classes  to the classpath), some\n-     * classes can be \"implanted\" into the instrumented code.\n-     * @return Path containing the classes to be implanted. Must be in a form which can be added to Java classpath.\n-     *\/\n-    \/\/TODO perhaps this can return a list of classes to be implanted\n-    Path runtime() throws Exception;\n-\n-    \/**\n-     * Name of a package which contains code, that will be called from the instrumented\n-     * code. Such package may need to be exported from a module.\n-     * @return package name\n-     *\/\n-    String collectorPackage();\n+\n+    void instrument(Collection<String> classes, Function<String, byte[]> loader, BiConsumer<String, byte[]> saver,\n+                    InstrumentationParams parameters) throws Exception;\n+\n+    void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception;\n+\n+    \/\/TODO properly relocate the inner classes\n+\n+    abstract class FilteringPlugin implements InstrumentationPlugin {\n+        private final InstrumentationPlugin inner;\n+\n+        public FilteringPlugin(InstrumentationPlugin inner) {\n+            this.inner = inner;\n+        }\n+\n+        protected abstract boolean filter(String cls);\n+        @Override\n+        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n+                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n+            inner.instrument(classes.stream().filter(this::filter).collect(Collectors.toList()),\n+                    loader, saver, parameters);\n+        }\n+\n+        @Override\n+        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n+            inner.complete(templateStreamSupplier);\n+        }\n+    }\n+\n+    interface ModuleImplant {\n+        \/\/TODO qualified exports?\n+        List<String> exports();\n+        Collection<String> classes();\n+        Function<String, byte[]> loader();\n+    }\n+\n+    abstract class ModuleImplantingPlugin implements InstrumentationPlugin {\n+\n+        public static final String MODULE_INFO_CLASS = \"module-info.class\";\n+\n+        public interface ModuleInstrumentationPlugin extends InstrumentationPlugin {\n+            String getModuleName(byte[] moduleInfo);\n+            byte[] addExports(List<String> exports, byte[] moduleInfo);\n+        }\n+\n+        private final ModuleInstrumentationPlugin inner;\n+        private final Function<String, ModuleImplant> implants;\n+\n+        public ModuleImplantingPlugin(ModuleInstrumentationPlugin inner, Function<String, ModuleImplant> implants) {\n+            this.inner = inner;\n+            this.implants = implants;\n+        }\n+\n+        @Override\n+        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n+                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n+            inner.instrument(classes, loader, saver, parameters);\n+            String moduleName = inner.getModuleName(loader.apply(MODULE_INFO_CLASS));\n+            if(moduleName != null) {\n+                ModuleImplant implant = implants.apply(moduleName);\n+                if(implant != null) {\n+                    saver.accept(MODULE_INFO_CLASS, loader.apply(MODULE_INFO_CLASS));\n+                    for(String c : implant.classes()) saver.accept(c, implant.loader().apply(c));\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void complete(Supplier<OutputStream> template) throws Exception {\n+            inner.complete(template);\n+        }\n+    }\n+\n+    class ImplantingPlugin implements InstrumentationPlugin {\n+        private final Collection<String> implant;\n+        private final Function<String, byte[]> implantLoader;\n+        private final InstrumentationPlugin inner;\n+\n+        \/\/TODO similar to ModuleImplantingPlugin have different implants for different locations somehow?\n+        public ImplantingPlugin(InstrumentationPlugin inner,\n+                                Collection<String> implant, Function<String, byte[]> loader) {\n+            this.implant = implant;\n+            this.implantLoader = loader;\n+            this.inner = inner;\n+        }\n+\n+        @Override\n+        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n+                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n+            inner.instrument(classes, loader, saver, parameters);\n+            implant.forEach(c -> saver.accept(c, implantLoader.apply(c)));\n+        }\n+\n+        @Override\n+        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n+            inner.complete(templateStreamSupplier);\n+        }\n+\n+        protected InstrumentationPlugin inner() {\n+            return inner;\n+        }\n+    }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationPlugin.java","additions":111,"deletions":32,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov.instrument;\n-\n-import org.objectweb.asm.tree.*;\n-\n-import org.objectweb.asm.MethodVisitor;\n-import static org.objectweb.asm.Opcodes.*;\n-\n-\/**\n- * @author Dmitry Fazunenko\n- * @author Alexey Fedorchenko\n- *\/\n-class Instrumenter {\n-\n-    private static InsnList instrumentation(int id, boolean detectInternal) {\n-        return instrumentation(id, 0, 0, detectInternal);\n-    }\n-\n-    private static InsnList instrumentation(int id, int hash, int fullHash, boolean detectInternal) {\n-        InsnList il = new InsnList();\n-        if (hash != 0 || fullHash != 0) { \/\/ caller filter ON (hash & fullHash == 0 otherwise)\n-            il.add(new LdcInsnNode(id));\n-            il.add(new LdcInsnNode(hash));\n-            il.add(new LdcInsnNode(fullHash));\n-            il.add(new MethodInsnNode(INVOKESTATIC,\n-                    \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"hit\", \"(III)V\", false));\n-        } else if (detectInternal) { \/\/ agent (hardcoded by default) or loaded, false otherwise\n-            il.add(new LdcInsnNode(id));\n-            il.add(new MethodInsnNode(INVOKESTATIC,\n-                    \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"hit\", \"(I)V\", false));\n-        } else { \/\/ static\n-            il.add(new LdcInsnNode(id));\n-            il.add(new MethodInsnNode(INVOKESTATIC,\n-                    \"com\/sun\/tdk\/jcov\/runtime\/Collect\", \"hit\", \"(I)V\", false));\n-        }\n-        return il;\n-    }\n-\n-    static InsnList instrumentation(DataBlock block, boolean detectInternal) {\n-        return instrumentation(block.getId(), detectInternal);\n-    }\n-\n-    static InsnList instrumentation(SimpleBasicBlock block, boolean detectInternal) {\n-        return instrumentation(block.getId(), detectInternal);\n-    }\n-\n-    static void visitInstrumentation(final MethodVisitor mv, int id, int hash, int fullHash, boolean detectInternal) {\n-        instrumentation(id, hash, fullHash, detectInternal).accept(mv);\n-    }\n-    \/*\n-     static InsnList insertSavePoint() {\n-     InsnList il = new InsnList();\n-     il.add(new MethodInsnNode(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/Collect\",\"saveResults\", \"(V)V\"));\n-     return il;\n-     }\n-     *\/\n-}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/Instrumenter.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,291 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov.instrument;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import com.sun.tdk.jcov.util.Utils;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.tree.InsnList;\n-import org.objectweb.asm.tree.LdcInsnNode;\n-import org.objectweb.asm.tree.MethodInsnNode;\n-import static org.objectweb.asm.Opcodes.*;\n-\n-\/**\n- * @author Leonid Mesnik\n- * @author Sergey Borodin\n- *\n- * Used in dynamic instrumentation mode. It handles method invocations - sets\n- * instructions to serve caller include options (setExpected[Refl] instructions)\n- * and checks all virtual invocations. In contrast to StaticInvokeMethodAdapter,\n- * it hits CollectDetect slots and does it for all such invocations, not\n- * filtering abstract and native invocations (we do not see access flags in\n- * meth. invoke instruction)\n- *\n- *\/\n-public class InvokeMethodAdapter extends MethodVisitor {\n-\n-    static volatile int invokeCount = 0;\n-    private final String className;\n-    private final InstrumentationParams params;\n-\n-    public static int getInvokeID(String owner, String name, String descr) {\n-        String sig = owner + \".\" + name + descr;\n-        synchronized (map) {\n-            Integer id = map.get(sig);\n-            if (id != null) {\n-                return id;\n-            }\n-            \/\/return 0;\n-            id = invokeCount++;\n-            map.put(sig, id);\n-            return id;\n-        }\n-    }\n-    final private static Map<String, Integer> map =\n-            Collections.synchronizedMap(new HashMap<String, Integer>());\n-\n-    public InvokeMethodAdapter(MethodVisitor mv, String className, final InstrumentationParams params) {\n-        super(Utils.ASM_API_VERSION, mv);\n-        this.className = className;\n-        this.params = params;\n-    }\n-\n-    @Override\n-    public void visitFieldInsn(int opcode, String owner, String name, String desc) {\n-        if ((opcode == GETFIELD || opcode == GETSTATIC)\n-                && params.isInstrumentFields() && params.isIncluded(owner)\n-                && params.isCallerFilterAccept(className)) {\n-            InsnList il = new InsnList();\n-            il.add(new LdcInsnNode(getInvokeID(owner, name, desc)));\n-            il.add(new MethodInsnNode(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"invokeHit\", \"(I)V\", false));\n-            il.accept(this);\n-        }\n-        super.visitFieldInsn(opcode, owner, name, desc);\n-    }\n-\n-    @Override\n-    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n-        if (params.isCallerFilterOn()\n-                && params.isCallerFilterAccept(className)) {\n-\n-            if (ReflPair.contains(owner, name)) {\n-                \/\/handle reflection invokations\n-                visitReflectionCI(ReflPair.valueOf(owner, name));\n-            } else {\n-                int id = (name + desc).hashCode();\n-                super.visitLdcInsn(id);\n-                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"setExpected\", \"(I)V\", false);\n-            }\n-        }\n-\n-        if ((opcode == INVOKEVIRTUAL || opcode == INVOKEINTERFACE)\n-                && params.isInstrumentAbstract()\n-                && params.isIncluded(owner)\n-                && params.isCallerFilterAccept(className)) {\n-            super.visitLdcInsn(getInvokeID(owner, name, desc));\n-            super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"invokeHit\", \"(I)V\", false);\n-        }\n-        super.visitMethodInsn(opcode, owner, name, desc, itf);\n-    }\n-\n-    private enum ReflPair {\n-\n-        CLASS(\"java\/lang\/Class\", \"newInstance\"),\n-        METHOD(\"java\/lang\/reflect\/Method\", \"invoke\"),\n-        CONSTRUCTOR(\"java\/lang\/reflect\/Constructor\", \"newInstance\");\n-        private String className;\n-        private String methName;\n-\n-        ReflPair(String className, String methName) {\n-            this.className = className;\n-            this.methName = methName;\n-        }\n-\n-        private boolean isEqual(String clName, String mName) {\n-            return className.equals(clName) && methName.equals(mName);\n-        }\n-\n-        public static boolean contains(String clName, String mName) {\n-            return valueOf(clName, mName) != null;\n-        }\n-\n-        public static ReflPair valueOf(String clName, String mName) {\n-            for (ReflPair p : values()) {\n-                if (p.isEqual(clName, mName)) {\n-                    return p;\n-                }\n-            }\n-            return null;\n-\n-        }\n-    }\n-\n-    private void visitReflectionCI(ReflPair p) {\n-        if (p == null) {\n-            return;\n-        }\n-\n-        switch (p) {\n-            case CLASS:\n-                super.visitInsn(DUP);\n-\n-                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/instrument\/InvokeMethodAdapter\",\n-                        \"getMethodHash\", \"(Ljava\/lang\/Object;)I\", false);\n-                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\",\n-                        \"setExpectedFull\", \"(I)V\", false);\n-                break;\n-            case METHOD:\n-                super.visitInsn(DUP2_X1);\n-                super.visitInsn(POP);\n-                super.visitInsn(POP);\n-                super.visitInsn(DUP);\n-\n-                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/instrument\/InvokeMethodAdapter\",\n-                        \"getMethodHash\", \"(Ljava\/lang\/Object;)I\", false);\n-                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\",\n-                        \"setExpectedFull\", \"(I)V\", false);\n-                super.visitInsn(DUP_X2);\n-                super.visitInsn(POP);\n-                break;\n-            case CONSTRUCTOR:\n-                super.visitInsn(DUP2);\n-                super.visitInsn(POP);\n-\n-                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/instrument\/InvokeMethodAdapter\",\n-                        \"getMethodHash\", \"(Ljava\/lang\/Object;)I\", false);\n-                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\",\n-                        \"setExpectedFull\", \"(I)V\", false);\n-                break;\n-            default:\n-                break;\n-        }\n-    }\n-\n-    public static int getMethodHash(Object obj) {\n-        String desc = \"\";\n-        if (obj instanceof Method) {\n-            Method m = (Method) obj;\n-            Class c = m.getDeclaringClass();\n-            desc = c.getName().replace(\".\", \"\/\");\n-\n-            desc += m.getName();\n-\n-            Class[] types = m.getParameterTypes();\n-            desc += \"(\";\n-            for (Class t : types) {\n-                desc += vmType(t.getName());\n-            }\n-            desc += \")\";\n-            desc += vmType(m.getReturnType().getName());\n-        } else if (obj instanceof Constructor) {\n-            Constructor c = (Constructor) obj;\n-            Class cl = c.getDeclaringClass();\n-            desc = cl.getName().replace(\".\", \"\/\");\n-\n-            desc += \"<init>\";\n-            Class[] types = c.getParameterTypes();\n-            desc += \"(\";\n-            for (Class t : types) {\n-                desc += vmType(t.getName());\n-            }\n-            desc += \")\";\n-            desc += \"V\";\n-        } else if (obj instanceof Class) {\n-            Class c = (Class) obj;\n-            desc = c.getName().replace(\".\", \"\/\");\n-            desc += \"<init>\" + \"()V\";\n-        }\n-\n-        return desc.hashCode();\n-    }\n-\n-    private static String vmType(String type) {\n-        \/\/      [<s>  -> <s>[]      <s> is converted recursively\n-        \/\/      L<s>; -> <s>        characters '\/' are replaced by '.' in <s>\n-        \/\/      B     -> byte\n-        \/\/      C     -> char\n-        \/\/      D     -> double\n-        \/\/      F     -> float\n-        \/\/      I     -> int\n-        \/\/      J     -> long\n-        \/\/      S     -> short\n-        \/\/      Z     -> boolean\n-        \/\/      V     -> void       valid only in method return type\n-        String res = \"\";\n-        if (type.equals(\"\")) {\n-            return \"V\";\n-        }\n-\n-        while (type.endsWith(\"[]\")) {\n-            type = type.substring(0, type.length() - 2);\n-            res += \"[\";\n-        }\n-\n-        while (type.startsWith(\"[\")) {\n-            res += '[';\n-            type = type.substring(1);\n-        }\n-        if (type.equals(\"byte\")) {\n-            res += \"B\";\n-        } else if (type.equals(\"char\")) {\n-            res += \"C\";\n-        } else if (type.equals(\"double\")) {\n-            res += \"D\";\n-        } else if (type.equals(\"float\")) {\n-            res += \"F\";\n-        } else if (type.equals(\"int\")) {\n-            res += \"I\";\n-        } else if (type.equals(\"long\")) {\n-            res += \"J\";\n-        } else if (type.equals(\"short\")) {\n-            res += \"S\";\n-        } else if (type.equals(\"boolean\")) {\n-            res += \"Z\";\n-        } else if (type.equals(\"void\")) {\n-            res += \"V\";\n-        } else {\n-            type = type.replace(\".\", \"\/\");\n-            if (!type.startsWith(\"L\")) {\n-                type = \"L\" + type;\n-            }\n-            res += type;\n-            if (!type.endsWith(\";\")) {\n-                res += \";\";\n-            }\n-        }\n-\n-        return res;\n-    }\n-\n-    \/\/never used\n-    public static void addID(String className, String name, String descr, int id) {\n-        String sig = className + \".\" + name + descr;\n-        map.put(sig, id);\n-    }\n-}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InvokeMethodAdapter.java","additions":0,"deletions":291,"binary":false,"changes":291,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    void xmlAttrs(XmlContext ctx) {\n+    protected void xmlAttrs(XmlContext ctx) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/LocationAbstract.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    LocationConcrete(int rootId, int startBCI, int endBCI) {\n+    protected LocationConcrete(int rootId, int startBCI, int endBCI) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/LocationConcrete.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov.instrument;\n-\n-import com.sun.tdk.jcov.util.Utils;\n-import org.objectweb.asm.AnnotationVisitor;\n-import org.objectweb.asm.MethodVisitor;\n-\n-\/**\n- * Class that does nothing but collects runtime annotations\n- *\n- * @author Dmitry Fazunenko\n- *\/\n-class MethodAnnotationAdapter extends MethodVisitor {\n-\n-    final DataMethod meth;\n-\n-    @Override\n-    public AnnotationVisitor visitAnnotation(String anno, boolean b) {\n-        meth.addAnnotation(anno);\n-        return super.visitAnnotation(anno, b);\n-    }\n-\n-    MethodAnnotationAdapter(final MethodVisitor mv,\n-            final DataMethod method) {\n-        super(Utils.ASM_API_VERSION, mv);\n-        this.meth = method;\n-    }\n-}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/MethodAnnotationAdapter.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument;\n+\n+public interface Modifiers {\n+    boolean isPublic();\n+\n+    boolean isPrivate();\n+\n+    boolean isProtected();\n+\n+    boolean isAbstract();\n+\n+    boolean isFinal();\n+\n+    boolean isSynthetic();\n+\n+    boolean isStatic();\n+\n+    boolean isInterface();\n+\n+    boolean isSuper();\n+\n+    boolean isNative();\n+\n+    boolean isDeprecated();\n+\n+    boolean isSynchronized();\n+\n+    boolean isVolatile();\n+\n+    boolean isBridge();\n+\n+    boolean isVarargs();\n+\n+    boolean isTransient();\n+\n+    boolean isStrict();\n+\n+    boolean isAnnotation();\n+\n+    boolean isEnum();\n+\n+    int access();\n+\n+    \/**\n+     * This method is only a part of the contract to support deprecated methods.\n+     * @param code\n+     * @return\n+     * @see DataClass#hasModifier(int)\n+     * @see DataField#hasModifier(int)\n+     * @see DataMethod#hasModifier(int)\n+     *\/\n+    @Deprecated\n+    boolean is(int code);\n+\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/Modifiers.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-    void xmlGen(XmlContext ctx) {\n+    public void xmlGen(XmlContext ctx) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/SimpleBasicBlock.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.asm;\n+\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.XmlContext;\n+import com.sun.tdk.jcov.runtime.FileSaver;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * SPI class which allows to do additional instrumentation, in addition to instrumentation performed by JCov by default.\n+ * @author Alexander (Shura) Ilin.\n+ *\/\n+public class ASMInstrumentationPlugin implements InstrumentationPlugin {\n+\n+    private final DataRoot data = new DataRoot();\n+    \/\/TODO prehaps support qualified exports\n+    private List<String> exports = new ArrayList<>();\n+\n+    @Override\n+    public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n+                           BiConsumer<String, byte[]> saver, InstrumentationParams parameters) {\n+        \/\/TODO are paremeters used in serialization only?\n+        \/\/for now we have to assume that the same parameters are used for every call\n+        data.setParams(parameters);\n+        ClassMorph morph = new ClassMorph(null, data, parameters);\n+        classes.forEach(cls -> {\n+            try {\n+                \/\/TODO nulls\n+                byte[] instrumented = morph.morph(loader.apply(cls), null, null);\n+                \/\/TODO shoul never be null\n+                if(instrumented != null) saver.accept(cls, instrumented);\n+            } catch (IOException e) {\n+                \/\/todo should this even be thrown?\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void complete(Supplier<OutputStream> templateStreamSupplier) throws IOException {\n+        try (XmlContext ctx = new XmlContext(templateStreamSupplier.get(), data.getParams())) {\n+            \/\/TODO\n+            \/\/ctx.setSkipNotCoveredClasses(agentdata);\n+            data.xmlGen(ctx);\n+        }\n+    }\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ASMInstrumentationPlugin.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.asm;\n+\n+import com.sun.tdk.jcov.instrument.Modifiers;\n+import com.sun.tdk.jcov.instrument.XmlNames;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class ASMModifiers implements Modifiers {\n+    private final int access;\n+\n+    public ASMModifiers(int access) {\n+        this.access = access;\n+    }\n+\n+    @Override\n+    public int access() { return access & ACCESS_MASK; }\n+\n+    @Override\n+    public boolean is(int flag) { return (access & flag) != 0; }\n+\n+    @Override\n+    public boolean isPublic() { return is(ACC_PUBLIC); }\n+\n+    @Override\n+    public boolean isPrivate() { return is(ACC_PRIVATE); }\n+\n+    @Override\n+    public boolean isProtected() { return is(ACC_PROTECTED); }\n+\n+    @Override\n+    public boolean isAbstract() { return is(ACC_ABSTRACT); }\n+\n+    @Override\n+    public boolean isFinal() { return is(ACC_FINAL); }\n+\n+    @Override\n+    public boolean isSynthetic() { return is(ACC_SYNTHETIC); }\n+\n+    @Override\n+    public boolean isStatic() { return is(ACC_STATIC); }\n+\n+    @Override\n+    public boolean isInterface() { return is(ACC_INTERFACE); }\n+\n+    @Override\n+    public boolean isSuper() { return is(ACC_SUPER); }\n+\n+    @Override\n+    public boolean isNative() { return is(ACC_NATIVE); }\n+\n+    @Override\n+    public boolean isDeprecated() { return is(ACC_DEPRECATED); }\n+\n+    @Override\n+    public boolean isSynchronized() { return is(ACC_SYNCHRONIZED); }\n+\n+    @Override\n+    public boolean isVolatile() { return is(ACC_VOLATILE); }\n+\n+    @Override\n+    public boolean isBridge() { return is(ACC_BRIDGE); }\n+\n+    @Override\n+    public boolean isVarargs() { return is(ACC_VARARGS); }\n+\n+    @Override\n+    public boolean isTransient() { return is(ACC_TRANSIENT); }\n+\n+    @Override\n+    public boolean isStrict() { return is(ACC_STRICT); }\n+\n+    @Override\n+    public boolean isAnnotation() { return is(ACC_ANNOTATION); }\n+\n+    @Override\n+    public boolean isEnum() { return is(ACC_ENUM); }\n+\n+    public static final int ACCESS_MASK = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_FINAL | ACC_STATIC | ACC_SYNCHRONIZED\n+            | ACC_VOLATILE | ACC_BRIDGE | ACC_VARARGS | ACC_TRANSIENT | ACC_NATIVE | ACC_ABSTRACT | ACC_INTERFACE\n+            | ACC_STRICT | ACC_ANNOTATION | ACC_ENUM | ACC_SYNTHETIC | ACC_SUPER | ACC_DEPRECATED;\n+\n+    public static ASMModifiers parse(String[] modifiers) {\n+        int access = 0;\n+        for (String flag : modifiers) {\n+            if (flag.contains(XmlNames.A_PUBLIC)) access |= ACC_PUBLIC;\n+            if (flag.contains(XmlNames.A_PRIVATE)) access |= ACC_PRIVATE;\n+            if (flag.contains(XmlNames.A_PROTECTED)) access |= ACC_PROTECTED;\n+            if (flag.contains(XmlNames.A_STATIC)) access |= ACC_STATIC;\n+            if (flag.contains(XmlNames.A_FINAL)) access |= ACC_FINAL;\n+            if (flag.contains(XmlNames.A_VOLATILE)) access |= ACC_VOLATILE;\n+            if (flag.contains(XmlNames.A_BRIDGE)) access |= ACC_BRIDGE;\n+            if (flag.contains(XmlNames.A_VARARGS)) access |= ACC_VARARGS;\n+            if (flag.contains(XmlNames.A_TRANSIENT)) access |= ACC_TRANSIENT;\n+            if (flag.contains(XmlNames.A_NATIVE)) access |= ACC_NATIVE;\n+            if (flag.contains(XmlNames.A_INTERFACE) || flag.contains(XmlNames.A_DEFENDER_METH)) access |= ACC_INTERFACE;\n+            if (flag.contains(XmlNames.A_ABSTRACT)) access |= ACC_ABSTRACT;\n+            if (flag.contains(XmlNames.A_STRICT)) access |= ACC_STRICT;\n+            if (flag.contains(XmlNames.A_ANNOTATION)) access |= ACC_ANNOTATION;\n+            if (flag.contains(XmlNames.A_ENUM)) access |= ACC_ENUM;\n+            if (flag.contains(XmlNames.A_SYNTHETIC)) access |= ACC_SYNTHETIC;\n+            if (flag.contains(XmlNames.A_SYNCHRONIZED)) access |= ACC_SYNCHRONIZED;\n+        }\n+        return new ASMModifiers(access);\n+    }\n+}\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ASMModifiers.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.asm;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+public class ASMUtils {\n+    \/**\n+     * The ASM API version that should be used by jcov.\n+     *\/\n+    public static final int ASM_API_VERSION = Opcodes.ASM9;\n+\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ASMUtils.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -27,1 +27,0 @@\n-import com.sun.tdk.jcov.instrument.CharacterRangeTableAttribute.CRTEntry;\n@@ -32,0 +31,12 @@\n+import com.sun.tdk.jcov.instrument.CharacterRangeTable;\n+import com.sun.tdk.jcov.instrument.DataBlock;\n+import com.sun.tdk.jcov.instrument.DataBlockFallThrough;\n+import com.sun.tdk.jcov.instrument.DataBlockTargetDefault;\n+import com.sun.tdk.jcov.instrument.DataBranchCond;\n+import com.sun.tdk.jcov.instrument.DataBranchGoto;\n+import com.sun.tdk.jcov.instrument.DataBranchSwitch;\n+import com.sun.tdk.jcov.instrument.DataExit;\n+import com.sun.tdk.jcov.instrument.DataExitSimple;\n+import com.sun.tdk.jcov.instrument.DataMethodWithBlocks;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.SimpleBasicBlock;\n@@ -62,1 +73,1 @@\n-            bb = new SimpleBasicBlock(method.rootId, startBCI);\n+            bb = new SimpleBasicBlock(method.rootId(), startBCI);\n@@ -140,1 +151,1 @@\n-                        DataBranchCond branch = new DataBranchCond(method.rootId, bci, bciFalse - 1);\n+                        DataBranchCond branch = new DataBranchCond(method.rootId(), bci, bciFalse - 1);\n@@ -177,1 +188,1 @@\n-                        DataBranchSwitch branch = new DataBranchSwitch(method.rootId, bci, bciEnd, blockDefault);\n+                        DataBranchSwitch branch = new DataBranchSwitch(method.rootId(), bci, bciEnd, blockDefault);\n@@ -214,1 +225,1 @@\n-                        DataBranchSwitch branch = new DataBranchSwitch(method.rootId, bci, bciEnd, blockDefault);\n+                        DataBranchSwitch branch = new DataBranchSwitch(method.rootId(), bci, bciEnd, blockDefault);\n@@ -242,1 +253,1 @@\n-                        DataBranchGoto branch = new DataBranchGoto(method.rootId, bci, bciEnd);\n+                        DataBranchGoto branch = new DataBranchGoto(method.rootId(), bci, bciEnd);\n@@ -266,1 +277,1 @@\n-                        DataExit exit = new DataExitSimple(method.rootId, bci, bciNext - 1, insn.getOpcode());\n+                        DataExit exit = new DataExitSimple(method.rootId(), bci, bciNext - 1, insn.getOpcode());\n@@ -318,1 +329,1 @@\n-                for (CharacterRangeTableAttribute.CRTEntry entry : method().getCharacterRangeTable().getEntries()) {\n+                for (CharacterRangeTable.CRTEntry entry : method().getCharacterRangeTable().getEntries()) {\n@@ -321,1 +332,1 @@\n-                        if ((entry.flags & CRTEntry.CRT_STATEMENT) != 0 \/*& newBlock*\/) {\n+                        if ((entry.flags & CharacterRangeTable.CRTEntry.CRT_STATEMENT) != 0 \/*& newBlock*\/) {\n@@ -331,1 +342,1 @@\n-                        if (entry.endBCI() == index && (entry.flags & CRTEntry.CRT_FLOW_TARGET) != 0) {\n+                        if (entry.endBCI() == index && (entry.flags & CharacterRangeTable.CRTEntry.CRT_FLOW_TARGET) != 0) {\n@@ -429,1 +440,1 @@\n-            method().setCharacterRangeTable((CharacterRangeTableAttribute) attr);\n+            method().setCharacterRangeTable(((CharacterRangeTableAttribute) attr).getCrt());\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/BlockCodeMethodAdapter.java","additions":24,"deletions":13,"binary":false,"changes":37,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/BlockCodeMethodAdapter.java","status":"renamed"},{"patch":"@@ -0,0 +1,615 @@\n+\/*\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.asm;\n+\n+import com.sun.tdk.jcov.instrument.BasicBlock;\n+import java.util.*;\n+\n+import static org.objectweb.asm.Opcodes.*;\n+\n+import com.sun.tdk.jcov.instrument.CharacterRangeTable;\n+import com.sun.tdk.jcov.instrument.Constants;\n+import com.sun.tdk.jcov.instrument.DataBlock;\n+import com.sun.tdk.jcov.instrument.DataBlockCatch;\n+import com.sun.tdk.jcov.instrument.DataBlockFallThrough;\n+import com.sun.tdk.jcov.instrument.DataBlockMethEnter;\n+import com.sun.tdk.jcov.instrument.DataBlockTarget;\n+import com.sun.tdk.jcov.instrument.DataBlockTargetCase;\n+import com.sun.tdk.jcov.instrument.DataBlockTargetCond;\n+import com.sun.tdk.jcov.instrument.DataBlockTargetDefault;\n+import com.sun.tdk.jcov.instrument.DataBlockTargetGoto;\n+import com.sun.tdk.jcov.instrument.DataBranchCond;\n+import com.sun.tdk.jcov.instrument.DataBranchGoto;\n+import com.sun.tdk.jcov.instrument.DataBranchSwitch;\n+import com.sun.tdk.jcov.instrument.DataExit;\n+import com.sun.tdk.jcov.instrument.DataExitSimple;\n+import com.sun.tdk.jcov.instrument.DataMethodWithBlocks;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Attribute;\n+\n+import org.objectweb.asm.tree.*;\n+import static org.objectweb.asm.tree.AbstractInsnNode.*;\n+\n+\/**\n+ * @author Dmitry Fazunenko\n+ * @author Alexey Fedorchenko\n+ *\/\n+class BranchCodeMethodAdapter extends OffsetRecordingMethodAdapter {\n+\n+    private final MethodVisitor nextVisitor;\n+    private final List<DataExit> exits;\n+    private final List<DataBlock> src;\n+    private final Map<AbstractInsnNode, BasicBlock> insnToBB;\n+    private final InstrumentationParams params;\n+    private final Map<DataBlock, LabelNode> blockLabels;\n+\n+    public BranchCodeMethodAdapter(final MethodVisitor mv,\n+                                   final DataMethodWithBlocks method, InstrumentationParams params) {\n+        super(new MethodNode(method.getAccess(), method.getName(), method.getVmSignature(), method.getSignature(), method.getExceptions()),\n+                method);\n+        this.nextVisitor = mv;\n+        this.insnToBB = new IdentityHashMap<AbstractInsnNode, BasicBlock>();\n+        this.exits = new ArrayList<DataExit>();\n+        this.src = new ArrayList<DataBlock>();\n+        this.params = params;\n+        blockLabels = new IdentityHashMap<>();\n+    }\n+\n+    private BasicBlock getBB(AbstractInsnNode insn, int startBCI) {\n+        BasicBlock bb = insnToBB.get(insn);\n+        if (bb == null) {\n+            bb = new BasicBlock(method.rootId(), startBCI);\n+            insnToBB.put(insn, bb);\n+        } else if (startBCI >= 0) {\n+            bb.setStartBCI(startBCI);\n+        }\n+        return bb;\n+    }\n+\n+    private BasicBlock getBB(AbstractInsnNode insn) {\n+        return getBB(insn, -1);\n+    }\n+\n+    private AbstractInsnNode peek(ListIterator iit) {\n+        \/\/ Do a next() to get the next instruction..\n+        \/\/ Then immediately do a previous to restore our position.\n+        if (iit.hasNext()) {\n+            AbstractInsnNode insn = (AbstractInsnNode) iit.next();\n+            iit.previous();\n+            return insn;\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Do fix ups so that: There are unique CodeLabelNodes at the beginning of\n+     * each basic block; All branch-mode blocks hang off CodeLabelNodes Misc\n+     * info, like case values, are attached Fall throughs from one block to\n+     * another are computed\n+     *\n+     *\/\n+    private BasicBlock[] completeComputationOfCodeLabelNodes() {\n+        MethodNode methodNode = (MethodNode) mv;\n+        InsnList instructions = methodNode.instructions;\n+        int[] allToReal = new int[instructions.size()];\n+        int allIdx = 0;\n+        int insnIdx = 0;\n+        ListIterator iit = instructions.iterator();\n+\n+        \/\/ Create the method entry block and basic block\n+        AbstractInsnNode insnFirst = peek(iit);\n+        BasicBlock bbFirst = getBB(insnFirst, 0);\n+        DataBlock blockFirst = new DataBlockMethEnter(bbFirst.rootId());\n+        bbFirst.add(blockFirst);\n+\n+        while (iit.hasNext()) {\n+            AbstractInsnNode insn = (AbstractInsnNode) iit.next();\n+            allToReal[allIdx++] = insnIdx;\n+            int bci = bcis[insnIdx];\n+            int opcode = insn.getOpcode();\n+            if (opcode < 0) {\n+                \/\/ a pseudo-instruction\n+                if (insn.getType() == AbstractInsnNode.LINE) {\n+                    LineNumberNode lineNode = (LineNumberNode) insn;\n+                    method().addLineEntry(bci, lineNode.line);\n+                }\n+            } else {\n+                \/\/ a real instruction\n+                ++insnIdx; \/\/ advance the real instruction index\n+\n+                \/\/System.out.println( \"#\" + (insnIdx - 1) +\n+                \/\/        \" bci: \" + bci + \"  \" +\n+                \/\/        instr.toString().replace(\"org.objectweb.asm.tree.\", \"\").replace(\"@\", \" @ \") +\n+                \/\/        \" [\" + (opcode>=0? Constants.opcNames[opcode] : \" pseudo\") +\"]\");\n+                switch (opcode) {\n+                    case IFEQ:\n+                    case IFNE:\n+                    case IFLT:\n+                    case IFGE:\n+                    case IFGT:\n+                    case IFLE:\n+                    case IF_ICMPEQ:\n+                    case IF_ICMPNE:\n+                    case IF_ICMPLT:\n+                    case IF_ICMPGE:\n+                    case IF_ICMPGT:\n+                    case IF_ICMPLE:\n+                    case IF_ACMPEQ:\n+                    case IF_ACMPNE:\n+                    case IFNULL:\n+                    case IFNONNULL: \/\/case JSR:\n+                    {\n+                        JumpInsnNode jumpInsn = (JumpInsnNode) insn;\n+                        LabelNode insnTrue = jumpInsn.label;\n+                        int bciFalse = bcis[insnIdx]; \/\/ fall-through\n+\n+                        DataBranchCond branch = new DataBranchCond(method.rootId(), bci, bciFalse - 1);\n+                        DataBlockTarget blockTrue = new DataBlockTargetCond(branch.rootId(), true);\n+                        DataBlockTarget blockFalse = new DataBlockTargetCond(branch.rootId(), false);\n+                        branch.addTarget(blockTrue);\n+                        branch.addTarget(blockFalse);\n+\n+                        AbstractInsnNode insnFalse = peek(iit);\n+                        assert (insnFalse != null); \/\/ must be fall-through code\n+                        BasicBlock bbTrue = getBB(insnTrue);\n+                        BasicBlock bbFalse = getBB(insnFalse, bciFalse);\n+\n+                        exits.add(branch);\n+\n+                        \/\/ assign a new label for branch counting\n+                        LabelNode nlab = new LabelNode();\n+                        jumpInsn.label = nlab;  \/\/ branch to new label\n+                        bbTrue.add(blockTrue);\n+                        blockLabels.put(blockTrue, nlab);\n+\n+                        bbFalse.add(blockFalse);\n+                        break;\n+                    }\n+\n+                    case TABLESWITCH: {\n+                        TableSwitchInsnNode switchInsn = (TableSwitchInsnNode) insn;\n+\n+                        \/\/ Create a block and basic-block the \"default:\" case\n+                        LabelNode insnDflt = switchInsn.dflt;\n+                        BasicBlock bbDefault = getBB(insnDflt);\n+                        DataBlockTargetDefault blockDefault = new DataBlockTargetDefault(bbDefault.rootId());\n+\n+                        \/\/ assign a new default label for branch counting\n+                        LabelNode nlab = new LabelNode();\n+                        switchInsn.dflt = nlab;  \/\/ branch to new label\n+                        bbDefault.add(blockDefault);\n+                        blockLabels.put(blockDefault, nlab);\n+\n+                        \/\/ Create the branch information\n+                        int bciEnd = bcis[insnIdx] - 1; \/\/ end of the switch\n+                        DataBranchSwitch branch = new DataBranchSwitch(method.rootId(), bci, bciEnd, blockDefault);\n+                        branch.addTarget(blockDefault);\n+                        exits.add(branch);\n+\n+                        \/\/ Process the other cases\n+                        ListIterator lit = switchInsn.labels.listIterator();\n+                        int key = switchInsn.min;\n+                        while (lit.hasNext()) {\n+                            \/\/ Create a block and basic-block the case\n+                            LabelNode labCase = (LabelNode) lit.next();\n+                            BasicBlock bbCase = getBB(labCase);\n+                            DataBlockTargetCase blockCase = new DataBlockTargetCase(bbCase.rootId(), key++);\n+                            branch.addTarget(blockCase);\n+\n+                            \/\/ assign a new label to the case for branch counting\n+                            nlab = new LabelNode();\n+                            lit.set(nlab);\n+                            bbCase.add(blockCase);\n+                            blockLabels.put(blockCase, nlab);\n+                        }\n+                        break;\n+                    }\n+\n+                    case LOOKUPSWITCH: {\n+                        LookupSwitchInsnNode switchInsn = (LookupSwitchInsnNode) insn;\n+\n+                        \/\/ Create a block and basic-block the \"default:\" case\n+                        LabelNode insnDflt = switchInsn.dflt;\n+                        BasicBlock bbDefault = getBB(insnDflt);\n+                        DataBlockTargetDefault blockDefault = new DataBlockTargetDefault(bbDefault.rootId());\n+\n+                        \/\/ assign a new default label for branch counting\n+                        LabelNode nlab = new LabelNode();\n+                        switchInsn.dflt = nlab;  \/\/ branch to new label\n+                        bbDefault.add(blockDefault);\n+                        blockLabels.put(blockDefault, nlab);\n+\n+                        \/\/ Create the branch information\n+                        int bciEnd = bcis[insnIdx] - 1; \/\/ end of the switch\n+                        DataBranchSwitch branch = new DataBranchSwitch(method.rootId(), bci, bciEnd, blockDefault);\n+                        branch.addTarget(blockDefault);\n+                        exits.add(branch);\n+\n+                        \/\/ Process the other cases\n+                        ListIterator kit = switchInsn.keys.listIterator();\n+                        ListIterator lit = switchInsn.labels.listIterator();\n+                        while (lit.hasNext()) {\n+                            \/\/ Create a block and basic-block the case\n+                            LabelNode labCase = (LabelNode) lit.next();\n+                            BasicBlock bbCase = getBB(labCase);\n+                            Integer key = (Integer) kit.next();\n+                            DataBlockTargetCase blockCase = new DataBlockTargetCase(branch.rootId(), key.intValue());\n+                            branch.addTarget(blockCase);\n+\n+                            \/\/ assign a new label to the case for branch counting\n+                            nlab = new LabelNode();\n+                            lit.set(nlab);\n+                            bbCase.add(blockCase);\n+                            blockLabels.put(blockCase, nlab);\n+                        }\n+                        break;\n+                    }\n+\n+                    case GOTO: {\n+                        JumpInsnNode jumpInsn = (JumpInsnNode) insn;\n+\n+                        \/\/ Create origin info, a branch\n+                        int bciEnd = bcis[insnIdx] - 1;\n+                        DataBranchGoto branch = new DataBranchGoto(method.rootId(), bci, bciEnd);\n+                        exits.add(branch);\n+\n+                        \/\/ Create destination info, a block target\n+                        LabelNode insnTarget = jumpInsn.label;\n+                        BasicBlock bbTarget = getBB(insnTarget);\n+                        DataBlockTarget blockTarget = new DataBlockTargetGoto(bbTarget.rootId());\n+                        branch.addTarget(blockTarget);\n+\n+                        \/\/ assign a new label for branch counting\n+                        LabelNode nlab = new LabelNode();\n+                        jumpInsn.label = nlab;  \/\/ branch to new label\n+                        bbTarget.add(blockTarget);\n+                        blockLabels.put(blockTarget, nlab);\n+                        break;\n+                    }\n+                    case ATHROW:\n+                    case RET:\n+                    case IRETURN:\n+                    case LRETURN:\n+                    case FRETURN:\n+                    case DRETURN:\n+                    case ARETURN:\n+                    case RETURN: {\n+                        int bciNext = bcis[insnIdx];\n+                        DataExit exit = new DataExitSimple(method.rootId(), bci, bciNext - 1, insn.getOpcode());\n+                        exits.add(exit);\n+\n+                        AbstractInsnNode insnNext = peek(iit);\n+                        if (insnNext != null) {\n+                            \/\/ If there is code after this, it has to be the start of a\n+                            \/\/ new basic block\n+                            getBB(insnNext, bciNext);\n+                        }\n+                        break;\n+                    }\n+                    default:\n+                        break;\n+                }\n+                \/\/ try add src block\n+            }\n+        }\n+\n+        \/\/ Now go through the try-catch blocks\n+        LabelNode previousHandler = null;\n+        for (Iterator tbit = methodNode.tryCatchBlocks.iterator(); tbit.hasNext();) {\n+            TryCatchBlockNode tcbn = (TryCatchBlockNode) tbit.next();\n+            LabelNode insnHandler = tcbn.handler;\n+            if (insnHandler != previousHandler) {\n+                previousHandler = insnHandler;\n+\n+                \/\/ Create destination info, a block target\n+                BasicBlock bbCatch = getBB(insnHandler);\n+                DataBlockCatch blockCatch = new DataBlockCatch(bbCatch.rootId());\n+\n+                \/\/ assign a new label for catch counting\n+                LabelNode nlab = new LabelNode();\n+                tcbn.handler = nlab;  \/\/ change handler\n+                bbCatch.add(blockCatch);\n+                blockLabels.put(blockCatch, nlab);\n+            }\n+        }\n+        if (method().getCharacterRangeTable() != null) {\n+            boolean newBlock = true;\n+            int skip = 0;\n+            iit = instructions.iterator();\n+            while (iit.hasNext()) {\n+                AbstractInsnNode insn = (AbstractInsnNode) iit.next();\n+                int index = instructions.indexOf(insn);\n+                int bci = bcis[allToReal[index]];\n+                if (bci == skip) {\n+                    continue;\n+                }\n+\n+                if (insnToBB.get(insn) != null) {\n+                    skip = bcis[allToReal[ instructions.indexOf(insn)]];\n+                }\n+\n+                if (insn.getOpcode() < 0) {\n+                    continue;\n+                }\n+\n+                for (CharacterRangeTable.CRTEntry entry : method().getCharacterRangeTable().getEntries()) {\n+                    if (entry.startBCI() == bci) {\n+\n+                        if ((entry.flags & CharacterRangeTable.CRTEntry.CRT_STATEMENT) != 0 \/*& newBlock*\/) {\n+                            newBlock = false;\n+                            if (insnToBB.get(insn) == null) {\n+                                \/\/System.out.println(\"Should add block at: \" + bci + \" in \" + method().name +\n+                                \/\/       \" for \" + Constants.opcNames[insn.getOpcode()]);\n+                                getBB(insn);\n+                                break;\n+                            }\n+                        }\n+                    } else {\n+                        if (entry.endBCI() == index && (entry.flags & CharacterRangeTable.CRTEntry.CRT_FLOW_TARGET) != 0) {\n+                            newBlock = true;\n+                        }\n+                    }\n+\n+                }\n+            }\n+\n+        }\n+\n+        \/\/ Compute the startBCI for any basic blocks that don't have it'\n+        BasicBlock[] basicBlocks = new BasicBlock[insnToBB.size()];\n+        int i = 0;\n+        for (Map.Entry<AbstractInsnNode, BasicBlock> entry : insnToBB.entrySet()) {\n+            BasicBlock bb = entry.getValue();\n+\n+            if (bb.startBCI() < 0) {\n+                AbstractInsnNode insn = entry.getKey();\n+                int index = instructions.indexOf(insn);\n+                int bci = bcis[allToReal[index]];\n+                bb.setStartBCI(bci);\n+            }\n+            basicBlocks[i++] = bb;\n+        }\n+        Arrays.sort(basicBlocks);\n+\n+        return basicBlocks;\n+    }\n+\n+    \/**\n+     * Compute end BCIs for basic blocks, then set this info into detail blocks.\n+     * Assumes the basic blocks are sorted\n+     *\/\n+    private void computeEndBCIsAndFoldInExits(BasicBlock[] basicBlocks) {\n+        int ei = 0;  \/\/ exit index\n+        BasicBlock prev = basicBlocks[0];\n+        for (int bi = 1; bi <= basicBlocks.length; ++bi) {\n+            BasicBlock curr = null;\n+            int start;\n+            if (bi == basicBlocks.length) {\n+                start = method().getBytecodeLength();\n+            } else {\n+                curr = basicBlocks[bi];\n+                start = curr.startBCI();\n+            }\n+\n+            int prevStart = prev.startBCI();\n+            \/\/ Set the previous block to end just before the current starts\n+            int prevEnd = start - 1;\n+            prev.setEndBCI(prevEnd);\n+\n+            \/\/ Now that we know the endBCI, we can determine if\n+            \/\/ any exits reside in this range\n+            DataExit exit = null;\n+            int exitStart;\n+            if (ei < exits.size()) {\n+                exit = exits.get(ei);\n+                exitStart = exit.startBCI();\n+            } else {\n+                exitStart = -1; \/\/ always go to the fall-into code\n+            }\n+            if (exitStart >= prevStart && exitStart <= prevEnd) {\n+                \/\/ The exit is in the prev block attach it\n+                prev.setExit(exit);\n+                \/\/ System.out.println(\"found \" + ei + \" BB: \" + prev + \" exit: \" + exit);\n+                ++ei;  \/\/ set-up to handle the next exit\n+            } else {\n+                \/\/ There is no exit from the prev block, so we fall\n+                \/\/ into the curr block (if any)\n+                if (curr != null) {\n+                    DataBlock fall = new DataBlockFallThrough(curr.rootId());\n+                    curr.add(fall);\n+                }\n+            }\n+\n+            prev = curr;\n+        }\n+        \/\/ System.out.println(\"ei: \" + ei + \" \/ \" + exits.size());\n+        assert (ei == exits.size());\n+    }\n+\n+    private void insertInstrumentation() {\n+        MethodNode methodNode = (MethodNode) mv;\n+        InsnList instructions = methodNode.instructions;\n+\n+        for (Map.Entry<AbstractInsnNode, BasicBlock> entry : insnToBB.entrySet()) {\n+            \/\/ Basic block 'bb' starts at instruction 'insn'\n+            AbstractInsnNode insn = entry.getKey();\n+            BasicBlock bb = entry.getValue();\n+\n+            \/\/ Get the entry blocks for this basic block\n+            Collection<DataBlock> blocks = bb.blocks();\n+            int remaining = blocks.size();\n+            LabelNode realStuff = null;\n+            if (remaining > 1) {\n+                \/\/ There are two or more entries to this block.\n+                \/\/ We will need a label to jump over the other entries.\n+                realStuff = new LabelNode();\n+            }\n+            \/\/ any fallen into entry blocks must be instrumented first (no label\n+            \/\/ switching was done for them.\n+            DataBlock fallenInto = bb.fallenInto();\n+            if (fallenInto != null) {\n+                assert (blockLabels.get(fallenInto) == null);\n+                instructions.insertBefore(insn, Instrumenter.instrumentation(fallenInto, params.isDetectInternal()));\n+                if (--remaining > 0) {\n+                    \/\/ jump over the next instrumentation of this basic block\n+                    instructions.insertBefore(insn, new JumpInsnNode(GOTO, realStuff));\n+                }\n+            }\n+\n+            \/\/ Process the other entry blocks\n+            for (DataBlock block : blocks) {\n+                if (!block.isFallenInto()) {\n+                    \/\/ insert the label\n+                    LabelNode lnode = blockLabels.get(block);\n+                    assert (lnode != null);\n+\n+                    \/\/ insert created label\n+                    instructions.insertBefore(insn, lnode);\n+\n+                    \/\/ insert the instrumentation\n+                    instructions.insertBefore(insn, Instrumenter.instrumentation(block, params.isDetectInternal()));\n+                    if (--remaining > 0) {\n+                        \/\/ jump over the next instrumentation of this basic block\n+                        instructions.insertBefore(insn, new JumpInsnNode(GOTO, realStuff));\n+                    }\n+                }\n+            }\n+            if (realStuff != null) {\n+                \/\/ insert label for the real code\n+                instructions.insertBefore(insn, realStuff);\n+            }\n+\n+            assert (remaining == 0);\n+        }\n+    }\n+\n+    @Override\n+    public void visitAttribute(Attribute attr) {\n+        super.visitAttribute(attr);\n+        if (attr instanceof CharacterRangeTableAttribute) {\n+            method().setCharacterRangeTable(((CharacterRangeTableAttribute) attr).getCrt());\n+        }\n+    }\n+\n+\/\/ the instruction list has been built, insert the instrumentation\n+    @Override\n+    public void visitEnd() {\n+        super.visitEnd();\n+\n+        BasicBlock[] basicBlocks = completeComputationOfCodeLabelNodes();\n+        computeEndBCIsAndFoldInExits(basicBlocks);\n+        \/\/debugDump();\n+        insertInstrumentation();\n+        method().setBasicBlocks(basicBlocks);\n+\n+        \/\/ push the result to the writer\n+        MethodNode methodNode = (MethodNode) mv;\n+        methodNode.accept(nextVisitor);\n+    }\n+\n+    private void debugDump() {\n+        \/* Opcode Names *\/\n+\n+        MethodNode methodNode = (MethodNode) mv;\n+        InsnList instructions = methodNode.instructions;\n+        ListIterator iit = instructions.iterator();\n+\n+        System.out.println(methodNode.name + \"  ----\");\n+        while (iit.hasNext()) {\n+            AbstractInsnNode instr = (AbstractInsnNode) iit.next();\n+            int opcode = instr.getOpcode();\n+            if (opcode >= 0) {\n+                System.out.print(\"        \");\n+                System.out.print(Constants.opcNames[opcode]);\n+                System.out.print(\"  \");\n+            }\n+            switch (instr.getType()) {\n+                case LINE:\n+                    System.out.print(((LineNumberNode) instr).line);\n+                    System.out.print(\"#\");\n+                    break;\n+                case LABEL:\n+                    System.out.print(labelString(((LabelNode) instr)));\n+                    System.out.print(\":\");\n+                    break;\n+                case FRAME:\n+                    System.out.print(\"frame-\");\n+                    break;\n+                case JUMP_INSN:\n+                    System.out.print(labelString(((JumpInsnNode) instr).label));\n+                    break;\n+                case LOOKUPSWITCH: {\n+                    LookupSwitchInsnNode node = (LookupSwitchInsnNode) instr;\n+                    System.out.println();\n+                    System.out.print(\"            default: \");\n+                    System.out.print(labelString(node.dflt));\n+                    int len = node.labels.size();\n+                    for (int i = 0; i < len; ++i) {\n+                        LabelNode lnode = (LabelNode) (node.labels.get(i));\n+                        Integer key = (Integer) (node.keys.get(i));\n+                        System.out.println();\n+                        System.out.print(\"            \");\n+                        System.out.print(key);\n+                        System.out.print(\": \");\n+                        System.out.print(labelString(lnode));\n+                    }\n+                    break;\n+                }\n+                case TABLESWITCH_INSN: {\n+                    TableSwitchInsnNode node = (TableSwitchInsnNode) instr;\n+                    System.out.println();\n+                    System.out.print(\"            default: \");\n+                    System.out.print(labelString(node.dflt));\n+                    int len = node.labels.size();\n+                    int key = node.min;\n+                    for (int i = 0; i < len; ++i) {\n+                        LabelNode lnode = (LabelNode) (node.labels.get(i));\n+                        System.out.println();\n+                        System.out.print(\"            \");\n+                        System.out.print(key++);\n+                        System.out.print(\": \");\n+                        System.out.print(labelString(lnode));\n+                    }\n+                    break;\n+                }\n+                default:\n+                    break;\n+            }\n+            if (insnToBB.get(instr) != null) {\n+                System.out.println(\"  block [\" + insnToBB.get(instr).startBCI()\n+                        + \", \" + insnToBB.get(instr).endBCI() + \"]\");\n+            } else {\n+                System.out.println();\n+            }\n+        }\n+    }\n+\n+    private String labelString(LabelNode lnode) {\n+        Label lab = lnode.getLabel();\n+        return lab.toString();\n+    }\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/BranchCodeMethodAdapter.java","additions":615,"deletions":0,"binary":false,"changes":615,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.asm;\n+\n+import com.sun.tdk.jcov.instrument.CharacterRangeTable;\n+import com.sun.tdk.jcov.instrument.CharacterRangeTable.CRTEntry;\n+import org.objectweb.asm.Attribute;\n+import org.objectweb.asm.ByteVector;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.Label;\n+\n+\/**\n+ * CharacterRangeTableAttribute\n+ *\n+ *\n+ *\n+ * @author Robert Field\n+ *\/\n+public class CharacterRangeTableAttribute extends Attribute {\n+\n+    private CharacterRangeTable crt;\n+\n+    CharacterRangeTableAttribute(CharacterRangeTable crt) {\n+        super(\"CharacterRangeTable\");\n+        this.crt = crt;\n+    }\n+\n+    public CharacterRangeTable getCrt() {\n+        return crt;\n+    }\n+\n+    @Override\n+    public boolean isUnknown() {\n+        return false;\n+    }\n+\n+    void put(CRTEntry entry, ByteVector bv) {\n+        bv.putShort(entry.startBCI());\n+        bv.putShort(entry.endBCI());\n+        bv.putInt(entry.char_start);\n+        bv.putInt(entry.char_end);\n+        bv.putShort(entry.flags);\n+    }\n+\n+    @Override\n+    protected Attribute read(ClassReader cr, int off, int len,\n+            char[] buf, int codeOff, Label[] labels) {\n+        int length = cr.readShort(off);\n+        CRTEntry[] entries = new CRTEntry[length];\n+        for (int i = 0; i < length; ++i) {\n+            int eoff = off + 2 + (i * 14);\n+            int start_pc = cr.readShort(eoff + 0);\n+            int end_pc = cr.readShort(eoff + 2);\n+            int char_start = cr.readInt(eoff + 4);\n+            int char_end = cr.readInt(eoff + 8);\n+            int flags = cr.readShort(eoff + 12);\n+            entries[i] = new CRTEntry(crt.getRootId(), start_pc, end_pc, char_start, char_end, flags);\n+        }\n+        return new CharacterRangeTableAttribute(new CharacterRangeTable(crt.getRootId(), length, entries));\n+    }\n+\n+    @Override\n+    protected ByteVector write(ClassWriter cw, byte[] code, int len,\n+            int maxStack, int maxLocals) {\n+        ByteVector bv = new ByteVector();\n+        bv.putShort(crt.length);\n+        for (CRTEntry entry : crt.entries) {\n+            put(entry, bv);\n+        }\n+        return bv;\n+    }\n+\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/CharacterRangeTableAttribute.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -28,0 +28,14 @@\n+import com.sun.tdk.jcov.instrument.BasicBlock;\n+import com.sun.tdk.jcov.instrument.CharacterRangeTable;\n+import com.sun.tdk.jcov.instrument.DataBlock;\n+import com.sun.tdk.jcov.instrument.DataClass;\n+import com.sun.tdk.jcov.instrument.DataField;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataMethodEntryOnly;\n+import com.sun.tdk.jcov.instrument.DataMethodInvoked;\n+import com.sun.tdk.jcov.instrument.DataMethodWithBlocks;\n+import com.sun.tdk.jcov.instrument.DataPackage;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.XmlNames;\n@@ -34,0 +48,8 @@\n+import org.objectweb.asm.Attribute;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.ModuleVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.util.TraceClassVisitor;\n+\n@@ -38,0 +60,1 @@\n+import java.util.List;\n@@ -42,5 +65,0 @@\n-import org.objectweb.asm.Attribute;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.util.TraceClassVisitor;\n@@ -124,2 +142,2 @@\n-                && !isAlreadyTransformed(className)\n-                && params.isIncluded(className);\n+                && !isAlreadyTransformed(className);\n+                \/\/&& params.isIncluded(className);\n@@ -182,3 +200,3 @@\n-                if (!params.isIncluded(fullname)) {\n-                    logger.log(Level.INFO, \"{0} - skipped (is not included or is excluded explicitly)\", fullname);\n-                }\n+\/\/                if (!params.isIncluded(fullname)) {\n+\/\/                    logger.log(Level.INFO, \"{0} - skipped (is not included or is excluded explicitly)\", fullname);\n+\/\/                }\n@@ -223,1 +241,1 @@\n-            moduleName = \"module \"+XmlNames.NO_MODULE;\n+            moduleName = \"module \"+ XmlNames.NO_MODULE;\n@@ -257,1 +275,2 @@\n-        cr.accept(cv, new Attribute[]{new CharacterRangeTableAttribute(root.rootId())}, 0);\n+        cr.accept(cv,\n+                new Attribute[]{new CharacterRangeTableAttribute(new CharacterRangeTable(root.rootId()))}, 0);\n@@ -281,0 +300,31 @@\n+    public byte[] clearHashes(byte[] moduleInfo, ClassLoader loader) {\n+        ClassReader cr = new ClassReader(moduleInfo);\n+        ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, loader);\n+        cr.accept( new ClassVisitor(ASMUtils.ASM_API_VERSION, cw) {\n+            @Override\n+            public void visitAttribute(final Attribute attribute) {\n+                if (!attribute.type.equals(\"ModuleHashes\")) {\n+                    super.visitAttribute(attribute);\n+                }\n+            }\n+        }, 0);\n+        return cw.toByteArray();\n+    }\n+\n+    public byte[] addExports(byte[] moduleInfo, List<String> exports, ClassLoader loader) {\n+        ClassReader cr = new ClassReader(moduleInfo);\n+        ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, loader);\n+        cr.accept( new ClassVisitor(ASMUtils.ASM_API_VERSION, cw) {\n+            @Override\n+            public ModuleVisitor visitModule(String name, int access, String version) {\n+                ModuleVisitor mv = super.visitModule(name, access, version);\n+                exports.forEach(e -> {\n+                    mv.visitPackage(e);\n+                    mv.visitExport(e, 0);\n+                });\n+                return mv;\n+            }\n+        }, 0);\n+        return cw.toByteArray();\n+    }\n+\n@@ -589,2 +639,1 @@\n-                        if (meth.access(meth.getAccess()).matches(\".*abstract.*\")\n-                                || meth.access(meth.getAccess()).matches(\".*native.*\")) {\n+                        if (meth.getModifiers().isAbstract() || meth.getModifiers().isNative()) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ClassMorph.java","additions":64,"deletions":15,"binary":false,"changes":79,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/ClassMorph.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -27,0 +27,2 @@\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ClassMorph2.java","additions":4,"deletions":2,"binary":false,"changes":6,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/ClassMorph2.java","status":"renamed"},{"patch":"@@ -25,2 +25,10 @@\n-package com.sun.tdk.jcov.instrument;\n-\n+package com.sun.tdk.jcov.instrument.asm;\n+\n+import com.sun.tdk.jcov.instrument.DataClass;\n+import com.sun.tdk.jcov.instrument.DataField;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataMethodEntryOnly;\n+import com.sun.tdk.jcov.instrument.DataMethodInvoked;\n+import com.sun.tdk.jcov.instrument.DataMethodWithBlocks;\n+import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n@@ -34,1 +42,0 @@\n-import static java.lang.String.format;\n@@ -39,1 +46,0 @@\n-import java.util.logging.Level;\n@@ -54,1 +60,1 @@\n-        super(Utils.ASM_API_VERSION, cv);\n+        super(ASMUtils.ASM_API_VERSION, cv);\n@@ -67,1 +73,1 @@\n-        dataClass.setInfo(access, signature, superName, interfaces);\n+        dataClass.setInfo(new ASMModifiers(access), signature, superName, interfaces);\n@@ -191,1 +197,1 @@\n-            mv = new MethodVisitor(Utils.ASM_API_VERSION, mv) {\n+            mv = new MethodVisitor(ASMUtils.ASM_API_VERSION, mv) {\n@@ -233,1 +239,1 @@\n-        mv = new MethodVisitor(Utils.ASM_API_VERSION, mv) {\n+        mv = new MethodVisitor(ASMUtils.ASM_API_VERSION, mv) {\n@@ -245,3 +251,3 @@\n-        InstrumentationPlugin plugin = params.getInstrumentationPlugin();\n-        if (plugin != null)\n-            mv = plugin.methodVisitor(access, dataClass.getFullname(), methodName, desc, mv);\n+        ASMInstrumentationPlugin plugin = (ASMInstrumentationPlugin) params.getInstrumentationPlugin();\n+\/\/        if (plugin != null)\n+\/\/            mv = plugin.methodVisitor(access, dataClass.getFullname(), methodName, desc, mv);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/DeferringMethodClassAdapter.java","additions":17,"deletions":11,"binary":false,"changes":28,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DeferringMethodClassAdapter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -27,0 +27,2 @@\n+import com.sun.tdk.jcov.instrument.DataMethodEntryOnly;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n@@ -46,1 +48,1 @@\n-        super(Utils.ASM_API_VERSION, mv);\n+        super(ASMUtils.ASM_API_VERSION, mv);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/EntryCodeMethodAdapter.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/EntryCodeMethodAdapter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -27,0 +27,1 @@\n+import com.sun.tdk.jcov.instrument.DataField;\n@@ -43,1 +44,1 @@\n-        super(Utils.ASM_API_VERSION, fv);\n+        super(ASMUtils.ASM_API_VERSION, fv);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/FieldAnnotationVisitor.java","additions":4,"deletions":3,"binary":false,"changes":7,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/FieldAnnotationVisitor.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -47,1 +47,1 @@\n-            super(Utils.ASM_API_VERSION);\n+            super(ASMUtils.ASM_API_VERSION);\n@@ -92,1 +92,1 @@\n-        super(Utils.ASM_API_VERSION);\n+        super(ASMUtils.ASM_API_VERSION);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ForkingMethodAdapter.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/ForkingMethodAdapter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -48,1 +48,1 @@\n-        super(Utils.ASM_API_VERSION, cv);\n+        super(ASMUtils.ASM_API_VERSION, cv);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/InstrumentedAttributeClassAdapter.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentedAttributeClassAdapter.java","status":"renamed"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.asm;\n+\n+import com.sun.tdk.jcov.instrument.DataBlock;\n+import com.sun.tdk.jcov.instrument.SimpleBasicBlock;\n+import org.objectweb.asm.tree.*;\n+\n+import org.objectweb.asm.MethodVisitor;\n+import static org.objectweb.asm.Opcodes.*;\n+\n+\/**\n+ * @author Dmitry Fazunenko\n+ * @author Alexey Fedorchenko\n+ *\/\n+class Instrumenter {\n+\n+    private static InsnList instrumentation(int id, boolean detectInternal) {\n+        return instrumentation(id, 0, 0, detectInternal);\n+    }\n+\n+    private static InsnList instrumentation(int id, int hash, int fullHash, boolean detectInternal) {\n+        InsnList il = new InsnList();\n+        if (hash != 0 || fullHash != 0) { \/\/ caller filter ON (hash & fullHash == 0 otherwise)\n+            il.add(new LdcInsnNode(id));\n+            il.add(new LdcInsnNode(hash));\n+            il.add(new LdcInsnNode(fullHash));\n+            il.add(new MethodInsnNode(INVOKESTATIC,\n+                    \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"hit\", \"(III)V\", false));\n+        } else if (detectInternal) { \/\/ agent (hardcoded by default) or loaded, false otherwise\n+            il.add(new LdcInsnNode(id));\n+            il.add(new MethodInsnNode(INVOKESTATIC,\n+                    \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"hit\", \"(I)V\", false));\n+        } else { \/\/ static\n+            il.add(new LdcInsnNode(id));\n+            il.add(new MethodInsnNode(INVOKESTATIC,\n+                    \"com\/sun\/tdk\/jcov\/runtime\/Collect\", \"hit\", \"(I)V\", false));\n+        }\n+        return il;\n+    }\n+\n+    public static InsnList instrumentation(DataBlock block, boolean detectInternal) {\n+        return instrumentation(block.getId(), detectInternal);\n+    }\n+\n+    public static InsnList instrumentation(SimpleBasicBlock block, boolean detectInternal) {\n+        return instrumentation(block.getId(), detectInternal);\n+    }\n+\n+    static void visitInstrumentation(final MethodVisitor mv, int id, int hash, int fullHash, boolean detectInternal) {\n+        instrumentation(id, hash, fullHash, detectInternal).accept(mv);\n+    }\n+    \/*\n+     static InsnList insertSavePoint() {\n+     InsnList il = new InsnList();\n+     il.add(new MethodInsnNode(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/Collect\",\"saveResults\", \"(V)V\"));\n+     return il;\n+     }\n+     *\/\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/Instrumenter.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -27,0 +27,1 @@\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n@@ -41,1 +42,1 @@\n-        super(Utils.ASM_API_VERSION, cv);\n+        super(ASMUtils.ASM_API_VERSION, cv);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/InvokeClassAdapter.java","additions":4,"deletions":3,"binary":false,"changes":7,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InvokeClassAdapter.java","status":"renamed"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.asm;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+\n+import com.sun.tdk.jcov.instrument.DataAbstract;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.tree.InsnList;\n+import org.objectweb.asm.tree.LdcInsnNode;\n+import org.objectweb.asm.tree.MethodInsnNode;\n+import static org.objectweb.asm.Opcodes.*;\n+\n+\/**\n+ * @author Leonid Mesnik\n+ * @author Sergey Borodin\n+ *\n+ * Used in dynamic instrumentation mode. It handles method invocations - sets\n+ * instructions to serve caller include options (setExpected[Refl] instructions)\n+ * and checks all virtual invocations. In contrast to StaticInvokeMethodAdapter,\n+ * it hits CollectDetect slots and does it for all such invocations, not\n+ * filtering abstract and native invocations (we do not see access flags in\n+ * meth. invoke instruction)\n+ *\n+ *\/\n+public class InvokeMethodAdapter extends MethodVisitor {\n+\n+    private final String className;\n+    private final InstrumentationParams params;\n+\n+    public InvokeMethodAdapter(MethodVisitor mv, String className, final InstrumentationParams params) {\n+        super(ASMUtils.ASM_API_VERSION, mv);\n+        this.className = className;\n+        this.params = params;\n+    }\n+\n+    @Override\n+    public void visitFieldInsn(int opcode, String owner, String name, String desc) {\n+        if ((opcode == GETFIELD || opcode == GETSTATIC)\n+                && params.isInstrumentFields() && params.isIncluded(owner)\n+                && params.isCallerFilterAccept(className)) {\n+            InsnList il = new InsnList();\n+            il.add(new LdcInsnNode(DataAbstract.getInvokeID(owner, name, desc)));\n+            il.add(new MethodInsnNode(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"invokeHit\", \"(I)V\", false));\n+            il.accept(this);\n+        }\n+        super.visitFieldInsn(opcode, owner, name, desc);\n+    }\n+\n+    @Override\n+    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+        if (params.isCallerFilterOn()\n+                && params.isCallerFilterAccept(className)) {\n+\n+            if (ReflPair.contains(owner, name)) {\n+                \/\/handle reflection invokations\n+                visitReflectionCI(ReflPair.valueOf(owner, name));\n+            } else {\n+                int id = (name + desc).hashCode();\n+                super.visitLdcInsn(id);\n+                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"setExpected\", \"(I)V\", false);\n+            }\n+        }\n+\n+        if ((opcode == INVOKEVIRTUAL || opcode == INVOKEINTERFACE)\n+                && params.isInstrumentAbstract()\n+                && params.isIncluded(owner)\n+                && params.isCallerFilterAccept(className)) {\n+            super.visitLdcInsn(DataAbstract.getInvokeID(owner, name, desc));\n+            super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"invokeHit\", \"(I)V\", false);\n+        }\n+        super.visitMethodInsn(opcode, owner, name, desc, itf);\n+    }\n+\n+    private enum ReflPair {\n+\n+        CLASS(\"java\/lang\/Class\", \"newInstance\"),\n+        METHOD(\"java\/lang\/reflect\/Method\", \"invoke\"),\n+        CONSTRUCTOR(\"java\/lang\/reflect\/Constructor\", \"newInstance\");\n+        private String className;\n+        private String methName;\n+\n+        ReflPair(String className, String methName) {\n+            this.className = className;\n+            this.methName = methName;\n+        }\n+\n+        private boolean isEqual(String clName, String mName) {\n+            return className.equals(clName) && methName.equals(mName);\n+        }\n+\n+        public static boolean contains(String clName, String mName) {\n+            return valueOf(clName, mName) != null;\n+        }\n+\n+        public static ReflPair valueOf(String clName, String mName) {\n+            for (ReflPair p : values()) {\n+                if (p.isEqual(clName, mName)) {\n+                    return p;\n+                }\n+            }\n+            return null;\n+\n+        }\n+    }\n+\n+    private void visitReflectionCI(ReflPair p) {\n+        if (p == null) {\n+            return;\n+        }\n+\n+        switch (p) {\n+            case CLASS:\n+                super.visitInsn(DUP);\n+\n+                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/instrument\/InvokeMethodAdapter\",\n+                        \"getMethodHash\", \"(Ljava\/lang\/Object;)I\", false);\n+                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\",\n+                        \"setExpectedFull\", \"(I)V\", false);\n+                break;\n+            case METHOD:\n+                super.visitInsn(DUP2_X1);\n+                super.visitInsn(POP);\n+                super.visitInsn(POP);\n+                super.visitInsn(DUP);\n+\n+                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/instrument\/InvokeMethodAdapter\",\n+                        \"getMethodHash\", \"(Ljava\/lang\/Object;)I\", false);\n+                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\",\n+                        \"setExpectedFull\", \"(I)V\", false);\n+                super.visitInsn(DUP_X2);\n+                super.visitInsn(POP);\n+                break;\n+            case CONSTRUCTOR:\n+                super.visitInsn(DUP2);\n+                super.visitInsn(POP);\n+\n+                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/instrument\/InvokeMethodAdapter\",\n+                        \"getMethodHash\", \"(Ljava\/lang\/Object;)I\", false);\n+                super.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\",\n+                        \"setExpectedFull\", \"(I)V\", false);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    public static int getMethodHash(Object obj) {\n+        String desc = \"\";\n+        if (obj instanceof Method) {\n+            Method m = (Method) obj;\n+            Class c = m.getDeclaringClass();\n+            desc = c.getName().replace(\".\", \"\/\");\n+\n+            desc += m.getName();\n+\n+            Class[] types = m.getParameterTypes();\n+            desc += \"(\";\n+            for (Class t : types) {\n+                desc += vmType(t.getName());\n+            }\n+            desc += \")\";\n+            desc += vmType(m.getReturnType().getName());\n+        } else if (obj instanceof Constructor) {\n+            Constructor c = (Constructor) obj;\n+            Class cl = c.getDeclaringClass();\n+            desc = cl.getName().replace(\".\", \"\/\");\n+\n+            desc += \"<init>\";\n+            Class[] types = c.getParameterTypes();\n+            desc += \"(\";\n+            for (Class t : types) {\n+                desc += vmType(t.getName());\n+            }\n+            desc += \")\";\n+            desc += \"V\";\n+        } else if (obj instanceof Class) {\n+            Class c = (Class) obj;\n+            desc = c.getName().replace(\".\", \"\/\");\n+            desc += \"<init>\" + \"()V\";\n+        }\n+\n+        return desc.hashCode();\n+    }\n+\n+    private static String vmType(String type) {\n+        \/\/      [<s>  -> <s>[]      <s> is converted recursively\n+        \/\/      L<s>; -> <s>        characters '\/' are replaced by '.' in <s>\n+        \/\/      B     -> byte\n+        \/\/      C     -> char\n+        \/\/      D     -> double\n+        \/\/      F     -> float\n+        \/\/      I     -> int\n+        \/\/      J     -> long\n+        \/\/      S     -> short\n+        \/\/      Z     -> boolean\n+        \/\/      V     -> void       valid only in method return type\n+        String res = \"\";\n+        if (type.equals(\"\")) {\n+            return \"V\";\n+        }\n+\n+        while (type.endsWith(\"[]\")) {\n+            type = type.substring(0, type.length() - 2);\n+            res += \"[\";\n+        }\n+\n+        while (type.startsWith(\"[\")) {\n+            res += '[';\n+            type = type.substring(1);\n+        }\n+        if (type.equals(\"byte\")) {\n+            res += \"B\";\n+        } else if (type.equals(\"char\")) {\n+            res += \"C\";\n+        } else if (type.equals(\"double\")) {\n+            res += \"D\";\n+        } else if (type.equals(\"float\")) {\n+            res += \"F\";\n+        } else if (type.equals(\"int\")) {\n+            res += \"I\";\n+        } else if (type.equals(\"long\")) {\n+            res += \"J\";\n+        } else if (type.equals(\"short\")) {\n+            res += \"S\";\n+        } else if (type.equals(\"boolean\")) {\n+            res += \"Z\";\n+        } else if (type.equals(\"void\")) {\n+            res += \"V\";\n+        } else {\n+            type = type.replace(\".\", \"\/\");\n+            if (!type.startsWith(\"L\")) {\n+                type = \"L\" + type;\n+            }\n+            res += type;\n+            if (!type.endsWith(\";\")) {\n+                res += \";\";\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/InvokeMethodAdapter.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.asm;\n+\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.util.Utils;\n+import org.objectweb.asm.AnnotationVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+\n+\/**\n+ * Class that does nothing but collects runtime annotations\n+ *\n+ * @author Dmitry Fazunenko\n+ *\/\n+class MethodAnnotationAdapter extends MethodVisitor {\n+\n+    final DataMethod meth;\n+\n+    @Override\n+    public AnnotationVisitor visitAnnotation(String anno, boolean b) {\n+        meth.addAnnotation(anno);\n+        return super.visitAnnotation(anno, b);\n+    }\n+\n+    MethodAnnotationAdapter(final MethodVisitor mv,\n+            final DataMethod method) {\n+        super(ASMUtils.ASM_API_VERSION, mv);\n+        this.meth = method;\n+    }\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/MethodAnnotationAdapter.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -27,0 +27,3 @@\n+import com.sun.tdk.jcov.instrument.DataMethodEntryOnly;\n+import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n@@ -182,1 +185,2 @@\n-        instructions.add(new MethodInsnNode(invokeOp, dataMethod.getParent().getFullname(), InstrumentationOptions.nativePrefix + dataMethod.getName(), dataMethod.getVmSignature()));\n+        instructions.add(new MethodInsnNode(invokeOp, dataMethod.getParent().getFullname(),\n+                InstrumentationOptions.nativePrefix + dataMethod.getName(), dataMethod.getVmSignature()));\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/NativeWrappingMethodAdapter.java","additions":7,"deletions":3,"binary":false,"changes":10,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/NativeWrappingMethodAdapter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/OffsetLabel.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/OffsetLabel.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/OffsetLabelingClassReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/OffsetLabelingClassReader.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -27,0 +27,1 @@\n+import com.sun.tdk.jcov.instrument.DataMethodWithBlocks;\n@@ -47,1 +48,1 @@\n-        super(Utils.ASM_API_VERSION, mv);\n+        super(ASMUtils.ASM_API_VERSION, mv);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/OffsetRecordingMethodAdapter.java","additions":4,"deletions":3,"binary":false,"changes":7,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/OffsetRecordingMethodAdapter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021,  Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022  Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/OverriddenClassWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/OverriddenClassWriter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -44,1 +44,1 @@\n-        super(Utils.ASM_API_VERSION, mv);\n+        super(ASMUtils.ASM_API_VERSION, mv);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/SavePointsMethodAdapter.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/SavePointsMethodAdapter.java","status":"renamed"},{"patch":"@@ -25,1 +25,1 @@\n-package com.sun.tdk.jcov.instrument;\n+package com.sun.tdk.jcov.instrument.asm;\n@@ -27,0 +27,1 @@\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n@@ -75,1 +76,1 @@\n-        super(Utils.ASM_API_VERSION, mv);\n+        super(ASMUtils.ASM_API_VERSION, mv);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/StaticInvokeMethodAdapter.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/StaticInvokeMethodAdapter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n-import com.sun.tdk.jcov.instrument.CharacterRangeTableAttribute;\n-import com.sun.tdk.jcov.instrument.CharacterRangeTableAttribute.CRTEntry;\n+import com.sun.tdk.jcov.instrument.CharacterRangeTable;\n+import com.sun.tdk.jcov.instrument.CharacterRangeTable.CRTEntry;\n@@ -43,1 +43,1 @@\n-    CharacterRangeTableAttribute crt;\n+    CharacterRangeTable crt;\n@@ -47,1 +47,1 @@\n-        crt = (CharacterRangeTableAttribute) dest;\n+        crt = (CharacterRangeTable) dest;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/reader\/CharacterRangeTableAttributeStAX.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-import com.sun.tdk.jcov.instrument.CharacterRangeTableAttribute;\n+import com.sun.tdk.jcov.instrument.CharacterRangeTable;\n@@ -98,1 +98,1 @@\n-                meth.setCharacterRangeTable(new CharacterRangeTableAttribute(meth.rootId()));\n+                meth.setCharacterRangeTable(new CharacterRangeTable(meth.rootId()));\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/reader\/DataMethodWithBlocksStAX.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+\n@@ -34,1 +35,0 @@\n-import java.util.Comparator;\n@@ -38,2 +38,0 @@\n-import java.util.TreeSet;\n-import org.objectweb.asm.Opcodes;\n@@ -98,1 +96,0 @@\n-                    boolean isPublic = isPublic(c, toMerge);\n@@ -106,6 +103,1 @@\n-                        int newAccess = isPublic ? m.getAccess() : makePrivate(m.getAccess());\n-                        if ((c.getAccess() & Opcodes.ACC_SYNTHETIC) != 0 && (m.getAccess() & Opcodes.ACC_SYNTHETIC) == 0){\n-                            newAccess = m.getAccess() | Opcodes.ACC_SYNTHETIC;\n-                        }\n-\n-                        DataMethod nm = m.clone(newClass, newAccess, prefix + m.getName());\n+                        DataMethod nm = m.clone(newClass, m.getAccess(), prefix + m.getName());\n@@ -120,3 +112,1 @@\n-                        int newAccess = isPublic ? f.getAccess() : makePrivate(f.getAccess());\n-                        f.clone(newClass, newAccess, prefix + f.getName());\n-                        \/\/ new created field will be added to the newClass\n+                        f.clone(newClass, f.getAccess(), prefix + f.getName());\n@@ -170,112 +160,0 @@\n-    \/**\n-     * Returns true if the given class is public (contains \"public\" modifier)\n-     * and all its outers are public as well.\n-     *\n-     * @param cls - class to analyze\n-     * @param peers classes the could be potentionaly outer of the cls\n-     * @return true or false\n-     *\/\n-    private boolean isPublic(DataClass cls, ArrayList<DataClass> peers) {\n-        ArrayList<DataClass> outers = findOuters(cls, peers);\n-        DataClass outClass = outers.get(outers.size() - 1);\n-        for (DataClass c : outers) {\n-            if (!isPublic(c, outClass)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Scans given modifiers in attempt to find \"public\".\n-     *\n-     * @param modifiers - array to scan\n-     * @return true if given array is not null and contains \"public\"\n-     *\/\n-    private boolean isPublic(DataClass c, DataClass outClass) {\n-        if (isAnonymous(c.getName())) {\n-            return isPublicAnonymous(c, outClass);\n-        }\n-\n-        return (c.getAccess() & Opcodes.ACC_PUBLIC) != 0;\n-    }\n-\n-    private boolean isPublicAnonymous(DataClass c, DataClass outClass) {\n-\n-        TreeSet<DataMethod> sortedMethods = new TreeSet<DataMethod>(new Comparator<DataMethod>() {\n-            @Override\n-            public int compare(DataMethod dm1, DataMethod dm2) {\n-                return dm1.getLineTable().get(dm1.getLineTable().size() - 1).line - dm2.getLineTable().get(dm2.getLineTable().size() - 1).line;\n-            }\n-        });\n-\n-        for (DataMethod dm : outClass.getMethods()) {\n-            if (dm.getLineTable() != null) {\n-                sortedMethods.add(dm);\n-            }\n-        }\n-\n-        DataMethod initMethod = c.findMethod(\"<init>\");\n-\n-        if (sortedMethods != null && initMethod != null) {\n-            for (DataMethod dataMethod : sortedMethods) {\n-\n-                if (initMethod.getLineTable().get(0).line <= dataMethod.getLineTable().get(dataMethod.getLineTable().size() - 1).line) {\n-\n-                    \/\/Anonymous classes in init and clinit is not public\n-                    if (dataMethod.getName().equals(\"<init>\") || dataMethod.getName().equals(\"<clinit>\")) {\n-                        return false;\n-                    }\n-\n-                    return dataMethod.isPublicAPI();\n-                }\n-\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    \/**\n-     * Finds outer classes among classes obtained from the same source.\n-     *\n-     * @param cls - class to find outers\n-     * @param peers - class obtained from the same source\n-     * @return list of outers including cls itself.\n-     *\/\n-    private ArrayList<DataClass> findOuters(DataClass cls, ArrayList<DataClass> peers) {\n-        ArrayList<DataClass> result = new ArrayList<DataClass>();\n-        result.add(cls);\n-        String name = cls.getName();\n-        for (DataClass c : peers) {\n-            if (name.startsWith(c.getName() + \"$\")) {\n-                result.add(c);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    \/**\n-     * Removes \"public\" and \"protected\" modifiers from the given list\n-     *\n-     * @param modifiers array of modifiers\n-     * @return modified array\n-     *\/\n-    private int makePrivate(int modifiers) {\n-        return modifiers & ~Opcodes.ACC_PUBLIC & ~Opcodes.ACC_PROTECTED;\n-    }\n-\n-    \/**\n-     * @param name - name of a class\n-     * @return true, if the given class name is anonyomous\n-     *\/\n-    private boolean isAnonymous(String name) {\n-        if (name == null) {\n-            return false;\n-        }\n-        int index = name.lastIndexOf(\"$\");\n-        if (index < 0) {\n-            return false;\n-        }\n-        return Character.isDigit(name.charAt(index + 1));\n-    }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/processing\/CombinerDataProcessor.java","additions":4,"deletions":126,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import com.sun.tdk.jcov.instrument.Modifiers;\n@@ -38,1 +39,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -66,5 +66,6 @@\n-    private int access;\n-    private String fullname;\n-    private String name;\n-    private String packagename;\n-    private String modulename;\n+    private final int access;\n+    private final String fullname;\n+    private final String name;\n+    private final String packagename;\n+    private final String modulename;\n+    private final Modifiers modifiers;\n@@ -95,0 +96,1 @@\n+        modifiers = clz.getModifiers();\n@@ -128,1 +130,1 @@\n-            if ((method.getAccess() & Opcodes.ACC_SYNTHETIC) != 0 && method.getName().startsWith(\"lambda$\")){\n+            if (method.getModifiers().isSynthetic() && method.getName().startsWith(\"lambda$\")){\n@@ -173,1 +175,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -180,3 +182,1 @@\n-    public boolean isPublicAPI() {\n-        return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED)) != 0;\n-    }\n+    public boolean isPublicAPI() { return modifiers.isPublic() || modifiers.isProtected(); }\n@@ -186,1 +186,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -193,1 +193,1 @@\n-        return (access & Opcodes.ACC_PUBLIC) != 0;\n+        return modifiers.isPublic();\n@@ -198,1 +198,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -205,1 +205,1 @@\n-        return (access & Opcodes.ACC_PRIVATE) != 0;\n+        return modifiers.isPrivate();\n@@ -210,1 +210,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -217,1 +217,1 @@\n-        return (access & Opcodes.ACC_PROTECTED) != 0;\n+        return modifiers.isProtected();\n@@ -222,1 +222,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -229,1 +229,1 @@\n-        return (access & Opcodes.ACC_ABSTRACT) != 0;\n+        return modifiers.isAbstract();\n@@ -234,1 +234,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -241,1 +241,1 @@\n-        return (access & Opcodes.ACC_FINAL) != 0;\n+        return modifiers.isFinal();\n@@ -247,2 +247,1 @@\n-     * @return Access bit-mask of org.objectweb.asm.Opcodes constants.\n-     * @see Opcodes\n+     * @return Access bit-mask.\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/ClassCoverage.java","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -50,4 +50,3 @@\n-        count = fld.getCount();\n-        startLine = 0;\n-        modifiers = Arrays.deepToString(fld.getAccessFlags());\n-        name = fld.getName();\n+        access = fld.getAccess();\n+        modifiersString =  Arrays.deepToString(fld.getAccessFlags());\n+        name =  fld.getName();\n@@ -55,0 +54,2 @@\n+        startLine = 0;\n+        count = fld.getCount();\n@@ -56,1 +57,1 @@\n-        access = fld.getAccess();\n+        modifiers = fld.getModifiers();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/FieldCoverage.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.tdk.jcov.instrument.Modifiers;\n@@ -32,1 +33,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -45,1 +45,1 @@\n-    protected String modifiers;\n+    protected String modifiersString;\n@@ -48,0 +48,1 @@\n+    protected Modifiers modifiers;\n@@ -89,2 +90,2 @@\n-    public String getModifiers() {\n-        return modifiers;\n+    public String getModifiersString() {\n+        return modifiersString;\n@@ -151,1 +152,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -159,1 +160,1 @@\n-        return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED)) != 0;\n+        return modifiers.isPublic() || modifiers.isProtected();\n@@ -164,1 +165,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -171,1 +172,1 @@\n-        return (access & Opcodes.ACC_PUBLIC) != 0;\n+        return modifiers.isPublic();\n@@ -176,1 +177,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -183,1 +184,1 @@\n-        return (access & Opcodes.ACC_PRIVATE) != 0;\n+        return modifiers.isPrivate();\n@@ -188,1 +189,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -195,1 +196,1 @@\n-        return (access & Opcodes.ACC_PROTECTED) != 0;\n+        return modifiers.isProtected();\n@@ -200,1 +201,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -207,1 +208,1 @@\n-        return (access & Opcodes.ACC_ABSTRACT) != 0;\n+        return modifiers.isAbstract();\n@@ -212,1 +213,1 @@\n-     * getAccess() method returns a bit-mask of org.objectweb.asm.Opcodes\n+     * getAccess() method returns a bit-mask\n@@ -219,1 +220,1 @@\n-        return (access & Opcodes.ACC_FINAL) != 0;\n+        return modifiers.isFinal();\n@@ -225,2 +226,1 @@\n-     * @return Access bit-mask of org.objectweb.asm.Opcodes constants.\n-     * @see Opcodes\n+     * @return Access bit-mask.\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/MemberCoverage.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -86,1 +85,2 @@\n-        modifiers = Arrays.deepToString(method.getAccessFlags());\n+        access = method.getAccess();\n+        modifiersString = Arrays.deepToString(method.getAccessFlags());\n@@ -88,0 +88,4 @@\n+        signature = (method.getVmSignature() != null) ? method.getVmSignature() : \"\";\n+        startLine = (method.getLineTable() != null && method.getLineTable().size() > 0) ?\n+                        method.getLineTable().get(0).line : 0;\n+        count = method.getCount();\n@@ -89,2 +93,1 @@\n-        signature = method.getVmSignature();\n-        access = method.getAccess();\n+        modifiers = method.getModifiers();\n@@ -94,5 +97,0 @@\n-        if (signature == null) {\n-            signature = \"\";\n-        }\n-        count = method.getCount();\n-\n@@ -103,3 +101,0 @@\n-            if (lineTable.size() > 0) {\n-                super.startLine = lineTable.get(0).line;\n-            }\n@@ -419,1 +414,1 @@\n-                if (inAnonymClass && !anonymon && (access & Opcodes.ACC_SYNTHETIC) != 0) {\n+                if (inAnonymClass && !anonymon && modifiers.isSynthetic()) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/MethodCoverage.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -46,1 +45,1 @@\n-        if ((m.getAccess() & Opcodes.ACC_DEPRECATED) != 0){\n+        if (m.getModifiers().isDeprecated()){\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/ancfilters\/DeprecatedANCFilter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -46,1 +45,1 @@\n-        if ((m.getAccess() & Opcodes.ACC_SYNTHETIC) != 0){\n+        if (m.getModifiers().isSynthetic()){\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/ancfilters\/SyntheticANCFilter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -1585,1 +1585,1 @@\n-            String mmodifiers = mcov.getModifiers();\n+            String mmodifiers = mcov.getModifiersString();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/html\/CoverageReport.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import org.objectweb.asm.Opcodes;\n@@ -60,5 +59,0 @@\n-    \/**\n-     * The ASM API version that should be used by jcov.\n-     *\/\n-    public static final int ASM_API_VERSION = Opcodes.ASM9;\n-\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/util\/Utils.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+\n+public class Util {\n+    private final Path outputDir;\n+\n+    public Util(Path dir) {\n+        outputDir = dir;\n+    }\n+\n+    public List<Path> copyBytecode(String... classes) throws IOException {\n+        byte[] buf = new byte[1024];\n+        List<Path> result = new ArrayList<>();\n+        for(String c : classes) {\n+            String classFile = classFile(c);\n+            try(InputStream in = getClass().getClassLoader().getResourceAsStream(classFile)) {\n+                Path o = outputDir.resolve(classFile);\n+                result.add(o);\n+                if(!Files.exists(o.getParent())) Files.createDirectories(o.getParent());\n+                try(OutputStream out = Files.newOutputStream(o)) {\n+                    int read;\n+                    while((read = in.read(buf)) > 0)\n+                        out.write(buf, 0, read);\n+                }\n+            }\n+        };\n+        return result;\n+    }\n+\n+    public static Path copyJRE(Path src) throws IOException {\n+        Path dest = Files.createTempDirectory(\"JDK\");\n+        System.out.println(\"Copying a JDK from \" + src + \" to \" + dest);\n+        Files.walk(src).forEach(s -> {\n+            try {\n+                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        return dest;\n+    }\n+\n+    public static Path createRtJar(String prefix, Class collect) throws IOException {\n+        Path dest = Files.createTempFile(prefix, \".jar\");\n+        System.out.println(prefix + \" jar: \" + dest);\n+        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n+            jar.putNextEntry(new JarEntry(collect.getName().replace(\".\", File.separator) + \".class\"));\n+            try (InputStream ci = collect.getClassLoader()\n+                    .getResourceAsStream(collect.getName().replace('.', '\/') + \".class\")) {\n+                byte[] buffer = new byte[1024];\n+                int read;\n+                while((read = ci.read(buffer)) > 0) {\n+                    jar.write(buffer, 0, read);\n+                }\n+            }\n+        }\n+        return dest;\n+    }\n+\n+    public static String classFile(String className) {\n+        return className.replace('.', '\/') + \".class\";\n+    }\n+    public Class runClass(Class className, String[] argv)\n+            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+        return runClass(className.getName(), argv);\n+    }\n+    public Class runClass(String className, String[] argv)\n+            throws ClassNotFoundException, NoSuchMethodException,\n+            InvocationTargetException, IllegalAccessException, InstantiationException {\n+        ClassLoader offOutputDir = new InstrumentedClassLoader();\n+        Class cls = offOutputDir.loadClass(className);\n+        Method m = cls.getMethod(\"main\", new String[0].getClass());\n+        m.invoke(null, (Object)argv);\n+        return cls;\n+    }\n+\n+    private class InstrumentedClassLoader extends ClassLoader {\n+        protected InstrumentedClassLoader() {\n+            super(Util.class.getClassLoader());\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            Path classFile = outputDir.resolve(classFile(name));\n+            if(Files.exists(classFile)) {\n+                byte[] buf = new byte[1024];\n+                try(InputStream in = Files.newInputStream(classFile)) {\n+                    try(ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                        int read;\n+                        while((read = in.read(buf)) > 0)\n+                            out.write(buf, 0, read);\n+                        return defineClass(name, out.toByteArray(), 0, out.size());\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return super.loadClass(name);\n+        }\n+    }\n+    public static void rmRF(Path jre) throws IOException {\n+        System.out.println(\"Removing \" + jre);\n+        if(Files.isRegularFile(jre))\n+            Files.deleteIfExists(jre);\n+        else\n+            Files.walkFileTree(jre, new FileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                    Files.delete(file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                    Files.delete(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/Util.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.instr;\n+\n+import com.sun.tdk.jcov.Instr;\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.Util;\n+import com.sun.tdk.jcov.io.Reader;\n+import com.sun.tdk.jcov.runtime.Collect;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class InstrTest {\n+    Path test_dir;\n+    Path template;\n+    int method_slot = -1;\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        System.setProperty(\"jcov.selftest\", \"true\");\n+        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n+        test_dir = data_dir.resolve(\"instr_test\");\n+        System.out.println(\"test dir = \" + test_dir);\n+        Util.rmRF(test_dir);\n+        template = test_dir.resolve(\"template.lst\");\n+    }\n+    \/\/@Test\n+    public void instrumentClass() throws IOException, InterruptedException, FileFormatException,\n+            ClassNotFoundException, InvocationTargetException, NoSuchMethodException,\n+            IllegalAccessException, InstantiationException {\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(new Util(test_dir).copyBytecode(UserCode.class.getName()).get(0).toString());\n+        new Instr().run(params.toArray(new String[0]));\n+        testInstrumentation();\n+        run();\n+    }\n+    @Test\n+    public void instrumentDir() throws IOException, InterruptedException, FileFormatException,\n+            ClassNotFoundException, InvocationTargetException, NoSuchMethodException,\n+            IllegalAccessException, InstantiationException {\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(\"-i\");\n+        params.add(\"UserCode\");\n+        new Util(test_dir).copyBytecode(UserCode.class.getName(), InstrTest.class.getName());\n+        params.add(test_dir.toString());\n+        new Instr().run(params.toArray(new String[0]));\n+        testInstrumentation();\n+        run();\n+    }\n+    private void testInstrumentation() throws FileFormatException {\n+        DataRoot data = Reader.readXML(template.toString());\n+        DataMethod dm =\n+                data.getPackages().stream().filter(p -> p.getName().equals(\"com\/sun\/tdk\/jcov\/instrument\/instr\")).findAny().get()\n+                        .getClasses().stream().filter(c -> c.getName().equals(\"UserCode\")).findAny().get()\n+                        .getMethods().stream().filter(m -> m.getName().equals(\"main\")).findAny().get();\n+        method_slot = dm.getSlot();\n+        assertTrue(method_slot > 0);\n+    }\n+\n+\/\/    @Test(dependsOnMethods = \"instrumentDir\")\n+    public void run() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n+            IllegalAccessException, IOException, InstantiationException {\n+        new Util(test_dir).runClass(UserCode.class, new String[] {\"+\"});\n+        assertTrue(Collect.wasHit(method_slot));\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        Util.rmRF(test_dir);\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/instr\/InstrTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.instr;\n+\n+public class UserCode {\n+    private static int count = 0;\n+    public static void main(String[] args) {\n+        if(args[0].equals(\"-\")) count--;\n+        else if(args[0].equals(\"+\")) count++;\n+        System.out.println(\"User code is running.\");\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/instr\/UserCode.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.jreinstr;\n+\n+import javax.swing.JFrame;\n+\n+public class Code {\n+    public static void main(String[] args) {\n+        new JFrame();\n+        System.out.println(\"User code has been executed.\");\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/jreinstr\/Code.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.jreinstr;\n+\n+import com.sun.tdk.jcov.JREInstr;\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataClass;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataPackage;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.Util;\n+import com.sun.tdk.jcov.io.Reader;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class JREInstrTest {\n+\n+    Path jre;\n+    Path userCode;\n+\n+    static void createUserCode(Path location, Class code) throws IOException {\n+        String fileName = code.getName().replace('.', '\/') + \".class\";\n+        Path classFile = location.resolve(fileName);\n+        Files.createDirectories(classFile.getParent());\n+        try (InputStream ci = code.getClassLoader().getResourceAsStream(fileName);\n+             OutputStream out = Files.newOutputStream(classFile)) {\n+            byte[] buffer = new byte[1024];\n+            int read;\n+            while ((read = ci.read(buffer)) > 0) {\n+                out.write(buffer, 0, read);\n+            }\n+        }\n+    }\n+\n+    @BeforeClass\n+    public void setup() throws IOException, InterruptedException {\n+        String testJRE = System.getProperty(\"test.jre\");\n+        if(testJRE == null) {\n+            testJRE = System.getProperty(\"java.home\");\n+        }\n+        jre = Util.copyJRE(Paths.get(testJRE));\n+        userCode = Paths.get(\"user_code\");\n+        createUserCode(userCode, Code.class);\n+    }\n+\n+    @Test\n+    public void testJREInstr() throws IOException, InterruptedException {\n+        String runtime = Arrays.stream(System.getProperty(\"java.class.path\").split(File.pathSeparator))\n+                .peek(System.out::println)\n+                .filter(s -> s.endsWith(\"jcov_file_saver.jar\")).findAny().get();\n+        String[] params = new String[] {\n+                \"-implantrt\", runtime,\n+                \"-im\", \"java.base\",\n+                jre.toString()};\n+        System.out.println(\"Running JREInstr with \" + Arrays.stream(params).collect(Collectors.joining(\" \")));\n+        long start = System.currentTimeMillis();\n+        assertEquals(new JREInstr().run(params), 0);\n+        \/\/track instrumentation time for the TODO in copyJRE\n+        System.out.println(\"Took \" + (System.currentTimeMillis() - start) + \" to instrument.\");\n+    }\n+\n+    @Test(dependsOnMethods = \"testJREInstr\")\n+    public void testInstrumentation() throws IOException, InterruptedException {\n+        List<String> command = List.of(\n+                jre.toString() + File.separator + \"bin\" + File.separator + \"java\",\n+                \"-cp\", userCode.toAbsolutePath().toString(), Code.class.getName());\n+        System.out.println(command.stream().collect(Collectors.joining(\" \")));\n+        new ProcessBuilder()\n+                .command(command)\n+                .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                .start().waitFor();\n+        assertTrue(Files.exists(Paths.get(\"result.xml\")));\n+    }\n+\n+    @Test(dependsOnMethods = \"testInstrumentation\")\n+    public void testCoverage() throws IOException, InterruptedException, FileFormatException {\n+        DataRoot data = Reader.readXML(Files.newInputStream(Paths.get(\"result.xml\")));\n+        DataPackage pkg = data.getPackages().stream().filter(p -> p.getName().equals(\"javax\/swing\")).findAny().get();\n+        DataClass cls = pkg.getClasses().stream().filter(c -> c.getName().equals(\"JFrame\"))\n+                .findAny().get();\n+        DataMethod method = cls.getMethods().stream().filter(m ->\n+                m.getName().equals(\"<init>\") && m.getVmSignature().equals(\"()V\")\n+        ).findFirst().get();\n+        assertEquals(method.getCount(), 1);\n+    }\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(jre != null && Files.exists(jre)) Util.rmRF(jre);\n+        if(userCode != null && Files.exists(userCode)) Util.rmRF(userCode);\n+        Files.deleteIfExists(Paths.get(\"result.xml\"));\n+    }\n+\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/jreinstr\/JREInstrTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n@@ -49,1 +49,2 @@\n-public class FieldsPlugin implements InstrumentationPlugin, JCovSaver {\n+\/\/TODO\n+public class FieldsPlugin implements \/*ASMInstrumentationPlugin, *\/JCovSaver {\n@@ -91,1 +92,1 @@\n-    @Override\n+\/\/    @Override\n@@ -97,1 +98,1 @@\n-    @Override\n+\/\/    @Override\n@@ -102,1 +103,1 @@\n-    @Override\n+\/\/    @Override\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/FieldsPlugin.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n@@ -34,2 +34,2 @@\n-\n-public class TestPlugin implements InstrumentationPlugin {\n+\/\/TODO\n+public class TestPlugin \/*implements ASMInstrumentationPlugin*\/ {\n@@ -54,1 +54,1 @@\n-    @Override\n+\/\/    @Override\n@@ -60,1 +60,1 @@\n-    @Override\n+\/\/    @Override\n@@ -65,1 +65,1 @@\n-    @Override\n+\/\/    @Override\n@@ -70,1 +70,1 @@\n-    @Override\n+\/\/    @Override\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/jreinstr\/TestPlugin.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.report.dataprocessor.privacy;\n+\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataClass;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataPackage;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.io.Reader;\n+import com.sun.tdk.jcov.processing.DefaultDataProcessorSPI;\n+import com.sun.tdk.jcov.processing.ProcessingException;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class PrivacyTest {\n+\n+    static DataRoot data;\n+    static String template;\n+\n+    @BeforeClass\n+    public static void setup() {\n+        template = PrivacyTest.class.getPackageName()\n+                .replace(\".\", \"\/\") + \"\/privacy_template.xml\";\n+    }\n+    @Test\n+    public void load() throws FileFormatException {\n+        data = Reader.readXML(ClassLoader.getSystemResourceAsStream(template));\n+        DataPackage p = data.findPackage(\"pkg\");\n+        DataClass tc1 = p.findClass(\"TestCode$1\");\n+        assertTrue(tc1.findMethod(\"publicMethod\").getModifiers().isPublic());\n+        DataClass tc2 = p.findClass(\"TestCode$1\");\n+        assertTrue(tc2.findMethod(\"publicMethod\").getModifiers().isPublic());\n+        DataClass tcInner = p.findClass(\"TestCode$Inner\");\n+        assertTrue(tcInner.findMethod(\"publicMethod\").getModifiers().isPublic());\n+    }\n+    @Test(dependsOnMethods = \"load\")\n+   public void transform() throws ProcessingException {\n+        data = new DefaultDataProcessorSPI().getDataProcessor().process(data);\n+        DataPackage p = data.findPackage(\"pkg\");\n+        DataClass tc = p.findClass(\"TestCode\");\n+        assertTrue(tc.findMethod(\"$1.publicMethod\").getModifiers().isPublic());\n+        assertTrue(tc.findMethod(\"$2.publicMethod\").getModifiers().isPublic());\n+        assertTrue(tc.findMethod(\"$Inner.publicMethod\").getModifiers().isPublic());\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/report\/dataprocessor\/privacy\/PrivacyTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+<?xml version='1.0' encoding='UTF-8'?>\n+<!--\n+Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+\n+<coverage\n+        xmlns='http:\/\/java.sun.com\/jcov\/namespace'\n+        xmlns:xsi='http:\/\/www.w3.org\/2001\/XMLSchema-instance'\n+        xsi:schemaLocation='http:\/\/java.sun.com\/jcov\/namespace coverage.xsd'>\n+\n+\t<head>\n+\t\t<property name='coverage.generator.args' val=''\/>\n+\t\t<property name='coverage.generator.mode' val='BRANCH'\/>\n+\t\t<property name='coverage.generator.internal' val='include'\/>\n+\t\t<property name='coverage.generator.include' val=''\/>\n+\t\t<property name='coverage.generator.exclude' val=''\/>\n+\t\t<property name='coverage.generator.caller_include' val='.*'\/>\n+\t\t<property name='coverage.generator.caller_exclude' val=''\/>\n+\t\t<property name='coverage.created.date' val='2022-10-04'\/>\n+\t\t<property name='coverage.created.time' val='19:13:10'\/>\n+\t\t<property name='coverage.generator.fullversion' val=' 3.0_13 (os.ea) September 30, 2022'\/>\n+\t\t<property name='coverage.generator.name' val='jcov'\/>\n+\t\t<property name='coverage.generator.version' val='3.0'\/>\n+\t\t<property name='coverage.spec.version' val='1.3'\/>\n+\t\t<property name='java.runtime.version' val='11.0.12+8-LTS-237'\/>\n+\t\t<property name='java.version' val='11.0.12'\/>\n+\t\t<property name='os.arch' val='x86_64'\/>\n+\t\t<property name='os.name' val='Mac OS X'\/>\n+\t\t<property name='os.version' val='11.5'\/>\n+\t\t<property name='user.name' val='shura'\/>\n+\t\t<property name='dynamic.collected' val='false'\/>\n+\t\t<property name='id.count' val='9'\/>\n+\t<\/head>\n+\t<package name=\"pkg\" moduleName=\"no_module\">\n+\t\t<class name=\"TestCode\" supername=\"java\/lang\/Object\" checksum=\"4029051559\" interface=\"true\" source=\"TestCode.java\" flags=' public'>\n+\t\t\t<meth name=\"&lt;init&gt;\" vmsig=\"()V\" flags=' public' access=\"1\" cons=\"true\" length=\"14\">\n+\t\t\t\t<bl s=\"0\" e=\"13\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"13\" id=\"6\" count=\"0\"\/>\n+\t\t\t\t\t<exit s=\"13\" e=\"13\" opcode=\"return\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t\t<lt>0=4;4=5;13=8;<\/lt>\n+\t\t\t<\/meth>\n+\t\t\t<meth name=\"method\" vmsig=\"()V\" flags='' access=\"0\" length=\"10\">\n+\t\t\t\t<bl s=\"0\" e=\"9\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"9\" id=\"7\" count=\"0\"\/>\n+\t\t\t\t\t<exit s=\"9\" e=\"9\" opcode=\"return\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t\t<lt>0=10;9=13;<\/lt>\n+\t\t\t<\/meth>\n+\t\t<\/class>\n+\t\t<class name=\"TestCode$1\" supername=\"java\/lang\/Object\" checksum=\"641620908\" interface=\"true\" source=\"TestCode.java\" inner=\"anon\" flags=''>\n+\t\t\t<meth name=\"&lt;init&gt;\" vmsig=\"(Lpkg\/TestCode;)V\" flags='' access=\"0\" cons=\"true\" length=\"10\">\n+\t\t\t\t<bl s=\"0\" e=\"9\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"9\" id=\"0\" count=\"0\"\/>\n+\t\t\t\t\t<exit s=\"9\" e=\"9\" opcode=\"return\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t\t<lt>0=5;<\/lt>\n+\t\t\t<\/meth>\n+\t\t\t<meth name=\"publicMethod\" vmsig=\"()V\" flags=' public' access=\"1\" length=\"1\">\n+\t\t\t\t<bl s=\"0\" e=\"0\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"0\" id=\"1\" count=\"0\"\/>\n+\t\t\t\t\t<exit s=\"0\" e=\"0\" opcode=\"return\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t\t<lt>0=6;<\/lt>\n+\t\t\t<\/meth>\n+\t\t<\/class>\n+\t\t<class name=\"TestCode$2\" supername=\"java\/lang\/Object\" checksum=\"3175112320\" interface=\"true\" source=\"TestCode.java\" inner=\"anon\" flags=''>\n+\t\t\t<meth name=\"&lt;init&gt;\" vmsig=\"(Lpkg\/TestCode;)V\" flags='' access=\"0\" cons=\"true\" length=\"10\">\n+\t\t\t\t<bl s=\"0\" e=\"9\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"9\" id=\"2\" count=\"0\"\/>\n+\t\t\t\t\t<exit s=\"9\" e=\"9\" opcode=\"return\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t\t<lt>0=10;<\/lt>\n+\t\t\t<\/meth>\n+\t\t\t<meth name=\"publicMethod\" vmsig=\"()V\" flags=' public' access=\"1\" length=\"1\">\n+\t\t\t\t<bl s=\"0\" e=\"0\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"0\" id=\"3\" count=\"0\"\/>\n+\t\t\t\t\t<exit s=\"0\" e=\"0\" opcode=\"return\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t\t<lt>0=11;<\/lt>\n+\t\t\t<\/meth>\n+\t\t<\/class>\n+\t\t<class name=\"TestCode$Inner\" supername=\"java\/lang\/Object\" checksum=\"706304885\" interface=\"true\" source=\"TestCode.java\" inner=\"inner\" flags=''>\n+\t\t\t<meth name=\"&lt;init&gt;\" vmsig=\"(Lpkg\/TestCode;)V\" flags='' access=\"0\" cons=\"true\" length=\"10\">\n+\t\t\t\t<bl s=\"0\" e=\"9\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"9\" id=\"4\" count=\"0\"\/>\n+\t\t\t\t\t<exit s=\"9\" e=\"9\" opcode=\"return\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t\t<lt>0=14;<\/lt>\n+\t\t\t<\/meth>\n+\t\t\t<meth name=\"publicMethod\" vmsig=\"()V\" flags=' public' access=\"1\" length=\"1\">\n+\t\t\t\t<bl s=\"0\" e=\"0\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"0\" id=\"5\" count=\"0\"\/>\n+\t\t\t\t\t<exit s=\"0\" e=\"0\" opcode=\"return\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t\t<lt>0=15;<\/lt>\n+\t\t\t<\/meth>\n+\t\t<\/class>\n+\t<\/package>\n+<\/coverage>\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/report\/dataprocessor\/privacy\/privacy_template.xml","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.report.dataprocessor.syntheticity;\n+\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataClass;\n+import com.sun.tdk.jcov.instrument.DataPackage;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.io.Reader;\n+import com.sun.tdk.jcov.processing.DefaultDataProcessorSPI;\n+import com.sun.tdk.jcov.processing.ProcessingException;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class SyntheticityTest {\n+\n+    static DataRoot data;\n+    static String template;\n+\n+    @BeforeClass\n+    public static void setup() {\n+        template = SyntheticityTest.class.getPackageName()\n+                .replace(\".\", \"\/\") + \"\/synthetic_template.xml\";\n+    }\n+    @Test\n+    public void load() throws FileFormatException {\n+        data = Reader.readXML(ClassLoader.getSystemResourceAsStream(template));\n+        DataPackage p = data.findPackage(\"package\");\n+        DataClass sc1 = p.findClass(\"SyntheticityClass$SyntheticClass\");\n+        assertTrue(sc1.findMethod(\"syntheticMethod\").getModifiers().isSynthetic());\n+        assertFalse(sc1.findMethod(\"nonSyntheticMethod\").getModifiers().isSynthetic());\n+        DataClass sc2 = p.findClass(\"SyntheticityClass$NonSyntheticClass\");\n+        assertTrue(sc2.findMethod(\"syntheticMethod\").getModifiers().isSynthetic());\n+        assertFalse(sc2.findMethod(\"nonSyntheticMethod\").getModifiers().isSynthetic());\n+    }\n+    @Test(dependsOnMethods = \"load\")\n+   public void transform() throws ProcessingException {\n+        data = new DefaultDataProcessorSPI().getDataProcessor().process(data);\n+        DataPackage p = data.findPackage(\"package\");\n+        DataClass sc = p.findClass(\"SyntheticityClass\");\n+        assertTrue(sc.findMethod(\"$SyntheticClass.syntheticMethod\").getModifiers().isSynthetic());\n+        assertFalse(sc.findMethod(\"$SyntheticClass.nonSyntheticMethod\").getModifiers().isSynthetic());\n+        assertTrue(sc.findMethod(\"$NonSyntheticClass.syntheticMethod\").getModifiers().isSynthetic());\n+        assertFalse(sc.findMethod(\"$NonSyntheticClass.nonSyntheticMethod\").getModifiers().isSynthetic());\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/report\/dataprocessor\/syntheticity\/SyntheticityTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+<?xml version='1.0' encoding='UTF-8'?>\n+<!--\n+Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<coverage\n+        xmlns='http:\/\/java.sun.com\/jcov\/namespace'\n+        xmlns:xsi='http:\/\/www.w3.org\/2001\/XMLSchema-instance'\n+        xsi:schemaLocation='http:\/\/java.sun.com\/jcov\/namespace coverage.xsd'>\n+\n+\t<head>\n+\t\t<property name='coverage.generator.args' val=''\/>\n+\t\t<property name='coverage.generator.mode' val='BRANCH'\/>\n+\t\t<property name='coverage.generator.internal' val='include'\/>\n+\t\t<property name='coverage.generator.include' val=''\/>\n+\t\t<property name='coverage.generator.exclude' val=''\/>\n+\t\t<property name='coverage.generator.caller_include' val='.*'\/>\n+\t\t<property name='coverage.generator.caller_exclude' val=''\/>\n+\t\t<property name='coverage.created.date' val='2022-09-27'\/>\n+\t\t<property name='coverage.created.time' val='03:25:24'\/>\n+\t\t<property name='coverage.generator.fullversion' val=' 3.0_13 (os.ea) September 26, 2022'\/>\n+\t\t<property name='coverage.generator.name' val='jcov'\/>\n+\t\t<property name='coverage.generator.version' val='3.0'\/>\n+\t\t<property name='coverage.spec.version' val='1.3'\/>\n+\t\t<property name='java.runtime.version' val='11.0.12+8-LTS-237'\/>\n+\t\t<property name='java.version' val='11.0.12'\/>\n+\t\t<property name='os.arch' val='x86_64'\/>\n+\t\t<property name='os.name' val='Mac OS X'\/>\n+\t\t<property name='os.version' val='11.5'\/>\n+\t\t<property name='user.name' val='shura'\/>\n+\t\t<property name='dynamic.collected' val='false'\/>\n+\t\t<property name='id.count' val='4'\/>\n+\t<\/head>\n+\t<package name=\"package\" moduleName=\"no_module\">\n+\t\t<class name=\"SyntheticityClass\" supername=\"java\/lang\/Object\" flags=' synthetic' source=\"SyntheticityClass.java\">\n+\n+\t\t<\/class>\n+\t\t<class name=\"SyntheticityClass$SyntheticClass\" supername=\"java\/lang\/Object\" flags=' synthetic' source=\"SyntheticityClass.java\">\n+\t\t\t<meth name=\"syntheticMethod\" vmsig=\"()V\" flags=' ' access=\"4097\" length=\"0\">\n+\t\t\t\t<bl s=\"0\" e=\"-1\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"-1\" id=\"1\" count=\"0\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t<\/meth>\n+\t\t\t<meth name=\"nonSyntheticMethod\" vmsig=\"()V\" flags=' ' access=\"1\" length=\"0\">\n+\t\t\t\t<bl s=\"0\" e=\"-1\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"-1\" id=\"1\" count=\"0\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t<\/meth>\n+\t\t<\/class>\n+\t\t<class name=\"SyntheticityClass$NonSyntheticClass\" supername=\"java\/lang\/Object\" flags=' ' source=\"SyntheticityClass.java\">\n+\t\t\t<meth name=\"syntheticMethod\" vmsig=\"()V\" flags=' ' access=\"4097\" length=\"0\">\n+\t\t\t\t<bl s=\"0\" e=\"-1\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"-1\" id=\"1\" count=\"0\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t<\/meth>\n+\t\t\t<meth name=\"nonSyntheticMethod\" vmsig=\"()V\" flags=' ' access=\"1\" length=\"0\">\n+\t\t\t\t<bl s=\"0\" e=\"-1\">\n+\t\t\t\t\t<methenter s=\"0\" e=\"-1\" id=\"1\" count=\"0\"\/>\n+\t\t\t\t<\/bl>\n+\t\t\t<\/meth>\n+\t\t<\/class>\n+\t<\/package>\n+<\/coverage>\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/report\/dataprocessor\/syntheticity\/synthetic_template.xml","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}