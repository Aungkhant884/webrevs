{"files":[{"patch":"@@ -48,0 +48,1 @@\n+data.src.dir = ..\/data\/classes\n","filename":"build\/build.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-  Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+  Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+    <property name=\"jcov.data.classes\" location=\"${tmp.dir}\/jcov_data_classes\"\/>\n@@ -70,0 +71,5 @@\n+    <patternset id=\"jcov.data.files\">\n+        <include name=\"openjdk\/jcov\/**\"\/>\n+        <include name=\"module-info.*\"\/>\n+    <\/patternset>\n+\n@@ -128,0 +134,1 @@\n+        <mkdir dir=\"${jcov.data.classes}\"\/>\n@@ -223,1 +230,16 @@\n-    <target name=\"compile\"  depends=\"compile-jcov, compile-asm\"\/>\n+    <target name=\"compile-data\"  depends=\"compile-jcov\" if=\"with.data\">\n+        <javac encoding=\"iso-8859-1\" debug=\"true\"\n+               srcdir=\"${data.src.dir}\"\n+               destdir=\"${jcov.data.classes}\"\n+               modulepath=\"${jcov.classes}:${jcov.modulepath}:${javatestjar}:${ant.home}\/lib\/ant.jar\">\n+            <patternset refid=\"jcov.data.files\"\/>\n+            <compilerarg value=\"--add-exports\"\/> <compilerarg value=\"java.base\/jdk.internal.classfile=jcov.data\"\/>\n+            <compilerarg value=\"--add-exports\"\/> <compilerarg value=\"java.base\/jdk.internal.classfile.instruction=jcov.data\"\/>\n+            <compilerarg value=\"--add-exports\"\/> <compilerarg value=\"java.base\/jdk.internal.classfile.constantpool=jcov.data\"\/>\n+            <compilerarg value=\"--add-exports\"\/> <compilerarg value=\"java.base\/jdk.internal.classfile.attribute=jcov.data\"\/>\n+            <compilerarg value=\"--add-exports\"\/> <compilerarg value=\"java.base\/jdk.internal.classfile.java.lang.constant=jcov.data\"\/>\n+        <\/javac>\n+        <jar basedir=\"${jcov.data.classes}\" destfile=\"${modules.dir}\/jcov-data.jar\"\/>\n+    <\/target>\n+\n+    <target name=\"compile\"  depends=\"compile-jcov, compile-asm, compile-data\"\/>\n@@ -383,1 +405,1 @@\n-            <arg value=\"-javaoption:\/Users\/shura\/JDK\/git\/jcov-mine\/JCOV_build\/modules\/jcov.jar:${javatestjar}:${ant.home}\/lib\/ant.jar\"\/>\n+            <arg value=\"-javaoption:${modules.dir}\/jcov.jar:${javatestjar}:${ant.home}\/lib\/ant.jar\"\/>\n@@ -394,0 +416,23 @@\n+\n+    <target name=\"test-data\" depends=\"compile-jcov, compile-data\" if=\"with.data\">\n+        <mkdir dir=\"${result.dir}\/test-data\" \/>\n+        <java jar=\"${jtreg.home}\/lib\/jtreg.jar\" fork=\"true\">\n+            <arg value=\"-cpa:${modules.dir}\/jcov.jar:${modules.dir}\/jcov-data.jar\"\/>\n+            <arg value=\"-javacoption:--add-exports\"\/> <arg value=\"-javacoption:java.base\/jdk.internal.classfile=ALL-UNNAMED\"\/>\n+            <arg value=\"-javacoption:--add-exports\"\/> <arg value=\"-javacoption:java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\"\/>\n+            <arg value=\"-javacoption:--add-exports\"\/> <arg value=\"-javacoption:java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\"\/>\n+            <arg value=\"-javacoption:--add-exports\"\/> <arg value=\"-javacoption:java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\"\/>\n+            <arg value=\"-javacoption:--add-exports\"\/> <arg value=\"-javacoption:java.base\/jdk.internal.classfile.java.lang.constant=ALL-UNNAMED\"\/>\n+            <arg value=\"-javaoption:--add-exports\"\/> <arg value=\"-javaoption:java.base\/jdk.internal.classfile=ALL-UNNAMED\"\/>\n+            <arg value=\"-javaoption:--add-exports\"\/> <arg value=\"-javaoption:java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\"\/>\n+            <arg value=\"-javaoption:--add-exports\"\/> <arg value=\"-javaoption:java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\"\/>\n+            <arg value=\"-javaoption:--add-exports\"\/> <arg value=\"-javaoption:java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\"\/>\n+            <arg value=\"-javaoption:--add-exports\"\/> <arg value=\"-javaoption:java.base\/jdk.internal.classfile.java.lang.constant=ALL-UNNAMED\"\/>\n+            <arg value=\"-workDir:${result.dir}\/test-data\/workdir\"\/>\n+            <arg value=\"-reportDir:${result.dir}\/test-data\/report\"\/>\n+            <arg value=\"-timeoutFactor:10\"\/>\n+            <arg value=\"-jdk:${java.home}\"\/>\n+            <arg value=\"-v1\"\/>\n+            <arg value=\"..\/data\/test\"\/>\n+        <\/java>\n+    <\/target>\n","filename":"build\/build.xml","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module jcov.data {\n+    requires jcov;\n+    exports openjdk.jcov.data.instrument;\n+    exports openjdk.jcov.data.arguments.instrument;\n+    exports openjdk.jcov.data.fields.instrument;\n+}\n","filename":"data\/classes\/module-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+\/**\n+ * Much of the functionality in this plugin is controlled through system properties. This class defines some shortcuts\n+ * which makes it a bit easier.\n+ *\/\n+public class Env {\n+\n+    public static final String PROP_FILE =\n+            Env.class.getPackageName().replace('.', '\/') +\n+            \"\/coverage.properties\";\n+    \/**\n+     * Prefix for all system property names which will be passed to the VM running JCov calls.\n+     *\/\n+    public static final String JCOV_DATA_ENV_PREFIX = \"jcov.data.\";\n+\n+    private static final Properties DEFAULT_STRINGS = new Properties();\n+    private static final Map<String, Object> DEFAULT_SPI = new HashMap<>();\n+\n+    public static void setSystemProperties(Map<String, String> properties) {\n+        properties.forEach((k, v) -> System.setProperty(k, v));\n+    }\n+\n+    public static void clear(String prefix) {\n+        Set<String> keys = System.getProperties().stringPropertyNames();\n+        keys.stream().filter(k -> k.startsWith(prefix))\n+                .forEach(k -> System.clearProperty(k));\n+    }\n+\n+    public static String getStringEnv(String property, String defaultValue) {\n+        synchronized(Env.class) {\n+                try {\n+                    InputStream in = Env.class.getResourceAsStream(\"\/\" + PROP_FILE);\n+                    if(in != null) {\n+                        DEFAULT_STRINGS.load(in);\n+                        System.out.println(\"Using property definitions from \" + PROP_FILE + \":\");\n+                        DEFAULT_STRINGS.list(System.out);\n+                    }\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                    throw e;\n+                }\n+\/\/            }\n+        }\n+        String override = System.getProperty(property);\n+        return (override != null) ? override : DEFAULT_STRINGS.getProperty(property, defaultValue);\n+    }\n+\n+    public static Path getPathEnv(String property, Path defaultValue) {\n+        String propValue = getStringEnv(property, null);\n+        if(propValue != null) return Path.of(propValue);\n+        else return defaultValue;\n+    }\n+\n+    public static <SPI> SPI getSPIEnv(String property, SPI defaultValue) throws ClassNotFoundException,\n+            NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+        if(DEFAULT_SPI.containsKey(property)) {\n+            return (SPI)DEFAULT_SPI.get(property);\n+        }\n+        String propValue = getStringEnv(property, null);\n+        if(propValue != null) {\n+            if (!propValue.contains(\"(\"))\n+                return (SPI) Class.forName(propValue).getConstructor().newInstance();\n+            else {\n+                int ob = propValue.indexOf('(');\n+                int cb = propValue.indexOf(')');\n+                Class cls = Class.forName(propValue.substring(0, ob));\n+                String[] params = propValue.substring(ob + 1, cb).split(\",\");\n+                Class[] paramTypes = new Class[params.length];\n+                Arrays.fill(paramTypes, String.class);\n+                return (SPI) cls.getConstructor((Class<?>[])paramTypes).newInstance((Object)params);\n+            }\n+        } else return defaultValue;\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/Env.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,2 @@\n-        return new com.sun.tdk.jcov.JREInstr().run(params);\n+\/\/        return new com.sun.tdk.jcov.JREInstr().run(params);\n+        return 0;\n","filename":"data\/classes\/openjdk\/jcov\/data\/JREInstr.java","additions":3,"deletions":2,"binary":false,"changes":5,"previous_filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/JREInstr.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"data\/classes\/openjdk\/jcov\/data\/arguments\/analysis\/Reader.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/analysis\/Reader.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"data\/classes\/openjdk\/jcov\/data\/arguments\/analysis\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/analysis\/package-info.java","status":"renamed"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.instrument;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.MethodModel;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.arguments.runtime.Runtime;\n+import openjdk.jcov.data.runtime.CoverageData;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.UncheckedIOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+public class Plugin extends openjdk.jcov.data.instrument.Plugin {\n+    \/**\n+     * Classname of a collector class which will be called from every instrumented method.\n+     *\/\n+    public static final String COLLECTOR_CLASS = Collect.class.getName()\n+            .replace('.', '\/');\n+    \/**\n+     * Name of the methods which will be called from every instrumented method.\n+     *\/\n+    public static final String COLLECTOR_METHOD = \"collect\";\n+    \/**\n+     * Signature of the method which will be called from every instrumented method.\n+     *\/\n+    public static final String COLLECTOR_DESC =\n+            \"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;[Ljava\/lang\/Object;)V\";\n+\n+    final static Map<String, TypeDescriptor> primitiveTypes;\n+\n+    static {\n+        primitiveTypes = new HashMap<>();\n+        primitiveTypes.put(\"S\", new TypeDescriptor(\"S\", Short.class, (cb, i) -> cb.iload(i), false, true));\n+        primitiveTypes.put(\"I\", new TypeDescriptor(\"I\", Integer.class, (cb, i) -> cb.iload(i), false, true));\n+        primitiveTypes.put(\"J\", new TypeDescriptor(\"J\", Long.class, (cb, i) -> cb.lload(i), true, true));\n+        primitiveTypes.put(\"F\", new TypeDescriptor(\"F\", Float.class, (cb, i) -> cb.fload(i), false, true));\n+        primitiveTypes.put(\"D\", new TypeDescriptor(\"D\", Double.class, (cb, i) -> cb.dload(i), true, true));\n+        primitiveTypes.put(\"Z\", new TypeDescriptor(\"Z\", Boolean.class, (cb, i) -> cb.iload(i), false, true));\n+        primitiveTypes.put(\"B\", new TypeDescriptor(\"B\", Byte.class, (cb, i) -> cb.iload(i), false, true));\n+        primitiveTypes.put(\"C\", new TypeDescriptor(\"C\", Character.class, (cb, i) -> cb.iload(i), false, true));\n+    }\n+\n+    public Plugin() throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException,\n+            IllegalAccessException, InstantiationException {\n+        Runtime.init();\n+    }\n+\n+    @Override\n+    public Map<String, Consumer<OutputStream>> complete() throws Exception {\n+        Consumer<OutputStream> writer = o -> {\n+            try {\n+                Coverage.write(Collect.data(), new BufferedWriter(new OutputStreamWriter(o)));\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        };\n+        return Map.of(CoverageData.COVERAGE_OUT, writer, InstrumentationPlugin.TEMPLATE_ARTIFACT, writer);\n+    }\n+\n+    public static List<TypeDescriptor> parseDesc(String desc) throws ClassNotFoundException {\n+        if(!desc.startsWith(\"(\")) throw new IllegalArgumentException(\"Not a method descriptor: \" + desc);\n+        int pos = 1;\n+        List<TypeDescriptor> res = new ArrayList<>();\n+        while(desc.charAt(pos) != ')') {\n+            char next = desc.charAt(pos);\n+            if(next == 'L') {\n+                int l = pos;\n+                pos = desc.indexOf(\";\", pos) + 1;\n+                res.add(new TypeDescriptor(\"L\", desc.substring(l + 1, pos - 1), (cb, i) -> cb.aload(i)));\n+            } else if(next == '[') {\n+                \/\/TODO can we do better?\n+                res.add(new TypeDescriptor(\"[\", \"java\/lang\/Object\", (cb, i) -> cb.aload(i)));\n+                if(desc.charAt(pos + 1) == 'L') pos = desc.indexOf(\";\", pos) + 1;\n+                else pos = pos + 2;\n+            } else {\n+                res.add(primitiveTypes.get(new String(new char[] {next})));\n+                pos++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    \/**\n+     * Injects necessary instructions to place all the arguments into an array which is then passed tp the collector's\n+     * method.\n+     *\/\n+    @Override\n+    public void instrument(ClassBuilder clb, MethodModel mm) throws Exception {\n+\/\/        if (mm.code().isPresent()) System.out.println(mm.parent().get().thisClass().name().stringValue());\n+        if (mm.code().isPresent() &&\n+                methodFilter.accept(mm.flags().flagsMask(), mm.parent().get().thisClass().name().stringValue(),\n+                    mm.methodName().stringValue(), mm.methodType().stringValue())) {\n+            Collect.template(clb.original().get().thisClass().name().toString(),\n+                    mm.methodName().stringValue(), mm.methodTypeSymbol().descriptorString());\n+            clb.withMethod(mm.methodName().stringValue(), mm.methodTypeSymbol(), mm.flags().flagsMask(), mb -> {\n+                mb.withCode(cb -> {\n+                    try {\n+                        List<TypeDescriptor> params = parseDesc(mm.methodType().stringValue());\n+                        if (params.size() > 0) {\n+                            cb.constantInstruction(mm.parent().get().thisClass().name().stringValue());\n+                            cb.constantInstruction(mm.methodName().stringValue());\n+                            cb.constantInstruction(mm.methodType().stringValue());\n+                            cb.bipush(params.size());\n+                            cb.anewarray(ClassDesc.of(Object.class.getName()));\n+                            \/\/TODO is this the correct STATIC?\n+                            int stackIndex = ((mm.flags().flagsMask() & Modifier.STATIC) > 0) ? 0 : 1;\n+                            for (int i = 0; i < params.size(); i++)\n+                                stackIndex = params.get(i).visit(i, stackIndex, cb);\n+                            cb.invokestatic(ClassDesc.of(COLLECTOR_CLASS.replace('\/', '.')), COLLECTOR_METHOD,\n+                                    MethodTypeDesc.of(ClassDesc.ofDescriptor(\"V\"),\n+                                            ClassDesc.of(String.class.getName()),\n+                                            ClassDesc.of(String.class.getName()),\n+                                            ClassDesc.of(String.class.getName()),\n+                                            ClassDesc.of(Object.class.getName()).arrayType()));\n+                        }\n+                    } catch (ClassNotFoundException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                    mm.code().get().elementList().forEach(element -> cb.with(element));\n+                });\n+            });\n+        } else {\n+            clb.accept(mm);\n+        }\n+    }\n+\n+    private static final Set<Class> runtimeClasses = Set.of(\n+            Collect.class, Coverage.class, Runtime.class,\n+            Runtime.CompletionTask.class\n+    );\n+\n+    @Override\n+    public Set<Class> runtime() {\n+        return runtimeClasses;\n+    }\n+\n+    \/**\n+     * Aux class responsible for code generation for different types.\n+     *\/\n+    public static class TypeDescriptor extends openjdk.jcov.data.instrument.TypeDescriptor {\n+\n+        public TypeDescriptor(String id, String cls, BiConsumer<CodeBuilder, Integer> loadOpcode) {\n+            super(id, cls, loadOpcode);\n+        }\n+\n+        public TypeDescriptor(String id, Class cls, BiConsumer<CodeBuilder, Integer> loadOpcode, boolean longOrDouble, boolean isPrimitive) {\n+            super(id, cls, loadOpcode, longOrDouble, isPrimitive);\n+        }\n+\n+        public int visit(int paramIndex, int stackIndex, CodeBuilder codeBuilder) {\n+            codeBuilder.dup();\n+            codeBuilder.bipush(paramIndex);\n+            load(codeBuilder, stackIndex);\n+            if(isPrimitive())\n+                codeBuilder.invokestatic(ClassDesc.of(cls()),\n+                        \"valueOf\", MethodTypeDesc.ofDescriptor(\"(\" + id() + \")L\" + vmCls() + \";\"));\n+            codeBuilder.aastore();\n+            return stackIndex + (isLongOrDouble() ? 2 : 1);\n+        }\n+    }\n+\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/arguments\/instrument\/Plugin.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"data\/classes\/openjdk\/jcov\/data\/arguments\/instrument\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/instrument\/package-info.java","status":"renamed"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.runtime;\n+\n+import openjdk.jcov.data.runtime.CoverageData;\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.runtime.EntryControl;\n+import openjdk.jcov.data.runtime.Serializer;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Calls to this class' collect(...) methods are injected in the beginning of every instrumented method.\n+ *\/\n+public class Collect {\n+    \/**\n+     * Property name prefix for all properties used by this plugin. The property names are started with\n+     * <code>Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX<\/code>\n+     *\/\n+    public static final String ARGUMENTS_PREFIX = \"args.\";\n+\n+    static volatile Coverage data;\n+    private static volatile Path outputFile;\n+    private static volatile Function<Object, String> serializer;\n+\n+    static {\n+            try {\n+                Path coverageFile = Env.getPathEnv(CoverageData.COVERAGE_IN, null);\n+                if(coverageFile != null)\n+                    data = Coverage.read(coverageFile);\n+                else\n+                    data = new Coverage();\n+                outputFile = Env.getPathEnv(CoverageData.COVERAGE_OUT, Paths.get(\"coverage.lst\"));\n+                serializer = Env.getSPIEnv(Serializer.SERIALIZER, Serializer.TO_STRING);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException |\n+                    InvocationTargetException | InstantiationException e) {\n+                throw new RuntimeException(e);\n+            }\n+    }\n+\n+    public static Coverage data() {return data;}\n+\n+    public static void data(Coverage data) {Collect.data = data;}\n+\n+    public static void outputFile(Path outputFile) {\n+        Collect.outputFile = outputFile;\n+    }\n+\n+    public static void serializer(Function<Object, String> serializer) {\n+        Collect.serializer = serializer;\n+    }\n+\n+    public static synchronized void template(String owner, String name, String desc) {\n+        data.add(owner, name + desc, null);\n+    }\n+\n+    private final static EntryControl entryControl = new EntryControl();\n+\n+    public static synchronized void collect(String owner, String name, String desc, Object... params) {\n+\/\/        keep these lines, it is useful for debugging in hard cases\n+\/\/        System.out.println(\"Collect.collect has been called with\");\n+\/\/        System.out.printf(\"%s.%s%s: %s\\n\", owner, name, desc, (params == null) ? \"null\" :\n+\/\/                Arrays.stream(params).map(Object::getClass).map(Class::getName)\n+\/\/                        .collect(java.util.stream.Collectors.joining(\",\")));\n+\/\/        System.out.println(Arrays.stream(params).map(java.util.Objects::toString)\n+\/\/                .collect(Collectors.joining(\",\")));\n+        Runtime.init();\n+        if (!entryControl.enter()) return;\n+        try {\n+            if (!data.writing)\n+                data.add(owner, name + desc, Arrays.stream(params)\n+                    .collect(Collectors.toList()));\n+        } finally {\n+            entryControl.exit();\n+        }\n+    }\n+\n+    static int countParams(String desc) {\n+        if(!desc.startsWith(\"(\")) throw new IllegalArgumentException(\"Not a method descriptor: \" + desc);\n+        int pos = 1;\n+        int count = 0;\n+        while(desc.charAt(pos) != ')') {\n+            char next = desc.charAt(pos);\n+            if(next == 'L') {\n+                int l = pos;\n+                pos = desc.indexOf(\";\", pos) + 1;\n+                count++;\n+            } else if(next == '[') {\n+                \/\/TODO can we do better?\n+                count++;\n+                if(desc.charAt(pos + 1) == 'L') pos = desc.indexOf(\";\", pos) + 1;\n+                else pos = pos + 2;\n+            } else {\n+                count++;\n+                pos++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    public static void clearData() {\n+        data.coverage().clear();\n+    }\n+\n+    public static void save() throws IOException {\n+        System.out.println(\"Saving the data info \" + outputFile);\n+        Coverage.write(data, outputFile, serializer);\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/arguments\/runtime\/Collect.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.runtime;\n+\n+import openjdk.jcov.data.runtime.CoverageData;\n+import openjdk.jcov.data.runtime.Serializer;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+\/**\n+ * Data container for the values collected in runtime. Same class is used to store template as a file with no\n+ * values and just method descriptions.\n+ *\/\n+public class Coverage {\n+\n+    public static final String DATA_PREFIX = \" -> \";\n+    private final Map<String, Map<String, List<List<? extends Object>>>> data;\n+    volatile boolean writing = false;\n+\n+    public static Coverage read(Path path) throws IOException {\n+        return readImpl(path, s -> s);\n+    }\n+\n+    \/\/TODO move to an SPI class\n+    public static Coverage read(Path path, Function<String, ? extends Object> deserializer) throws IOException {\n+        return readImpl(path, deserializer);\n+    }\n+\n+    \/**\n+     * Loads the data from a file in a custom plain text format.\n+     *\/\n+    private static Coverage readImpl(Path path, Function<String, ? extends Object> deserializer) throws IOException {\n+        Coverage result = new Coverage();\n+        List<List<? extends Object>> lastData = null;\n+        String desc = null, name = null, owner = null;\n+        for (String l : Files.readAllLines(path)) {\n+            if (!l.startsWith(DATA_PREFIX)) {\n+                int descStart = l.indexOf('(');\n+                int classEnd = l.lastIndexOf('#', descStart);\n+                owner = l.substring(0, classEnd);\n+                name = l.substring(classEnd + 1, descStart);\n+                desc = l.substring(descStart);\n+                lastData = result.get(owner, name + desc);\n+            } else {\n+                List<? extends Object> values = CoverageData.parse(l.substring(DATA_PREFIX.length()), deserializer);\n+                \/\/TODO this needs to be fixed for arrays\n+\/\/                if(Collect.countParams(desc) != values.size()) {\n+\/\/                    throw new IllegalStateException(\"Incorrect number of parameters for \" +\n+\/\/                            owner + \"#\" + name + desc + \": \" + values.size());\n+\/\/                }\n+                lastData.add(values);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/\/TODO move to an SPI class\n+\n+    \/**\n+     * Saves the data into a file in a custom plain text format.\n+     *\/\n+    public static void write(Coverage coverage, Path path) throws IOException {\n+        write(coverage, path, (Serializer) o -> o.toString());\n+    }\n+    public static void write(Coverage coverage, BufferedWriter out) throws IOException {\n+        write(coverage, out, (Serializer) o -> o.toString());\n+    }\n+    public static void write(Coverage coverage, Path path, Function<Object, String> serializer)\n+            throws IOException {\n+        try (BufferedWriter out = Files.newBufferedWriter(path)){\n+            write(coverage, out, serializer);\n+        }\n+    }\n+    public static void write(Coverage coverage, BufferedWriter out, Function<Object, String> serializer)\n+            throws IOException {\n+        try {\n+            coverage.writing = true;\n+            coverage.data.entrySet().forEach(ce -> {\n+                ce.getValue().entrySet().forEach(me -> {\n+                    try {\n+                        out.write(ce.getKey() + \"#\" + me.getKey());\n+                        out.newLine();\n+                        me.getValue().forEach(dl -> {\n+                            try {\n+                                String desc = me.getKey().substring(me.getKey().indexOf(\"(\"));\n+                                List<String> values = dl.stream()\n+                                        .map(serializer::apply)\n+                                        .collect(toList());\n+                                if (Collect.countParams(desc) != values.size()) {\n+                                    System.err.println(\"Incorect number of params for \" + me.getKey());\n+                                    System.out.println(values.stream().map(Objects::toString)\n+                                            .collect(Collectors.joining(\",\")));\n+                                    throw new IllegalStateException(\"Incorrect number of parameters for \" +\n+                                            me.getKey() + \": \" + values.size());\n+                                }\n+                                out.write(DATA_PREFIX +\n+                                        values.stream().collect(Collectors.joining(\",\")));\n+                                out.newLine();\n+                            } catch (IOException e) {\n+                                throw new UncheckedIOException(e);\n+                            }\n+                        });\n+                        out.flush();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+            });\n+        } finally {\n+            coverage.writing = false;\n+        }\n+    }\n+\n+    private final boolean selfCompacting = true;\n+\n+    public Coverage() {\n+        data = new HashMap<>();\n+    }\n+\n+    \/**\n+     * Obtains a structure for the data, adding an empty one, if necessary.\n+     *\/\n+    public List<List<? extends Object>> get(String owner, String method) {\n+        Map<String, List<List<? extends Object>>> methods = data.get(owner);\n+        if(methods == null) {\n+            methods = new HashMap<>();\n+            data.put(owner, methods);\n+        }\n+        List<List<? extends Object>> result = methods.get(method);\n+        if(result == null) {\n+            result = new ArrayList<>();\n+            methods.put(method, result);\n+        }\n+        return result;\n+    }\n+\n+    public void add(String owner, String method, List<? extends Object> params) {\n+        List<List<? extends Object>> methodCov = get(owner, method);\n+        if(params != null)\n+            if(methodCov.stream().noneMatch(call -> {\n+                if(call.size() != params.size()) return false;\n+                for (int i = 0; i < call.size(); i++)\n+                    if(!Objects.equals(call.get(i), params.get(i))) return false;\n+                return true;\n+            })) methodCov.add(params);\n+    }\n+\n+    public Map<String, Map<String, List<List<? extends Object>>>> coverage() {\n+        return data;\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/arguments\/runtime\/Coverage.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.runtime;\n+\n+import openjdk.jcov.data.runtime.EntryControl;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+\n+public class Runtime extends openjdk.jcov.data.runtime.Runtime {\n+\n+    public static void main(String[] args) {\n+        init();\n+    }\n+\n+    public static class CompletionTask implements Runnable {\n+        public void run() {\n+            try {\n+                Path out = coverageOut();\n+                if(out != null) {\n+                    System.out.println(\"Saving collected coverage to \" + out);\n+                    Coverage.write(Collect.data(), out, serializer());\n+                } else {\n+                    System.err.println(\"No output file specified!\");\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Exception during shutting down.\", e);\n+            }\n+        }\n+    }\n+    static {\n+        try {\n+            Collect.data(initialData());\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Exception during runtime initialization\", e);\n+        }\n+        addCompletionTask(new CompletionTask());\n+    }\n+\n+    private static Coverage initialData() throws IOException, ClassNotFoundException, InvocationTargetException,\n+            NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        Path inputFile = openjdk.jcov.data.runtime.Runtime.coverageIn();\n+        if (inputFile != null) {\n+            System.out.println(\"Loading data coverage from \" + inputFile);\n+            return Coverage.read(inputFile, deserializer());\n+        } else return new Coverage();\n+    }\n+\n+    public static void init() {\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/arguments\/runtime\/Runtime.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"data\/classes\/openjdk\/jcov\/data\/arguments\/runtime\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/package-info.java","status":"renamed"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.instrument;\n+\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import openjdk.jcov.data.fields.runtime.Collect;\n+import openjdk.jcov.data.fields.runtime.Coverage;\n+import openjdk.jcov.data.fields.runtime.Runtime;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class Plugin extends openjdk.jcov.data.instrument.Plugin {\n+    public Plugin() throws IOException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        Runtime.init();\n+    }\n+    @Override\n+    public Map<String, Consumer<OutputStream>> complete() throws Exception {\n+        \/\/this plugin does not generate a template during the instrumentation\n+        \/\/the template needs to be generated before - such as by TemplateGenerator class\n+        return Map.of();\n+    }\n+\n+    private static final Set<Class> runtime = Set.of(\n+            Collect.class, Coverage.class, Runtime.class, Runtime.CompletionTask.class\n+    );\n+\n+    @Override\n+    public Set<Class> runtime() {\n+        return runtime;\n+    }\n+\n+    @Override\n+    public void instrument(ClassBuilder clb, MethodModel mm) throws Exception {\n+        if (methodFilter.accept(mm.flags().flagsMask(), mm.parent().get().thisClass().name().stringValue(),\n+                mm.methodName().stringValue(), mm.methodType().stringValue())) {\n+            clb.withMethod(mm.methodName().stringValue(), mm.methodTypeSymbol(), mm.flags().flagsMask(), mb -> {\n+                mb.withCode(cb -> {\n+                    mm.code().get().elementList().forEach(element -> {\n+                        if(element instanceof FieldInstruction) {\n+                            FieldInstruction instruction = (FieldInstruction) element;\n+                            if (instruction.opcode().equals(Opcode.PUTFIELD) || instruction.opcode().equals(Opcode.PUTSTATIC)) {\n+                                try {\n+                                    if (Collect.data().contains(\n+                                            instruction.owner().name().stringValue(),\n+                                            instruction.name().stringValue())) {\n+                                        String vmType = instruction.type().stringValue();\n+                                        if (vmType.startsWith(\"L\") || vmType.startsWith(\"[\")) {\n+                                            new Plugin.\n+                                                    TypeDescriptor(\"L\", instruction.owner().name()\n+                                                    .stringValue()).visit(cb, instruction);\n+                                        } else {\n+                                            primitiveTypes.get(vmType).visit(cb, instruction);\n+                                        }\n+                                    } else cb.with(element);\n+                                } catch (Exception e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            } else cb.with(element);\n+                        } else cb.with(element);\n+                    });\n+                });\n+            });\n+        } else {\n+            clb.accept(mm);\n+        }\n+    }\n+\n+    public static class TypeDescriptor extends openjdk.jcov.data.instrument.TypeDescriptor {\n+\n+        public TypeDescriptor(String id, String cls) {\n+            super(id, cls, (a,b) -> {});\n+        }\n+\n+        public TypeDescriptor(String id, Class cls, boolean longOrDouble, boolean isPrimitive) {\n+            super(id, cls, (a,b) -> {}, longOrDouble, isPrimitive);\n+        }\n+\n+        public void visit(CodeBuilder codeBuilder, FieldInstruction fi) {\n+            if(isLongOrDouble()) codeBuilder.dup2();\n+            else codeBuilder.dup();\n+            if(isPrimitive())\n+                codeBuilder.invokestatic(ClassDesc.of(cls()),\n+                        \"valueOf\", MethodTypeDesc.ofDescriptor(\"(\" + id() + \")L\" + vmCls() + \";\"));\n+            codeBuilder.constantInstruction(fi.owner().name().stringValue());\n+            codeBuilder.constantInstruction(fi.name().stringValue());\n+            codeBuilder.invokestatic(ClassDesc.of(Collect.class.getName().replace('\/', '.')),\n+                    \"collect\",\n+                    MethodTypeDesc.of(ClassDesc.ofDescriptor(\"V\"),\n+                            ClassDesc.of(Object.class.getName()),\n+                            ClassDesc.of(String.class.getName()),\n+                            ClassDesc.of(String.class.getName())));\n+            codeBuilder.with(fi);\n+        }\n+    }\n+\n+    final static Map<String, TypeDescriptor> primitiveTypes;\n+\n+    static {\n+        primitiveTypes = new HashMap<>();\n+        primitiveTypes.put(\"S\", new TypeDescriptor(\"S\", Short.class, false, true));\n+        primitiveTypes.put(\"I\", new TypeDescriptor(\"I\", Integer.class, false, true));\n+        primitiveTypes.put(\"J\", new TypeDescriptor(\"J\", Long.class, true, true));\n+        primitiveTypes.put(\"F\", new TypeDescriptor(\"F\", Float.class, false, true));\n+        primitiveTypes.put(\"D\", new TypeDescriptor(\"D\", Double.class, true, true));\n+        primitiveTypes.put(\"Z\", new TypeDescriptor(\"Z\", Boolean.class, false, true));\n+        primitiveTypes.put(\"B\", new TypeDescriptor(\"B\", Byte.class, false, true));\n+        primitiveTypes.put(\"C\", new TypeDescriptor(\"C\", Character.class, false, true));\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/fields\/instrument\/Plugin.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.instrument;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.FieldModel;\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.fields.runtime.Collect;\n+import openjdk.jcov.data.fields.runtime.Runtime;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n+\n+public class TemplateGenerator {\n+    public static final String FIELD_FILTER =\n+            JCOV_DATA_ENV_PREFIX + openjdk.jcov.data.arguments.runtime.Collect.ARGUMENTS_PREFIX + \"field.filter\";\n+\n+    public interface FieldFilter {\n+        boolean accept(FieldModel fieldModel) throws Exception;\n+    }\n+\n+    private FieldFilter fieldFilter;\n+\n+    public TemplateGenerator() throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        this.fieldFilter = Env.getSPIEnv(FIELD_FILTER, fm -> true);\n+    }\n+\n+    public void setFieldFilter(FieldFilter fieldFilter) {\n+        this.fieldFilter = fieldFilter;\n+    }\n+\n+    public void generate(Path root) throws IOException {\n+        List<Path> allClasses = new ArrayList<>();\n+        Files.walkFileTree(root, new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                if (file.getFileName().toString().endsWith(\".class\")) {\n+                    allClasses.add(file);\n+                }\n+                return super.visitFile(file, attrs);\n+            }\n+        });\n+        generate(allClasses);\n+    }\n+\n+    public void generate(List<Path> classes) {\n+        classes.forEach(file -> {\n+            try {\n+                Classfile.parse(Files.readAllBytes(file)).fields().forEach(fm -> {\n+                    try {\n+                        if (fieldFilter.accept(fm)) Collect.template(fm);\n+                    } catch (Exception e) {\n+                        throw new RuntimeException();\n+                    }\n+                });\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+    }\n+\n+    public static void main(String[] args) throws IOException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        Runtime.init();\n+        TemplateGenerator generator = new TemplateGenerator();\n+        if (args.length > 1) {\n+            generator.generate(Arrays.stream(args).map(Path::of).collect(Collectors.toList()));\n+        } else if (args[0].startsWith(\"jrt:\/\")) {\n+            generator.generate(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(args[0].substring(\"jrt:\/\".length())));\n+        } else {\n+            generator.generate(Path.of(args[0]));\n+        }\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/fields\/instrument\/TemplateGenerator.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.runtime;\n+\n+\n+import jdk.internal.classfile.FieldModel;\n+import openjdk.jcov.data.runtime.EntryControl;\n+\n+public class Collect {\n+\n+    private static volatile Coverage data = new Coverage();\n+\n+    public static void template(FieldModel fieldModel) {\n+        data.get(fieldModel.parent().get().thisClass().name().stringValue(), fieldModel.fieldName().stringValue());\n+    }\n+\n+    private final static EntryControl entryControl = new EntryControl();\n+\n+    public static void collect(Object value, String owner, String name) {\n+        Runtime.init();\n+        if(!entryControl.enter()) return;\n+        try {\n+            if (!data.writing) data.add(owner, name, value);\n+        } finally {\n+            entryControl.exit();\n+        }\n+    }\n+\n+    public static void data(Coverage data) {\n+        Collect.data = data;\n+    }\n+\n+    public static Coverage data() {\n+        return data;\n+    }\n+\n+    static void setData(Coverage data) {\n+        Collect.data = data;\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/fields\/runtime\/Collect.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.runtime;\n+\n+import openjdk.jcov.data.runtime.Serializer;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class Coverage {\n+    public static final String DATA_PREFIX = \" -> \";\n+    private final Map<String, Map<String, List>> data;\n+    volatile boolean writing;\n+\n+    public Coverage() {\n+        data = new HashMap<>();\n+    }\n+\n+    public Map<String, Map<String, List>> coverage() {\n+        return data;\n+    }\n+\n+    \/**\n+     * Obtains a structure for the data, adding an empty one, if necessary.\n+     *\/\n+    public List<? extends Object> get(String owner, String field) {\n+        Map<String, List> fields = data.get(owner);\n+        if(fields == null) {\n+            fields = new HashMap<>();\n+            data.put(owner, fields);\n+        }\n+        List<? extends Object> fieldCov = fields.get(field);\n+        if(fieldCov == null) {\n+            fieldCov = new ArrayList<>();\n+            fields.put(field, fieldCov);\n+        }\n+        return fieldCov;\n+    }\n+\n+    public boolean contains(String owner) {\n+        return data.containsKey(owner);\n+    }\n+\n+    public boolean contains(String owner, String field) {\n+        return contains(owner) && data.get(owner).containsKey(field);\n+    }\n+\n+    public void add(String owner, String field, Object value) {\n+        List fieldCov = get(owner, field);\n+        if(fieldCov.stream().noneMatch(val -> Objects.equals(val, value)))\n+            fieldCov.add(value);\n+    }\n+\n+    public static Coverage read(Path file) throws IOException {\n+        return read(file, s -> s);\n+    }\n+\n+    public static Coverage read(Path path, Function<String, ? extends Object> deserializer) throws IOException {\n+        Coverage result = new Coverage();\n+        List lastData = null;\n+        for (String l : Files.readAllLines(path)) {\n+            if (!l.startsWith(DATA_PREFIX)) {\n+                int classEnd = l.indexOf('#');\n+                String owner = l.substring(0, classEnd);\n+                String name = l.substring(classEnd + 1);\n+                lastData = result.get(owner, name);\n+            } else {\n+                Object value = deserializer.apply(l.substring(DATA_PREFIX.length()));\n+                lastData.add(value);\n+            }\n+        }\n+        return result;\n+    }\n+    \/**\n+     * Saves the data into a file in a custom plain text format.\n+     *\/\n+    public static void write(Coverage coverage, Path path) throws IOException {\n+        write(coverage, path, Serializer.TO_STRING);\n+    }\n+    public static void write(Coverage coverage, Path path, Function<Object, String> serializer)\n+            throws IOException {\n+        write(coverage, Files.newOutputStream(path), serializer);\n+    }\n+    public static void write(Coverage coverage, OutputStream outStream) throws IOException {\n+        write(coverage, outStream, Serializer.TO_STRING);\n+    }\n+    public static void write(Coverage coverage, OutputStream outStream, Function<Object, String> serializer)\n+            throws IOException {\n+        coverage.writing = true;\n+        try(BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream))) {\n+            coverage.data.entrySet().forEach(ce -> {\n+                ce.getValue().entrySet().forEach(me -> {\n+                    try {\n+                        out.write(ce.getKey() + \"#\" + me.getKey());\n+                        out.newLine();\n+                        me.getValue().forEach(d -> {\n+                            try {\n+                                out.write(DATA_PREFIX + serializer.apply(d));\n+                                out.newLine();\n+                            } catch (IOException e) {\n+                                throw new UncheckedIOException(e);\n+                            }\n+                        });\n+                        out.flush();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+            });\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        } finally {\n+            coverage.writing = false;\n+        }\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/fields\/runtime\/Coverage.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.runtime;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+\n+public class Runtime extends openjdk.jcov.data.runtime.Runtime {\n+\n+    public static void main(String[] args) {\n+        Runtime.class.getName();\n+    }\n+\n+    public static class CompletionTask implements Runnable {\n+        @Override\n+        public void run() {\n+            try {\n+                Path out = coverageOut();\n+                if(out != null)\n+                    Coverage.write(Collect.data(), out, serializer());\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Exception during shutting down.\", e);\n+            }\n+        }\n+    }\n+\n+    static {\n+        try {\n+            Collect.setData(initialData());\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Exception during runtime initialization\", e);\n+        }\n+        addCompletionTask(new CompletionTask());\n+    }\n+\n+    private static Coverage initialData() throws IOException, ClassNotFoundException, InvocationTargetException,\n+            NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        Path inputFile = openjdk.jcov.data.runtime.Runtime.coverageIn();\n+        if (inputFile != null) {\n+            System.out.println(\"Loading data coverage from \" + inputFile);\n+            return Coverage.read(inputFile, deserializer());\n+        } else return new Coverage();\n+    }\n+\n+    public static void init() {\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/fields\/runtime\/Runtime.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.instrument;\n+\n+public class ArgumentTypeMethodFilter implements MethodFilter {\n+    private final Class argumentType;\n+\n+    public ArgumentTypeMethodFilter(Class type) {\n+        argumentType = type;\n+    }\n+\n+    @Override\n+    public boolean accept(int access, String owner, String name, String desc) throws Exception {\n+        return openjdk.jcov.data.arguments.instrument.Plugin.parseDesc(desc).stream().anyMatch(td -> {\n+            try {\n+                return argumentType.isAssignableFrom(Class.forName(td.cls().replace('\/', '.')));\n+            } catch (ClassNotFoundException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/instrument\/ArgumentTypeMethodFilter.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.instrument;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.plugin.ClassListSource;\n+import com.sun.tdk.jcov.instrument.plugin.ImplantingPlugin;\n+import com.sun.tdk.jcov.instrument.plugin.Instrumentation;\n+import com.sun.tdk.jcov.instrument.plugin.PathDestination;\n+import com.sun.tdk.jcov.instrument.plugin.PathSource;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.MethodModel;\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.runtime.CoverageData;\n+import openjdk.jcov.data.runtime.Deserializer;\n+import openjdk.jcov.data.runtime.EntryControl;\n+import openjdk.jcov.data.runtime.Runtime;\n+import openjdk.jcov.data.runtime.Serializer;\n+\n+import java.io.OutputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n+\n+public class Instrument {\n+    \/**\n+     * Name of a system property which contains class name of an instrumentation plugin.\n+     *\/\n+    public static final String PLUGIN_CLASS = JCOV_DATA_ENV_PREFIX + \"plugin\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Path src = Paths.get(args[0]);\n+        Path dest;\n+        if(args.length > 2)\n+            dest = Paths.get(args[1]);\n+        else\n+            dest = src;\n+        Plugin plugin = Env.getSPIEnv(PLUGIN_CLASS, new DoNothingPlugin());\n+        Set<Class> runtime = new HashSet<>(plugin.runtime());\n+        runtime.addAll(Set.of(CoverageData.class, Deserializer.class, Runtime.class, Serializer.class, Env.class,\n+                EntryControl.class));\n+        Set.of(Runtime.serializer().getClass(), Runtime.deserializer().getClass()).forEach(cls -> {\n+            if (!runtime.contains(cls)) runtime.add(cls);\n+        });\n+        com.sun.tdk.jcov.instrument.InstrumentationPlugin imlanting =\n+                new ImplantingPlugin(plugin, new ClassListSource(Instrument.class.getClassLoader(),\n+                runtime));\n+        Instrumentation instrumentation = new Instrumentation(imlanting);\n+        instrumentation.instrument(new PathSource(ClassLoader.getSystemClassLoader(), src),\n+                new PathDestination(dest), new InstrumentationParams());\n+    }\n+\n+    private static class DoNothingPlugin extends Plugin {\n+\n+        public DoNothingPlugin() throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException,\n+                IllegalAccessException, InstantiationException {\n+        }\n+\n+        @Override\n+        public Map<String, Consumer<OutputStream>> complete() throws Exception {\n+            return Map.of();\n+        }\n+\n+        @Override\n+        public Set<Class> runtime() {\n+            return Set.of();\n+        }\n+\n+        @Override\n+        public void instrument(ClassBuilder clb, MethodModel mm) throws Exception {\n+\n+        }\n+\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/instrument\/Instrument.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.instrument;\n+\n+import com.sun.tdk.jcov.JREInstr;\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.runtime.EntryControl;\n+import openjdk.jcov.data.runtime.Runtime;\n+import openjdk.jcov.data.runtime.Serializer;\n+import openjdk.jcov.data.runtime.serialization.ToStringSerializer;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+import java.util.stream.Collectors;\n+\n+public class InstrumentJDK {\n+\n+    private final Plugin plugin;\n+\n+    public InstrumentJDK(Plugin plugin) {\n+        this.plugin = plugin;\n+    }\n+\n+    public int instrument(Path jdk, List<String> modules, Class<? extends Plugin> aClass,\n+                          List<String> exports,\n+                          String includes, Path template) throws IOException {\n+        List<String> params = new ArrayList<>();\n+        modules.forEach(m -> {\n+            params.add(\"-im\"); params.add(m);\n+        });\n+        params.add(\"-i\"); params.add(includes);\n+        params.add(\"-instr_plugin\"); params.add(aClass.getName());\n+        params.add(\"-t\"); params.add(template.toString());\n+        Path rt = createRtJar(exports);\n+        params.add(\"-rt\"); params.add(rt.toString());\n+        params.add(jdk.toString());\n+        System.out.println(\"Running JREInstr with: \" + params.stream().collect(Collectors.joining(\" \")));\n+        try {\n+            return new JREInstr().run(params.toArray(new String[0]));\n+        } finally {\n+            Files.deleteIfExists(rt);\n+        }\n+    }\n+\n+    public Path createRtJar(List<String> exports) throws IOException {\n+        Path dest = Files.createTempFile(\"rtjar\", \".jar\");\n+        List<Class> runtime = new ArrayList<>(plugin.runtime());\n+        \/\/TODO move to Plugin\n+        runtime.addAll(List.of(Env.class, Runtime.class, Serializer.class, ToStringSerializer.class,\n+                EntryControl.class));\n+        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n+            jar.putNextEntry(new JarEntry(JREInstr.JCOV_EXPORTS_FILE_NAME  ));\n+            for (String e : exports) {\n+                jar.write((e + \"=ALL-UNNAMED\").getBytes());\n+                jar.write(System.getProperty(\"line.separator\").getBytes());\n+            }\n+            for (Class cls : runtime) {\n+                String entryName = cls.getName().replace('.', '\/') + \".class\";\n+                jar.putNextEntry(new JarEntry(entryName));\n+                try (InputStream ci = cls.getClassLoader()\n+                        .getResourceAsStream(entryName)) {\n+                    byte[] buffer = new byte[1024];\n+                    int read;\n+                    while ((read = ci.read(buffer)) > 0) {\n+                        jar.write(buffer, 0, read);\n+                    }\n+                }\n+            }\n+        }\n+        return dest;\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/instrument\/InstrumentJDK.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.instrument;\n+\n+public interface MethodFilter {\n+    boolean accept(int access, String owner, String name, String desc) throws Exception;\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/instrument\/MethodFilter.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.instrument;\n+\n+import com.sun.tdk.jcov.instrument.ModuleInstrumentationPlugin;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleExportInfo;\n+import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class ModulePlugin implements ModuleInstrumentationPlugin {\n+    @Override\n+    public String getModuleName(byte[] bytes) {\n+        ClassModel cls = Classfile.parse(bytes);\n+        if (cls.isModuleInfo()) {\n+            ModuleAttribute attr = ((ModuleAttribute) cls.attributes().stream()\n+                    .filter(a -> a.attributeMapper() == Attributes.MODULE)\n+                    .findFirst()\n+                    .orElseThrow());\n+            return attr.moduleName().name().stringValue();\n+        } else throw new IllegalStateException(\"Not a module!\");\n+    }\n+\n+    @Override\n+    public byte[] addExports(List<String> packages, byte[] bytes, ClassLoader loader) {\n+        ClassModel cls = Classfile.parse(bytes);\n+        if (cls.isModuleInfo()) {\n+            return cls.transform((builder, element) -> {\n+                if(element instanceof ModuleAttribute) {\n+                    ModuleAttribute me = (ModuleAttribute) element;\n+                    List<ModuleExportInfo> newExports = new ArrayList<>(me.exports());\n+                    newExports.addAll(packages.stream().map(p ->\n+                            ModuleExportInfo.of(PackageDesc.of(p), 0)).collect(Collectors.toList()));\n+                    builder.with(ModuleAttribute.of(me.moduleName(), me.moduleFlagsMask(), me.moduleVersion().get(),\n+                            me.requires(), newExports, me.opens(), me.uses(), me.provides()));\n+                } else if (element instanceof ModulePackagesAttribute) {\n+                    ModulePackagesAttribute mpe = (ModulePackagesAttribute) element;\n+                    List<PackageDesc> newPackages = new ArrayList<>(mpe.packages().stream()\n+                            .map(pe -> PackageDesc.of(pe.name().stringValue().replace('\/', '.')))\n+                            .collect(Collectors.toList()));\n+                    newPackages.addAll(packages.stream().map(PackageDesc::of).collect(Collectors.toList()));\n+                    builder.with(ModulePackagesAttribute.ofNames(newPackages));\n+                } else builder.with(element);\n+            });\n+        } else throw new IllegalStateException(\"Not a module!\");\n+    }\n+\n+    @Override\n+    public byte[] clearHashes(byte[] bytes, ClassLoader loader) {\n+        ClassModel cls = Classfile.parse(bytes);\n+        if (cls.isModuleInfo()) {\n+            return cls.transform((builder, element) -> {\n+                if(element instanceof ModuleHashesAttribute) {\n+                } else builder.with(element);\n+            });\n+        } else throw new IllegalStateException(\"Not a module!\");\n+    }\n+\/\/\n+\/\/    public static void main(String[] args) throws IOException {\n+\/\/        Path module_info = FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getRootDirectories().iterator().next()\n+\/\/                .resolve(\"\/modules\").resolve(\"java.base\").resolve(\"module-info.class\");\n+\/\/        byte[] orig = Files.readAllBytes(module_info);\n+\/\/        byte[] addd = new ModulePlugin().addExports(List.of(\"other.pkg\"), orig, ClassLoader.getSystemClassLoader());\n+\/\/        addd = new ModulePlugin().clearHashes(addd, ClassLoader.getSystemClassLoader());\n+\/\/        System.out.println(orig.length);\n+\/\/        System.out.println(addd.length);\n+\/\/\/\/        System.out.println(module_info);\n+\/\/    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/instrument\/ModulePlugin.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.instrument;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.ModuleInstrumentationPlugin;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleExportInfo;\n+import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n+\n+\n+public abstract class Plugin extends ModulePlugin implements InstrumentationPlugin {\n+    \/**\n+     * Name of a property which contains class name for the method filter.\n+     *\/\n+    public static final String METHOD_FILTER =\n+            JCOV_DATA_ENV_PREFIX + Collect.ARGUMENTS_PREFIX + \"method.filter\";\n+    protected MethodFilter methodFilter;\n+\n+    public Plugin() throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException,\n+            IllegalAccessException, InstantiationException {\n+        methodFilter = Env.getSPIEnv(METHOD_FILTER, (a, o, m, d) -> true);\n+    }\n+\n+    private final Set<String> JCOV_FORCED_CLASSES = Set.of(\"java\/lang\/Shutdown\", \"java\/lang\/invoke\/LambdaForm\");\n+\n+    @Override\n+    public void instrument(Collection<String> collection, ClassLoader loader, BiConsumer<String, byte[]> consumer,\n+                           InstrumentationParams params) throws Exception {\n+        for (String r: collection) {\n+            if (isClass(r)) {\n+                ClassModel model = Classfile.parse(loader.getResourceAsStream(r).readAllBytes());\n+                if (!JCOV_FORCED_CLASSES.stream().anyMatch(c -> model.thisClass().name().stringValue().startsWith(c))) {\n+\/\/                byte[] oldContent =  model.transform((classBuilder, ce) -> {\n+\/\/                    classBuilder.with(ce);\n+\/\/                });\n+                    byte[] newContent = model.transform((classBuilder, ce) -> {\n+                        if (ce instanceof MethodModel) {\n+                            MethodModel mm = (MethodModel) ce;\n+                            try {\n+                                instrument(classBuilder, mm);\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        } else classBuilder.with(ce);\n+                    });\n+                    consumer.accept(r, newContent);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void methodFilter(MethodFilter methodFilter) {\n+        this.methodFilter = methodFilter;\n+    }\n+\n+    abstract public void instrument(ClassBuilder clb, MethodModel mm) throws Exception;\n+    abstract public Set<Class> runtime();\n+\n+    @Override\n+    public String getModuleName(byte[] bytes) {\n+        ClassModel cls = Classfile.parse(bytes);\n+        if (cls.isModuleInfo()) {\n+            ModuleAttribute attr = ((ModuleAttribute) cls.attributes().stream()\n+                    .filter(a -> a.attributeMapper() == Attributes.MODULE)\n+                    .findFirst()\n+                    .orElseThrow());\n+            return attr.moduleName().name().stringValue();\n+        } else throw new IllegalStateException(\"Not a module!\");\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/instrument\/Plugin.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.instrument;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+\n+import java.util.function.BiConsumer;\n+\n+\/**\n+ * Contains necessary type information for code generation, etc. Should be extended as needed with the actual code\n+ * generation logic.\n+ *\/\n+public class TypeDescriptor {\n+    private final String id;\n+    private final String cls;\n+    private final BiConsumer<CodeBuilder, Integer> load;\n+    private final boolean longOrDouble;\n+    private final boolean isPrimitive;\n+\n+    public static String toVMClassName(Class cls) {\n+        return toVMClassName(cls.getName());\n+    }\n+    public static String toVMClassName(String className) {\n+        return className.replace('.','\/');\n+    }\n+    public TypeDescriptor(String id, Class cls, BiConsumer<CodeBuilder, Integer> load) {\n+        this(id, toVMClassName(cls), load);\n+    }\n+    public TypeDescriptor(String id, String cls, BiConsumer<CodeBuilder, Integer> load) {\n+        this(id, cls, load, false, false);\n+    }\n+    public TypeDescriptor(String id, Class cls, BiConsumer<CodeBuilder, Integer>load, boolean longOrDouble, boolean isPrimitive) {\n+        this(id, cls.getName(), load, longOrDouble, isPrimitive);\n+    }\n+    public TypeDescriptor(String id, String cls, BiConsumer<CodeBuilder, Integer> load, boolean longOrDouble, boolean isPrimitive) {\n+        this.id = id;\n+        this.cls = cls;\n+        this.load = load;\n+        this.longOrDouble = longOrDouble;\n+        this.isPrimitive = isPrimitive;\n+    }\n+\n+    public String id() {\n+        return id;\n+    }\n+\n+    public String cls() { return cls; }\n+\n+    public String vmCls() { return toVMClassName(cls); }\n+\n+    public void load(CodeBuilder code, int index) {\n+        load.accept(code, index);\n+    }\n+\n+    public boolean isLongOrDouble() {\n+        return longOrDouble;\n+    }\n+\n+    public boolean isPrimitive() {\n+        return isPrimitive;\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/instrument\/TypeDescriptor.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.runtime;\n+\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toList;\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n+\n+public interface CoverageData {\n+    \/**\n+     * Specifies where to save collected data or instrumentation information.\n+     *\/\n+    String COVERAGE_OUT = JCOV_DATA_ENV_PREFIX + Collect.ARGUMENTS_PREFIX +\n+            \"coverage\";\n+    \/**\n+     * Specifies where to load previously collected data from. A non-empty value of this property will\n+     * make Collect class to load the data on class loading.\n+     *\/\n+    String COVERAGE_IN = JCOV_DATA_ENV_PREFIX + Collect.ARGUMENTS_PREFIX +\n+            \"coverage.in\";\n+\n+    public static List<String> split(String s) {\n+                List<String> result = new ArrayList<>();\n+                int lci = -1;\n+                for (int ci = 0; ci < s.length(); ci++) {\n+                    if(s.charAt(ci) == ',') {\n+                        result.add(s.substring(lci + 1, ci));\n+                        lci = ci;\n+                    }\n+                }\n+                result.add(s.substring(lci + 1));\n+                return result;\n+            }\n+\n+    public static List<? extends Object> parse(String s, Function<String, ? extends Object> deserialize) {\n+                return split(s).stream()\n+                        .map(v -> v.isEmpty() ? \"\" : deserialize.apply(v))\n+                        .collect(toList());\n+            }\n+\n+    void setResultFile(Path file);\n+\n+    void saveResults();\n+\n+    void clearData();\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/runtime\/CoverageData.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.runtime;\n+\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.runtime.serialization.SelfDeserializer;\n+\n+import java.util.function.Function;\n+\n+public interface Deserializer extends Function<String, Object> {\n+    Function<String, Object> SELF = new SelfDeserializer();\n+\n+    String DESERIALIZER = Env.JCOV_DATA_ENV_PREFIX +\n+            Collect.ARGUMENTS_PREFIX + \"deserializer\";\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/runtime\/Deserializer.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.runtime;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class EntryControl {\n+    private final Set<Thread> threads = new HashSet<>();\n+    public synchronized boolean enter() {\n+        Thread current = Thread.currentThread();\n+        if (threads.contains(current)) return false;\n+        threads.add(current);\n+        return true;\n+    }\n+    public synchronized void exit() {\n+        threads.remove(Thread.currentThread());\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/runtime\/EntryControl.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.runtime;\n+\n+import openjdk.jcov.data.Env;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+public class Runtime {\n+\n+    private static volatile Thread exitHook = null;\n+\n+    static {\n+        installExitHook();\n+    }\n+\n+    private static List<Runnable> completionTasks = new ArrayList<>(1);\n+\n+    protected static void addCompletionTask(Runnable task) {\n+        completionTasks.add(task);\n+    }\n+\n+    public static synchronized void complete() {\n+        for(Runnable r : completionTasks) {\n+            r.run();\n+        }\n+    }\n+\n+    public static Function<Object, String> serializer() throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        return Env.getSPIEnv(Serializer.SERIALIZER, Serializer.TO_STRING);\n+    }\n+\n+    public static Function<String, Object> deserializer() throws ClassNotFoundException,\n+            InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        return Env.getSPIEnv(Deserializer.DESERIALIZER, Deserializer.SELF);\n+    }\n+\n+    public static Path coverageIn() {\n+        return Env.getPathEnv(CoverageData.COVERAGE_IN, null);\n+    }\n+\n+    public static Path coverageOut() {\n+        return Env.getPathEnv(CoverageData.COVERAGE_OUT, null);\n+    }\n+\n+    public static synchronized void installExitHook() {\n+        clearExitHook();\n+        exitHook = new Thread(Runtime::complete);\n+        java.lang.Runtime.getRuntime().addShutdownHook(exitHook);\n+    }\n+\n+    public static synchronized void clearExitHook() {\n+        if (exitHook != null) java.lang.Runtime.getRuntime().removeShutdownHook(exitHook);\n+    }\n+\n+    public static void init() {\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/runtime\/Runtime.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.runtime;\n+\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.runtime.serialization.ToStringSerializer;\n+\n+import java.util.function.Function;\n+\n+public interface Serializer extends Function<Object, String> {\n+    Function<Object, String> TO_STRING = new ToStringSerializer();\n+\n+    \/**\n+     * Name of a property containing a class name of a class of type <code>Function<Object, String><\/code> which will\n+     * be used during the serialization. <code>Object::toString<\/code> is used by default.\n+     *\/\n+    String SERIALIZER = Env.JCOV_DATA_ENV_PREFIX +\n+            Collect.ARGUMENTS_PREFIX + \"serializer\";\n+\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/runtime\/Serializer.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package openjdk.jcov.data.serialization;\n+package openjdk.jcov.data.runtime.serialization;\n","filename":"data\/classes\/openjdk\/jcov\/data\/runtime\/serialization\/EnumDeserializer.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/serialization\/EnumDeserializer.java","status":"renamed"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.runtime.serialization;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Serializes an enum into its name.\n+ *\/\n+public class EnumSerializer implements Function<Object, String>\/*, Implantable*\/ {\n+\n+    private final String defaultValue;\n+\n+    public EnumSerializer(String value) {\n+        defaultValue = value;\n+    }\n+\n+    public EnumSerializer() {\n+        this(\"NOT_AN_ENUM\");\n+    }\n+\n+    @Override\n+    public String apply(Object anEnum) {\n+        if (anEnum instanceof Enum)\n+            return ((Enum) anEnum).name();\n+        else\n+            return defaultValue;\n+    }\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/runtime\/serialization\/EnumSerializer.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.runtime.serialization;\n+\n+import java.util.function.Function;\n+\n+public class SelfDeserializer implements Function<String, Object> {\n+    @Override\n+    public Object apply(String o) {return o;}\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/runtime\/serialization\/SelfDeserializer.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.runtime.serialization;\n+\n+import openjdk.jcov.data.runtime.Serializer;\n+\n+import java.util.function.Function;\n+\n+public class ToStringSerializer implements Function<Object, String> {\n+    @Override\n+    public String apply(Object o) {return o.toString();}\n+\n+}\n","filename":"data\/classes\/openjdk\/jcov\/data\/runtime\/serialization\/ToStringSerializer.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+TestNG.dirs = .\n","filename":"data\/test\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-    @Test\n+\/\/    @Test\n","filename":"data\/test\/openjdk\/jcov\/data\/EnvTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/EnvTest.java","status":"renamed"},{"patch":"","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/CoverageTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/CoverageTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.enums;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.plugin.Instrumentation;\n+import com.sun.tdk.jcov.instrument.plugin.PathDestination;\n+import com.sun.tdk.jcov.instrument.plugin.PathSource;\n+import openjdk.jcov.data.arguments.instrument.Plugin;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.instrument.ArgumentTypeMethodFilter;\n+import openjdk.jcov.data.lib.TestStatusListener;\n+import openjdk.jcov.data.lib.Util;\n+import openjdk.jcov.data.runtime.serialization.EnumDeserializer;\n+import openjdk.jcov.data.runtime.serialization.EnumSerializer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertSame;\n+\n+@Listeners({openjdk.jcov.data.lib.TestStatusListener.class})\n+public class EnumTest {\n+    private Path test_dir;\n+    private Path template;\n+    private EnumDeserializer deserializer = new EnumDeserializer(UserCode.ENum.class);\n+    private Path data_dir;\n+\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        data_dir = Files.createTempDirectory(\"userdir\");\n+        test_dir = data_dir.resolve(\"enum_test\");\n+        Util.rfrm(test_dir);\n+        Files.createDirectories(test_dir);\n+        template = test_dir.resolve(\"template.lst\");\n+    }\n+    @Test\n+    public void serialization() {\n+        assertSame(UserCode.ENum.THREE,\n+                new EnumDeserializer(UserCode.ENum.class).apply(new EnumSerializer().apply(UserCode.ENum.THREE)));\n+    }\n+    @Test\n+    public void instrument() throws Exception {\n+        Collect.clearData();\n+        Collect.outputFile(template);\n+        new Util(test_dir).\n+                copyBytecode(openjdk.jcov.data.arguments.enums.UserCode.class.getName());\n+        Plugin plugin = new Plugin();\n+        plugin.methodFilter(new ArgumentTypeMethodFilter(Enum.class));\n+        new Instrumentation(plugin)\n+                .instrument(new PathSource(getClass().getClassLoader(), test_dir), new PathDestination(test_dir),\n+                        new InstrumentationParams());\n+        Collect.save();\n+        Coverage tmplt = Coverage.read(template);\n+        assertEquals(tmplt.coverage().get(UserCode.class.getName().replace('.', '\/')).size(), 2);\n+    }\n+\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws\n+            ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException,\n+            IOException, InstantiationException {\n+    new Util(test_dir).runClass(UserCode.class, new String[0]);\n+    Collect.outputFile(template);\n+    Collect.serializer(new EnumSerializer());\n+    Collect.save();\n+    Coverage res = Coverage.read(template, deserializer);\n+    List<List<?>> method =\n+            res.get(UserCode.class.getName().replace('.', '\/'),\n+                    \"method(Lopenjdk\/jcov\/data\/arguments\/enums\/UserCode$ENum;)V\");\n+    assertEquals(method.size(), 1);\n+    assertEquals(method.get(0).size(), 1);\n+    assertEquals(method.get(0).size(), 1);\n+    assertEquals(method.get(0).get(0), UserCode.ENum.ONE);\n+    List<List<?>> staticMethod =\n+            res.get(UserCode.class.getName().replace('.', '\/'),\n+                    \"staticMethod(Lopenjdk\/jcov\/data\/arguments\/enums\/UserCode$ENum;)V\");\n+    assertEquals(staticMethod.size(), 1);\n+    assertEquals(staticMethod.get(0).size(), 1);\n+    assertEquals(staticMethod.get(0).get(0), UserCode.ENum.TWO);\n+    }\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(TestStatusListener.status) {\n+            Util.rfrm(data_dir);\n+        }\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/enums\/EnumTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/enums\/UserCode.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/enums\/UserCode.java","status":"renamed"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.enums;\n+\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+\n+public class UserCodeComplete {\n+    public enum ENum {ONE, TWO, THREE};\n+    public void method(ENum e) {\n+        System.out.println(e);\n+    }\n+    public static void staticMethod(ENum e) {\n+        System.out.println(e);\n+    }\n+\n+    public static void main(String[] args) {\n+        Collect.collect(\"openjdk\/jcov\/data\/arguments\/enums\/UserCode\", \"main\", \"([Ljava\/lang\/String;)V\", new Object[] {args});\n+        new UserCodeComplete().method(ENum.ONE);\n+        UserCodeComplete.staticMethod(ENum.TWO);\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/enums\/UserCodeComplete.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import openjdk.jcov.data.arguments.instrument.MethodFilter;\n@@ -29,0 +28,1 @@\n+import openjdk.jcov.data.instrument.MethodFilter;\n@@ -36,1 +36,1 @@\n-        List<Plugin.TypeDescriptor> params = MethodFilter.parseDesc(desc);\n+        List<Plugin.TypeDescriptor> params = Plugin.parseDesc(desc);\n","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/main\/MainFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/main\/MainFilter.java","status":"renamed"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.main;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.plugin.FilteringPlugin;\n+import com.sun.tdk.jcov.instrument.plugin.Instrumentation;\n+import com.sun.tdk.jcov.instrument.plugin.PathDestination;\n+import com.sun.tdk.jcov.instrument.plugin.PathSource;\n+import openjdk.jcov.data.arguments.instrument.Plugin;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.lib.TestStatusListener;\n+import openjdk.jcov.data.lib.Util;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Listeners({TestStatusListener.class})\n+public class MainTest {\n+    private Path test_dir;\n+    private Path coverage;\n+    private Path data_dir;\n+\n+    @BeforeClass\n+    public void cleanClass() throws IOException {\n+        data_dir = Files.createTempDirectory(\"userdir\");\n+        test_dir = data_dir.resolve(\"main_test\");\n+        coverage = test_dir.resolve(\"coverage.lst\");\n+        Util.rfrm(test_dir);\n+        Files.createDirectories(test_dir);\n+    }\n+    private Coverage instrument(Class cls, Function<com.sun.tdk.jcov.instrument.InstrumentationPlugin,\n+            com.sun.tdk.jcov.instrument.InstrumentationPlugin> transform) throws Exception {\n+        new Util(test_dir).copyBytecode(cls.getName());\n+        Plugin plugin = new Plugin();\n+        plugin.methodFilter(new MainFilter());\n+        new Instrumentation(plugin).instrument(\n+                new PathSource(getClass().getClassLoader(), test_dir),\n+                new PathDestination(test_dir),\n+                new InstrumentationParams());\n+        Instrumentation instr = new Instrumentation(transform.apply(plugin));\n+        Collect.clearData();\n+        instr.instrument(new PathSource(ClassLoader.getSystemClassLoader(), test_dir),\n+                new PathDestination(test_dir), new InstrumentationParams());\n+        Collect.outputFile(coverage);\n+        Collect.save();\n+        return Coverage.read(coverage);\n+    }\n+    @Test\n+    public void instrument() throws Exception {\n+        Coverage tmplt = instrument(UserCode.class, p -> p);\n+        assertEquals(tmplt.coverage().size(), 0);\n+    }\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void instrumentStatic() throws Exception {\n+        Coverage tmplt = instrument(UserCodeStatic.class, p -> new FilteringPlugin(p, s -> s.contains(\"UserCodeStatic\")));\n+        Map<String, List<List<?>>> userCode =  tmplt.coverage().get(UserCodeStatic.class.getName().replace('.', '\/'));\n+        assertEquals(userCode.size(), 1);\n+        assertEquals(userCode.keySet().iterator().next(), \"main([Ljava\/lang\/String;)V\");\n+    }\n+    @Test(dependsOnMethods = \"instrumentStatic\")\n+    public void run() throws\n+                ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException,\n+                IOException, InstantiationException {\n+            new Util(test_dir).runClass(UserCodeStatic.class, new String[] {\"one\", \"two\"});\n+            Collect.outputFile(coverage);\n+            Collect.serializer(new StringArraySerializer());\n+            Collect.save();\n+            Coverage res = Coverage.read(coverage, Objects::toString);\n+            List<List<?>> method =\n+                    res.get(UserCodeStatic.class.getName().replace('.', '\/'),\n+                            \"main([Ljava\/lang\/String;)V\");\n+            assertEquals(method.size(), 1);\n+            assertEquals(method.get(0).size(), 2);\n+            assertEquals(method.get(0).get(0), \"one\");\n+            assertEquals(method.get(0).get(1), \"two\");\n+    }\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(TestStatusListener.status) Util.rfrm(data_dir);\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/main\/MainTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/main\/StringArrayDeserializer.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/main\/StringArrayDeserializer.java","status":"renamed"},{"patch":"","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/main\/StringArraySerializer.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/main\/StringArraySerializer.java","status":"renamed"},{"patch":"","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/main\/UserCode.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/main\/UserCode.java","status":"renamed"},{"patch":"@@ -28,1 +28,3 @@\n-    public static void main(String[] args) {}\n+    public static void main(String[] args) {\n+        System.out.println(\"args = \" + args);\n+    }\n","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/main\/UserCodeStatic.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/main\/UserCodeStatic.java","status":"renamed"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.othervm;\n+\n+import openjdk.jcov.data.arguments.instrument.Plugin;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.arguments.test.UserCode;\n+import openjdk.jcov.data.instrument.Instrument;\n+import openjdk.jcov.data.lib.TestStatusListener;\n+import openjdk.jcov.data.lib.Util;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import static openjdk.jcov.data.instrument.Instrument.PLUGIN_CLASS;\n+import static openjdk.jcov.data.runtime.CoverageData.COVERAGE_IN;\n+import static openjdk.jcov.data.runtime.CoverageData.COVERAGE_OUT;\n+import static org.testng.Assert.assertEquals;\n+\n+public class OtherVMTest {\n+    private Path test_dir;\n+    private Path template;\n+    private Path coverage;\n+    private Path data_dir;\n+\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        data_dir = Files.createTempDirectory(\"other-vm-test\");\n+        Files.createDirectories(data_dir);\n+        test_dir = data_dir.resolve(\"othervm_args_test\");\n+        Util.rfrm(test_dir);\n+        template = test_dir.resolve(\"template.lst\");\n+        coverage = test_dir.resolve(\"coverage.lst\");\n+        new Util(test_dir).copyBytecode(UserCode.class.getName());\n+    }\n+    @Test\n+    public void instrument() throws IOException, InterruptedException {\n+        assertEquals(Util.runClassOnM(List.of(\"-D\" + PLUGIN_CLASS + \"=\" + Plugin.class.getName(), \"-D\" + COVERAGE_OUT + \"=\" + template),\n+                Instrument.class,\n+                List.of(test_dir.toString(), test_dir.toString())), 0);\n+        Coverage data = Coverage.read(template);\n+        assertEquals(data.coverage().get(UserCode.class.getName().replace(\".\", \"\/\")).size(), 3);\n+    }\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws IOException, InterruptedException {\n+        assertEquals(Util.runAClassOnCP(List.of(\"-D\" + COVERAGE_IN + \"=\" + template,\n+                \"-D\" + COVERAGE_OUT + \"=\" + coverage), List.of(test_dir), UserCode.class.getName(),\n+                List.of()), 0);\n+        Coverage data = Coverage.read(coverage);\n+        List<List<?>> values = data.get(UserCode.class.getName().replace(\".\", \"\/\"),\n+                \"method(IJFDZBLjava\/lang\/String;)V\");\n+        assertEquals(values.size(), 2);\n+        assertEquals(values.get(0).get(0), \"0\");\n+    }\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        Util.rfrm(data_dir);\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/othervm\/OtherVMTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.test;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.plugin.Instrumentation;\n+import com.sun.tdk.jcov.instrument.plugin.PathDestination;\n+import com.sun.tdk.jcov.instrument.plugin.PathSource;\n+import openjdk.jcov.data.arguments.instrument.Plugin;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.lib.TestStatusListener;\n+import openjdk.jcov.data.lib.Util;\n+import openjdk.jcov.data.runtime.Serializer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import static java.util.stream.Collectors.joining;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+\n+@Listeners({openjdk.jcov.data.lib.TestStatusListener.class})\n+public class ArgumentsTest {\n+    Path test_dir;\n+    Path template;\n+    private Path data_dir;\n+\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        data_dir = Files.createTempDirectory(\"userdir\");\n+        test_dir = data_dir.resolve(\"arguments_test\");\n+        Util.rfrm(test_dir);\n+        template = test_dir.resolve(\"template.lst\");\n+    }\n+    @Test\n+    public void instrument() throws Exception {\n+        Collect.clearData();\n+        Collect.outputFile(template);\n+        new Util(test_dir).copyBytecode(UserCode.class.getName());\n+        openjdk.jcov.data.instrument.Plugin plugin = new Plugin();\n+        new Instrumentation(plugin)\n+                .instrument(new PathSource(getClass().getClassLoader(), test_dir), new PathDestination(test_dir),\n+                        new InstrumentationParams());\n+        Collect.save();\n+        Coverage tmpl = Coverage.read(template);\n+        assertNotNull(tmpl.coverage().get(UserCode.class.getName().replace('.', '\/')).\n+                get(\"method(IJFDZBLjava\/lang\/String;)V\"));\n+    }\n+\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n+            IllegalAccessException, IOException, InstantiationException {\n+        Collect.serializer(Serializer.TO_STRING);\n+        new Util(test_dir).runClass(UserCode.class, new String[0]);\n+        Collect.save();\n+        Coverage coverage = Coverage.read(template);\n+        List<List<?>> calls = coverage.get(UserCode.class.getName().replace('.', '\/'),\n+                \"method(IJFDZBLjava\/lang\/String;)V\");\n+        assertEquals(calls.size(), 2);\n+        assertEquals(calls.get(0).get(6), \"6\");\n+        assertEquals(calls.get(1).get(0), \"7\");\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(TestStatusListener.status)\n+            Util.rfrm(data_dir);\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/test\/ArgumentsTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"","filename":"data\/test\/openjdk\/jcov\/data\/arguments\/test\/UserCode.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/test\/UserCode.java","status":"renamed"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.enums;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.plugin.Instrumentation;\n+import com.sun.tdk.jcov.instrument.plugin.PathDestination;\n+import com.sun.tdk.jcov.instrument.plugin.PathSource;\n+import openjdk.jcov.data.fields.instrument.Plugin;\n+import openjdk.jcov.data.fields.instrument.TemplateGenerator;\n+import openjdk.jcov.data.fields.runtime.Collect;\n+import openjdk.jcov.data.fields.runtime.Coverage;\n+import openjdk.jcov.data.fields.runtime.Runtime;\n+import openjdk.jcov.data.lib.TestStatusListener;\n+import openjdk.jcov.data.lib.Util;\n+import openjdk.jcov.data.runtime.serialization.EnumDeserializer;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+@Listeners({TestStatusListener.class})\n+public class EnumTest {\n+    Path test_dir;\n+    Path template;\n+    Path coverage;\n+    List<Path> classes;\n+    Util util;\n+    Path data_dir;\n+\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        data_dir = Files.createTempDirectory(\"userdir\");\n+        test_dir = data_dir.resolve(\"enum_field_test\");\n+        Util.rfrm(test_dir);\n+        template = test_dir.resolve(\"template.lst\");\n+        coverage = test_dir.resolve(\"coverage.lst\");\n+        util = new Util(test_dir);\n+        Runtime.init();\n+        Runtime.clearExitHook();\n+    }\n+    @Test\n+    public void template() throws IOException, InterruptedException, ClassNotFoundException,\n+            InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        Collect.data().coverage().clear();\n+        TemplateGenerator tg = new TemplateGenerator();\n+        String vmEnumName = \"L\" + UserCode.ENum.class.getName().replace(\".\", \"\/\") + \";\";\n+        String vmClassName = UserCode.class.getName().replace(\".\", \"\/\");\n+        tg.setFieldFilter(fm -> vmEnumName.equals(fm.fieldType().stringValue()) &&\n+                vmClassName.equals(fm.parent().get().thisClass().name().stringValue()));\n+        classes = util.copyBytecode(UserCode.class.getName(), UserCode.ENum.class.getName());\n+        tg.generate(classes);\n+        Coverage.write(Collect.data(), template);\n+        Coverage tmpl = Coverage.read(template);\n+        String cn = UserCode.class.getName().replace('.', '\/');\n+        assertTrue(tmpl.coverage().containsKey(cn));\n+        assertEquals(tmpl.coverage().get(cn).size(), 2);\n+    }\n+    @Test(dependsOnMethods = \"template\")\n+    public void instrument() throws Exception {\n+        Collect.data(Coverage.read(template));\n+        new Instrumentation(new Plugin())\n+                .instrument(new PathSource(test_dir), new PathDestination(test_dir), new InstrumentationParams());\n+    }\n+\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n+            IllegalAccessException, IOException, InstantiationException {\n+        Collect.data(Coverage.read(template));\n+        util.runClass(UserCode.class, new String[0]);\n+        Coverage.write(Collect.data(), coverage);\n+        Coverage loaded = Coverage.read(coverage, new EnumDeserializer(UserCode.ENum.class));\n+        String cn = UserCode.class.getName().replace('.', '\/');\n+        Map<String, List> fields = loaded.coverage().get(cn);\n+        assertEquals(fields.size(), 2);\n+        assertEquals(fields.get(\"eNum\").get(0), UserCode.ENum.TWO);\n+        assertEquals(fields.get(\"staticENum\").get(0), UserCode.ENum.ONE);\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(TestStatusListener.status)\n+            Util.rfrm(data_dir);\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/fields\/enums\/EnumTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.enums;\n+\n+public class UserCode {\n+    public enum ENum {ONE, TWO, THREE};\n+    static ENum staticENum;\n+    ENum eNum;\n+\n+    public static void main(String[] args) {\n+        staticENum = ENum.ONE;\n+        new UserCode().eNum = ENum.TWO;\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/fields\/enums\/UserCode.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.othervm;\n+\n+import openjdk.jcov.data.fields.instrument.Plugin;\n+import openjdk.jcov.data.fields.instrument.TemplateGenerator;\n+import openjdk.jcov.data.fields.runtime.Coverage;\n+import openjdk.jcov.data.fields.test.UserCode;\n+import openjdk.jcov.data.instrument.Instrument;\n+import openjdk.jcov.data.lib.TestStatusListener;\n+import openjdk.jcov.data.lib.Util;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import static openjdk.jcov.data.instrument.Instrument.PLUGIN_CLASS;\n+import static openjdk.jcov.data.runtime.CoverageData.COVERAGE_IN;\n+import static openjdk.jcov.data.runtime.CoverageData.COVERAGE_OUT;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+@Listeners({openjdk.jcov.data.lib.TestStatusListener.class})\n+public class OtherVMTest {\n+    private Path test_dir;\n+    private Path template;\n+    private Path coverage;\n+    private Path data_dir;\n+\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        data_dir = Files.createTempDirectory(\"othervm_test\");\n+        test_dir = data_dir.resolve(\"othervm_test\");\n+        Util.rfrm(test_dir);\n+        template = test_dir.resolve(\"template.lst\");\n+        coverage = test_dir.resolve(\"coverage.lst\");\n+        new Util(test_dir).copyBytecode(UserCode.class.getName());\n+    }\n+    @Test\n+    public void template() throws IOException, InterruptedException {\n+        assertEquals(Util.runClassOnM(List.of(\"-D\" + COVERAGE_OUT + \"=\" + template),\n+                TemplateGenerator.class,\n+                List.of(test_dir.toString())), 0);\n+    }\n+    @Test(dependsOnMethods = \"template\")\n+    public void instrument() throws IOException, InterruptedException {\n+        assertEquals(Util.runClassOnM(List.of(\"-D\" + PLUGIN_CLASS + \"=\" + Plugin.class.getName(),\n+                        \"-D\" + COVERAGE_IN + \"=\" + template),\n+                Instrument.class,\n+                List.of(test_dir.toString(), test_dir.toString())), 0);\n+    }\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws IOException, InterruptedException {\n+        assertEquals(Util.runAClassOnCP(List.of(\"-D\" + COVERAGE_IN + \"=\" + template,\n+                        \"-D\" + COVERAGE_OUT + \"=\" + coverage),\n+                List.of(test_dir),\n+                UserCode.class.getName(),\n+                List.of()), 0);\n+        Coverage data = Coverage.read(coverage);\n+        List values = data.get(UserCode.class.getName().replace(\".\", \"\/\"), \"b\");\n+        assertEquals(values.size(), 2);\n+        assertTrue(values.contains(\"5\"));\n+        assertTrue(values.contains(\"12\"));\n+    }\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(TestStatusListener.status)\n+            Util.rfrm(data_dir);\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/fields\/othervm\/OtherVMTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.test;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.plugin.Instrumentation;\n+import com.sun.tdk.jcov.instrument.plugin.PathDestination;\n+import com.sun.tdk.jcov.instrument.plugin.PathSource;\n+import openjdk.jcov.data.fields.instrument.Plugin;\n+import openjdk.jcov.data.fields.instrument.TemplateGenerator;\n+import openjdk.jcov.data.fields.runtime.Collect;\n+import openjdk.jcov.data.fields.runtime.Coverage;\n+import openjdk.jcov.data.fields.runtime.Runtime;\n+import openjdk.jcov.data.lib.TestStatusListener;\n+import openjdk.jcov.data.lib.Util;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import static org.testng.Assert.*;\n+\n+@Listeners({TestStatusListener.class})\n+public class FieldsTest {\n+    Path test_dir;\n+    Path template;\n+    private List<Path> classes;\n+    Path data_dir;\n+\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        data_dir = Files.createTempDirectory(\"userdir\");\n+        test_dir = data_dir.resolve(\"fields_test\");\n+        Util.rfrm(test_dir);\n+        template = test_dir.resolve(\"template.lst\");\n+        classes = new Util(test_dir).copyBytecode(UserCode.class.getName());\n+        Runtime.init();\n+        Runtime.clearExitHook();\n+    }\n+    @Test\n+    public void template() throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException, IOException {\n+        new TemplateGenerator().generate(classes);\n+        Coverage.write(Collect.data(), template);\n+    }\n+\n+    @Test(dependsOnMethods = \"template\")\n+    public void instrument() throws Exception {\n+        Collect.data(Coverage.read(template));\n+        new Instrumentation(new Plugin())\n+                .instrument(new PathSource(getClass().getClassLoader(), test_dir), new PathDestination(test_dir),\n+                        new InstrumentationParams());\n+        Coverage.write(Collect.data(), template);\n+        Coverage tmpl = Coverage.read(template);\n+        String cn = UserCode.class.getName().replace('.', '\/');\n+        assertTrue(tmpl.coverage().containsKey(cn));\n+        assertTrue(tmpl.coverage().get(cn).containsKey(\"i\"));\n+        assertTrue(tmpl.coverage().get(cn).get(\"i\").isEmpty());\n+    }\n+\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n+            IllegalAccessException, IOException, InstantiationException {\n+        new Util(test_dir).runClass(UserCode.class, new String[0]);\n+        Coverage.write(Collect.data(), template);\n+        Coverage coverage = Coverage.read(template);\n+        String cn = UserCode.class.getName().replace('.', '\/');\n+        List values = coverage.get(cn, \"i\");\n+        assertEquals(values.size(), 2);\n+        assertTrue(values.contains(\"0\"));\n+        assertTrue(values.contains(\"7\"));\n+        values = coverage.get(cn, \"j\");\n+        assertEquals(values.size(), 2);\n+        assertTrue(values.contains(\"1\"));\n+        assertTrue(values.contains(\"8\"));\n+        values = coverage.get(cn, \"f\");\n+        assertEquals(values.size(), 2);\n+        assertTrue(values.contains(\"2.0\"));\n+        assertTrue(values.contains(\"9.0\"));\n+        values = coverage.get(cn, \"d\");\n+        assertEquals(values.size(), 2);\n+        assertTrue(values.contains(\"3.0\"));\n+        assertTrue(values.contains(\"10.0\"));\n+        values = coverage.get(cn, \"b\");\n+        assertEquals(values.size(), 2);\n+        assertTrue(values.contains(\"5\"));\n+        assertTrue(values.contains(\"12\"));\n+        values = coverage.get(cn, \"z\");\n+        assertEquals(values.size(), 2);\n+        assertTrue(values.contains(\"true\"));\n+        assertTrue(values.contains(\"false\"));\n+        values = coverage.get(cn, \"s\");\n+        assertEquals(values.size(), 2);\n+        assertTrue(values.contains(\"6\"));\n+        assertTrue(values.contains(\"13\"));\n+    }\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(TestStatusListener.status)\n+            Util.rfrm(data_dir);\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/fields\/test\/FieldsTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.fields.test;\n+\n+public class UserCode {\n+    int i;\n+    long j;\n+    float f;\n+    double d;\n+    boolean z;\n+    byte b;\n+    String s;\n+\n+    public void setI(int i) {\n+        this.i = i;\n+    }\n+\n+    public void setJ(long j) {\n+        this.j = j;\n+    }\n+\n+    public void setF(float f) {\n+        this.f = f;\n+    }\n+\n+    public void setD(double d) {\n+        this.d = d;\n+    }\n+\n+    public void setZ(boolean z) {\n+        this.z = z;\n+    }\n+\n+    public void setB(byte b) {\n+        this.b = b;\n+    }\n+\n+    public void setS(String s) {\n+        this.s = s;\n+    }\n+\n+    public static void main(String[] args) {\n+        UserCode o = new UserCode();\n+        o.setI(0); o.setJ(1); o.setF(2f); o.setD(3.); o.setZ(true); o.setB((byte)5); o.setS(\"6\");\n+        o.setI(7); o.setJ(8); o.setF(9f); o.setD(10d); o.setZ(false); o.setB((byte)12); o.setS(\"13\");\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/fields\/test\/UserCode.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"","filename":"data\/test\/openjdk\/jcov\/data\/instrumentation.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/instrumentation.properties","status":"renamed"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.jdk;\n+\n+import openjdk.jcov.data.arguments.instrument.Plugin;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.instrument.ArgumentTypeMethodFilter;\n+import openjdk.jcov.data.instrument.InstrumentJDK;\n+import openjdk.jcov.data.lib.Util;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.LocalDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.List;\n+\n+import static openjdk.jcov.data.runtime.CoverageData.COVERAGE_OUT;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class JDKTestArguments {\n+    static Path instrJDK;\n+    @BeforeClass\n+    public static void prepare() throws IOException {\n+        instrJDK = Util.copyJRE(Path.of(System.getProperty(\"java.home\")));\n+    }\n+    @Test\n+    public void instrument() throws IOException, InterruptedException, ClassNotFoundException,\n+            InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        Plugin plugin = new Plugin();\n+        plugin.methodFilter(new ArgumentTypeMethodFilter(ChronoUnit.class));\n+        Path template = instrJDK.resolve(\"template.lst\");\n+        assertEquals(new InstrumentJDK(plugin).instrument(instrJDK, List.of(\"java.base\"), Plugin.class,\n+                        List.of(Collect.class.getPackageName()), \"java.time\", template),\n+                0);\n+        assertTrue(Files.exists(template));\n+    }\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws IOException, InterruptedException {\n+        Path output = instrJDK.resolve(\"coverage.lst\");\n+        String[] command = new String[] {\n+                instrJDK.resolve(\"bin\").resolve(\"java\").toString(),\n+                \"-D\" + COVERAGE_OUT + \"=\" + output.toString(),\n+                \"-cp\", System.getProperty(\"java.class.path\"),\n+                UserCode.class.getName()\n+        };\n+        new ProcessBuilder(command).inheritIO().start().waitFor();\n+        System.out.println(\"Expecting output in \" + output);\n+        assertTrue(Files.exists(output));\n+        Coverage coverage = Coverage.read(output);\n+        List<List<?>> calls = coverage.get(LocalDateTime.class.getName().replace('.', '\/'),\n+                \"minus(JLjava\/time\/temporal\/TemporalUnit;)Ljava\/time\/LocalDateTime;\");\n+        assertTrue(calls.stream().anyMatch(vs -> vs.get(0).equals(\"42\") && vs.get(1).equals(\"Years\")));\n+    }\n+    @AfterClass\n+    public static void cleanup() throws IOException {\n+        Util.rfrm(instrJDK);\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/jdk\/JDKTestArguments.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.jdk;\n+\n+import openjdk.jcov.data.fields.instrument.Plugin;\n+import openjdk.jcov.data.fields.instrument.TemplateGenerator;\n+import openjdk.jcov.data.fields.runtime.Collect;\n+import openjdk.jcov.data.fields.runtime.Coverage;\n+import openjdk.jcov.data.fields.runtime.Runtime;\n+import openjdk.jcov.data.instrument.InstrumentJDK;\n+import openjdk.jcov.data.lib.Util;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import static openjdk.jcov.data.runtime.CoverageData.COVERAGE_OUT;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class JDKTestFields {\n+    static Path instrJDK;\n+    static Path template;\n+    @BeforeClass\n+    public static void prepare() throws IOException {\n+        instrJDK = Util.copyJRE(Path.of(System.getProperty(\"java.home\")));\n+        template = instrJDK.resolve(\"template.lst\");\n+\/\/        System.setProperty(COVERAGE_IN, template.toString());\n+    }\n+    @Test\n+    public void instrument() throws IOException, InterruptedException, ClassNotFoundException,\n+            InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+\/\/        Path template = Files.createTempFile(\"template\", \".lst\");\n+        Runtime.init();\n+        System.out.println(template);\n+        System.setProperty(COVERAGE_OUT, template.toString());\n+        TemplateGenerator generator = new TemplateGenerator();\n+        generator.setFieldFilter(fm -> {\n+            if (fm.parent().isPresent()) {\n+                String typeName = fm.parent().get().thisClass().name().stringValue();\n+                if (typeName.equals(\"java\/time\/LocalDateTime\")) {\n+                    String fieldName = fm.fieldName().stringValue();\n+                    return fieldName.equals(\"date\") || fieldName.equals(\"time\");\n+                }\n+            }\n+            return false;\n+        });\n+        generator.generate(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"\/modules\/java.base\/java\/time\"));\n+        \/\/this is only needed for the manual file review.\n+        \/\/since running in the same VM, Collect.data() will just keep holding the data\n+\/\/        Coverage.write(Collect.data(), template);\n+        Plugin plugin = new Plugin();\n+        assertEquals(new InstrumentJDK(plugin).instrument(instrJDK, List.of(\"java.base\"), Plugin.class,\n+                        List.of(Collect.class.getPackageName()), \"java.time.LocalDateTime\", template),\n+                0);\n+    }\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws IOException, InterruptedException {\n+        Path output = instrJDK.resolve(\"coverage.lst\");\n+        String[] command = new String[] {\n+                instrJDK.resolve(\"bin\").resolve(\"java\").toString(),\n+                \"-D\" + COVERAGE_OUT + \"=\" + output.toString(),\n+                \"-cp\", System.getProperty(\"java.class.path\"),\n+                UserCode.class.getName()\n+        };\n+        new ProcessBuilder(command).inheritIO().start().waitFor();\n+        System.out.println(\"Expecting output in \" + output);\n+        assertTrue(Files.exists(output));\n+        Coverage coverage = Coverage.read(output);\n+        assertTrue(coverage.get(\"java\/time\/LocalDateTime\", \"date\").contains(\"0001-01-01\"));\n+        assertTrue(coverage.get(\"java\/time\/LocalDateTime\", \"time\").contains(\"01:01\"));\n+    }\n+    @AfterClass\n+    public static void cleanup() throws IOException {\n+        Util.rfrm(instrJDK);\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/jdk\/JDKTestFields.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.jdk;\n+\n+import java.time.LocalDateTime;\n+import java.time.temporal.ChronoUnit;\n+\n+public class UserCode {\n+    public static void main(String[] args) {\n+        LocalDateTime.of(1, 1, 1, 1, 1);\n+        System.out.println(LocalDateTime.now().minus(42, ChronoUnit.YEARS));\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/jdk\/UserCode.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.lib;\n+\n+import org.testng.ITestContext;\n+import org.testng.ITestListener;\n+import org.testng.ITestResult;\n+\n+public class TestStatusListener implements ITestListener {\n+\n+    public static volatile boolean status = true;\n+\n+    @Override\n+    public void onTestStart(ITestResult result) { }\n+\n+    @Override\n+    public void onTestSuccess(ITestResult result) { }\n+\n+    @Override\n+    public void onTestFailure(ITestResult result) {\n+        status = false;\n+    }\n+\n+    @Override\n+    public void onTestSkipped(ITestResult result) { }\n+\n+    @Override\n+    public void onTestFailedButWithinSuccessPercentage(ITestResult result) { }\n+\n+    @Override\n+    public void onStart(ITestContext context) { status = true; }\n+\n+    @Override\n+    public void onFinish(ITestContext context) { }\n+}\n+\n","filename":"data\/test\/openjdk\/jcov\/data\/lib\/TestStatusListener.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.lib;\n+\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.instrument.Instrument;\n+import openjdk.jcov.data.instrument.Plugin;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+\n+import static java.io.File.separator;\n+import static openjdk.jcov.data.instrument.Instrument.PLUGIN_CLASS;\n+import static openjdk.jcov.data.runtime.CoverageData.COVERAGE_OUT;\n+\n+public class Util {\n+    private final Path outputDir;\n+\n+    public Util(Path dir) {\n+        outputDir = dir;\n+    }\n+\n+    public List<Path> copyBytecode(String... classes) throws IOException {\n+        byte[] buf = new byte[1024];\n+        List<Path> result = new ArrayList<>();\n+        for(String c : classes) {\n+            String classFile = classFile(c);\n+            try(InputStream in = getClass().getClassLoader().getResourceAsStream(classFile)) {\n+                Path o = outputDir.resolve(classFile);\n+                result.add(o);\n+                if(!Files.exists(o.getParent())) Files.createDirectories(o.getParent());\n+                try(OutputStream out = Files.newOutputStream(o)) {\n+                    int read;\n+                    while((read = in.read(buf)) > 0)\n+                        out.write(buf, 0, read);\n+                }\n+            }\n+        };\n+        return result;\n+    }\n+\n+    public static Path copyJRE(Path src) throws IOException {\n+        Path dest = Files.createTempDirectory(\"JDK\");\n+        System.out.println(\"Copying a JDK from \" + src + \" to \" + dest);\n+        Files.walk(src).forEach(s -> {\n+            try {\n+                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        return dest;\n+    }\n+\n+    public static Path createRtJar(String prefix, Collection<Class> implant) throws IOException {\n+        Path dest = Files.createTempFile(prefix, \".jar\");\n+        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n+            for (Class cls : implant) {\n+                String entryName = cls.getName().replace('.', '\/') + \".class\";\n+                jar.putNextEntry(new JarEntry(entryName));\n+                try (InputStream ci = cls.getClassLoader()\n+                        .getResourceAsStream(entryName)) {\n+                    byte[] buffer = new byte[1024];\n+                    int read;\n+                    while ((read = ci.read(buffer)) > 0) {\n+                        jar.write(buffer, 0, read);\n+                    }\n+                }\n+            }\n+        }\n+        return dest;\n+    }\n+\n+    public static String classFile(String className) {\n+        return className.replace('.', '\/') + \".class\";\n+    }\n+\n+    public Class runClass(Class clss, String[] argv)\n+            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+        return runClass(clss.getName(), argv);\n+    }\n+    public Class runClass(String className, String[] argv)\n+            throws ClassNotFoundException, NoSuchMethodException,\n+            InvocationTargetException, IllegalAccessException, InstantiationException {\n+        Collect.clearData();\n+        ClassLoader ofOutputDir = new InstrumentedClassLoader();\n+        Class cls = ofOutputDir.loadClass(className);\n+        Method m = cls.getMethod(\"main\", new String[0].getClass());\n+        System.out.println(\"invoking \" + m);\n+        m.invoke(null, (Object)argv);\n+        return cls;\n+    }\n+\n+    public static int runClassOnM(List<String> vmArgs, Class mainClass, List<String> params)\n+            throws IOException, InterruptedException {\n+        List<String> command = new ArrayList<>();\n+        command.add(System.getProperty(\"java.home\") + separator + \"bin\" + separator + \"java\");\n+        command.addAll(vmArgs);\n+        command.addAll(addExports());\n+        String classPath = System.getProperty(\"java.class.path\");\n+        if (classPath != null) {\n+            command.add(\"-cp\"); command.add(classPath);\n+        }\n+        String modulePath = System.getProperty(\"jdk.module.path\");\n+        if (modulePath != null) {\n+            command.add(\"--module-path\"); command.add(modulePath);\n+        }\n+        if (modulePath != null) {\n+            command.add(\"--module\"); command.add(\"jcov.data\/\" + mainClass.getName());\n+        } else {\n+            command.add(mainClass.getName());\n+        }\n+        command.addAll(params);\n+        System.out.println(\"Running \" + command.stream().collect(Collectors.joining(\" \")));\n+        ProcessBuilder pb = new ProcessBuilder(command).inheritIO();\n+        return pb.start().waitFor();\n+    }\n+\n+    public static int runAClassOnCP(List<String> vmArgs, List<Path> classPath, String mainClass,\n+                                    List<String> params)\n+            throws IOException, InterruptedException {\n+        List<String> command = new ArrayList<>();\n+        command.add(System.getProperty(\"java.home\") + separator + \"bin\" + separator + \"java\");\n+        command.addAll(vmArgs);\n+        command.addAll(addExports());\n+        command.add(\"-cp\"); command.add(classPath.stream().map(Path::toString).collect(Collectors.joining(\":\")));\n+        command.add(mainClass);\n+        command.addAll(params);\n+        System.out.println(\"Running \" + command.stream().collect(Collectors.joining(\" \")));\n+        ProcessBuilder pb = new ProcessBuilder(command).inheritIO();\n+        return pb.start().waitFor();\n+    }\n+\n+    private static List<String> addExports() {\n+        return List.of(\n+                \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=jcov.data,ALL-UNNAMED\",\n+                \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=jcov.data,ALL-UNNAMED\",\n+                \"--add-exports\", \"java.base\/jdk.internal.classfile=jcov.data,ALL-UNNAMED\"\n+        );\n+    }\n+\n+    private class InstrumentedClassLoader extends ClassLoader {\n+        protected InstrumentedClassLoader() {\n+            super(Util.class.getClassLoader());\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            Path classFile = outputDir.resolve(classFile(name));\n+            if(Files.exists(classFile)) {\n+                byte[] buf = new byte[1024];\n+                try(InputStream in = Files.newInputStream(classFile)) {\n+                    try(ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                        int read;\n+                        while((read = in.read(buf)) > 0)\n+                            out.write(buf, 0, read);\n+                        return defineClass(name, out.toByteArray(), 0, out.size());\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return super.loadClass(name);\n+        }\n+    }\n+    public static void rfrm(Path jre) throws IOException {\n+        System.out.println(\"Removing \" + jre);\n+        if(Files.isRegularFile(jre))\n+            Files.deleteIfExists(jre);\n+        else\n+            Files.walkFileTree(jre, new FileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                    Files.delete(file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                    Files.delete(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+    }\n+}\n","filename":"data\/test\/openjdk\/jcov\/data\/lib\/Util.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -1,2 +0,0 @@\n-.idea\n-build\n","filename":"plugins\/data_coverage\/.gitignore","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,11 +0,0 @@\n-# JCov data plugin\n-\n-This is an implementation of *com.sun.tdk.jcov.instrument.InstrumentationPlugin* plugin which can help with investigating of data flow within Java code. The plugin is intended to add additional instrumentation to collect facts about values used in runtime.\n-\n-Currently this repository only contains code allowing to capture information about method arguments.\n-\n-Code from *com.sun.tdk.jcov.instrument.plugin* JCov unit tests will later be also migrated  into this project to be able to collect data about values assigned to fields.\n-\n-WIP!\n-\n-Please see tests to find out how this can be used.\n","filename":"plugins\/data_coverage\/README.md","additions":0,"deletions":11,"binary":false,"changes":11,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-\n-<!--\n-  Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n-  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-  This code is free software; you can redistribute it and\/or modify it\n-  under the terms of the GNU General Public License version 2 only, as\n-  published by the Free Software Foundation.  Oracle designates this\n-  particular file as subject to the \"Classpath\" exception as provided\n-  by Oracle in the LICENSE file that accompanied this code.\n-\n-  This code is distributed in the hope that it will be useful, but WITHOUT\n-  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-  version 2 for more details (a copy is included in the LICENSE file that\n-  accompanied this code).\n-\n-  You should have received a copy of the GNU General Public License version\n-  2 along with this work; if not, write to the Free Software Foundation,\n-  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-  or visit www.oracle.com if you need additional information or have any\n-  questions.\n--->\n-<project name=\"SimpleMethodsANCFilter\" default=\"jar\" basedir=\".\">\n-  <!-- set global properties for this build -->\n-  <property name=\"src\" location=\"src\"\/>\n-  <property name=\"test\" location=\"test\"\/>\n-  <property name=\"build\" location=\"build\"\/>\n-  <property name=\"classes\" location=\"${build}\/classes\"\/>\n-  <property name=\"test.classes\" location=\"${build}\/tests\"\/>\n-  <property name=\"test.jar\" location=\"${build}\/tests.jar\"\/>\n-  <property name=\"jar\" location=\"${build}\/DataCoverage.jar\"\/>\n-  <property name=\"test.results\" location=\"${build}\/test_results\"\/>\n-  <property name=\"jcov.jar\" location=\"..\/..\/JCOV_BUILD\/jcov_3.0\/jcov.jar\"\/>\n-  <property name=\"jcov.file.saver.jar\" location=\"..\/..\/JCOV_BUILD\/jcov_3.0\/jcov_file_saver.jar\"\/>\n-  <property name=\"test.includes\" value=\"**\/*Test.class\"\/>\n-  <property name=\"test.excludes\" value=\"\"\/>\n-\n-  <target name=\"compile\">\n-    <available file=\"${jcov.jar}\" property=\"jcov-jar-exists\"\/>\n-    <fail unless=\"jcov-jar-exists\" message=\"There is no ${jcov.jar}\"\/>\n-    <mkdir dir=\"${classes}\"\/>\n-    <javac srcdir=\"${src}\" classpath=\"${jcov.jar}\" destdir=\"${classes}\"\/>\n-  <\/target>\n-\n-  <target name=\"jar\" depends=\"compile\">\n-    <jar jarfile=\"${jar}\" basedir=\"${classes}\"\/>\n-  <\/target>\n-\n-  <target name=\"clean\">\n-    <delete dir=\"${build}\"\/>\n-  <\/target>\n-\n-  <target name=\"compile-test\" depends=\"compile\">\n-    <fail unless=\"testng.classpath\" message=\"Please specify testng.classpath\"\/>\n-    <mkdir dir=\"${test.classes}\"\/>\n-    <javac srcdir=\"${test}\" classpath=\"${classes}:${jcov.jar}:${testng.classpath}\" destdir=\"${test.classes}\" debug=\"true\"\/>\n-    <copy file=\"${test}\/openjdk\/jcov\/data\/instrumentation.properties\" tofile=\"${test.classes}\/openjdk\/jcov\/data\/instrumentation.properties\"\/>\n-  <\/target>\n-\n-  <target name=\"fast-test\">\n-    <antcall target=\"test\" inheritAll=\"true\">\n-      <param name=\"test.excludes\" value=\"**\/jreinstr\/**\/*.class\"\/>\n-    <\/antcall>\n-  <\/target>\n-\n-  <target name=\"test\" depends=\"compile,compile-test\">\n-    <available file=\"${jcov.file.saver.jar}\" property=\"jcov-file-saver-jar-exists\"\/>\n-    <fail unless=\"jcov-file-saver-jar-exists\" message=\"There is no ${jcov.file.saver.jar}\"\/>\n-    <taskdef resource=\"testngtasks\" classpath=\"${testng.classpath}\"\/>\n-    <mkdir dir=\"${test.results}\"\/>\n-    <jar jarfile=\"${test.jar}\" basedir=\"${test.classes}\"\/>\n-    <propertyset id=\"test.bytecode\">\n-      <propertyref name=\"test.classes\"\/>\n-      <propertyref name=\"test.jar\"\/>\n-      <propertyref name=\"jcov.file.saver.jar\"\/>\n-    <\/propertyset>\n-    <testng classpath=\"${classes}:${jcov.jar}:${test.classes}:${testng.classpath}\" outputDir=\"${test.results}\" verbose=\"3\">\n-      <propertyset refid=\"test.bytecode\"\/>\n-      <classfileset dir=\"${test.classes}\" includes=\"${test.includes}\" excludes=\"${test.excludes}\"\/>\n-    <\/testng>\n-  <\/target>\n-<\/project>\n","filename":"plugins\/data_coverage\/build.xml","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.Set;\n-\n-\/**\n- * Much of the functionality in this plugin is controlled through system properties. This class defines some shortcuts\n- * which makes it a bit easier.\n- *\/\n-public class Env {\n-\n-    public static final String PROP_FILE =\n-            Env.class.getPackageName().replace('.', '\/') +\n-            \"\/instrumentation.properties\";\n-    \/**\n-     * Prefix for all system property names which will be passed to the VM running JCov calls.\n-     *\/\n-    public static final String JCOV_DATA_ENV_PREFIX = \"jcov.data.\";\n-\n-    public static final String JCOV_DATA_SAVER = \"jcov.data.saver\";\n-    private static final String JCOV_OPTION_FOR_DATA_SAVER = \"jcov.data-saver\";\n-\n-    private static volatile Properties SAVED;\n-\n-    public static void setSystemProperties(Map<String, String> properties) {\n-        properties.forEach((k, v) -> System.setProperty(k, v));\n-    }\n-\n-    public static void clear(String prefix) {\n-        Set<String> keys = System.getProperties().stringPropertyNames();\n-        keys.stream().filter(k -> k.startsWith(prefix))\n-                .forEach(k -> System.clearProperty(k));\n-    }\n-\n-    public static String getStringEnv(String property, String defaultValue) {\n-        synchronized(Env.class) {\n-            if (SAVED == null) {\n-                try {\n-                    SAVED = new Properties();\n-                    InputStream in = Env.class.getResourceAsStream(\"\/\" + PROP_FILE);\n-                    if(in != null) {\n-                        SAVED.load(in);\n-                        if(System.getProperty(JCOV_OPTION_FOR_DATA_SAVER) == null) {\n-                            String saver = SAVED.getProperty(JCOV_DATA_SAVER);\n-                            if(saver != null)\n-                                System.setProperty(JCOV_OPTION_FOR_DATA_SAVER, saver);\n-                        }\n-                        System.out.println(\"Using property definitions from \" + PROP_FILE + \":\");\n-                        SAVED.list(System.out);\n-                    }\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                } catch (Throwable e) {\n-                    e.printStackTrace();\n-                    throw e;\n-                }\n-            }\n-        }\n-        String override = System.getProperty(property);\n-        return (override != null) ? override : SAVED.getProperty(property, defaultValue);\n-    }\n-\n-    public static Path getPathEnv(String property, Path defaultValue) {\n-        String propValue = getStringEnv(property, null);\n-        if(propValue != null) return Path.of(propValue);\n-        else return defaultValue;\n-    }\n-\n-    public static <SPI> SPI getSPIEnv(String property, SPI defaultValue) throws ClassNotFoundException,\n-            NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n-        String propValue = getStringEnv(property, null);\n-        if(propValue != null) {\n-            if (!propValue.contains(\"(\"))\n-                return (SPI) Class.forName(propValue).getConstructor().newInstance();\n-            else {\n-                int ob = propValue.indexOf('(');\n-                int cb = propValue.indexOf(')');\n-                Class cls = Class.forName(propValue.substring(0, ob));\n-                String[] params = propValue.substring(ob + 1, cb).split(\",\");\n-                Class[] paramTypes = new Class[params.length];\n-                Arrays.fill(paramTypes, String.class);\n-                return (SPI) cls.getConstructor(paramTypes).newInstance(params);\n-            }\n-        } else return defaultValue;\n-    }\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/Env.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data;\n-\n-import com.sun.tdk.jcov.Instr;\n-import openjdk.jcov.data.arguments.instrument.Plugin;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import static java.util.stream.Collectors.toList;\n-import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n-\n-\/**\n- * Some API which makes it easier to run JCov instrumentation while setting specific options to use an instrumentation\n- * plugin. Could be used in tests or other java code.<br\/>\n- * Also provides a main method so it is easier to run the instrumentation from the command line.<br\/>\n- * Current implementaion runs JCov code in the same VM.\n- *\/\n-public class Instrument {\n-    \/**\n-     * Name of a system property which contains class name of an instrumentation plugin.\n-     *\/\n-    public static final String PLUGIN_CLASS = JCOV_DATA_ENV_PREFIX + \"plugin\";\n-    public static final String JCOV_TEMPLATE = JCOV_DATA_ENV_PREFIX + \"jcov.template\";\n-\n-    private String pluginClass;\n-    private Path jcovTemplate;\n-\n-    public Instrument() {\n-        pluginClass = Env.getStringEnv(PLUGIN_CLASS, Plugin.class.getName());\n-        jcovTemplate = Env.getPathEnv(JCOV_TEMPLATE, Paths.get(\"template.xml\"));\n-    }\n-\n-    public Instrument pluginClass(String pluginClass) {\n-        this.pluginClass = pluginClass;\n-        return this;\n-    }\n-\n-    public Instrument jcovTemplate(Path jcovTemplate) {\n-        this.jcovTemplate = jcovTemplate;\n-        return this;\n-    }\n-\n-    public boolean instrument(List<Path> classes) throws IOException, InterruptedException {\n-        List<String> params = new ArrayList<>();\n-        params.add(\"-instr_plugin\");\n-        params.add(pluginClass);\n-        params.add(\"-t\");\n-        params.add(jcovTemplate.toString());\n-        params.addAll(classes.stream().map(Path::toString).collect(toList()));\n-        return new Instr().run(params.toArray(new String[0])) == 0;\n-    }\n-\n-    public static void main(String[] args) throws IOException, InterruptedException {\n-        new Instrument().instrument(Arrays.stream(args).map(Paths::get).collect(toList()));\n-    }\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/Instrument.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.instrument;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static org.objectweb.asm.Opcodes.ALOAD;\n-\n-\/**\n- * When used defines which methods to instrument for argument collection.\n- *\/\n-public interface MethodFilter {\n-    static List<Plugin.TypeDescriptor> parseDesc(String desc) throws ClassNotFoundException {\n-        if(!desc.startsWith(\"(\")) throw new IllegalArgumentException(\"Not a method descriptor: \" + desc);\n-        int pos = 1;\n-        List<Plugin.TypeDescriptor> res = new ArrayList<>();\n-        while(desc.charAt(pos) != ')') {\n-            char next = desc.charAt(pos);\n-            if(next == 'L') {\n-                int l = pos;\n-                pos = desc.indexOf(\";\", pos) + 1;\n-                res.add(new Plugin.TypeDescriptor(\"L\", desc.substring(l + 1, pos - 1), ALOAD));\n-            } else if(next == '[') {\n-                \/\/TODO can we do better?\n-                res.add(new Plugin.TypeDescriptor(\"[\", \"java\/lang\/Object\", ALOAD));\n-                if(desc.charAt(pos + 1) == 'L') pos = desc.indexOf(\";\", pos) + 1;\n-                else pos = pos + 2;\n-            } else {\n-                res.add(Plugin.primitiveTypes.get(new String(new char[] {next})));\n-                pos++;\n-            }\n-        }\n-        return res;\n-    }\n-\n-    boolean accept(int access, String owner, String name, String desc) throws Exception;\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/instrument\/MethodFilter.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,253 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.instrument;\n-\n-import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n-import openjdk.jcov.data.arguments.runtime.Collect;\n-import openjdk.jcov.data.arguments.runtime.Coverage;\n-import openjdk.jcov.data.Env;\n-import openjdk.jcov.data.arguments.runtime.Implantable;\n-import openjdk.jcov.data.arguments.runtime.Saver;\n-import openjdk.jcov.data.arguments.runtime.Serializer;\n-import org.objectweb.asm.MethodVisitor;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarOutputStream;\n-\n-import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n-import static openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER;\n-import static org.objectweb.asm.Opcodes.*;\n-\n-\/**\n- * An instrumention plugin responsible for adding necessary bytecode instructions to collect and pass argument values to\n- * a specified collector.\n- *\/\n-public class Plugin implements ASMInstrumentationPlugin {\n-    \/**\n-     * Classname of a collector class which will be called from every instrumented method.\n-     *\/\n-    public static final String COLLECTOR_CLASS = Collect.class.getName()\n-            .replace('.', '\/');\n-    \/**\n-     * Name of the methods which will be called from every instrumented method.\n-     *\/\n-    public static final String COLLECTOR_METHOD = \"collect\";\n-    \/**\n-     * Signature of the method which will be called from every instrumented method.\n-     *\/\n-    public static final String COLLECTOR_DESC =\n-            \"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;[Ljava\/lang\/Object;)V\";\n-    \/**\n-     * Name of a property which contains class name for the method filter.\n-     *\/\n-    public static final String METHOD_FILTER =\n-        JCOV_DATA_ENV_PREFIX + Collect.ARGUMENTS_PREFIX + \"method.filter\";\n-\n-    \/**\n-     * Aux class responsible for code generation for different types.\n-     *\/\n-    public static class TypeDescriptor extends openjdk.jcov.data.instrument.TypeDescriptor {\n-\n-        public TypeDescriptor(String id, String cls, int loadOpcode) {\n-            super(id, cls, loadOpcode);\n-        }\n-\n-        public TypeDescriptor(String id, Class cls, int loadOpcode, boolean longOrDouble, boolean isPrimitive) {\n-            super(id, cls, loadOpcode, longOrDouble, isPrimitive);\n-        }\n-\n-        \/\/returns new stack index increased by 1 or 2\n-        int visit(int paramIndex, int stackIndex, MethodVisitor visitor) {\n-            visitor.visitInsn(DUP);\n-            visitor.visitIntInsn(BIPUSH, paramIndex);\n-            visitor.visitIntInsn(loadOpcode(), stackIndex);\n-            if(isPrimitive())\n-                visitor.visitMethodInsn(INVOKESTATIC, cls(), \"valueOf\",\n-                        \"(\" + id() + \")L\" + cls() + \";\", false);\n-            visitor.visitInsn(AASTORE);\n-            return stackIndex + (isLongOrDouble() ? 2 : 1);\n-        }\n-    }\n-\n-    final static Map<String, TypeDescriptor> primitiveTypes;\n-\n-    static {\n-        primitiveTypes = new HashMap<>();\n-        primitiveTypes.put(\"S\", new TypeDescriptor(\"S\", Short.class, ILOAD, false, true));\n-        primitiveTypes.put(\"I\", new TypeDescriptor(\"I\", Integer.class, ILOAD, false, true));\n-        primitiveTypes.put(\"J\", new TypeDescriptor(\"J\", Long.class, LLOAD, true, true));\n-        primitiveTypes.put(\"F\", new TypeDescriptor(\"F\", Float.class, FLOAD, false, true));\n-        primitiveTypes.put(\"D\", new TypeDescriptor(\"D\", Double.class, DLOAD, true, true));\n-        primitiveTypes.put(\"Z\", new TypeDescriptor(\"Z\", Boolean.class, ILOAD, false, true));\n-        primitiveTypes.put(\"B\", new TypeDescriptor(\"B\", Byte.class, ILOAD, false, true));\n-        primitiveTypes.put(\"C\", new TypeDescriptor(\"C\", Character.class, ILOAD, false, true));\n-    }\n-\n-    final static TypeDescriptor objectType = new TypeDescriptor(\"L\", Object.class, ALOAD, false, false);\n-\n-    private final Coverage template;\n-    private MethodFilter methodFilter;\n-    private Path templateFile;\n-    private Function<Object, String> serializer;\n-\n-    public Plugin() throws\n-            ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException,\n-            IllegalAccessException {\n-        template = new Coverage();\n-        methodFilter = Env.getSPIEnv(METHOD_FILTER, (a, o, m, d) -> true);\n-        templateFile = Env.getPathEnv(Collect.COVERAGE_OUT, Paths.get(\"template.lst\"));\n-        serializer = Env.getSPIEnv(SERIALIZER, Object::toString);\n-    }\n-\n-    \/**\n-     * Injects necessary instructions to place all the arguments into an array which is then passed tp the collector's\n-     * method.\n-     *\/\n-    @Override\n-    public MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor) {\n-        try {\n-            String method = name + desc;\n-            try {\n-                if (methodFilter.accept(access, owner, name, desc)) {\n-                    template.get(owner, method);\n-                    return new MethodVisitor(ASM6, visitor) {\n-                        @Override\n-                        public void visitCode() {\n-                            try {\n-                                List<TypeDescriptor> params = MethodFilter.parseDesc(desc);\n-                                if (params.size() > 0) {\n-                                    super.visitLdcInsn(owner);\n-                                    super.visitLdcInsn(name);\n-                                    super.visitLdcInsn(desc);\n-                                    super.visitIntInsn(BIPUSH, params.size());\n-                                    super.visitTypeInsn(ANEWARRAY, \"java\/lang\/Object\");\n-                                    int stackIndex = ((access & ACC_STATIC) > 0) ? 0 : 1;\n-                                    for (int i = 0; i < params.size(); i++) {\n-                                        stackIndex = params.get(i).visit(i, stackIndex, this);\n-                                    }\n-                                    visitor.visitMethodInsn(INVOKESTATIC, COLLECTOR_CLASS, COLLECTOR_METHOD,\n-                                            COLLECTOR_DESC, false);\n-                                }\n-                            } catch (Exception e) {\n-                                e.printStackTrace();\n-                            }\n-                            super.visitCode();\n-                        }\n-                    };\n-                } else return visitor;\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-        } catch(Throwable e) {\n-            \/\/JCov is known for swallowing exceptions\n-            e.printStackTrace();\n-            throw e;\n-        }\n-    }\n-\n-    @Override\n-    public void instrumentationComplete() throws IOException {\n-        try {\n-            Coverage.write(template, templateFile);\n-        } catch(Throwable e) {\n-            \/\/JCov is known for swallowing exceptions\n-            e.printStackTrace();\n-            throw e;\n-        }\n-    }\n-\n-    private static final Set<Class> runtimeClasses = Set.of(\n-            Collect.class, Coverage.class, Saver.class, Saver.NoRuntimeSerializer.class, Env.class,\n-            Implantable.class, Serializer.class\n-    );\n-\n-    protected List<Class> runtimeClasses() {\n-        return runtimeClasses();\n-    }\n-\n-    @Override\n-    public Path runtime() throws Exception {\n-        try {\n-            Path dest = Files.createTempFile(\"jcov-data\", \".jar\");\n-            Properties toSave = new Properties();\n-            System.getProperties().forEach((k, v) -> {\n-                if(k.toString().startsWith(JCOV_DATA_ENV_PREFIX))\n-                    toSave.setProperty(k.toString(), v.toString());\n-            });\n-            Set<Class> allRuntime = runtimeClasses;\n-            Function<Object, String> serializer = Env.getSPIEnv(SERIALIZER, null);\n-            if(serializer != null && serializer instanceof Implantable) {\n-                allRuntime = new HashSet<>(runtimeClasses);\n-                allRuntime.addAll(((Implantable)serializer).runtime());\n-            }\n-            try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n-                jar.putNextEntry(new JarEntry(Env.PROP_FILE));\n-                toSave.store(jar, \"\");\n-                jar.closeEntry();\n-                for(Class rc : allRuntime) {\n-                    String fileName = rc.getName().replace(\".\", \"\/\") + \".class\";\n-                    jar.putNextEntry(new JarEntry(fileName));\n-                    try (InputStream ci = rc.getClassLoader().getResourceAsStream(fileName)) {\n-                        byte[] buffer = new byte[1024];\n-                        int read;\n-                        while ((read = ci.read(buffer)) > 0) {\n-                            jar.write(buffer, 0, read);\n-                        }\n-                    }\n-                    jar.closeEntry();\n-                }\n-            }\n-            return dest;\n-        } catch(Throwable e) {\n-            \/\/JCov is known for swallowing exceptions\n-            e.printStackTrace();\n-            throw e;\n-        }\n-    }\n-\n-    @Override\n-    public String collectorPackage() {\n-        try {\n-            return Collect.class.getPackage().getName();\n-        } catch(Throwable e) {\n-            \/\/JCov is known for swallowing exceptions\n-            e.printStackTrace();\n-            throw e;\n-        }\n-    }\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/instrument\/Plugin.java","additions":0,"deletions":253,"binary":false,"changes":253,"status":"deleted"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.runtime;\n-\n-import openjdk.jcov.data.Env;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * Calls to this class' collect(...) methods are injected in the beginning of every instrumented method.\n- *\/\n-public class Collect {\n-    \/**\n-     * Property name prefix for all properties used by this plugin. The property names are started with\n-     * <code>Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX<\/code>\n-     *\/\n-    public static final String ARGUMENTS_PREFIX = \"args.\";\n-    \/**\n-     * Specifies where to save collected data or instrumentation information.\n-     *\/\n-    public static final String COVERAGE_OUT = Env.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX +\n-            \"coverage\";\n-    \/**\n-     * Specifies where to load previously collected data from. A non-empty value of this property will\n-     * make Collect class to load the data on class loading.\n-     *\/\n-    public static final String COVERAGE_IN = Env.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX +\n-            \"coverage.in\";\n-\n-    \/**\n-     * Name of a property containing a class name of a class of type <code>Function<Object, String><\/code> which will\n-     * be used during the serialization. <code>Object::toString<\/code> is used by default.\n-     *\/\n-    public static final String SERIALIZER = Env.JCOV_DATA_ENV_PREFIX +\n-            Collect.ARGUMENTS_PREFIX + \"serializer\";\n-\n-    static volatile Coverage data;\n-    private volatile static Serializer serializer;\n-\n-    static {\n-        if (!Env.getStringEnv(COVERAGE_IN, \"\").isEmpty()) {\n-            try {\n-                Path coverageFile = Env.getPathEnv(COVERAGE_IN, null);\n-                System.out.println(\"Loading data coverage from \" + coverageFile);\n-                data = Coverage.read(coverageFile);\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        } else data = new Coverage();\n-        try {\n-            serializer = wrap(Env.getSPIEnv(SERIALIZER, Object::toString));\n-        } catch (ClassNotFoundException|NoSuchMethodException|IllegalAccessException|InvocationTargetException|InstantiationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private static Serializer wrap(Function<Object, String> function) {\n-        if(function instanceof Serializer)\n-            return (Serializer) function;\n-        else\n-            return new Saver.NoRuntimeSerializer(function);\n-    }\n-\n-    public static synchronized void collect(String owner, String name, String desc, Object... params) {\n-\/\/        keep these lines, it is useful for debugging in hard cases\n-\/\/        System.out.printf(\"%s.%s%s: %s\\n\", owner, name, desc, (params == null) ? \"null\" :\n-\/\/                Arrays.stream(params).map(Object::getClass).map(Class::getName)\n-\/\/                        .collect(java.util.stream.Collectors.joining(\",\")));\n-\/\/        System.out.println(Arrays.stream(params).map(Objects::toString)\n-\/\/                .collect(Collectors.joining(\",\")));\n-        data.add(owner, name + desc, Arrays.stream(params).map(serializer::apply)\n-                .collect(Collectors.toList()));\n-    }\n-\n-    static int countParams(String desc) {\n-        if(!desc.startsWith(\"(\")) throw new IllegalArgumentException(\"Not a method descriptor: \" + desc);\n-        int pos = 1;\n-        int count = 0;\n-        while(desc.charAt(pos) != ')') {\n-            char next = desc.charAt(pos);\n-            if(next == 'L') {\n-                int l = pos;\n-                pos = desc.indexOf(\";\", pos) + 1;\n-                count++;\n-            } else if(next == '[') {\n-                \/\/TODO can we do better?\n-                count++;\n-                if(desc.charAt(pos + 1) == 'L') pos = desc.indexOf(\";\", pos) + 1;\n-                else pos = pos + 2;\n-            } else {\n-                count++;\n-                pos++;\n-            }\n-        }\n-        return count;\n-    }\n-\n-    public static void clearData() {\n-        data.coverage().clear();\n-    }\n-\n-    public static void serializer(Serializer serializer) {\n-        Collect.serializer = serializer;\n-    }\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Collect.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.runtime;\n-\n-import java.io.BufferedWriter;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-\n-import static java.util.stream.Collectors.toList;\n-\n-\/**\n- * Data container for the values collected in runtime. Same class is used to store template as a file with no\n- * values and just method descriptions.\n- *\/\n-public class Coverage {\n-\n-    public static final String DATA_PREFIX = \" -> \";\n-    private final Map<String, Map<String, List<List<? extends Object>>>> data;\n-\n-    public static Coverage read(Path path) throws IOException {\n-        return readImpl(path, s -> s);\n-    }\n-\n-    private static List<String> split(String s) {\n-        List<String> result = new ArrayList<>();\n-        int lci = -1;\n-        for (int ci = 0; ci < s.length(); ci++) {\n-            if(s.charAt(ci) == ',') {\n-                result.add(s.substring(lci + 1, ci));\n-                lci = ci;\n-            }\n-        }\n-        result.add(s.substring(lci + 1));\n-        return result;\n-    }\n-\n-    private static List<? extends Object> parse(String s, Function<String, ? extends Object> deserialize) {\n-        return split(s).stream()\n-                .map(v -> v.isEmpty() ? \"\" : deserialize.apply(v))\n-                .collect(toList());\n-    }\n-\n-    \/\/TODO move to an SPI class\n-    public static Coverage read(Path path, Function<String, ? extends Object> deserializer) throws IOException {\n-        return readImpl(path, deserializer);\n-    }\n-\n-    \/**\n-     * Loads the data from a file in a custom plain text format.\n-     *\/\n-    private static Coverage readImpl(Path path, Function<String, ? extends Object> deserializer) throws IOException {\n-        Coverage result = new Coverage();\n-        List<List<? extends Object>> lastData = null;\n-        String desc = null, name = null, owner = null;\n-        for (String l : Files.readAllLines(path)) {\n-            if (!l.startsWith(DATA_PREFIX)) {\n-                int descStart = l.indexOf('(');\n-                int classEnd = l.lastIndexOf('#', descStart);\n-                owner = l.substring(0, classEnd);\n-                name = l.substring(classEnd + 1, descStart);\n-                desc = l.substring(descStart);\n-                lastData = result.get(owner, name + desc);\n-            } else {\n-                List<? extends Object> values = parse(l.substring(DATA_PREFIX.length()), deserializer);\n-                \/\/TODO this needs to be fixed for arrays\n-\/\/                if(Collect.countParams(desc) != values.size()) {\n-\/\/                    throw new IllegalStateException(\"Incorrect number of parameters for \" +\n-\/\/                            owner + \"#\" + name + desc + \": \" + values.size());\n-\/\/                }\n-                lastData.add(values);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    \/\/TODO move to an SPI class\n-\n-    \/**\n-     * Saves the data into a file in a custom plain text format.\n-     *\/\n-    public static final void write(Coverage coverage, Path path\/*, Function<Object, String> serializer*\/)\n-            throws IOException {\n-        try(BufferedWriter out = Files.newBufferedWriter(path)) {\n-            coverage.data.entrySet().forEach(ce -> {\n-                    ce.getValue().entrySet().forEach(me -> {\n-                        try {\n-                            out.write(ce.getKey() + \"#\" + me.getKey());\n-                            out.newLine();\n-                            me.getValue().forEach(dl -> {\n-                                try {\n-                                    String desc = me.getKey().substring(me.getKey().indexOf(\"(\"));\n-                                    List<String> values = dl.stream().map(o -> (String)o)\n-                                            .collect(toList());\n-                                    if(Collect.countParams(desc) != values.size()) {\n-                                        System.err.println(\"Incorect number of params for \" + me.getKey());\n-                                        System.out.println(values.stream().map(Objects::toString)\n-                                                .collect(Collectors.joining(\",\")));\n-                                        throw new IllegalStateException(\"Incorrect number of parameters for \" +\n-                                                me.getKey() + \": \" + values.size());\n-                                    }\n-                                    out.write(DATA_PREFIX +\n-                                            values.stream()\/\/.map(d -> serializer.apply(d))\n-                                            .collect(Collectors.joining(\",\")));\n-                                    out.newLine();\n-                                } catch (IOException e) {\n-                                    throw new UncheckedIOException(e);\n-                                }\n-                            });\n-                            out.flush();\n-                        } catch (IOException e) {\n-                            throw new UncheckedIOException(e);\n-                        }\n-                    });\n-            });\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    private final boolean selfCompacting = true;\n-\n-    public Coverage() {\n-        data = new HashMap<>();\n-    }\n-\n-    \/**\n-     * Obtains a structure for the data, adding an empty one, if necessary.\n-     *\/\n-    public List<List<? extends Object>> get(String owner, String method) {\n-        Map<String, List<List<? extends Object>>> methods = data.get(owner);\n-        if(methods == null) {\n-            methods = new HashMap<>();\n-            data.put(owner, methods);\n-        }\n-        List<List<? extends Object>> result = methods.get(method);\n-        if(result == null) {\n-            result = new ArrayList<>();\n-            methods.put(method, result);\n-        }\n-        return result;\n-    }\n-\n-    public void add(String owner, String method, List<? extends Object> params) {\n-        List<List<? extends Object>> methodCov = get(owner, method);\n-        if(methodCov.stream().noneMatch(call -> {\n-            if(call.size() != params.size()) return false;\n-            for (int i = 0; i < call.size(); i++)\n-                if(!Objects.equals(call.get(i), params.get(i))) return false;\n-            return true;\n-        })) methodCov.add(params);\n-    }\n-\n-    public Map<String, Map<String, List<List<? extends Object>>>> coverage() {\n-        return data;\n-    }\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Coverage.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.runtime;\n-\n-import java.util.Collection;\n-\n-public interface Implantable {\n-    Collection<Class> runtime();\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Implantable.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.runtime;\n-\n-import com.sun.tdk.jcov.runtime.JCovSaver;\n-import openjdk.jcov.data.Env;\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Collection;\n-import java.util.function.Function;\n-\n-public class Saver implements JCovSaver {\n-\n-    \/**\n-     * Name of a property containing a class name of a class of type <code>Function<Object, String><\/code> which will\n-     * be used during the serialization. <code>Object::toString<\/code> is used by default.\n-     *\/\n-\/\/    public static final String SERIALIZER = Env.JCOV_DATA_ENV_PREFIX +\n-\/\/            Collect.ARGUMENTS_PREFIX + \"serializer\";\n-\n-    private Path resultFile;\n-\/\/    private Serializer serializer;\n-\n-    public Saver() throws\n-            ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException,\n-            IllegalAccessException {\n-        resultFile = Env.getPathEnv(Collect.COVERAGE_OUT, Paths.get(\"result.lst\"));\n-\/\/        serializer = wrap(Env.getSPIEnv(SERIALIZER, Object::toString));\n-    }\n-\n-    public Saver resultFile(Path resultFile) {\n-        this.resultFile = resultFile;\n-        return this;\n-    }\n-\n-\/\/    public Saver serializer(Function<Object, String> function) {\n-\/\/        this.serializer = wrap(function);\n-\/\/        return this;\n-\/\/    }\n-\/\/\n-\/\/    public Saver serializer(Serializer serializer) {\n-\/\/        this.serializer = serializer;\n-\/\/        return this;\n-\/\/    }\n-\/\/\n-\/\/    private static Serializer wrap(Function<Object, String> function) {\n-\/\/        if(function instanceof Serializer)\n-\/\/            return (Serializer) function;\n-\/\/        else\n-\/\/            return new NoRuntimeSerializer(function);\n-\/\/    }\n-\n-    public void saveResults() {\n-        try {\n-            System.out.println(\"Saving the data info \" + resultFile);\n-            Coverage.write(Collect.data, resultFile\/*, serializer*\/);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static class NoRuntimeSerializer implements Serializer {\n-        private final Function<Object, String> function;\n-\n-        public NoRuntimeSerializer(Function<Object, String> function) {\n-            this.function = function;\n-        }\n-\n-        @Override\n-        public String apply(Object o) {\n-            return function.apply(o);\n-        }\n-\n-        @Override\n-        public Collection<Class> runtime() {\n-            return null;\n-        }\n-    }\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Saver.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.runtime;\n-\n-import java.util.function.Function;\n-\n-public interface Serializer extends Implantable, Function<Object, String> {\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Serializer.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.instrument;\n-\n-\/**\n- * Contains necessary type information for code generation, etc. Should be extended as needed with the actual code\n- * generation logic.\n- *\/\n-public class TypeDescriptor {\n-    private final String id;\n-    private final String cls;\n-    private final int loadOpcode;\n-    private final boolean longOrDouble;\n-    private final boolean isPrimitive;\n-\n-    public static String toVMClassName(Class cls) {\n-        return toVMClassName(cls.getName());\n-    }\n-    public static String toVMClassName(String className) {\n-        return className.replace('.','\/');\n-    }\n-    public TypeDescriptor(String id, Class cls, int loadOpcode) {\n-        this(id, toVMClassName(cls), loadOpcode);\n-    }\n-    public TypeDescriptor(String id, String cls, int loadOpcode) {\n-        this(id, cls, loadOpcode, false, false);\n-    }\n-    public TypeDescriptor(String id, Class cls, int loadOpcode, boolean longOrDouble, boolean isPrimitive) {\n-        this(id, toVMClassName(cls), loadOpcode, longOrDouble, isPrimitive);\n-    }\n-    public TypeDescriptor(String id, String cls, int loadOpcode, boolean longOrDouble, boolean isPrimitive) {\n-        this.id = id;\n-        this.cls = cls;\n-        this.loadOpcode = loadOpcode;\n-        this.longOrDouble = longOrDouble;\n-        this.isPrimitive = isPrimitive;\n-    }\n-\n-    public String id() {\n-        return id;\n-    }\n-\n-    public String cls() { return cls; }\n-\n-    public int loadOpcode() {\n-        return loadOpcode;\n-    }\n-\n-    public boolean isLongOrDouble() {\n-        return longOrDouble;\n-    }\n-\n-    public boolean isPrimitive() {\n-        return isPrimitive;\n-    }\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/instrument\/TypeDescriptor.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.serialization;\n-\n-import openjdk.jcov.data.arguments.runtime.Implantable;\n-\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.function.Function;\n-\n-\/**\n- * Serializes an enum into its name.\n- *\/\n-public class EnumSerializer implements Function<Object, String>, Implantable {\n-\n-    private final String defaultValue;\n-\n-    public EnumSerializer(String value) {\n-        defaultValue = value;\n-    }\n-\n-    public EnumSerializer() {\n-        this(\"NOT_AN_ENUM\");\n-    }\n-\n-    @Override\n-    public String apply(Object anEnum) {\n-        if (anEnum instanceof Enum)\n-            return ((Enum) anEnum).name();\n-        else\n-            return defaultValue;\n-    }\n-\n-    public Collection<Class> runtime() {\n-        return List.of(EnumSerializer.class);\n-    }\n-}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/serialization\/EnumSerializer.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.enums;\n-\n-import openjdk.jcov.data.arguments.instrument.MethodFilter;\n-\n-public class EnumMethodsFilter implements MethodFilter {\n-    @Override\n-    public boolean accept(int access, String owner, String method, String desc) throws ClassNotFoundException {\n-        return MethodFilter.parseDesc(desc).stream().anyMatch(td -> {\n-            try {\n-                return Enum.class.isAssignableFrom(Class.forName(td.cls().replace('\/', '.')));\n-            } catch (ClassNotFoundException e) {\n-                throw new RuntimeException(e);\n-            }\n-        });\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/enums\/EnumMethodsFilter.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.enums;\n-\n-import openjdk.jcov.data.Instrument;\n-import openjdk.jcov.data.arguments.runtime.Collect;\n-import openjdk.jcov.data.arguments.runtime.Coverage;\n-import openjdk.jcov.data.arguments.instrument.Plugin;\n-import openjdk.jcov.data.arguments.runtime.Saver;\n-import openjdk.jcov.data.Env;\n-import openjdk.jcov.data.lib.TestStatusListener;\n-import openjdk.jcov.data.lib.Util;\n-import openjdk.jcov.data.serialization.EnumDeserializer;\n-import openjdk.jcov.data.serialization.EnumSerializer;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Listeners;\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.List;\n-import java.util.Map;\n-\n-import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n-import static openjdk.jcov.data.Instrument.JCOV_TEMPLATE;\n-import static openjdk.jcov.data.arguments.instrument.Plugin.*;\n-import static openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertSame;\n-\n-@Listeners({openjdk.jcov.data.lib.TestStatusListener.class})\n-public class EnumTest {\n-    private Path test_dir;\n-    private Path template;\n-    private EnumDeserializer deserializer = new EnumDeserializer(UserCode.ENum.class);\n-\n-    @BeforeClass\n-    public void clean() throws IOException {\n-        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n-        test_dir = data_dir.resolve(\"enum_test\");\n-        Util.rfrm(test_dir);\n-        Files.createDirectories(test_dir);\n-        template = test_dir.resolve(\"template.lst\");\n-    }\n-    @Test\n-    public void serialization() {\n-        assertSame(UserCode.ENum.THREE,\n-                new EnumDeserializer(UserCode.ENum.class).apply(new EnumSerializer().apply(UserCode.ENum.THREE)));\n-    }\n-    @Test\n-    public void instrument() throws IOException, InterruptedException {\n-        Env.clear(JCOV_DATA_ENV_PREFIX);\n-        Env.setSystemProperties(Map.of(\n-                Collect.COVERAGE_OUT, template.toString(),\n-                JCOV_TEMPLATE, test_dir.resolve(\"template.xml\").toString(),\n-                METHOD_FILTER, EnumMethodsFilter.class.getName()));\n-        new Instrument().pluginClass(Plugin.class.getName())\n-                .instrument(new Util(test_dir).\n-                        copyBytecode(openjdk.jcov.data.arguments.enums.UserCode.class.getName()));\n-        Coverage tmplt = Coverage.read(template);\n-        assertEquals(tmplt.coverage().get(UserCode.class.getName().replace('.', '\/')).size(), 2);\n-    }\n-\n-    @Test(dependsOnMethods = \"instrument\")\n-    public void run() throws\n-            ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException,\n-            IOException, InstantiationException {\n-        Env.clear(JCOV_DATA_ENV_PREFIX);\n-        Env.setSystemProperties(Map.of(\n-                Collect.COVERAGE_IN, template.toString(),\n-                Collect.COVERAGE_OUT, template.toString(),\n-                SERIALIZER, EnumSerializer.class.getName()));\n-        new Util(test_dir).runClass(UserCode.class, new String[0], new Saver());\n-        Coverage res = Coverage.read(template, deserializer);\n-        List<List<?>> method =\n-                res.get(UserCode.class.getName().replace('.', '\/'),\n-                        \"method(Lopenjdk\/jcov\/data\/arguments\/enums\/UserCode$ENum;)V\");\n-        assertEquals(method.size(), 1);\n-        assertEquals(method.get(0).size(), 1);\n-        assertEquals(method.get(0).get(0), UserCode.ENum.ONE);\n-        List<List<?>> staticMethod =\n-                res.get(UserCode.class.getName().replace('.', '\/'),\n-                        \"staticMethod(Lopenjdk\/jcov\/data\/arguments\/enums\/UserCode$ENum;)V\");\n-        assertEquals(staticMethod.size(), 1);\n-        assertEquals(staticMethod.get(0).size(), 1);\n-        assertEquals(staticMethod.get(0).get(0), UserCode.ENum.TWO);\n-    }\n-    @AfterClass\n-    public void tearDown() throws IOException {\n-        if(TestStatusListener.status) {\n-            Util.rfrm(test_dir);\n-        }\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/enums\/EnumTest.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-package openjdk.jcov.data.arguments.jreinstr.filepermission;\n-\n-import openjdk.jcov.data.Env;\n-\n-import java.io.File;\n-import java.io.FilePermission;\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-\n-import static java.util.stream.Collectors.toMap;\n-\n-public class Main {\n-    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n-        System.getProperties().storeToXML(System.out, \"\");\n-        System.out.println(\"\" + Env.getSPIEnv(openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER, null));\n-        System.getProperties().entrySet().stream()\n-                .forEach(e -> System.out.println(e.getKey() + \" -> \" + e.getValue()));\n-        System.out.println(openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER + \" = \" + System.getProperties().entrySet().stream()\n-                .collect(toMap(Object::toString, Object::toString)).get(openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER));\n-        Path file = Files.createTempFile(\"test\", \".txt\");\n-        FilePermission filePermission = new FilePermission(file.toString(), \"read\");\n-        FilePermission dirPermission = new FilePermission(file.getParent().toString() + \"\/-\", \"read,write\");\n-        System.out.println(dirPermission.implies(filePermission));\n-        Files.delete(file);\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Main.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-package openjdk.jcov.data.arguments.jreinstr.filepermission;\n-\n-import openjdk.jcov.data.arguments.instrument.MethodFilter;\n-\n-import java.io.FilePermission;\n-\n-public class PermissionMethodFilter implements MethodFilter {\n-    @Override\n-    public boolean accept(int access, String owner, String name, String desc) throws Exception {\n-\/\/        return false;\n-        return openjdk.jcov.data.arguments.instrument.MethodFilter.parseDesc(desc).stream()\n-                .anyMatch(td -> td.cls().equals(FilePermission.class.getName().replace('.', '\/')));\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/PermissionMethodFilter.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,18 +0,0 @@\n-package openjdk.jcov.data.arguments.jreinstr.filepermission;\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class Plugin extends openjdk.jcov.data.arguments.instrument.Plugin {\n-    public Plugin() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n-        super();\n-    }\n-\n-    @Override\n-    protected List<Class> runtimeClasses() {\n-        ArrayList<Class> result =  new ArrayList<>(super.runtimeClasses());\n-        result.add(Serializer.class);\n-        return result;\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Plugin.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-package openjdk.jcov.data.arguments.jreinstr.filepermission;\n-\n-import openjdk.jcov.data.arguments.runtime.Collect;\n-import openjdk.jcov.data.arguments.runtime.Implantable;\n-\n-import java.io.File;\n-import java.io.FilePermission;\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Set;\n-\n-public class Serializer implements openjdk.jcov.data.arguments.runtime.Serializer {\n-    @Override\n-    public String apply(Object o) {\n-        if(o instanceof FilePermission) {\n-            return ((FilePermission)o).getActions();\n-        } else return null;\n-    }\n-\n-    @Override\n-    public Collection<Class> runtime() {\n-        return Set.of(Serializer.class,\n-                Implantable.class);\n-    }\n-\n-    public static void main(String[] args) throws IOException {\n-        File file = File.createTempFile(\"test\", \".txt\");\n-        file.delete();\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Serializer.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-package openjdk.jcov.data.arguments.jreinstr.filepermission;\n-\n-import openjdk.jcov.data.JREInstr;\n-import openjdk.jcov.data.arguments.runtime.Coverage;\n-import openjdk.jcov.data.arguments.runtime.Saver;\n-import openjdk.jcov.data.lib.TestStatusListener;\n-import openjdk.jcov.data.lib.Util;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Listeners;\n-\n-import java.io.File;\n-import java.io.FilePermission;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileTime;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import static openjdk.jcov.data.arguments.instrument.Plugin.METHOD_FILTER;\n-import static openjdk.jcov.data.arguments.runtime.Collect.COVERAGE_OUT;\n-import static openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER;\n-import static openjdk.jcov.data.lib.Util.copyJRE;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-@Listeners({TestStatusListener.class})\n-public class Test {\n-    private Path data_dir;\n-    private Path template;\n-    private Path jcov_template;\n-    private Path jcov_result;\n-    private Path jre;\n-    private Path main;\n-    private FileTime templateCreated;\n-\n-    @BeforeClass\n-    public void setup() throws IOException {\n-        jre = copyJRE(Paths.get(System.getProperty(\"test.jre\", System.getProperty(\"java.home\"))));\n-        data_dir = Paths.get(System.getProperty(\"user.dir\"));\n-        template = data_dir.resolve(\"template.lst\");\n-        jcov_template = data_dir.resolve(\"template.xml\");\n-        jcov_result = data_dir.resolve(\"result.xml\");\n-        main = data_dir.resolve(\"Main.java\");\n-    }\n-    @org.testng.annotations.Test\n-    public void instrument() throws IOException, InterruptedException {\n-        Files.deleteIfExists(jcov_template);\n-        Files.deleteIfExists(template);\n-        String runtime = Arrays.stream(System.getProperty(\"java.class.path\").split(File.pathSeparator))\n-                .filter(s -> s.endsWith(\"jcov_file_saver.jar\")).findAny().get();\n-        int status = new JREInstr()\n-                .clearEnv()\n-                .setEnv(Map.of(\n-                        COVERAGE_OUT, template.toString(),\n-                        METHOD_FILTER, PermissionMethodFilter.class.getName(),\n-                        SERIALIZER, Serializer.class.getName()))\n-                .pluginClass(Plugin.class.getName())\n-                .jcovRuntime(runtime)\n-                .jcovTemplate(jcov_template.toString())\n-                .instrument(jre.toString());\n-        assertEquals(status, 0);\n-        assertTrue(Files.exists(jcov_template), \"Template file: \" + jcov_template);\n-        assertTrue(Files.exists(template), \"Template file: \" + template);\n-        templateCreated = Files.readAttributes(template, BasicFileAttributes.class).lastModifiedTime();\n-    }\n-\n-    @org.testng.annotations.Test(dependsOnMethods = \"instrument\")\n-    public void testInstrumentation() throws IOException, InterruptedException {\n-        Files.write(main, List.of(\n-                \"package openjdk.jcov.data.arguments.jreinstr.filepermission;\",\n-                \"import java.io.FilePermission;\",\n-                \"import java.io.IOException;\",\n-                \"import java.nio.file.Files;\",\n-                \"import java.nio.file.Path;\",\n-                \"public class Main {\",\n-                \"    public static void main(String[] args) throws IOException {\",\n-                \"        Path file = Files.createTempFile(\\\"test\\\", \\\".txt\\\");\",\n-                \"        FilePermission filePermission = new FilePermission(file.toString(), \\\"read\\\");\",\n-                \"        FilePermission dirPermission = new FilePermission(file.getParent().toString() + \\\"\/-\\\", \\\"read,write\\\");\",\n-                \"        System.out.println(dirPermission.implies(filePermission));\",\n-                \"        Files.delete(file);\",\n-                \"    }\",\n-                \"}\"\n-        ));\n-        Files.deleteIfExists(jcov_result);\n-        \/\/no classpath necessary for the next call because the class is implanted\n-        List<String> command = List.of(\n-                jre.toString() + File.separator + \"bin\" + File.separator + \"java\",\n-                \"-Djcov.data-saver=\" + Saver.class.getName(),\n-                main.toString());\n-        System.out.println(command.stream().collect(Collectors.joining(\" \")));\n-        Process p = new ProcessBuilder()\n-                .directory(data_dir.toFile())\n-                .command(command)\n-                .redirectError(ProcessBuilder.Redirect.INHERIT)\n-                .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n-                .start();\n-        int status = p.waitFor();\n-        assertEquals(status, 0);\n-        assertTrue(Files.exists(jcov_result), \"Result file: \" + jcov_result);\n-        assertTrue(Files.readAttributes(template, BasicFileAttributes.class).lastModifiedTime()\n-                .compareTo(templateCreated) > 0);\n-    }\n-\n-    @org.testng.annotations.Test(dependsOnMethods = \"testInstrumentation\")\n-    public void testCoverage() throws IOException, InterruptedException {\n-        Coverage cov = Coverage.read(template, a -> a);\n-        assertEquals(cov.coverage().get(FilePermission.class.getName().replace('.', '\/'))\n-                .entrySet().stream().filter(e -> e.getKey().startsWith(\"impliesIgnoreMask\"))\n-                .findAny().get().getValue().get(0).get(0), \"read\");\n-    }\n-\n-    @AfterClass\n-    public void tearDown() throws IOException {\n-        List<Path> artifacts = List.of(template, jcov_template, template, jcov_result, jre, main);\n-        if(TestStatusListener.status)\n-            for(Path file : artifacts) Util.rfrm(file);\n-        else {\n-            System.out.println(\"Test failed, keeping the artifacts:\");\n-            artifacts.forEach(System.out::println);\n-        }\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Test.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-package openjdk.jcov.data.arguments.jreinstr.filepermission;\n-\n-import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n-import org.objectweb.asm.MethodVisitor;\n-\n-import java.nio.file.Path;\n-\n-public class VoidPlugin implements ASMInstrumentationPlugin {\n-\n-    public VoidPlugin() {\n-        super();\n-    }\n-\n-    @Override\n-    public MethodVisitor methodVisitor(int i, String s, String s1, String s2, MethodVisitor visitor) {\n-        return visitor;\n-    }\n-\n-    @Override\n-    public void instrumentationComplete() throws Exception {\n-\n-    }\n-\n-    @Override\n-    public Path runtime() throws Exception {\n-        return null;\n-    }\n-\n-    @Override\n-    public String collectorPackage() {\n-        return null;\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/VoidPlugin.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.main;\n-\n-import openjdk.jcov.data.Env;\n-import openjdk.jcov.data.Instrument;\n-import openjdk.jcov.data.arguments.enums.EnumTest;\n-import openjdk.jcov.data.arguments.instrument.Plugin;\n-import openjdk.jcov.data.arguments.runtime.Collect;\n-import openjdk.jcov.data.arguments.runtime.Coverage;\n-import openjdk.jcov.data.arguments.runtime.Saver;\n-import openjdk.jcov.data.lib.TestStatusListener;\n-import openjdk.jcov.data.lib.Util;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Listeners;\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n-import static openjdk.jcov.data.Instrument.JCOV_TEMPLATE;\n-import static openjdk.jcov.data.arguments.instrument.Plugin.*;\n-import static openjdk.jcov.data.arguments.runtime.Collect.*;\n-import static org.testng.Assert.assertEquals;\n-\n-@Listeners({TestStatusListener.class})\n-public class MainTest {\n-    private Path test_dir;\n-    private Path coverage;\n-\n-    @BeforeClass\n-    public void clean() throws IOException {\n-        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n-        test_dir = data_dir.resolve(\"main_test\");\n-        Util.rfrm(test_dir);\n-        Files.createDirectories(test_dir);\n-        coverage = test_dir.resolve(\"coverage.lst\");\n-    }\n-    private Coverage instrument(Class cls) throws IOException, InterruptedException {\n-        Env.clear(JCOV_DATA_ENV_PREFIX);\n-        Env.setSystemProperties(Map.of(\n-                COVERAGE_OUT, coverage.toString(),\n-                JCOV_TEMPLATE, test_dir.resolve(\"template.xml\").toString(),\n-                METHOD_FILTER, MainFilter.class.getName()));\n-        new Instrument().pluginClass(Plugin.class.getName())\n-                .instrument(new Util(test_dir).\n-                        copyBytecode(cls.getName()));\n-        return Coverage.read(coverage);\n-    }\n-    @Test\n-    public void instrument() throws IOException, InterruptedException {\n-        Coverage tmplt = instrument(UserCode.class);\n-        assertEquals(tmplt.coverage().size(), 0);\n-    }\n-    @Test(dependsOnMethods = \"instrument\")\n-    public void instrumentStatic() throws IOException, InterruptedException {\n-        Coverage tmplt = instrument(UserCodeStatic.class);\n-        Map<String, List<List<?>>> userCode =  tmplt.coverage().get(UserCodeStatic.class.getName().replace('.', '\/'));\n-        assertEquals(userCode.size(), 1);\n-        assertEquals(userCode.keySet().iterator().next(), \"main([Ljava\/lang\/String;)V\");\n-    }\n-    @Test(dependsOnMethods = \"instrumentStatic\")\n-    public void run() throws\n-            ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException,\n-            IOException, InstantiationException {\n-        Env.clear(JCOV_DATA_ENV_PREFIX);\n-        Env.setSystemProperties(Map.of(\n-                COVERAGE_IN, coverage.toString(),\n-                COVERAGE_OUT, coverage.toString(),\n-                SERIALIZER, StringArraySerializer.class.getName()));\n-        new Util(test_dir).runClass(UserCodeStatic.class, new String[] {\"one\", \"two\"}, new Saver());\n-        Coverage res = Coverage.read(coverage, Objects::toString);\n-        List<List<?>> method =\n-                res.get(UserCodeStatic.class.getName().replace('.', '\/'),\n-                        \"main([Ljava\/lang\/String;)V\");\n-        assertEquals(method.size(), 1);\n-        assertEquals(method.get(0).size(), 2);\n-        assertEquals(method.get(0).get(0), \"one\");\n-        assertEquals(method.get(0).get(1), \"two\");\n-    }\n-    @AfterClass\n-    public void tearDown() throws IOException {\n-        if(TestStatusListener.status) Util.rfrm(test_dir);\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/main\/MainTest.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.arguments.test;\n-\n-import openjdk.jcov.data.Instrument;\n-import openjdk.jcov.data.arguments.runtime.Collect;\n-import openjdk.jcov.data.arguments.runtime.Coverage;\n-import openjdk.jcov.data.arguments.instrument.Plugin;\n-import openjdk.jcov.data.arguments.runtime.Saver;\n-import openjdk.jcov.data.Env;\n-import openjdk.jcov.data.lib.TestStatusListener;\n-import openjdk.jcov.data.lib.Util;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Listeners;\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.List;\n-import java.util.Map;\n-\n-import static java.util.stream.Collectors.joining;\n-import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n-import static openjdk.jcov.data.Instrument.JCOV_TEMPLATE;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNotNull;\n-\n-@Listeners({openjdk.jcov.data.lib.TestStatusListener.class})\n-public class ArgumentsTest {\n-    Path test_dir;\n-    Path template;\n-    @BeforeClass\n-    public void clean() throws IOException {\n-        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n-        test_dir = data_dir.resolve(\"arguments_test\");\n-        Util.rfrm(test_dir);\n-        template = test_dir.resolve(\"template.lst\");\n-    }\n-    @Test\n-    public void instrument() throws IOException, InterruptedException {\n-        Env.clear(JCOV_DATA_ENV_PREFIX);\n-        Env.setSystemProperties(Map.of(\n-                Collect.COVERAGE_OUT, template.toString(),\n-                JCOV_TEMPLATE, test_dir.resolve(\"template.xml\").toString()));\n-        new Instrument().pluginClass(Plugin.class.getName()).\n-                instrument(new Util(test_dir).copyBytecode(UserCode.class.getName()));\n-        Coverage tmpl = Coverage.read(template);\n-        System.out.println(\"Data:\");\n-        tmpl.coverage().entrySet().forEach(e -> {\n-            System.out.println(e.getKey() + \"->\");\n-            e.getValue().entrySet().forEach(ee -> {\n-                System.out.println(\"  \" + ee.getKey());\n-                ee.getValue().forEach(l -> {\n-                    System.out.println(l.stream().map(Object::toString).collect(joining(\",\")));\n-                });\n-            });\n-        });\n-        assertNotNull(tmpl.coverage().get(UserCode.class.getName().replace('.', '\/')).\n-                get(\"method(IJFDZBLjava\/lang\/String;)V\"));\n-    }\n-\n-    @Test(dependsOnMethods = \"instrument\")\n-    public void run() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n-            IllegalAccessException, IOException, InstantiationException {\n-        Env.clear(JCOV_DATA_ENV_PREFIX);\n-        Env.setSystemProperties(Map.of(\n-                Collect.COVERAGE_OUT, template.toString()));\n-        new Util(test_dir).runClass(UserCode.class, new String[0], new Saver());\n-        Coverage coverage = Coverage.read(template);\n-        List<List<?>> calls = coverage.get(UserCode.class.getName().replace('.', '\/'),\n-                \"method(IJFDZBLjava\/lang\/String;)V\");\n-        assertEquals(calls.size(), 2);\n-        assertEquals(calls.get(0).get(6), \"6\");\n-        assertEquals(calls.get(1).get(0), \"7\");\n-    }\n-\n-    @AfterClass\n-    public void tearDown() throws IOException {\n-        if(TestStatusListener.status)\n-            Util.rfrm(test_dir);\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/test\/ArgumentsTest.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-package openjdk.jcov.data.lib;\n-\n-import org.testng.ITestContext;\n-import org.testng.ITestListener;\n-import org.testng.ITestResult;\n-\n-public class TestStatusListener implements ITestListener {\n-\n-    public static volatile boolean status = true;\n-\n-    @Override\n-    public void onTestStart(ITestResult result) { }\n-\n-    @Override\n-    public void onTestSuccess(ITestResult result) { }\n-\n-    @Override\n-    public void onTestFailure(ITestResult result) {\n-        status = false;\n-    }\n-\n-    @Override\n-    public void onTestSkipped(ITestResult result) { }\n-\n-    @Override\n-    public void onTestFailedButWithinSuccessPercentage(ITestResult result) { }\n-\n-    @Override\n-    public void onStart(ITestContext context) { status = true; }\n-\n-    @Override\n-    public void onFinish(ITestContext context) { }\n-}\n-\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/lib\/TestStatusListener.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,182 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package openjdk.jcov.data.lib;\n-\n-import com.sun.tdk.jcov.runtime.JCovSaver;\n-import openjdk.jcov.data.Env;\n-import openjdk.jcov.data.arguments.runtime.Collect;\n-import openjdk.jcov.data.arguments.runtime.Saver;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.UncheckedIOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.FileVisitor;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarOutputStream;\n-\n-import static openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER;\n-\n-public class Util {\n-    private final Path outputDir;\n-\n-    public Util(Path dir) {\n-        outputDir = dir;\n-    }\n-\n-    public List<Path> copyBytecode(String... classes) throws IOException {\n-        byte[] buf = new byte[1024];\n-        List<Path> result = new ArrayList<>();\n-        for(String c : classes) {\n-            String classFile = classFile(c);\n-            try(InputStream in = getClass().getClassLoader().getResourceAsStream(classFile)) {\n-                Path o = outputDir.resolve(classFile);\n-                result.add(o);\n-                if(!Files.exists(o.getParent())) Files.createDirectories(o.getParent());\n-                try(OutputStream out = Files.newOutputStream(o)) {\n-                    int read;\n-                    while((read = in.read(buf)) > 0)\n-                        out.write(buf, 0, read);\n-                }\n-            }\n-        };\n-        return result;\n-    }\n-\n-    public static Path copyJRE(Path src) throws IOException {\n-        Path dest = Files.createTempDirectory(\"JDK\");\n-        System.out.println(\"Copying a JDK from \" + src + \" to \" + dest);\n-        Files.walk(src).forEach(s -> {\n-            try {\n-                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        });\n-        return dest;\n-    }\n-\n-    public static Path createRtJar(String prefix, Class collect) throws IOException {\n-        Path dest = Files.createTempFile(prefix, \".jar\");\n-        System.out.println(prefix + \" jar: \" + dest);\n-        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n-            jar.putNextEntry(new JarEntry(collect.getName().replace(\".\", File.separator) + \".class\"));\n-            try (InputStream ci = collect.getClassLoader()\n-                    .getResourceAsStream(collect.getName().replace('.', '\/') + \".class\")) {\n-                byte[] buffer = new byte[1024];\n-                int read;\n-                while((read = ci.read(buffer)) > 0) {\n-                    jar.write(buffer, 0, read);\n-                }\n-            }\n-        }\n-        return dest;\n-    }\n-\n-    public static String classFile(String className) {\n-        return className.replace('.', '\/') + \".class\";\n-    }\n-    public Class runClass(Class className, String[] argv, JCovSaver saver)\n-            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n-        return runClass(className.getName(), argv, saver);\n-    }\n-    public Class runClass(String className, String[] argv, JCovSaver saver)\n-            throws ClassNotFoundException, NoSuchMethodException,\n-            InvocationTargetException, IllegalAccessException, InstantiationException {\n-        Collect.clearData();\n-        \/\/TODO an API is really needed for this kind of usage\n-        Collect.serializer(new Saver.NoRuntimeSerializer(Env.getSPIEnv(SERIALIZER, Objects::toString)));\n-        ClassLoader offOutputDir = new InstrumentedClassLoader();\n-        Class cls = offOutputDir.loadClass(className);\n-        Method m = cls.getMethod(\"main\", new String[0].getClass());\n-        m.invoke(null, (Object)argv);\n-        \/\/have to do this because normally it only works on system exit\n-        saver.saveResults();\n-        return cls;\n-    }\n-\n-    private class InstrumentedClassLoader extends ClassLoader {\n-        protected InstrumentedClassLoader() {\n-            super(Util.class.getClassLoader());\n-        }\n-\n-        @Override\n-        public Class<?> loadClass(String name) throws ClassNotFoundException {\n-            Path classFile = outputDir.resolve(classFile(name));\n-            if(Files.exists(classFile)) {\n-                byte[] buf = new byte[1024];\n-                try(InputStream in = Files.newInputStream(classFile)) {\n-                    try(ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n-                        int read;\n-                        while((read = in.read(buf)) > 0)\n-                            out.write(buf, 0, read);\n-                        return defineClass(name, out.toByteArray(), 0, out.size());\n-                    }\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-            return super.loadClass(name);\n-        }\n-    }\n-    public static void rfrm(Path jre) throws IOException {\n-        System.out.println(\"Removing \" + jre);\n-        if(Files.isRegularFile(jre))\n-            Files.deleteIfExists(jre);\n-        else\n-            Files.walkFileTree(jre, new FileVisitor<Path>() {\n-                @Override\n-                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-                    return FileVisitResult.CONTINUE;\n-                }\n-                @Override\n-                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                    Files.delete(file);\n-                    return FileVisitResult.CONTINUE;\n-                }\n-                @Override\n-                public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n-                    return FileVisitResult.CONTINUE;\n-                }\n-                @Override\n-                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n-                    Files.delete(dir);\n-                    return FileVisitResult.CONTINUE;\n-                }\n-            });\n-    }\n-}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/lib\/Util.java","additions":0,"deletions":182,"binary":false,"changes":182,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+import java.util.Collection;\n@@ -87,0 +88,1 @@\n+    public static final String JCOV_EXPORTS_FILE_NAME = \"META-INF\/JCOV.exports\";\n@@ -140,2 +142,0 @@\n-                        moduleInfo = mip.addExports(List.of(\"com\/sun\/tdk\/jcov\/runtime\"), moduleInfo, loader);\n-                        moduleInfo = mip.clearHashes(moduleInfo, loader);\n@@ -144,1 +144,19 @@\n-                        for (String resource : implantSource.resources()) {\n+                        Collection<String> resources = implantSource.resources();\n+                        List<String> javaBaseExports;\n+                        if (resources.contains(JCOV_EXPORTS_FILE_NAME)) {\n+                            javaBaseExports = new ArrayList<>();\n+                            try (BufferedReader exportsIn =\n+                                         new BufferedReader(new InputStreamReader(\n+                                                 implantSource.loader().getResourceAsStream(JCOV_EXPORTS_FILE_NAME)))) {\n+                                String line;\n+                                while ((line = exportsIn.readLine()) != null) {\n+                                    \/\/TODO allow qualified exports\n+                                    javaBaseExports.add(line.substring(0, line.indexOf(\"=\")));\n+                                }\n+                            }\n+                        } else {\n+                            javaBaseExports = List.of(\"com\/sun\/tdk\/jcov\/runtime\");\n+                        }\n+                        moduleInfo = mip.addExports(javaBaseExports, moduleInfo, loader);\n+                        moduleInfo = mip.clearHashes(moduleInfo, loader);\n+                        for (String resource : resources) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/JREInstr.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class ClassListSource implements Source {\n+    private final ClassLoader loader;\n+    private final Set<Class> classes;\n+\n+    public ClassListSource(ClassLoader loader, Set<Class> classes) {\n+        this.loader = loader;\n+        this.classes = classes;\n+    }\n+\n+    @Override\n+    public Collection<String> resources() throws Exception {\n+        return classes.stream().map(c -> c.getName().replace('.','\/') + \".class\")\n+                .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClassLoader loader() {\n+        return loader;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/plugin\/ClassListSource.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -43,0 +43,4 @@\n+    public PathSource(Path root) {\n+        this(ClassLoader.getSystemClassLoader(), root);\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/plugin\/PathSource.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n@@ -14,0 +38,1 @@\n+    exports com.sun.tdk.jcov.instrument.plugin;\n@@ -22,1 +47,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/classes\/module-info.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"}]}