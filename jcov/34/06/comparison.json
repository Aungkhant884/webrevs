{"files":[{"patch":"@@ -1,869 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov;\n-\n-import com.sun.tdk.jcov.constants.MiscConstants;\n-import com.sun.tdk.jcov.instrument.*;\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n-import com.sun.tdk.jcov.runtime.AgentSocketSaver;\n-import com.sun.tdk.jcov.runtime.Collect;\n-import com.sun.tdk.jcov.runtime.CollectDetect;\n-import com.sun.tdk.jcov.runtime.FileSaver;\n-import com.sun.tdk.jcov.runtime.JCovSaver;\n-import com.sun.tdk.jcov.runtime.PropertyFinder;\n-import com.sun.tdk.jcov.runtime.SaverDecorator;\n-import com.sun.tdk.jcov.tools.EnvHandler;\n-import com.sun.tdk.jcov.tools.JCovTool;\n-import com.sun.tdk.jcov.tools.OptionDescr;\n-import com.sun.tdk.jcov.util.Utils;\n-import java.io.*;\n-import java.lang.instrument.*;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.nio.charset.Charset;\n-import java.security.ProtectionDomain;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Locale;\n-import java.util.Set;\n-import java.util.Timer;\n-import java.util.TimerTask;\n-import java.util.logging.FileHandler;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * @author Dmitry Fazunenko\n- * @author Alexey Fedorchenko\n- *\/\n-public class Agent extends JCovTool {\n-\n-    private boolean detectInternal;\n-    private boolean classesReload;\n-    private boolean instrumentField;\n-    private boolean instrumentAbstract;\n-    private boolean instrumentNative;\n-    private boolean instrumentAnonymous = true;\n-    private boolean instrumentSynthetic = true;\n-    private String[] include;\n-    private String[] exclude;\n-    private String[] m_include;\n-    private String[] m_exclude;\n-    private String[] callerInclude;\n-    private String[] callerExclude;\n-    private String[] fm;\n-    private String[] saveBegin;\n-    private String[] saveEnd;\n-    private String template;\n-    private String filename;\n-    private String flushPath;\n-    private InstrumentationOptions.InstrumentationMode mode;\n-    private InstrumentationOptions.MERGE merge;\n-    private boolean grabberSaver = false;\n-\n-    static {\n-        Utils.initLogger();\n-        logger = Logger.getLogger(Agent.class.getName());\n-    }\n-    private final static Logger logger;\n-    private static ClassMorph classMorph;\n-    private String host;\n-    private int port;\n-    private static final Object LOCK = new Object();\n-\n-    private static class SynchronizedSaverDecorator implements SaverDecorator {\n-\n-        private JCovSaver wrap;\n-\n-        public SynchronizedSaverDecorator(JCovSaver wrap) {\n-            init(wrap);\n-        }\n-\n-        @Override\n-        public final void init(JCovSaver saver) {\n-            this.wrap = saver;\n-        }\n-\n-        public void saveResults() {\n-            synchronized (LOCK) {\n-                wrap.saveResults();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * ClassFileTransformer implementation. Gets classfile binary data from VM\n-     * and runs ClassMorph.morph method.\n-     *\/\n-    private static class Tr implements ClassFileTransformer {\n-\n-        \/**\n-         * Path to flush instrumented classfiles to. Null means that\n-         * instrumented classfiles should not be flushed.\n-         *\/\n-        private final String flushpath;\n-        \/**\n-         * Transformer name. Is not used.\n-         *\/\n-        private final String trname;\n-        \/**\n-         * Can turn off agent instrumentation\n-         *\/\n-        private boolean ignoreLoads = true;\n-\n-        \/**\n-         * Creates new Tr instance\n-         *\n-         * @param trname Transformer name. Is not used.\n-         * @param flushpath Path to flush instrumented classfiles to. Null means\n-         * that instrumented classfiles should not be flushed.\n-         *\/\n-        public Tr(String trname, String flushpath) {\n-            this.trname = trname;\n-            this.flushpath = flushpath;\n-        }\n-\n-        \/**\n-         * transform method implementation\n-         *\n-         * @param loader\n-         * @param className\n-         * @param classBeingRedefined\n-         * @param protectionDomain\n-         * @param classfileBuffer\n-         * @return instrumented classfile binary data (if ignoreLoads is not set\n-         * to true, classfileBuffer will be returned otherwise). If collect is\n-         * not enabled - null is returned.\n-         *\/\n-        public byte[] transform(ClassLoader loader,\n-                String className,\n-                Class<?> classBeingRedefined,\n-                ProtectionDomain protectionDomain,\n-                byte[] classfileBuffer) {\n-            synchronized (LOCK) {\n-                if (Collect.enabled == false) {\n-                    return null; \/\/ signals to the VM that no changes were done\n-                }\n-\n-                \/\/ no need to enter when Collect is disabled\n-                CollectDetect.enterInstrumentationCode(); \/\/ ensuring that instrumenting will not influence on coverage data\n-\n-                try {\n-                    if (ignoreLoads) {\n-                        logger.log(Level.INFO, \"Ignore for now {0}\", className);\n-                    } else {\n-                        logger.log(Level.INFO, \"Try to transform {0}\", className);\n-\n-                        byte[] newBuff = classMorph.morph(classfileBuffer, loader, flushpath);\n-                        return newBuff;\n-                    }\n-                } catch (Throwable e) {\n-                    logger.log(Level.SEVERE, \"Adaption failed for {0} with :{1}\", new Object[]{className, e});\n-                    e.printStackTrace();\n-                } finally {\n-                    CollectDetect.leaveInstrumentationCode(); \/\/ release instrumentation lock\n-                }\n-                return null;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Class for listening agent commands\n-     *\/\n-    private static class CommandThread extends Thread {\n-\n-        \/**\n-         * Agent commands\n-         *\/\n-        public static enum COMMAND {\n-\n-            SAVE {\n-                String cmd() {\n-                    return \"save\";\n-                }\n-            },\n-            SAVED {\n-                String cmd() {\n-                    return \"saved\";\n-                }\n-            },\n-            EXIT {\n-                String cmd() {\n-                    return \"exit\";\n-                }\n-            },\n-            EXIT_WITHOUT_SAVE {\n-                String cmd() {\n-                    return \"exitWithoutSave\".toLowerCase();\n-                }\n-            },\n-            AUTOSAVE_DISABLED {\n-                String cmd() {\n-                    return \"autosave disabled\";\n-                }\n-            };\n-\n-            abstract String cmd();\n-        }\n-        \/**\n-         * Port to listen incoming messages\n-         *\/\n-        private int port;\n-        \/**\n-         * Instrumentation params\n-         *\/\n-        private InstrumentationParams params;\n-\n-        \/**\n-         * Creates CommandThread instance\n-         *\n-         * @param port Port to listen incoming messages\n-         * @param params Instrumentation params\n-         *\/\n-        public CommandThread(int port, InstrumentationParams params) {\n-            this.port = port;\n-            this.params = params;\n-            setDaemon(true);\n-        }\n-\n-        @Override\n-        public void run() {\n-            while (true) {\n-                try {\n-                    ServerSocket sock = new ServerSocket(port);\n-                    Socket s = sock.accept();\n-\/\/                    System.out.println(\"Accepted\");\n-                    InputStream is = s.getInputStream();\n-                    byte[] buff = new byte[1024];\n-                    int l;\n-                    String rest = \"\";\n-                    while ((l = is.read(buff)) > 0) {\n-                        String msg = rest + new String(buff, 0, l, Charset.defaultCharset());\n-\/\/                        System.out.println(\"Message: \" + msg);\n-                        rest = performTask(msg, s);\n-                    }\n-                    sock.close();\n-                } catch (IOException ex) {\n-                    logger.log(Level.SEVERE, \"Network IOException\", ex);\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Parse and execute incoming message\n-         *\n-         * @param msg message\n-         * @param sock socket\n-         * @return exit code\n-         * @throws IOException\n-         *\/\n-        private String performTask(String msg, Socket sock) throws IOException {\n-            Pattern p = Pattern.compile(\"\\\\p{Space}*(\\\\p{Digit}+).*\");\n-            msg = msg.toLowerCase(Locale.getDefault());\n-            PrintStream ps = new PrintStream(sock.getOutputStream(), false, \"UTF-8\");\n-            while (msg.length() > 0) {\n-                msg = msg.trim();\n-                COMMAND cmd = nextCommand(msg);\n-                if (cmd == null) {\n-                    break;\n-                } else {\n-                    switch (cmd) {\n-                        case SAVE:\n-                            msg = msg.substring(cmd.cmd().length());\n-                            if (Collect.enabled) {\n-                                Collect.disable();\n-                                Collect.saveResults();\n-                                params.enable();\n-                            }\n-                            ps.print(COMMAND.SAVED.cmd());\n-                            ps.flush();\n-                            break;\n-                        case EXIT:\n-                            msg = msg.substring(cmd.cmd().length());\n-                            Matcher m = p.matcher(msg);\n-                            int exitCode = 0;\n-                            if (m.matches()) {\n-                                exitCode = Integer.parseInt(m.group(1));\n-                            }\n-                            System.exit(exitCode);\n-                            break;\n-                        case EXIT_WITHOUT_SAVE:\n-                            msg = msg.substring(cmd.cmd().length());\n-                            m = p.matcher(msg);\n-                            exitCode = 0;\n-                            if (m.matches()) {\n-                                exitCode = Integer.parseInt(m.group(1));\n-                            }\n-                            FileSaver.setDisableAutoSave(true);\n-                            ps.print(COMMAND.AUTOSAVE_DISABLED.cmd());\n-                            ps.flush();\n-                            System.exit(exitCode);\n-                            break;\n-                    }\n-                }\n-            }\n-\n-            return msg;\n-        }\n-\n-        \/**\n-         * Parse incomming message and return COMMAND value\n-         *\n-         * @param msg message to parse\n-         * @return associated COMMAND value\n-         *\/\n-        private COMMAND nextCommand(String msg) {\n-            String foundPref = \"\";\n-            COMMAND found = null;\n-\n-            for (COMMAND c : COMMAND.values()) {\n-                if (msg.startsWith(c.cmd()) && foundPref.length() < c.cmd().length()) {\n-                    found = c;\n-                    foundPref = c.cmd();\n-                }\n-            }\n-\n-            return found;\n-        }\n-    }\n-\n-    \/**\n-     * javaagent entry point\n-     *\n-     * @param agentArgs\n-     * @param instArg\n-     * @throws Exception\n-     *\/\n-    public static void premain(String agentArgs, Instrumentation instArg) {\n-\n-        \/\/ handling JCovTool\n-\n-        \/\/ This method manages CLI handling for Agent tool.\n-        \/\/ If any change is performed here - check JCovCMDTool CLI handling logic.\n-\n-        Agent tool = new Agent();\n-\n-        EnvHandler handler = tool.defineHandler();\n-\n-        try {\n-            \/\/ proccess cmd options\n-            if (agentArgs == null) {\n-                agentArgs = \"\";\n-            }\n-            handler.parseCLIArgs(EnvHandler.parseAgentString(agentArgs));\n-            tool.handleEnv(handler);\n-            if (handler.isSet(EnvHandler.PRINT_ENV)) {\n-                handler.printEnv();\n-            }\n-        } catch (EnvHandler.CLParsingException ex) {\n-            if (handler.isSet(EnvHandler.HELP)) {\n-                handler.usage();\n-                handler.getOut().println(\"\\n JCov Agent command line error: \" + ex.getMessage() + \"\\n\");\n-                System.exit(ERROR_CMDLINE_EXIT_CODE);\n-            }\n-\n-            if (handler.isSet(EnvHandler.HELP_VERBOSE)) {\n-                handler.usage(true);\n-                handler.getOut().println(\"\\n JCov Agent command line error: \" + ex.getMessage() + \"\\n\");\n-                System.exit(ERROR_CMDLINE_EXIT_CODE);\n-            }\n-\n-            handler.getOut().println(\" JCov Agent command line error: \" + ex.getMessage() + \"\\n\");\n-            handler.getOut().println(\"Use \\\"java -jar jcov.jar Agent -h\\\" for command-line help or \\\"java -jar jcov.jar Agent -hv\\\" for wider description\");\n-            System.exit(ERROR_CMDLINE_EXIT_CODE);\n-        } catch (EnvHandlingException ex) {\n-            handler.getOut().println(\"JCov Agent command line error: \" + ex.getMessage() + \"\\n\");\n-            handler.getOut().println(\"Use \\\"java -jar jcov.jar Agent -h\\\" for command-line help or \\\"java -jar jcov.jar Agent -hv\\\" for wider description\");\n-            if (handler.isSet(EnvHandler.PRINT_ENV)) {\n-                handler.printEnv();\n-            }\n-            System.exit(ERROR_CMDLINE_EXIT_CODE);\n-        } catch (Throwable ex) {\n-            handler.getOut().println(\"JCov Agent command line error: \" + ex.getMessage());\n-            System.exit(ERROR_CMDLINE_EXIT_CODE);\n-        }\n-        if (handler.isSet(EnvHandler.PRINT_ENV)) {\n-            handler.printEnv();\n-            System.exit(SUCCESS_EXIT_CODE);\n-        }\n-\n-        try {\n-            if (Utils.getJavaVersion() >= Utils.VER1_6) {\n-                tool.premainV50(agentArgs, instArg);\n-            } else {\n-                tool.premainV49(agentArgs, instArg);\n-            }\n-        } catch (Exception ex) {\n-            System.out.println(\"Agent execution error: \" + ex.getMessage());\n-            ex.printStackTrace();\n-            System.exit(ERROR_EXEC_EXIT_CODE);\n-        }\n-    }\n-\n-    \/**\n-     * premain chain for classfiles V50+\n-     *\n-     * @param agentArgs\n-     * @param inst\n-     * @throws Exception\n-     *\/\n-    public void premainV50(String agentArgs, Instrumentation inst) throws Exception {\n-        InstrumentationParams params =\n-                new InstrumentationParams(true, classesReload, true, instrumentNative, instrumentField,\n-                detectInternal, instrumentAbstract ? InstrumentationOptions.ABSTRACTMODE.DIRECT : InstrumentationOptions.ABSTRACTMODE.NONE,\n-                include, exclude, callerInclude, callerExclude, m_include, m_exclude, mode, saveBegin, saveEnd)\n-                .setInstrumentAnonymous(instrumentAnonymous)\n-                .setInstrumentSynthetic(instrumentSynthetic);\n-\n-        params.enable();\n-        CollectDetect.enterInstrumentationCode();\n-\n-        Tr transformer = new Tr(\"RetransformApp\", flushPath);\n-        inst.addTransformer(transformer, true);\n-        if (params.isInstrumentNative()) {\n-            inst.setNativeMethodPrefix(transformer, InstrumentationOptions.nativePrefix);\n-        }\n-\n-        DataRoot root = new DataRoot(agentArgs, params);\n-        classMorph = new ClassMorph(filename, root, params);\n-        Class[] classes = inst.getAllLoadedClasses();\n-        Set<Class> examinedClasses = new HashSet<Class>(Arrays.asList(classes));\n-        int keep = 0;\n-        for (Class c : classes) {\n-            if (inst.isModifiableClass(c)\n-                    && classMorph.shouldTransform(c.getName().replace('.', '\/'))\n-                    && !c.getName().replace('.', '\/').equals(\"jdk\/internal\/reflect\/Reflection\")\n-                    && !c.getName().replace('.', '\/').equals(\"sun\/reflect\/Reflection\")) {\n-                classes[keep++] = c;\n-            }\n-        }\n-        transformer.ignoreLoads = false;\n-        if (keep > 0) {\n-            classes = Utils.copyOf(classes, keep);\n-            logger.log(Level.INFO, \"About to retransform {0} classes {1}\", new Object[]{keep, classes[0]});\n-            try {\n-                inst.retransformClasses(classes);\n-            } catch (UnmodifiableClassException e) {\n-                System.err.println(\"Should not happen: \" + e);\n-                e.printStackTrace(System.err);\n-            } catch (Throwable e) {\n-                System.err.println(\"During retransform: \" + e);\n-                e.printStackTrace(System.err);\n-            }\n-        }\n-        logger.log(Level.INFO, \"Retransformed {0} classes\", keep);\n-        Class[] allClasses = inst.getAllLoadedClasses();\n-        keep = 0;\n-        for (Class c : allClasses) {\n-            if (!examinedClasses.contains(c)\n-                    && inst.isModifiableClass(c)\n-                    && classMorph.shouldTransform(c.getName().replace('.', '\/'))) {\n-                allClasses[keep++] = c;\n-            }\n-        }\n-        if (keep > 0) {\n-            logger.log(Level.INFO, \"New not transformed: {0} classes {1}\", new Object[]{keep, allClasses[0]});\n-            classes = Utils.copyOf(classes, keep);\n-            try {\n-                inst.retransformClasses(classes);\n-            } catch (UnmodifiableClassException e) {\n-                logger.log(Level.SEVERE, \"retransformClasses: Should not happen: \", e);\n-                \/\/log.log(.printStackTrace(System.err);\n-            } catch (Throwable e) {\n-                logger.log(Level.SEVERE, \"Error during retransform: \", e);\n-            }\n-        }\n-\n-        if (!grabberSaver) {\n-            \/\/ File saver should perform full merge here, not only insert new classes.\n-            JCovSaver saver = FileSaver.getFileSaver(root, filename, template, merge, true);\n-            loadFileSaverClasses();\n-            Collect.setSaver(Collect.decorateSaver(new SynchronizedSaverDecorator(saver)));\n-        } else {\n-            AgentSocketSaver saver = new AgentSocketSaver(root, filename, host, port);\n-            Collect.setSaver(Collect.decorateSaver(new SynchronizedSaverDecorator(saver)));\n-        }\n-        CollectDetect.leaveInstrumentationCode();\n-        PropertyFinder.addAutoShutdownSave();\n-\n-    }\n-\n-    private void loadFileSaverClasses() throws IOException{\n-        File file = new File(filename + \"_load\");\n-        new FileOutputStream(file).close();\n-        file.delete();\n-    }\n-\n-    \/**\n-     * premain chain for classfiles V49+\n-     *\n-     * @param agentArgs\n-     * @param inst\n-     * @throws Exception\n-     *\/\n-    public void premainV49(String agentArgs, Instrumentation inst) throws Exception {\n-        InstrumentationParams params =\n-                new InstrumentationParams(true, instrumentNative, instrumentField,\n-                detectInternal, instrumentAbstract ? InstrumentationOptions.ABSTRACTMODE.DIRECT : InstrumentationOptions.ABSTRACTMODE.NONE,\n-                include, exclude, callerInclude, callerExclude, mode, saveBegin, saveEnd)\n-                .setInstrumentAnonymous(instrumentAnonymous)\n-                .setInstrumentSynthetic(instrumentSynthetic);\n-\n-        params.enable();\n-        CollectDetect.enterInstrumentationCode();\n-        Tr transformer = new Tr(\"RetransformApp\", flushPath);\n-        inst.addTransformer(transformer);\n-        \/* if (Options.isInstrumentNative()) {\n-         inst.setNativeMethodPrefix(transformer, Options.nativePrefix);\n-         }\n-         *\/\n-        DataRoot root = new DataRoot(agentArgs, params);\n-        classMorph = new ClassMorph(filename, root, params);\n-        Class[] classes = inst.getAllLoadedClasses();\n-        Set<Class> examinedClasses = new HashSet<Class>(Arrays.asList(classes));\n-        int keep = 0;\n-        for (Class c : classes) {\n-            if (\/*inst.isModifiableClass(c) &&*\/classMorph.shouldTransform(c.getName().replace('.', '\/'))) {\n-                classes[keep++] = c;\n-            }\n-        }\n-        if (keep > 0) {\n-            classes = Utils.copyOf(classes, keep);\n-            logger.log(Level.INFO, \"About to retransform {0} classes {1}\", new Object[]{keep, classes[0]});\n-        }\n-        logger.log(Level.INFO, \"Retransformed {0} classes\", keep);\n-        transformer.ignoreLoads = false;\n-        Class[] allClasses = inst.getAllLoadedClasses();\n-        keep = 0;\n-        for (Class c : allClasses) {\n-            if (!examinedClasses.contains(c)\n-                    && \/\/  inst.isModifiableClass(c) &&\n-                    classMorph.shouldTransform(c.getName().replace('.', '\/'))) {\n-                allClasses[keep++] = c;\n-            }\n-        }\n-        if (keep > 0) {\n-            classes = Utils.copyOf(allClasses, keep);\n-        }\n-\n-        if (!grabberSaver) {\n-            \/\/ File saver should perform full merge here, not only insert new classes.\n-            JCovSaver saver = FileSaver.getFileSaver(root, filename, template, merge, true);\n-            loadFileSaverClasses();\n-            Collect.setSaver(Collect.decorateSaver(new SynchronizedSaverDecorator(saver)));\n-        } else {\n-            AgentSocketSaver saver = new AgentSocketSaver(root, filename, host, port);\n-            Collect.setSaver(Collect.decorateSaver(new SynchronizedSaverDecorator(saver)));\n-        }\n-        CollectDetect.leaveInstrumentationCode();\n-        PropertyFinder.addAutoShutdownSave();\n-    }\n-\n-    public String usageString() {\n-        return \"java -javaagent:jcov.jar=[=option=value[,option=value]*] ...\";\n-    }\n-\n-    public String exampleString() {\n-        return \"java -javaagent:jcov.jar=include=java\\\\.lang\\\\.String,native=on,type=branch,abstract=off -jar MyApp.jar\";\n-    }\n-\n-    public String getDescr() {\n-        return \"print help on usage jcov in dynamic mode\";\n-    }\n-\n-    @Override\n-    public boolean isMainClassProvided() {\n-        return false;\n-    }\n-\n-\/\/\/\/\/\/\/\/\/ JCovTool implementation \/\/\/\/\/\/\/\/\/\n-    @Override\n-    public EnvHandler defineHandler() {\n-        return new EnvHandler(new OptionDescr[]{\n-                    DSC_OUTPUT,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MERGE,\n-                    \/\/ Verbosity\n-                    DSC_VERBOSE,\n-                    DSC_TIMEOUT,\n-                    DSC_PORT,\n-                    \/\/ Instrumentation parameters.\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TEMPLATE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TYPE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ABSTRACT,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_NATIVE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FIELD,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SYNTHETIC,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ANONYM,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CLASSESRELOAD,\n-                    \/\/ Data save points\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SAVE_BEGIN,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SAVE_AT_END,\n-                    ClassMorph.DSC_FLUSH_CLASSES,\n-                    DSC_GRABBER,\n-                    DSC_PORT_GRABBER,\n-                    DSC_HOST_GRABBER,\n-                    DSC_LOG\n-                }, this);\n-    }\n-\n-    @Override\n-    public int handleEnv(EnvHandler opts) throws EnvHandlingException {\n-        String internal = \"default\";\n-        if (internal.equals(\"detect\")) {\n-            detectInternal = true;\n-        } else if (internal.equals(\"show\")) {\n-            detectInternal = true;\n-        } else if (internal.equals(\"include\")) {\n-            detectInternal = false;\n-        } else if (internal.equals(\"default\")) {\n-            detectInternal = true;\n-        } else {\n-            throw new Error(\"Parameter error\");\n-        }\n-\n-        mode = InstrumentationOptions.InstrumentationMode.fromString(opts.getValue(InstrumentationOptions.DSC_TYPE));\n-        if (opts.isSet(InstrumentationOptions.DSC_TEMPLATE)) {\n-            template = opts.getValue(InstrumentationOptions.DSC_TEMPLATE);\n-        }\n-\n-        include = InstrumentationOptions.handleInclude(opts);\n-        exclude = InstrumentationOptions.handleExclude(opts);\n-\n-        m_include = InstrumentationOptions.handleMInclude(opts);\n-        m_exclude = InstrumentationOptions.handleMExclude(opts);\n-\n-        fm = InstrumentationOptions.handleFM(opts);\n-\n-        callerInclude = opts.getValues(InstrumentationOptions.DSC_CALLER_INCLUDE);\n-\/\/        System.out.println(\"Setup callerInclude \" + Arrays.toString(callerInclude));\n-        callerExclude = opts.getValues(InstrumentationOptions.DSC_CALLER_EXCLUDE);\n-\/\/        System.out.println(\"Setup callerExclude \" + Arrays.toString(callerExclude));\n-\n-        String abstractValue = opts.getValue(InstrumentationOptions.DSC_ABSTRACT);\n-        if (abstractValue.equals(\"off\")) {\n-            instrumentAbstract = false;\n-        } else if (abstractValue.equals(\"on\")) {\n-            instrumentAbstract = true;\n-        } else {\n-            \/\/ will not happen - checking inside EnvHandler\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_ABSTRACT.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + abstractValue + \"'\");\n-        }\n-\n-        String classesReloadValue = opts.getValue(InstrumentationOptions.DSC_CLASSESRELOAD);\n-        if (classesReloadValue.equals(\"on\")) {\n-            classesReload = true;\n-        } else {\n-            classesReload = false;\n-        }\n-\n-        String nativeValue = opts.getValue(InstrumentationOptions.DSC_NATIVE);\n-        if (nativeValue.equals(\"on\")) {\n-            instrumentNative = true;\n-        } else if (nativeValue.equals(\"off\")) {\n-            instrumentNative = false;\n-        } else {\n-            \/\/ will not happen - checking inside EnvHandler\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_NATIVE.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + nativeValue + \"'\");\n-        }\n-\n-        String fieldValue = opts.getValue(InstrumentationOptions.DSC_FIELD);\n-        if (fieldValue.equals(\"on\")) {\n-            instrumentField = true;\n-        } else if (fieldValue.equals(\"off\")) {\n-            instrumentField = false;\n-        } else {\n-            \/\/ will not happen - checking inside EnvHandler\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_FIELD.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + fieldValue + \"'\");\n-        }\n-\n-        String anonym = opts.getValue(InstrumentationOptions.DSC_ANONYM);\n-        if (anonym.equals(\"on\")) {\n-            instrumentAnonymous = true;\n-        } else { \/\/ off\n-            instrumentAnonymous = false;\n-        }\n-\n-        String synthetic = opts.getValue(InstrumentationOptions.DSC_SYNTHETIC);\n-        if (synthetic.equals(\"on\")) {\n-            instrumentSynthetic = true;\n-        } else { \/\/ off\n-            instrumentSynthetic = false;\n-        }\n-\n-        String mergeValue = opts.getValue(InstrumentationOptions.DSC_MERGE);\n-        if (mergeValue.equals(\"merge\")) {\n-            merge = InstrumentationOptions.MERGE.MERGE;\n-        } else if (mergeValue.equals(\"scale\")) {\n-            merge = InstrumentationOptions.MERGE.SCALE;\n-        } else if (mergeValue.equals(\"overwrite\")) {\n-            merge = InstrumentationOptions.MERGE.OVERWRITE;\n-        } else if (mergeValue.equals(\"gensuff\")) {\n-            merge = InstrumentationOptions.MERGE.GEN_SUFF;\n-        } else {\n-            \/\/ will never happen as this is checked in EnvHandler\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_MERGE.name + \"' parameter value error: expected 'merge', 'scale', 'overwrite' or 'gensuff'; found: '\" + mergeValue + \"'\");\n-        }\n-\n-        saveBegin = opts.getValues(InstrumentationOptions.DSC_SAVE_BEGIN);\n-        saveEnd = opts.getValues(InstrumentationOptions.DSC_SAVE_AT_END);\n-\n-        flushPath = opts.getValue(ClassMorph.DSC_FLUSH_CLASSES);\n-        if (\"none\".equals(flushPath)) {\n-            flushPath = null;\n-        }\n-\n-        String logfile = opts.getValue(EnvHandler.LOGFILE);\n-        if (opts.isSet(DSC_LOG) || logfile != null) {\n-            if (logfile == null) {\n-                logfile = \"jcov.log\";\n-            }\n-            try {\n-                Utils.setLoggerHandler(new FileHandler(logfile));\n-            } catch (Exception ex) {\n-                throw new EnvHandlingException(\"Can't open file '\" + logfile + \"' for writing the log\", ex);\n-            }\n-            if (opts.isSet(EnvHandler.LOGLEVEL)) {\n-                Utils.setLoggingLevel(opts.getValue(EnvHandler.LOGLEVEL));\n-            } else if (opts.isSet(DSC_VERBOSE)) {\n-                int verbositylevel = Utils.checkedToInt(opts.getValue(DSC_VERBOSE), \"verbosity level\", Utils.CheckOptions.INT_NONNEGATIVE);\n-                switch (verbositylevel) {\n-                    case 0:\n-                        logger.setLevel(Level.SEVERE);\n-                        Utils.setLoggingLevel(Level.SEVERE);\n-                        break;\n-                    case 1:\n-                        logger.setLevel(Level.CONFIG);\n-                        Utils.setLoggingLevel(Level.CONFIG);\n-                        break;\n-                    case 2:\n-                        logger.setLevel(Level.INFO);\n-                        Utils.setLoggingLevel(Level.INFO);\n-                        break;\n-                    case 3:\n-                        logger.setLevel(Level.ALL);\n-                        Utils.setLoggingLevel(Level.ALL);\n-                        break;\n-                    default:\n-                        throw new EnvHandlingException(\"Incorrect verbosity level (\" + opts.getValue(DSC_VERBOSE) + \") - should be 0..3\");\n-                }\n-            }\n-        } else {\n-            Utils.setLoggingLevel(Level.OFF);\n-        }\n-\n-        if (opts.isSet(DSC_TIMEOUT)) {\n-            long timeout = Utils.checkedToInt(opts.getValue(DSC_TIMEOUT), \"timeout value\");\n-            if (timeout > 0) {\n-                Timer timer = new Timer(true);\n-                timer.schedule(new TimerTask() {\n-                    @Override\n-                    public void run() {\n-                        logger.log(Level.INFO, \"Agent has been timed out.\");\n-                        if (Collect.enabled) {\n-                            Collect.disable();\n-                            Collect.saveResults();\n-                        }\n-                        Runtime.getRuntime().halt(0);\n-                    }\n-                }, timeout);\n-            }\n-        }\n-\n-        grabberSaver = opts.isSet(DSC_GRABBER);\n-        if (grabberSaver) {\n-            host = opts.getValue(DSC_HOST_GRABBER);\n-            Utils.checkHostCanBeNull(host, \"grabber host\");\n-\n-            this.port = Utils.checkedToInt(opts.getValue(DSC_PORT_GRABBER), \"grabber port number\", Utils.CheckOptions.INT_POSITIVE);\n-        }\n-\n-        filename = opts.getValue(DSC_OUTPUT);\n-        if (!grabberSaver) {\n-            Utils.checkFileNotNull(filename, \"output filename\", Utils.CheckOptions.FILE_NOTISDIR, Utils.CheckOptions.FILE_PARENTEXISTS);\n-        }\n-\n-        if (opts.isSet(DSC_PORT)) {\n-            CommandThread cmdThread = new CommandThread(Utils.checkedToInt(opts.getValue(DSC_PORT), \"command listener port number\", Utils.CheckOptions.INT_POSITIVE),\n-                    new InstrumentationParams(true, instrumentNative, instrumentField, detectInternal,\n-                    instrumentAbstract ? InstrumentationOptions.ABSTRACTMODE.DIRECT : InstrumentationOptions.ABSTRACTMODE.NONE,\n-                    include, exclude, callerInclude, callerExclude, mode, saveBegin, saveEnd)\n-                    .setInstrumentAnonymous(instrumentAnonymous)\n-                    .setInstrumentSynthetic(instrumentSynthetic));\n-            cmdThread.start();\n-        }\n-\n-        return SUCCESS_EXIT_CODE;\n-    }\n-    public static final OptionDescr DSC_OUTPUT =\n-            new OptionDescr(\"file\", new String[]{\"url\", \"o\"}, \"Output path definition.\",\n-            OptionDescr.VAL_SINGLE, \"Specifies output data file. \\n\"\n-            + \"If specified file already exists, collected data will be merged with data from file\",\n-            \"result.xml\");\n-    public final static OptionDescr DSC_VERBOSE =\n-            new OptionDescr(\"verbose\", \"Verbosity level.\",\n-            new String[][]{\n-                {\"0\", \"minimal, only fatal failure diagnostic is printed\"},\n-                {\"1\", \"moderate, non-fatal errors are included in log\"},\n-                {\"2\", \"high, all warnings are included in log\"},\n-                {\"3\", \"highest, all messages are included in log\"}\n-            },\n-            \"Set verbosity level.\", \"0\");\n-    public static final OptionDescr DSC_TIMEOUT =\n-            new OptionDescr(\"timeout\", \"Agent process timeout.\",\n-            OptionDescr.VAL_SINGLE, \"Specifies timeout for agent process in milliseconds.\\n\"\n-            + \"0 means there is no timeout specified. Default is 0.\\n\",\n-            \"0\");\n-    \/\/ port now can be set only as \"agent.port\" via VM properties and env variables. \"Port\" is used only for grabber and socket saver.\n-    public static final OptionDescr DSC_PORT = new OptionDescr(\"agent.port\", new String[]{\"portcl\"}, \"Agent command listening port\",\n-            OptionDescr.VAL_SINGLE, \"Specifies port number to listen for driving commands.\\n\"\n-            + \"Commands are executed sequentially, some may send messages in response. \"\n-            + \"Valid commands to send are: \\n\"\n-            + \"   \\\"save\\\" - to save already collected data. It will respond with \\\"saved\\\" message\\n\"\n-            + \"   \\\"exit\\\" - to perform System.exit() immediately. Exit code number may be sent with this command.\\n\"\n-            + \"              It's chars should follow \\\"exit\\\"\");\n-    public static final OptionDescr DSC_PORT_GRABBER = new OptionDescr(\"port\", new String[]{\"grabberport\"}, \"\",\n-            OptionDescr.VAL_SINGLE, \"Specifies port number to send data to the grabber\", MiscConstants.JcovPortNumber + \"\");\n-    public static final OptionDescr DSC_HOST_GRABBER = new OptionDescr(\"host\", new String[]{\"grabberhost\"}, \"\",\n-            OptionDescr.VAL_SINGLE, \"Specifies host name to send data to the grabber\", \"localhost\");\n-    public final static OptionDescr DSC_LOG =\n-            new OptionDescr(\"log\", \"logging\", OptionDescr.VAL_NONE, \"Turns on JCov's agent logging.\\n\"\n-            + \"Log records saved in jcov.log file\");\n-    public final static OptionDescr DSC_GRABBER =\n-            new OptionDescr(\"grabber\", \"use grabber saver\", OptionDescr.VAL_NONE, \"Use grabber saver instead of file saver. jcov.port \"\n-            + \"and jcov.host VM properties could be used to control the saver as well as JCOV_PORT and JCOV_HOST env variable\");\n-}\n\\ No newline at end of file\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Agent.java","additions":0,"deletions":869,"binary":false,"changes":869,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n@@ -37,0 +36,2 @@\n+\n+import java.beans.EventHandler;\n@@ -84,0 +85,1 @@\n+    private EnvHandler envHandler;\n@@ -99,0 +101,1 @@\n+            grabber.handleEnv(envHandler);\n@@ -259,1 +262,2 @@\n-        grabber.handleEnv(envHandler);\n+\/\/        grabber.handleEnv(envHandler);\n+        this.envHandler = envHandler;\n@@ -272,1 +276,1 @@\n-            Utils.checkFileNotNull(template, \"template file\", Utils.CheckOptions.FILE_CANREAD, Utils.CheckOptions.FILE_ISFILE, Utils.CheckOptions.FILE_EXISTS);\n+            Utils.checkFileNotNull(template, \"template file\", Utils.CheckOptions.FILE_PARENTEXISTS);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Exec.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n@@ -29,2 +28,0 @@\n-import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n@@ -32,1 +29,1 @@\n-import com.sun.tdk.jcov.runtime.FileSaver;\n+import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n@@ -39,2 +36,0 @@\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n@@ -42,1 +37,0 @@\n-import java.io.UncheckedIOException;\n@@ -46,2 +40,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -51,0 +43,1 @@\n+import java.util.stream.Stream;\n@@ -53,0 +46,1 @@\n+import static com.sun.tdk.jcov.instrument.InstrumentationPlugin.TEMPLATE_ARTIFACT;\n@@ -92,3 +86,1 @@\n-    private AbstractUniversalInstrumenter instrumenter;\n-    private ClassMorph morph;\n-    private ClassLoader cl = null;\n+    private ClassLoader cl = ClassLoader.getSystemClassLoader();\n@@ -96,0 +88,1 @@\n+    \/\/TODO do need both?\n@@ -104,6 +97,0 @@\n-    private boolean needToFixJavaBase = false;\n-\n-    public void fixJavaBase() {\n-        needToFixJavaBase = true;\n-    }\n-\n@@ -129,1 +116,1 @@\n-    public void instrumentAll(File[] files, File outDir, String includeRTJar) throws IOException {\n+    public void instrumentAll(File[] files, File outDir, String includeRTJar) throws Exception {\n@@ -131,1 +118,1 @@\n-        instrumenter.finishWork();\n+\/\/        instrumenter.finishWork();\n@@ -142,3 +129,1 @@\n-     * @see\n-     * #setInstrumenter(com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter)\n-     * @see #setDefaultInstrumenter()\n+     * @see #setup()\n@@ -146,1 +131,1 @@\n-    public void instrumentAll(File[] files, File outDir) throws IOException {\n+    public void instrumentAll(File[] files, File outDir) throws Exception {\n@@ -160,3 +145,1 @@\n-     * @see\n-     * #setInstrumenter(com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter)\n-     * @see #setDefaultInstrumenter()\n+     * @see #setup()\n@@ -165,3 +148,3 @@\n-    public void instrumentFile(File file, File outDir, String includeRTJar) throws IOException {\n-        setDefaultInstrumenter();\n-        instrumenter.instrument(file, outDir, includeRTJar, recurse);\n+    public void instrumentFile(File file, File outDir, String includeRTJar) throws Exception {\n+        instrumentFiles(new String[] {file.getAbsolutePath()}, outDir, includeRTJar);\n+        \/\/instrumenter.instrument(file, outDir, includeRTJar, recurse);\n@@ -180,3 +163,1 @@\n-     * @see\n-     * #setInstrumenter(com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter)\n-     * @see #setDefaultInstrumenter()\n+     * @see #setup()\n@@ -185,1 +166,1 @@\n-    public void instrumentFile(String file, File outDir, String includeRTJar) throws IOException {\n+    public void instrumentFile(String file, File outDir, String includeRTJar) throws Exception {\n@@ -189,26 +170,3 @@\n-    public void instrumentFile(String file, File outDir, String includeRTJar, String moduleName) throws IOException {\n-        if (morph != null){\n-            morph.setCurrentModuleName(moduleName);\n-            if(needToFixJavaBase && \"java.base\".equals(moduleName)) {\n-                File moduleInfo = new File(file + File.separator +  \"module-info.class\");\n-                if(!moduleInfo.exists()) throw new IllegalStateException(moduleInfo + \" does not exist!\");\n-                try(FileInputStream fi = new FileInputStream(moduleInfo)) {\n-                    byte[] noHashes = morph.clearHashes(fi.readAllBytes(), cl);\n-                    List<String> packages = new ArrayList<>();\n-                    packages.add(\"com\/sun\/tdk\/jcov\/runtime\");\n-\/\/                    if(plugin != null) {\n-\/\/                        String pluginRuntimePackage = plugin.collectorPackage();\n-\/\/                        if (pluginRuntimePackage != null) {\n-\/\/                            pluginRuntimePackage = pluginRuntimePackage.replace('.', '\/');\n-\/\/                            packages.add(pluginRuntimePackage);\n-\/\/                        }\n-\/\/                    }\n-                    byte[] withExports = morph.addExports(noHashes, packages, cl);\n-                    try (FileOutputStream fo = new FileOutputStream(((outDir == null) ? file : outDir) +\n-                            File.separator +  \"module-info.class\")) {\n-                        fo.write(withExports);\n-                    }\n-                }\n-            }\n-            instrumentFile(new File(file), outDir, includeRTJar);\n-        }\n+    @Deprecated\n+    public void instrumentFile(String file, File outDir, String includeRTJar, String moduleName) throws Exception {\n+        instrumentFiles(new String[] {file}, outDir, includeRTJar);\n@@ -227,5 +185,3 @@\n-    public void instrumentFiles(File[] files, File outDir, String implantRT) throws IOException {\n-        setDefaultInstrumenter();\n-        for (File file : files) {\n-            instrumenter.instrument(file, outDir, implantRT, recurse);\n-        }\n+    public void instrumentFiles(File[] files, File outDir, String implantRT) throws Exception {\n+        instrumentFiles(Stream.of(files).map(File::toString).collect(Collectors.toList()).toArray(new String[0]),\n+                outDir, implantRT);\n@@ -245,33 +201,6 @@\n-        \/\/TODO rename\n-        setDefaultInstrumenter();\n-        for (String file : files) {\n-            Path in = Path.of(file);\n-            Path out = (outDir != null) ? outDir.toPath() : in;\n-            List<String> classes = Files.find(in, Integer.MAX_VALUE,\n-                            (f, a) -> f.getFileName().toString().endsWith(\".class\"))\n-                    .map(f -> in.relativize(f))\n-                    .map(Path::toString)\n-                    .map(s -> s.substring(0, s.length() - \".class\".length()))\n-                    .collect(Collectors.toList());\n-            params.isIncluded(\"UserCode\");\n-            plugin.instrument(classes, f -> {\n-\/\/            params.filter(plugin).instrument(classes, f -> {\n-                try {\n-                    return Files.readAllBytes(in.resolve(f + \".class\"));\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-            }, (c, d) -> {\n-                try {\n-                    Files.write(out.resolve(c + \".class\"), d);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-            }, params);\n-        }\n-    }\n-\n-    public void instrumentTests(String[] files, File outDir, String implantRT) throws IOException {\n-\n-        if (gennative || genAbstract) {\n-            morph.fillIntrMethodsIDs(morph.getRoot());\n+        setup();\n+        InstrumentationPlugin aPlugin = plugin;\n+        InstrumentationPlugin.Source source;\n+        if (implantRT != null) {\n+            source = new InstrumentationPlugin.PathSource(ClassLoader.getSystemClassLoader(), Path.of(implantRT));\n+            aPlugin = new InstrumentationPlugin.ImplantingPlugin(plugin, source);\n@@ -279,0 +208,1 @@\n+        aPlugin = new InstrumentationPlugin.FilteringPlugin(aPlugin, InstrumentationPlugin.classNameFilter(params));\n@@ -280,1 +210,2 @@\n-        setDefaultInstrumenter();\n+        InstrumentationPlugin.Instrumentation fi =\n+                new InstrumentationPlugin.Instrumentation(aPlugin);\n@@ -282,1 +213,19 @@\n-            instrumenter.instrument(new File(file), outDir, implantRT, recurse);\n+            InstrumentationPlugin.PathSource in;\n+\/\/            FileSystem outFS = null;\n+            Path inPath = Path.of(file);\n+            if (Files.isDirectory(inPath) || file.endsWith(\".jar\") || file.endsWith(\".jmod\")) {\n+                in = new InstrumentationPlugin.PathSource(cl, inPath);\n+            } else if (Files.isRegularFile(inPath) && file.endsWith(\".class\")) {\n+                \/\/TODO implement by directly calling the plugin\n+                \/\/TODO deprecate in documentation: instead of providing specific files, ask the user to provide\n+                \/\/a class hierarchy root and filters\n+                throw new RuntimeException();\n+            } else throw new IllegalStateException(\"Unknown input kind: \" + file);\n+            InstrumentationPlugin.Destination out;\n+            out = getDestination(outDir, inPath);\n+            try (in) {\n+                fi.instrument(in, out, params);\n+            } finally {\n+                in.close();\n+                out.close();\n+            }\n@@ -286,0 +235,27 @@\n+    protected InstrumentationPlugin.Destination getDestination(File outDir, Path inPath) throws IOException {\n+        InstrumentationPlugin.Destination out;\n+        Path outPath = (outDir != null) ? outDir.toPath().resolve(inPath.getFileName()) : inPath;\n+        if (Files.isDirectory(outPath) ||\n+                outPath.toString().endsWith(\".jar\") ||\n+                outPath.toString().endsWith(\".jmod\")) {\n+            out = new InstrumentationPlugin.PathDestination(outPath);\n+        } else if (Files.isRegularFile(outPath) && outPath.toString().endsWith(\".class\")) {\n+            \/\/TODO as above\n+            throw new RuntimeException();\n+        } else throw new IllegalStateException(\"Unknown output kind: \" + inPath);\n+        return out;\n+    }\n+\n+\/\/    See comments in JREInstr.handleEnv(EventHandler)\n+\/\/    public void instrumentTests(String[] files, File outDir, String implantRT) throws IOException {\n+\/\/\n+\/\/        if (gennative || genAbstract) {\n+\/\/            morph.fillIntrMethodsIDs(morph.getRoot());\n+\/\/        }\n+\/\/\n+\/\/        setup();\n+\/\/        for (String file : files) {\n+\/\/            instrumenter.instrument(new File(file), outDir, implantRT, recurse);\n+\/\/        }\n+\/\/    }\n+\n@@ -292,1 +268,1 @@\n-        setDefaultInstrumenter();\n+        setup();\n@@ -298,1 +274,1 @@\n-    private void setDefaultInstrumenter() {\n+    private void setup() {\n@@ -323,37 +299,0 @@\n-        if (morph == null) {\n-            if (subsequentInstr) {\n-                morph = new ClassMorph(params, template);\n-            } else {\n-                morph = new ClassMorph(params, null);\n-            }\n-        }\n-        if (instrumenter == null) {\n-            instrumenter = new AbstractUniversalInstrumenter(true) {\n-                protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n-                    return morph.morph(classData, cl, flushPath);\n-                }\n-\n-                public void finishWork() {\n-                    if (subsequentInstr) {\n-                        morph.saveData(MERGE.MERGE); \/\/ template should be initialized\n-                    } else {\n-                        morph.saveData(template, null, MERGE.OVERWRITE); \/\/ template should be initialized\n-                    }\n-                }\n-\n-                 public void processClassFileInModules(Path filePath, File outDir){\n-                    if (morph != null){\n-                        if (filePath != null){\n-                            String mpath = filePath.toAbsolutePath().toString();\n-                            mpath = mpath.substring(\"\/modules\/\".length());\n-                            if (mpath.contains(\"\/\")){\n-                                String module_name = mpath.substring(0, mpath.indexOf(\"\/\"));\n-                                morph.setCurrentModuleName(module_name);\n-                            }\n-                        }\n-                        super.processClassFileInModules(filePath, outDir);\n-                    }\n-                }\n-            };\n-            instrumenter.setParams(params);\n-        }\n@@ -362,9 +301,0 @@\n-    \/**\n-     * Set instrumenter\n-     *\n-     * @param instrumenter instrumenter used to instrument data\n-     *\/\n-\/\/    public void setInstrumenter(AbstractUniversalInstrumenter instrumenter) {\n-\/\/        this.instrumenter = instrumenter;\n-\/\/    }\n-\n@@ -377,5 +307,1 @@\n-\/\/        if (instrumenter != null) {\n-\/\/            instrumenter.finishWork();\n-            \/\/ destroy instrumenter & morph?\n-\/\/        }\n-\/\/        if(plugin != null) plugin.instrumentationComplete();\n+        plugin.complete().get(TEMPLATE_ARTIFACT).accept(Files.newOutputStream(Path.of(template)));\n@@ -391,15 +317,2 @@\n-\/\/        if (instrumenter != null) {\n-\/\/            if (subsequentInstr) {\n-\/\/                morph.saveData(outTemplate, MERGE.MERGE); \/\/ template should be initialized\n-\/\/            } else {\n-\/\/                morph.saveData(outTemplate, null, MERGE.OVERWRITE); \/\/ template should be initialized\n-\/\/            }\n-\/\/        }\n-\/\/        if(plugin != null) plugin.instrumentationComplete();\n-        plugin.complete(() -> {\n-            try {\n-                return Files.newOutputStream(Path.of(template));\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        });\n+        \/\/TODO what's with two finishWork methods????\n+        plugin.complete().get(TEMPLATE_ARTIFACT).accept(Files.newOutputStream(Path.of(outTemplate)));\n@@ -473,3 +386,3 @@\n-    public String[] getExclude() {\n-        return exclude;\n-    }\n+    public InstrumentationParams getParams() { return params; }\n+\n+    public String[] getExclude() { return exclude; }\n@@ -501,4 +414,0 @@\n-    public void setGenNative(boolean gennative) {\n-        this.gennative = gennative;\n-    }\n-\n@@ -509,3 +418,1 @@\n-    public void setInclude(String[] include) {\n-        this.include = include;\n-    }\n+    public String[] getMInclude() {return m_include;}\n@@ -513,2 +420,10 @@\n-    public String[] getMInclude() {\n-        return m_include;\n+    public File getOutDir() { return outDir; }\n+\n+    public String getInclude_rt() { return include_rt; }\n+\n+    public void setInclude_rt(String include_rt) { this.include_rt = include_rt; }\n+\n+    public void setOutDir(File outDir) { this.outDir = outDir; }\n+\n+    public void setGenNative(boolean gennative) {\n+        this.gennative = gennative;\n@@ -517,2 +432,2 @@\n-    public void setMInclude(String[] m_include) {\n-        this.m_include = m_include;\n+    public void setInclude(String[] include) {\n+        this.include = include;\n@@ -521,0 +436,2 @@\n+    public void setMInclude(String[] m_include) {this.m_include = m_include;}\n+\n@@ -594,0 +511,4 @@\n+    public String[] getSrcs() { return srcs; }\n+\n+    public void setSrcs(String[] srcs) { this.srcs = srcs; }\n+\n@@ -647,1 +568,1 @@\n-                ClassMorph.DSC_FLUSH_CLASSES,\n+                DSC_FLUSH_CLASSES,\n@@ -652,1 +573,1 @@\n-    private int handleEnv_(EnvHandler opts) throws EnvHandlingException {\n+    protected int handleEnv_(EnvHandler opts) throws EnvHandlingException {\n@@ -727,1 +648,1 @@\n-        flushPath = opts.getValue(ClassMorph.DSC_FLUSH_CLASSES);\n+        flushPath = opts.getValue(DSC_FLUSH_CLASSES);\n@@ -736,1 +657,1 @@\n-            if(pluginClass != null && !pluginClass.isEmpty())\n+            if(pluginClass != null && !pluginClass.isEmpty()) {\n@@ -739,0 +660,1 @@\n+            }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":108,"deletions":186,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -27,8 +27,0 @@\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph2;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n-import com.sun.tdk.jcov.instrument.InstrumentationParams;\n-import com.sun.tdk.jcov.tools.EnvHandler;\n-import com.sun.tdk.jcov.tools.JCovCMDTool;\n-import com.sun.tdk.jcov.tools.OptionDescr;\n@@ -36,3 +28,1 @@\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.logging.Level;\n+\n@@ -49,0 +39,1 @@\n+ * @deprecated Use Instr\n@@ -50,1 +41,2 @@\n-public class Instr2 extends JCovCMDTool {\n+@Deprecated(forRemoval = true)\n+public class Instr2 extends Instr {\n@@ -52,9 +44,0 @@\n-    private boolean genabstract;\n-    private boolean genfield;\n-    private boolean gennative;\n-    private boolean gensynthetic;\n-    private boolean genanonymous;\n-    private String template;\n-    private String flushPath;\n-    private String[] include;\n-    private String[] exclude;\n@@ -62,2 +45,0 @@\n-    private String[] srcs;\n-    private File outDir;\n@@ -95,137 +76,0 @@\n-\n-    @Override\n-    protected int run() throws Exception {\n-        Utils.addToClasspath(srcs);\n-\n-        AbstractUniversalInstrumenter instrumenter =\n-                new AbstractUniversalInstrumenter(true) {\n-                    ClassMorph2 morph = new ClassMorph2(\n-                            new InstrumentationParams(gennative, genfield, genabstract, include, exclude, InstrumentationOptions.InstrumentationMode.BLOCK)\n-                            .setInstrumentAnonymous(genanonymous)\n-                            .setInstrumentSynthetic(gensynthetic), template);\n-\n-                    protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n-                        return morph.morph(classData, flushPath);\n-                    }\n-\n-                    public void finishWork() {\n-                    }\n-                };\n-\n-        \/\/instrumenter.setPrintStats(opts.isSet(DSC_STATS));\n-\/\/        com.sun.tdk.jcov.instrument.Options.instrumentAbstract = com.sun.tdk.jcov.instrument.Options.instrumentAbstract.NONE;\n-\n-        for (String root : srcs) {\n-            instrumenter.instrument(new File(root), outDir);\n-        }\n-        \/*\n-         if ((opts.isSet(JcovInstrContext.OPT_SAVE_BEFORE) ||\n-         opts.isSet(JcovInstrContext.OPT_SAVE_AFTER)  ||\n-         opts.isSet(JcovInstrContext.OPT_SAVE_BEGIN)  ||\n-         opts.isSet(JcovInstrContext.OPT_SAVE_AT_END)) &&\n-         instrumenter.getSavePointCount() < 1) {\n-\n-         log.warning(\"no coverage data savepoints have been inserted\");\n-         }\n-         *\/\n-        instrumenter.finishWork();\n-        return SUCCESS_EXIT_CODE;\n-    }\n-\n-    @Override\n-    protected EnvHandler defineHandler() {\n-        return new EnvHandler(new OptionDescr[]{\n-                    DSC_OUTPUT,\n-                    DSC_VERBOSE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TEMPLATE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ABSTRACT,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_NATIVE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FIELD,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SYNTHETIC,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ANONYM,\n-                    ClassMorph.DSC_FLUSH_CLASSES\n-                }, this);\n-    }\n-\n-    @Override\n-    protected int handleEnv(EnvHandler envHandler) throws EnvHandlingException {\n-        srcs = envHandler.getTail();\n-        if (srcs == null) {\n-            throw new EnvHandlingException(\"No input files specified\");\n-        }\n-        if (envHandler.isSet(DSC_VERBOSE)) {\n-            logger.setLevel(Level.INFO);\n-        }\n-\n-        outDir = null;\n-        if (envHandler.isSet(DSC_OUTPUT)) {\n-            outDir = new File(envHandler.getValue(DSC_OUTPUT));\n-            if (!outDir.exists()) {\n-                outDir.mkdirs();\n-                logger.log(Level.INFO, \"The directory {0} was created.\", outDir.getAbsolutePath());\n-            }\n-        }\n-\n-        String abstractValue = envHandler.getValue(InstrumentationOptions.DSC_ABSTRACT);\n-        if (abstractValue.equals(\"off\")) {\n-            genabstract = false;\n-        } else if (abstractValue.equals(\"on\")) {\n-            genabstract = true;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_ABSTRACT.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + abstractValue + \"'\");\n-        }\n-\n-        String nativeValue = envHandler.getValue(InstrumentationOptions.DSC_NATIVE);\n-        if (nativeValue.equals(\"on\")) {\n-            gennative = true;\n-        } else if (nativeValue.equals(\"off\")) {\n-            gennative = false;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_NATIVE.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + nativeValue + \"'\");\n-        }\n-\n-        String fieldValue = envHandler.getValue(InstrumentationOptions.DSC_FIELD);\n-        if (fieldValue.equals(\"on\")) {\n-            genfield = true;\n-        } else if (fieldValue.equals(\"off\")) {\n-            genfield = false;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_FIELD.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + fieldValue + \"'\");\n-        }\n-\n-        String anonym = envHandler.getValue(InstrumentationOptions.DSC_ANONYM);\n-        if (anonym.equals(\"on\")) {\n-            genanonymous = true;\n-        } else { \/\/ off\n-            genanonymous = false;\n-        }\n-\n-        String syntheticField = envHandler.getValue(InstrumentationOptions.DSC_SYNTHETIC);\n-        if (syntheticField.equals(\"on\")) {\n-            gensynthetic = true;\n-        } else { \/\/ if (fieldValue.equals(\"off\"))\n-            gensynthetic = false;\n-        }\n-\n-        template = envHandler.getValue(InstrumentationOptions.DSC_TEMPLATE);\n-        Utils.checkFileNotNull(template, \"template filename\", Utils.CheckOptions.FILE_NOTISDIR, Utils.CheckOptions.FILE_PARENTEXISTS);\n-\n-        include = InstrumentationOptions.handleInclude(envHandler);\n-        exclude = InstrumentationOptions.handleExclude(envHandler);\n-\n-        flushPath = envHandler.getValue(ClassMorph.DSC_FLUSH_CLASSES);\n-        if (\"none\".equals(flushPath)) {\n-            flushPath = null;\n-        }\n-\n-        return SUCCESS_EXIT_CODE;\n-    }\n-    final static OptionDescr DSC_OUTPUT =\n-            new OptionDescr(\"instr2.output\", new String[]{\"output\", \"o\"}, \"Output directory\", OptionDescr.VAL_SINGLE,\n-            \"Specifies output file or directory, default directory is current.\");\n-    final static OptionDescr DSC_VERBOSE =\n-            new OptionDescr(\"verbose\", \"Verbose mode\", \"Enable verbose mode.\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr2.java","additions":4,"deletions":160,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n@@ -34,1 +37,7 @@\n-import java.io.*;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n@@ -36,1 +45,0 @@\n-import java.net.URLClassLoader;\n@@ -38,0 +46,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -39,0 +49,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -41,0 +53,1 @@\n+import java.util.function.BiConsumer;\n@@ -44,0 +57,5 @@\n+import static com.sun.tdk.jcov.Instr.DSC_INCLUDE_RT;\n+import static com.sun.tdk.jcov.Instr.DSC_VERBOSE;\n+import static com.sun.tdk.jcov.instrument.InstrumentationOptions.*;\n+import static com.sun.tdk.jcov.instrument.InstrumentationPlugin.MODULE_INFO_CLASS;\n+import static com.sun.tdk.jcov.instrument.InstrumentationPlugin.TEMPLATE_ARTIFACT;\n@@ -60,1 +78,1 @@\n-    private Instr instr;\n+\/\/    private Instr instr;\n@@ -69,0 +87,6 @@\n+    private InstrumentationPlugin plugin = new ASMInstrumentationPlugin();\n+    private InstrumentationParams params;\n+    private String template = \"template.xml\";\n+    private String[] m_excludes;\n+    private String[] m_includes;\n+    private String include_rt;\n@@ -75,4 +99,0 @@\n-    \/**\n-     * tries to find class in the specified jars\n-     *\/\n-    public static class StaticJREInstrClassLoader extends URLClassLoader {\n@@ -80,18 +100,0 @@\n-        StaticJREInstrClassLoader(URL[] urls) {\n-            super(urls);\n-        }\n-\n-        @Override\n-        public InputStream getResourceAsStream(String s) {\n-            InputStream in = null;\n-            try {\n-                in = findResource(s).openStream();\n-            } catch (IOException ignore) {\n-                \/\/nothing to do\n-            }\n-            if (in != null) {\n-                return in;\n-            }\n-            return super.getResourceAsStream(s);\n-        }\n-    }\n@@ -103,6 +105,0 @@\n-        instr.startWorking();\n-\n-        StaticJREInstrClassLoader cl = new StaticJREInstrClassLoader(new URL[]{toInstrument.toURI().toURL()});\n-        instr.setClassLoader(cl);\n-\n-        instr.fixJavaBase();\n@@ -125,2 +121,21 @@\n-            cl = new StaticJREInstrClassLoader(urls.toArray(new URL[0]));\n-            instr.setClassLoader(cl);\n+            ClassLoader cl = new InstrumentationPlugin.OverridingClassLoader(urls.toArray(new URL[0]),\n+                    ClassLoader.getSystemClassLoader());\n+\n+            InstrumentationPlugin.ModuleInstrumentation mi = new InstrumentationPlugin.ModuleInstrumentation(\n+                    new InstrumentationPlugin.FilteringPlugin(plugin, InstrumentationPlugin.classNameFilter(params)),\n+                    (InstrumentationPlugin.ModuleInstrumentationPlugin) plugin) {\n+                public void proccessModule(byte[] moduleInfo, ClassLoader loader,\n+                                           BiConsumer<String, byte[]> destination) throws Exception {\n+                    InstrumentationPlugin.ModuleInstrumentationPlugin mip = getModulePluign();\n+                    if(mip.getModuleName(moduleInfo).equals(\"java.base\")) {\n+                        moduleInfo = mip.addExports(List.of(\"com\/sun\/tdk\/jcov\/runtime\"), moduleInfo, loader);\n+                        moduleInfo = mip.clearHashes(moduleInfo, loader);\n+                        InstrumentationPlugin.PathSource implantSource =\n+                                new InstrumentationPlugin.PathSource(cl, implant.toPath());\n+                        for (String resource : implantSource.resources()) {\n+                            destination.accept(resource, implantSource.loader().getResourceAsStream(resource).readAllBytes());\n+                        }\n+                    }\n+                    destination.accept(MODULE_INFO_CLASS, moduleInfo);\n+                }\n+            };\n@@ -131,2 +146,7 @@\n-                        File modClasses = new File(mod, \"classes\");\n-                        instr.instrumentFile(modClasses.getAbsolutePath(), null, null, mod.getName());\n+                        String moduleName = mod.getName();\n+                        if (isModuleIncluded(moduleName)) {\n+                            logger.log(Level.INFO, \"Instrumenting \" + moduleName);\n+                            File modClasses = new File(mod, \"classes\");\n+                            mi.instrument(new InstrumentationPlugin.PathSource(cl, modClasses.toPath()),\n+                                    new InstrumentationPlugin.PathDestination(modClasses.toPath()), params);\n+                        }\n@@ -166,0 +186,1 @@\n+                e.printStackTrace();\n@@ -170,60 +191,0 @@\n-\/\/            ArrayList<File> jdkImages = new ArrayList<>();\n-\/\/            jdkImages.add(toInstrument);\n-\/\/            if (addJimages != null) {\n-\/\/                Collections.addAll(jdkImages, addJimages);\n-\/\/            }\n-\/\/\n-\/\/            for (File jimageInstr : jdkImages) {\n-\/\/                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n-\/\/\n-\/\/                expandJimage(jimageInstr, tempDirName);\n-\/\/\n-\/\/                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n-\/\/\/\/                still need it\n-\/\/                Utils.addToClasspath(new String[]{dirtoInstrument.getAbsolutePath()});\n-\/\/                for (File file : getListFiles(dirtoInstrument)) {\n-\/\/                    if (file.isDirectory()) {\n-\/\/                        Utils.addToClasspath(new String[]{file.getAbsolutePath()});\n-\/\/                    }\n-\/\/                }\n-\/\/\n-\/\/                if (jimageInstr.equals(toInstrument)) {\n-\/\/                    for (File mod : getListFiles(dirtoInstrument)) {\n-\/\/                        if (mod != null && mod.isDirectory()) {\n-\/\/\n-\/\/                            if (\"java.base\".equals(mod.getName())) {\n-\/\/                                instr.instrumentFile(mod.getAbsolutePath(), null, implant.getAbsolutePath(), mod.getName());\n-\/\/                            } else {\n-\/\/                                instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n-\/\/                            }\n-\/\/                        }\n-\/\/                    }\n-\/\/                } else {\n-\/\/                    for (File mod : getListFiles(dirtoInstrument)) {\n-\/\/                        if (mod != null && mod.isDirectory()) {\n-\/\/                            instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n-\/\/                        }\n-\/\/                    }\n-\/\/                }\n-\/\/                createJimage(dirtoInstrument, jimageInstr.getAbsolutePath() + \"i\");\n-\n-\/\/            }\n-\/\/            for (File jimageInstr : jdkImages) {\n-\/\/\n-\/\/                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n-\/\/                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n-\/\/                if (!Utils.deleteDirectory(dirtoInstrument)) {\n-\/\/                    logger.log(Level.SEVERE, \"please, delete \" + tempDirName + \" jimage dir manually\");\n-\/\/                }\n-\/\/\n-\/\/                Utils.copyFile(jimageInstr, new File(jimageInstr.getParent(), jimageInstr.getName() + \".bak\"));\n-\/\/\n-\/\/                if (!jimageInstr.delete()) {\n-\/\/                    logger.log(Level.SEVERE, \"please, delete original jimage manually: \" + jimageInstr);\n-\/\/                } else {\n-\/\/                    Utils.copyFile(new File(jimageInstr.getAbsolutePath() + \"i\"), jimageInstr);\n-\/\/                    new File(jimageInstr.getAbsolutePath() + \"i\").delete();\n-\/\/                }\n-\/\/\n-\/\/            }\n-\n@@ -232,1 +193,0 @@\n-\/\/            instr.instrumentFile(toInstrument.getAbsolutePath(), null, implant.getAbsolutePath());\n@@ -235,20 +195,20 @@\n-        ArrayList<String> srcs = null;\n-        if (addJars != null) {\n-            srcs = new ArrayList<>();\n-            for (File addJar : addJars) {\n-                srcs.add(addJar.getAbsolutePath());\n-            }\n-        }\n-\n-        if (srcs != null) {\n-            Utils.addToClasspath(srcs.toArray(new String[0]));\n-            instr.instrumentFiles(srcs.toArray(new String[0]), null, null);\n-        }\n-\n-        if (addTests != null) {\n-            ArrayList<String> tests = new ArrayList<>();\n-            for (File addTest : addTests) {\n-                tests.add(addTest.getAbsolutePath());\n-            }\n-            instr.instrumentTests(tests.toArray(new String[0]), null, null);\n-        }\n+        \/\/see a comment in handleEnv(EnvHandler)\n+\/\/        ArrayList<String> srcs = null;\n+\/\/        if (addJars != null) {\n+\/\/            srcs = new ArrayList<>();\n+\/\/            for (File addJar : addJars) {\n+\/\/                srcs.add(addJar.getAbsolutePath());\n+\/\/            }\n+\/\/        }\n+\/\/\n+\/\/        if (srcs != null) {\n+\/\/            Utils.addToClasspath(srcs.toArray(new String[0]));\n+\/\/            instr.instrumentFiles(srcs.toArray(new String[0]), null, null);\n+\/\/        }\n+\/\/        if (addTests != null) {\n+\/\/            ArrayList<String> tests = new ArrayList<>();\n+\/\/            for (File addTest : addTests) {\n+\/\/                tests.add(addTest.getAbsolutePath());\n+\/\/            }\n+\/\/            instr.instrumentTests(tests.toArray(new String[0]), null, null);\n+\/\/        }\n@@ -256,1 +216,1 @@\n-        instr.finishWork();\n+        plugin.complete().get(TEMPLATE_ARTIFACT).accept(Files.newOutputStream(Path.of(template)));\n@@ -264,1 +224,1 @@\n-        boolean success;\n+        boolean success = false;\n@@ -280,0 +240,2 @@\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n@@ -333,0 +295,4 @@\n+    private boolean isModuleIncluded(String moduleName) {\n+        return (m_includes.length == 0 || Arrays.stream(m_includes).anyMatch(i -> moduleName.matches(i))) &&\n+               Arrays.stream(m_excludes).noneMatch(i -> moduleName.matches(i));\n+    }\n@@ -375,0 +341,1 @@\n+            e.printStackTrace();\n@@ -403,1 +370,1 @@\n-        Instr.DSC_INCLUDE_RT.usage = \"To run instrumented JRE you should implant JCov runtime library both into rt.jar \" +\n+        DSC_INCLUDE_RT.usage = \"To run instrumented JRE you should implant JCov runtime library both into rt.jar \" +\n@@ -408,2 +375,2 @@\n-                Instr.DSC_INCLUDE_RT,\n-                Instr.DSC_VERBOSE,\n+                DSC_INCLUDE_RT,\n+                DSC_VERBOSE,\n@@ -433,3 +400,4 @@\n-                DCS_ADD_JAR,\n-                DCS_ADD_JIMAGE,\n-                DCS_ADD_TESTS,\n+                \/\/See comment in handleEnv(EnvHandler)\n+\/\/                DCS_ADD_JAR,\n+\/\/                DCS_ADD_JIMAGE,\n+\/\/                DCS_ADD_TESTS,\n@@ -443,1 +411,2 @@\n-        instr = new Instr();\n+\n+        params = new InstrumentationParams();\n@@ -453,1 +422,1 @@\n-        if (!envHandler.isSet(Instr.DSC_INCLUDE_RT)) {\n+        if (!envHandler.isSet(DSC_INCLUDE_RT)) {\n@@ -457,1 +426,1 @@\n-        implant = new File(envHandler.getValue(Instr.DSC_INCLUDE_RT));\n+        implant = new File(envHandler.getValue(DSC_INCLUDE_RT));\n@@ -460,0 +429,3 @@\n+        \/\/It is currently unclear if there are solid usecases for instrumenting any additional bytecode together\n+        \/\/with the JDK. That applies to additional jars, sources and also test. If anything else need to be\n+        \/\/instrumented, a separate instrumentation call could be used.\n@@ -461,11 +433,12 @@\n-            String[] jars = envHandler.getValues(DCS_ADD_JAR);\n-            addJars = new File[jars.length];\n-            for (int i = 0; i < addJars.length; ++i) {\n-                addJars[i] = new File(jars[i]);\n-                if (!addJars[i].exists()) {\n-                    throw new EnvHandlingException(\"Additional jar \" + jars[i] + \" doesn't exist\");\n-                }\n-                if (!addJars[i].canRead()) {\n-                    throw new EnvHandlingException(\"Can't read additional jar \" + jars[i]);\n-                }\n-            }\n+            throw new UnsupportedOperationException(\"Instrumenting additional code together with JDK is not supported.\");\n+\/\/            String[] jars = envHandler.getValues(DCS_ADD_JAR);\n+\/\/            addJars = new File[jars.length];\n+\/\/            for (int i = 0; i < addJars.length; ++i) {\n+\/\/                addJars[i] = new File(jars[i]);\n+\/\/                if (!addJars[i].exists()) {\n+\/\/                    throw new EnvHandlingException(\"Additional jar \" + jars[i] + \" doesn't exist\");\n+\/\/                }\n+\/\/                if (!addJars[i].canRead()) {\n+\/\/                    throw new EnvHandlingException(\"Can't read additional jar \" + jars[i]);\n+\/\/                }\n+\/\/            }\n@@ -474,11 +447,12 @@\n-            String[] images = envHandler.getValues(DCS_ADD_JIMAGE);\n-            addJimages = new File[images.length];\n-            for (int i = 0; i < addJimages.length; ++i) {\n-                addJimages[i] = new File(images[i]);\n-                if (!addJimages[i].exists()) {\n-                    throw new EnvHandlingException(\"Additional jimage \" + images[i] + \" doesn't exist\");\n-                }\n-                if (!addJimages[i].canRead()) {\n-                    throw new EnvHandlingException(\"Can't read additional jimage \" + images[i]);\n-                }\n-            }\n+            throw new UnsupportedOperationException(\"Instrumenting additional code together with JDK is not supported.\");\n+\/\/            String[] images = envHandler.getValues(DCS_ADD_JIMAGE);\n+\/\/            addJimages = new File[images.length];\n+\/\/            for (int i = 0; i < addJimages.length; ++i) {\n+\/\/                addJimages[i] = new File(images[i]);\n+\/\/                if (!addJimages[i].exists()) {\n+\/\/                    throw new EnvHandlingException(\"Additional jimage \" + images[i] + \" doesn't exist\");\n+\/\/                }\n+\/\/                if (!addJimages[i].canRead()) {\n+\/\/                    throw new EnvHandlingException(\"Can't read additional jimage \" + images[i]);\n+\/\/                }\n+\/\/            }\n@@ -488,11 +462,12 @@\n-            String[] files = envHandler.getValues(DCS_ADD_TESTS);\n-            addTests = new File[files.length];\n-            for (int i = 0; i < addTests.length; ++i) {\n-                addTests[i] = new File(files[i]);\n-                if (!addTests[i].exists()) {\n-                    throw new EnvHandlingException(\"Test file \" + files[i] + \" doesn't exist\");\n-                }\n-                if (!addTests[i].canRead()) {\n-                    throw new EnvHandlingException(\"Can't read test file \" + files[i]);\n-                }\n-            }\n+            throw new UnsupportedOperationException(\"Instrumenting additional code together with JDK is not supported.\");\n+\/\/            String[] files = envHandler.getValues(DCS_ADD_TESTS);\n+\/\/            addTests = new File[files.length];\n+\/\/            for (int i = 0; i < addTests.length; ++i) {\n+\/\/                addTests[i] = new File(files[i]);\n+\/\/                if (!addTests[i].exists()) {\n+\/\/                    throw new EnvHandlingException(\"Test file \" + files[i] + \" doesn't exist\");\n+\/\/                }\n+\/\/                if (!addTests[i].canRead()) {\n+\/\/                    throw new EnvHandlingException(\"Can't read test file \" + files[i]);\n+\/\/                }\n+\/\/            }\n@@ -611,1 +586,1 @@\n-                instr.setTemplate(template);\n+                setTemplate(template);\n@@ -703,2 +678,2 @@\n-        String[] m_excludes = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleMExclude(envHandler);\n-        String[] m_includes = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleMInclude(envHandler);\n+        m_excludes = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleMExclude(envHandler);\n+        m_includes = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleMInclude(envHandler);\n@@ -732,4 +707,3 @@\n-        int ret = instr.handleEnv(envHandler);\n-        instr.setSave_end(new String[]{\"java\/lang\/Shutdown.runHooks\"});\n-        instr.setInclude(includes);\n-        instr.setExclude(excludes);\n+        if (envHandler.isSet(DSC_VERBOSE)) {\n+            logger.setLevel(Level.INFO);\n+        }\n@@ -737,2 +711,2 @@\n-        instr.setMInclude(m_includes);\n-        instr.setMExclude(m_excludes);\n+        params.setSavesBegin(envHandler.getValues(DSC_SAVE_BEGIN));\n+        params.setSavesEnd(envHandler.getValues(DSC_SAVE_AT_END));\n@@ -740,2 +714,34 @@\n-        instr.setCallerInclude(callerInclude);\n-        instr.setCallerExclude(callerExclude);\n+        String abstractValue = envHandler.getValue(DSC_ABSTRACT);\n+        if (abstractValue.equals(\"off\")) {\n+            params.setInstrumentAbstract(ABSTRACTMODE.NONE);\n+        } else if (abstractValue.equals(\"on\")) {\n+            params.setInstrumentAbstract(ABSTRACTMODE.DIRECT);\n+        } else {\n+            throw new EnvHandlingException(\"'\" + DSC_ABSTRACT.name +\n+                    \"' parameter value error: expected 'on' or 'off'; found: '\" + abstractValue + \"'\");\n+        }\n+\n+        String nativeValue = envHandler.getValue(DSC_NATIVE);\n+        if (nativeValue.equals(\"on\")) {\n+            params.setInstrumentNative(true);\n+        } else if (nativeValue.equals(\"off\")) {\n+            params.setInstrumentNative(false);\n+        } else {\n+            throw new EnvHandlingException(\"'\" + DSC_NATIVE.name +\n+                    \"' parameter value error: expected 'on' or 'off'; found: '\" + nativeValue + \"'\");\n+        }\n+\n+        String fieldValue = envHandler.getValue(DSC_FIELD);\n+        if (fieldValue.equals(\"on\")) {\n+            params.setInstrumentFields(true);\n+        } else if (fieldValue.equals(\"off\")) {\n+            params.setInstrumentFields(false);\n+        } else {\n+            \/\/ can't happen - check is in EnvHandler\n+            throw new EnvHandlingException(\"'\" + DSC_FIELD.name +\n+                    \"' parameter value error: expected 'on' or 'off'; found: '\" + fieldValue + \"'\");\n+        }\n+\n+        params.setInstrumentAnonymous(envHandler.getValue(DSC_ANONYM).equals(\"on\"));\n+\n+        params.setInstrumentSynthetic(envHandler.getValue(DSC_SYNTHETIC).equals(\"on\"));\n@@ -743,2 +749,23 @@\n-        instr.setInnerInclude(innerInclude);\n-        instr.setInnerExclude(innerExclude);\n+        params.setInnerInvocations(envHandler.getValue(DSC_INNERINVOCATION).equals(\"off\"));\n+\n+        params.setCallerIncludes(callerInclude);\n+        params.setCallerExcludes(callerExclude);\n+\n+        params.setMode(InstrumentationMode.fromString(envHandler.getValue(DSC_TYPE)));\n+\n+        template = envHandler.getValue(DSC_TEMPLATE);\n+        Utils.checkFileNotNull(template, \"template filename\", FILE_NOTISDIR, FILE_PARENTEXISTS);\n+\n+        include_rt = envHandler.getValue(DSC_INCLUDE_RT);\n+        Utils.checkFileCanBeNull(include_rt, \"JCovRT library jarfile\", FILE_EXISTS, FILE_ISFILE, FILE_CANREAD);\n+\n+        params.setSavesEnd(new String[]{\"java\/lang\/Shutdown.runHooks\"});\n+\n+        params.setIncludes(includes);\n+        params.setExcludes(excludes);\n+\n+        params.setInnerIncludes(innerInclude);\n+        params.setInnerExcludes(innerExclude);\n+\n+        return SUCCESS_EXIT_CODE;\n+    }\n@@ -746,1 +773,2 @@\n-        return ret;\n+    private void setTemplate(String template) {\n+        this.template = template;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/JREInstr.java","additions":202,"deletions":174,"binary":false,"changes":376,"status":"modified"},{"patch":"@@ -27,5 +27,1 @@\n-import com.sun.tdk.jcov.constants.MiscConstants;\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n-import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -33,1 +29,0 @@\n-import com.sun.tdk.jcov.tools.JCovCMDTool;\n@@ -35,1 +30,0 @@\n-import com.sun.tdk.jcov.util.RuntimeUtils;\n@@ -37,0 +31,1 @@\n+\n@@ -39,0 +34,1 @@\n+import java.nio.file.Path;\n@@ -40,2 +36,1 @@\n-import java.util.Arrays;\n-import java.util.logging.Level;\n+import java.util.List;\n@@ -43,0 +38,1 @@\n+import java.util.stream.Collectors;\n@@ -48,2 +44,1 @@\n-public class ProductInstr extends JCovCMDTool {\n-    \/\/ instrumentation filters (include\/exclude, fields, abstract, ...); removing temporary directory\n+public class ProductInstr extends Instr {\n@@ -57,34 +52,0 @@\n-    private File instrProductDir;\n-    private File instrOutputDir;\n-    private String template = MiscConstants.JcovTemplateFileNameXML;\n-    private String tempPath;\n-    private File rtLibFile;\n-    private String[] rtClassDirTargets;\n-    private InstrumentationOptions.InstrumentationMode mode = InstrumentationOptions.InstrumentationMode.BRANCH;\n-    private String[] include = new String[]{\".*\"};\n-    private String[] exclude = new String[]{\"\"};\n-    private String[] m_include = new String[]{\".*\"};\n-    private String[] m_exclude = new String[]{\"\"};\n-    private String[] callerInclude;\n-    private String[] callerExclude;\n-\n-    public void instrumentProduct() throws Exception {\n-        logger.log(Level.INFO, \" - Instrumenting product\");\n-        logger.log(Level.CONFIG, \"Product location: ''{0}'', target location: ''{1}''\", new Object[]{instrProductDir.getPath(), instrOutputDir.getPath()});\n-\n-        tempPath = instrProductDir.getPath() + RuntimeUtils.genSuffix();\n-        createTempDir();\n-\n-        AbstractUniversalInstrumenter instrumenter = setupInstrumenter();\n-\n-        instrOutputDir.mkdir();\n-        instrumenter.instrument(instrProductDir, instrOutputDir, rtLibFile.getAbsolutePath(), rtClassDirTargets == null ? null : new ArrayList(Arrays.asList(rtClassDirTargets)), true);\n-        instrumenter.finishWork();\n-\n-        removeTempDir();\n-    }\n-\n-    private AbstractUniversalInstrumenter setupInstrumenter() {\n-        InstrumentationParams params = new InstrumentationParams(true, false, false, false, false, false, InstrumentationOptions.ABSTRACTMODE.NONE, include, exclude, callerInclude, callerExclude, m_include, m_exclude, mode, null, null)\n-                .setInstrumentAnonymous(true)\n-                .setInstrumentSynthetic(false);\n@@ -92,18 +53,5 @@\n-        final ClassMorph morph = new ClassMorph(params, null);\n-        return new AbstractUniversalInstrumenter(true) {\n-            @Override\n-            protected byte[] instrument(byte[] classData, int classLength) throws IOException {\n-                return morph.morph(classBuf, null, tempPath);\n-            }\n-\n-            @Override\n-            public void finishWork() {\n-                morph.saveData(template, null, InstrumentationOptions.MERGE.OVERWRITE);\n-            }\n-        };\n-    }\n-\n-    private void createTempDir() {\n-        new File(tempPath).mkdir();\n-        logger.log(Level.INFO, \"Temp directory for storing instrumented classes created: ''{0}''. Automatic removal is not implemented yet so please remove it manually after all is done.\", tempPath);\n-    }\n+    public final static OptionDescr DSC_INSTRUMENT =\n+            new OptionDescr(\"product\", \"\", OptionDescr.VAL_SINGLE, \"\");\n+    public final static OptionDescr DSC_INSTRUMENT_TO =\n+            new OptionDescr(\"productOutput\", \"\", OptionDescr.VAL_SINGLE, \"\");\n+    public final static OptionDescr DSC_RT_TO = new OptionDescr(\"rtTo\", \"\", OptionDescr.VAL_MULTI, \"\");\n@@ -111,9 +59,4 @@\n-    private void removeTempDir() {\n-        File tempFile = new File(tempPath);\n-        if (tempFile.isDirectory()) {\n-            Utils.deleteDirectory(tempFile);\n-        } else {\n-            tempFile.delete();\n-        }\n-        logger.log(Level.INFO, \"Temp directory for storing instrumented classes deleted: ''{0}''.\", tempPath);\n-    }\n+    private static final List<String> SKIP_INSTR_OPTIONS = List.of(\n+            DSC_OUTPUT).stream().map(o -> o.name).collect(Collectors.toList());\n+    private static final List<OptionDescr> ADD_TO_INSTR_OPTIONS = List.of(\n+            DSC_INSTRUMENT, DSC_INSTRUMENT_TO, Instr.DSC_INCLUDE_RT);\n@@ -122,3 +65,3 @@\n-    protected int run() throws Exception {\n-        instrumentProduct();\n-        return SUCCESS_EXIT_CODE;\n+    protected InstrumentationPlugin.Destination getDestination(File outDir, Path inPath) throws IOException {\n+        if (getOutDir() == null) return new InstrumentationPlugin.PathDestination(inPath);\n+        else return new InstrumentationPlugin.PathDestination(Path.of(outDir.getAbsolutePath()));\n@@ -129,16 +72,6 @@\n-        return new EnvHandler(new OptionDescr[]{\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TYPE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_EXCLUDE,\n-                    DSC_INSTRUMENT,\n-                    DSC_INSTRUMENT_TO,\n-                    Instr.DSC_INCLUDE_RT,\n-                    DSC_RT_TO,}, this);\n+        EnvHandler superHandler = super.defineHandler();\n+        List<OptionDescr> opts = superHandler.getValidOptions().stream()\n+                .filter(o -> !SKIP_INSTR_OPTIONS.contains(o.name)).collect(Collectors.toList());\n+        opts = new ArrayList<>(opts);\n+        opts.addAll(ADD_TO_INSTR_OPTIONS);\n+        return new EnvHandler(opts.toArray(new OptionDescr[0]), this);\n@@ -149,2 +82,8 @@\n-        instrProductDir = Utils.checkFileCanBeNull(envHandler.getValue(ProductInstr.DSC_INSTRUMENT), \"product directory\", Utils.CheckOptions.FILE_ISDIR, Utils.CheckOptions.FILE_CANREAD);\n-        instrOutputDir = Utils.checkFileCanBeNull(envHandler.getValue(ProductInstr.DSC_INSTRUMENT_TO), \"directory for instrumented product\", Utils.CheckOptions.FILE_NOTEXISTS, Utils.CheckOptions.FILE_CANWRITE);\n+        int superRes = super.handleEnv_(envHandler);\n+        if(superRes != SUCCESS_EXIT_CODE) return superRes;\n+        File instrProductDir = Utils.checkFileCanBeNull(envHandler.getValue(ProductInstr.DSC_INSTRUMENT),\n+                \"product directory\",\n+                Utils.CheckOptions.FILE_ISDIR, Utils.CheckOptions.FILE_CANREAD);\n+        File instrOutputDir = Utils.checkFileCanBeNull(envHandler.getValue(ProductInstr.DSC_INSTRUMENT_TO),\n+                \"directory for instrumented product\",\n+                Utils.CheckOptions.FILE_NOTEXISTS, Utils.CheckOptions.FILE_CANWRITE);\n@@ -154,1 +93,3 @@\n-        rtLibFile = Utils.checkFileCanBeNull(envHandler.getValue(Instr.DSC_INCLUDE_RT), \"JCov RT Saver path\", Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_ISFILE, Utils.CheckOptions.FILE_CANREAD);\n+        setSrcs(new String[] {instrProductDir.getAbsolutePath()});\n+        setOutDir(instrOutputDir);\n+        File rtLibFile = Utils.checkFileCanBeNull(envHandler.getValue(Instr.DSC_INCLUDE_RT), \"JCov RT Saver path\", Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_ISFILE, Utils.CheckOptions.FILE_CANREAD);\n@@ -158,14 +99,1 @@\n-        rtClassDirTargets = envHandler.getValues(ProductInstr.DSC_RT_TO);\n-        if (envHandler.getValue(InstrumentationOptions.DSC_TYPE) != null) {\n-            mode = InstrumentationOptions.InstrumentationMode.fromString(envHandler.getValue(InstrumentationOptions.DSC_TYPE));\n-        }\n-\n-        include = InstrumentationOptions.handleInclude(envHandler);\n-        exclude = InstrumentationOptions.handleExclude(envHandler);\n-\n-        m_include = InstrumentationOptions.handleMInclude(envHandler);\n-        m_exclude = InstrumentationOptions.handleMExclude(envHandler);\n-\n-        callerInclude = envHandler.getValues(InstrumentationOptions.DSC_CALLER_INCLUDE);\n-        callerExclude = envHandler.getValues(InstrumentationOptions.DSC_CALLER_EXCLUDE);\n-\n+        setInclude_rt(rtLibFile.toString());\n@@ -189,5 +117,6 @@\n-    public final static OptionDescr DSC_INSTRUMENT =\n-            new OptionDescr(\"product\", \"\", OptionDescr.VAL_SINGLE, \"\");\n-    public final static OptionDescr DSC_INSTRUMENT_TO =\n-            new OptionDescr(\"productOutput\", \"\", OptionDescr.VAL_SINGLE, \"\");\n-    public final static OptionDescr DSC_RT_TO = new OptionDescr(\"rtTo\", \"\", OptionDescr.VAL_MULTI, \"\");\n+\n+    public void instrumentProduct() throws Exception {\n+        if (!getOutDir().exists()) getOutDir().mkdirs();\n+        instrumentFiles(getSrcs(), getOutDir(), getInclude_rt());\n+        finishWork(getTemplate());\n+    }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/ProductInstr.java","additions":42,"deletions":113,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -27,5 +27,1 @@\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions.InstrumentationMode;\n-import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -33,1 +29,0 @@\n-import com.sun.tdk.jcov.tools.JCovCMDTool;\n@@ -35,1 +30,1 @@\n-import com.sun.tdk.jcov.util.Utils;\n+\n@@ -37,2 +32,6 @@\n-import java.io.IOException;\n-import java.util.logging.Level;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import static com.sun.tdk.jcov.instrument.InstrumentationOptions.*;\n@@ -47,17 +46,1 @@\n-public class TmplGen extends JCovCMDTool {\n-\n-    private String[] files;\n-    private AbstractUniversalInstrumenter instrumenter;\n-    private String flushPath;\n-    private String template;\n-    private String[] include;\n-    private String[] exclude;\n-    private String[] m_include;\n-    private String[] m_exclude;\n-    private boolean instrumentAbstract = false;\n-    private boolean instrumentNative = true;\n-    private boolean instrumentField = false;\n-    private boolean instrumentAnonymous = true;\n-    private boolean instrumentSynthetic = true;\n-    private InstrumentationOptions.InstrumentationMode mode;\n-    private String currentModule = null;\n+public class TmplGen extends Instr {\n@@ -81,0 +64,8 @@\n+    @Override\n+    protected InstrumentationPlugin.Destination getDestination(File outDir, Path inPath) {\n+        return new InstrumentationPlugin.Destination() {\n+            @Override public BiConsumer<String, byte[]> saver() {return (n, c) -> {};}\n+            @Override public void close() {}\n+        };\n+    }\n+\n@@ -93,137 +84,7 @@\n-    @Override\n-    protected int run() throws Exception {\n-        try {\n-            generateAndSave(files);\n-        } catch (IOException ioe) {\n-            throw new Exception(\"Unexpected error during instrumentation\", ioe);\n-        }\n-        return SUCCESS_EXIT_CODE;\n-    }\n-\n-    private boolean expandJimage(File jimage, String tempDirName, boolean isModulesDir){\n-        try {\n-            String command = \"\";\n-            if (isModulesDir) {\n-                command = jimage.getParentFile().getParentFile().getParent() + File.separator + \"bin\" + File.separator + \"jimage extract --dir \" +\n-                        jimage.getParent() + File.separator + tempDirName + \" \" + jimage.getAbsolutePath();\n-            }\n-            else{\n-                command = jimage.getParentFile().getParentFile() + File.separator + \"bin\" + File.separator + \"jimage extract --dir \" +\n-                        jimage.getParent() + File.separator + tempDirName + \" \" + jimage.getAbsolutePath();\n-            }\n-            Process process = Runtime.getRuntime().exec(command);\n-            process.waitFor();\n-            if (process.exitValue() != 0) {\n-                \/\/logger.log(Level.SEVERE, \"wrong command for expand jimage: \"+command);\n-                return false;\n-            }\n-        } catch (Exception e) {\n-            \/\/logger.log(Level.SEVERE, \"exception in process(expanding jimage)\", e);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    public void generateAndSave(String[] files) throws Exception {\n-        setDefaultInstrumenter();\n-        for (String root : files) {\n-            if (root.endsWith(\".jimage\")){\n-                readJImage(new File(root), true);\n-            }\n-            else if (root.endsWith(\"modules\") && (new File(root).isFile())) {\n-                readJImage(new File(root), false);\n-            }\n-            else{\n-                instrumenter.instrument(new File(root), null);\n-            }\n-        }\n-        for (String root : files) {\n-            if (root.endsWith(\".jimage\")) {\n-                File rootFile = new File(root);\n-                Utils.deleteDirectory(new File(rootFile.getParentFile().getAbsolutePath() + File.separator + \"temp_\" + getJImageName(rootFile)));\n-            }\n-            if (root.endsWith(\"modules\")){\n-                File rootFile = new File(root);\n-                if (rootFile.isFile()){\n-                    Utils.deleteDirectory(new File(rootFile.getParentFile().getAbsolutePath() + File.separator + \"temp_modules\"));\n-                }\n-            }\n-        }\n-        instrumenter.finishWork();\n-        instrumenter = null;\n-    }\n-\n-    private void readJImage(File rootFile, boolean isModulesDir) throws IOException{\n-        String jimagename = \"modules\";\n-        if (isModulesDir) {\n-            jimagename = getJImageName(rootFile);\n-        }\n-\n-        expandJimage(rootFile, \"temp_\"+jimagename, isModulesDir);\n-        File tempJimage = new File(rootFile.getParentFile().getAbsolutePath()+File.separator+\"temp_\"+jimagename);\n-        \/\/still need it\n-        Utils.addToClasspath(new String[]{tempJimage.getAbsolutePath()});\n-        for (File file:tempJimage.listFiles()){\n-            if (file.isDirectory()){\n-                Utils.addToClasspath(new String[]{file.getAbsolutePath()});\n-            }\n-        }\n-        for (File file:tempJimage.listFiles()){\n-            if (file.isDirectory()){\n-                currentModule = file.getName();\n-                instrumenter.instrument(file, null);\n-            }\n-        }\n-    }\n-\n-    private String getJImageName(File jimage){\n-        String jimagename = jimage.getName();\n-        int pos = jimagename.lastIndexOf(\".\");\n-        if (pos > 0) {\n-            jimagename = jimagename.substring(0, pos);\n-        }\n-        return jimagename;\n-    }\n-\n-    public void generateTemplate(String[] files) throws IOException {\n-        if (instrumenter == null) {\n-            setDefaultInstrumenter();\n-        }\n-        for (String root : files) {\n-            instrumenter.instrument(new File(root), null);\n-        }\n-    }\n-\n-    public void finishWork() throws Exception {\n-        if (instrumenter == null) {\n-            throw new IllegalStateException(\"Instrumenter is not ready\");\n-        }\n-        instrumenter.finishWork();\n-        instrumenter = null;\n-    }\n-\n-    public void setDefaultInstrumenter() {\n-        if (instrumenter == null) {\n-            \/\/TODO\n-            instrumenter = null;\n-\/\/            instrumenter = new AbstractUniversalInstrumenter(true, true, plugin) {\n-\/\/                ClassMorph morph = new ClassMorph(\n-\/\/                        new InstrumentationParams(instrumentNative, instrumentField, instrumentAbstract, include, exclude, m_include, m_exclude, mode)\n-\/\/                        .setInstrumentAnonymous(instrumentAnonymous)\n-\/\/                        .setInstrumentSynthetic(instrumentSynthetic), template);\n-\/\/\n-\/\/                protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n-\/\/\/\/                    byte[] res = Arrays.copyOf(classData, classLen);\n-\/\/                    byte[] res = new byte[classLen];\n-\/\/                    System.arraycopy(classData, 0, res, 0, classLen);\n-\/\/                    morph.setCurrentModuleName(currentModule);\n-\/\/                    morph.morph(res, null, flushPath); \/\/ jdk1.5 support\n-\/\/                    return res;\n-\/\/                }\n-\/\/\n-\/\/                public void finishWork() {\n-\/\/                    morph.saveData(template, InstrumentationOptions.MERGE.MERGE);\n-\/\/                }\n-\/\/            };\n-        }\n-    }\n+    private static final List<String> SKIP_INSTR_OPTIONS = List.of(\n+            DSC_OUTPUT,\n+            DSC_CALLER_INCLUDE,\n+            DSC_CALLER_EXCLUDE,\n+            DSC_SAVE_BEGIN,\n+            DSC_SAVE_AT_END,\n+            DSC_FLUSH_CLASSES).stream().map(o -> o.name).collect(Collectors.toList());\n@@ -233,19 +94,4 @@\n-        return new EnvHandler(new OptionDescr[]{\n-                    \/\/        DSC_OUTPUT,\n-                    DSC_VERBOSE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TEMPLATE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TYPE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ABSTRACT,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_NATIVE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FIELD,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SYNTHETIC,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ANONYM,\n-                    ClassMorph.DSC_FLUSH_CLASSES,}, this);\n+        EnvHandler superHandler = super.defineHandler();\n+        List<OptionDescr> opts = superHandler.getValidOptions().stream()\n+                .filter(o -> !SKIP_INSTR_OPTIONS.contains(o.name)).collect(Collectors.toList());\n+        return new EnvHandler(opts.toArray(new OptionDescr[0]), this);\n@@ -253,162 +99,0 @@\n-\n-    @Override\n-    protected int handleEnv(EnvHandler opts) throws EnvHandlingException {\n-        files = opts.getTail();\n-        if (files == null) {\n-            throw new EnvHandlingException(\"No input files specified\");\n-        }\n-\n-        if (opts.isSet(DSC_VERBOSE)) {\n-            Utils.setLoggingLevel(Level.INFO);\n-        }\n-\n-        Utils.addToClasspath(files);\n-\n-        flushPath = opts.getValue(ClassMorph.DSC_FLUSH_CLASSES);\n-        if (\"none\".equals(flushPath)) {\n-            flushPath = null;\n-        }\n-        String abstractValue = opts.getValue(InstrumentationOptions.DSC_ABSTRACT);\n-        if (abstractValue.equals(\"off\")) {\n-            instrumentAbstract = false;\n-        } else if (abstractValue.equals(\"on\")) {\n-            instrumentAbstract = true;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_ABSTRACT.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + abstractValue + \"'\");\n-        }\n-\n-        String nativeValue = opts.getValue(InstrumentationOptions.DSC_NATIVE);\n-        if (nativeValue.equals(\"on\")) {\n-            instrumentNative = true;\n-        } else if (nativeValue.equals(\"off\")) {\n-            instrumentNative = false;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_NATIVE.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + nativeValue + \"'\");\n-        }\n-\n-        String fieldValue = opts.getValue(InstrumentationOptions.DSC_FIELD);\n-        if (fieldValue.equals(\"on\")) {\n-            instrumentField = true;\n-        } else if (fieldValue.equals(\"off\")) {\n-            instrumentField = false;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_FIELD.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + fieldValue + \"'\");\n-        }\n-\n-        String anonym = opts.getValue(InstrumentationOptions.DSC_ANONYM);\n-        if (anonym.equals(\"on\")) {\n-            instrumentAnonymous = true;\n-        } else { \/\/ off\n-            instrumentAnonymous = false;\n-        }\n-\n-        String synth = opts.getValue(InstrumentationOptions.DSC_SYNTHETIC);\n-        if (synth.equals(\"on\")) {\n-            instrumentSynthetic = true;\n-        } else { \/\/ off\n-            instrumentSynthetic = false;\n-        }\n-\n-        mode = InstrumentationOptions.InstrumentationMode.fromString(opts.getValue(InstrumentationOptions.DSC_TYPE));\n-        template = opts.getValue(InstrumentationOptions.DSC_TEMPLATE);\n-        File tmpl = new File(template);\n-        if (tmpl.isDirectory()) {\n-            throw new EnvHandlingException(\"'\" + template + \"' is a directory while expected template filename\");\n-        }\n-        if (tmpl.getParentFile() != null && !tmpl.getParentFile().exists()) {\n-            throw new EnvHandlingException(\"Template parent directory '\" + tmpl.getParentFile() + \"' doesn't exits\");\n-        }\n-\n-        include = InstrumentationOptions.handleInclude(opts);\n-        exclude = InstrumentationOptions.handleExclude(opts);\n-\n-        m_exclude = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleMExclude(opts);\n-        m_include = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleMInclude(opts);\n-\n-        com.sun.tdk.jcov.runtime.CollectDetect.enableInvokeCounts();\n-\n-        return SUCCESS_EXIT_CODE;\n-    }\n-\n-    public String[] getExclude() {\n-        return exclude;\n-    }\n-\n-    public void setExclude(String[] exclude) {\n-        this.exclude = exclude;\n-    }\n-\n-    public String[] getMExclude() {\n-        return m_exclude;\n-    }\n-\n-    public void setMExclude(String[] m_exclude) {\n-        this.m_exclude = exclude;\n-    }\n-\n-    public String getFlushPath() {\n-        return flushPath;\n-    }\n-\n-    public void setFlushPath(String flushPath) {\n-        this.flushPath = flushPath;\n-    }\n-\n-    public String[] getInclude() {\n-        return include;\n-    }\n-\n-    public void setInclude(String[] include) {\n-        this.include = include;\n-    }\n-\n-    public String[] getMInclude() {\n-        return m_include;\n-    }\n-\n-    public void setMInclude(String[] m_include) {\n-        this.m_include = m_include;\n-    }\n-\n-    public boolean isInstrumentAbstract() {\n-        return instrumentAbstract;\n-    }\n-\n-    public void setInstrumentAbstract(boolean instrumentAbstract) {\n-        this.instrumentAbstract = instrumentAbstract;\n-    }\n-\n-    public boolean isInstrumentField() {\n-        return instrumentField;\n-    }\n-\n-    public void setInstrumentField(boolean instrumentField) {\n-        this.instrumentField = instrumentField;\n-    }\n-\n-    public boolean isInstrumentNative() {\n-        return instrumentNative;\n-    }\n-\n-    public void setInstrumentNative(boolean instrumentNative) {\n-        this.instrumentNative = instrumentNative;\n-    }\n-\n-    public InstrumentationMode getMode() {\n-        return mode;\n-    }\n-\n-    public void setMode(InstrumentationMode mode) {\n-        this.mode = mode;\n-    }\n-\n-    public String getTemplate() {\n-        return template;\n-    }\n-\n-    public void setTemplate(String template) {\n-        this.template = template;\n-    }\n-\n-    final static OptionDescr DSC_VERBOSE =\n-            new OptionDescr(\"verbose\", \"Verbosity\", \"Enables verbose mode.\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/TmplGen.java","additions":28,"deletions":344,"binary":false,"changes":372,"status":"modified"},{"patch":"@@ -597,17 +597,17 @@\n-            try {\n-                plugin.instrument(classes, f -> {\n-                    try {\n-                        return Files.readAllBytes(in.resolve(f));\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                }, (c, d) -> {\n-                    try {\n-                        Files.write(out.resolve(c), d);\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                }, params);\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n+\/\/            try {\n+\/\/                plugin.instrument(classes, f -> {\n+\/\/                    try {\n+\/\/                        return Files.readAllBytes(in.resolve(f));\n+\/\/                    } catch (IOException e) {\n+\/\/                        throw new UncheckedIOException(e);\n+\/\/                    }\n+\/\/                }, (c, d) -> {\n+\/\/                    try {\n+\/\/                        Files.write(out.resolve(c), d);\n+\/\/                    } catch (IOException e) {\n+\/\/                        throw new UncheckedIOException(e);\n+\/\/                    }\n+\/\/                }, params);\n+\/\/            } catch (Exception e) {\n+\/\/                throw new RuntimeException(e);\n+\/\/            }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/insert\/AbstractUniversalInstrumenter.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -162,0 +162,5 @@\n+    public final static OptionDescr DSC_FLUSH_CLASSES =\n+            new OptionDescr(\"flush\", null, \"flush instrumented classes\",\n+                    OptionDescr.VAL_SINGLE, null, \"Specify path to directory, where to store instrumented classes.\\n\"\n+                    + \"Directory should exist. Classes will be saved in respect to their package hierarchy.\\n\"\n+                    + \"Default value is \\\"none\\\". Pushing it means you don't want to flush classes.\", \"none\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationOptions.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -39,1 +38,0 @@\n-import java.util.Collection;\n@@ -79,0 +77,7 @@\n+\n+\n+    public InstrumentationParams() {\n+        this(false, false, false, false, ABSTRACTMODE.NONE,\n+                new String[0], new String[0], new String[0], new String[0], InstrumentationMode.BLOCK);\n+    }\n+\n@@ -208,6 +213,1 @@\n-        return new InstrumentationPlugin.FilteringPlugin(plugin) {\n-            @Override\n-            protected boolean filter(String cls) {\n-                return isIncluded(cls);\n-            }\n-        };\n+        return new InstrumentationPlugin.FilteringPlugin(plugin, this::isIncluded);\n@@ -361,0 +361,62 @@\n+    public ABSTRACTMODE getInstrumentAbstract() {\n+        return instrumentAbstract;\n+    }\n+\n+    public String[] getSavesBegin() {\n+        return savesBegin;\n+    }\n+\n+    public String[] getSavesEnd() {\n+        return savesEnd;\n+    }\n+\n+    public InstrumentationParams setSavesBegin(String[] savesBegin) {\n+        this.savesBegin = savesBegin;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setSavesEnd(String[] savesEnd) {\n+        this.savesEnd = savesEnd;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setMode(InstrumentationMode mode) {\n+        this.mode = mode;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setCallerInclude(String callerInclude) {\n+        this.callerInclude = callerInclude;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setCallerExclude(String callerExclude) {\n+        this.callerExclude = callerExclude;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setCallerIncludes(String[] callerIncludes) {\n+        this.callerIncludes = callerIncludes;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setCallerExcludes(String[] callerExcludes) {\n+        this.callerExcludes = callerExcludes;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setInstrumentFields(boolean instrumentFields) {\n+        this.instrumentFields = instrumentFields;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setInstrumentNative(boolean instrumentNative) {\n+        this.instrumentNative = instrumentNative;\n+        return this;\n+    }\n+\n+    public InstrumentationParams setInstrumentAbstract(ABSTRACTMODE instrumentAbstract) {\n+        this.instrumentAbstract = instrumentAbstract;\n+        return this;\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationParams.java","additions":70,"deletions":8,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+import com.sun.tdk.jcov.util.Utils;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n@@ -28,0 +32,9 @@\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n@@ -30,0 +43,1 @@\n+import java.util.Map;\n@@ -31,2 +45,3 @@\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.jar.JarFile;\n@@ -34,0 +49,3 @@\n+import java.util.zip.ZipEntry;\n+\n+import static com.sun.tdk.jcov.util.Utils.isClassFile;\n@@ -40,1 +58,18 @@\n-    void instrument(Collection<String> classes, Function<String, byte[]> loader, BiConsumer<String, byte[]> saver,\n+    \/**\n+     * An identifier for template artifact.\n+     *\/\n+    String TEMPLATE_ARTIFACT = \"template.xml\";\n+    String CLASS_EXTENTION = \".class\";\n+    String MODULE_INFO_CLASS = \"module-info.class\";\n+\n+    \/**\n+     *\n+     * @param resources A collection of resource paths relative to root of the class hierarchy. '\/' is supposed to be\n+     *                  used as a file separator.\n+     * @param loader\n+     * @param saver\n+     * @param parameters\n+     * @throws Exception\n+     *\/\n+    void instrument(Collection<String> resources, ClassLoader loader,\n+                    BiConsumer<String, byte[]> saver,\n@@ -43,1 +78,13 @@\n-    void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception;\n+    \/**\n+     * Completes the instrumentation proccess and returns a map of instrumentation artifacts.\n+     * @see #TEMPLATE_ARTIFACT\n+     *\n+     * @return the artifact map. The artifacts are identifiable by a string. The artifacts are consumers of\n+     * OutputStream's.\n+     * @throws Exception\n+     *\/\n+    Map<String, Consumer<OutputStream>> complete() throws Exception;\n+\n+    default boolean isClass(String resource) {\n+        return resource.endsWith(CLASS_EXTENTION) && !resource.endsWith(MODULE_INFO_CLASS);\n+    }\n@@ -47,1 +94,7 @@\n-    abstract class FilteringPlugin implements InstrumentationPlugin {\n+    interface ModuleInstrumentationPlugin {\n+        String getModuleName(byte[] moduleInfo);\n+        byte[] addExports(List<String> exports, byte[] moduleInfo, ClassLoader loader);\n+        byte[] clearHashes(byte[] moduleInfo, ClassLoader loader);\n+    }\n+\n+    abstract class ProxyInstrumentationPlugin implements InstrumentationPlugin {\n@@ -50,1 +103,1 @@\n-        public FilteringPlugin(InstrumentationPlugin inner) {\n+        protected ProxyInstrumentationPlugin(InstrumentationPlugin inner) {\n@@ -54,6 +107,2 @@\n-        protected abstract boolean filter(String cls);\n-        @Override\n-        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n-                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n-            inner.instrument(classes.stream().filter(this::filter).collect(Collectors.toList()),\n-                    loader, saver, parameters);\n+        public InstrumentationPlugin getInner() {\n+            return inner;\n@@ -63,2 +112,2 @@\n-        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n-            inner.complete(templateStreamSupplier);\n+        public final Map<String, Consumer<OutputStream>> complete() throws Exception {\n+            return inner.complete();\n@@ -68,8 +117,2 @@\n-    interface ModuleImplant {\n-        \/\/TODO qualified exports?\n-        List<String> exports();\n-        Collection<String> classes();\n-        Function<String, byte[]> loader();\n-    }\n-\n-    abstract class ModuleImplantingPlugin implements InstrumentationPlugin {\n+    class FilteringPlugin extends ProxyInstrumentationPlugin {\n+        private final Predicate<String> filter;\n@@ -77,1 +120,4 @@\n-        public static final String MODULE_INFO_CLASS = \"module-info.class\";\n+        public FilteringPlugin(InstrumentationPlugin inner, Predicate<String> filter) {\n+            super(inner);\n+            this.filter = filter;\n+        }\n@@ -79,3 +125,18 @@\n-        public interface ModuleInstrumentationPlugin extends InstrumentationPlugin {\n-            String getModuleName(byte[] moduleInfo);\n-            byte[] addExports(List<String> exports, byte[] moduleInfo);\n+        @Override\n+        public void instrument(Collection<String> resources, ClassLoader loader,\n+                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n+            List<String> accepted = new ArrayList<>();\n+            List<String> rejected = new ArrayList<>();\n+            resources.forEach(r -> {\n+                if (filter.test(r)) accepted.add(r);\n+                else rejected.add(r);\n+            });\n+            getInner().instrument(accepted, loader, saver, parameters);\n+            rejected.forEach(c -> {\n+                try {\n+                    saver.accept(c,\n+                            loader.getResourceAsStream(c).readAllBytes());\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            });\n@@ -83,0 +144,1 @@\n+    }\n@@ -84,2 +146,8 @@\n-        private final ModuleInstrumentationPlugin inner;\n-        private final Function<String, ModuleImplant> implants;\n+    static Predicate<String> classNameFilter(InstrumentationParams params) {\n+        return r -> {\n+            if (isClassFile(r))\n+                return params.isIncluded(r.substring(0,\n+                        r.length() - Utils.FILE_TYPE.CLASS.name().length() - 1));\n+            else return true;\n+        };\n+    }\n@@ -87,3 +155,13 @@\n-        public ModuleImplantingPlugin(ModuleInstrumentationPlugin inner, Function<String, ModuleImplant> implants) {\n-            this.inner = inner;\n-            this.implants = implants;\n+    interface Source extends Closeable {\n+        \/\/paths relative to the result root\n+        Collection<String> resources() throws Exception;\n+        ClassLoader loader();\n+    }\n+\n+    class ImplantingPlugin extends ProxyInstrumentationPlugin {\n+        private final Source source;\n+\n+        \/\/TODO similar to ModuleImplantingPlugin have different implants for different locations somehow?\n+        public ImplantingPlugin(InstrumentationPlugin inner, Source source) {\n+            super(inner);\n+            this.source = source;\n@@ -93,1 +171,1 @@\n-        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n+        public void instrument(Collection<String> classes, ClassLoader loader,\n@@ -95,8 +173,14 @@\n-            inner.instrument(classes, loader, saver, parameters);\n-            String moduleName = inner.getModuleName(loader.apply(MODULE_INFO_CLASS));\n-            if(moduleName != null) {\n-                ModuleImplant implant = implants.apply(moduleName);\n-                if(implant != null) {\n-                    saver.accept(MODULE_INFO_CLASS, loader.apply(MODULE_INFO_CLASS));\n-                    for(String c : implant.classes()) saver.accept(c, implant.loader().apply(c));\n-                }\n+            getInner().instrument(classes, loader, saver, parameters);\n+            for(String r : source.resources()) saver.accept(r, source.loader().getResourceAsStream(r).readAllBytes());\n+        }\n+    }\n+\n+    \/\/TODO better be private\n+    class OverridingClassLoader extends URLClassLoader {\n+\n+        private static URL[] toURL(Path root) {\n+            try {\n+                return new URL[] {root.toUri().toURL()};\n+            } catch (MalformedURLException e) {\n+                \/\/should not happen since getting teh URL legally\n+                throw new RuntimeException(e);\n@@ -106,0 +190,11 @@\n+        private final ClassLoader backup;\n+\n+        public OverridingClassLoader(Path root, ClassLoader backup) {\n+            this(toURL(root), backup);\n+        }\n+\n+        public OverridingClassLoader(URL[] urls, ClassLoader backup) {\n+            super(urls);\n+            this.backup = backup;\n+        }\n+\n@@ -107,2 +202,11 @@\n-        public void complete(Supplier<OutputStream> template) throws Exception {\n-            inner.complete(template);\n+        public URL getResource(String name) {\n+            \/\/first try to find local resource, from teh current module\n+            URL resource = findResource(name);\n+            \/\/for module-info it does not make sense to look in other classloaders\n+            if(name.equals(MODULE_INFO_CLASS)) return resource;\n+            \/\/if none, try other modules\n+            if (resource == null) resource = backup.getResource(name);\n+            \/\/that should not happen during normal use\n+            \/\/if happens, refer to super, nothing else we can do\n+            if (resource == null) resource = super.getResource(name);\n+            return resource;\n@@ -112,3 +216,8 @@\n-    class ImplantingPlugin implements InstrumentationPlugin {\n-        private final Collection<String> implant;\n-        private final Function<String, byte[]> implantLoader;\n+    interface Destination extends Closeable {\n+        BiConsumer<String, byte[]> saver();\n+    }\n+\n+    \/**\n+     * A utility class which works with a given plugin in turms of file hierarchies.\n+     *\/\n+    class Instrumentation {\n@@ -117,5 +226,1 @@\n-        \/\/TODO similar to ModuleImplantingPlugin have different implants for different locations somehow?\n-        public ImplantingPlugin(InstrumentationPlugin inner,\n-                                Collection<String> implant, Function<String, byte[]> loader) {\n-            this.implant = implant;\n-            this.implantLoader = loader;\n+        public Instrumentation(InstrumentationPlugin inner) {\n@@ -125,0 +230,35 @@\n+        public void instrument(Source source, Destination destination,\n+                                     InstrumentationParams parameters) throws Exception {\n+            inner.instrument(source.resources(), source.loader(),\n+                    destination.saver(), parameters);\n+        }\n+    }\n+\n+    \/**\n+     * Helps to instrument modules.\n+     * @see #Instrumentation\n+     *\/\n+    class ModuleInstrumentation extends Instrumentation {\n+        private final ModuleInstrumentationPlugin modulePlugin;\n+\n+        public ModuleInstrumentation(InstrumentationPlugin inner, ModuleInstrumentationPlugin modulePlugin) {\n+            super(inner);\n+            this.modulePlugin = modulePlugin;\n+        }\n+\n+        public ModuleInstrumentationPlugin getModulePluign() {\n+            return modulePlugin;\n+        }\n+\n+        \/**\n+         * Take any required action needed to instrument a module. This implementation does not do anything.\n+         * @param moduleInfo\n+         * @param loader\n+         * @param destination\n+         * @throws Exception\n+         * @see ModuleInstrumentationPlugin\n+         *\/\n+        protected void proccessModule(byte[] moduleInfo, ClassLoader loader, BiConsumer<String, byte[]> destination)\n+                throws Exception {\n+        }\n+\n@@ -126,4 +266,16 @@\n-        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n-                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n-            inner.instrument(classes, loader, saver, parameters);\n-            implant.forEach(c -> saver.accept(c, implantLoader.apply(c)));\n+        public void instrument(Source source, Destination destination,\n+                               InstrumentationParams parameters) throws Exception {\n+            super.instrument(source, destination, parameters);\n+            byte[] moduleInfo = source.loader().getResourceAsStream(MODULE_INFO_CLASS).readAllBytes();\n+            proccessModule(moduleInfo, source.loader(), destination.saver());\n+        }\n+    }\n+\n+    class PathSource implements Source, Closeable {\n+\n+        private final ClassLoader loader;\n+        private final Path root;\n+\n+        public PathSource(ClassLoader backup, Path root) {\n+            this.loader = new OverridingClassLoader(root, backup);\n+            this.root = root;\n@@ -133,2 +285,10 @@\n-        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n-            inner.complete(templateStreamSupplier);\n+        public Collection<String> resources() throws Exception {\n+            if(Files.isDirectory(root))\n+                return Files.find(root, Integer.MAX_VALUE, (f, a) -> Files.isRegularFile(f))\n+                        .map(r -> root.relativize(r).toString())\n+                        .collect(Collectors.toList());\n+            else\n+                try (JarFile jar = new JarFile(root.toFile())) {\n+                    return jar.stream().filter(f -> !f.isDirectory())\n+                            .map(ZipEntry::getName).collect(Collectors.toList());\n+                }\n@@ -137,2 +297,48 @@\n-        protected InstrumentationPlugin inner() {\n-            return inner;\n+        @Override\n+        public ClassLoader loader() {\n+            return loader;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (loader instanceof Closeable) ((Closeable) loader).close();\n+        }\n+\n+        public boolean isModule() throws IOException {\n+            if (Files.isDirectory(root)) {\n+                return Files.exists(root.resolve(MODULE_INFO_CLASS));\n+            } else {\n+                try (JarFile jar = new JarFile(root.toFile())) {\n+                    return jar.stream().map(ZipEntry::getName).anyMatch(MODULE_INFO_CLASS::equals);\n+                }\n+            }\n+        }\n+    }\n+\n+    class PathDestination implements Destination, Closeable {\n+        private final Path root;\n+        private final FileSystem fs;\n+        private final BiConsumer<String, byte[]> saver;\n+\n+        public PathDestination(Path root) throws IOException {\n+            fs = Files.isDirectory(root) ? null : FileSystems.newFileSystem(root, null);\n+            this.root = Files.isDirectory(root) ? root : fs.getPath(\"\/\");\n+            saver = (s, bytes) -> {\n+                try {\n+                    Path f = PathDestination.this.root.resolve(s);\n+                    Files.createDirectories(f.getParent());\n+                    Files.write(f, bytes);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (fs != null) fs.close();\n+        }\n+\n+        @Override\n+        public BiConsumer<String, byte[]> saver() {\n+            return saver;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationPlugin.java","additions":264,"deletions":58,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n@@ -32,1 +31,4 @@\n-import com.sun.tdk.jcov.runtime.FileSaver;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.ModuleVisitor;\n@@ -34,0 +36,1 @@\n+import java.io.FileNotFoundException;\n@@ -37,1 +40,1 @@\n-import java.util.ArrayList;\n+import java.net.URL;\n@@ -40,0 +43,2 @@\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -41,2 +46,1 @@\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n+import java.util.function.Consumer;\n@@ -48,1 +52,2 @@\n-public class ASMInstrumentationPlugin implements InstrumentationPlugin {\n+public class ASMInstrumentationPlugin implements InstrumentationPlugin,\n+        InstrumentationPlugin.ModuleInstrumentationPlugin {\n@@ -51,2 +56,1 @@\n-    \/\/TODO prehaps support qualified exports\n-    private List<String> exports = new ArrayList<>();\n+\/\/    private String moduleName;\n@@ -55,2 +59,2 @@\n-    public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n-                           BiConsumer<String, byte[]> saver, InstrumentationParams parameters) {\n+    public void instrument(Collection<String> resources, ClassLoader loader,\n+                           BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws IOException {\n@@ -60,0 +64,2 @@\n+        URL miURL = loader.getResource(MODULE_INFO_CLASS);\n+        String moduleName = (miURL == null) ? null : getModuleName(miURL.openStream().readAllBytes());\n@@ -61,8 +67,20 @@\n-        classes.forEach(cls -> {\n-            try {\n-                \/\/TODO nulls\n-                byte[] instrumented = morph.morph(loader.apply(cls), null, null);\n-                \/\/TODO shoul never be null\n-                if(instrumented != null) saver.accept(cls, instrumented);\n-            } catch (IOException e) {\n-                \/\/todo should this even be thrown?\n+        morph.setCurrentModuleName(moduleName);\n+        for(String r : resources) {\n+            byte[] content = loader.getResourceAsStream(r).readAllBytes();\n+            if(isClass(r)) {\n+                byte[] instrumented = morph.morph(content, loader, null);\n+                \/\/TODO should never be null\n+                if(instrumented != null) saver.accept(r, instrumented);\n+            } else saver.accept(r, content);\n+        }\n+\/\/        moduleName = null;\n+    }\n+\n+    @Override\n+    public Map<String, Consumer<OutputStream>> complete() {\n+        return Map.of(TEMPLATE_ARTIFACT, out -> {\n+            try (XmlContext ctx = new XmlContext(out, data.getParams())) {\n+                \/\/TODO\n+                \/\/ctx.setSkipNotCoveredClasses(agentdata);\n+                data.xmlGen(ctx);\n+            } catch (FileNotFoundException e) {\n@@ -75,6 +93,12 @@\n-    public void complete(Supplier<OutputStream> templateStreamSupplier) throws IOException {\n-        try (XmlContext ctx = new XmlContext(templateStreamSupplier.get(), data.getParams())) {\n-            \/\/TODO\n-            \/\/ctx.setSkipNotCoveredClasses(agentdata);\n-            data.xmlGen(ctx);\n-        }\n+    public String getModuleName(byte[] moduleInfo) {\n+        AtomicReference<String> moduleName = new AtomicReference<>(null);\n+        ClassReader cr = new ClassReader(moduleInfo);\n+        ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, getClass().getClassLoader());\n+        cr.accept( new ClassVisitor(ASMUtils.ASM_API_VERSION, cw) {\n+            @Override\n+            public ModuleVisitor visitModule(String name, int access, String version) {\n+                moduleName.set(name);\n+                return null;\n+            }\n+        }, 0);\n+        return moduleName.get();\n@@ -82,0 +106,20 @@\n+\n+    @Override\n+    public byte[] addExports(List<String> exports, byte[] moduleInfo, ClassLoader loader) {\n+        return ClassMorph.addExports(moduleInfo, exports, loader);\n+    }\n+\n+    @Override\n+    public byte[] clearHashes(byte[] moduleInfo, ClassLoader loader) {\n+        return ClassMorph.clearHashes(moduleInfo, loader);\n+    }\n+\n+\/\/    @Override\n+\/\/    public void instrumentModuleInfo(ClassLoader loader, BiConsumer<String, byte[]> saver, List<String> expports,\n+\/\/                                     boolean clearHashes, InstrumentationParams parameters) throws IOException {\n+\/\/        byte[] mi = loader.getResourceAsStream(MODULE_INFO_CLASS).readAllBytes();\n+\/\/        moduleName = getModuleName(mi);\n+\/\/        if(expports != null && !expports.isEmpty()) mi = addExports(expports, mi, loader);\n+\/\/        if(clearHashes) mi = clearHashes(mi, loader);\n+\/\/        saver.accept(MODULE_INFO_CLASS, mi);\n+\/\/    }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ASMInstrumentationPlugin.java","additions":68,"deletions":24,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -143,1 +144,1 @@\n-                \/\/&& params.isIncluded(className);\n+\/\/                && params.isIncluded(className);\n@@ -300,1 +301,1 @@\n-    public byte[] clearHashes(byte[] moduleInfo, ClassLoader loader) {\n+    public static byte[] clearHashes(byte[] moduleInfo, ClassLoader loader) {\n@@ -314,1 +315,15 @@\n-    public byte[] addExports(byte[] moduleInfo, List<String> exports, ClassLoader loader) {\n+    public static String getModuleName(byte[] moduleInfo) {\n+        AtomicReference<String> moduleName = new AtomicReference<>(null);\n+        ClassReader cr = new ClassReader(moduleInfo);\n+        ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, ClassMorph.class.getClassLoader());\n+        cr.accept( new ClassVisitor(ASMUtils.ASM_API_VERSION, cw) {\n+            @Override\n+            public ModuleVisitor visitModule(String name, int access, String version) {\n+                moduleName.set(name);\n+                return null;\n+            }\n+        }, 0);\n+        return moduleName.get();\n+    }\n+\n+    public static byte[] addExports(byte[] moduleInfo, List<String> exports, ClassLoader loader) {\n@@ -711,5 +726,0 @@\n-    public final static OptionDescr DSC_FLUSH_CLASSES =\n-            new OptionDescr(\"flush\", null, \"flush instrumented classes\",\n-                    OptionDescr.VAL_SINGLE, null, \"Specify path to directory, where to store instrumented classes.\\n\"\n-                    + \"Directory should exist. Classes will be saved in respect to their package hierarchy.\\n\"\n-                    + \"Default value is \\\"none\\\". Pushing it means you don't want to flush classes.\", \"none\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ClassMorph.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -230,28 +230,0 @@\n-        if (loader instanceof JREInstr.StaticJREInstrClassLoader) {\n-            InputStream in = getInputStreamForName(clName, loader, false, \".class\");\n-\n-            if (in == null) {\n-                in = getInputStreamForName(clName, ClassLoader.getSystemClassLoader(), false, \".class\");\n-\n-                if (in == null) {\n-                    throw new IOException(\"Can't read class \" + clName + \" from classloader \" + loader);\n-                }\n-\n-                ClassReader cr = new OffsetLabelingClassReader(in);\n-                classInfo = new ClassInfo(cr.getSuperName(), cr.getInterfaces());\n-                try{\n-                    in.close();\n-                }\n-                catch (Throwable ignore){}\n-                return classInfo;\n-            }\n-\n-            ClassReader cr = new OffsetLabelingClassReader(in);\n-            classInfo = new ClassInfo(cr.getSuperName(), cr.getInterfaces());\n-            try{\n-                in.close();\n-            }\n-            catch (Throwable ignore){}\n-            return classInfo;\n-        }\n-\n@@ -333,0 +305,1 @@\n+            ignore.printStackTrace();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/OverriddenClassWriter.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -119,0 +119,4 @@\n+    public List<OptionDescr> getValidOptions() {\n+        return validOptions;\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/tools\/EnvHandler.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,5 @@\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+import java.io.BufferedWriter;\n@@ -42,0 +47,1 @@\n+import java.util.Arrays;\n@@ -43,0 +49,1 @@\n+import java.util.function.Predicate;\n@@ -45,0 +52,4 @@\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n@@ -169,0 +180,57 @@\n+    public static void jar(Path dir, Path dest, Predicate<Path> filter) throws IOException {\n+        try(ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(dest))) {\n+            Files.find(dir, Integer.MAX_VALUE, (p, a) -> true).forEach(p -> {\n+                try {\n+                    if(Files.isRegularFile(p) && filter.test(p)) {\n+                        out.putNextEntry(new ZipEntry(dir.relativize(p).toString()));\n+                        out.write(Files.readAllBytes(p));\n+                        out.closeEntry();\n+                    }\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            });\n+\/\/            out.putNextEntry(new ZipEntry(\"META-INF\/MANIFEST.MF\"));\n+            out.closeEntry();\n+        }\n+    }\n+    public static void unjar(Path src, Path dest) throws IOException {\n+        ZipFile zip = new ZipFile(src.toFile());\n+        zip.stream().forEach(e -> {\n+            try {\n+                Path p = dest.resolve(e.getName());\n+                Files.createDirectories(p.getParent());\n+                try(OutputStream out = Files.newOutputStream(p)) {\n+                    out.write(zip.getInputStream(e).readAllBytes());\n+                }\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        });\n+    }\n+    public static void javac(List<Path> classes) {\n+        JavaCompiler jc = ToolProvider.getSystemJavaCompiler();\n+        StandardJavaFileManager fm = jc.getStandardFileManager(null, null, null);\n+        Iterable<? extends JavaFileObject> cu =\n+                fm.getJavaFileObjectsFromFiles(classes.stream().map(Path::toFile).collect(Collectors.toList()));\n+        jc.getTask(null, fm, null, null, null, cu).call();\n+\/\/        List<String> command = new ArrayList<>();\n+\/\/        command.add(System.getProperty(\"java.home\") + File.separator + \"bin\" + File.separator + )\n+    }\n+    public static void genModuleInfo(Path toDir, String name,\n+                                  List<String> requires,\n+                                  List<String> exports) throws IOException {\n+        Path mi = toDir.resolve(\"module-info.java\");\n+        try(BufferedWriter out = Files.newBufferedWriter(mi)) {\n+            out.write(\"module \" + name + \" {\");out.newLine();\n+            for(String r : requires) {\n+                out.write(\"requires \" + r + \";\"); out.newLine();\n+            }\n+            for(String e: exports) {\n+                out.write(\"exports \" + e + \";\"); out.newLine();\n+            }\n+            out.write(\"}\"); out.newLine();\n+        }\n+        javac(List.of(mi));\n+        Files.delete(mi);\n+    }\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/Util.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+package com.sun.tdk.jcov.instrument.exec;\n+\n+import com.sun.tdk.jcov.Exec;\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataPackage;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.Util;\n+import com.sun.tdk.jcov.instrument.instr.UserCode;\n+import com.sun.tdk.jcov.io.Reader;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class ExecTest {\n+    Path test_dir;\n+    Path output_dir;\n+    Path result;\n+    Path template;\n+    Path log;\n+    Path data_dir;\n+\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        System.setProperty(\"jcov.selftest\", \"true\");\n+        data_dir = Files.createTempDirectory(\"instr_test\");\n+        result = data_dir.resolve(\"result.xml\");\n+        template = data_dir.resolve(\"template.xml\");\n+        log = data_dir.resolve(\"log\");\n+        test_dir = data_dir.resolve(\"instr_test\");\n+        output_dir = data_dir.resolve(\"instr_test_output\");\n+        System.out.println(\"data dir = \" + data_dir);\n+    }\n+    @Test\n+    public void testExec() throws IOException, FileFormatException {\n+        String runtime = Arrays.stream(System.getProperty(\"java.class.path\").split(File.pathSeparator))\n+                .peek(System.out::println)\n+                .filter(s -> s.endsWith(\"jcov_file_saver.jar\")).findAny().get();\n+        new Util(test_dir).copyBytecode(UserCode.class.getName());\n+        \/\/java -jar JCOV_BUILD\/jcov_3.0\/jcov.jar Exec -product cl_test -productOutput cl_test_instr -rt JCOV_BUILD\/jcov_3.0\/jcov_network_saver.jar -command \"java -cp cl_test com.sun.tdk.jcov.instrument.instr.UserCode 1\"\n+        String javaCommand = System.getProperty(\"java.home\") + File.separator + \"bin\" + File.separator + \"java\" +\n+                (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\") ? \".exe\" : \"\") +\n+                \" -cp \" + output_dir.toString() + \/\/\" -output \" + result.toString()  +\n+                \" com.sun.tdk.jcov.instrument.instr.UserCode 1\";\n+        List<String> params = List.of(\"-product\", test_dir.toString(), \"-productOutput\", output_dir.toString(),\n+                \"-rt\", runtime,\n+                \"-output\", result.toString(),\n+                \"-t\", template.toString(),\n+                \"-out.file\", log.toString(),\n+                \"-command\", javaCommand);\n+        System.out.println(\"Running Exec with\");\n+        System.out.println(params.stream().collect(Collectors.joining(\" \")));\n+        new Exec().run(params.toArray(new String[0]));\n+        DataRoot data = Reader.readXML(result.toString());\n+        DataPackage dp =\n+                data.getPackages().stream()\n+                        .filter(p -> p.getName().equals(\"com\/sun\/tdk\/jcov\/instrument\/instr\")).findAny().get();\n+        DataMethod dm = dp\n+                .getClasses().stream().filter(c -> c.getName().equals(\"UserCode\")).findAny().get()\n+                .getMethods().stream().filter(m -> m.getName().equals(\"main\")).findAny().get();\n+        assertTrue(dm.getSlot() > 0);\n+        assertFalse(dp\n+                .getClasses().stream().filter(c -> c.getName().equals(\"InstrTest\")).findAny().isPresent());\n+    }\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        Util.rmRF(data_dir);\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/exec\/ExecTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tdk.jcov.instrument.DataClass;\n@@ -30,0 +31,1 @@\n+import com.sun.tdk.jcov.instrument.DataPackage;\n@@ -36,0 +38,1 @@\n+import org.testng.annotations.BeforeMethod;\n@@ -38,0 +41,1 @@\n+import java.io.File;\n@@ -40,0 +44,1 @@\n+import java.nio.file.Files;\n@@ -41,1 +46,0 @@\n-import java.nio.file.Paths;\n@@ -45,0 +49,1 @@\n+import static org.testng.Assert.assertFalse;\n@@ -48,0 +53,2 @@\n+    Path implant_dir;\n+    Path implant_jar;\n@@ -49,0 +56,1 @@\n+    Path test_zip;\n@@ -54,1 +62,3 @@\n-        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n+        Path data_dir = Files.createTempDirectory(\"instr_test\");\n+        implant_dir = data_dir.resolve(\"instr_implant\");\n+        implant_jar = data_dir.resolve(\"instr_implant.jar\");\n@@ -56,0 +66,1 @@\n+        test_zip = data_dir.resolve(\"instr_test.jar\");\n@@ -57,0 +68,4 @@\n+        template = test_dir.resolve(\"template.xml\");\n+    }\n+    @BeforeMethod\n+    public void rm() throws IOException {\n@@ -58,1 +73,0 @@\n-        template = test_dir.resolve(\"template.lst\");\n@@ -60,1 +74,1 @@\n-    \/\/@Test\n+\/\/    @Test\n@@ -70,1 +84,1 @@\n-        run();\n+        run(test_dir);\n@@ -80,1 +94,1 @@\n-        params.add(\"UserCode\");\n+        params.add(UserCode.class.getName());\n@@ -85,1 +99,61 @@\n-        run();\n+        run(test_dir);\n+    }\n+    @Test\n+    public void instrumentJar() throws IOException, InterruptedException, FileFormatException,\n+            ClassNotFoundException, InvocationTargetException, NoSuchMethodException,\n+            IllegalAccessException, InstantiationException {\n+        Path classes = test_dir.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        new Util(classes).copyBytecode(UserCode.class.getName(), InstrTest.class.getName());\n+        Util.jar(classes, test_zip, p -> true);\n+        Util.rmRF(classes);\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(\"-i\");\n+        params.add(UserCode.class.getName());\n+        params.add(test_zip.toString());\n+        new Instr().run(params.toArray(new String[0]));\n+        Util.unjar(test_zip, classes);\n+        testInstrumentation();\n+        run(classes);\n+    }\n+    @Test\n+    public void implantTest() throws IOException, FileFormatException, ClassNotFoundException,\n+            InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        new Util(test_dir).copyBytecode(UserCode.class.getName());\n+        new Util(implant_dir).copyBytecode(InstrTest.class.getName());\n+        Files.write(implant_dir.resolve(\"some.properties\"), \"some.property=value\\n\".getBytes());\n+        Util.jar(implant_dir, implant_jar, p -> true);\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(\"-implantrt\");\n+        params.add(implant_jar.toString());\n+        params.add(test_dir.toString());\n+        new Instr().run(params.toArray(new String[0]));\n+        testInstrumentation();\n+        assertTrue(Files.exists(test_dir.\n+                resolve(InstrTest.class.getName().replace('.', File.separatorChar) + \".class\")));\n+        assertTrue(Files.exists(test_dir.resolve(\"some.properties\")));\n+        assertFalse(Files.exists(test_dir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\")));\n+        run(test_dir);\n+    }\n+    @Test\n+    public void moduleTest() throws Exception {\n+        new Util(test_dir).copyBytecode(UserCode.class.getName());\n+        Util.genModuleInfo(test_dir, \"test\", List.of(), List.of());\n+        new Util(implant_dir).copyBytecode(InstrTest.class.getName());\n+        Files.write(implant_dir.resolve(\"some.properties\"), \"some.property=value\\n\".getBytes());\n+        Util.jar(implant_dir, implant_jar, p -> true);\n+        Instr instr = new Instr();\n+        instr.instrumentFiles(new String[] {test_dir.toString()}, null, implant_jar.toString());\n+        instr.setTemplate(template.toString());\n+        instr.finishWork(template.toString());\n+        testInstrumentation();\n+        assertTrue(Files.exists(test_dir.\n+                resolve(InstrTest.class.getName().replace('.', File.separatorChar) + \".class\")));\n+        assertTrue(Files.exists(test_dir.resolve(\"some.properties\")));\n+        assertTrue(Files.exists(test_dir.resolve(\"module-info.class\")));\n+        assertFalse(Files.exists(test_dir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\")));\n+        run(test_dir);\n@@ -89,2 +163,4 @@\n-        DataMethod dm =\n-                data.getPackages().stream().filter(p -> p.getName().equals(\"com\/sun\/tdk\/jcov\/instrument\/instr\")).findAny().get()\n+        DataPackage dp =\n+                data.getPackages().stream()\n+                        .filter(p -> p.getName().equals(\"com\/sun\/tdk\/jcov\/instrument\/instr\")).findAny().get();\n+        DataMethod dm = dp\n@@ -95,0 +171,2 @@\n+        assertFalse(dp\n+                .getClasses().stream().filter(c -> c.getName().equals(\"InstrTest\")).findAny().isPresent());\n@@ -97,2 +175,1 @@\n-\/\/    @Test(dependsOnMethods = \"instrumentDir\")\n-    public void run() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n+    public void run(Path test_dir) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n@@ -107,0 +184,3 @@\n+        Util.rmRF(test_zip);\n+        Util.rmRF(implant_dir);\n+        Util.rmRF(implant_jar);\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/instr\/InstrTest.java","additions":91,"deletions":11,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.time.LocalDateTime;\n@@ -57,0 +58,2 @@\n+    Path template;\n+    Path result;\n@@ -81,0 +84,6 @@\n+        System.out.println(\"JRE: \" + testJRE);\n+        template = Path.of(System.getProperty(\"user.dir\")).resolve(\"template.xml\");\n+        result = Path.of(System.getProperty(\"user.dir\")).resolve(\"result.xml\");\n+        Files.deleteIfExists(template);\n+        Files.deleteIfExists(result);\n+        System.out.println(\"Template: \" + template);\n@@ -91,0 +100,2 @@\n+                \"-im\", \"java.desktop\",\n+                \"-exclude\", LocalDateTime.class.getName(),\n@@ -95,0 +106,12 @@\n+        \/\/no other modules but java.base and java.desktopm\n+        assertEquals(Files.readAllLines(template)\n+                .stream()\n+                .filter(s -> s.trim().startsWith(\"<package\"))\n+                .filter(s -> !s.contains(\"moduleName=\\\"java.base\\\"\"))\n+                .filter(s -> !s.contains(\"moduleName=\\\"java.desktop\\\"\"))\n+                .count(), 0);\n+        \/\/no java.time.LocalDateTime\n+        assertEquals(Files.readAllLines(template)\n+                .stream()\n+                .filter(s -> s.trim().startsWith(\"<class name=\\\"LocalDateTime\\\"\"))\n+                .count(), 0);\n@@ -127,1 +150,2 @@\n-        Files.deleteIfExists(Paths.get(\"result.xml\"));\n+        Files.deleteIfExists(template);\n+        Files.deleteIfExists(result);\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/jreinstr\/JREInstrTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.tmplgen;\n+\n+import com.sun.tdk.jcov.Instr;\n+import com.sun.tdk.jcov.TmplGen;\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataPackage;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.Util;\n+import com.sun.tdk.jcov.instrument.instr.UserCode;\n+import com.sun.tdk.jcov.io.Reader;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.testng.Assert.*;\n+\n+public class TmplGenTest {\n+    Path test_dir;\n+    Path test_zip;\n+    Path template;\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        System.setProperty(\"jcov.selftest\", \"true\");\n+        Path data_dir = Files.createTempDirectory(\"instr_test\");\n+        test_dir = data_dir.resolve(\"instr_test\");\n+        test_zip = data_dir.resolve(\"instr_test.jar\");\n+        System.out.println(\"test dir = \" + test_dir);\n+        template = test_dir.resolve(\"template.xml\");\n+    }\n+    @BeforeMethod\n+    public void rm() throws IOException {\n+        Util.rmRF(test_dir);\n+    }\n+\/\/    @Test\n+    public void instrumentClass() {\n+    }\n+    @Test\n+    public void instrumentDir() throws IOException, FileFormatException {\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(\"-i\");\n+        params.add(UserCode.class.getName());\n+        new Util(test_dir).copyBytecode(UserCode.class.getName(), TmplGenTest.class.getName());\n+        int classSize = classSize(UserCode.class.getName());\n+        params.add(test_dir.toString());\n+        new TmplGen().run(params.toArray(new String[0]));\n+        testInstrumentation();\n+        assertEquals(classSize(UserCode.class.getName()), classSize);\n+    }\n+\n+    private int classSize(String name) throws IOException {\n+        return Files.readAllBytes(test_dir.resolve(name.replace('.', File.separatorChar) + \".class\")).length;\n+    }\n+\n+    @Test\n+    public void instrumentJar() throws IOException, FileFormatException {\n+        Path classes = test_dir.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        new Util(classes).copyBytecode(UserCode.class.getName(), TmplGenTest.class.getName());\n+        Util.jar(classes, test_zip, p -> true);\n+        Util.rmRF(classes);\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(\"-i\");\n+        params.add(UserCode.class.getName());\n+        params.add(test_zip.toString());\n+        new Instr().run(params.toArray(new String[0]));\n+        Util.unjar(test_zip, classes);\n+        testInstrumentation();\n+    }\n+    private void testInstrumentation() throws FileFormatException {\n+        DataRoot data = Reader.readXML(template.toString());\n+        DataPackage dp =\n+                data.getPackages().stream()\n+                        .filter(p -> p.getName().equals(\"com\/sun\/tdk\/jcov\/instrument\/instr\")).findAny().get();\n+        DataMethod dm = dp\n+                        .getClasses().stream().filter(c -> c.getName().equals(\"UserCode\")).findAny().get()\n+                        .getMethods().stream().filter(m -> m.getName().equals(\"main\")).findAny().get();\n+        int method_slot = dm.getSlot();\n+        assertTrue(dm.getSlot() > 0);\n+        assertFalse(dp\n+                .getClasses().stream().filter(c -> c.getName().equals(\"InstrTest\")).findAny().isPresent());\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        Util.rmRF(test_dir);\n+        Util.rmRF(test_zip);\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/tmplgen\/TmplGenTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"}]}