{"files":[{"patch":"@@ -1,870 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov;\n-\n-import com.sun.tdk.jcov.constants.MiscConstants;\n-import com.sun.tdk.jcov.instrument.*;\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n-import com.sun.tdk.jcov.runtime.AgentSocketSaver;\n-import com.sun.tdk.jcov.runtime.Collect;\n-import com.sun.tdk.jcov.runtime.CollectDetect;\n-import com.sun.tdk.jcov.runtime.FileSaver;\n-import com.sun.tdk.jcov.runtime.JCovSaver;\n-import com.sun.tdk.jcov.runtime.PropertyFinder;\n-import com.sun.tdk.jcov.runtime.SaverDecorator;\n-import com.sun.tdk.jcov.tools.EnvHandler;\n-import com.sun.tdk.jcov.tools.JCovTool;\n-import com.sun.tdk.jcov.tools.OptionDescr;\n-import com.sun.tdk.jcov.util.Utils;\n-import java.io.*;\n-import java.lang.instrument.*;\n-import java.lang.instrument.Instrumentation;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.nio.charset.Charset;\n-import java.security.ProtectionDomain;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Locale;\n-import java.util.Set;\n-import java.util.Timer;\n-import java.util.TimerTask;\n-import java.util.logging.FileHandler;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * @author Dmitry Fazunenko\n- * @author Alexey Fedorchenko\n- *\/\n-public class Agent extends JCovTool {\n-\n-    private boolean detectInternal;\n-    private boolean classesReload;\n-    private boolean instrumentField;\n-    private boolean instrumentAbstract;\n-    private boolean instrumentNative;\n-    private boolean instrumentAnonymous = true;\n-    private boolean instrumentSynthetic = true;\n-    private String[] include;\n-    private String[] exclude;\n-    private String[] m_include;\n-    private String[] m_exclude;\n-    private String[] callerInclude;\n-    private String[] callerExclude;\n-    private String[] fm;\n-    private String[] saveBegin;\n-    private String[] saveEnd;\n-    private String template;\n-    private String filename;\n-    private String flushPath;\n-    private InstrumentationOptions.InstrumentationMode mode;\n-    private InstrumentationOptions.MERGE merge;\n-    private boolean grabberSaver = false;\n-\n-    static {\n-        Utils.initLogger();\n-        logger = Logger.getLogger(Agent.class.getName());\n-    }\n-    private final static Logger logger;\n-    private static ClassMorph classMorph;\n-    private String host;\n-    private int port;\n-    private static final Object LOCK = new Object();\n-\n-    private static class SynchronizedSaverDecorator implements SaverDecorator {\n-\n-        private JCovSaver wrap;\n-\n-        public SynchronizedSaverDecorator(JCovSaver wrap) {\n-            init(wrap);\n-        }\n-\n-        @Override\n-        public final void init(JCovSaver saver) {\n-            this.wrap = saver;\n-        }\n-\n-        public void saveResults() {\n-            synchronized (LOCK) {\n-                wrap.saveResults();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * ClassFileTransformer implementation. Gets classfile binary data from VM\n-     * and runs ClassMorph.morph method.\n-     *\/\n-    private static class Tr implements ClassFileTransformer {\n-\n-        \/**\n-         * Path to flush instrumented classfiles to. Null means that\n-         * instrumented classfiles should not be flushed.\n-         *\/\n-        private final String flushpath;\n-        \/**\n-         * Transformer name. Is not used.\n-         *\/\n-        private final String trname;\n-        \/**\n-         * Can turn off agent instrumentation\n-         *\/\n-        private boolean ignoreLoads = true;\n-\n-        \/**\n-         * Creates new Tr instance\n-         *\n-         * @param trname Transformer name. Is not used.\n-         * @param flushpath Path to flush instrumented classfiles to. Null means\n-         * that instrumented classfiles should not be flushed.\n-         *\/\n-        public Tr(String trname, String flushpath) {\n-            this.trname = trname;\n-            this.flushpath = flushpath;\n-        }\n-\n-        \/**\n-         * transform method implementation\n-         *\n-         * @param loader\n-         * @param className\n-         * @param classBeingRedefined\n-         * @param protectionDomain\n-         * @param classfileBuffer\n-         * @return instrumented classfile binary data (if ignoreLoads is not set\n-         * to true, classfileBuffer will be returned otherwise). If collect is\n-         * not enabled - null is returned.\n-         *\/\n-        public byte[] transform(ClassLoader loader,\n-                String className,\n-                Class<?> classBeingRedefined,\n-                ProtectionDomain protectionDomain,\n-                byte[] classfileBuffer) {\n-            synchronized (LOCK) {\n-                if (Collect.enabled == false) {\n-                    return null; \/\/ signals to the VM that no changes were done\n-                }\n-\n-                \/\/ no need to enter when Collect is disabled\n-                CollectDetect.enterInstrumentationCode(); \/\/ ensuring that instrumenting will not influence on coverage data\n-\n-                try {\n-                    if (ignoreLoads) {\n-                        logger.log(Level.INFO, \"Ignore for now {0}\", className);\n-                    } else {\n-                        logger.log(Level.INFO, \"Try to transform {0}\", className);\n-\n-                        byte[] newBuff = classMorph.morph(classfileBuffer, loader, flushpath);\n-                        return newBuff;\n-                    }\n-                } catch (Throwable e) {\n-                    logger.log(Level.SEVERE, \"Adaption failed for {0} with :{1}\", new Object[]{className, e});\n-                    e.printStackTrace();\n-                } finally {\n-                    CollectDetect.leaveInstrumentationCode(); \/\/ release instrumentation lock\n-                }\n-                return null;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Class for listening agent commands\n-     *\/\n-    private static class CommandThread extends Thread {\n-\n-        \/**\n-         * Agent commands\n-         *\/\n-        public static enum COMMAND {\n-\n-            SAVE {\n-                String cmd() {\n-                    return \"save\";\n-                }\n-            },\n-            SAVED {\n-                String cmd() {\n-                    return \"saved\";\n-                }\n-            },\n-            EXIT {\n-                String cmd() {\n-                    return \"exit\";\n-                }\n-            },\n-            EXIT_WITHOUT_SAVE {\n-                String cmd() {\n-                    return \"exitWithoutSave\".toLowerCase();\n-                }\n-            },\n-            AUTOSAVE_DISABLED {\n-                String cmd() {\n-                    return \"autosave disabled\";\n-                }\n-            };\n-\n-            abstract String cmd();\n-        }\n-        \/**\n-         * Port to listen incoming messages\n-         *\/\n-        private int port;\n-        \/**\n-         * Instrumentation params\n-         *\/\n-        private InstrumentationParams params;\n-\n-        \/**\n-         * Creates CommandThread instance\n-         *\n-         * @param port Port to listen incoming messages\n-         * @param params Instrumentation params\n-         *\/\n-        public CommandThread(int port, InstrumentationParams params) {\n-            this.port = port;\n-            this.params = params;\n-            setDaemon(true);\n-        }\n-\n-        @Override\n-        public void run() {\n-            while (true) {\n-                try {\n-                    ServerSocket sock = new ServerSocket(port);\n-                    Socket s = sock.accept();\n-\/\/                    System.out.println(\"Accepted\");\n-                    InputStream is = s.getInputStream();\n-                    byte[] buff = new byte[1024];\n-                    int l;\n-                    String rest = \"\";\n-                    while ((l = is.read(buff)) > 0) {\n-                        String msg = rest + new String(buff, 0, l, Charset.defaultCharset());\n-\/\/                        System.out.println(\"Message: \" + msg);\n-                        rest = performTask(msg, s);\n-                    }\n-                    sock.close();\n-                } catch (IOException ex) {\n-                    logger.log(Level.SEVERE, \"Network IOException\", ex);\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Parse and execute incoming message\n-         *\n-         * @param msg message\n-         * @param sock socket\n-         * @return exit code\n-         * @throws IOException\n-         *\/\n-        private String performTask(String msg, Socket sock) throws IOException {\n-            Pattern p = Pattern.compile(\"\\\\p{Space}*(\\\\p{Digit}+).*\");\n-            msg = msg.toLowerCase(Locale.getDefault());\n-            PrintStream ps = new PrintStream(sock.getOutputStream(), false, \"UTF-8\");\n-            while (msg.length() > 0) {\n-                msg = msg.trim();\n-                COMMAND cmd = nextCommand(msg);\n-                if (cmd == null) {\n-                    break;\n-                } else {\n-                    switch (cmd) {\n-                        case SAVE:\n-                            msg = msg.substring(cmd.cmd().length());\n-                            if (Collect.enabled) {\n-                                Collect.disable();\n-                                Collect.saveResults();\n-                                params.enable();\n-                            }\n-                            ps.print(COMMAND.SAVED.cmd());\n-                            ps.flush();\n-                            break;\n-                        case EXIT:\n-                            msg = msg.substring(cmd.cmd().length());\n-                            Matcher m = p.matcher(msg);\n-                            int exitCode = 0;\n-                            if (m.matches()) {\n-                                exitCode = Integer.parseInt(m.group(1));\n-                            }\n-                            System.exit(exitCode);\n-                            break;\n-                        case EXIT_WITHOUT_SAVE:\n-                            msg = msg.substring(cmd.cmd().length());\n-                            m = p.matcher(msg);\n-                            exitCode = 0;\n-                            if (m.matches()) {\n-                                exitCode = Integer.parseInt(m.group(1));\n-                            }\n-                            FileSaver.setDisableAutoSave(true);\n-                            ps.print(COMMAND.AUTOSAVE_DISABLED.cmd());\n-                            ps.flush();\n-                            System.exit(exitCode);\n-                            break;\n-                    }\n-                }\n-            }\n-\n-            return msg;\n-        }\n-\n-        \/**\n-         * Parse incomming message and return COMMAND value\n-         *\n-         * @param msg message to parse\n-         * @return associated COMMAND value\n-         *\/\n-        private COMMAND nextCommand(String msg) {\n-            String foundPref = \"\";\n-            COMMAND found = null;\n-\n-            for (COMMAND c : COMMAND.values()) {\n-                if (msg.startsWith(c.cmd()) && foundPref.length() < c.cmd().length()) {\n-                    found = c;\n-                    foundPref = c.cmd();\n-                }\n-            }\n-\n-            return found;\n-        }\n-    }\n-\n-    \/**\n-     * javaagent entry point\n-     *\n-     * @param agentArgs\n-     * @param instArg\n-     * @throws Exception\n-     *\/\n-    public static void premain(String agentArgs, Instrumentation instArg) {\n-\n-        \/\/ handling JCovTool\n-\n-        \/\/ This method manages CLI handling for Agent tool.\n-        \/\/ If any change is performed here - check JCovCMDTool CLI handling logic.\n-\n-        Agent tool = new Agent();\n-\n-        EnvHandler handler = tool.defineHandler();\n-\n-        try {\n-            \/\/ proccess cmd options\n-            if (agentArgs == null) {\n-                agentArgs = \"\";\n-            }\n-            handler.parseCLIArgs(EnvHandler.parseAgentString(agentArgs));\n-            tool.handleEnv(handler);\n-            if (handler.isSet(EnvHandler.PRINT_ENV)) {\n-                handler.printEnv();\n-            }\n-        } catch (EnvHandler.CLParsingException ex) {\n-            if (handler.isSet(EnvHandler.HELP)) {\n-                handler.usage();\n-                handler.getOut().println(\"\\n JCov Agent command line error: \" + ex.getMessage() + \"\\n\");\n-                System.exit(ERROR_CMDLINE_EXIT_CODE);\n-            }\n-\n-            if (handler.isSet(EnvHandler.HELP_VERBOSE)) {\n-                handler.usage(true);\n-                handler.getOut().println(\"\\n JCov Agent command line error: \" + ex.getMessage() + \"\\n\");\n-                System.exit(ERROR_CMDLINE_EXIT_CODE);\n-            }\n-\n-            handler.getOut().println(\" JCov Agent command line error: \" + ex.getMessage() + \"\\n\");\n-            handler.getOut().println(\"Use \\\"java -jar jcov.jar Agent -h\\\" for command-line help or \\\"java -jar jcov.jar Agent -hv\\\" for wider description\");\n-            System.exit(ERROR_CMDLINE_EXIT_CODE);\n-        } catch (EnvHandlingException ex) {\n-            handler.getOut().println(\"JCov Agent command line error: \" + ex.getMessage() + \"\\n\");\n-            handler.getOut().println(\"Use \\\"java -jar jcov.jar Agent -h\\\" for command-line help or \\\"java -jar jcov.jar Agent -hv\\\" for wider description\");\n-            if (handler.isSet(EnvHandler.PRINT_ENV)) {\n-                handler.printEnv();\n-            }\n-            System.exit(ERROR_CMDLINE_EXIT_CODE);\n-        } catch (Throwable ex) {\n-            handler.getOut().println(\"JCov Agent command line error: \" + ex.getMessage());\n-            System.exit(ERROR_CMDLINE_EXIT_CODE);\n-        }\n-        if (handler.isSet(EnvHandler.PRINT_ENV)) {\n-            handler.printEnv();\n-            System.exit(SUCCESS_EXIT_CODE);\n-        }\n-\n-        try {\n-            if (Utils.getJavaVersion() >= Utils.VER1_6) {\n-                tool.premainV50(agentArgs, instArg);\n-            } else {\n-                tool.premainV49(agentArgs, instArg);\n-            }\n-        } catch (Exception ex) {\n-            System.out.println(\"Agent execution error: \" + ex.getMessage());\n-            ex.printStackTrace();\n-            System.exit(ERROR_EXEC_EXIT_CODE);\n-        }\n-    }\n-\n-    \/**\n-     * premain chain for classfiles V50+\n-     *\n-     * @param agentArgs\n-     * @param inst\n-     * @throws Exception\n-     *\/\n-    public void premainV50(String agentArgs, Instrumentation inst) throws Exception {\n-        InstrumentationParams params =\n-                new InstrumentationParams(true, classesReload, true, instrumentNative, instrumentField,\n-                detectInternal, instrumentAbstract ? InstrumentationOptions.ABSTRACTMODE.DIRECT : InstrumentationOptions.ABSTRACTMODE.NONE,\n-                include, exclude, callerInclude, callerExclude, m_include, m_exclude, mode, saveBegin, saveEnd)\n-                .setInstrumentAnonymous(instrumentAnonymous)\n-                .setInstrumentSynthetic(instrumentSynthetic);\n-\n-        params.enable();\n-        CollectDetect.enterInstrumentationCode();\n-\n-        Tr transformer = new Tr(\"RetransformApp\", flushPath);\n-        inst.addTransformer(transformer, true);\n-        if (params.isInstrumentNative()) {\n-            inst.setNativeMethodPrefix(transformer, InstrumentationOptions.nativePrefix);\n-        }\n-\n-        DataRoot root = new DataRoot(agentArgs, params);\n-        classMorph = new ClassMorph(filename, root, params);\n-        Class[] classes = inst.getAllLoadedClasses();\n-        Set<Class> examinedClasses = new HashSet<Class>(Arrays.asList(classes));\n-        int keep = 0;\n-        for (Class c : classes) {\n-            if (inst.isModifiableClass(c)\n-                    && classMorph.shouldTransform(c.getName().replace('.', '\/'))\n-                    && !c.getName().replace('.', '\/').equals(\"jdk\/internal\/reflect\/Reflection\")\n-                    && !c.getName().replace('.', '\/').equals(\"sun\/reflect\/Reflection\")) {\n-                classes[keep++] = c;\n-            }\n-        }\n-        transformer.ignoreLoads = false;\n-        if (keep > 0) {\n-            classes = Utils.copyOf(classes, keep);\n-            logger.log(Level.INFO, \"About to retransform {0} classes {1}\", new Object[]{keep, classes[0]});\n-            try {\n-                inst.retransformClasses(classes);\n-            } catch (UnmodifiableClassException e) {\n-                System.err.println(\"Should not happen: \" + e);\n-                e.printStackTrace(System.err);\n-            } catch (Throwable e) {\n-                System.err.println(\"During retransform: \" + e);\n-                e.printStackTrace(System.err);\n-            }\n-        }\n-        logger.log(Level.INFO, \"Retransformed {0} classes\", keep);\n-        Class[] allClasses = inst.getAllLoadedClasses();\n-        keep = 0;\n-        for (Class c : allClasses) {\n-            if (!examinedClasses.contains(c)\n-                    && inst.isModifiableClass(c)\n-                    && classMorph.shouldTransform(c.getName().replace('.', '\/'))) {\n-                allClasses[keep++] = c;\n-            }\n-        }\n-        if (keep > 0) {\n-            logger.log(Level.INFO, \"New not transformed: {0} classes {1}\", new Object[]{keep, allClasses[0]});\n-            classes = Utils.copyOf(classes, keep);\n-            try {\n-                inst.retransformClasses(classes);\n-            } catch (UnmodifiableClassException e) {\n-                logger.log(Level.SEVERE, \"retransformClasses: Should not happen: \", e);\n-                \/\/log.log(.printStackTrace(System.err);\n-            } catch (Throwable e) {\n-                logger.log(Level.SEVERE, \"Error during retransform: \", e);\n-            }\n-        }\n-\n-        if (!grabberSaver) {\n-            \/\/ File saver should perform full merge here, not only insert new classes.\n-            JCovSaver saver = FileSaver.getFileSaver(root, filename, template, merge, true);\n-            loadFileSaverClasses();\n-            Collect.setSaver(Collect.decorateSaver(new SynchronizedSaverDecorator(saver)));\n-        } else {\n-            AgentSocketSaver saver = new AgentSocketSaver(root, filename, host, port);\n-            Collect.setSaver(Collect.decorateSaver(new SynchronizedSaverDecorator(saver)));\n-        }\n-        CollectDetect.leaveInstrumentationCode();\n-        PropertyFinder.addAutoShutdownSave();\n-\n-    }\n-\n-    private void loadFileSaverClasses() throws IOException{\n-        File file = new File(filename + \"_load\");\n-        new FileOutputStream(file).close();\n-        file.delete();\n-    }\n-\n-    \/**\n-     * premain chain for classfiles V49+\n-     *\n-     * @param agentArgs\n-     * @param inst\n-     * @throws Exception\n-     *\/\n-    public void premainV49(String agentArgs, Instrumentation inst) throws Exception {\n-        InstrumentationParams params =\n-                new InstrumentationParams(true, instrumentNative, instrumentField,\n-                detectInternal, instrumentAbstract ? InstrumentationOptions.ABSTRACTMODE.DIRECT : InstrumentationOptions.ABSTRACTMODE.NONE,\n-                include, exclude, callerInclude, callerExclude, mode, saveBegin, saveEnd)\n-                .setInstrumentAnonymous(instrumentAnonymous)\n-                .setInstrumentSynthetic(instrumentSynthetic);\n-\n-        params.enable();\n-        CollectDetect.enterInstrumentationCode();\n-        Tr transformer = new Tr(\"RetransformApp\", flushPath);\n-        inst.addTransformer(transformer);\n-        \/* if (Options.isInstrumentNative()) {\n-         inst.setNativeMethodPrefix(transformer, Options.nativePrefix);\n-         }\n-         *\/\n-        DataRoot root = new DataRoot(agentArgs, params);\n-        classMorph = new ClassMorph(filename, root, params);\n-        Class[] classes = inst.getAllLoadedClasses();\n-        Set<Class> examinedClasses = new HashSet<Class>(Arrays.asList(classes));\n-        int keep = 0;\n-        for (Class c : classes) {\n-            if (\/*inst.isModifiableClass(c) &&*\/classMorph.shouldTransform(c.getName().replace('.', '\/'))) {\n-                classes[keep++] = c;\n-            }\n-        }\n-        if (keep > 0) {\n-            classes = Utils.copyOf(classes, keep);\n-            logger.log(Level.INFO, \"About to retransform {0} classes {1}\", new Object[]{keep, classes[0]});\n-        }\n-        logger.log(Level.INFO, \"Retransformed {0} classes\", keep);\n-        transformer.ignoreLoads = false;\n-        Class[] allClasses = inst.getAllLoadedClasses();\n-        keep = 0;\n-        for (Class c : allClasses) {\n-            if (!examinedClasses.contains(c)\n-                    && \/\/  inst.isModifiableClass(c) &&\n-                    classMorph.shouldTransform(c.getName().replace('.', '\/'))) {\n-                allClasses[keep++] = c;\n-            }\n-        }\n-        if (keep > 0) {\n-            classes = Utils.copyOf(allClasses, keep);\n-        }\n-\n-        if (!grabberSaver) {\n-            \/\/ File saver should perform full merge here, not only insert new classes.\n-            JCovSaver saver = FileSaver.getFileSaver(root, filename, template, merge, true);\n-            loadFileSaverClasses();\n-            Collect.setSaver(Collect.decorateSaver(new SynchronizedSaverDecorator(saver)));\n-        } else {\n-            AgentSocketSaver saver = new AgentSocketSaver(root, filename, host, port);\n-            Collect.setSaver(Collect.decorateSaver(new SynchronizedSaverDecorator(saver)));\n-        }\n-        CollectDetect.leaveInstrumentationCode();\n-        PropertyFinder.addAutoShutdownSave();\n-    }\n-\n-    public String usageString() {\n-        return \"java -javaagent:jcov.jar=[=option=value[,option=value]*] ...\";\n-    }\n-\n-    public String exampleString() {\n-        return \"java -javaagent:jcov.jar=include=java\\\\.lang\\\\.String,native=on,type=branch,abstract=off -jar MyApp.jar\";\n-    }\n-\n-    public String getDescr() {\n-        return \"print help on usage jcov in dynamic mode\";\n-    }\n-\n-    @Override\n-    public boolean isMainClassProvided() {\n-        return false;\n-    }\n-\n-\/\/\/\/\/\/\/\/\/ JCovTool implementation \/\/\/\/\/\/\/\/\/\n-    @Override\n-    public EnvHandler defineHandler() {\n-        return new EnvHandler(new OptionDescr[]{\n-                    DSC_OUTPUT,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MERGE,\n-                    \/\/ Verbosity\n-                    DSC_VERBOSE,\n-                    DSC_TIMEOUT,\n-                    DSC_PORT,\n-                    \/\/ Instrumentation parameters.\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TEMPLATE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TYPE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ABSTRACT,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_NATIVE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FIELD,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SYNTHETIC,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ANONYM,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CLASSESRELOAD,\n-                    \/\/ Data save points\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SAVE_BEGIN,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SAVE_AT_END,\n-                    InstrumentationOptions.DSC_FLUSH_CLASSES,\n-                    DSC_GRABBER,\n-                    DSC_PORT_GRABBER,\n-                    DSC_HOST_GRABBER,\n-                    DSC_LOG\n-                }, this);\n-    }\n-\n-    @Override\n-    public int handleEnv(EnvHandler opts) throws EnvHandlingException {\n-        String internal = \"default\";\n-        if (internal.equals(\"detect\")) {\n-            detectInternal = true;\n-        } else if (internal.equals(\"show\")) {\n-            detectInternal = true;\n-        } else if (internal.equals(\"include\")) {\n-            detectInternal = false;\n-        } else if (internal.equals(\"default\")) {\n-            detectInternal = true;\n-        } else {\n-            throw new Error(\"Parameter error\");\n-        }\n-\n-        mode = InstrumentationOptions.InstrumentationMode.fromString(opts.getValue(InstrumentationOptions.DSC_TYPE));\n-        if (opts.isSet(InstrumentationOptions.DSC_TEMPLATE)) {\n-            template = opts.getValue(InstrumentationOptions.DSC_TEMPLATE);\n-        }\n-\n-        include = InstrumentationOptions.handleInclude(opts);\n-        exclude = InstrumentationOptions.handleExclude(opts);\n-\n-        m_include = InstrumentationOptions.handleMInclude(opts);\n-        m_exclude = InstrumentationOptions.handleMExclude(opts);\n-\n-        fm = InstrumentationOptions.handleFM(opts);\n-\n-        callerInclude = opts.getValues(InstrumentationOptions.DSC_CALLER_INCLUDE);\n-\/\/        System.out.println(\"Setup callerInclude \" + Arrays.toString(callerInclude));\n-        callerExclude = opts.getValues(InstrumentationOptions.DSC_CALLER_EXCLUDE);\n-\/\/        System.out.println(\"Setup callerExclude \" + Arrays.toString(callerExclude));\n-\n-        String abstractValue = opts.getValue(InstrumentationOptions.DSC_ABSTRACT);\n-        if (abstractValue.equals(\"off\")) {\n-            instrumentAbstract = false;\n-        } else if (abstractValue.equals(\"on\")) {\n-            instrumentAbstract = true;\n-        } else {\n-            \/\/ will not happen - checking inside EnvHandler\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_ABSTRACT.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + abstractValue + \"'\");\n-        }\n-\n-        String classesReloadValue = opts.getValue(InstrumentationOptions.DSC_CLASSESRELOAD);\n-        if (classesReloadValue.equals(\"on\")) {\n-            classesReload = true;\n-        } else {\n-            classesReload = false;\n-        }\n-\n-        String nativeValue = opts.getValue(InstrumentationOptions.DSC_NATIVE);\n-        if (nativeValue.equals(\"on\")) {\n-            instrumentNative = true;\n-        } else if (nativeValue.equals(\"off\")) {\n-            instrumentNative = false;\n-        } else {\n-            \/\/ will not happen - checking inside EnvHandler\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_NATIVE.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + nativeValue + \"'\");\n-        }\n-\n-        String fieldValue = opts.getValue(InstrumentationOptions.DSC_FIELD);\n-        if (fieldValue.equals(\"on\")) {\n-            instrumentField = true;\n-        } else if (fieldValue.equals(\"off\")) {\n-            instrumentField = false;\n-        } else {\n-            \/\/ will not happen - checking inside EnvHandler\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_FIELD.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + fieldValue + \"'\");\n-        }\n-\n-        String anonym = opts.getValue(InstrumentationOptions.DSC_ANONYM);\n-        if (anonym.equals(\"on\")) {\n-            instrumentAnonymous = true;\n-        } else { \/\/ off\n-            instrumentAnonymous = false;\n-        }\n-\n-        String synthetic = opts.getValue(InstrumentationOptions.DSC_SYNTHETIC);\n-        if (synthetic.equals(\"on\")) {\n-            instrumentSynthetic = true;\n-        } else { \/\/ off\n-            instrumentSynthetic = false;\n-        }\n-\n-        String mergeValue = opts.getValue(InstrumentationOptions.DSC_MERGE);\n-        if (mergeValue.equals(\"merge\")) {\n-            merge = InstrumentationOptions.MERGE.MERGE;\n-        } else if (mergeValue.equals(\"scale\")) {\n-            merge = InstrumentationOptions.MERGE.SCALE;\n-        } else if (mergeValue.equals(\"overwrite\")) {\n-            merge = InstrumentationOptions.MERGE.OVERWRITE;\n-        } else if (mergeValue.equals(\"gensuff\")) {\n-            merge = InstrumentationOptions.MERGE.GEN_SUFF;\n-        } else {\n-            \/\/ will never happen as this is checked in EnvHandler\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_MERGE.name + \"' parameter value error: expected 'merge', 'scale', 'overwrite' or 'gensuff'; found: '\" + mergeValue + \"'\");\n-        }\n-\n-        saveBegin = opts.getValues(InstrumentationOptions.DSC_SAVE_BEGIN);\n-        saveEnd = opts.getValues(InstrumentationOptions.DSC_SAVE_AT_END);\n-\n-        flushPath = opts.getValue(InstrumentationOptions.DSC_FLUSH_CLASSES);\n-        if (\"none\".equals(flushPath)) {\n-            flushPath = null;\n-        }\n-\n-        String logfile = opts.getValue(EnvHandler.LOGFILE);\n-        if (opts.isSet(DSC_LOG) || logfile != null) {\n-            if (logfile == null) {\n-                logfile = \"jcov.log\";\n-            }\n-            try {\n-                Utils.setLoggerHandler(new FileHandler(logfile));\n-            } catch (Exception ex) {\n-                throw new EnvHandlingException(\"Can't open file '\" + logfile + \"' for writing the log\", ex);\n-            }\n-            if (opts.isSet(EnvHandler.LOGLEVEL)) {\n-                Utils.setLoggingLevel(opts.getValue(EnvHandler.LOGLEVEL));\n-            } else if (opts.isSet(DSC_VERBOSE)) {\n-                int verbositylevel = Utils.checkedToInt(opts.getValue(DSC_VERBOSE), \"verbosity level\", Utils.CheckOptions.INT_NONNEGATIVE);\n-                switch (verbositylevel) {\n-                    case 0:\n-                        logger.setLevel(Level.SEVERE);\n-                        Utils.setLoggingLevel(Level.SEVERE);\n-                        break;\n-                    case 1:\n-                        logger.setLevel(Level.CONFIG);\n-                        Utils.setLoggingLevel(Level.CONFIG);\n-                        break;\n-                    case 2:\n-                        logger.setLevel(Level.INFO);\n-                        Utils.setLoggingLevel(Level.INFO);\n-                        break;\n-                    case 3:\n-                        logger.setLevel(Level.ALL);\n-                        Utils.setLoggingLevel(Level.ALL);\n-                        break;\n-                    default:\n-                        throw new EnvHandlingException(\"Incorrect verbosity level (\" + opts.getValue(DSC_VERBOSE) + \") - should be 0..3\");\n-                }\n-            }\n-        } else {\n-            Utils.setLoggingLevel(Level.OFF);\n-        }\n-\n-        if (opts.isSet(DSC_TIMEOUT)) {\n-            long timeout = Utils.checkedToInt(opts.getValue(DSC_TIMEOUT), \"timeout value\");\n-            if (timeout > 0) {\n-                Timer timer = new Timer(true);\n-                timer.schedule(new TimerTask() {\n-                    @Override\n-                    public void run() {\n-                        logger.log(Level.INFO, \"Agent has been timed out.\");\n-                        if (Collect.enabled) {\n-                            Collect.disable();\n-                            Collect.saveResults();\n-                        }\n-                        Runtime.getRuntime().halt(0);\n-                    }\n-                }, timeout);\n-            }\n-        }\n-\n-        grabberSaver = opts.isSet(DSC_GRABBER);\n-        if (grabberSaver) {\n-            host = opts.getValue(DSC_HOST_GRABBER);\n-            Utils.checkHostCanBeNull(host, \"grabber host\");\n-\n-            this.port = Utils.checkedToInt(opts.getValue(DSC_PORT_GRABBER), \"grabber port number\", Utils.CheckOptions.INT_POSITIVE);\n-        }\n-\n-        filename = opts.getValue(DSC_OUTPUT);\n-        if (!grabberSaver) {\n-            Utils.checkFileNotNull(filename, \"output filename\", Utils.CheckOptions.FILE_NOTISDIR, Utils.CheckOptions.FILE_PARENTEXISTS);\n-        }\n-\n-        if (opts.isSet(DSC_PORT)) {\n-            CommandThread cmdThread = new CommandThread(Utils.checkedToInt(opts.getValue(DSC_PORT), \"command listener port number\", Utils.CheckOptions.INT_POSITIVE),\n-                    new InstrumentationParams(true, instrumentNative, instrumentField, detectInternal,\n-                    instrumentAbstract ? InstrumentationOptions.ABSTRACTMODE.DIRECT : InstrumentationOptions.ABSTRACTMODE.NONE,\n-                    include, exclude, callerInclude, callerExclude, mode, saveBegin, saveEnd)\n-                    .setInstrumentAnonymous(instrumentAnonymous)\n-                    .setInstrumentSynthetic(instrumentSynthetic));\n-            cmdThread.start();\n-        }\n-\n-        return SUCCESS_EXIT_CODE;\n-    }\n-    public static final OptionDescr DSC_OUTPUT =\n-            new OptionDescr(\"file\", new String[]{\"url\", \"o\"}, \"Output path definition.\",\n-            OptionDescr.VAL_SINGLE, \"Specifies output data file. \\n\"\n-            + \"If specified file already exists, collected data will be merged with data from file\",\n-            \"result.xml\");\n-    public final static OptionDescr DSC_VERBOSE =\n-            new OptionDescr(\"verbose\", \"Verbosity level.\",\n-            new String[][]{\n-                {\"0\", \"minimal, only fatal failure diagnostic is printed\"},\n-                {\"1\", \"moderate, non-fatal errors are included in log\"},\n-                {\"2\", \"high, all warnings are included in log\"},\n-                {\"3\", \"highest, all messages are included in log\"}\n-            },\n-            \"Set verbosity level.\", \"0\");\n-    public static final OptionDescr DSC_TIMEOUT =\n-            new OptionDescr(\"timeout\", \"Agent process timeout.\",\n-            OptionDescr.VAL_SINGLE, \"Specifies timeout for agent process in milliseconds.\\n\"\n-            + \"0 means there is no timeout specified. Default is 0.\\n\",\n-            \"0\");\n-    \/\/ port now can be set only as \"agent.port\" via VM properties and env variables. \"Port\" is used only for grabber and socket saver.\n-    public static final OptionDescr DSC_PORT = new OptionDescr(\"agent.port\", new String[]{\"portcl\"}, \"Agent command listening port\",\n-            OptionDescr.VAL_SINGLE, \"Specifies port number to listen for driving commands.\\n\"\n-            + \"Commands are executed sequentially, some may send messages in response. \"\n-            + \"Valid commands to send are: \\n\"\n-            + \"   \\\"save\\\" - to save already collected data. It will respond with \\\"saved\\\" message\\n\"\n-            + \"   \\\"exit\\\" - to perform System.exit() immediately. Exit code number may be sent with this command.\\n\"\n-            + \"              It's chars should follow \\\"exit\\\"\");\n-    public static final OptionDescr DSC_PORT_GRABBER = new OptionDescr(\"port\", new String[]{\"grabberport\"}, \"\",\n-            OptionDescr.VAL_SINGLE, \"Specifies port number to send data to the grabber\", MiscConstants.JcovPortNumber + \"\");\n-    public static final OptionDescr DSC_HOST_GRABBER = new OptionDescr(\"host\", new String[]{\"grabberhost\"}, \"\",\n-            OptionDescr.VAL_SINGLE, \"Specifies host name to send data to the grabber\", \"localhost\");\n-    public final static OptionDescr DSC_LOG =\n-            new OptionDescr(\"log\", \"logging\", OptionDescr.VAL_NONE, \"Turns on JCov's agent logging.\\n\"\n-            + \"Log records saved in jcov.log file\");\n-    public final static OptionDescr DSC_GRABBER =\n-            new OptionDescr(\"grabber\", \"use grabber saver\", OptionDescr.VAL_NONE, \"Use grabber saver instead of file saver. jcov.port \"\n-            + \"and jcov.host VM properties could be used to control the saver as well as JCOV_PORT and JCOV_HOST env variable\");\n-}\n\\ No newline at end of file\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Agent.java","additions":0,"deletions":870,"binary":false,"changes":870,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n@@ -37,0 +36,2 @@\n+\n+import java.beans.EventHandler;\n@@ -84,0 +85,1 @@\n+    private EnvHandler envHandler;\n@@ -99,0 +101,1 @@\n+            grabber.handleEnv(envHandler);\n@@ -259,1 +262,2 @@\n-        grabber.handleEnv(envHandler);\n+\/\/        grabber.handleEnv(envHandler);\n+        this.envHandler = envHandler;\n@@ -272,1 +276,1 @@\n-            Utils.checkFileNotNull(template, \"template file\", Utils.CheckOptions.FILE_CANREAD, Utils.CheckOptions.FILE_ISFILE, Utils.CheckOptions.FILE_EXISTS);\n+            Utils.checkFileNotNull(template, \"template file\", Utils.CheckOptions.FILE_PARENTEXISTS);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Exec.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -414,4 +414,0 @@\n-    public void setGenNative(boolean gennative) {\n-        this.gennative = gennative;\n-    }\n-\n@@ -422,0 +418,14 @@\n+    public String[] getMInclude() {return m_include;}\n+\n+    public File getOutDir() { return outDir; }\n+\n+    public String getInclude_rt() { return include_rt; }\n+\n+    public void setInclude_rt(String include_rt) { this.include_rt = include_rt; }\n+\n+    public void setOutDir(File outDir) { this.outDir = outDir; }\n+\n+    public void setGenNative(boolean gennative) {\n+        this.gennative = gennative;\n+    }\n+\n@@ -426,2 +436,0 @@\n-    public String[] getMInclude() {return m_include;}\n-\n@@ -503,0 +511,4 @@\n+    public String[] getSrcs() { return srcs; }\n+\n+    public void setSrcs(String[] srcs) { this.srcs = srcs; }\n+\n@@ -561,1 +573,1 @@\n-    private int handleEnv_(EnvHandler opts) throws EnvHandlingException {\n+    protected int handleEnv_(EnvHandler opts) throws EnvHandlingException {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,7 +27,0 @@\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph2;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n-import com.sun.tdk.jcov.instrument.InstrumentationParams;\n-import com.sun.tdk.jcov.tools.EnvHandler;\n-import com.sun.tdk.jcov.tools.JCovCMDTool;\n-import com.sun.tdk.jcov.tools.OptionDescr;\n@@ -35,3 +28,1 @@\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.logging.Level;\n+\n@@ -48,0 +39,1 @@\n+ * @deprecated Use Instr\n@@ -49,1 +41,2 @@\n-public class Instr2 extends JCovCMDTool {\n+@Deprecated(forRemoval = true)\n+public class Instr2 extends Instr {\n@@ -51,9 +44,0 @@\n-    private boolean genabstract;\n-    private boolean genfield;\n-    private boolean gennative;\n-    private boolean gensynthetic;\n-    private boolean genanonymous;\n-    private String template;\n-    private String flushPath;\n-    private String[] include;\n-    private String[] exclude;\n@@ -61,2 +45,0 @@\n-    private String[] srcs;\n-    private File outDir;\n@@ -94,137 +76,0 @@\n-\n-    @Override\n-    protected int run() throws Exception {\n-        Utils.addToClasspath(srcs);\n-\n-        AbstractUniversalInstrumenter instrumenter =\n-                new AbstractUniversalInstrumenter(true) {\n-                    ClassMorph2 morph = new ClassMorph2(\n-                            new InstrumentationParams(gennative, genfield, genabstract, include, exclude, InstrumentationOptions.InstrumentationMode.BLOCK)\n-                            .setInstrumentAnonymous(genanonymous)\n-                            .setInstrumentSynthetic(gensynthetic), template);\n-\n-                    protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n-                        return morph.morph(classData, flushPath);\n-                    }\n-\n-                    public void finishWork() {\n-                    }\n-                };\n-\n-        \/\/instrumenter.setPrintStats(opts.isSet(DSC_STATS));\n-\/\/        com.sun.tdk.jcov.instrument.Options.instrumentAbstract = com.sun.tdk.jcov.instrument.Options.instrumentAbstract.NONE;\n-\n-        for (String root : srcs) {\n-            instrumenter.instrument(new File(root), outDir);\n-        }\n-        \/*\n-         if ((opts.isSet(JcovInstrContext.OPT_SAVE_BEFORE) ||\n-         opts.isSet(JcovInstrContext.OPT_SAVE_AFTER)  ||\n-         opts.isSet(JcovInstrContext.OPT_SAVE_BEGIN)  ||\n-         opts.isSet(JcovInstrContext.OPT_SAVE_AT_END)) &&\n-         instrumenter.getSavePointCount() < 1) {\n-\n-         log.warning(\"no coverage data savepoints have been inserted\");\n-         }\n-         *\/\n-        instrumenter.finishWork();\n-        return SUCCESS_EXIT_CODE;\n-    }\n-\n-    @Override\n-    protected EnvHandler defineHandler() {\n-        return new EnvHandler(new OptionDescr[]{\n-                    DSC_OUTPUT,\n-                    DSC_VERBOSE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TEMPLATE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ABSTRACT,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_NATIVE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FIELD,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SYNTHETIC,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ANONYM,\n-                    InstrumentationOptions.DSC_FLUSH_CLASSES\n-                }, this);\n-    }\n-\n-    @Override\n-    protected int handleEnv(EnvHandler envHandler) throws EnvHandlingException {\n-        srcs = envHandler.getTail();\n-        if (srcs == null) {\n-            throw new EnvHandlingException(\"No input files specified\");\n-        }\n-        if (envHandler.isSet(DSC_VERBOSE)) {\n-            logger.setLevel(Level.INFO);\n-        }\n-\n-        outDir = null;\n-        if (envHandler.isSet(DSC_OUTPUT)) {\n-            outDir = new File(envHandler.getValue(DSC_OUTPUT));\n-            if (!outDir.exists()) {\n-                outDir.mkdirs();\n-                logger.log(Level.INFO, \"The directory {0} was created.\", outDir.getAbsolutePath());\n-            }\n-        }\n-\n-        String abstractValue = envHandler.getValue(InstrumentationOptions.DSC_ABSTRACT);\n-        if (abstractValue.equals(\"off\")) {\n-            genabstract = false;\n-        } else if (abstractValue.equals(\"on\")) {\n-            genabstract = true;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_ABSTRACT.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + abstractValue + \"'\");\n-        }\n-\n-        String nativeValue = envHandler.getValue(InstrumentationOptions.DSC_NATIVE);\n-        if (nativeValue.equals(\"on\")) {\n-            gennative = true;\n-        } else if (nativeValue.equals(\"off\")) {\n-            gennative = false;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_NATIVE.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + nativeValue + \"'\");\n-        }\n-\n-        String fieldValue = envHandler.getValue(InstrumentationOptions.DSC_FIELD);\n-        if (fieldValue.equals(\"on\")) {\n-            genfield = true;\n-        } else if (fieldValue.equals(\"off\")) {\n-            genfield = false;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_FIELD.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + fieldValue + \"'\");\n-        }\n-\n-        String anonym = envHandler.getValue(InstrumentationOptions.DSC_ANONYM);\n-        if (anonym.equals(\"on\")) {\n-            genanonymous = true;\n-        } else { \/\/ off\n-            genanonymous = false;\n-        }\n-\n-        String syntheticField = envHandler.getValue(InstrumentationOptions.DSC_SYNTHETIC);\n-        if (syntheticField.equals(\"on\")) {\n-            gensynthetic = true;\n-        } else { \/\/ if (fieldValue.equals(\"off\"))\n-            gensynthetic = false;\n-        }\n-\n-        template = envHandler.getValue(InstrumentationOptions.DSC_TEMPLATE);\n-        Utils.checkFileNotNull(template, \"template filename\", Utils.CheckOptions.FILE_NOTISDIR, Utils.CheckOptions.FILE_PARENTEXISTS);\n-\n-        include = InstrumentationOptions.handleInclude(envHandler);\n-        exclude = InstrumentationOptions.handleExclude(envHandler);\n-\n-        flushPath = envHandler.getValue(InstrumentationOptions.DSC_FLUSH_CLASSES);\n-        if (\"none\".equals(flushPath)) {\n-            flushPath = null;\n-        }\n-\n-        return SUCCESS_EXIT_CODE;\n-    }\n-    final static OptionDescr DSC_OUTPUT =\n-            new OptionDescr(\"instr2.output\", new String[]{\"output\", \"o\"}, \"Output directory\", OptionDescr.VAL_SINGLE,\n-            \"Specifies output file or directory, default directory is current.\");\n-    final static OptionDescr DSC_VERBOSE =\n-            new OptionDescr(\"verbose\", \"Verbose mode\", \"Enable verbose mode.\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr2.java","additions":4,"deletions":159,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -27,5 +27,1 @@\n-import com.sun.tdk.jcov.constants.MiscConstants;\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n-import com.sun.tdk.jcov.instrument.InstrumentationParams;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -33,1 +29,0 @@\n-import com.sun.tdk.jcov.tools.JCovCMDTool;\n@@ -35,1 +30,0 @@\n-import com.sun.tdk.jcov.util.RuntimeUtils;\n@@ -37,0 +31,1 @@\n+\n@@ -39,0 +34,1 @@\n+import java.nio.file.Path;\n@@ -40,2 +36,1 @@\n-import java.util.Arrays;\n-import java.util.logging.Level;\n+import java.util.List;\n@@ -43,0 +38,1 @@\n+import java.util.stream.Collectors;\n@@ -48,2 +44,1 @@\n-public class ProductInstr extends JCovCMDTool {\n-    \/\/ instrumentation filters (include\/exclude, fields, abstract, ...); removing temporary directory\n+public class ProductInstr extends Instr {\n@@ -57,34 +52,0 @@\n-    private File instrProductDir;\n-    private File instrOutputDir;\n-    private String template = MiscConstants.JcovTemplateFileNameXML;\n-    private String tempPath;\n-    private File rtLibFile;\n-    private String[] rtClassDirTargets;\n-    private InstrumentationOptions.InstrumentationMode mode = InstrumentationOptions.InstrumentationMode.BRANCH;\n-    private String[] include = new String[]{\".*\"};\n-    private String[] exclude = new String[]{\"\"};\n-    private String[] m_include = new String[]{\".*\"};\n-    private String[] m_exclude = new String[]{\"\"};\n-    private String[] callerInclude;\n-    private String[] callerExclude;\n-\n-    public void instrumentProduct() throws Exception {\n-        logger.log(Level.INFO, \" - Instrumenting product\");\n-        logger.log(Level.CONFIG, \"Product location: ''{0}'', target location: ''{1}''\", new Object[]{instrProductDir.getPath(), instrOutputDir.getPath()});\n-\n-        tempPath = instrProductDir.getPath() + RuntimeUtils.genSuffix();\n-        createTempDir();\n-\n-        AbstractUniversalInstrumenter instrumenter = setupInstrumenter();\n-\n-        instrOutputDir.mkdir();\n-        instrumenter.instrument(instrProductDir, instrOutputDir, rtLibFile.getAbsolutePath(), rtClassDirTargets == null ? null : new ArrayList(Arrays.asList(rtClassDirTargets)), true);\n-        instrumenter.finishWork();\n-\n-        removeTempDir();\n-    }\n-\n-    private AbstractUniversalInstrumenter setupInstrumenter() {\n-        InstrumentationParams params = new InstrumentationParams(true, false, false, false, false, false, InstrumentationOptions.ABSTRACTMODE.NONE, include, exclude, callerInclude, callerExclude, m_include, m_exclude, mode, null, null)\n-                .setInstrumentAnonymous(true)\n-                .setInstrumentSynthetic(false);\n@@ -92,18 +53,5 @@\n-        final ClassMorph morph = new ClassMorph(params, null);\n-        return new AbstractUniversalInstrumenter(true) {\n-            @Override\n-            protected byte[] instrument(byte[] classData, int classLength) throws IOException {\n-                return morph.morph(classBuf, null, tempPath);\n-            }\n-\n-            @Override\n-            public void finishWork() {\n-                morph.saveData(template, null, InstrumentationOptions.MERGE.OVERWRITE);\n-            }\n-        };\n-    }\n-\n-    private void createTempDir() {\n-        new File(tempPath).mkdir();\n-        logger.log(Level.INFO, \"Temp directory for storing instrumented classes created: ''{0}''. Automatic removal is not implemented yet so please remove it manually after all is done.\", tempPath);\n-    }\n+    public final static OptionDescr DSC_INSTRUMENT =\n+            new OptionDescr(\"product\", \"\", OptionDescr.VAL_SINGLE, \"\");\n+    public final static OptionDescr DSC_INSTRUMENT_TO =\n+            new OptionDescr(\"productOutput\", \"\", OptionDescr.VAL_SINGLE, \"\");\n+    public final static OptionDescr DSC_RT_TO = new OptionDescr(\"rtTo\", \"\", OptionDescr.VAL_MULTI, \"\");\n@@ -111,9 +59,4 @@\n-    private void removeTempDir() {\n-        File tempFile = new File(tempPath);\n-        if (tempFile.isDirectory()) {\n-            Utils.deleteDirectory(tempFile);\n-        } else {\n-            tempFile.delete();\n-        }\n-        logger.log(Level.INFO, \"Temp directory for storing instrumented classes deleted: ''{0}''.\", tempPath);\n-    }\n+    private static final List<String> SKIP_INSTR_OPTIONS = List.of(\n+            DSC_OUTPUT).stream().map(o -> o.name).collect(Collectors.toList());\n+    private static final List<OptionDescr> ADD_TO_INSTR_OPTIONS = List.of(\n+            DSC_INSTRUMENT, DSC_INSTRUMENT_TO, Instr.DSC_INCLUDE_RT);\n@@ -122,3 +65,3 @@\n-    protected int run() throws Exception {\n-        instrumentProduct();\n-        return SUCCESS_EXIT_CODE;\n+    protected InstrumentationPlugin.Destination getDestination(File outDir, Path inPath) throws IOException {\n+        if (getOutDir() == null) return new InstrumentationPlugin.PathDestination(inPath);\n+        else return new InstrumentationPlugin.PathDestination(Path.of(outDir.getAbsolutePath()));\n@@ -129,16 +72,6 @@\n-        return new EnvHandler(new OptionDescr[]{\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TYPE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_EXCLUDE,\n-                    DSC_INSTRUMENT,\n-                    DSC_INSTRUMENT_TO,\n-                    Instr.DSC_INCLUDE_RT,\n-                    DSC_RT_TO,}, this);\n+        EnvHandler superHandler = super.defineHandler();\n+        List<OptionDescr> opts = superHandler.getValidOptions().stream()\n+                .filter(o -> !SKIP_INSTR_OPTIONS.contains(o.name)).collect(Collectors.toList());\n+        opts = new ArrayList<>(opts);\n+        opts.addAll(ADD_TO_INSTR_OPTIONS);\n+        return new EnvHandler(opts.toArray(new OptionDescr[0]), this);\n@@ -149,2 +82,8 @@\n-        instrProductDir = Utils.checkFileCanBeNull(envHandler.getValue(ProductInstr.DSC_INSTRUMENT), \"product directory\", Utils.CheckOptions.FILE_ISDIR, Utils.CheckOptions.FILE_CANREAD);\n-        instrOutputDir = Utils.checkFileCanBeNull(envHandler.getValue(ProductInstr.DSC_INSTRUMENT_TO), \"directory for instrumented product\", Utils.CheckOptions.FILE_NOTEXISTS, Utils.CheckOptions.FILE_CANWRITE);\n+        int superRes = super.handleEnv_(envHandler);\n+        if(superRes != SUCCESS_EXIT_CODE) return superRes;\n+        File instrProductDir = Utils.checkFileCanBeNull(envHandler.getValue(ProductInstr.DSC_INSTRUMENT),\n+                \"product directory\",\n+                Utils.CheckOptions.FILE_ISDIR, Utils.CheckOptions.FILE_CANREAD);\n+        File instrOutputDir = Utils.checkFileCanBeNull(envHandler.getValue(ProductInstr.DSC_INSTRUMENT_TO),\n+                \"directory for instrumented product\",\n+                Utils.CheckOptions.FILE_NOTEXISTS, Utils.CheckOptions.FILE_CANWRITE);\n@@ -154,1 +93,3 @@\n-        rtLibFile = Utils.checkFileCanBeNull(envHandler.getValue(Instr.DSC_INCLUDE_RT), \"JCov RT Saver path\", Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_ISFILE, Utils.CheckOptions.FILE_CANREAD);\n+        setSrcs(new String[] {instrProductDir.getAbsolutePath()});\n+        setOutDir(instrOutputDir);\n+        File rtLibFile = Utils.checkFileCanBeNull(envHandler.getValue(Instr.DSC_INCLUDE_RT), \"JCov RT Saver path\", Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_ISFILE, Utils.CheckOptions.FILE_CANREAD);\n@@ -158,14 +99,1 @@\n-        rtClassDirTargets = envHandler.getValues(ProductInstr.DSC_RT_TO);\n-        if (envHandler.getValue(InstrumentationOptions.DSC_TYPE) != null) {\n-            mode = InstrumentationOptions.InstrumentationMode.fromString(envHandler.getValue(InstrumentationOptions.DSC_TYPE));\n-        }\n-\n-        include = InstrumentationOptions.handleInclude(envHandler);\n-        exclude = InstrumentationOptions.handleExclude(envHandler);\n-\n-        m_include = InstrumentationOptions.handleMInclude(envHandler);\n-        m_exclude = InstrumentationOptions.handleMExclude(envHandler);\n-\n-        callerInclude = envHandler.getValues(InstrumentationOptions.DSC_CALLER_INCLUDE);\n-        callerExclude = envHandler.getValues(InstrumentationOptions.DSC_CALLER_EXCLUDE);\n-\n+        setInclude_rt(rtLibFile.toString());\n@@ -189,5 +117,6 @@\n-    public final static OptionDescr DSC_INSTRUMENT =\n-            new OptionDescr(\"product\", \"\", OptionDescr.VAL_SINGLE, \"\");\n-    public final static OptionDescr DSC_INSTRUMENT_TO =\n-            new OptionDescr(\"productOutput\", \"\", OptionDescr.VAL_SINGLE, \"\");\n-    public final static OptionDescr DSC_RT_TO = new OptionDescr(\"rtTo\", \"\", OptionDescr.VAL_MULTI, \"\");\n+\n+    public void instrumentProduct() throws Exception {\n+        if (!getOutDir().exists()) getOutDir().mkdirs();\n+        instrumentFiles(getSrcs(), getOutDir(), getInclude_rt());\n+        finishWork(getTemplate());\n+    }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/ProductInstr.java","additions":42,"deletions":113,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+package com.sun.tdk.jcov.instrument.exec;\n+\n+import com.sun.tdk.jcov.Exec;\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataPackage;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.Util;\n+import com.sun.tdk.jcov.instrument.instr.UserCode;\n+import com.sun.tdk.jcov.io.Reader;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class ExecTest {\n+    Path test_dir;\n+    Path output_dir;\n+    Path result;\n+    Path template;\n+    Path log;\n+    Path data_dir;\n+\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        System.setProperty(\"jcov.selftest\", \"true\");\n+        data_dir = Files.createTempDirectory(\"instr_test\");\n+        result = data_dir.resolve(\"result.xml\");\n+        template = data_dir.resolve(\"template.xml\");\n+        log = data_dir.resolve(\"log\");\n+        test_dir = data_dir.resolve(\"instr_test\");\n+        output_dir = data_dir.resolve(\"instr_test_output\");\n+        System.out.println(\"data dir = \" + data_dir);\n+    }\n+    @Test\n+    public void testExec() throws IOException, FileFormatException {\n+        String runtime = Arrays.stream(System.getProperty(\"java.class.path\").split(File.pathSeparator))\n+                .peek(System.out::println)\n+                .filter(s -> s.endsWith(\"jcov_file_saver.jar\")).findAny().get();\n+        new Util(test_dir).copyBytecode(UserCode.class.getName());\n+        \/\/java -jar JCOV_BUILD\/jcov_3.0\/jcov.jar Exec -product cl_test -productOutput cl_test_instr -rt JCOV_BUILD\/jcov_3.0\/jcov_network_saver.jar -command \"java -cp cl_test com.sun.tdk.jcov.instrument.instr.UserCode 1\"\n+        String javaCommand = System.getProperty(\"java.home\") + File.separator + \"bin\" + File.separator + \"java\" +\n+                (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\") ? \".exe\" : \"\") +\n+                \" -cp \" + output_dir.toString() + \/\/\" -output \" + result.toString()  +\n+                \" com.sun.tdk.jcov.instrument.instr.UserCode 1\";\n+        List<String> params = List.of(\"-product\", test_dir.toString(), \"-productOutput\", output_dir.toString(),\n+                \"-rt\", runtime,\n+                \"-output\", result.toString(),\n+                \"-t\", template.toString(),\n+                \"-out.file\", log.toString(),\n+                \"-command\", javaCommand);\n+        System.out.println(\"Running Exec with\");\n+        System.out.println(params.stream().collect(Collectors.joining(\" \")));\n+        new Exec().run(params.toArray(new String[0]));\n+        DataRoot data = Reader.readXML(result.toString());\n+        DataPackage dp =\n+                data.getPackages().stream()\n+                        .filter(p -> p.getName().equals(\"com\/sun\/tdk\/jcov\/instrument\/instr\")).findAny().get();\n+        DataMethod dm = dp\n+                .getClasses().stream().filter(c -> c.getName().equals(\"UserCode\")).findAny().get()\n+                .getMethods().stream().filter(m -> m.getName().equals(\"main\")).findAny().get();\n+        assertTrue(dm.getSlot() > 0);\n+        assertFalse(dp\n+                .getClasses().stream().filter(c -> c.getName().equals(\"InstrTest\")).findAny().isPresent());\n+    }\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        Util.rmRF(data_dir);\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/exec\/ExecTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"}]}