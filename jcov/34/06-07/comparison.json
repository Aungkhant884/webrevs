{"files":[{"patch":"@@ -1,842 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov.insert;\n-\n-import com.sun.tdk.jcov.instrument.InstrumentationParams;\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n-import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n-import com.sun.tdk.jcov.instrument.asm.OverriddenClassWriter;\n-import com.sun.tdk.jcov.util.Utils;\n-import java.io.BufferedInputStream;\n-import java.io.BufferedOutputStream;\n-import java.io.EOFException;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.net.URI;\n-import java.nio.file.*;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import java.util.stream.Collectors;\n-import java.util.zip.CRC32;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipException;\n-import java.util.zip.ZipInputStream;\n-import java.util.zip.ZipOutputStream;\n-\n-import static com.sun.tdk.jcov.util.Utils.FILE_TYPE;\n-import static com.sun.tdk.jcov.util.Utils.FILE_TYPE.*;\n-import static com.sun.tdk.jcov.util.Utils.isClassFile;\n-\n-\/**\n- * The class is resposible to deal with class files and hierarchies of files, such as directories, jars, zips, modules.\n- * The actual logic of bytecode instrumentation is left for subclasses of this class.\n- * @see #instrument(byte[], int)\n- * @see #finishWork()\n- * @author Dmitry Fazunenko\n- * @author Alexey Fedorchenko\n- *\/\n-public abstract class AbstractUniversalInstrumenter {\n-\n-    private String INSTR_FILE_SUFF = \"i\";\n-    private int fileCount = 0; \/\/ counter of processed files\n-    private int classCount = 0; \/\/ counter of processed classes\n-    private int iClassCount = 0; \/\/ counter of successfully instrumented classes\n-\n-    private static final Logger logger;\n-\n-    private InstrumentationPlugin plugin = new ASMInstrumentationPlugin();\n-    private InstrumentationParams params;\n-\n-    static {\n-        Utils.initLogger();\n-        logger = Logger.getLogger(AbstractUniversalInstrumenter.class.getName());\n-    }\n-    \/**\n-     * buffer for reading class data (either from a class file or from an\n-     * archive)\n-     *\/\n-    protected byte[] classBuf = new byte[32 * 1024];\n-    \/**\n-     * whether to overwrite files with their instrumented versions\n-     *\/\n-    protected boolean overwrite;\n-    \/**\n-     * whether to save instrumentation results or not\n-     *\/\n-    protected boolean readOnly;\n-\n-    public AbstractUniversalInstrumenter(boolean overwrite) {\n-        this(overwrite, false);\n-    }\n-\n-    \/**\n-     * <p> Creates AbstractUniversalInstrumenter instance <\/p>\n-     *\n-     * @param overwrite Overwrite existing binary\n-     * @param readOnly Do not produce instrumented binaries (template generation\n-     * purposes)\n-     *\/\n-    public AbstractUniversalInstrumenter(boolean overwrite, boolean readOnly) {\n-        this.overwrite = overwrite;\n-        this.readOnly = readOnly;\n-    }\n-\n-    public void setParams(InstrumentationParams params) {\n-        this.params = params;\n-    }\n-\n-    \/**\n-     * constructs instrumented file name by inserting\n-     * InstrConstants.INSTR_FILE_SUFF string before the first character of the\n-     * extension\n-     *\n-     * @param name file name to construct new name for\n-     * @return constructed name\n-     *\/\n-    protected String makeInstrumentedFileName(String name) {\n-        int dotInd = name.lastIndexOf('.');\n-        if (dotInd <= 0) {\n-            logger.log(Level.SEVERE, \"Invalid classfile name: ''{0}''\", name);\n-        }\n-        return name.substring(0, dotInd) + \".\" + INSTR_FILE_SUFF + name.substring(dotInd + 1, name.length());\n-    }\n-\n-    \/**\n-     * ensures that the class data buffer is capable of storing the specified\n-     * number of bytes\n-     *\n-     * @param length number of bytes to be stored\n-     * @param copy_old_buf preserve contents of the buffer if it must be\n-     * reallocated\n-     *\/\n-    private void ensureClassBufLength(int length, boolean copy_old_buf) {\n-        if (classBuf.length >= length) {\n-            return;\n-        }\n-        byte[] tmp_buf = new byte[length + length \/ 2];\n-        if (copy_old_buf) {\n-            System.arraycopy(classBuf, 0, tmp_buf, 0, classBuf.length);\n-        }\n-        classBuf = tmp_buf;\n-    }\n-\n-    \/**\n-     * instruments specified class file\n-     *\n-     * @param f class file to be instrumented\n-     * @return whether the file represented by f has been instrumented\n-     *\/\n-    protected boolean processClassFile(File f, File outFile) throws IOException {\n-        String fname = f.getPath();\n-        \/\/ to suppress verbosity: logger.log(Level.INFO, \"Instrumenting classfile ''{0}''...\", fname);\n-        boolean instredFine = true;\n-        int classLength = (int) f.length();\n-\n-        if (f.getName().equals(\"module-info.class\")){\n-            return true;\n-        }\n-\n-        ensureClassBufLength(classLength, false);\n-        FileInputStream fis = null;\n-\n-        try {\n-            fis = new FileInputStream(f);\n-        } catch (FileNotFoundException e) {\n-            logger.log(Level.SEVERE, \"  File not found - skipped\", e);\n-            return false;\n-        }\n-        try {\n-            fis.read(classBuf, 0, classLength); \/\/ read in class data\n-            fis.close();\n-        } catch (IOException e) {\n-            logger.log(Level.SEVERE, \"  Error reading '\" + fname + \"' - skipped\", e);\n-            return false;\n-        }\n-\n-        byte[] outBuf = null;\n-        try {\n-            if (f.length() < 4) {\n-                if (f.length() == 0) {\n-                    logger.log(Level.SEVERE, \"  Error reading data from ''{0}'': File is empty\\n - skipped\",\n-                            fname);\n-                    instredFine = false;\n-                } else {\n-                    logger.log(Level.SEVERE, \"  Error reading data from ''{0}'': File is too small ({1}) - skipped\",\n-                            new Object[]{fname, f.length()});\n-                    instredFine = false;\n-                }\n-            } else {\n-                outBuf = instrument(classBuf, classLength); \/\/ instrument the class\n-\/\/                System.out.println(f + \" \" + classBuf.length + \" \" + (outBuf == null ? \"null\" : outBuf.length));\n-            }\n-        } catch (IOException e) {\n-            logger.log(Level.SEVERE, \"  Error reading data from '\" + fname + \"' - skipped\", e);\n-            instredFine = false;\n-        } catch (NullPointerException e) {\n-            logger.log(Level.SEVERE, \"  Error reading data from '\" + fname + \"' - skipped\", e);\n-            instredFine = false;\n-        } catch (Exception e) {\n-            logger.log(Level.SEVERE, \"  Error instrumenting '\" + fname + \"' - skipped\", e);\n-            instredFine = false;\n-        }\n-        if (outBuf == null) {\n-            \/\/ class can't be\/is already instrumented\n-            instredFine = false;\n-            outBuf = classBuf;\n-        } else {\n-            classLength = outBuf.length;\n-        }\n-\n-        if (!readOnly) {\n-            \/\/ construct instrumented class file name\n-            if (outFile == null) {\n-                outFile = f;\n-                f.delete();\n-            }\n-\n-            \/\/ create \"super\" directories if necessary\n-            String parentName = outFile.getParent();\n-            if (parentName != null) {\n-                File parent = new File(parentName);\n-                if (!parent.exists()) {\n-                    parent.mkdirs();\n-                }\n-            }\n-            \/\/ write instrumented classfile\n-            FileOutputStream fos = new FileOutputStream(outFile);\n-            fos.write(outBuf, 0, classLength);\n-            fos.close();\n-        }\n-        return instredFine;\n-    }\n-\n-    \/**\n-     * instruments all class files in the specified directory and its\n-     * subdirectories.\n-     *\n-     * @param dir directory to be instrumented\n-     *\/\n-    protected void processClassDir(File dir, File outDir) throws IOException {\n-        String[] entries = dir.list();\n-        Arrays.sort(entries);\n-        for (int i = 0; i < entries.length; i++) {\n-            File f = new File(dir.getPath() + File.separator + entries[i]);\n-            if (f.isDirectory()) {\n-                processClassDir(f, new File(outDir, entries[i]));\n-            } else {\n-                fileCount++;\n-                if (FILE_TYPE.hasExtension(f.getPath(), CLASS)) {\n-                    classCount++;\n-                    if (processClassFile(f, new File(outDir, entries[i]))) {\n-                        iClassCount++;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * instruments classes in specified jar- or zip-archive\n-     *\n-     * @param arc archive to be instrumented\n-     * @param rtPath runtime jar to me implanted. Ignored when null\n-     *\/\n-    protected void processArc(File arc, File outArc, String rtPath) {\n-        logger.log(Level.INFO, \" - Instrumenting archive ''{0}''...\", arc);\n-        String outFilename = outArc == null ? makeInstrumentedFileName(arc.getPath()) :\n-                outArc.getPath() + File.separator + arc.getName();\n-        logger.log(Level.CONFIG, \"  Output archive ''{0}''\", outFilename);\n-        if (rtPath != null) {\n-            logger.log(Level.CONFIG, \"  RT to implant: ''{0}''\", rtPath);\n-        }\n-        CRC32 crc32 = new CRC32();\n-        ZipInputStream in;\n-        try {\n-            in = new ZipInputStream(new BufferedInputStream(new FileInputStream(arc)));\n-        } catch (Exception ex) {\n-            logger.log(Level.SEVERE, \"  Error opening archive '\" + arc.getPath() + \"'\", ex);\n-            return;\n-        }\n-        ZipOutputStream out = null;\n-        \/\/ construct instrumented archive name and create the file\n-        File outFile = new File(outFilename);\n-        if (!readOnly) {\n-            try {\n-                out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n-            } catch (IOException ex) {\n-                logger.log(Level.SEVERE, \"  Error creating output archive '\" + outFilename + \"'\", ex);\n-            }\n-        }\n-\n-        while (true) {\n-            \/\/ cycle by all entries in the archive\n-            ZipEntry e0 = null; \/\/ last read entry\n-            try {\n-                e0 = in.getNextEntry();\n-            } catch (IOException ex) {\n-                logger.log(Level.SEVERE, \"  Error reading archive entry in '\" + arc.getPath() + \"'\", ex);\n-            }\n-            if (e0 == null) {\n-                \/\/ are there any remaining entries?\n-                break;\n-            }\n-            String ename = e0.getName();\n-            boolean isDir = e0.isDirectory();\n-            if (!isDir) {\n-                fileCount++;\n-            }\n-\n-            int fileLength = (int) e0.getSize();\n-            try {\n-                if (fileLength >= 0) {\n-                    \/\/ is length of the entry known?\n-                    ensureClassBufLength(fileLength, false);\n-                    \/\/ in.read(byte[],int,int) has a bug in JDK1.1.x - using in.read()...\n-                    for (int i = 0; i < fileLength; classBuf[i++] = (byte) in.read()) {\n-                    }\n-                    in.read(classBuf, 0, fileLength);\n-                } else {\n-                    \/\/ no - read until the end of stream is encountered\n-                    int i = 0;\n-                    for (;; i++) {\n-                        int b = in.read();\n-                        if (b < 0) {\n-                            break;\n-                        }\n-                        ensureClassBufLength(i + 1, true); \/\/ make sure classBuf is big enough\n-                        classBuf[i] = (byte) b;\n-                    }\n-                    fileLength = i;\n-                }\n-            } catch (IOException ex) {\n-                logger.log(Level.SEVERE, \"  Error reading archive entry '\" + ename + \"' in '\" + arc.getPath() + \"' - skipped\", ex);\n-            }\n-\n-            byte[] res;\n-            boolean isClass = ename.endsWith(CLASS.getExtension()) && !isDir;\n-            if (isClass) {\n-                \/\/ does the entry represent a class file?\n-                classCount++;\n-                logger.log(Level.INFO, \"  Instrumenting ''{0}''...\", ename);\n-                try {\n-                    res = instrument(classBuf, fileLength); \/\/ try to instrument it\n-                } catch (IOException ex) {\n-                    logger.log(Level.SEVERE, \"    Error reading archive entry '\" + ename + \"' in '\" + arc.getPath() + \"' - skipped\", ex);\n-                    res = null;\n-                } catch (Exception ex) {\n-                    logger.log(Level.SEVERE, \"    Error instrumenting archive entry '\" + ename + \"' in '\" + arc.getPath() + \"' - skipped\", ex);\n-                    res = null;\n-                }\n-            } else {\n-                \/\/ no - will write the buffer unchanged\n-                res = classBuf;\n-                logger.log(Level.INFO, \"  Storing ''{0}''...\", ename);\n-            }\n-\n-            if (!readOnly) {\n-                ZipEntry e1 = new ZipEntry(ename); \/\/ entry to be written to the resulting archive\n-                e1.setSize(fileLength);\n-                e1.setMethod(e0.getMethod());\n-                e1.setExtra(e0.getExtra());\n-                e1.setComment(e0.getComment());\n-                long crc = e0.getCrc();\n-                if (crc >= 0) {\n-                    e1.setCrc(crc);\n-                }\n-                if (res != null && isClass) {\n-                    \/\/ have the class been instrumented?\n-                    if (res.length > 1) {\n-                        iClassCount++;\n-                        if (e0.getCrc() != -1) {\n-                            \/\/ update CRC if needed\n-                            crc32.reset();\n-                            crc32.update(res);\n-                            e1.setCrc(crc32.getValue());\n-                        }\n-                        fileLength = res.length; \/\/ set new length\n-                        e1.setSize(fileLength);\n-                    } else {\n-                        if (res.length == 1 && res[0] == (byte) 'P') {\n-                            logger.log(Level.WARNING, \"    skipped: first pass native preview\");\n-                        }\n-                        if (res.length == 1 && res[0] == (byte) 'F') {\n-                            logger.log(Level.WARNING, \"    skipped: filtered out\");\n-                        }\n-                        res = classBuf;\n-                    }\n-                } else {\n-                    \/\/ no - will write the buffer unchanged\n-                    res = classBuf;\n-                    if (!isClass) {\n-                        logger.log(Level.FINE, \"    ''{0}'' - not instrumented (not a class)\", ename);\n-                    } else {\n-\/\/                        logger.log(Level.WARNING, \"    ''{0}'' - not instrumented\", ename);\n-                    }\n-                }\n-\n-                try {\n-                    out.putNextEntry(e1); \/\/ write the entry to the resulting archive\n-                    out.write(res, 0, fileLength); \/\/ write actual entry data as well\n-                    out.closeEntry();\n-                } catch (IOException ex) {\n-                    logger.log(Level.SEVERE, \"Error adding archive entry '\" + ename + \"' to '\" + outFilename + \"' - skipped\", ex);\n-                }\n-            }\n-        }\n-\n-        \/\/ all entries read\/processed\/written - close input stream\n-        try {\n-            in.close();\n-        } catch (IOException ex) {\n-        }\n-\n-        try {\n-            \/\/ coping JCovRT classes to the output jar\n-            if (rtPath != null) {\n-                logger.log(Level.INFO, \"  Adding saver library...\");\n-                File rt = new File(rtPath);\n-                if (!rt.exists()) {\n-                    throw new IOException(\"Runtime file doesn't exist \" + rt);\n-                }\n-                if (!rt.isFile() || !FILE_TYPE.hasExtension(rt.getName(), JAR, ZIP)) {\n-                    throw new IOException(\"Malformed runtime archive \" + rt);\n-                }\n-                ZipInputStream rtIn = new ZipInputStream(new BufferedInputStream(new FileInputStream(rt)));\n-\n-                outer:\n-                while (true) {\n-                    ZipEntry e0 = rtIn.getNextEntry();\n-                    if (e0 == null) {\n-                        \/\/ are there any remaining entries?\n-                        break;\n-                    }\n-                    String ename = e0.getName();\n-                    if (ename.startsWith(\"META-INF\")) {\n-                        continue;\n-                    }\n-\n-                    int fileLength = (int) e0.getSize();\n-                    if (fileLength >= 0) {\n-                        \/\/ is length of the entry known?\n-                        ensureClassBufLength(fileLength, false);\n-                        \/\/ in.read(byte[],int,int) has a bug in JDK1.1.x - using in.read()...\n-                        for (int i = 0; i < fileLength; classBuf[i++] = (byte) rtIn.read());\n-                        rtIn.read(classBuf, 0, fileLength);\n-                    } else {\n-                        \/\/ no - read until the end of stream is encountered\n-                        int i = 0;\n-                        for (;; i++) {\n-                            int b = rtIn.read();\n-                            if (b < 0) {\n-                                break;\n-                            }\n-                            ensureClassBufLength(i + 1, true); \/\/ make sure classBuf is big enough\n-                            classBuf[i] = (byte) b;\n-                        }\n-                        fileLength = i;\n-                    }\n-                    ZipEntry e1 = new ZipEntry(ename); \/\/ entry to be written to the resulting archive\n-                    e1.setSize(fileLength);\n-                    e1.setMethod(e0.getMethod());\n-                    e1.setExtra(e0.getExtra());\n-                    e1.setComment(e0.getComment());\n-                    long crc = e0.getCrc();\n-                    if (crc >= 0) {\n-                        e1.setCrc(crc);\n-                    }\n-\n-                    ZipInputStream inJar = new ZipInputStream(new BufferedInputStream(new FileInputStream(arc)));\n-                    try {\n-                        ZipEntry checking;\n-                        while (true) {\n-                            checking = inJar.getNextEntry();\n-                            if (checking == null) {\n-                                break;\n-                            }\n-                            if (checking.getName().equals(e1.getName())) {\n-                                if (checking.getSize() != e1.getSize()) {\n-                                    \/\/ logger.log(Level.WARNING, \"Output jar contains file {0} that was found in runtime jar but files sizes differ, skipping\",\n-                                    \/\/ checking.getName());\n-                                } else {\n-                                    \/\/ logger.log(Level.INFO, \"Output jar contains file {0} that was found in runtime jar, skipping\",\n-                                    \/\/ checking.getName());\n-                                }\n-                                inJar.close();\n-                                continue outer;\n-                            }\n-                        }\n-                    } catch (EOFException e) {\n-                        \/\/ logger.log(Level.SEVERE);\n-                    } finally {\n-                        inJar.close();\n-                    }\/**\/\n-\n-                    \/\/ logger.log(Level.INFO, \"Adding runtime file {0} to output jar {1}\", new Object[]{e1.getName, jar.getName()})\n-                    try {\n-                        out.putNextEntry(e1); \/\/ write the entry to the resulting archive\n-                    } catch (ZipException e) {\n-                        if (!e.getMessage().startsWith(\"duplicate entry\")) {\n-                            throw e;\n-                        }\n-                    }\n-                    out.write(classBuf, 0, fileLength); \/\/ write actual entry data as well\n-                    out.closeEntry();\n-                }\n-\n-                rtIn.close();\n-            }\n-\n-            if (out != null) {\n-                out.finish();\n-                out.close();\n-            }\n-        } catch (Throwable ex) {\n-            logger.log(Level.SEVERE, \"Error processing archive '\" + arc.getPath() + \"'\", ex);\n-            outFile.delete();\n-            return;\n-        }\n-        if (!readOnly && outArc == null && overwrite) {\n-            if (!arc.delete()) {\n-                logger.log(Level.WARNING, \" Can''t remove initial JAR file ''{0}''\",\n-                        arc.getAbsolutePath());\n-            }\n-            if (!outFile.renameTo(arc)) {\n-                logger.log(Level.WARNING, \" Can''t rename result JAR file ''{0}' to ''{1}''. Please move manually\",\n-                        new Object[]{outFile.getAbsolutePath(), arc.getAbsolutePath()});\n-            }\n-        }\n-    }\n-\n-    public void instrument(String arg) throws IOException {\n-        instrument(new File(arg), null, null, false);\n-    }\n-\n-    \/**\n-     * determines what kind of object is represented by given path and invokes\n-     * appropriate methods to instrument the object\n-     *\n-     * @param arg path to a class file, zip\/jar archive or a directory\n-     *\/\n-    public void instrument(File arg, File outDir) throws IOException {\n-        instrument(arg, outDir, null, false);\n-    }\n-\n-    public void instrument(File arg, File outDir, String rtPath) throws IOException {\n-        instrument(arg, outDir, rtPath, false);\n-    }\n-\n-    public void instrument(File instrumentingPath, File destinationPath, String rtPath, boolean recursive) throws IOException {\n-        instrument(instrumentingPath, destinationPath, rtPath, null, recursive);\n-    }\n-\n-    \/**\n-     * <p> Determines what kind of object is represented by given path and\n-     * invokes appropriate methods to instrument the object <\/p>\n-     *\n-     * @param instrumentingPath path to a class file, zip\/jar archive or a\n-     * directory\n-     * @param destinationPath output path. Initial file is replaced in case if\n-     * null\n-     * @param rtPath path to runtime jar. Ignored if null\n-     * @param recursive insrument method will recurse through initial directory\n-     * if true instrumenting each file in the tree\n-     *\/\n-    public void instrument(File instrumentingPath, File destinationPath,\n-                           String rtPath, ArrayList<String> rtClassDirTargets,\n-                           boolean recursive) throws IOException {\n-\/\/        fileCount = 0;\n-\/\/        classCount = 0;\n-\/\/        iClassCount = 0;\n-\n-        if (!instrumentingPath.exists()) {\n-            logger.log(Level.WARNING, \"Path ''{0}'' doesn''t exist - skipped\", instrumentingPath);\n-            return;\n-        }\n-        boolean isClassFile = false;\n-        if (instrumentingPath.isDirectory()) {\n-            if (destinationPath == null) {\n-                destinationPath = instrumentingPath;\n-            }\n-            Path in = Path.of(instrumentingPath.getAbsolutePath());\n-            Path out = Path.of(destinationPath.getAbsolutePath());\n-            List<String> classes = Files.find(in, Integer.MAX_VALUE,\n-                            (f, a) -> f.getFileName().toString().endsWith(\".class\"))\n-                    .map(f -> in.relativize(f))\n-                    .map(Path::toString)\n-                    .collect(Collectors.toList());\n-\/\/            try {\n-\/\/                plugin.instrument(classes, f -> {\n-\/\/                    try {\n-\/\/                        return Files.readAllBytes(in.resolve(f));\n-\/\/                    } catch (IOException e) {\n-\/\/                        throw new UncheckedIOException(e);\n-\/\/                    }\n-\/\/                }, (c, d) -> {\n-\/\/                    try {\n-\/\/                        Files.write(out.resolve(c), d);\n-\/\/                    } catch (IOException e) {\n-\/\/                        throw new UncheckedIOException(e);\n-\/\/                    }\n-\/\/                }, params);\n-\/\/            } catch (Exception e) {\n-\/\/                throw new RuntimeException(e);\n-\/\/            }\n-            \/\/TODO what about recursive?\n-\/\/            if (recursive) {\n-\/\/\n-\/\/                Utils.addToClasspath(instrumentingPath);\n-\/\/\n-\/\/                logger.log(Level.FINE, \"Scanning directory ''{0}''...\", instrumentingPath);\n-\/\/                File[] entries = instrumentingPath.listFiles();\n-\/\/                Arrays.sort(entries);\n-\/\/                for (int i = 0; i < entries.length; i++) {\n-\/\/                    destinationPath.mkdir();\n-\/\/                    instrument(entries[i], new File(destinationPath, entries[i].getName()), rtPath, rtClassDirTargets, recursive);\n-\/\/                }\n-\/\/            } else {\n-\/\/                logger.log(Level.INFO, \"Instrumenting directory ''{0}''...\", instrumentingPath);\n-\/\/                processClassDir(instrumentingPath, destinationPath);\n-\/\/                if (rtPath != null) {\n-\/\/                    if (destinationPath != null) {\n-\/\/                        unjarRT(rtPath, destinationPath);\n-\/\/                    } else {\n-\/\/                        unjarRT(rtPath, instrumentingPath);\n-\/\/                    }\n-\/\/                }\n-\/\/            }\n-        } else if ( FILE_TYPE.hasExtension(instrumentingPath.getName(), JAR, ZIP, WAR) ) {\n-            \/\/ initially instrument(jar, toJar) meant create instrumented \"toJar\/jar\". But in recursive mode it should be just \"toJar\".\n-            if (rtClassDirTargets == null || rtClassDirTargets.contains(instrumentingPath.getPath())) {\n-                if (recursive) {\n-                    processArc(instrumentingPath, destinationPath.getParentFile(), rtPath);\n-                } else {\n-                    processArc(instrumentingPath, destinationPath, rtPath);\n-                }\n-            } else {\n-                if (recursive) {\n-                    processArc(instrumentingPath, destinationPath.getParentFile(), null);\n-                } else {\n-                    processArc(instrumentingPath, destinationPath, null);\n-                }\n-            }\n-        } else if (instrumentingPath.getName().equals(\"modules\")) {\n-            instrumentModulesFile(instrumentingPath, destinationPath);\n-        } else if (isClassFile(instrumentingPath.getName())) {\n-            if (destinationPath == null) {\n-                destinationPath = instrumentingPath;\n-            }\n-            processClassFile(instrumentingPath, destinationPath);\n-            isClassFile = true;\n-        } else {\n-            if (destinationPath == null) {\n-                destinationPath = instrumentingPath;\n-            }\n-            Utils.copyFile(instrumentingPath, destinationPath);\n-            return;\n-        }\n-        if (!isClassFile) {\n-            logger.log(Level.INFO, \"Summary for ''{0}'': files total={1}, classes total={2}, instrumented classes total={3}\",\n-                    new Object[]{instrumentingPath, fileCount, classCount, iClassCount});\n-        }\n-    }\n-\n-    public void processClassFileInModules(Path file, File destinationPath){\n-        String fname = file.toAbsolutePath().toString();\n-        try {\n-            final String distinationStr = destinationPath.toString();\n-            classBuf = Files.readAllBytes(file);\n-            int classLength = classBuf.length;\n-            byte[] outBuf = null;\n-            try {\n-                if (!\"module-info.class\".equals(file.getFileName().toString())) {\n-                    outBuf = instrument(classBuf, classLength);\n-                }\n-            } catch (IOException e) {\n-                logger.log(Level.SEVERE, \"  Error reading data from '\" + fname + \"' - skipped\", e);\n-            } catch (NullPointerException e) {\n-                logger.log(Level.SEVERE, \"  Error reading data from '\" + fname + \"' - skipped\", e);\n-            } catch (Exception e) {\n-                logger.log(Level.SEVERE, \"  Error instrumenting '\" + fname + \"' - skipped\", e);\n-            }\n-            if (outBuf != null) {\n-\n-                classLength = outBuf.length;\n-\n-                File outFile = new File(distinationStr + File.separator + fname);\n-                String parentName = outFile.getParent();\n-                if (parentName != null) {\n-                    File parent = new File(parentName);\n-                    if (!parent.exists()) {\n-                        parent.mkdirs();\n-                    }\n-                }\n-                \/\/ write instrumented classfile\n-                FileOutputStream fos = new FileOutputStream(outFile);\n-                fos.write(outBuf, 0, classLength);\n-                try {\n-                    fos.close();\n-                } catch (IOException e) {\n-                    logger.log(Level.SEVERE, \"  Error writing data to '\" + outFile.getAbsolutePath() + \"' - skipped\", e);\n-                }\n-            }\n-        }\n-        catch(IOException e){\n-            logger.log(Level.SEVERE, \"  Error processing classFile by Path '\" + fname + \"' - skipped\", e);\n-        }\n-    }\n-\n-    private void instrumentModulesFile(File modulePath, final File destinationPath){\n-\n-        try {\n-            Utils.addToClasspath(modulePath.getParentFile().getParentFile());\n-            FileSystem fs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n-            final Path path = fs.getPath(\"\/modules\/\");\n-\n-            Files.walkFileTree(path, new SimpleFileVisitor<Path>(){\n-                @Override\n-                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                    if(!attrs.isDirectory() && isClassFile(file.getFileName().toString())){\n-                        OverriddenClassWriter.addClassInfo(Files.newInputStream(file));\n-                    }\n-                    return FileVisitResult.CONTINUE;\n-                }\n-            });\n-\n-            Files.walkFileTree(path, new SimpleFileVisitor<Path>(){\n-                @Override\n-                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                    if(!attrs.isDirectory() && isClassFile(file.getFileName().toString())){\n-                        processClassFileInModules(file, destinationPath);\n-                    }\n-                    return FileVisitResult.CONTINUE;\n-                }\n-            });\n-\n-        } catch (Exception e) {\n-            logger.log(Level.SEVERE, \"Modules instrumentaion failed\", e);\n-        }\n-\n-    }\n-\n-    \/**\n-     * <p> Treats given byte array as a class data and instruments the class.\n-     * Any Exception thrown from this metod will be treated as error during\n-     * instrumentation, class will be skipped. <\/p> <p> It's called for\n-     * instrumenting each binary file <\/p>\n-     *\n-     * @param classData class data to be instrumented\n-     * @param classLength length of the data\n-     * @return bytes of instrumented class. null means class won't be changed.\n-     *\/\n-    protected abstract byte[] instrument(byte[] classData, int classLength) throws IOException;\n-\n-    public abstract void finishWork();\n-\n-    \/**\n-     * Get classfiles from a jar file. Use to implant rt classfiles to unpacked\n-     * binaries.\n-     *\n-     * @param rtJar\n-     * @param output\n-     * @throws IOException\n-     *\/\n-    public void unjarRT(String rtJar, File output) throws IOException {\n-        if (output == null) {\n-            throw new IllegalArgumentException(\"Output path (jar file or classfile directory) needed to copy runtime jar file to\");\n-        }\n-        File rt = new File(rtJar);\n-        if (!rt.exists()) {\n-            throw new IOException(\"Runtime file doesn't exist \" + rt);\n-        }\n-        if (!rt.isFile() || !FILE_TYPE.hasExtension(rt.getName(), JAR, ZIP)) {\n-            throw new IOException(\"Malformed runtime archive \" + rt);\n-        }\n-\n-        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(rt)));\n-        while (true) {\n-            ZipEntry e0 = in.getNextEntry();\n-            if (e0 == null) {\n-                \/\/ are there any remaining entries?\n-                break;\n-            }\n-            String ename = e0.getName();\n-            if (ename.startsWith(\"META-INF\")) {\n-                continue;\n-            }\n-\n-            int fileLength = (int) e0.getSize();\n-            if (fileLength >= 0) {\n-                \/\/ is length of the entry known?\n-                ensureClassBufLength(fileLength, false);\n-                \/\/ in.read(byte[],int,int) has a bug in JDK1.1.x - using in.read()...\n-                for (int i = 0; i < fileLength; classBuf[i++] = (byte) in.read());\n-                in.read(classBuf, 0, fileLength);\n-            } else {\n-                \/\/ no - read until the end of stream is encountered\n-                int i = 0;\n-                for (;; i++) {\n-                    int b = in.read();\n-                    if (b < 0) {\n-                        break;\n-                    }\n-                    ensureClassBufLength(i + 1, true); \/\/ make sure classBuf is big enough\n-                    classBuf[i] = (byte) b;\n-                }\n-                fileLength = i;\n-            }\n-\n-            File outFile = new File(output.getPath() + File.separator + e0.getName());\n-            if (!e0.isDirectory()) {\n-                if (outFile.exists()) {\n-                    \/\/ logger.log(Level.WARNING, \"Output classfile directory contains file {0} that was found in runtime jar,\n-                    \/\/ skipping without contains checking\", e0.getName());\n-                    continue;\n-                } else {\n-                    \/\/ logger.log(Level.INFO, \"Adding runtime file {0} to output directory {1}\",\n-                    \/\/ new Object[]{e1.getName, outDir.getName()})\n-                    String parentName = outFile.getAbsoluteFile().getParent();\n-                    if (parentName != null) {\n-                        File parent = new File(parentName);\n-                        if (!parent.exists()) {\n-                            parent.mkdirs();\n-                        }\n-                    }\n-                    FileOutputStream fos = new FileOutputStream(outFile);\n-                    fos.write(classBuf, 0, fileLength);\n-                    fos.close();\n-                }\n-            }\n-        }\n-        in.close();\n-        }\n-}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/insert\/AbstractUniversalInstrumenter.java","additions":0,"deletions":842,"binary":false,"changes":842,"status":"deleted"}]}