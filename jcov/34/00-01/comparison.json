{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import java.lang.instrument.Instrumentation;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Agent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n+import com.sun.tdk.jcov.instrument.Instrumentation;\n@@ -41,1 +41,0 @@\n-import java.io.OutputStream;\n@@ -44,0 +43,2 @@\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n@@ -48,1 +49,1 @@\n-import java.util.function.BiConsumer;\n+import java.util.Map;\n@@ -55,0 +56,1 @@\n+import static com.sun.tdk.jcov.instrument.InstrumentationPlugin.TEMPLATE_ARTIFACT;\n@@ -94,1 +96,1 @@\n-    private AbstractUniversalInstrumenter instrumenter;\n+\/\/    private AbstractUniversalInstrumenter instrumenter;\n@@ -98,0 +100,1 @@\n+    \/\/TODO do need both?\n@@ -99,0 +102,1 @@\n+    private Instrumentation instrumentation = new Instrumentation(plugin);\n@@ -133,1 +137,1 @@\n-        instrumenter.finishWork();\n+\/\/        instrumenter.finishWork();\n@@ -146,1 +150,1 @@\n-     * @see #setDefaultInstrumenter()\n+     * @see #setup()\n@@ -164,1 +168,1 @@\n-     * @see #setDefaultInstrumenter()\n+     * @see #setup()\n@@ -167,3 +171,3 @@\n-    public void instrumentFile(File file, File outDir, String includeRTJar) throws IOException {\n-        setDefaultInstrumenter();\n-        instrumenter.instrument(file, outDir, includeRTJar, recurse);\n+    public void instrumentFile(File file, File outDir, String includeRTJar) throws Exception {\n+        instrumentFiles(new String[] {file.getAbsolutePath()}, outDir, includeRTJar);\n+        \/\/instrumenter.instrument(file, outDir, includeRTJar, recurse);\n@@ -184,1 +188,1 @@\n-     * @see #setDefaultInstrumenter()\n+     * @see #setup()\n@@ -187,1 +191,1 @@\n-    public void instrumentFile(String file, File outDir, String includeRTJar) throws IOException {\n+    public void instrumentFile(String file, File outDir, String includeRTJar) throws Exception {\n@@ -192,1 +196,1 @@\n-    public void instrumentFile(String file, File outDir, String includeRTJar, String moduleName) throws IOException {\n+    public void instrumentFile(String file, File outDir, String includeRTJar, String moduleName) throws Exception {\n@@ -216,1 +220,1 @@\n-            instrumentFile(new File(file), outDir, includeRTJar);\n+            instrumentFiles(new String[] {file}, outDir, includeRTJar);\n@@ -246,2 +250,1 @@\n-        \/\/TODO rename\n-        setDefaultInstrumenter();\n+        setup();\n@@ -249,24 +252,34 @@\n-            Path in = Path.of(file);\n-            Path out = (outDir != null) ? outDir.toPath() : in;\n-            InstrumentationPlugin.ClassHierarchyReader reader;\n-            BiConsumer<String, byte[]> writer;\n-            if (Files.isRegularFile(in) && file.endsWith(\".class\")) {\n-                reader = new InstrumentationPlugin.SingleClassReader(in);\n-                writer = (c, b) -> {\n-                    try(OutputStream outputStream = Files.newOutputStream(out)) {\n-                        outputStream.write(b);\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                };\n-            } else if (Files.isRegularFile(in) && file.endsWith(\".jar\")) {\n-                reader = new InstrumentationPlugin.JarFileReader(in);\n-                writer = new InstrumentationPlugin.ClassHierarchyJarWriter(out);\n-            } else if (Files.isDirectory(in)) {\n-                reader = new InstrumentationPlugin.ClassHierarchyFileSystemReader(in);\n-                writer = new InstrumentationPlugin.ClassHierarchyFileSystemWriter(out);\n-            }\n-            else throw new IllegalStateException(\"Unknown input kind: \" + file);\n-            if(implantRT != null) {\n-                InstrumentationPlugin.ClassHierarchyReader implantReader = new InstrumentationPlugin.JarFileReader(implantRT);\n-                plugin = new InstrumentationPlugin.ImplantingPlugin(plugin, implantReader.getClasses(), implantReader.getLoader());\n+            Path in, out;\n+            FileSystem inFS = null, outFS = null;\n+            Path inPath = Path.of(file);\n+            if (Files.isRegularFile(inPath) && file.endsWith(\".class\")) {\n+                \/\/not implemented yet\n+                \/\/TODO implement by directly calling the plugin\n+                \/\/TODO deprecate in documentation: instead of providing specific files, ask the user to provide\n+                \/\/a class hierarchy root and filters\n+                throw new RuntimeException();\n+            } else {\n+                if (Files.isRegularFile(inPath) && file.endsWith(\".jar\")) {\n+                    inFS = FileSystems.newFileSystem(Path.of(file), null);\n+                    in = inFS.getPath(\"\/\");\n+                } else if (Files.isDirectory(inPath)) {\n+                    in = Path.of(file);\n+                } else throw new IllegalStateException(\"Unknown input kind: \" + file);\n+                Path outPath  = (outDir != null) ? outDir.toPath().resolve(inPath.getFileName()) : inPath;\n+                if (Files.isRegularFile(outPath) && outPath.toString().endsWith(\".class\")) {\n+                    \/\/not implemented yet\n+                    throw new RuntimeException();\n+                } else if (Files.isRegularFile(outPath) && outPath.toString().endsWith(\".jar\")) {\n+                    outFS = FileSystems.newFileSystem(outPath, null);\n+                    out = outFS.getPath(\"\/\");\n+                } else if (Files.isDirectory(outPath)) {\n+                    out = outPath;\n+                } else throw new IllegalStateException(\"Unknown input kind: \" + file);\n+                Instrumentation.FileSystemImplant implant = null;\n+                if (implantRT != null) {\n+                    implant = new Instrumentation.JarImplant(Path.of(implantRT));\n+                }\n+                instrumentation.instrument(in, out, params, implant);\n+                if(inFS != null) inFS.close();\n+                if(outFS != null) outFS.close();\n+                if(implant != null) implant.close();\n@@ -274,1 +287,0 @@\n-            plugin.instrument(reader.getClasses(), reader.getLoader(), writer, params);\n@@ -284,1 +296,1 @@\n-        setDefaultInstrumenter();\n+        setup();\n@@ -286,1 +298,2 @@\n-            instrumenter.instrument(new File(file), outDir, implantRT, recurse);\n+            \/\/TODO\n+            \/\/instrumenter.instrument(new File(file), outDir, implantRT, recurse);\n@@ -296,1 +309,1 @@\n-        setDefaultInstrumenter();\n+        setup();\n@@ -302,1 +315,1 @@\n-    private void setDefaultInstrumenter() {\n+    private void setup() {\n@@ -334,30 +347,30 @@\n-        if (instrumenter == null) {\n-            instrumenter = new AbstractUniversalInstrumenter(true) {\n-                protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n-                    return morph.morph(classData, cl, flushPath);\n-                }\n-\n-                public void finishWork() {\n-                    if (subsequentInstr) {\n-                        morph.saveData(MERGE.MERGE); \/\/ template should be initialized\n-                    } else {\n-                        morph.saveData(template, null, MERGE.OVERWRITE); \/\/ template should be initialized\n-                    }\n-                }\n-\n-                 public void processClassFileInModules(Path filePath, File outDir){\n-                    if (morph != null){\n-                        if (filePath != null){\n-                            String mpath = filePath.toAbsolutePath().toString();\n-                            mpath = mpath.substring(\"\/modules\/\".length());\n-                            if (mpath.contains(\"\/\")){\n-                                String module_name = mpath.substring(0, mpath.indexOf(\"\/\"));\n-                                morph.setCurrentModuleName(module_name);\n-                            }\n-                        }\n-                        super.processClassFileInModules(filePath, outDir);\n-                    }\n-                }\n-            };\n-            instrumenter.setParams(params);\n-        }\n+\/\/        if (instrumenter == null) {\n+\/\/            instrumenter = new AbstractUniversalInstrumenter(true) {\n+\/\/                protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n+\/\/                    return morph.morph(classData, cl, flushPath);\n+\/\/                }\n+\/\/\n+\/\/                public void finishWork() {\n+\/\/                    if (subsequentInstr) {\n+\/\/                        morph.saveData(MERGE.MERGE); \/\/ template should be initialized\n+\/\/                    } else {\n+\/\/                        morph.saveData(template, null, MERGE.OVERWRITE); \/\/ template should be initialized\n+\/\/                    }\n+\/\/                }\n+\/\/\n+\/\/                 public void processClassFileInModules(Path filePath, File outDir){\n+\/\/                    if (morph != null){\n+\/\/                        if (filePath != null){\n+\/\/                            String mpath = filePath.toAbsolutePath().toString();\n+\/\/                            mpath = mpath.substring(\"\/modules\/\".length());\n+\/\/                            if (mpath.contains(\"\/\")){\n+\/\/                                String module_name = mpath.substring(0, mpath.indexOf(\"\/\"));\n+\/\/                                morph.setCurrentModuleName(module_name);\n+\/\/                            }\n+\/\/                        }\n+\/\/                        super.processClassFileInModules(filePath, outDir);\n+\/\/                    }\n+\/\/                }\n+\/\/            };\n+\/\/            instrumenter.setParams(params);\n+\/\/        }\n@@ -403,7 +416,8 @@\n-        plugin.complete(() -> {\n-            try {\n-                return Files.newOutputStream(Path.of(template));\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        });\n+        if (subsequentInstr) {\n+            morph.saveData(MERGE.MERGE); \/\/ template should be initialized\n+        } else {\n+            morph.saveData(template, null, MERGE.OVERWRITE); \/\/ template should be initialized\n+        }\n+        Path templ = Path.of(template);\n+        instrumentation.complete(templ.getParent(), Map.of(TEMPLATE_ARTIFACT, templ));\n+\/\/        plugin.complete().get(TEMPLATE_ARTIFACT).accept(Files.newOutputStream(Path.of(template)));\n@@ -548,0 +562,1 @@\n+        instrumentation = new Instrumentation(plugin);\n@@ -740,1 +755,1 @@\n-            if(pluginClass != null && !pluginClass.isEmpty())\n+            if(pluginClass != null && !pluginClass.isEmpty()) {\n@@ -743,0 +758,2 @@\n+                instrumentation = new Instrumentation(plugin);\n+            }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":100,"deletions":83,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+package com.sun.tdk.jcov.instrument;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A utility class to implement the most common case of using the InstrumentationPlaugin: with the files in filesystems.\n+ * Suitable to be used for any supported filesystem type.\n+ *\/\n+public class Instrumentation {\n+    private final InstrumentationPlugin plugin;\n+\n+    public Instrumentation(InstrumentationPlugin plugin) {\n+        this.plugin = plugin;\n+    }\n+\n+    \/**\n+     * Instruments classes with the specified plugin, reading from one location and saving to another. Resources which\n+     * are not classfiles are copied derectly. Content of the implant is also copied into the output.\n+     *\n+     * @param from\n+     * @param to\n+     * @param params\n+     * @param implant\n+     * @throws Exception\n+     *\/\n+    \/\/TODO should implant really even be a part of this? easily could be added after this call\n+    public void instrument(Path from, Path to, InstrumentationParams params, Implant implant)\n+            throws Exception {\n+        List<Path> resources = Files.find(from, Integer.MAX_VALUE,\n+                        (f, a) -> Files.isRegularFile(f))\n+                .collect(Collectors.toList());\n+        plugin.instrument(resources.stream()\n+                            .filter(r -> isClass(r))\n+                        .map(r -> toClassName(from, r))\n+                        .collect(Collectors.toList()),\n+                c -> {\n+                    try {\n+                        return Files.readAllBytes(toResource(from, c));\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                },\n+                (c, b) -> {\n+                    try {\n+                        Files.write(toResource(to, c), b);\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                },\n+                params);\n+        resources.stream().filter(r -> !isClass(r)).forEach(p -> {\n+            try {\n+                Files.write(to.resolve(from.relativize(p)), Files.readAllBytes(p));\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        if(implant != null) {\n+            for (String r : implant.resources()) Files.write(to.resolve(r), implant.read(r));\n+        }\n+    }\n+\n+    public void complete(Path outputDir, Map<String, Path> artifactMap) throws Exception {\n+        Map<String, Consumer<OutputStream>> pluginArtifacts = plugin.complete();\n+        for (String a : pluginArtifacts.keySet()) {\n+            Path to = artifactMap.containsKey(a) ? artifactMap.get(a) : outputDir.resolve(a);\n+            pluginArtifacts.get(a).accept(Files.newOutputStream(to));\n+        }\n+    }\n+\n+    private static boolean isClass(Path p) {\n+        return p.getFileName().toString().endsWith(\".class\");\n+    }\n+\n+    static String toClassName(Path root, Path classFile) {\n+        String shortFileName = root.relativize(classFile).toString();\n+        return shortFileName.substring(0, shortFileName.length() - 6)\/\/\".class\"\n+                .replace(root.getFileSystem().getSeparator(), \".\");\n+    }\n+\n+    static Path toResource(Path root, String className) {\n+        return root.resolve(className.replace(\".\", root.getFileSystem().getSeparator()) + \".class\");\n+    }\n+\n+    static public class PathImplant implements Implant {\n+\n+        private final Path source;\n+\n+        public PathImplant(Path source) {\n+            this.source = source;\n+        }\n+\n+        public Path getSource() {\n+            return source;\n+        }\n+\n+        protected boolean accept(Path path, BasicFileAttributes fa) {return true;}\n+\n+        @Override\n+        public Collection<String> resources() throws IOException {\n+            return Files.find(source, Integer.MAX_VALUE, (p,a) -> Files.isRegularFile(p) && accept(p, a))\n+                    .map(p -> source.relativize(p).toString())\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public byte[] read(String path) {\n+            return new byte[0];\n+        }\n+    }\n+\n+    public interface Implant {\n+        \/\/paths relative to the result root\n+        Collection<String> resources() throws Exception;\n+        byte[] read(String path) throws Exception;\n+    }\n+\n+    public static class FileSystemImplant extends PathImplant implements AutoCloseable {\n+        private final FileSystem fs;\n+        public FileSystemImplant(FileSystem fs) throws IOException {\n+            super(fs.getPath(\"\/\"));\n+            this.fs = fs;\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            fs.close();\n+        }\n+    }\n+\n+    public static class JarImplant extends FileSystemImplant {\n+\n+        public JarImplant(Path jar) throws IOException {\n+            super(FileSystems.newFileSystem(jar, null));\n+        }\n+\n+        @Override\n+        protected boolean accept(Path path, BasicFileAttributes fa) {\n+            return !path.toString().startsWith(\"\/META-INF\");\n+        }\n+    }\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/Instrumentation.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -39,1 +38,0 @@\n-import java.util.Collection;\n@@ -208,6 +206,1 @@\n-        return new InstrumentationPlugin.FilteringPlugin(plugin) {\n-            @Override\n-            protected boolean filter(String cls) {\n-                return isIncluded(cls);\n-            }\n-        };\n+        return new InstrumentationPlugin.FilteringPlugin(plugin, this::isIncluded);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationParams.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.io.IOException;\n+import java.io.InputStream;\n@@ -29,6 +29,0 @@\n-import java.io.UncheckedIOException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n@@ -36,1 +30,1 @@\n-import java.util.List;\n+import java.util.Map;\n@@ -38,0 +32,1 @@\n+import java.util.function.Consumer;\n@@ -39,0 +34,1 @@\n+import java.util.function.Predicate;\n@@ -47,0 +43,5 @@\n+    \/**\n+     * An identifier for template artifact.\n+     *\/\n+    String TEMPLATE_ARTIFACT = \"template.xml\";\n+\n@@ -50,1 +51,9 @@\n-    void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception;\n+    \/**\n+     * Completes the instrumentation proccess and returns a map of instrumentation artifacts.\n+     * @see #TEMPLATE_ARTIFACT\n+     *\n+     * @return the artifact map. The artifacts are identifiable by a string. The artifacts are consumers of\n+     * OutputStream's.\n+     * @throws Exception\n+     *\/\n+    Map<String, Consumer<OutputStream>> complete() throws Exception;\n@@ -54,1 +63,1 @@\n-    abstract class FilteringPlugin implements InstrumentationPlugin {\n+    class FilteringPlugin implements InstrumentationPlugin {\n@@ -56,0 +65,1 @@\n+        private final Predicate<String> filter;\n@@ -57,1 +67,1 @@\n-        public FilteringPlugin(InstrumentationPlugin inner) {\n+        public FilteringPlugin(InstrumentationPlugin inner, Predicate<String> filter) {\n@@ -59,0 +69,1 @@\n+            this.filter = filter;\n@@ -61,1 +72,0 @@\n-        protected abstract boolean filter(String cls);\n@@ -65,1 +75,1 @@\n-            inner.instrument(classes.stream().filter(this::filter).collect(Collectors.toList()),\n+            inner.instrument(classes.stream().filter(filter).collect(Collectors.toList()),\n@@ -67,0 +77,1 @@\n+            classes.stream().filter(filter.negate()).forEach(c -> saver.accept(c, loader.apply(c)));\n@@ -70,76 +81,2 @@\n-        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n-            inner.complete(templateStreamSupplier);\n-        }\n-    }\n-\n-    interface ModuleImplant {\n-        \/\/TODO qualified exports?\n-        List<String> exports();\n-        Collection<String> classes();\n-        Function<String, byte[]> loader();\n-    }\n-\n-    abstract class ModuleImplantingPlugin implements InstrumentationPlugin {\n-\n-        public static final String MODULE_INFO_CLASS = \"module-info.class\";\n-\n-        public interface ModuleInstrumentationPlugin extends InstrumentationPlugin {\n-            String getModuleName(byte[] moduleInfo);\n-            byte[] addExports(List<String> exports, byte[] moduleInfo);\n-        }\n-\n-        private final ModuleInstrumentationPlugin inner;\n-        private final Function<String, ModuleImplant> implants;\n-\n-        public ModuleImplantingPlugin(ModuleInstrumentationPlugin inner, Function<String, ModuleImplant> implants) {\n-            this.inner = inner;\n-            this.implants = implants;\n-        }\n-\n-        @Override\n-        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n-                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n-            inner.instrument(classes, loader, saver, parameters);\n-            String moduleName = inner.getModuleName(loader.apply(MODULE_INFO_CLASS));\n-            if(moduleName != null) {\n-                ModuleImplant implant = implants.apply(moduleName);\n-                if(implant != null) {\n-                    saver.accept(MODULE_INFO_CLASS, loader.apply(MODULE_INFO_CLASS));\n-                    for(String c : implant.classes()) saver.accept(c, implant.loader().apply(c));\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void complete(Supplier<OutputStream> template) throws Exception {\n-            inner.complete(template);\n-        }\n-    }\n-\n-    class ImplantingPlugin implements InstrumentationPlugin {\n-        private final Collection<String> implant;\n-        private final Function<String, byte[]> implantLoader;\n-        private final InstrumentationPlugin inner;\n-\n-        \/\/TODO similar to ModuleImplantingPlugin have different implants for different locations somehow?\n-        public ImplantingPlugin(InstrumentationPlugin inner,\n-                                Collection<String> implant, Function<String, byte[]> loader) {\n-            this.implant = implant;\n-            this.implantLoader = loader;\n-            this.inner = inner;\n-        }\n-\n-        @Override\n-        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n-                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n-            inner.instrument(classes, loader, saver, parameters);\n-            implant.forEach(c -> saver.accept(c, implantLoader.apply(c)));\n-        }\n-\n-        @Override\n-        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n-            inner.complete(templateStreamSupplier);\n-        }\n-\n-        protected InstrumentationPlugin inner() {\n-            return inner;\n+        public Map<String, Consumer<OutputStream>> complete() throws Exception {\n+            return inner.complete();\n@@ -147,6 +84,0 @@\n-    }\n-\n-    interface ClassHierarchyReader {\n-        Collection<String> getClasses() throws Exception;\n-        Function<String, byte[]> getLoader() throws Exception;\n-    }\n@@ -154,124 +85,4 @@\n-    class ClassHierarchyFileSystemReader implements ClassHierarchyReader {\n-\n-        private final FileSystem fs;\n-        private final Path root;\n-\n-        public ClassHierarchyFileSystemReader(FileSystem fs, Path root) {\n-            this.fs = fs;\n-            this.root = root;\n-        }\n-\n-        public ClassHierarchyFileSystemReader(Path root) {\n-            this(FileSystems.getDefault(), root);\n-        }\n-\n-        public ClassHierarchyFileSystemReader(FileSystem fs) {\n-            this(fs, fs.getRootDirectories().iterator().next());\n-        }\n-\n-        @Override\n-        public Collection<String> getClasses() throws IOException {\n-            return Files.find(root, Integer.MAX_VALUE,\n-                            (f, a) -> f.toString().endsWith(\".class\"))\n-                    .map(f -> root.relativize(f))\n-                    .map(Path::toString)\n-                    .map(s -> s.substring(0, s.length() - \".class\".length()))\n-                    .collect(Collectors.toList());\n-        }\n-\n-        @Override\n-        public Function<String, byte[]> getLoader() {\n-            return f -> {\n-                try {\n-                    return Files.readAllBytes(root.resolve(f + \".class\"));\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-            };\n-        }\n-    }\n-\n-    class SingleClassReader implements ClassHierarchyReader {\n-\n-        private final Path source;\n-\n-        public SingleClassReader(Path source) {\n-            if(!source.toString().endsWith(\"class\")) throw new IllegalArgumentException(\"Must be a class file: \" + source);\n-            this.source = source;\n-        }\n-\n-        @Override\n-        public Collection<String> getClasses() throws IOException {\n-            return List.of(source.toString().substring(0, source.toString().length() - \".class\".length()));\n-        }\n-\n-        @Override\n-        public Function<String, byte[]> getLoader() {\n-            return f -> {\n-                try {\n-                    return Files.readAllBytes(source);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-            };\n-        }\n-    }\n-\n-    class ClassHierarchyFileSystemWriter implements BiConsumer<String, byte[]> {\n-        private final FileSystem fs;\n-        private final Path target;\n-\n-        public ClassHierarchyFileSystemWriter(FileSystem fs, Path target) {\n-            this.fs = fs;\n-            this.target = target;\n-        }\n-\n-        public ClassHierarchyFileSystemWriter(Path target) {\n-            this(FileSystems.getDefault(), target);\n-        }\n-\n-        public ClassHierarchyFileSystemWriter(FileSystem fs) {\n-            this(fs, fs.getRootDirectories().iterator().next());\n-        }\n-\n-        @Override\n-        public void accept(String s, byte[] bytes) {\n-            try {\n-                Files.write(target.resolve(s + \".class\"), bytes);\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        }\n-    }\n-\n-    \/\/TODO inherit ClassHierarchyFileSystemWriter\n-    class ClassHierarchyJarWriter implements BiConsumer<String, byte[]> {\n-        private final Path path;\n-\n-        public ClassHierarchyJarWriter(String rt) throws IOException {\n-            this(Paths.get(rt));\n-        }\n-\n-        public ClassHierarchyJarWriter(Path path) throws IOException {\n-            this.path = path;\n-        }\n-\n-        @Override\n-        public void accept(String s, byte[] bytes) {\n-            try (FileSystem fs = FileSystems.newFileSystem(path, null)) {\n-                try(OutputStream out = Files.newOutputStream(fs.getPath(s + \".class\"))) {\n-                    out.write(bytes);\n-                }\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        }\n-    }\n-\n-    class JarFileReader extends ClassHierarchyFileSystemReader {\n-        public JarFileReader(String jar) throws IOException {\n-            this(Paths.get(jar));\n-        }\n-        public JarFileReader(Path jar) throws IOException {\n-            super(FileSystems.newFileSystem(jar, null));\n-        }\n+\/\/        @Override\n+\/\/        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n+\/\/            inner.complete(templateStreamSupplier);\n+\/\/        }\n@@ -280,0 +91,205 @@\n+\/\/    interface ModuleImplant {\n+\/\/        \/\/TODO qualified exports?\n+\/\/        List<String> exports();\n+\/\/        Collection<String> classes();\n+\/\/        Function<String, byte[]> loader();\n+\/\/    }\n+\/\/\n+\/\/    abstract class ModuleImplantingPlugin implements InstrumentationPlugin {\n+\/\/\n+\/\/        public static final String MODULE_INFO_CLASS = \"module-info.class\";\n+\/\/\n+\/\/        public interface ModuleInstrumentationPlugin extends InstrumentationPlugin {\n+\/\/            String getModuleName(byte[] moduleInfo);\n+\/\/            byte[] addExports(List<String> exports, byte[] moduleInfo);\n+\/\/        }\n+\/\/\n+\/\/        private final ModuleInstrumentationPlugin inner;\n+\/\/        private final Function<String, ModuleImplant> implants;\n+\/\/\n+\/\/        public ModuleImplantingPlugin(ModuleInstrumentationPlugin inner, Function<String, ModuleImplant> implants) {\n+\/\/            this.inner = inner;\n+\/\/            this.implants = implants;\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n+\/\/                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n+\/\/            inner.instrument(classes, loader, saver, parameters);\n+\/\/            String moduleName = inner.getModuleName(loader.apply(MODULE_INFO_CLASS));\n+\/\/            if(moduleName != null) {\n+\/\/                ModuleImplant implant = implants.apply(moduleName);\n+\/\/                if(implant != null) {\n+\/\/                    saver.accept(MODULE_INFO_CLASS, loader.apply(MODULE_INFO_CLASS));\n+\/\/                    for(String c : implant.classes()) saver.accept(c, implant.loader().apply(c));\n+\/\/                }\n+\/\/            }\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public void complete(Supplier<OutputStream> template) throws Exception {\n+\/\/            inner.complete(template);\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    class ImplantingPlugin implements InstrumentationPlugin {\n+\/\/        private final Collection<String> implant;\n+\/\/        private final Function<String, byte[]> implantLoader;\n+\/\/        private final InstrumentationPlugin inner;\n+\/\/\n+\/\/        \/\/TODO similar to ModuleImplantingPlugin have different implants for different locations somehow?\n+\/\/        public ImplantingPlugin(InstrumentationPlugin inner,\n+\/\/                                Collection<String> implant, Function<String, byte[]> loader) {\n+\/\/            this.implant = implant;\n+\/\/            this.implantLoader = loader;\n+\/\/            this.inner = inner;\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n+\/\/                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n+\/\/            inner.instrument(classes, loader, saver, parameters);\n+\/\/            implant.forEach(c -> saver.accept(c, implantLoader.apply(c)));\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n+\/\/            inner.complete(templateStreamSupplier);\n+\/\/        }\n+\/\/\n+\/\/        protected InstrumentationPlugin inner() {\n+\/\/            return inner;\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    interface ClassHierarchyReader {\n+\/\/        Collection<String> getClasses() throws Exception;\n+\/\/        Function<String, byte[]> getLoader() throws Exception;\n+\/\/    }\n+\/\/\n+\/\/    class ClassHierarchyFileSystemReader implements ClassHierarchyReader {\n+\/\/\n+\/\/        private final FileSystem fs;\n+\/\/        private final Path root;\n+\/\/\n+\/\/        public ClassHierarchyFileSystemReader(FileSystem fs, Path root) {\n+\/\/            this.fs = fs;\n+\/\/            this.root = root;\n+\/\/        }\n+\/\/\n+\/\/        public ClassHierarchyFileSystemReader(Path root) {\n+\/\/            this(FileSystems.getDefault(), root);\n+\/\/        }\n+\/\/\n+\/\/        public ClassHierarchyFileSystemReader(FileSystem fs) {\n+\/\/            this(fs, fs.getRootDirectories().iterator().next());\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public Collection<String> getClasses() throws IOException {\n+\/\/            return Files.find(root, Integer.MAX_VALUE,\n+\/\/                            (f, a) -> f.toString().endsWith(\".class\"))\n+\/\/                    .map(f -> root.relativize(f))\n+\/\/                    .map(Path::toString)\n+\/\/                    .map(s -> s.substring(0, s.length() - \".class\".length()))\n+\/\/                    .collect(Collectors.toList());\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public Function<String, byte[]> getLoader() {\n+\/\/            return f -> {\n+\/\/                try {\n+\/\/                    return Files.readAllBytes(root.resolve(f + \".class\"));\n+\/\/                } catch (IOException e) {\n+\/\/                    throw new UncheckedIOException(e);\n+\/\/                }\n+\/\/            };\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    class SingleClassReader implements ClassHierarchyReader {\n+\/\/\n+\/\/        private final Path source;\n+\/\/\n+\/\/        public SingleClassReader(Path source) {\n+\/\/            if(!source.toString().endsWith(\"class\")) throw new IllegalArgumentException(\"Must be a class file: \" + source);\n+\/\/            this.source = source;\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public Collection<String> getClasses() throws IOException {\n+\/\/            return List.of(source.toString().substring(0, source.toString().length() - \".class\".length()));\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public Function<String, byte[]> getLoader() {\n+\/\/            return f -> {\n+\/\/                try {\n+\/\/                    return Files.readAllBytes(source);\n+\/\/                } catch (IOException e) {\n+\/\/                    throw new UncheckedIOException(e);\n+\/\/                }\n+\/\/            };\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    class ClassHierarchyFileSystemWriter implements BiConsumer<String, byte[]> {\n+\/\/        private final FileSystem fs;\n+\/\/        private final Path target;\n+\/\/\n+\/\/        public ClassHierarchyFileSystemWriter(FileSystem fs, Path target) {\n+\/\/            this.fs = fs;\n+\/\/            this.target = target;\n+\/\/        }\n+\/\/\n+\/\/        public ClassHierarchyFileSystemWriter(Path target) {\n+\/\/            this(FileSystems.getDefault(), target);\n+\/\/        }\n+\/\/\n+\/\/        public ClassHierarchyFileSystemWriter(FileSystem fs) {\n+\/\/            this(fs, fs.getRootDirectories().iterator().next());\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public void accept(String s, byte[] bytes) {\n+\/\/            try {\n+\/\/                Files.write(target.resolve(s + \".class\"), bytes);\n+\/\/            } catch (IOException e) {\n+\/\/                throw new UncheckedIOException(e);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    \/\/TODO inherit ClassHierarchyFileSystemWriter\n+\/\/    class ClassHierarchyJarWriter implements BiConsumer<String, byte[]> {\n+\/\/        private final Path path;\n+\/\/\n+\/\/        public ClassHierarchyJarWriter(String rt) throws IOException {\n+\/\/            this(Paths.get(rt));\n+\/\/        }\n+\/\/\n+\/\/        public ClassHierarchyJarWriter(Path path) throws IOException {\n+\/\/            this.path = path;\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public void accept(String s, byte[] bytes) {\n+\/\/            try (FileSystem fs = FileSystems.newFileSystem(path, null)) {\n+\/\/                try(OutputStream out = Files.newOutputStream(fs.getPath(s + \".class\"))) {\n+\/\/                    out.write(bytes);\n+\/\/                }\n+\/\/            } catch (IOException e) {\n+\/\/                throw new UncheckedIOException(e);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    class JarFileReader extends ClassHierarchyFileSystemReader {\n+\/\/        public JarFileReader(String jar) throws IOException {\n+\/\/            this(Paths.get(jar));\n+\/\/        }\n+\/\/        public JarFileReader(Path jar) throws IOException {\n+\/\/            super(FileSystems.newFileSystem(jar, null));\n+\/\/        }\n+\/\/    }\n+\/\/\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationPlugin.java","additions":235,"deletions":219,"binary":false,"changes":454,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n@@ -32,1 +31,0 @@\n-import com.sun.tdk.jcov.runtime.FileSaver;\n@@ -34,0 +32,1 @@\n+import java.io.FileNotFoundException;\n@@ -40,0 +39,1 @@\n+import java.util.Map;\n@@ -41,0 +41,1 @@\n+import java.util.function.Consumer;\n@@ -42,1 +43,0 @@\n-import java.util.function.Supplier;\n@@ -75,6 +75,10 @@\n-    public void complete(Supplier<OutputStream> templateStreamSupplier) throws IOException {\n-        try (XmlContext ctx = new XmlContext(templateStreamSupplier.get(), data.getParams())) {\n-            \/\/TODO\n-            \/\/ctx.setSkipNotCoveredClasses(agentdata);\n-            data.xmlGen(ctx);\n-        }\n+    public Map<String, Consumer<OutputStream>> complete() {\n+        return Map.of(TEMPLATE_ARTIFACT, out -> {\n+            try (XmlContext ctx = new XmlContext(out, data.getParams())) {\n+                \/\/TODO\n+                \/\/ctx.setSkipNotCoveredClasses(agentdata);\n+                data.xmlGen(ctx);\n+            } catch (FileNotFoundException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ASMInstrumentationPlugin.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+package com.sun.tdk.jcov;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Map;\n+import java.util.jar.JarFile;\n+import java.util.jar.JarOutputStream;\n+\n+public class ZipTest {\n+    public static void main(String[] args) throws IOException {\n+        Path zip = Paths.get(\"\/tmp\/aaa.jar\");\n+        if(Files.exists(zip)) Files.delete(zip);\n+        try(var out = new JarOutputStream(Files.newOutputStream(zip))) {}\n+        var fs = FileSystems.newFileSystem(zip, null);\n+        var root = fs.getRootDirectories().iterator().next();\n+        Path text_file = root.resolve(\"text.txt\");\n+        try(var out = Files.newBufferedWriter(text_file)) {\n+            out.write(\"test\\n\");\n+        }\n+        fs.close();\n+\n+        var fsin = FileSystems.newFileSystem(zip, null);\n+        var fsout = FileSystems.newFileSystem(zip, null);\n+        System.out.write(Files.readAllBytes(fsin.getPath(\"text.txt\")));\n+        Files.write(fsout.getPath(\"text.txt\"), \"new test\".getBytes());\n+        fsout.close();\n+        fsin.close();\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/ZipTest.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -186,0 +186,2 @@\n+            out.putNextEntry(new ZipEntry(\"META-INF\/MANIFEST.MF\"));\n+            out.closeEntry();\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/Util.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import org.testng.annotations.BeforeMethod;\n@@ -38,0 +39,1 @@\n+import java.io.File;\n@@ -46,0 +48,1 @@\n+import static org.testng.Assert.assertFalse;\n@@ -64,1 +67,0 @@\n-        Util.rmRF(test_dir);\n@@ -67,1 +69,5 @@\n-    @Test\n+    @BeforeMethod\n+    public void rm() throws IOException {\n+        Util.rmRF(test_dir);\n+    }\n+    \/\/@Test\n@@ -95,1 +101,1 @@\n-    public void instrumentZip() throws IOException, InterruptedException, FileFormatException,\n+    public void instrumentJar() throws IOException, InterruptedException, FileFormatException,\n@@ -119,0 +125,1 @@\n+        Files.write(implant_dir.resolve(\"some.properties\"), \"some.property=value\\n\".getBytes());\n@@ -131,1 +138,3 @@\n-                resolve(InstrTest.class.getName().replace('.', '\/') + \".class\")));\n+                resolve(InstrTest.class.getName().replace('.', File.separatorChar) + \".class\")));\n+        assertTrue(Files.exists(test_dir.resolve(\"some.properties\")));\n+        assertFalse(Files.exists(test_dir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\")));\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/instr\/InstrTest.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"}]}