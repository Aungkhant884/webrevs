{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n@@ -30,0 +29,1 @@\n+import com.sun.tdk.jcov.instrument.asm.ASMInstrumentationPlugin;\n@@ -37,1 +37,0 @@\n-import java.io.UncheckedIOException;\n@@ -39,2 +38,0 @@\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n@@ -228,9 +225,1 @@\n-            Path outPath = (outDir != null) ? outDir.toPath().resolve(inPath.getFileName()) : inPath;\n-            if (Files.isDirectory(outPath) ||\n-                    outPath.toString().endsWith(\".jar\") ||\n-                    outPath.toString().endsWith(\".jmod\")) {\n-                out = new InstrumentationPlugin.PathDestination(outPath);\n-            } else if (Files.isRegularFile(outPath) && outPath.toString().endsWith(\".class\")) {\n-                \/\/TODO as above\n-                throw new RuntimeException();\n-            } else throw new IllegalStateException(\"Unknown output kind: \" + file);\n+            out = getDestination(outDir, inPath);\n@@ -246,0 +235,14 @@\n+    protected InstrumentationPlugin.Destination getDestination(File outDir, Path inPath) throws IOException {\n+        InstrumentationPlugin.Destination out;\n+        Path outPath = (outDir != null) ? outDir.toPath().resolve(inPath.getFileName()) : inPath;\n+        if (Files.isDirectory(outPath) ||\n+                outPath.toString().endsWith(\".jar\") ||\n+                outPath.toString().endsWith(\".jmod\")) {\n+            out = new InstrumentationPlugin.PathDestination(outPath);\n+        } else if (Files.isRegularFile(outPath) && outPath.toString().endsWith(\".class\")) {\n+            \/\/TODO as above\n+            throw new RuntimeException();\n+        } else throw new IllegalStateException(\"Unknown output kind: \" + inPath);\n+        return out;\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,3 +27,1 @@\n-import com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions;\n-import com.sun.tdk.jcov.instrument.InstrumentationOptions.InstrumentationMode;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -31,1 +29,0 @@\n-import com.sun.tdk.jcov.tools.JCovCMDTool;\n@@ -33,1 +30,1 @@\n-import com.sun.tdk.jcov.util.Utils;\n+\n@@ -35,2 +32,6 @@\n-import java.io.IOException;\n-import java.util.logging.Level;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import static com.sun.tdk.jcov.instrument.InstrumentationOptions.*;\n@@ -45,17 +46,1 @@\n-public class TmplGen extends JCovCMDTool {\n-\n-    private String[] files;\n-    private AbstractUniversalInstrumenter instrumenter;\n-    private String flushPath;\n-    private String template;\n-    private String[] include;\n-    private String[] exclude;\n-    private String[] m_include;\n-    private String[] m_exclude;\n-    private boolean instrumentAbstract = false;\n-    private boolean instrumentNative = true;\n-    private boolean instrumentField = false;\n-    private boolean instrumentAnonymous = true;\n-    private boolean instrumentSynthetic = true;\n-    private InstrumentationOptions.InstrumentationMode mode;\n-    private String currentModule = null;\n+public class TmplGen extends Instr {\n@@ -79,0 +64,8 @@\n+    @Override\n+    protected InstrumentationPlugin.Destination getDestination(File outDir, Path inPath) {\n+        return new InstrumentationPlugin.Destination() {\n+            @Override public BiConsumer<String, byte[]> saver() {return (n, c) -> {};}\n+            @Override public void close() {}\n+        };\n+    }\n+\n@@ -91,137 +84,7 @@\n-    @Override\n-    protected int run() throws Exception {\n-        try {\n-            generateAndSave(files);\n-        } catch (IOException ioe) {\n-            throw new Exception(\"Unexpected error during instrumentation\", ioe);\n-        }\n-        return SUCCESS_EXIT_CODE;\n-    }\n-\n-    private boolean expandJimage(File jimage, String tempDirName, boolean isModulesDir){\n-        try {\n-            String command = \"\";\n-            if (isModulesDir) {\n-                command = jimage.getParentFile().getParentFile().getParent() + File.separator + \"bin\" + File.separator + \"jimage extract --dir \" +\n-                        jimage.getParent() + File.separator + tempDirName + \" \" + jimage.getAbsolutePath();\n-            }\n-            else{\n-                command = jimage.getParentFile().getParentFile() + File.separator + \"bin\" + File.separator + \"jimage extract --dir \" +\n-                        jimage.getParent() + File.separator + tempDirName + \" \" + jimage.getAbsolutePath();\n-            }\n-            Process process = Runtime.getRuntime().exec(command);\n-            process.waitFor();\n-            if (process.exitValue() != 0) {\n-                \/\/logger.log(Level.SEVERE, \"wrong command for expand jimage: \"+command);\n-                return false;\n-            }\n-        } catch (Exception e) {\n-            \/\/logger.log(Level.SEVERE, \"exception in process(expanding jimage)\", e);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    public void generateAndSave(String[] files) throws Exception {\n-        setDefaultInstrumenter();\n-        for (String root : files) {\n-            if (root.endsWith(\".jimage\")){\n-                readJImage(new File(root), true);\n-            }\n-            else if (root.endsWith(\"modules\") && (new File(root).isFile())) {\n-                readJImage(new File(root), false);\n-            }\n-            else{\n-                instrumenter.instrument(new File(root), null);\n-            }\n-        }\n-        for (String root : files) {\n-            if (root.endsWith(\".jimage\")) {\n-                File rootFile = new File(root);\n-                Utils.deleteDirectory(new File(rootFile.getParentFile().getAbsolutePath() + File.separator + \"temp_\" + getJImageName(rootFile)));\n-            }\n-            if (root.endsWith(\"modules\")){\n-                File rootFile = new File(root);\n-                if (rootFile.isFile()){\n-                    Utils.deleteDirectory(new File(rootFile.getParentFile().getAbsolutePath() + File.separator + \"temp_modules\"));\n-                }\n-            }\n-        }\n-        instrumenter.finishWork();\n-        instrumenter = null;\n-    }\n-\n-    private void readJImage(File rootFile, boolean isModulesDir) throws IOException{\n-        String jimagename = \"modules\";\n-        if (isModulesDir) {\n-            jimagename = getJImageName(rootFile);\n-        }\n-\n-        expandJimage(rootFile, \"temp_\"+jimagename, isModulesDir);\n-        File tempJimage = new File(rootFile.getParentFile().getAbsolutePath()+File.separator+\"temp_\"+jimagename);\n-        \/\/still need it\n-        Utils.addToClasspath(new String[]{tempJimage.getAbsolutePath()});\n-        for (File file:tempJimage.listFiles()){\n-            if (file.isDirectory()){\n-                Utils.addToClasspath(new String[]{file.getAbsolutePath()});\n-            }\n-        }\n-        for (File file:tempJimage.listFiles()){\n-            if (file.isDirectory()){\n-                currentModule = file.getName();\n-                instrumenter.instrument(file, null);\n-            }\n-        }\n-    }\n-\n-    private String getJImageName(File jimage){\n-        String jimagename = jimage.getName();\n-        int pos = jimagename.lastIndexOf(\".\");\n-        if (pos > 0) {\n-            jimagename = jimagename.substring(0, pos);\n-        }\n-        return jimagename;\n-    }\n-\n-    public void generateTemplate(String[] files) throws IOException {\n-        if (instrumenter == null) {\n-            setDefaultInstrumenter();\n-        }\n-        for (String root : files) {\n-            instrumenter.instrument(new File(root), null);\n-        }\n-    }\n-\n-    public void finishWork() throws Exception {\n-        if (instrumenter == null) {\n-            throw new IllegalStateException(\"Instrumenter is not ready\");\n-        }\n-        instrumenter.finishWork();\n-        instrumenter = null;\n-    }\n-\n-    public void setDefaultInstrumenter() {\n-        if (instrumenter == null) {\n-            \/\/TODO\n-            instrumenter = null;\n-\/\/            instrumenter = new AbstractUniversalInstrumenter(true, true, plugin) {\n-\/\/                ClassMorph morph = new ClassMorph(\n-\/\/                        new InstrumentationParams(instrumentNative, instrumentField, instrumentAbstract, include, exclude, m_include, m_exclude, mode)\n-\/\/                        .setInstrumentAnonymous(instrumentAnonymous)\n-\/\/                        .setInstrumentSynthetic(instrumentSynthetic), template);\n-\/\/\n-\/\/                protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n-\/\/\/\/                    byte[] res = Arrays.copyOf(classData, classLen);\n-\/\/                    byte[] res = new byte[classLen];\n-\/\/                    System.arraycopy(classData, 0, res, 0, classLen);\n-\/\/                    morph.setCurrentModuleName(currentModule);\n-\/\/                    morph.morph(res, null, flushPath); \/\/ jdk1.5 support\n-\/\/                    return res;\n-\/\/                }\n-\/\/\n-\/\/                public void finishWork() {\n-\/\/                    morph.saveData(template, InstrumentationOptions.MERGE.MERGE);\n-\/\/                }\n-\/\/            };\n-        }\n-    }\n+    private static final List<String> SKIP_INSTR_OPTIONS = List.of(\n+            DSC_OUTPUT,\n+            DSC_CALLER_INCLUDE,\n+            DSC_CALLER_EXCLUDE,\n+            DSC_SAVE_BEGIN,\n+            DSC_SAVE_AT_END,\n+            DSC_FLUSH_CLASSES).stream().map(o -> o.name).collect(Collectors.toList());\n@@ -231,19 +94,4 @@\n-        return new EnvHandler(new OptionDescr[]{\n-                    \/\/        DSC_OUTPUT,\n-                    DSC_VERBOSE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TEMPLATE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_TYPE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ABSTRACT,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_NATIVE,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FIELD,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_SYNTHETIC,\n-                    com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_ANONYM,\n-                    InstrumentationOptions.DSC_FLUSH_CLASSES,}, this);\n+        EnvHandler superHandler = super.defineHandler();\n+        List<OptionDescr> opts = superHandler.getValidOptions().stream()\n+                .filter(o -> !SKIP_INSTR_OPTIONS.contains(o.name)).collect(Collectors.toList());\n+        return new EnvHandler(opts.toArray(new OptionDescr[0]), this);\n@@ -251,162 +99,0 @@\n-\n-    @Override\n-    protected int handleEnv(EnvHandler opts) throws EnvHandlingException {\n-        files = opts.getTail();\n-        if (files == null) {\n-            throw new EnvHandlingException(\"No input files specified\");\n-        }\n-\n-        if (opts.isSet(DSC_VERBOSE)) {\n-            Utils.setLoggingLevel(Level.INFO);\n-        }\n-\n-        Utils.addToClasspath(files);\n-\n-        flushPath = opts.getValue(InstrumentationOptions.DSC_FLUSH_CLASSES);\n-        if (\"none\".equals(flushPath)) {\n-            flushPath = null;\n-        }\n-        String abstractValue = opts.getValue(InstrumentationOptions.DSC_ABSTRACT);\n-        if (abstractValue.equals(\"off\")) {\n-            instrumentAbstract = false;\n-        } else if (abstractValue.equals(\"on\")) {\n-            instrumentAbstract = true;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_ABSTRACT.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + abstractValue + \"'\");\n-        }\n-\n-        String nativeValue = opts.getValue(InstrumentationOptions.DSC_NATIVE);\n-        if (nativeValue.equals(\"on\")) {\n-            instrumentNative = true;\n-        } else if (nativeValue.equals(\"off\")) {\n-            instrumentNative = false;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_NATIVE.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + nativeValue + \"'\");\n-        }\n-\n-        String fieldValue = opts.getValue(InstrumentationOptions.DSC_FIELD);\n-        if (fieldValue.equals(\"on\")) {\n-            instrumentField = true;\n-        } else if (fieldValue.equals(\"off\")) {\n-            instrumentField = false;\n-        } else {\n-            throw new EnvHandlingException(\"'\" + InstrumentationOptions.DSC_FIELD.name + \"' parameter value error: expected 'on' or 'off'; found: '\" + fieldValue + \"'\");\n-        }\n-\n-        String anonym = opts.getValue(InstrumentationOptions.DSC_ANONYM);\n-        if (anonym.equals(\"on\")) {\n-            instrumentAnonymous = true;\n-        } else { \/\/ off\n-            instrumentAnonymous = false;\n-        }\n-\n-        String synth = opts.getValue(InstrumentationOptions.DSC_SYNTHETIC);\n-        if (synth.equals(\"on\")) {\n-            instrumentSynthetic = true;\n-        } else { \/\/ off\n-            instrumentSynthetic = false;\n-        }\n-\n-        mode = InstrumentationOptions.InstrumentationMode.fromString(opts.getValue(InstrumentationOptions.DSC_TYPE));\n-        template = opts.getValue(InstrumentationOptions.DSC_TEMPLATE);\n-        File tmpl = new File(template);\n-        if (tmpl.isDirectory()) {\n-            throw new EnvHandlingException(\"'\" + template + \"' is a directory while expected template filename\");\n-        }\n-        if (tmpl.getParentFile() != null && !tmpl.getParentFile().exists()) {\n-            throw new EnvHandlingException(\"Template parent directory '\" + tmpl.getParentFile() + \"' doesn't exits\");\n-        }\n-\n-        include = InstrumentationOptions.handleInclude(opts);\n-        exclude = InstrumentationOptions.handleExclude(opts);\n-\n-        m_exclude = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleMExclude(opts);\n-        m_include = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleMInclude(opts);\n-\n-        com.sun.tdk.jcov.runtime.CollectDetect.enableInvokeCounts();\n-\n-        return SUCCESS_EXIT_CODE;\n-    }\n-\n-    public String[] getExclude() {\n-        return exclude;\n-    }\n-\n-    public void setExclude(String[] exclude) {\n-        this.exclude = exclude;\n-    }\n-\n-    public String[] getMExclude() {\n-        return m_exclude;\n-    }\n-\n-    public void setMExclude(String[] m_exclude) {\n-        this.m_exclude = exclude;\n-    }\n-\n-    public String getFlushPath() {\n-        return flushPath;\n-    }\n-\n-    public void setFlushPath(String flushPath) {\n-        this.flushPath = flushPath;\n-    }\n-\n-    public String[] getInclude() {\n-        return include;\n-    }\n-\n-    public void setInclude(String[] include) {\n-        this.include = include;\n-    }\n-\n-    public String[] getMInclude() {\n-        return m_include;\n-    }\n-\n-    public void setMInclude(String[] m_include) {\n-        this.m_include = m_include;\n-    }\n-\n-    public boolean isInstrumentAbstract() {\n-        return instrumentAbstract;\n-    }\n-\n-    public void setInstrumentAbstract(boolean instrumentAbstract) {\n-        this.instrumentAbstract = instrumentAbstract;\n-    }\n-\n-    public boolean isInstrumentField() {\n-        return instrumentField;\n-    }\n-\n-    public void setInstrumentField(boolean instrumentField) {\n-        this.instrumentField = instrumentField;\n-    }\n-\n-    public boolean isInstrumentNative() {\n-        return instrumentNative;\n-    }\n-\n-    public void setInstrumentNative(boolean instrumentNative) {\n-        this.instrumentNative = instrumentNative;\n-    }\n-\n-    public InstrumentationMode getMode() {\n-        return mode;\n-    }\n-\n-    public void setMode(InstrumentationMode mode) {\n-        this.mode = mode;\n-    }\n-\n-    public String getTemplate() {\n-        return template;\n-    }\n-\n-    public void setTemplate(String template) {\n-        this.template = template;\n-    }\n-\n-    final static OptionDescr DSC_VERBOSE =\n-            new OptionDescr(\"verbose\", \"Verbosity\", \"Enables verbose mode.\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/TmplGen.java","additions":28,"deletions":342,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -119,0 +119,4 @@\n+    public List<OptionDescr> getValidOptions() {\n+        return validOptions;\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/tools\/EnvHandler.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.tmplgen;\n+\n+import com.sun.tdk.jcov.Instr;\n+import com.sun.tdk.jcov.TmplGen;\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataPackage;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.Util;\n+import com.sun.tdk.jcov.instrument.instr.UserCode;\n+import com.sun.tdk.jcov.io.Reader;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.testng.Assert.*;\n+\n+public class TmplGenTest {\n+    Path test_dir;\n+    Path test_zip;\n+    Path template;\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        System.setProperty(\"jcov.selftest\", \"true\");\n+        Path data_dir = Files.createTempDirectory(\"instr_test\");\n+        test_dir = data_dir.resolve(\"instr_test\");\n+        test_zip = data_dir.resolve(\"instr_test.jar\");\n+        System.out.println(\"test dir = \" + test_dir);\n+        template = test_dir.resolve(\"template.xml\");\n+    }\n+    @BeforeMethod\n+    public void rm() throws IOException {\n+        Util.rmRF(test_dir);\n+    }\n+\/\/    @Test\n+    public void instrumentClass() {\n+    }\n+    @Test\n+    public void instrumentDir() throws IOException, FileFormatException {\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(\"-i\");\n+        params.add(UserCode.class.getName());\n+        new Util(test_dir).copyBytecode(UserCode.class.getName(), TmplGenTest.class.getName());\n+        int classSize = classSize(UserCode.class.getName());\n+        params.add(test_dir.toString());\n+        new TmplGen().run(params.toArray(new String[0]));\n+        testInstrumentation();\n+        assertEquals(classSize(UserCode.class.getName()), classSize);\n+    }\n+\n+    private int classSize(String name) throws IOException {\n+        return Files.readAllBytes(test_dir.resolve(name.replace('.', File.separatorChar) + \".class\")).length;\n+    }\n+\n+    @Test\n+    public void instrumentJar() throws IOException, FileFormatException {\n+        Path classes = test_dir.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        new Util(classes).copyBytecode(UserCode.class.getName(), TmplGenTest.class.getName());\n+        Util.jar(classes, test_zip, p -> true);\n+        Util.rmRF(classes);\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(\"-i\");\n+        params.add(UserCode.class.getName());\n+        params.add(test_zip.toString());\n+        new Instr().run(params.toArray(new String[0]));\n+        Util.unjar(test_zip, classes);\n+        testInstrumentation();\n+    }\n+    private void testInstrumentation() throws FileFormatException {\n+        DataRoot data = Reader.readXML(template.toString());\n+        DataPackage dp =\n+                data.getPackages().stream()\n+                        .filter(p -> p.getName().equals(\"com\/sun\/tdk\/jcov\/instrument\/instr\")).findAny().get();\n+        DataMethod dm = dp\n+                        .getClasses().stream().filter(c -> c.getName().equals(\"UserCode\")).findAny().get()\n+                        .getMethods().stream().filter(m -> m.getName().equals(\"main\")).findAny().get();\n+        int method_slot = dm.getSlot();\n+        assertTrue(dm.getSlot() > 0);\n+        assertFalse(dp\n+                .getClasses().stream().filter(c -> c.getName().equals(\"InstrTest\")).findAny().isPresent());\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        Util.rmRF(test_dir);\n+        Util.rmRF(test_zip);\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/tmplgen\/TmplGenTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"}]}