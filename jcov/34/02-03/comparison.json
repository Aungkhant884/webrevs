{"files":[{"patch":"@@ -637,1 +637,1 @@\n-                    ClassMorph.DSC_FLUSH_CLASSES,\n+                    InstrumentationOptions.DSC_FLUSH_CLASSES,\n@@ -746,1 +746,1 @@\n-        flushPath = opts.getValue(ClassMorph.DSC_FLUSH_CLASSES);\n+        flushPath = opts.getValue(InstrumentationOptions.DSC_FLUSH_CLASSES);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Agent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.tdk.jcov.instrument.Instrumentation;\n@@ -30,1 +29,0 @@\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n@@ -38,2 +36,0 @@\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n@@ -47,3 +43,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n@@ -97,2 +90,2 @@\n-    private ClassMorph morph;\n-    private ClassLoader cl = null;\n+\/\/    private ClassMorph morph;\n+    private ClassLoader cl = ClassLoader.getSystemClassLoader();\n@@ -102,1 +95,0 @@\n-    private Instrumentation instrumentation = new Instrumentation(plugin);\n@@ -110,6 +102,0 @@\n-    private boolean needToFixJavaBase = false;\n-\n-    public void fixJavaBase() {\n-        needToFixJavaBase = true;\n-    }\n-\n@@ -148,2 +134,0 @@\n-     * @see\n-     * #setInstrumenter(com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter)\n@@ -166,2 +150,0 @@\n-     * @see\n-     * #setInstrumenter(com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter)\n@@ -186,2 +168,0 @@\n-     * @see\n-     * #setInstrumenter(com.sun.tdk.jcov.insert.AbstractUniversalInstrumenter)\n@@ -197,25 +177,1 @@\n-        if (morph != null){\n-            morph.setCurrentModuleName(moduleName);\n-            if(needToFixJavaBase && \"java.base\".equals(moduleName)) {\n-                File moduleInfo = new File(file + File.separator +  \"module-info.class\");\n-                if(!moduleInfo.exists()) throw new IllegalStateException(moduleInfo + \" does not exist!\");\n-                try(FileInputStream fi = new FileInputStream(moduleInfo)) {\n-                    byte[] noHashes = morph.clearHashes(fi.readAllBytes(), cl);\n-                    List<String> packages = new ArrayList<>();\n-                    packages.add(\"com\/sun\/tdk\/jcov\/runtime\");\n-\/\/                    if(plugin != null) {\n-\/\/                        String pluginRuntimePackage = plugin.collectorPackage();\n-\/\/                        if (pluginRuntimePackage != null) {\n-\/\/                            pluginRuntimePackage = pluginRuntimePackage.replace('.', '\/');\n-\/\/                            packages.add(pluginRuntimePackage);\n-\/\/                        }\n-\/\/                    }\n-                    byte[] withExports = morph.addExports(noHashes, packages, cl);\n-                    try (FileOutputStream fo = new FileOutputStream(((outDir == null) ? file : outDir) +\n-                            File.separator +  \"module-info.class\")) {\n-                        fo.write(withExports);\n-                    }\n-                }\n-            }\n-            instrumentFiles(new String[] {file}, outDir, includeRTJar);\n-        }\n+        instrumentFiles(new String[] {file}, outDir, includeRTJar);\n@@ -251,0 +207,9 @@\n+        InstrumentationPlugin aPLugin = plugin;\n+        InstrumentationPlugin.Source source;\n+        if (implantRT != null) {\n+            source = new InstrumentationPlugin.PathSource(ClassLoader.getSystemClassLoader(), Path.of(implantRT));\n+            aPLugin = new InstrumentationPlugin.ImplantingPlugin(plugin, source);\n+        }\n+\n+        InstrumentationPlugin.Instrumentation fi =\n+                new InstrumentationPlugin.Instrumentation(aPLugin);\n@@ -252,2 +217,2 @@\n-            Path in, out;\n-            FileSystem inFS = null, outFS = null;\n+            InstrumentationPlugin.PathSource in;\n+\/\/            FileSystem outFS = null;\n@@ -255,2 +220,3 @@\n-            if (Files.isRegularFile(inPath) && file.endsWith(\".class\")) {\n-                \/\/not implemented yet\n+            if (Files.isDirectory(inPath) || file.endsWith(\".jar\") || file.endsWith(\".jmod\")) {\n+                in = new InstrumentationPlugin.PathSource(cl, inPath);\n+            } else if (Files.isRegularFile(inPath) && file.endsWith(\".class\")) {\n@@ -261,25 +227,16 @@\n-            } else {\n-                if (Files.isRegularFile(inPath) && file.endsWith(\".jar\")) {\n-                    inFS = FileSystems.newFileSystem(Path.of(file), null);\n-                    in = inFS.getPath(\"\/\");\n-                } else if (Files.isDirectory(inPath)) {\n-                    in = Path.of(file);\n-                } else throw new IllegalStateException(\"Unknown input kind: \" + file);\n-                Path outPath  = (outDir != null) ? outDir.toPath().resolve(inPath.getFileName()) : inPath;\n-                if (Files.isRegularFile(outPath) && outPath.toString().endsWith(\".class\")) {\n-                    \/\/not implemented yet\n-                    throw new RuntimeException();\n-                } else if (Files.isRegularFile(outPath) && outPath.toString().endsWith(\".jar\")) {\n-                    outFS = FileSystems.newFileSystem(outPath, null);\n-                    out = outFS.getPath(\"\/\");\n-                } else if (Files.isDirectory(outPath)) {\n-                    out = outPath;\n-                } else throw new IllegalStateException(\"Unknown input kind: \" + file);\n-                Instrumentation.FileSystemImplant implant = null;\n-                if (implantRT != null) {\n-                    implant = new Instrumentation.JarImplant(Path.of(implantRT));\n-                }\n-                instrumentation.instrument(in, out, params, implant);\n-                if(inFS != null) inFS.close();\n-                if(outFS != null) outFS.close();\n-                if(implant != null) implant.close();\n+            } else throw new IllegalStateException(\"Unknown input kind: \" + file);\n+            InstrumentationPlugin.Destination out;\n+            Path outPath = (outDir != null) ? outDir.toPath().resolve(inPath.getFileName()) : inPath;\n+            if (Files.isDirectory(outPath) ||\n+                    outPath.toString().endsWith(\".jar\") ||\n+                    outPath.toString().endsWith(\".jmod\")) {\n+                out = new InstrumentationPlugin.PathDestination(outPath);\n+            } else if (Files.isRegularFile(outPath) && outPath.toString().endsWith(\".class\")) {\n+                \/\/TODO as above\n+                throw new RuntimeException();\n+            } else throw new IllegalStateException(\"Unknown output kind: \" + file);\n+            try (in) {\n+                fi.instrument(in, out, params);\n+            } finally {\n+                in.close();\n+                out.close();\n@@ -293,1 +250,2 @@\n-            morph.fillIntrMethodsIDs(morph.getRoot());\n+            \/\/TODO\n+            \/\/morph.fillIntrMethodsIDs(morph.getRoot());\n@@ -340,37 +298,0 @@\n-        if (morph == null) {\n-            if (subsequentInstr) {\n-                morph = new ClassMorph(params, template);\n-            } else {\n-                morph = new ClassMorph(params, null);\n-            }\n-        }\n-\/\/        if (instrumenter == null) {\n-\/\/            instrumenter = new AbstractUniversalInstrumenter(true) {\n-\/\/                protected byte[] instrument(byte[] classData, int classLen) throws IOException {\n-\/\/                    return morph.morph(classData, cl, flushPath);\n-\/\/                }\n-\/\/\n-\/\/                public void finishWork() {\n-\/\/                    if (subsequentInstr) {\n-\/\/                        morph.saveData(MERGE.MERGE); \/\/ template should be initialized\n-\/\/                    } else {\n-\/\/                        morph.saveData(template, null, MERGE.OVERWRITE); \/\/ template should be initialized\n-\/\/                    }\n-\/\/                }\n-\/\/\n-\/\/                 public void processClassFileInModules(Path filePath, File outDir){\n-\/\/                    if (morph != null){\n-\/\/                        if (filePath != null){\n-\/\/                            String mpath = filePath.toAbsolutePath().toString();\n-\/\/                            mpath = mpath.substring(\"\/modules\/\".length());\n-\/\/                            if (mpath.contains(\"\/\")){\n-\/\/                                String module_name = mpath.substring(0, mpath.indexOf(\"\/\"));\n-\/\/                                morph.setCurrentModuleName(module_name);\n-\/\/                            }\n-\/\/                        }\n-\/\/                        super.processClassFileInModules(filePath, outDir);\n-\/\/                    }\n-\/\/                }\n-\/\/            };\n-\/\/            instrumenter.setParams(params);\n-\/\/        }\n@@ -379,9 +300,0 @@\n-    \/**\n-     * Set instrumenter\n-     *\n-     * @param instrumenter instrumenter used to instrument data\n-     *\/\n-\/\/    public void setInstrumenter(AbstractUniversalInstrumenter instrumenter) {\n-\/\/        this.instrumenter = instrumenter;\n-\/\/    }\n-\n@@ -394,5 +306,1 @@\n-\/\/        if (instrumenter != null) {\n-\/\/            instrumenter.finishWork();\n-            \/\/ destroy instrumenter & morph?\n-\/\/        }\n-\/\/        if(plugin != null) plugin.instrumentationComplete();\n+        plugin.complete().get(TEMPLATE_ARTIFACT).accept(Files.newOutputStream(Path.of(template)));\n@@ -408,16 +316,2 @@\n-\/\/        if (instrumenter != null) {\n-\/\/            if (subsequentInstr) {\n-\/\/                morph.saveData(outTemplate, MERGE.MERGE); \/\/ template should be initialized\n-\/\/            } else {\n-\/\/                morph.saveData(outTemplate, null, MERGE.OVERWRITE); \/\/ template should be initialized\n-\/\/            }\n-\/\/        }\n-\/\/        if(plugin != null) plugin.instrumentationComplete();\n-        if (subsequentInstr) {\n-            morph.saveData(MERGE.MERGE); \/\/ template should be initialized\n-        } else {\n-            morph.saveData(template, null, MERGE.OVERWRITE); \/\/ template should be initialized\n-        }\n-        Path templ = Path.of(template);\n-        instrumentation.complete(templ.getParent(), Map.of(TEMPLATE_ARTIFACT, templ));\n-\/\/        plugin.complete().get(TEMPLATE_ARTIFACT).accept(Files.newOutputStream(Path.of(template)));\n+        \/\/TODO what's with two finishWork methods????\n+        plugin.complete().get(TEMPLATE_ARTIFACT).accept(Files.newOutputStream(Path.of(outTemplate)));\n@@ -491,3 +385,3 @@\n-    public String[] getExclude() {\n-        return exclude;\n-    }\n+    public InstrumentationParams getParams() { return params; }\n+\n+    public String[] getExclude() { return exclude; }\n@@ -531,3 +425,1 @@\n-    public String[] getMInclude() {\n-        return m_include;\n-    }\n+    public String[] getMInclude() {return m_include;}\n@@ -535,3 +427,1 @@\n-    public void setMInclude(String[] m_include) {\n-        this.m_include = m_include;\n-    }\n+    public void setMInclude(String[] m_include) {this.m_include = m_include;}\n@@ -562,1 +452,0 @@\n-        instrumentation = new Instrumentation(plugin);\n@@ -666,1 +555,1 @@\n-                ClassMorph.DSC_FLUSH_CLASSES,\n+                DSC_FLUSH_CLASSES,\n@@ -746,1 +635,1 @@\n-        flushPath = opts.getValue(ClassMorph.DSC_FLUSH_CLASSES);\n+        flushPath = opts.getValue(DSC_FLUSH_CLASSES);\n@@ -758,1 +647,0 @@\n-                instrumentation = new Instrumentation(plugin);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":45,"deletions":157,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n@@ -150,1 +149,1 @@\n-                    ClassMorph.DSC_FLUSH_CLASSES\n+                    InstrumentationOptions.DSC_FLUSH_CLASSES\n@@ -220,1 +219,1 @@\n-        flushPath = envHandler.getValue(ClassMorph.DSC_FLUSH_CLASSES);\n+        flushPath = envHandler.getValue(InstrumentationOptions.DSC_FLUSH_CLASSES);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr2.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -34,1 +35,7 @@\n-import java.io.*;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n@@ -39,0 +46,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -41,0 +50,1 @@\n+import java.util.function.BiConsumer;\n@@ -44,0 +54,1 @@\n+import static com.sun.tdk.jcov.instrument.InstrumentationPlugin.MODULE_INFO_CLASS;\n@@ -75,24 +86,0 @@\n-    \/**\n-     * tries to find class in the specified jars\n-     *\/\n-    public static class StaticJREInstrClassLoader extends URLClassLoader {\n-\n-        StaticJREInstrClassLoader(URL[] urls) {\n-            super(urls);\n-        }\n-\n-        @Override\n-        public InputStream getResourceAsStream(String s) {\n-            InputStream in = null;\n-            try {\n-                in = findResource(s).openStream();\n-            } catch (IOException ignore) {\n-                \/\/nothing to do\n-            }\n-            if (in != null) {\n-                return in;\n-            }\n-            return super.getResourceAsStream(s);\n-        }\n-    }\n-\n@@ -105,5 +92,0 @@\n-        StaticJREInstrClassLoader cl = new StaticJREInstrClassLoader(new URL[]{toInstrument.toURI().toURL()});\n-        instr.setClassLoader(cl);\n-\n-        instr.fixJavaBase();\n-\n@@ -125,1 +107,2 @@\n-            cl = new StaticJREInstrClassLoader(urls.toArray(new URL[0]));\n+            ClassLoader cl = new InstrumentationPlugin.OverridingClassLoader(urls.toArray(new URL[0]),\n+                    ClassLoader.getSystemClassLoader());\n@@ -128,0 +111,19 @@\n+            \/\/TODO filtering\n+            InstrumentationPlugin.ModuleInstrumentation mi = new InstrumentationPlugin.ModuleInstrumentation(\n+                    instr.getPlugin(), (InstrumentationPlugin.ModuleInstrumentationPlugin) instr.getPlugin()) {\n+                public void proccessModule(byte[] moduleInfo, ClassLoader loader,\n+                                           BiConsumer<String, byte[]> destination) throws Exception {\n+                    InstrumentationPlugin.ModuleInstrumentationPlugin mip = getModulePluign();\n+                    if(mip.getModuleName(moduleInfo).equals(\"java.base\")) {\n+                        moduleInfo = mip.addExports(List.of(\"com\/sun\/tdk\/jcov\/runtime\"), moduleInfo, loader);\n+                        moduleInfo = mip.clearHashes(moduleInfo, loader);\n+                        InstrumentationPlugin.PathSource implantSource =\n+                                new InstrumentationPlugin.PathSource(cl, implant.toPath());\n+                        for (String resource : implantSource.resources()) {\n+                            destination.accept(resource, implantSource.loader().getResourceAsStream(resource).readAllBytes());\n+                        }\n+                    }\n+                    destination.accept(MODULE_INFO_CLASS, moduleInfo);\n+                }\n+            };\n+\n@@ -131,2 +133,7 @@\n-                        File modClasses = new File(mod, \"classes\");\n-                        instr.instrumentFile(modClasses.getAbsolutePath(), null, null, mod.getName());\n+                        String moduleName = mod.getName();\n+                        if (isModuleIncluded(moduleName)) {\n+                            logger.log(Level.INFO, \"Instrumenting \" + moduleName);\n+                            File modClasses = new File(mod, \"classes\");\n+                            mi.instrument(new InstrumentationPlugin.PathSource(cl, modClasses.toPath()),\n+                                    new InstrumentationPlugin.PathDestination(modClasses.toPath()), instr.getParams());\n+                        }\n@@ -166,0 +173,1 @@\n+                e.printStackTrace();\n@@ -170,60 +178,0 @@\n-\/\/            ArrayList<File> jdkImages = new ArrayList<>();\n-\/\/            jdkImages.add(toInstrument);\n-\/\/            if (addJimages != null) {\n-\/\/                Collections.addAll(jdkImages, addJimages);\n-\/\/            }\n-\/\/\n-\/\/            for (File jimageInstr : jdkImages) {\n-\/\/                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n-\/\/\n-\/\/                expandJimage(jimageInstr, tempDirName);\n-\/\/\n-\/\/                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n-\/\/\/\/                still need it\n-\/\/                Utils.addToClasspath(new String[]{dirtoInstrument.getAbsolutePath()});\n-\/\/                for (File file : getListFiles(dirtoInstrument)) {\n-\/\/                    if (file.isDirectory()) {\n-\/\/                        Utils.addToClasspath(new String[]{file.getAbsolutePath()});\n-\/\/                    }\n-\/\/                }\n-\/\/\n-\/\/                if (jimageInstr.equals(toInstrument)) {\n-\/\/                    for (File mod : getListFiles(dirtoInstrument)) {\n-\/\/                        if (mod != null && mod.isDirectory()) {\n-\/\/\n-\/\/                            if (\"java.base\".equals(mod.getName())) {\n-\/\/                                instr.instrumentFile(mod.getAbsolutePath(), null, implant.getAbsolutePath(), mod.getName());\n-\/\/                            } else {\n-\/\/                                instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n-\/\/                            }\n-\/\/                        }\n-\/\/                    }\n-\/\/                } else {\n-\/\/                    for (File mod : getListFiles(dirtoInstrument)) {\n-\/\/                        if (mod != null && mod.isDirectory()) {\n-\/\/                            instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n-\/\/                        }\n-\/\/                    }\n-\/\/                }\n-\/\/                createJimage(dirtoInstrument, jimageInstr.getAbsolutePath() + \"i\");\n-\n-\/\/            }\n-\/\/            for (File jimageInstr : jdkImages) {\n-\/\/\n-\/\/                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n-\/\/                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n-\/\/                if (!Utils.deleteDirectory(dirtoInstrument)) {\n-\/\/                    logger.log(Level.SEVERE, \"please, delete \" + tempDirName + \" jimage dir manually\");\n-\/\/                }\n-\/\/\n-\/\/                Utils.copyFile(jimageInstr, new File(jimageInstr.getParent(), jimageInstr.getName() + \".bak\"));\n-\/\/\n-\/\/                if (!jimageInstr.delete()) {\n-\/\/                    logger.log(Level.SEVERE, \"please, delete original jimage manually: \" + jimageInstr);\n-\/\/                } else {\n-\/\/                    Utils.copyFile(new File(jimageInstr.getAbsolutePath() + \"i\"), jimageInstr);\n-\/\/                    new File(jimageInstr.getAbsolutePath() + \"i\").delete();\n-\/\/                }\n-\/\/\n-\/\/            }\n-\n@@ -232,1 +180,0 @@\n-\/\/            instr.instrumentFile(toInstrument.getAbsolutePath(), null, implant.getAbsolutePath());\n@@ -264,1 +211,1 @@\n-        boolean success;\n+        boolean success = false;\n@@ -280,0 +227,2 @@\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n@@ -333,0 +282,4 @@\n+    private boolean isModuleIncluded(String moduleName) {\n+        return Arrays.stream(instr.getMInclude()).anyMatch(i -> moduleName.matches(i)) &&\n+               Arrays.stream(instr.getMExclude()).noneMatch(i -> moduleName.matches(i));\n+    }\n@@ -375,0 +328,1 @@\n+            e.printStackTrace();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/JREInstr.java","additions":49,"deletions":95,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tdk.jcov.instrument.asm.ClassMorph;\n@@ -31,1 +30,0 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationParams;\n@@ -251,1 +249,1 @@\n-                    ClassMorph.DSC_FLUSH_CLASSES,}, this);\n+                    InstrumentationOptions.DSC_FLUSH_CLASSES,}, this);\n@@ -267,1 +265,1 @@\n-        flushPath = opts.getValue(ClassMorph.DSC_FLUSH_CLASSES);\n+        flushPath = opts.getValue(InstrumentationOptions.DSC_FLUSH_CLASSES);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/TmplGen.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -597,17 +597,17 @@\n-            try {\n-                plugin.instrument(classes, f -> {\n-                    try {\n-                        return Files.readAllBytes(in.resolve(f));\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                }, (c, d) -> {\n-                    try {\n-                        Files.write(out.resolve(c), d);\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                }, params);\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n+\/\/            try {\n+\/\/                plugin.instrument(classes, f -> {\n+\/\/                    try {\n+\/\/                        return Files.readAllBytes(in.resolve(f));\n+\/\/                    } catch (IOException e) {\n+\/\/                        throw new UncheckedIOException(e);\n+\/\/                    }\n+\/\/                }, (c, d) -> {\n+\/\/                    try {\n+\/\/                        Files.write(out.resolve(c), d);\n+\/\/                    } catch (IOException e) {\n+\/\/                        throw new UncheckedIOException(e);\n+\/\/                    }\n+\/\/                }, params);\n+\/\/            } catch (Exception e) {\n+\/\/                throw new RuntimeException(e);\n+\/\/            }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/insert\/AbstractUniversalInstrumenter.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,178 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov.instrument;\n-\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.UncheckedIOException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * A utility class to implement the most common case of using the InstrumentationPlaugin: with the files in filesystems.\n- * Suitable to be used for any supported filesystem type.\n- *\/\n-public class Instrumentation {\n-    private final InstrumentationPlugin plugin;\n-\n-    public Instrumentation(InstrumentationPlugin plugin) {\n-        this.plugin = plugin;\n-    }\n-\n-    \/**\n-     * Instruments classes with the specified plugin, reading from one location and saving to another. Resources which\n-     * are not classfiles are copied derectly. Content of the implant is also copied into the output.\n-     *\n-     * @param from\n-     * @param to\n-     * @param params\n-     * @param implant\n-     * @throws Exception\n-     *\/\n-    \/\/TODO should implant really even be a part of this? easily could be added after this call\n-    public void instrument(Path from, Path to, InstrumentationParams params, Implant implant)\n-            throws Exception {\n-        List<Path> resources = Files.find(from, Integer.MAX_VALUE,\n-                        (f, a) -> Files.isRegularFile(f))\n-                .collect(Collectors.toList());\n-        plugin.instrument(resources.stream()\n-                            .filter(r -> isClass(r))\n-                        .map(r -> toClassName(from, r))\n-                        .collect(Collectors.toList()),\n-                c -> {\n-                    try {\n-                        return Files.readAllBytes(toResource(from, c));\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                },\n-                (c, b) -> {\n-                    try {\n-                        Files.write(toResource(to, c), b);\n-                    } catch (IOException e) {\n-                        throw new UncheckedIOException(e);\n-                    }\n-                },\n-                params);\n-        resources.stream().filter(r -> !isClass(r)).forEach(p -> {\n-            try {\n-                Files.write(to.resolve(from.relativize(p)), Files.readAllBytes(p));\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        });\n-        if(implant != null) {\n-            for (String r : implant.resources()) Files.write(to.resolve(r), implant.read(r));\n-        }\n-    }\n-\n-    public void complete(Path outputDir, Map<String, Path> artifactMap) throws Exception {\n-        Map<String, Consumer<OutputStream>> pluginArtifacts = plugin.complete();\n-        for (String a : pluginArtifacts.keySet()) {\n-            Path to = artifactMap.containsKey(a) ? artifactMap.get(a) : outputDir.resolve(a);\n-            pluginArtifacts.get(a).accept(Files.newOutputStream(to));\n-        }\n-    }\n-\n-    private static boolean isClass(Path p) {\n-        return p.getFileName().toString().endsWith(\".class\");\n-    }\n-\n-    static String toClassName(Path root, Path classFile) {\n-        String shortFileName = root.relativize(classFile).toString();\n-        return shortFileName.substring(0, shortFileName.length() - 6)\/\/\".class\"\n-                .replace(root.getFileSystem().getSeparator(), \".\");\n-    }\n-\n-    static Path toResource(Path root, String className) {\n-        return root.resolve(className.replace(\".\", root.getFileSystem().getSeparator()) + \".class\");\n-    }\n-\n-    static public class PathImplant implements Implant {\n-\n-        private final Path source;\n-\n-        public PathImplant(Path source) {\n-            this.source = source;\n-        }\n-\n-        public Path getSource() {\n-            return source;\n-        }\n-\n-        protected boolean accept(Path path, BasicFileAttributes fa) {return true;}\n-\n-        @Override\n-        public Collection<String> resources() throws IOException {\n-            return Files.find(source, Integer.MAX_VALUE, (p,a) -> Files.isRegularFile(p) && accept(p, a))\n-                    .map(p -> source.relativize(p).toString())\n-                    .collect(Collectors.toList());\n-        }\n-\n-        @Override\n-        public byte[] read(String path) {\n-            return new byte[0];\n-        }\n-    }\n-\n-    public interface Implant {\n-        \/\/paths relative to the result root\n-        Collection<String> resources() throws Exception;\n-        byte[] read(String path) throws Exception;\n-    }\n-\n-    public static class FileSystemImplant extends PathImplant implements AutoCloseable {\n-        private final FileSystem fs;\n-        public FileSystemImplant(FileSystem fs) throws IOException {\n-            super(fs.getPath(\"\/\"));\n-            this.fs = fs;\n-        }\n-\n-        @Override\n-        public void close() throws Exception {\n-            fs.close();\n-        }\n-    }\n-\n-    public static class JarImplant extends FileSystemImplant {\n-\n-        public JarImplant(Path jar) throws IOException {\n-            super(FileSystems.newFileSystem(jar, null));\n-        }\n-\n-        @Override\n-        protected boolean accept(Path path, BasicFileAttributes fa) {\n-            return !path.toString().startsWith(\"\/META-INF\");\n-        }\n-    }\n-}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/Instrumentation.java","additions":0,"deletions":178,"binary":false,"changes":178,"status":"deleted"},{"patch":"@@ -162,0 +162,5 @@\n+    public final static OptionDescr DSC_FLUSH_CLASSES =\n+            new OptionDescr(\"flush\", null, \"flush instrumented classes\",\n+                    OptionDescr.VAL_SINGLE, null, \"Specify path to directory, where to store instrumented classes.\\n\"\n+                    + \"Directory should exist. Classes will be saved in respect to their package hierarchy.\\n\"\n+                    + \"Default value is \\\"none\\\". Pushing it means you don't want to flush classes.\", \"none\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationOptions.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,0 +77,7 @@\n+\n+\n+    public InstrumentationParams() {\n+        this(false, false, false, false, ABSTRACTMODE.NONE,\n+                new String[0], new String[0], new String[0], new String[0], InstrumentationMode.BLOCK);\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationParams.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import java.io.InputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n@@ -29,0 +30,8 @@\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -30,0 +39,1 @@\n+import java.util.List;\n@@ -33,1 +43,0 @@\n-import java.util.function.Function;\n@@ -35,1 +44,1 @@\n-import java.util.function.Supplier;\n+import java.util.jar.JarFile;\n@@ -37,0 +46,1 @@\n+import java.util.zip.ZipEntry;\n@@ -47,0 +57,2 @@\n+    String CLASS_EXTENTION = \".class\";\n+    String MODULE_INFO_CLASS = \"module-info.class\";\n@@ -48,1 +60,11 @@\n-    void instrument(Collection<String> classes, Function<String, byte[]> loader, BiConsumer<String, byte[]> saver,\n+    \/**\n+     *\n+     * @param resources A collection of resource paths relative to root of the class hierarchy. '\/' is supposed to be\n+     *                  used as a file separator.\n+     * @param loader\n+     * @param saver\n+     * @param parameters\n+     * @throws Exception\n+     *\/\n+    void instrument(Collection<String> resources, ClassLoader loader,\n+                    BiConsumer<String, byte[]> saver,\n@@ -61,0 +83,4 @@\n+    default boolean isClass(String resource) {\n+        return resource.endsWith(CLASS_EXTENTION) && !resource.endsWith(MODULE_INFO_CLASS);\n+    }\n+\n@@ -63,1 +89,7 @@\n-    class FilteringPlugin implements InstrumentationPlugin {\n+    interface ModuleInstrumentationPlugin {\n+        String getModuleName(byte[] moduleInfo);\n+        byte[] addExports(List<String> exports, byte[] moduleInfo, ClassLoader loader);\n+        byte[] clearHashes(byte[] moduleInfo, ClassLoader loader);\n+    }\n+\n+    abstract class ProxyInstrumentationPlugin implements InstrumentationPlugin {\n@@ -65,0 +97,16 @@\n+\n+        protected ProxyInstrumentationPlugin(InstrumentationPlugin inner) {\n+            this.inner = inner;\n+        }\n+\n+        public InstrumentationPlugin getInner() {\n+            return inner;\n+        }\n+\n+        @Override\n+        public final Map<String, Consumer<OutputStream>> complete() throws Exception {\n+            return inner.complete();\n+        }\n+    }\n+\n+    class FilteringPlugin extends ProxyInstrumentationPlugin {\n@@ -68,1 +116,1 @@\n-            this.inner = inner;\n+            super(inner);\n@@ -73,1 +121,1 @@\n-        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n+        public void instrument(Collection<String> resources, ClassLoader loader,\n@@ -75,1 +123,1 @@\n-            inner.instrument(classes.stream().filter(filter).collect(Collectors.toList()),\n+            getInner().instrument(resources.stream().filter(filter).collect(Collectors.toList()),\n@@ -77,1 +125,24 @@\n-            classes.stream().filter(filter.negate()).forEach(c -> saver.accept(c, loader.apply(c)));\n+            resources.stream().filter(filter.negate()).forEach(c -> {\n+                try {\n+                    saver.accept(c,\n+                            loader.getResourceAsStream(c).readAllBytes());\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    interface Source extends Closeable {\n+        \/\/paths relative to the result root\n+        Collection<String> resources() throws Exception;\n+        ClassLoader loader();\n+    }\n+\n+    class ImplantingPlugin extends ProxyInstrumentationPlugin {\n+        private final Source source;\n+\n+        \/\/TODO similar to ModuleImplantingPlugin have different implants for different locations somehow?\n+        public ImplantingPlugin(InstrumentationPlugin inner, Source source) {\n+            super(inner);\n+            this.source = source;\n@@ -81,2 +152,28 @@\n-        public Map<String, Consumer<OutputStream>> complete() throws Exception {\n-            return inner.complete();\n+        public void instrument(Collection<String> classes, ClassLoader loader,\n+                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n+            getInner().instrument(classes, loader, saver, parameters);\n+            for(String r : source.resources()) saver.accept(r, source.loader().getResourceAsStream(r).readAllBytes());\n+        }\n+    }\n+\n+    \/\/TODO better be private\n+    class OverridingClassLoader extends URLClassLoader {\n+\n+        private static URL[] toURL(Path root) {\n+            try {\n+                return new URL[] {root.toUri().toURL()};\n+            } catch (MalformedURLException e) {\n+                \/\/should not happen since getting teh URL legally\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private final ClassLoader backup;\n+\n+        public OverridingClassLoader(Path root, ClassLoader backup) {\n+            this(toURL(root), backup);\n+        }\n+\n+        public OverridingClassLoader(URL[] urls, ClassLoader backup) {\n+            super(urls);\n+            this.backup = backup;\n@@ -85,4 +182,13 @@\n-\/\/        @Override\n-\/\/        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n-\/\/            inner.complete(templateStreamSupplier);\n-\/\/        }\n+        @Override\n+        public URL getResource(String name) {\n+            \/\/first try to find local resource, from teh current module\n+            URL resource = findResource(name);\n+            \/\/for module-info it does not make sense to look in other classloaders\n+            if(name.equals(MODULE_INFO_CLASS)) return resource;\n+            \/\/if none, try other modules\n+            if (resource == null) resource = backup.getResource(name);\n+            \/\/that should not happen during normal use\n+            \/\/if happens, refer to super, nothing else we can do\n+            if (resource == null) resource = super.getResource(name);\n+            return resource;\n+        }\n@@ -91,205 +197,131 @@\n-\/\/    interface ModuleImplant {\n-\/\/        \/\/TODO qualified exports?\n-\/\/        List<String> exports();\n-\/\/        Collection<String> classes();\n-\/\/        Function<String, byte[]> loader();\n-\/\/    }\n-\/\/\n-\/\/    abstract class ModuleImplantingPlugin implements InstrumentationPlugin {\n-\/\/\n-\/\/        public static final String MODULE_INFO_CLASS = \"module-info.class\";\n-\/\/\n-\/\/        public interface ModuleInstrumentationPlugin extends InstrumentationPlugin {\n-\/\/            String getModuleName(byte[] moduleInfo);\n-\/\/            byte[] addExports(List<String> exports, byte[] moduleInfo);\n-\/\/        }\n-\/\/\n-\/\/        private final ModuleInstrumentationPlugin inner;\n-\/\/        private final Function<String, ModuleImplant> implants;\n-\/\/\n-\/\/        public ModuleImplantingPlugin(ModuleInstrumentationPlugin inner, Function<String, ModuleImplant> implants) {\n-\/\/            this.inner = inner;\n-\/\/            this.implants = implants;\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n-\/\/                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n-\/\/            inner.instrument(classes, loader, saver, parameters);\n-\/\/            String moduleName = inner.getModuleName(loader.apply(MODULE_INFO_CLASS));\n-\/\/            if(moduleName != null) {\n-\/\/                ModuleImplant implant = implants.apply(moduleName);\n-\/\/                if(implant != null) {\n-\/\/                    saver.accept(MODULE_INFO_CLASS, loader.apply(MODULE_INFO_CLASS));\n-\/\/                    for(String c : implant.classes()) saver.accept(c, implant.loader().apply(c));\n-\/\/                }\n-\/\/            }\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public void complete(Supplier<OutputStream> template) throws Exception {\n-\/\/            inner.complete(template);\n-\/\/        }\n-\/\/    }\n-\/\/\n-\/\/    class ImplantingPlugin implements InstrumentationPlugin {\n-\/\/        private final Collection<String> implant;\n-\/\/        private final Function<String, byte[]> implantLoader;\n-\/\/        private final InstrumentationPlugin inner;\n-\/\/\n-\/\/        \/\/TODO similar to ModuleImplantingPlugin have different implants for different locations somehow?\n-\/\/        public ImplantingPlugin(InstrumentationPlugin inner,\n-\/\/                                Collection<String> implant, Function<String, byte[]> loader) {\n-\/\/            this.implant = implant;\n-\/\/            this.implantLoader = loader;\n-\/\/            this.inner = inner;\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n-\/\/                               BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws Exception {\n-\/\/            inner.instrument(classes, loader, saver, parameters);\n-\/\/            implant.forEach(c -> saver.accept(c, implantLoader.apply(c)));\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public void complete(Supplier<OutputStream> templateStreamSupplier) throws Exception {\n-\/\/            inner.complete(templateStreamSupplier);\n-\/\/        }\n-\/\/\n-\/\/        protected InstrumentationPlugin inner() {\n-\/\/            return inner;\n-\/\/        }\n-\/\/    }\n-\/\/\n-\/\/    interface ClassHierarchyReader {\n-\/\/        Collection<String> getClasses() throws Exception;\n-\/\/        Function<String, byte[]> getLoader() throws Exception;\n-\/\/    }\n-\/\/\n-\/\/    class ClassHierarchyFileSystemReader implements ClassHierarchyReader {\n-\/\/\n-\/\/        private final FileSystem fs;\n-\/\/        private final Path root;\n-\/\/\n-\/\/        public ClassHierarchyFileSystemReader(FileSystem fs, Path root) {\n-\/\/            this.fs = fs;\n-\/\/            this.root = root;\n-\/\/        }\n-\/\/\n-\/\/        public ClassHierarchyFileSystemReader(Path root) {\n-\/\/            this(FileSystems.getDefault(), root);\n-\/\/        }\n-\/\/\n-\/\/        public ClassHierarchyFileSystemReader(FileSystem fs) {\n-\/\/            this(fs, fs.getRootDirectories().iterator().next());\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public Collection<String> getClasses() throws IOException {\n-\/\/            return Files.find(root, Integer.MAX_VALUE,\n-\/\/                            (f, a) -> f.toString().endsWith(\".class\"))\n-\/\/                    .map(f -> root.relativize(f))\n-\/\/                    .map(Path::toString)\n-\/\/                    .map(s -> s.substring(0, s.length() - \".class\".length()))\n-\/\/                    .collect(Collectors.toList());\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public Function<String, byte[]> getLoader() {\n-\/\/            return f -> {\n-\/\/                try {\n-\/\/                    return Files.readAllBytes(root.resolve(f + \".class\"));\n-\/\/                } catch (IOException e) {\n-\/\/                    throw new UncheckedIOException(e);\n-\/\/                }\n-\/\/            };\n-\/\/        }\n-\/\/    }\n-\/\/\n-\/\/    class SingleClassReader implements ClassHierarchyReader {\n-\/\/\n-\/\/        private final Path source;\n-\/\/\n-\/\/        public SingleClassReader(Path source) {\n-\/\/            if(!source.toString().endsWith(\"class\")) throw new IllegalArgumentException(\"Must be a class file: \" + source);\n-\/\/            this.source = source;\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public Collection<String> getClasses() throws IOException {\n-\/\/            return List.of(source.toString().substring(0, source.toString().length() - \".class\".length()));\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public Function<String, byte[]> getLoader() {\n-\/\/            return f -> {\n-\/\/                try {\n-\/\/                    return Files.readAllBytes(source);\n-\/\/                } catch (IOException e) {\n-\/\/                    throw new UncheckedIOException(e);\n-\/\/                }\n-\/\/            };\n-\/\/        }\n-\/\/    }\n-\/\/\n-\/\/    class ClassHierarchyFileSystemWriter implements BiConsumer<String, byte[]> {\n-\/\/        private final FileSystem fs;\n-\/\/        private final Path target;\n-\/\/\n-\/\/        public ClassHierarchyFileSystemWriter(FileSystem fs, Path target) {\n-\/\/            this.fs = fs;\n-\/\/            this.target = target;\n-\/\/        }\n-\/\/\n-\/\/        public ClassHierarchyFileSystemWriter(Path target) {\n-\/\/            this(FileSystems.getDefault(), target);\n-\/\/        }\n-\/\/\n-\/\/        public ClassHierarchyFileSystemWriter(FileSystem fs) {\n-\/\/            this(fs, fs.getRootDirectories().iterator().next());\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public void accept(String s, byte[] bytes) {\n-\/\/            try {\n-\/\/                Files.write(target.resolve(s + \".class\"), bytes);\n-\/\/            } catch (IOException e) {\n-\/\/                throw new UncheckedIOException(e);\n-\/\/            }\n-\/\/        }\n-\/\/    }\n-\/\/\n-\/\/    \/\/TODO inherit ClassHierarchyFileSystemWriter\n-\/\/    class ClassHierarchyJarWriter implements BiConsumer<String, byte[]> {\n-\/\/        private final Path path;\n-\/\/\n-\/\/        public ClassHierarchyJarWriter(String rt) throws IOException {\n-\/\/            this(Paths.get(rt));\n-\/\/        }\n-\/\/\n-\/\/        public ClassHierarchyJarWriter(Path path) throws IOException {\n-\/\/            this.path = path;\n-\/\/        }\n-\/\/\n-\/\/        @Override\n-\/\/        public void accept(String s, byte[] bytes) {\n-\/\/            try (FileSystem fs = FileSystems.newFileSystem(path, null)) {\n-\/\/                try(OutputStream out = Files.newOutputStream(fs.getPath(s + \".class\"))) {\n-\/\/                    out.write(bytes);\n-\/\/                }\n-\/\/            } catch (IOException e) {\n-\/\/                throw new UncheckedIOException(e);\n-\/\/            }\n-\/\/        }\n-\/\/    }\n-\/\/\n-\/\/    class JarFileReader extends ClassHierarchyFileSystemReader {\n-\/\/        public JarFileReader(String jar) throws IOException {\n-\/\/            this(Paths.get(jar));\n-\/\/        }\n-\/\/        public JarFileReader(Path jar) throws IOException {\n-\/\/            super(FileSystems.newFileSystem(jar, null));\n-\/\/        }\n-\/\/    }\n-\/\/\n+    interface Destination extends Closeable {\n+        BiConsumer<String, byte[]> saver();\n+    }\n+\n+    \/**\n+     * A utility class which works with a given plugin in turms of file hierarchies.\n+     *\/\n+    class Instrumentation {\n+        private final InstrumentationPlugin inner;\n+\n+        public Instrumentation(InstrumentationPlugin inner) {\n+            this.inner = inner;\n+        }\n+\n+        public void instrument(Source source, Destination destination,\n+                                     InstrumentationParams parameters) throws Exception {\n+            inner.instrument(source.resources(), source.loader(),\n+                    destination.saver(), parameters);\n+        }\n+    }\n+\n+    \/**\n+     * Helps to instrument modules.\n+     * @see #Instrumentation\n+     *\/\n+    class ModuleInstrumentation extends Instrumentation {\n+        private final ModuleInstrumentationPlugin modulePlugin;\n+\n+        public ModuleInstrumentation(InstrumentationPlugin inner, ModuleInstrumentationPlugin modulePlugin) {\n+            super(inner);\n+            this.modulePlugin = modulePlugin;\n+        }\n+\n+        public ModuleInstrumentationPlugin getModulePluign() {\n+            return modulePlugin;\n+        }\n+\n+        \/**\n+         * Take any required action needed to instrument a module. This implementation does not do anything.\n+         * @param moduleInfo\n+         * @param loader\n+         * @param destination\n+         * @throws Exception\n+         * @see ModuleInstrumentationPlugin\n+         *\/\n+        protected void proccessModule(byte[] moduleInfo, ClassLoader loader, BiConsumer<String, byte[]> destination)\n+                throws Exception {\n+        }\n+\n+        @Override\n+        public void instrument(Source source, Destination destination,\n+                               InstrumentationParams parameters) throws Exception {\n+            super.instrument(source, destination, parameters);\n+            byte[] moduleInfo = source.loader().getResourceAsStream(MODULE_INFO_CLASS).readAllBytes();\n+            proccessModule(moduleInfo, source.loader(), destination.saver());\n+        }\n+    }\n+\n+    class PathSource implements Source, Closeable {\n+\n+        private final ClassLoader loader;\n+        private final Path root;\n+\n+        public PathSource(ClassLoader backup, Path root) {\n+            this.loader = new OverridingClassLoader(root, backup);\n+            this.root = root;\n+        }\n+\n+        @Override\n+        public Collection<String> resources() throws Exception {\n+            if(Files.isDirectory(root))\n+                return Files.find(root, Integer.MAX_VALUE, (f, a) -> Files.isRegularFile(f))\n+                        .map(r -> root.relativize(r).toString())\n+                        .collect(Collectors.toList());\n+            else\n+                try (JarFile jar = new JarFile(root.toFile())) {\n+                    return jar.stream().filter(f -> !f.isDirectory())\n+                            .map(ZipEntry::getName).collect(Collectors.toList());\n+                }\n+        }\n+\n+        @Override\n+        public ClassLoader loader() {\n+            return loader;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (loader instanceof Closeable) ((Closeable) loader).close();\n+        }\n+\n+        public boolean isModule() throws IOException {\n+            if (Files.isDirectory(root)) {\n+                return Files.exists(root.resolve(MODULE_INFO_CLASS));\n+            } else {\n+                try (JarFile jar = new JarFile(root.toFile())) {\n+                    return jar.stream().map(ZipEntry::getName).anyMatch(MODULE_INFO_CLASS::equals);\n+                }\n+            }\n+        }\n+    }\n+\n+    class PathDestination implements Destination, Closeable {\n+        private final Path root;\n+        private final FileSystem fs;\n+        private final BiConsumer<String, byte[]> saver;\n+\n+        public PathDestination(Path root) throws IOException {\n+            fs = Files.isDirectory(root) ? null : FileSystems.newFileSystem(root, null);\n+            this.root = Files.isDirectory(root) ? root : fs.getPath(\"\/\");\n+            saver = (s, bytes) -> {\n+                try {\n+                    Path f = PathDestination.this.root.resolve(s);\n+                    Files.createDirectories(f.getParent());\n+                    Files.write(f, bytes);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (fs != null) fs.close();\n+        }\n+\n+        @Override\n+        public BiConsumer<String, byte[]> saver() {\n+            return saver;\n+        }\n+    }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationPlugin.java","additions":252,"deletions":220,"binary":false,"changes":472,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.ModuleVisitor;\n@@ -36,1 +40,1 @@\n-import java.util.ArrayList;\n+import java.net.URL;\n@@ -40,0 +44,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -42,1 +47,0 @@\n-import java.util.function.Function;\n@@ -48,1 +52,2 @@\n-public class ASMInstrumentationPlugin implements InstrumentationPlugin {\n+public class ASMInstrumentationPlugin implements InstrumentationPlugin,\n+        InstrumentationPlugin.ModuleInstrumentationPlugin {\n@@ -51,2 +56,1 @@\n-    \/\/TODO prehaps support qualified exports\n-    private List<String> exports = new ArrayList<>();\n+\/\/    private String moduleName;\n@@ -55,2 +59,2 @@\n-    public void instrument(Collection<String> classes, Function<String, byte[]> loader,\n-                           BiConsumer<String, byte[]> saver, InstrumentationParams parameters) {\n+    public void instrument(Collection<String> resources, ClassLoader loader,\n+                           BiConsumer<String, byte[]> saver, InstrumentationParams parameters) throws IOException {\n@@ -60,0 +64,2 @@\n+        URL miURL = loader.getResource(MODULE_INFO_CLASS);\n+        String moduleName = (miURL == null) ? null : getModuleName(miURL.openStream().readAllBytes());\n@@ -61,11 +67,10 @@\n-        classes.forEach(cls -> {\n-            try {\n-                \/\/TODO nulls\n-                byte[] instrumented = morph.morph(loader.apply(cls), null, null);\n-                \/\/TODO shoul never be null\n-                if(instrumented != null) saver.accept(cls, instrumented);\n-            } catch (IOException e) {\n-                \/\/todo should this even be thrown?\n-                throw new UncheckedIOException(e);\n-            }\n-        });\n+        morph.setCurrentModuleName(moduleName);\n+        for(String r : resources) {\n+            byte[] content = loader.getResourceAsStream(r).readAllBytes();\n+            if(isClass(r)) {\n+                byte[] instrumented = morph.morph(content, loader, null);\n+                \/\/TODO should never be null\n+                if(instrumented != null) saver.accept(r, instrumented);\n+            } else saver.accept(r, content);\n+        }\n+\/\/        moduleName = null;\n@@ -86,0 +91,35 @@\n+\n+    @Override\n+    public String getModuleName(byte[] moduleInfo) {\n+        AtomicReference<String> moduleName = new AtomicReference<>(null);\n+        ClassReader cr = new ClassReader(moduleInfo);\n+        ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, getClass().getClassLoader());\n+        cr.accept( new ClassVisitor(ASMUtils.ASM_API_VERSION, cw) {\n+            @Override\n+            public ModuleVisitor visitModule(String name, int access, String version) {\n+                moduleName.set(name);\n+                return null;\n+            }\n+        }, 0);\n+        return moduleName.get();\n+    }\n+\n+    @Override\n+    public byte[] addExports(List<String> exports, byte[] moduleInfo, ClassLoader loader) {\n+        return ClassMorph.addExports(moduleInfo, exports, loader);\n+    }\n+\n+    @Override\n+    public byte[] clearHashes(byte[] moduleInfo, ClassLoader loader) {\n+        return ClassMorph.clearHashes(moduleInfo, loader);\n+    }\n+\n+\/\/    @Override\n+\/\/    public void instrumentModuleInfo(ClassLoader loader, BiConsumer<String, byte[]> saver, List<String> expports,\n+\/\/                                     boolean clearHashes, InstrumentationParams parameters) throws IOException {\n+\/\/        byte[] mi = loader.getResourceAsStream(MODULE_INFO_CLASS).readAllBytes();\n+\/\/        moduleName = getModuleName(mi);\n+\/\/        if(expports != null && !expports.isEmpty()) mi = addExports(expports, mi, loader);\n+\/\/        if(clearHashes) mi = clearHashes(mi, loader);\n+\/\/        saver.accept(MODULE_INFO_CLASS, mi);\n+\/\/    }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ASMInstrumentationPlugin.java","additions":58,"deletions":18,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -300,1 +301,1 @@\n-    public byte[] clearHashes(byte[] moduleInfo, ClassLoader loader) {\n+    public static byte[] clearHashes(byte[] moduleInfo, ClassLoader loader) {\n@@ -314,1 +315,15 @@\n-    public byte[] addExports(byte[] moduleInfo, List<String> exports, ClassLoader loader) {\n+    public static String getModuleName(byte[] moduleInfo) {\n+        AtomicReference<String> moduleName = new AtomicReference<>(null);\n+        ClassReader cr = new ClassReader(moduleInfo);\n+        ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, ClassMorph.class.getClassLoader());\n+        cr.accept( new ClassVisitor(ASMUtils.ASM_API_VERSION, cw) {\n+            @Override\n+            public ModuleVisitor visitModule(String name, int access, String version) {\n+                moduleName.set(name);\n+                return null;\n+            }\n+        }, 0);\n+        return moduleName.get();\n+    }\n+\n+    public static byte[] addExports(byte[] moduleInfo, List<String> exports, ClassLoader loader) {\n@@ -711,5 +726,0 @@\n-    public final static OptionDescr DSC_FLUSH_CLASSES =\n-            new OptionDescr(\"flush\", null, \"flush instrumented classes\",\n-                    OptionDescr.VAL_SINGLE, null, \"Specify path to directory, where to store instrumented classes.\\n\"\n-                    + \"Directory should exist. Classes will be saved in respect to their package hierarchy.\\n\"\n-                    + \"Default value is \\\"none\\\". Pushing it means you don't want to flush classes.\", \"none\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/ClassMorph.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -230,28 +230,0 @@\n-        if (loader instanceof JREInstr.StaticJREInstrClassLoader) {\n-            InputStream in = getInputStreamForName(clName, loader, false, \".class\");\n-\n-            if (in == null) {\n-                in = getInputStreamForName(clName, ClassLoader.getSystemClassLoader(), false, \".class\");\n-\n-                if (in == null) {\n-                    throw new IOException(\"Can't read class \" + clName + \" from classloader \" + loader);\n-                }\n-\n-                ClassReader cr = new OffsetLabelingClassReader(in);\n-                classInfo = new ClassInfo(cr.getSuperName(), cr.getInterfaces());\n-                try{\n-                    in.close();\n-                }\n-                catch (Throwable ignore){}\n-                return classInfo;\n-            }\n-\n-            ClassReader cr = new OffsetLabelingClassReader(in);\n-            classInfo = new ClassInfo(cr.getSuperName(), cr.getInterfaces());\n-            try{\n-                in.close();\n-            }\n-            catch (Throwable ignore){}\n-            return classInfo;\n-        }\n-\n@@ -333,0 +305,1 @@\n+            ignore.printStackTrace();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/OverriddenClassWriter.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,0 +27,5 @@\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+import java.io.BufferedWriter;\n@@ -42,0 +47,1 @@\n+import java.util.Arrays;\n@@ -46,0 +52,1 @@\n+import java.util.stream.Collectors;\n@@ -186,1 +193,1 @@\n-            out.putNextEntry(new ZipEntry(\"META-INF\/MANIFEST.MF\"));\n+\/\/            out.putNextEntry(new ZipEntry(\"META-INF\/MANIFEST.MF\"));\n@@ -204,0 +211,26 @@\n+    public static void javac(List<Path> classes) {\n+        JavaCompiler jc = ToolProvider.getSystemJavaCompiler();\n+        StandardJavaFileManager fm = jc.getStandardFileManager(null, null, null);\n+        Iterable<? extends JavaFileObject> cu =\n+                fm.getJavaFileObjectsFromFiles(classes.stream().map(Path::toFile).collect(Collectors.toList()));\n+        jc.getTask(null, fm, null, null, null, cu).call();\n+\/\/        List<String> command = new ArrayList<>();\n+\/\/        command.add(System.getProperty(\"java.home\") + File.separator + \"bin\" + File.separator + )\n+    }\n+    public static void genModuleInfo(Path toDir, String name,\n+                                  List<String> requires,\n+                                  List<String> exports) throws IOException {\n+        Path mi = toDir.resolve(\"module-info.java\");\n+        try(BufferedWriter out = Files.newBufferedWriter(mi)) {\n+            out.write(\"module \" + name + \" {\");out.newLine();\n+            for(String r : requires) {\n+                out.write(\"requires \" + r + \";\"); out.newLine();\n+            }\n+            for(String e: exports) {\n+                out.write(\"exports \" + e + \";\"); out.newLine();\n+            }\n+            out.write(\"}\"); out.newLine();\n+        }\n+        javac(List.of(mi));\n+        Files.delete(mi);\n+    }\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/Util.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.nio.file.Paths;\n@@ -61,1 +60,1 @@\n-        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n+        Path data_dir = Files.createTempDirectory(\"instr_test\");\n@@ -67,1 +66,1 @@\n-        template = test_dir.resolve(\"template.lst\");\n+        template = test_dir.resolve(\"template.xml\");\n@@ -73,1 +72,1 @@\n-    \/\/@Test\n+\/\/    @Test\n@@ -143,0 +142,19 @@\n+    @Test\n+    public void moduleTest() throws Exception {\n+        new Util(test_dir).copyBytecode(UserCode.class.getName());\n+        Util.genModuleInfo(test_dir, \"test\", List.of(), List.of());\n+        new Util(implant_dir).copyBytecode(InstrTest.class.getName());\n+        Files.write(implant_dir.resolve(\"some.properties\"), \"some.property=value\\n\".getBytes());\n+        Util.jar(implant_dir, implant_jar, p -> true);\n+        Instr instr = new Instr();\n+        instr.instrumentFiles(new String[] {test_dir.toString()}, null, implant_jar.toString());\n+        instr.setTemplate(template.toString());\n+        instr.finishWork(template.toString());\n+        testInstrumentation();\n+        assertTrue(Files.exists(test_dir.\n+                resolve(InstrTest.class.getName().replace('.', File.separatorChar) + \".class\")));\n+        assertTrue(Files.exists(test_dir.resolve(\"some.properties\")));\n+        assertTrue(Files.exists(test_dir.resolve(\"module-info.class\")));\n+        assertFalse(Files.exists(test_dir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\")));\n+        run(test_dir);\n+    }\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/instr\/InstrTest.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    Path template;\n+    Path result;\n@@ -81,0 +83,6 @@\n+        System.out.println(\"JRE: \" + testJRE);\n+        template = Path.of(System.getProperty(\"user.dir\")).resolve(\"template.xml\");\n+        result = Path.of(System.getProperty(\"user.dir\")).resolve(\"result.xml\");\n+        Files.deleteIfExists(template);\n+        Files.deleteIfExists(result);\n+        System.out.println(\"Template: \" + template);\n@@ -91,0 +99,1 @@\n+                \"-im\", \"java.desktop\",\n@@ -95,0 +104,6 @@\n+        assertEquals(Files.readAllLines(template)\n+                .stream()\n+                .filter(s -> s.trim().startsWith(\"<package\"))\n+                .filter(s -> !s.contains(\"moduleName=\\\"java.base\\\"\"))\n+                .filter(s -> !s.contains(\"moduleName=\\\"java.desktop\\\"\"))\n+                .count(), 0);\n@@ -127,1 +142,2 @@\n-        Files.deleteIfExists(Paths.get(\"result.xml\"));\n+        Files.deleteIfExists(template);\n+        Files.deleteIfExists(result);\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/jreinstr\/JREInstrTest.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"}]}