{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.tdk.jcov.runtime.FileSaver;\n@@ -42,0 +41,1 @@\n+import java.io.OutputStream;\n@@ -48,0 +48,1 @@\n+import java.util.function.BiConsumer;\n@@ -51,0 +52,1 @@\n+import java.util.stream.Stream;\n@@ -129,1 +131,1 @@\n-    public void instrumentAll(File[] files, File outDir, String includeRTJar) throws IOException {\n+    public void instrumentAll(File[] files, File outDir, String includeRTJar) throws Exception {\n@@ -146,1 +148,1 @@\n-    public void instrumentAll(File[] files, File outDir) throws IOException {\n+    public void instrumentAll(File[] files, File outDir) throws Exception {\n@@ -189,0 +191,1 @@\n+    @Deprecated\n@@ -227,5 +230,3 @@\n-    public void instrumentFiles(File[] files, File outDir, String implantRT) throws IOException {\n-        setDefaultInstrumenter();\n-        for (File file : files) {\n-            instrumenter.instrument(file, outDir, implantRT, recurse);\n-        }\n+    public void instrumentFiles(File[] files, File outDir, String implantRT) throws Exception {\n+        instrumentFiles(Stream.of(files).map(File::toString).collect(Collectors.toList()).toArray(new String[0]),\n+                outDir, implantRT);\n@@ -250,21 +251,24 @@\n-            List<String> classes = Files.find(in, Integer.MAX_VALUE,\n-                            (f, a) -> f.getFileName().toString().endsWith(\".class\"))\n-                    .map(f -> in.relativize(f))\n-                    .map(Path::toString)\n-                    .map(s -> s.substring(0, s.length() - \".class\".length()))\n-                    .collect(Collectors.toList());\n-            params.isIncluded(\"UserCode\");\n-            plugin.instrument(classes, f -> {\n-\/\/            params.filter(plugin).instrument(classes, f -> {\n-                try {\n-                    return Files.readAllBytes(in.resolve(f + \".class\"));\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-            }, (c, d) -> {\n-                try {\n-                    Files.write(out.resolve(c + \".class\"), d);\n-                } catch (IOException e) {\n-                    throw new UncheckedIOException(e);\n-                }\n-            }, params);\n+            InstrumentationPlugin.ClassHierarchyReader reader;\n+            BiConsumer<String, byte[]> writer;\n+            if (Files.isRegularFile(in) && file.endsWith(\".class\")) {\n+                reader = new InstrumentationPlugin.SingleClassReader(in);\n+                writer = (c, b) -> {\n+                    try(OutputStream outputStream = Files.newOutputStream(out)) {\n+                        outputStream.write(b);\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                };\n+            } else if (Files.isRegularFile(in) && file.endsWith(\".jar\")) {\n+                reader = new InstrumentationPlugin.JarFileReader(in);\n+                writer = new InstrumentationPlugin.ClassHierarchyJarWriter(out);\n+            } else if (Files.isDirectory(in)) {\n+                reader = new InstrumentationPlugin.ClassHierarchyFileSystemReader(in);\n+                writer = new InstrumentationPlugin.ClassHierarchyFileSystemWriter(out);\n+            }\n+            else throw new IllegalStateException(\"Unknown input kind: \" + file);\n+            if(implantRT != null) {\n+                InstrumentationPlugin.ClassHierarchyReader implantReader = new InstrumentationPlugin.JarFileReader(implantRT);\n+                plugin = new InstrumentationPlugin.ImplantingPlugin(plugin, implantReader.getClasses(), implantReader.getLoader());\n+            }\n+            plugin.instrument(reader.getClasses(), reader.getLoader(), writer, params);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":33,"deletions":29,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.IOException;\n@@ -28,0 +29,6 @@\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -141,0 +148,132 @@\n+\n+    interface ClassHierarchyReader {\n+        Collection<String> getClasses() throws Exception;\n+        Function<String, byte[]> getLoader() throws Exception;\n+    }\n+\n+    class ClassHierarchyFileSystemReader implements ClassHierarchyReader {\n+\n+        private final FileSystem fs;\n+        private final Path root;\n+\n+        public ClassHierarchyFileSystemReader(FileSystem fs, Path root) {\n+            this.fs = fs;\n+            this.root = root;\n+        }\n+\n+        public ClassHierarchyFileSystemReader(Path root) {\n+            this(FileSystems.getDefault(), root);\n+        }\n+\n+        public ClassHierarchyFileSystemReader(FileSystem fs) {\n+            this(fs, fs.getRootDirectories().iterator().next());\n+        }\n+\n+        @Override\n+        public Collection<String> getClasses() throws IOException {\n+            return Files.find(root, Integer.MAX_VALUE,\n+                            (f, a) -> f.toString().endsWith(\".class\"))\n+                    .map(f -> root.relativize(f))\n+                    .map(Path::toString)\n+                    .map(s -> s.substring(0, s.length() - \".class\".length()))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public Function<String, byte[]> getLoader() {\n+            return f -> {\n+                try {\n+                    return Files.readAllBytes(root.resolve(f + \".class\"));\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            };\n+        }\n+    }\n+\n+    class SingleClassReader implements ClassHierarchyReader {\n+\n+        private final Path source;\n+\n+        public SingleClassReader(Path source) {\n+            if(!source.toString().endsWith(\"class\")) throw new IllegalArgumentException(\"Must be a class file: \" + source);\n+            this.source = source;\n+        }\n+\n+        @Override\n+        public Collection<String> getClasses() throws IOException {\n+            return List.of(source.toString().substring(0, source.toString().length() - \".class\".length()));\n+        }\n+\n+        @Override\n+        public Function<String, byte[]> getLoader() {\n+            return f -> {\n+                try {\n+                    return Files.readAllBytes(source);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            };\n+        }\n+    }\n+\n+    class ClassHierarchyFileSystemWriter implements BiConsumer<String, byte[]> {\n+        private final FileSystem fs;\n+        private final Path target;\n+\n+        public ClassHierarchyFileSystemWriter(FileSystem fs, Path target) {\n+            this.fs = fs;\n+            this.target = target;\n+        }\n+\n+        public ClassHierarchyFileSystemWriter(Path target) {\n+            this(FileSystems.getDefault(), target);\n+        }\n+\n+        public ClassHierarchyFileSystemWriter(FileSystem fs) {\n+            this(fs, fs.getRootDirectories().iterator().next());\n+        }\n+\n+        @Override\n+        public void accept(String s, byte[] bytes) {\n+            try {\n+                Files.write(target.resolve(s + \".class\"), bytes);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+    }\n+\n+    \/\/TODO inherit ClassHierarchyFileSystemWriter\n+    class ClassHierarchyJarWriter implements BiConsumer<String, byte[]> {\n+        private final Path path;\n+\n+        public ClassHierarchyJarWriter(String rt) throws IOException {\n+            this(Paths.get(rt));\n+        }\n+\n+        public ClassHierarchyJarWriter(Path path) throws IOException {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public void accept(String s, byte[] bytes) {\n+            try (FileSystem fs = FileSystems.newFileSystem(path, null)) {\n+                try(OutputStream out = Files.newOutputStream(fs.getPath(s + \".class\"))) {\n+                    out.write(bytes);\n+                }\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+    }\n+\n+    class JarFileReader extends ClassHierarchyFileSystemReader {\n+        public JarFileReader(String jar) throws IOException {\n+            this(Paths.get(jar));\n+        }\n+        public JarFileReader(Path jar) throws IOException {\n+            super(FileSystems.newFileSystem(jar, null));\n+        }\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationPlugin.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.function.Predicate;\n@@ -45,0 +46,3 @@\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n@@ -169,0 +173,29 @@\n+    public static void jar(Path dir, Path dest, Predicate<Path> filter) throws IOException {\n+        try(ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(dest))) {\n+            Files.find(dir, Integer.MAX_VALUE, (p, a) -> true).forEach(p -> {\n+                try {\n+                    if(Files.isRegularFile(p) && filter.test(p)) {\n+                        out.putNextEntry(new ZipEntry(dir.relativize(p).toString()));\n+                        out.write(Files.readAllBytes(p));\n+                        out.closeEntry();\n+                    }\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            });\n+        }\n+    }\n+    public static void unjar(Path src, Path dest) throws IOException {\n+        ZipFile zip = new ZipFile(src.toFile());\n+        zip.stream().forEach(e -> {\n+            try {\n+                Path p = dest.resolve(e.getName());\n+                Files.createDirectories(p.getParent());\n+                try(OutputStream out = Files.newOutputStream(p)) {\n+                    out.write(zip.getInputStream(e).readAllBytes());\n+                }\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        });\n+    }\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/Util.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.nio.file.Files;\n@@ -48,0 +49,2 @@\n+    Path implant_dir;\n+    Path implant_jar;\n@@ -49,0 +52,1 @@\n+    Path test_zip;\n@@ -55,0 +59,2 @@\n+        implant_dir = data_dir.resolve(\"instr_implant\");\n+        implant_jar = data_dir.resolve(\"instr_implant.jar\");\n@@ -56,0 +62,1 @@\n+        test_zip = data_dir.resolve(\"instr_test.jar\");\n@@ -60,1 +67,1 @@\n-    \/\/@Test\n+    @Test\n@@ -70,1 +77,1 @@\n-        run();\n+        run(test_dir);\n@@ -85,1 +92,41 @@\n-        run();\n+        run(test_dir);\n+    }\n+    @Test\n+    public void instrumentZip() throws IOException, InterruptedException, FileFormatException,\n+            ClassNotFoundException, InvocationTargetException, NoSuchMethodException,\n+            IllegalAccessException, InstantiationException {\n+        Path classes = test_dir.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        new Util(classes).copyBytecode(UserCode.class.getName(), InstrTest.class.getName());\n+        Util.jar(classes, test_zip, p -> true);\n+        Util.rmRF(classes);\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(\"-i\");\n+        params.add(\"UserCode\");\n+        params.add(test_zip.toString());\n+        new Instr().run(params.toArray(new String[0]));\n+        Util.unjar(test_zip, classes);\n+        testInstrumentation();\n+        run(classes);\n+    }\n+    @Test\n+    public void implantTest() throws IOException, FileFormatException, ClassNotFoundException,\n+            InvocationTargetException, NoSuchMethodException, IllegalAccessException, InstantiationException {\n+        new Util(test_dir).copyBytecode(UserCode.class.getName());\n+        new Util(implant_dir).copyBytecode(InstrTest.class.getName());\n+        Util.jar(implant_dir, implant_jar, p -> true);\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(\"-implantrt\");\n+        params.add(implant_jar.toString());\n+        params.add(\"-i\");\n+        params.add(\"UserCode\");\n+        params.add(test_dir.toString());\n+        new Instr().run(params.toArray(new String[0]));\n+        testInstrumentation();\n+        assertTrue(Files.exists(test_dir.\n+                resolve(InstrTest.class.getName().replace('.', '\/') + \".class\")));\n+        run(test_dir);\n@@ -97,2 +144,1 @@\n-\/\/    @Test(dependsOnMethods = \"instrumentDir\")\n-    public void run() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n+    public void run(Path test_dir) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n@@ -107,0 +153,3 @@\n+        Util.rmRF(test_zip);\n+        Util.rmRF(implant_dir);\n+        Util.rmRF(implant_jar);\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/instr\/InstrTest.java","additions":54,"deletions":5,"binary":false,"changes":59,"status":"modified"}]}