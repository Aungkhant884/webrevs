{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -671,9 +671,0 @@\n-        try {\n-            String pluginClass = opts.getValue(DSC_INSTR_PLUGIN);\n-            if(pluginClass != null && !pluginClass.isEmpty())\n-                plugin = (InstrumentationPlugin) Class.forName(opts.getValue(DSC_INSTR_PLUGIN))\n-                        .getDeclaredConstructor().newInstance();\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n-                NoSuchMethodException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.tdk.jcov.instrument.HashesAttribute;\n@@ -29,1 +28,0 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -41,1 +39,1 @@\n-import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n@@ -46,0 +44,1 @@\n+import java.util.function.Function;\n@@ -49,0 +48,3 @@\n+import static com.sun.tdk.jcov.util.Utils.CheckOptions.*;\n+import static com.sun.tdk.jcov.util.Utils.getListFiles;\n+\n@@ -68,5 +70,0 @@\n-    private File javac;\n-    private String[] callerInclude;\n-    private String[] callerExclude;\n-    private String[] innerInclude;\n-    private String[] innerExclude;\n@@ -85,1 +82,1 @@\n-    public class StaticJREInstrClassLoader extends URLClassLoader {\n+    public static class StaticJREInstrClassLoader extends URLClassLoader {\n@@ -96,1 +93,1 @@\n-            } catch (IOException ex) {\n+            } catch (IOException ignore) {\n@@ -123,2 +120,2 @@\n-            ArrayList<URL> urls = new ArrayList<URL>();\n-            for (File mod : toInstrument.listFiles()) {\n+            ArrayList<URL> urls = new ArrayList<>();\n+            for (File mod : getListFiles(toInstrument)) {\n@@ -130,1 +127,1 @@\n-            cl = new StaticJREInstrClassLoader(urls.toArray(new URL[urls.size()]));\n+            cl = new StaticJREInstrClassLoader(urls.toArray(new URL[0]));\n@@ -134,1 +131,1 @@\n-                for (File mod : jmodsTemp.listFiles()) {\n+                for (File mod : getListFiles(jmodsTemp)) {\n@@ -136,1 +133,0 @@\n-\n@@ -139,1 +135,3 @@\n-                            addJCovRuntimeToJavaBase(new File(modClasses, \"module-info.class\"), cl);\n+                            File mInfo = new File(modClasses, \"module-info.class\");\n+                            addJCovRuntimeToJavaBase(mInfo, cl);\n+                            updateHashes(mInfo, cl);\n@@ -141,2 +139,0 @@\n-                        updateHashes(new File(modClasses, \"module-info.class\"), cl);\n-\n@@ -195,1 +191,1 @@\n-                for (File file : dirtoInstrument.listFiles()) {\n+                for (File file : getListFiles(dirtoInstrument)) {\n@@ -202,1 +198,1 @@\n-                    for (File mod : dirtoInstrument.listFiles()) {\n+                    for (File mod : getListFiles(dirtoInstrument)) {\n@@ -213,1 +209,1 @@\n-                    for (File mod : dirtoInstrument.listFiles()) {\n+                    for (File mod : getListFiles(dirtoInstrument)) {\n@@ -260,2 +256,2 @@\n-            for (int i = 0; i < addTests.length; ++i) {\n-                tests.add(addTests[i].getAbsolutePath());\n+            for (File addTest : addTests) {\n+                tests.add(addTest.getAbsolutePath());\n@@ -270,1 +266,6 @@\n-\n+    \/**\n+     * Add com\/sun\/tdk\/jcov\/runtime to the module exports to be visible externally\n+     *\n+     * @param file  module-info.class file of java.base\n+     * @param cl    class loader\n+     *\/\n@@ -273,23 +274,12 @@\n-            InputStream in = new FileInputStream(file.getCanonicalPath());\n-            ClassReader cr = new ClassReader(in);\n-            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, cl);\n-\n-            ClassVisitor cv = new ClassVisitor(Utils.ASM_API_VERSION, cw) {\n-                @Override\n-                public ModuleVisitor visitModule(String name, int access, String version) {\n-                    ModuleVisitor mv = super.visitModule(name, access, version);\n-                    mv.visitPackage(\"com\/sun\/tdk\/jcov\/runtime\");\n-                    mv.visitExport(\"com\/sun\/tdk\/jcov\/runtime\", 0);\n-                    return mv;\n-                }\n-            };\n-\n-            cr.accept(cv, 0);\n-\n-            DataOutputStream dout = new DataOutputStream(new FileOutputStream(file.getCanonicalPath()));\n-            dout.write(cw.toByteArray());\n-            dout.flush();\n-            in.close();\n-            dout.close();\n-        } catch (Exception e) {\n-            logger.log(Level.SEVERE, \"can not update java.base\", e);\n+            updateModuleInfoFile(file, cl, classWriter ->\n+                    new ClassVisitor(Utils.ASM_API_VERSION, classWriter) {\n+                        @Override\n+                        public ModuleVisitor visitModule(String name, int access, String version) {\n+                            ModuleVisitor mv = super.visitModule(name, access, version);\n+                            mv.visitPackage(\"com\/sun\/tdk\/jcov\/runtime\");\n+                            mv.visitExport(\"com\/sun\/tdk\/jcov\/runtime\", 0);\n+                            return mv;\n+                        }\n+                    });\n+        } catch (Exception ex) {\n+            logger.log(Level.SEVERE, \"Can't update java.base\/module-info\", ex);\n@@ -299,0 +289,6 @@\n+    \/**\n+     * Remove ModuleHashes attribute to skip a check that there are no qualified exports to upgradeable modules\n+     *\n+     * @param file  module-info.class file of java.base\n+     * @param cl    class loader\n+     *\/\n@@ -301,4 +297,13 @@\n-            InputStream in = new FileInputStream(file.getCanonicalPath());\n-            ClassReader cr = new ClassReader(in);\n-            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, cl);\n-            cr.accept(cw, new Attribute[]{new HashesAttribute()}, 0);\n+            updateModuleInfoFile(file, cl, classWriter ->\n+                    new ClassVisitor(Utils.ASM_API_VERSION, classWriter) {\n+                        @Override\n+                        public void visitAttribute(final Attribute attribute) {\n+                            if (!attribute.type.equals(\"ModuleHashes\")) {\n+                                super.visitAttribute(attribute);\n+                            }\n+                        }\n+                    });\n+        } catch (Exception ex) {\n+            logger.log(Level.SEVERE, \"Can't remove module hashes from java.base\/module-info\", ex);\n+        }\n+    }\n@@ -306,7 +311,9 @@\n-            DataOutputStream doutn = new DataOutputStream(new FileOutputStream(file.getCanonicalPath()));\n-            doutn.write(cw.toByteArray());\n-            doutn.flush();\n-            in.close();\n-            doutn.close();\n-        } catch (Exception e) {\n-            logger.log(Level.SEVERE, \"can not update module hashes\", e);\n+    private void updateModuleInfoFile(File file, ClassLoader cl, Function<ClassWriter, ClassVisitor> func) throws Exception {\n+        try( InputStream inputStream = new FileInputStream(file.getCanonicalPath()) ) {\n+            ClassReader cr = new ClassReader(inputStream);\n+            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, cl);\n+            cr.accept(func.apply(cw), 0);\n+            try(DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(file.getCanonicalPath())) ) {\n+                outputStream.write(cw.toByteArray());\n+                outputStream.flush();\n+            }\n@@ -351,1 +358,2 @@\n-            String command = jdk.getAbsolutePath() + File.separator + \"bin\" + File.separator + \"jar xf \" + from.getAbsolutePath();\n+            String command = jdk.getAbsolutePath() + File.separator + \"bin\" + File.separator + \"jar xf \" +\n+                    from.getAbsolutePath();\n@@ -365,1 +373,2 @@\n-            String command = jdk.getAbsolutePath() + File.separator + \"bin\" + File.separator + \"jlink --module-path \" + jmodDir.getCanonicalPath() + \" --add-modules \";\n+            String command = jdk.getAbsolutePath() + File.separator + \"bin\" + File.separator + \"jlink --module-path \" +\n+                    jmodDir.getCanonicalPath() + \" --add-modules \";\n@@ -367,2 +376,2 @@\n-            StringBuilder sb = new StringBuilder(\"\");\n-            for (File subDir : jmodDir.listFiles()) {\n+            StringBuilder sb = new StringBuilder();\n+            for (File subDir : getListFiles(jmodDir)) {\n@@ -373,1 +382,1 @@\n-            String mods = sb.toString().substring(0, sb.toString().length() - 1);\n+            String mods = sb.substring(0, sb.toString().length() - 1);\n@@ -390,2 +399,3 @@\n-            command.append(jdk.getAbsolutePath() + File.separator + \"bin\" + File.separator + \"jmod create \");\n-            command.append(\"--module-path \" + modsDir.getCanonicalPath() + \" \");\n+            command.append(jdk.getAbsolutePath()).append(File.separator).append(\"bin\").append(File.separator).\n+                    append(\"jmod create \").\n+                    append(\"--module-path \").append(modsDir.getCanonicalPath()).append(\" \");\n@@ -393,1 +403,1 @@\n-            for (File subDir : jmodDir.listFiles()) {\n+            for (File subDir : getListFiles(jmodDir)) {\n@@ -427,1 +437,1 @@\n-    private boolean expandJimage(File jimage, String tempDirName) {\n+    private void expandJimage(File jimage, String tempDirName) {\n@@ -429,3 +439,4 @@\n-            String command = jimage.getParentFile().getParentFile().getParent() + File.separator + \"bin\" + File.separator + \"jimage extract --dir \" +\n-                    jimage.getParent() + File.separator + tempDirName + \" \" + jimage.getAbsolutePath();\n-            return doCommand(command,null, \"wrong command for expand jimage: \");\n+            String command = jimage.getParentFile().getParentFile().getParent() + File.separator + \"bin\" + File.separator +\n+                    \"jimage extract --dir \" + jimage.getParent() + File.separator +\n+                    tempDirName + \" \" + jimage.getAbsolutePath();\n+            doCommand(command, null, \"wrong command for expand jimage: \");\n@@ -434,1 +445,0 @@\n-            return false;\n@@ -440,2 +450,2 @@\n-            String command = dir.getParentFile().getParentFile().getParent() + File.separator + \"bin\" + File.separator + \"jimage recreate --dir \" +\n-                    dir + \" \" + new_jimage_path;\n+            String command = dir.getParentFile().getParentFile().getParent() + File.separator + \"bin\" + File.separator +\n+                    \"jimage recreate --dir \" + dir + \" \" + new_jimage_path;\n@@ -451,1 +461,4 @@\n-        Instr.DSC_INCLUDE_RT.usage = \"To run instrumented JRE you should implant JCov runtime library both into rt.jar and into 'lib\/endorsed' directory.\\nWhen instrumenting whole JRE dir with jreinstr tool - these 2 actions will be done automatically.\";\n+        Instr.DSC_INCLUDE_RT.usage = \"To run instrumented JRE you should implant JCov runtime library both into rt.jar \" +\n+                \"and into 'lib\/endorsed' directory.\\nWhen instrumenting whole JRE dir with jreinstr tool - \" +\n+                \"these 2 actions will be done automatically.\";\n+\n@@ -503,1 +516,1 @@\n-        Utils.checkFile(implant, \"JCovRT library jarfile\", Utils.CheckOptions.FILE_ISFILE, Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_CANREAD);\n+        Utils.checkFile(implant, \"JCovRT library jarfile\", FILE_ISFILE, FILE_EXISTS, FILE_CANREAD);\n@@ -547,1 +560,1 @@\n-        Utils.checkFile(f, \"JRE directory\", Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_ISDIR, Utils.CheckOptions.FILE_CANREAD);\n+        Utils.checkFile(f, \"JRE directory\", FILE_EXISTS, FILE_ISDIR, FILE_CANREAD);\n@@ -563,3 +576,2 @@\n-            javac = new File(javacPath);\n-\n-            File newJavac = null;\n+            File javac = new File(javacPath);\n+            File newJavac;\n@@ -568,1 +580,1 @@\n-            if (javacPath.endsWith(\".exe\") && System.getProperty(\"os.name\").toLowerCase().indexOf(\"win\") >= 0) {\n+            if (javacPath.endsWith(\".exe\") && System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n@@ -583,1 +595,1 @@\n-                            OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(newFile), Charset.forName(\"UTF-8\"));\n+                            OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(newFile), StandardCharsets.UTF_8);\n@@ -594,1 +606,1 @@\n-                            OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(newFile), Charset.forName(\"UTF-8\"));\n+                            OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(newFile), StandardCharsets.UTF_8);\n@@ -617,1 +629,2 @@\n-                    throw new EnvHandlingException(\"Can't move specified javac to new location (\" + javacPath + \" to \" + newJavac.getPath() + \")\");\n+                    throw new EnvHandlingException(\"Can't move specified javac to new location\" +\n+                            \" (\" + javacPath + \" to \" + newJavac.getPath() + \")\");\n@@ -622,1 +635,1 @@\n-                        OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(newFile), Charset.forName(\"UTF-8\"));\n+                        OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(newFile), StandardCharsets.UTF_8);\n@@ -633,1 +646,1 @@\n-                        OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(newFile), Charset.forName(\"UTF-8\"));\n+                        OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(newFile), StandardCharsets.UTF_8);\n@@ -647,1 +660,2 @@\n-            \/\/ instrumenting JRE dir - check ${JRE}\/lib\/rt.jar, move ${JRE}\/lib\/rt.jar to ${JRE}\/lib\/rt.jar.bak (if not exist), add copy ${JRE}\/lib\/endorsed\/${implant.jar}\n+            \/\/ instrumenting JRE dir - check ${JRE}\/lib\/rt.jar, move ${JRE}\/lib\/rt.jar to ${JRE}\/lib\/rt.jar.bak (if not exist),\n+            \/\/ add copy ${JRE}\/lib\/endorsed\/${implant.jar}\n@@ -727,1 +741,1 @@\n-                            throw new EnvHandlingException(\"Error while backuping bootmodules.jimage: file not found\", ex);\n+                            throw new EnvHandlingException(\"Error while backing up bootmodules.jimage: file not found\", ex);\n@@ -729,1 +743,1 @@\n-                            throw new EnvHandlingException(\"Error while backuping bootmodules.jimage\", ex);\n+                            throw new EnvHandlingException(\"Error while backing up bootmodules.jimage\", ex);\n@@ -750,2 +764,2 @@\n-        callerInclude = envHandler.getValues(com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_INCLUDE);\n-        callerExclude = envHandler.getValues(com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_CALLER_EXCLUDE);\n+        String[] callerInclude = envHandler.getValues(InstrumentationOptions.DSC_CALLER_INCLUDE);\n+        String[] callerExclude = envHandler.getValues(InstrumentationOptions.DSC_CALLER_EXCLUDE);\n@@ -753,2 +767,2 @@\n-        innerInclude = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleInnerInclude(envHandler);\n-        innerExclude = com.sun.tdk.jcov.instrument.InstrumentationOptions.handleInnerExclude(envHandler);\n+        String[] innerInclude = InstrumentationOptions.handleInnerInclude(envHandler);\n+        String[] innerExclude = InstrumentationOptions.handleInnerExclude(envHandler);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/JREInstr.java","additions":107,"deletions":93,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,0 @@\n-\/\/            return null;\n@@ -196,1 +195,4 @@\n-                mv.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\", \"enterClinit\", \"()V\", false);\n+                mv.visitMethodInsn(INVOKESTATIC, \"com\/sun\/tdk\/jcov\/runtime\/CollectDetect\",\n+                        \"enterClinit\",\n+                        \"()V\",\n+                        false);\n@@ -201,1 +203,0 @@\n-        \/\/ System.out.println(\"Seeing \" + k.fullname + \".\" + name);\n@@ -223,1 +224,3 @@\n-            mv = plugin.methodVisitor(access, k.getFullname(), name, desc, mv);        return mv;\n+            mv = plugin.methodVisitor(access, k.getFullname(), name, desc, mv);\n+\n+        return mv;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DeferringMethodClassAdapter.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov.instrument;\n-\n-import org.objectweb.asm.*;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-\/**\n- *\n- * @author Alexey Fedorchenko\n- *\/\n-public class HashesAttribute extends Attribute {\n-    private String algorithm;\n-    private Map<String, byte[]> nameToHash;\n-\n-\n-    HashesAttribute(String algorithm, Map<String, byte[]> nameToHash) {\n-        super(\"ModuleHashes\");\n-        this.algorithm = algorithm;\n-        this.nameToHash = nameToHash;\n-    }\n-\n-    public HashesAttribute() {\n-        this(null, null);\n-    }\n-\n-    @Override\n-    protected Attribute read(ClassReader cr,\n-                             int off,\n-                             int len,\n-                             char[] buf,\n-                             int codeOff,\n-                             Label[] labels)\n-    {\n-        String algorithm = cr.readUTF8(off, buf);\n-        off += 2;\n-\n-        int hash_count = cr.readUnsignedShort(off);\n-        off += 2;\n-\n-        Map<String, byte[]> map = new HashMap<String, byte[]>();\n-        for (int i=0; i<hash_count; i++) {\n-            String mn = cr.readModule(off, buf);\n-            off += 2;\n-\n-            int hash_length = cr.readUnsignedShort(off);\n-            off += 2;\n-            byte[] hash = new byte[hash_length];\n-            for (int j = 0; j < hash_length; j++) {\n-                hash[j] = (byte) (0xff & cr.readByte(off + j));\n-            }\n-            off += hash_length;\n-\n-            map.put(mn, hash);\n-        }\n-\n-        return new HashesAttribute(algorithm, map);\n-    }\n-\n-    @Override\n-    protected ByteVector write(ClassWriter cw,\n-                               byte[] code,\n-                               int len,\n-                               int maxStack,\n-                               int maxLocals)\n-    {\n-        ByteVector attr = new ByteVector();\n-\n-        int index = cw.newUTF8(algorithm);\n-        attr.putShort(index);\n-        attr.putShort(0);\n-\n-        return attr;\n-    }\n-}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/HashesAttribute.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021,  Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+import static com.sun.tdk.jcov.util.Utils.CUSTOM_CLASS_FILE_EXTENSIONS;\n+\n@@ -52,1 +54,0 @@\n-    private static String[] customExtentions = PropertyFinder.findValue(\"clext\", \"\").split(\":\");\n@@ -334,1 +335,2 @@\n-        for (int i = 0; i < customExtentions.length; ++i) {\n+        \/\/ trying to get class with custom extension(s) mentioned in \"jcov.clext\" system property\n+        for(String fileExt : CUSTOM_CLASS_FILE_EXTENSIONS) {\n@@ -336,6 +338,3 @@\n-                InputStream in = loader.getResourceAsStream(name + \".\" + customExtentions[i]);\n-                if (in != null) {\n-                    return in;\n-                }\n-            } catch (Throwable ignore) {\n-            }\n+                InputStream in = loader.getResourceAsStream(name + (fileExt.startsWith(\".\") ? fileExt : \".\" + fileExt));\n+                if (in != null) return in;\n+            } catch (Throwable ignore) {}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/OverriddenClassWriter.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-                    System.err.println(\"cannot execute javap, perhaps jdk7+\/lib\/tools.jar is missing from the classpath\");\n+                    System.err.println(\"cannot execute javap, perhaps jdk8\/lib\/tools.jar is missing from the classpath\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/javap\/JavapClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Arrays;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/runtime\/Collect.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n- *\n- * @author Konstantin Bobrovsky\n@@ -1225,0 +1223,15 @@\n+    \/**\n+     * Returns an array of abstract pathnames denoting the files in the directory denoted by this abstract pathname or\n+     * empty list if the abstract pathname does not denote a directory\n+     *\n+     * @param dir abstract pathname denotes a directory\n+     *\/\n+    public static List<File> getListFiles(File dir) {\n+        ArrayList<File> listFiles = new ArrayList<>();\n+        File[] list = dir.listFiles();\n+        if( list != null && list.length > 0) {\n+            listFiles.addAll(Arrays.asList(list));\n+        }\n+        return listFiles;\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/util\/Utils.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"}]}