{"files":[{"patch":"@@ -0,0 +1,2 @@\n+parameter_test\n+out\n","filename":"plugins\/data_coverage\/.gitignore","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+# Default ignored files\n+\/shelf\/\n+\/workspace.xml\n","filename":"plugins\/data_coverage\/.idea\/.gitignore","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"CompilerConfiguration\">\n+    <wildcardResourcePatterns>\n+      <entry name=\"!?*.java\" \/>\n+      <entry name=\"!?*.form\" \/>\n+      <entry name=\"!?*.class\" \/>\n+      <entry name=\"!?*.groovy\" \/>\n+      <entry name=\"!?*.scala\" \/>\n+      <entry name=\"!?*.flex\" \/>\n+      <entry name=\"!?*.kt\" \/>\n+      <entry name=\"!?*.clj\" \/>\n+    <\/wildcardResourcePatterns>\n+  <\/component>\n+<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/compiler.xml","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"Encoding\">\n+    <file url=\"PROJECT\" charset=\"UTF-8\" \/>\n+  <\/component>\n+<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/encodings.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+<component name=\"libraryTable\">\n+  <library name=\"jcov\">\n+    <CLASSES>\n+      <root url=\"jar:\/\/$PROJECT_DIR$\/..\/..\/JCOV_BUILD\/jcov_3.0\/jcov.jar!\/\" \/>\n+    <\/CLASSES>\n+    <JAVADOC \/>\n+    <SOURCES \/>\n+  <\/library>\n+<\/component>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/libraries\/jcov.xml","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+<component name=\"libraryTable\">\n+  <library name=\"org.testng:testng:7.1.0\" type=\"repository\">\n+    <properties maven-id=\"org.testng:testng:7.1.0\" \/>\n+    <CLASSES>\n+      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/org\/testng\/testng\/7.1.0\/testng-7.1.0.jar!\/\" \/>\n+      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/beust\/jcommander\/1.72\/jcommander-1.72.jar!\/\" \/>\n+      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/google\/inject\/guice\/4.1.0\/guice-4.1.0-no_aop.jar!\/\" \/>\n+      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/javax\/inject\/javax.inject\/1\/javax.inject-1.jar!\/\" \/>\n+      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/aopalliance\/aopalliance\/1.0\/aopalliance-1.0.jar!\/\" \/>\n+      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/google\/guava\/guava\/19.0\/guava-19.0.jar!\/\" \/>\n+      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/org\/yaml\/snakeyaml\/1.21\/snakeyaml-1.21.jar!\/\" \/>\n+    <\/CLASSES>\n+    <JAVADOC \/>\n+    <SOURCES \/>\n+  <\/library>\n+<\/component>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/libraries\/org_testng_testng_7_1_0.xml","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"MavenBuildProjectComponent\">\n+    <option name=\"mavenExecutable\" value=\"\" \/>\n+    <option name=\"Settings File\" value=\"$USER_HOME$\/.m2\/settings.xml\" \/>\n+    <option name=\"mavenCommandLineParams\" value=\"\" \/>\n+    <option name=\"vmOptions\" value=\"\" \/>\n+    <option name=\"useMavenEmbedder\" value=\"false\" \/>\n+    <option name=\"useFilter\" value=\"false\" \/>\n+    <option name=\"Batch Mode\" value=\"false\" \/>\n+    <option name=\"Check Plugin Updates\" value=\"false\" \/>\n+    <option name=\"Debug\" value=\"false\" \/>\n+    <option name=\"Errors\" value=\"false\" \/>\n+    <option name=\"Fail At End\" value=\"false\" \/>\n+    <option name=\"Fail Fast\" value=\"false\" \/>\n+    <option name=\"Fail Never\" value=\"false\" \/>\n+    <option name=\"Lax Checksums\" value=\"false\" \/>\n+    <option name=\"No Plugin Registry\" value=\"false\" \/>\n+    <option name=\"No Plugin Updates\" value=\"false\" \/>\n+    <option name=\"Non Recursive\" value=\"false\" \/>\n+    <option name=\"Offline\" value=\"false\" \/>\n+    <option name=\"Reactor\" value=\"false\" \/>\n+    <option name=\"Strict Checksums\" value=\"false\" \/>\n+    <option name=\"Update Plugins\" value=\"false\" \/>\n+    <option name=\"Update Snapshots\" value=\"false\" \/>\n+    <option name=\"Skip Tests\" value=\"false\" \/>\n+    <pom-list \/>\n+  <\/component>\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_11\" default=\"true\" project-jdk-name=\"11\" project-jdk-type=\"JavaSDK\">\n+    <output url=\"file:\/\/$PROJECT_DIR$\/out\" \/>\n+  <\/component>\n+<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/misc.xml","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"ProjectModuleManager\">\n+    <modules>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/data_coverage.iml\" filepath=\"$PROJECT_DIR$\/data_coverage.iml\" \/>\n+    <\/modules>\n+  <\/component>\n+<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/modules.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"VcsDirectoryMappings\">\n+    <mapping directory=\"$PROJECT_DIR$\/..\/..\" vcs=\"Git\" \/>\n+  <\/component>\n+<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/vcs.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+# JCov data plugin\n+\n+This is an implementation of *com.sun.tdk.jcov.instrument.InstrumentationPlugin* plugin which can help with investigating of data flow within Java code. The plugin is intended to add additional instrumentation to collect facts about values used in runtime.\n+\n+Currently this repository only contains code allowing to capture information about method arguments.\n+\n+Code from *com.sun.tdk.jcov.instrument.plugin* JCov unit tests will later be also migrated  into this project to be able to collect data about values assigned to fields.\n+\n+WIP!\n+\n+Please see tests to find out how this can be used.\n","filename":"plugins\/data_coverage\/README.md","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+public abstract class Env<T> {\n+\n+    private static Map<String, String> properties = System.getProperties().entrySet().stream()\n+            .collect(toMap(Object::toString, Objects::toString));\n+\n+    public static Map<String, String> properties() {\n+        return properties;\n+    }\n+\n+    public static void properties(Map<String, String> properties) {\n+        Env.properties = properties;\n+    }\n+\n+    public static String getStringEnv(String property, String defaultValue) {\n+        String propValue = properties.get(property);\n+        if(propValue != null) return defaultValue;\n+        else return defaultValue;\n+    }\n+    public static Path getPathEnv(String property, Path defaultValue) {\n+        String propValue = properties.get(property);\n+        if(propValue != null) return Path.of(propValue);\n+        else return defaultValue;\n+    }\n+    public static <SPI> SPI getSPIEnv(String property, SPI defaultValue) throws ClassNotFoundException,\n+            NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+        String propValue = properties.get(property);\n+        if(propValue != null) {\n+            if (!propValue.contains(\"(\"))\n+                return (SPI) Class.forName(propValue).getConstructor().newInstance();\n+            else {\n+                int ob = propValue.indexOf('(');\n+                int cb = propValue.indexOf(')');\n+                Class cls = Class.forName(propValue.substring(0, ob));\n+                String[] params = propValue.substring(ob, cb - 1).split(\",\");\n+                Class[] paramTypes = new Class[params.length];\n+                Arrays.fill(paramTypes, String.class);\n+                return (SPI) cls.getConstructor(paramTypes).newInstance(params);\n+            }\n+        } else return defaultValue;\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/Env.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data;\n+\n+import com.sun.tdk.jcov.Instr;\n+import openjdk.jcov.data.arguments.instrument.Plugin;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class Instrument {\n+    \/**\n+     * Prefix for all system property names which will be passed to the VM running JCov calls.\n+     *\/\n+    public static final String JCOV_DATA_ENV_PREFIX = \"jcov.data.\";\n+    \/**\n+     * Name of a system property which contains class name of an instrumentation plugin.\n+     *\/\n+    public static final String PLUGIN_CLASS = JCOV_DATA_ENV_PREFIX + \"plugin\";\n+    public static final String JCOV_TEMPLATE = JCOV_DATA_ENV_PREFIX + \"jcov.template\";\n+\n+    private String pluginClass;\n+    private Path jcovTemplate;\n+\n+    public Instrument() {\n+        pluginClass = Env.getStringEnv(PLUGIN_CLASS, Plugin.class.getName());\n+        jcovTemplate = Env.getPathEnv(JCOV_TEMPLATE, Paths.get(\"template.xml\"));\n+    }\n+\n+    public Instrument pluginClass(String pluginClass) {\n+        this.pluginClass = pluginClass;\n+        return this;\n+    }\n+\n+    public Instrument jcovTemplate(Path jcovTemplate) {\n+        this.jcovTemplate = jcovTemplate;\n+        return this;\n+    }\n+\n+    public boolean instrument(List<Path> classes) throws IOException, InterruptedException {\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-instr_plugin\");\n+        params.add(pluginClass);\n+        params.add(\"-t\");\n+        params.add(jcovTemplate.toString());\n+        params.addAll(classes.stream().map(Path::toString).collect(toList()));\n+        return new Instr().run(params.toArray(new String[0])) == 0;\n+    }\n+\n+    public static void main(String[] args) throws IOException, InterruptedException {\n+        new Instrument().instrument(Arrays.stream(args).map(Paths::get).collect(toList()));\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/Instrument.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+package openjdk.jcov.data.arguments.analysis;\n+\n+import openjdk.jcov.data.Instrument;\n+\n+import static openjdk.jcov.data.arguments.instrument.Plugin.ARGUMENTS_PREFIX;\n+\n+public class Reader {\n+    public static final String DESERIALIZER =\n+            Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \".deserializer\";\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/analysis\/Reader.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.instrument;\n+\n+public interface MethodFilter {\n+    boolean accept(int access, String owner, String method);\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/instrument\/MethodFilter.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.instrument;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import openjdk.jcov.data.Instrument;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.Env;\n+import org.objectweb.asm.MethodVisitor;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import static openjdk.jcov.data.Instrument.JCOV_DATA_ENV_PREFIX;\n+import static org.objectweb.asm.Opcodes.*;\n+\n+public class Plugin implements InstrumentationPlugin {\n+    public static final String COLLECTOR_CLASS = \"openjdk.jcov.data.arguments.runtime.Collect\"\n+            .replace('.', '\/');\n+    public static final String COLLECTOR_METHOD = \"collect\";\n+    public static final String COLLECTOR_DESC =\n+            \"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;[Ljava\/lang\/Object;)V\";\n+    public static final String ARGUMENTS_PREFIX = \"args.\";\n+    public static final String SERIALIZER =\n+        Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \".serializer\";\n+    public static final String TEMPLATE_FILE =\n+            JCOV_DATA_ENV_PREFIX + \"arguments.template\";\n+    public static final String METHOD_FILTER =\n+        JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \"method.filter\";\n+\n+    private static class TypeDescriptor extends openjdk.jcov.data.instrument.TypeDescriptor {\n+\n+        public TypeDescriptor(String id, Class cls, int loadOpcode, boolean longOrDouble) {\n+            super(id, cls, loadOpcode, longOrDouble);\n+        }\n+\n+        public TypeDescriptor(String id, Class cls, int loadOpcode, boolean longOrDouble, boolean isPrimitive) {\n+            super(id, cls, loadOpcode, longOrDouble, isPrimitive);\n+        }\n+\n+        \/\/returns new stack index increased by 1 or 2\n+        int visit(int paramIndex, int stackIndex, MethodVisitor visitor) {\n+            visitor.visitInsn(DUP);\n+            visitor.visitIntInsn(BIPUSH, paramIndex);\n+            visitor.visitIntInsn(loadOpcode(), stackIndex);\n+            if(isPrimitive())\n+                visitor.visitMethodInsn(INVOKESTATIC, cls(), \"valueOf\",\n+                        \"(\" + id() + \")L\" + cls() + \";\", false);\n+            visitor.visitInsn(AASTORE);\n+            return stackIndex + (isLongOrDouble() ? 2 : 1);\n+        }\n+    }\n+\n+    final static Map<String, TypeDescriptor> primitiveTypes;\n+\n+    static {\n+        primitiveTypes = new HashMap<>();\n+        primitiveTypes.put(\"I\", new TypeDescriptor(\"I\", Integer.class, ILOAD, false));\n+        primitiveTypes.put(\"J\", new TypeDescriptor(\"J\", Long.class, LLOAD, true));\n+        primitiveTypes.put(\"F\", new TypeDescriptor(\"F\", Float.class, FLOAD, false));\n+        primitiveTypes.put(\"D\", new TypeDescriptor(\"D\", Double.class, DLOAD, true));\n+        primitiveTypes.put(\"Z\", new TypeDescriptor(\"Z\", Boolean.class, ILOAD, false));\n+        primitiveTypes.put(\"B\", new TypeDescriptor(\"B\", Byte.class, ILOAD, false));\n+    }\n+\n+    final static TypeDescriptor objectType = new TypeDescriptor(\"L\", Object.class, ALOAD, false, false);\n+\n+    private final Coverage template;\n+    private MethodFilter methodFilter;\n+    private Path templateFile;\n+    private Function<Object, String> serializer;\n+\n+    public Plugin() throws\n+            ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException,\n+            IllegalAccessException {\n+        template = new Coverage();\n+        methodFilter = (a, o, m) -> true;\n+        templateFile = Env.getPathEnv(TEMPLATE_FILE, Paths.get(\"template.lst\"));\n+        serializer = Env.getSPIEnv(SERIALIZER, Object::toString);\n+    }\n+\n+    @Override\n+    public MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor) {\n+        String method = name + desc;\n+        if(methodFilter.accept(access, owner, method)) {\n+            template.get(owner, method);\n+            return new MethodVisitor(ASM6, visitor) {\n+                @Override\n+                public void visitCode() {\n+                    try {\n+                        List<TypeDescriptor> params = parseDesc(desc);\n+                        if (params.size() > 0) {\n+                            super.visitLdcInsn(owner);\n+                            super.visitLdcInsn(name);\n+                            super.visitLdcInsn(desc);\n+                            super.visitIntInsn(BIPUSH, params.size());\n+                            super.visitTypeInsn(ANEWARRAY, \"java\/lang\/Object\");\n+                            int stackIndex = ((access & ACC_STATIC) > 0) ? 0 : 1;\n+                            for (int i = 0; i < params.size(); i++) {\n+                                stackIndex = params.get(i).visit(i, stackIndex, this);\n+                            }\n+                            visitor.visitMethodInsn(INVOKESTATIC, COLLECTOR_CLASS, COLLECTOR_METHOD,\n+                                    COLLECTOR_DESC, false);\n+                        }\n+                    } catch (Exception e) {\n+                        e.printStackTrace();\n+                    }\n+                    super.visitCode();\n+                }\n+            };\n+        } else return visitor;\n+    }\n+\n+    private static List<TypeDescriptor> parseDesc(String desc) {\n+        if(!desc.startsWith(\"(\")) throw new IllegalArgumentException(\"Not a method descriptor: \" + desc);\n+        int pos = 1;\n+        List<TypeDescriptor> res = new ArrayList<>();\n+        while(desc.charAt(pos) != ')') {\n+            String next = desc.substring(pos, pos + 1);\n+            if(next.equals(\"L\") || next.equals(\"[\")) {\n+                res.add(objectType);\n+                pos = desc.indexOf(\";\", pos) + 1;\n+            } else {\n+                res.add(primitiveTypes.get(next));\n+                pos++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Override\n+    public void instrumentationComplete() throws IOException {\n+        Coverage.write(template, templateFile, serializer);\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/instrument\/Plugin.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.runtime;\n+\n+import openjdk.jcov.data.Env;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+\n+import static openjdk.jcov.data.arguments.instrument.Plugin.TEMPLATE_FILE;\n+\n+public class Collect {\n+    static final Coverage data;\n+\n+    static{\n+        try {\n+            data = Coverage.readTemplate(Env.getPathEnv(TEMPLATE_FILE, Paths.get(\"template.lst\")));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    public static synchronized void collect(String owner, String name, String desc, Object... params) {\n+\/\/        System.out.printf(\"%s.%s%s: %s\\n\", owner, name, desc, (params == null) ? \"null\" :\n+\/\/                Arrays.stream(params).map(Object::getClass).map(Class::getName).collect(joining(\",\")));\n+        data.get(owner, name + desc).add(Arrays.asList(params));\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Collect.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.runtime;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+public class Coverage {\n+\n+    public static final String DATA_PREFIX = \" -> \";\n+    private final Map<String, Map<String, List<List<? extends Object>>>> data;\n+\n+    public static Coverage readTemplate(Path path) throws IOException {\n+        return readImpl(path, s -> null);\n+    }\n+\n+    private static List<? extends Object> parse(String s, Function<String, ? extends Object> deserialize) {\n+        return Arrays.stream(s.split(\",\"))\n+                .map(v -> v.isEmpty() ? null : deserialize.apply(v))\n+                .collect(toList());\n+    }\n+\n+    \/\/TODO move to an SPI class\n+    public static Coverage read(Path path, Function<String, ? extends Object> deserializer) throws IOException {\n+        return readImpl(path, deserializer);\n+    }\n+    private static Coverage readImpl(Path path, Function<String, ? extends Object> deserializer) throws IOException {\n+        Coverage result = new Coverage();\n+        List<List<? extends Object>> lastData = null;\n+        for (String l : Files.readAllLines(path)) {\n+            if (!l.startsWith(DATA_PREFIX)) {\n+                int descStart = l.indexOf('(');\n+                int classEnd = l.lastIndexOf('#', descStart);\n+                String owner = l.substring(0, classEnd);\n+                String name = l.substring(classEnd + 1, descStart);\n+                String desc = l.substring(descStart);\n+                lastData = result.get(owner, name + desc);\n+            } else {\n+                lastData.add(parse(l.substring(DATA_PREFIX.length()), deserializer));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/\/TODO move to an SPI class\n+    public static final void write(Coverage coverage, Path path, Function<Object, String> serializer)\n+            throws IOException {\n+        try(BufferedWriter out = Files.newBufferedWriter(path)) {\n+            coverage.data.entrySet().forEach(ce -> {\n+                    ce.getValue().entrySet().forEach(me -> {\n+                        try {\n+                            out.write(ce.getKey() + \"#\" + me.getKey());\n+                            out.newLine();\n+                            me.getValue().forEach(dl -> {\n+                                try {\n+                                    out.write(DATA_PREFIX +\n+                                            dl.stream().map(d -> serializer.apply(d))\n+                                            .collect(Collectors.joining(\",\")));\n+                                    out.newLine();\n+                                } catch (IOException e) {\n+                                    throw new UncheckedIOException(e);\n+                                }\n+                            });\n+                            out.flush();\n+                        } catch (IOException e) {\n+                            throw new UncheckedIOException(e);\n+                        }\n+                    });\n+            });\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    public Coverage() {\n+        data = new HashMap<>();\n+    }\n+\n+    public List<List<? extends Object>> get(String owner, String method) {\n+        Map<String, List<List<? extends Object>>> methods = data.get(owner);\n+        if(methods == null) {\n+            methods = new HashMap<>();\n+            data.put(owner, methods);\n+        }\n+        List<List<? extends Object>> result = methods.get(method);\n+        if(result == null) {\n+            result = new ArrayList<>();\n+            methods.put(method, result);\n+        }\n+        return result;\n+    }\n+\n+    public Map<String, Map<String, List<List<? extends Object>>>> coverage() {\n+        return data;\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Coverage.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.runtime;\n+\n+import com.sun.tdk.jcov.runtime.JCovSaver;\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.Instrument;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.function.Function;\n+\n+import static openjdk.jcov.data.Instrument.JCOV_DATA_ENV_PREFIX;\n+import static openjdk.jcov.data.arguments.instrument.Plugin.ARGUMENTS_PREFIX;\n+\n+public class Saver implements JCovSaver {\n+\n+    public static final String RESULT_FILE = JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \"result\";\n+    public static final String SERIALIZER =\n+            Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \".serializer\";\n+\n+    private Path resultFile;\n+    private Function<Object, String> serializer;\n+\n+    public Saver() throws\n+            ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException,\n+            IllegalAccessException {\n+        resultFile = Env.getPathEnv(RESULT_FILE, Paths.get(\"result.lst\"));\n+        serializer = Env.getSPIEnv(SERIALIZER, Object::toString);\n+    }\n+\n+    public Saver resultFile(Path resultFile) {\n+        this.resultFile = resultFile;\n+        return this;\n+    }\n+\n+    public Saver serializer(Function<Object, String> serializer) {\n+        this.serializer = serializer;\n+        return this;\n+    }\n+\n+    public void saveResults() {\n+        try {\n+            Coverage.write(Collect.data, resultFile, serializer);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Saver.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.instrument;\n+\n+public class TypeDescriptor {\n+    private final String id;\n+    private final String cls;\n+    private final int loadOpcode;\n+    private final boolean longOrDouble;\n+    private final boolean isPrimitive;\n+\n+    public TypeDescriptor(String id, Class cls, int loadOpcode, boolean longOrDouble) {\n+        this(id, cls, loadOpcode, longOrDouble, true);\n+    }\n+    public TypeDescriptor(String id, Class cls, int loadOpcode, boolean longOrDouble, boolean isPrimitive) {\n+        this.id = id;\n+        this.cls = cls.getName().replace('.','\/');\n+        this.loadOpcode = loadOpcode;\n+        this.longOrDouble = longOrDouble;\n+        this.isPrimitive = isPrimitive;\n+    }\n+\n+    public String id() {\n+        return id;\n+    }\n+\n+    public String cls() {\n+        return cls;\n+    }\n+\n+    public int loadOpcode() {\n+        return loadOpcode;\n+    }\n+\n+    public boolean isLongOrDouble() {\n+        return longOrDouble;\n+    }\n+\n+    public boolean isPrimitive() {\n+        return isPrimitive;\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/instrument\/TypeDescriptor.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.serialization;\n+\n+import java.util.Arrays;\n+import java.util.function.Function;\n+\n+public class EnumDeserializer implements Function<String, Object> {\n+    private final Class<? extends Enum> enumClass;\n+\n+    public EnumDeserializer(String enumClassName) throws ClassNotFoundException {\n+        this((Class<? extends Enum>) Class.forName(enumClassName));\n+    }\n+    public EnumDeserializer(Class<? extends Enum> aClass) {\n+        enumClass = aClass;\n+    }\n+\n+    @Override\n+    public Object apply(String s) {\n+        return Arrays.stream(enumClass.getEnumConstants()).filter(e -> e.name().equals(s))\n+                .findAny().get();\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/serialization\/EnumDeserializer.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.serialization;\n+\n+import java.util.function.Function;\n+\n+public class EnumSerializer implements Function<Object, String> {\n+    @Override\n+    public String apply(Object anEnum) {\n+        if (anEnum instanceof Enum)\n+            return ((Enum) anEnum).name();\n+        else\n+            return \"\";\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/serialization\/EnumSerializer.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.enums;\n+\n+import openjdk.jcov.data.Instrument;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.arguments.instrument.Plugin;\n+import openjdk.jcov.data.arguments.runtime.Saver;\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.lib.Util;\n+import openjdk.jcov.data.serialization.EnumDeserializer;\n+import openjdk.jcov.data.serialization.EnumSerializer;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static openjdk.jcov.data.Instrument.JCOV_TEMPLATE;\n+import static openjdk.jcov.data.arguments.analysis.Reader.DESERIALIZER;\n+import static openjdk.jcov.data.arguments.instrument.Plugin.*;\n+import static openjdk.jcov.data.arguments.runtime.Saver.RESULT_FILE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertSame;\n+\n+public class EnumTest {\n+    private Path test_dir;\n+    private Path template;\n+    private Path coverage;\n+    private EnumSerializer serializer = new EnumSerializer();\n+    private EnumDeserializer deserializer = new EnumDeserializer(UserCode.ENum.class);\n+\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n+        test_dir = data_dir.resolve(\"parameter_test\");\n+        template = test_dir.resolve(\"template.lst\");\n+        coverage = test_dir.resolve(\"coverage.lst\");\n+        Files.deleteIfExists(template);\n+        Files.deleteIfExists(coverage);\n+    }\n+    @Test\n+    public void serialization() {\n+        assertSame(UserCode.ENum.THREE,\n+                new EnumDeserializer(UserCode.ENum.class).apply(new EnumSerializer().apply(UserCode.ENum.THREE)));\n+    }\n+    @Test\n+    public void instrument() throws IOException, InterruptedException {\n+        Env.properties(Map.of(\n+                TEMPLATE_FILE, template.toString(),\n+                JCOV_TEMPLATE, test_dir.resolve(\"template.xml\").toString()));\n+        new Instrument().pluginClass(Plugin.class.getName())\n+                .instrument(new Util(test_dir).\n+                        copyBytecode(openjdk.jcov.data.arguments.enums.UserCode.class.getName()));\n+        Coverage tmplt = Coverage.readTemplate(template);\n+        assertEquals(tmplt.coverage().get(UserCode.class.getName().replace('.', '\/')).size(), 4);\n+    }\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws\n+            ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException,\n+            IOException, InstantiationException {\n+        Env.properties(Map.of(\n+                TEMPLATE_FILE, template.toString(),\n+                RESULT_FILE, coverage.toString(),\n+                SERIALIZER, EnumSerializer.class.getName(),\n+                DESERIALIZER, EnumDeserializer.class.getName() + \"(\" + UserCode.ENum.class.getName()+ \")\"));\n+        new Util(test_dir).runClass(UserCode.class, new String[0], new Saver());\n+        Coverage res = Coverage.read(coverage, deserializer);\n+        List<List<?>> method =\n+                res.get(UserCode.class.getName().replace('.', '\/'),\n+                        \"method(Lopenjdk\/jcov\/data\/arguments\/enums\/UserCode$ENum;)V\");\n+        assertEquals(method.size(), 1);\n+        assertEquals(method.get(0).size(), 1);\n+        assertEquals(method.get(0).get(0), UserCode.ENum.ONE);\n+        List<List<?>> staticMethod =\n+                res.get(UserCode.class.getName().replace('.', '\/'),\n+                        \"staticMethod(Lopenjdk\/jcov\/data\/arguments\/enums\/UserCode$ENum;)V\");\n+        assertEquals(staticMethod.size(), 1);\n+        assertEquals(staticMethod.get(0).size(), 1);\n+        assertEquals(staticMethod.get(0).get(0), UserCode.ENum.TWO);\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/enums\/EnumTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.enums;\n+\n+public class UserCode {\n+    public enum ENum {ONE, TWO, THREE};\n+    public void method(ENum e) {\n+\n+    }\n+    public static void staticMethod(ENum e) {\n+\n+    }\n+\n+    public static void main(String[] args) {\n+        new UserCode().method(ENum.ONE);\n+        UserCode.staticMethod(ENum.TWO);\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/enums\/UserCode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.test;\n+\n+import openjdk.jcov.data.Instrument;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.arguments.instrument.Plugin;\n+import openjdk.jcov.data.arguments.runtime.Saver;\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.lib.Util;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static openjdk.jcov.data.Instrument.JCOV_TEMPLATE;\n+import static openjdk.jcov.data.arguments.instrument.Plugin.*;\n+import static openjdk.jcov.data.arguments.runtime.Saver.RESULT_FILE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+\n+public class ArgumentsTest {\n+    Path test_dir;\n+    Path template;\n+    Path result;\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        Files.deleteIfExists(Paths.get(\"template.lst\"));\n+        Files.deleteIfExists(Paths.get(\"coverage.lst\"));\n+        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n+        test_dir = data_dir.resolve(\"parameter_test\");\n+        template = test_dir.resolve(\"template.lst\");\n+        result = test_dir.resolve(\"coverage.lst\");\n+    }\n+    @Test\n+    public void instrument() throws IOException, InterruptedException {\n+        Env.properties(Map.of(\n+                TEMPLATE_FILE, template.toString(),\n+                JCOV_TEMPLATE, test_dir.resolve(\"template.xml\").toString()));\n+        new Instrument().pluginClass(Plugin.class.getName()).\n+                instrument(new Util(test_dir).copyBytecode(UserCode.class.getName()));\n+        Coverage tmpl = Coverage.readTemplate(template);\n+        assertNotNull(tmpl.coverage().get(UserCode.class.getName().replace('.', '\/')).\n+                get(\"method(IJFDZBLjava\/lang\/String;)V\"));\n+    }\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n+            IllegalAccessException, IOException, InstantiationException {\n+        Env.properties(Map.of(\n+                TEMPLATE_FILE, template.toString(),\n+                RESULT_FILE, result.toString()));\n+        new Util(test_dir).runClass(UserCode.class, new String[0], new Saver());\n+        Coverage coverage = Coverage.read(result, a -> a);\n+        List<List<?>> calls = coverage.get(UserCode.class.getName().replace('.', '\/'),\n+                \"method(IJFDZBLjava\/lang\/String;)V\");\n+        assertEquals(calls.size(), 2);\n+        assertEquals(calls.get(0).get(6), \"6\");\n+        assertEquals(calls.get(1).get(0), \"7\");\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/test\/ArgumentsTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.test;\n+\n+public class UserCode {\n+    public static void method(int i, long j, float f, double d, boolean z, byte b, String s) {\n+        System.out.println(\"Calling with: \" + i + \",\" + j + \",\" + f + \",\" + d + \",\" + z + \",\" + b + \",\" + s);\n+    }\n+\n+    public static void main(String[] args) {\n+        method(0, 1, 2f, 3., true, (byte)5, \"6\");\n+        method(7, 8, 9f, 10d, false, (byte)12, \"13\");\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/test\/UserCode.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.lib;\n+\n+import com.sun.tdk.jcov.runtime.JCovSaver;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class Util {\n+    private final Path outputDir;\n+\n+    public Util(Path dir) {\n+        outputDir = dir;\n+    }\n+\n+    public List<Path> copyBytecode(String... classes) throws IOException {\n+        byte[] buf = new byte[1024];\n+        List<Path> result = new ArrayList<>();\n+        for(String c : classes) {\n+            String classFile = classFile(c);\n+            try(InputStream in = getClass().getClassLoader().getResourceAsStream(classFile)) {\n+                Path o = outputDir.resolve(classFile);\n+                result.add(o);\n+                if(!Files.exists(o.getParent())) Files.createDirectories(o.getParent());\n+                try(OutputStream out = Files.newOutputStream(o)) {\n+                    int read;\n+                    while((read = in.read(buf)) > 0)\n+                        out.write(buf, 0, read);\n+                }\n+            }\n+        };\n+        return result;\n+    }\n+\n+    public static String classFile(String className) {\n+        return className.replace('.', '\/') + \".class\";\n+    }\n+    public Class runClass(Class className, String[] argv, JCovSaver saver)\n+            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        return runClass(className.getName(), argv, saver);\n+    }\n+    public Class runClass(String className, String[] argv, JCovSaver saver)\n+            throws ClassNotFoundException, NoSuchMethodException,\n+            InvocationTargetException, IllegalAccessException {\n+        ClassLoader offOutputDir = new InstrumentedClassLoader();\n+        Class cls = offOutputDir.loadClass(className);\n+        Method m = cls.getMethod(\"main\", new String[0].getClass());\n+        m.invoke(null, (Object)argv);\n+        \/\/have to do this because normally it only works on system exit\n+        saver.saveResults();\n+        return cls;\n+    }\n+\n+    private class InstrumentedClassLoader extends ClassLoader {\n+        protected InstrumentedClassLoader() {\n+            super(Util.class.getClassLoader());\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            Path classFile = outputDir.resolve(classFile(name));\n+            if(Files.exists(classFile)) {\n+                byte[] buf = new byte[1024];\n+                try(InputStream in = Files.newInputStream(classFile)) {\n+                    try(ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                        int read;\n+                        while((read = in.read(buf)) > 0)\n+                            out.write(buf, 0, read);\n+                        return defineClass(name, out.toByteArray(), 0, out.size());\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return super.loadClass(name);\n+        }\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/lib\/Util.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}