{"files":[{"patch":"@@ -40,0 +40,3 @@\n+# path to JCommander library\n+jcommanderjar = jcommander.jar\n+\n","filename":"build\/build.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-                <path path=\"${testngjar}:${build.dir}\/jcov.jar:${result.dir}\/test\/classes\"\/>\n+                <path path=\"${testngjar}:${build.dir}\/jcov.jar:${result.dir}\/test\/classes:${jcommanderjar}\"\/>\n","filename":"build\/build.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -40,0 +41,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -85,0 +87,1 @@\n+    private InstrumentationPlugin plugin;\n@@ -243,1 +246,2 @@\n-                    .setInnerExcludes(innerExclude);\n+                    .setInnerExcludes(innerExclude)\n+                    .setInstrumentationPlugin(plugin);\n@@ -296,1 +300,1 @@\n-    public void finishWork() {\n+    public void finishWork() throws Exception {\n@@ -301,0 +305,1 @@\n+        if(plugin != null) plugin.instrumentationComplete();\n@@ -309,1 +314,1 @@\n-    public void finishWork(String outTemplate) {\n+    public void finishWork(String outTemplate) throws Exception {\n@@ -317,0 +322,1 @@\n+        if(plugin != null) plugin.instrumentationComplete();\n@@ -454,0 +460,4 @@\n+    public void setPlugin(InstrumentationPlugin plugin) {\n+        this.plugin = plugin;\n+    }\n+\n@@ -551,0 +561,1 @@\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INSTR_PLUGIN,\n@@ -647,0 +658,10 @@\n+        try {\n+            String pluginClass = opts.getValue(InstrumentationOptions.DSC_INSTR_PLUGIN);\n+            if(pluginClass != null && !pluginClass.isEmpty())\n+                plugin = (InstrumentationPlugin) Class.forName(opts.getValue(InstrumentationOptions.DSC_INSTR_PLUGIN))\n+                        .getDeclaredConstructor().newInstance();\n+        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n+                NoSuchMethodException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n@@ -474,0 +475,1 @@\n+                com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INSTR_PLUGIN,\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/JREInstr.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,1 +220,4 @@\n-        return mv;\n+\n+        InstrumentationPlugin plugin = params.getInstrumentationPlugin();\n+        if(plugin != null)\n+            mv = plugin.methodVisitor(access, k.getFullname(), name, desc, mv);        return mv;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DeferringMethodClassAdapter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -159,0 +159,3 @@\n+    public final static OptionDescr DSC_INSTR_PLUGIN =\n+            new OptionDescr(\"instr_plugin\", new String[0], \"Instrumentation plugin\", OptionDescr.VAL_SINGLE,\n+                    \"Defines instrumentation to be performed additionaly to already performed by JCov\");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationOptions.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Collection;\n@@ -71,35 +72,86 @@\n-\n-    public InstrumentationParams(boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, InstrumentationMode mode) {\n-        this(dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, mode, null, null);\n-    }\n-\n-    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract, String[] includes, String[] excludes, InstrumentationMode mode) {\n-        this(false, instrumentNative, instrumentFields, false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes, null, null, mode, null, null);\n-    }\n-\n-    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,  String[] includes, String[] excludes, String[] m_includes, String[] m_excludes, InstrumentationMode mode) {\n-        this(false, false, false, instrumentNative, instrumentFields, false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes, null, null, m_includes, m_excludes, mode, null, null);\n-    }\n-\n-    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract, String[] includes, String[] excludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(false, instrumentNative, instrumentFields, false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes, null, null, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract, String[] includes, String[] excludes, String[] callerincludes, String[] callersexcludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(false, instrumentNative, instrumentFields, false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes, callerincludes, callersexcludes, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(false, dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean classesReload, boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(true, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-        this(innerInvocations, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, null, null, mode, saveBegin, saveEnd);\n-    }\n-\n-    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes, String[] m_includes, String[] m_excludes, InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n-\n+    private InstrumentationPlugin plugin;\n+\n+    \/\/TODO replace by a builder!!!\n+    public InstrumentationParams(boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields,\n+                                 boolean detectInternal, ABSTRACTMODE instrumentAbstract, String[] includes,\n+                                 String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 InstrumentationMode mode) {\n+        this(dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract,\n+                includes, excludes, callerIncludes, callerExcludes, mode, null, null);\n+    }\n+\n+    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,\n+                                 String[] includes, String[] excludes, InstrumentationMode mode) {\n+        this(false, instrumentNative, instrumentFields, false,\n+                instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes,\n+                null, null, mode, null, null);\n+    }\n+\n+    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] m_includes, String[] m_excludes,\n+                                 InstrumentationMode mode) {\n+        this(false, false, false, instrumentNative, instrumentFields,\n+                false, instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes,\n+                null, null, m_includes, m_excludes, mode, null, null);\n+    }\n+\n+    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,\n+                                 String[] includes, String[] excludes, InstrumentationMode mode,\n+                                 String[] saveBegin, String[] saveEnd) {\n+        this(false, instrumentNative, instrumentFields, false,\n+                instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE, includes, excludes,\n+                null, null, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean instrumentNative, boolean instrumentFields, boolean instrumentAbstract,\n+                                 String[] includes, String[] excludes,\n+                                 String[] callerincludes, String[] callersexcludes,\n+                                 InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n+        this(false, instrumentNative, instrumentFields, false,\n+                instrumentAbstract ? ABSTRACTMODE.DIRECT : ABSTRACTMODE.NONE,\n+                includes, excludes, callerincludes, callersexcludes, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean dynamicCollect, boolean instrumentNative, boolean instrumentFields,\n+                                 boolean detectInternal, ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n+        this(false, dynamicCollect, instrumentNative, instrumentFields, detectInternal, instrumentAbstract,\n+                includes, excludes, callerIncludes, callerExcludes, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean classesReload, boolean dynamicCollect, boolean instrumentNative,\n+                                 boolean instrumentFields, boolean detectInternal, ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n+        this(true, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal,\n+                instrumentAbstract, includes, excludes, callerIncludes, callerExcludes, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect,\n+                                 boolean instrumentNative, boolean instrumentFields, boolean detectInternal,\n+                                 ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 InstrumentationMode mode, String[] saveBegin, String[] saveEnd) {\n+        this(innerInvocations, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal,\n+                instrumentAbstract, includes, excludes, callerIncludes, callerExcludes,\n+                null, null, mode, saveBegin, saveEnd);\n+    }\n+\n+    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect,\n+                                 boolean instrumentNative, boolean instrumentFields, boolean detectInternal,\n+                                 ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 String[] m_includes, String[] m_excludes, InstrumentationMode mode,\n+                                 String[] saveBegin, String[] saveEnd) {\n+        this(innerInvocations, classesReload, dynamicCollect, instrumentNative, instrumentFields, detectInternal,\n+                instrumentAbstract, includes, excludes, callerIncludes, callerExcludes,\n+                null, null, mode, saveBegin, saveEnd, null);\n+    }\n+\n+    public InstrumentationParams(boolean innerInvocations, boolean classesReload, boolean dynamicCollect,\n+                                 boolean instrumentNative, boolean instrumentFields, boolean detectInternal,\n+                                 ABSTRACTMODE instrumentAbstract,\n+                                 String[] includes, String[] excludes, String[] callerIncludes, String[] callerExcludes,\n+                                 String[] m_includes, String[] m_excludes, InstrumentationMode mode,\n+                                 String[] saveBegin, String[] saveEnd, InstrumentationPlugin plugin) {\n@@ -146,0 +198,1 @@\n+        this.plugin = plugin;\n@@ -176,0 +229,4 @@\n+    public InstrumentationPlugin getInstrumentationPlugin() {\n+        return plugin;\n+    }\n+\n@@ -332,0 +389,5 @@\n+    public InstrumentationParams setInstrumentationPlugin(InstrumentationPlugin plugin) {\n+        this.plugin = plugin;\n+        return this;\n+    }\n+\n@@ -364,0 +426,1 @@\n+        this.plugin = null;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationParams.java","additions":98,"deletions":35,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument;\n+\n+import org.objectweb.asm.MethodVisitor;\n+\n+\/**\n+ * SPI class which allows to do additional instrumentation, in addition to instrumentation performed by JCov by default.\n+ * @author Alexander (Shura) Ilin.\n+ *\/\n+public interface InstrumentationPlugin {\n+    \/**\n+     * Supplies a MethodVisitor to perform additional instrumentation.\n+     *\/\n+    MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor);\n+\n+    \/**\n+     * Called after all instrumentation is complete.\n+     * @throws Exception should some\n+     *\/\n+    void instrumentationComplete() throws Exception;\n+}\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationPlugin.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-import com.sun.tools.javap.Main;\n+\/\/import com.sun.tools.javap.Main;\n@@ -50,1 +50,1 @@\n-                Main.run(new String[]{\"-c\", \"-p\", filePath}, pw);\n+\/\/                Main.run(new String[]{\"-c\", \"-p\", filePath}, pw);\n@@ -52,1 +52,1 @@\n-                Main.run(new String[]{\"-c\", \"-p\", \"-classpath\", jarPath, filePath}, pw);\n+\/\/                Main.run(new String[]{\"-c\", \"-p\", \"-classpath\", jarPath, filePath}, pw);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/report\/javap\/JavapClassReader.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Arrays;\n@@ -317,1 +318,0 @@\n-                    PropertyFinder.addAutoShutdownSave();\n@@ -319,0 +319,1 @@\n+                PropertyFinder.addAutoShutdownSave();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/runtime\/Collect.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -472,0 +473,12 @@\n+                        String s = PropertyFinder.findValue(\"data-saver\", null);\n+                        if(s != null) {\n+                            try {\n+                                Class clz = Class.forName(s);\n+                                Object saver = clz.getConstructor().newInstance();\n+                                Method mthd = clz.getMethod(\"saveResults\", new Class[] {});\n+                                mthd.invoke(saver);\n+                            } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException |\n+                                    InvocationTargetException | InstantiationException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n@@ -476,0 +489,1 @@\n+                ignore.printStackTrace();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/runtime\/PropertyFinder.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin;\n+\n+\/**\n+ * This is a test class which is instrumented during the test.\n+ *\/\n+public class FieldsClass {\n+    int field1;\n+    String field2 = \"\";\n+\n+    public void setField1(int field1) {\n+        this.field1 = field1;\n+    }\n+\n+    public void setField2(String field2) {\n+        this.field2 = field2;\n+    }\n+\n+    public static void main(String[] args) {\n+        FieldsClass ac = new FieldsClass();\n+        ac.field1 = 1;\n+        ac.field2 = \"one\";\n+        ac.setField1(2);\n+        ac.setField2(\"two\");\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/FieldsClass.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.runtime.JCovSaver;\n+import org.objectweb.asm.MethodVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static java.lang.String.format;\n+import static org.objectweb.asm.Opcodes.*;\n+\n+\/**\n+ * An instrumentation plugin which saves some information about fields and methods used during execution.\n+ * This plugin inserts calls to specific mathod after every PUTFIELD bytecode instruction.\n+ * This plugin only supports Object and int data types.\n+ * This class also defines the logic to be used at runtime to save the collected data by printing it into the output.\n+ *\/\n+public class FieldsPlugin implements InstrumentationPlugin, JCovSaver {\n+\n+    public static final Map<String, Set<Object>> values = new HashMap<>();\n+    public static final String INSTRUMENTATION_COMPLETE = \"Instrumentation complete: \";\n+\n+    public static void recordFieldValue(Object value, String field) {\n+        Set<Object> fieldValues = values.getOrDefault(field, new HashSet<>());\n+        if(values.containsKey(field)) {\n+            fieldValues = values.get(field);\n+        } else {\n+            fieldValues = new HashSet<>();\n+            values.put(field, fieldValues);\n+        }\n+        fieldValues.add(value);\n+    }\n+\n+\/\/    @Override\n+    public MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor) {\n+        return new MethodVisitor(ASM6, visitor) {\n+            @Override\n+            public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {\n+                if(opcode == PUTFIELD) {\n+                    super.visitInsn(DUP);\n+                    if(!descriptor.startsWith(\"L\")) {\n+                        switch (descriptor) {\n+                            case \"I\":\n+                                super.visitMethodInsn(INVOKESTATIC, Integer.class.getName().replace(\".\", \"\/\"),\n+                                        \"valueOf\", \"(I)Ljava\/lang\/Integer;\", false);\n+                                break;\n+                        }\n+                    }\n+                    super.visitLdcInsn(format(\"%s.%s\", owner, name));\n+                    super.visitMethodInsn(INVOKESTATIC, FieldsPlugin.class.getName().replace('.', '\/'),\n+                            \"recordFieldValue\", \"(Ljava\/lang\/Object;Ljava\/lang\/String;)V\", false);\n+                }\n+                super.visitFieldInsn(opcode, owner, name, descriptor);\n+            }\n+        };\n+    }\n+\n+    final static AtomicInteger completeCount = new AtomicInteger(0);\n+\n+    @Override\n+    public void instrumentationComplete() throws Exception {\n+        completeCount.incrementAndGet();\n+        System.out.println(INSTRUMENTATION_COMPLETE + completeCount);\n+    }\n+\n+    @Override\n+    public void saveResults() {\n+        values.entrySet().forEach(e ->\n+                e.getValue().forEach(v -> System.out.println(e.getKey() + \"=\" + v)));\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/FieldsPlugin.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin;\n+\n+import com.sun.tdk.jcov.lib.InstrProxy;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static com.sun.tdk.jcov.instrument.plugin.FieldsPlugin.INSTRUMENTATION_COMPLETE;\n+import static java.lang.Integer.parseInt;\n+import static java.util.stream.Collectors.joining;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * Tests that it is possible to use instrumentation plugin and a corresponding data saver.\n+ *\/\n+public class FieldsTest {\n+    Path test_dir;\n+    InstrProxy instr;\n+\n+    \/**\n+     * Perform the instrumentation.\n+     *\/\n+    @Test\n+    public void instrument() throws IOException, InterruptedException {\n+        test_dir = Paths.get(System.getProperty(\"user.dir\")).resolve(\"plugin_test\");\n+        instr = new InstrProxy(test_dir);\n+        instr.copyBytecode(FieldsClass.class.getName());\n+        System.getProperties().setProperty(\"jcov.selftest\", \"true\");\n+        int[] instrumentationCompleteTimes = new int[1];\n+        instr.instr(new String[]{\"-instr_plugin\", FieldsPlugin.class.getName()},\n+                line -> {\n+                    if(line.startsWith(INSTRUMENTATION_COMPLETE))\n+                        instrumentationCompleteTimes[0] =\n+                                parseInt(line.substring(INSTRUMENTATION_COMPLETE.length()));\n+                }, null,\n+                FieldsClass.class.getName());\n+        assertEquals(instrumentationCompleteTimes[0], 1);\n+        \/\/this does not work because\n+        \/\/Warning: Add input source(s) to the classpath: -cp jcov.jar:...\n+        \/\/see InstrProxy class for more info\n+        \/\/assertEquals(FieldsPlugin.completeCount.intValue(), 1);\n+    }\n+\n+    \/**\n+     * Check collected field values at runtime in the same VM.\n+     *\/\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void fields() throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        instr.runClass(FieldsClass.class.getName(), new String[0]);\n+        testFieldValuesSameVM(\"field1\", Set.of(1, 2));\n+        testFieldValuesSameVM(\"field2\", Set.of(\"\", \"two\", \"one\"));\n+    }\n+    private void testFieldValuesSameVM(String field, Set<Object> values) {\n+        String fullName = FieldsClass.class.getName().replace('.','\/') + \".\" + field;\n+        testFieldValues(fullName, field, values, FieldsPlugin.values.get(fullName));\n+    }\n+\n+    \/**\n+     * Test that data saver is called.\n+     *\/\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void testSaver() throws IOException, InterruptedException {\n+        List<String> command = new ArrayList<>();\n+        command.add(System.getProperty(\"java.home\") + \"\/bin\/java\");\n+        command.add(\"-Djcov.data-saver=\"+FieldsPlugin.class.getName());\n+        command.add(\"-cp\");\n+        command.add(test_dir\n+                + File.pathSeparator + System.getProperty(\"java.class.path\"));\n+        command.add(FieldsClass.class.getName());\n+        System.out.println(command.stream().collect(joining(\" \")));\n+        Process p = new ProcessBuilder().command(command.toArray(new String[0]))\n+                .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                .start();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            List<String> lines = in.lines().collect(Collectors.toList());\n+            testFieldValuesOtherVM(\"field1\", Set.of(1, 2), lines);\n+            testFieldValuesOtherVM(\"field2\", Set.of(\"\", \"two\", \"one\"), lines);\n+        }\n+        assertEquals(p.waitFor(), 0);\n+    }\n+    private void testFieldValuesOtherVM(String field, Set<Object> values, List<String> lines) {\n+        String fullName = FieldsClass.class.getName().replace('.','\/') + \".\" + field;\n+        testFieldValues(fullName, field,\n+                values.stream().map(Object::toString).collect(Collectors.toSet()),\n+                lines.stream().filter(l -> l.startsWith(fullName + \"=\"))\n+                        .map(l -> l.substring(fullName.length() + 1))\n+                        .collect(Collectors.toSet()));\n+    }\n+    private void testFieldValues(String fullName, String field, Set<Object> values, Set<Object> actual) {\n+        if(values.size() == 0) {\n+            assertFalse(FieldsPlugin.values.containsKey(fullName), \"No values for field \" + fullName);\n+        } else {\n+            assertNotNull(actual);\n+            System.out.printf(\"Comparing [%s] with [%s]\\n\",\n+                    values.stream().map(Object::toString).collect(joining(\",\")),\n+                    actual.stream().map(Object::toString).collect(joining(\",\")));\n+            assertEquals(values.size(), actual.size(), \"size\");\n+            assertTrue(values.stream().allMatch(actual::contains), \"content is the same\");\n+        }\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/FieldsTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin;\n+\n+import com.sun.tdk.jcov.JREInstr;\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.runtime.Collect;\n+import org.objectweb.asm.MethodVisitor;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class JREInstrTest {\n+\n+    public static final String TIMES_SAVED = \"TIMES SAVED \";\n+    public static final String TIMES_CALLED = \"TIMES CALLED \";\n+\n+    Path rtJar;\n+    Path jre;\n+\n+    private Path copyJRE(Path src) throws IOException {\n+        Path dest = Files.createTempDirectory(\"JDK\");\n+        Files.walk(src).forEach(s -> {\n+            try {\n+                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        return dest;\n+    }\n+\n+    private void removeJRE(Path jre) throws IOException {\n+        Files.walkFileTree(jre, new FileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    private Path createJCovRtJar() throws IOException {\n+        Path dest = Files.createTempFile(\"jcov-rt-\", \".jar\");\n+        System.out.println(\"rt jar: \" + dest);\n+        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n+            jar.putNextEntry(new JarEntry(Collect.class.getName().replace(\".\", File.separator) + \".class\"));\n+        }\n+        return dest;\n+    }\n+\n+    @BeforeClass\n+    public void setup() throws IOException {\n+        String testJRE = System.getProperty(\"test.jre\");\n+        if(testJRE == null) {\n+            testJRE = System.getProperty(\"java.home\");\n+        }\n+        rtJar = createJCovRtJar();\n+        jre = copyJRE(Paths.get(testJRE));\n+    }\n+\n+    @Test\n+    public void testJREInstr() throws IOException, InterruptedException {\n+        VoidPlugin.reset();\n+        String[] params = new String[] {\n+                \"-implantrt\", rtJar.toString(),\n+                \"-instr_plugin\", VoidPlugin.class.getName(), jre.toString()};\n+        System.out.println(params);\n+        new JREInstr().run(params);\n+        assertEquals(VoidPlugin.savedTimes.intValue(), 1);\n+        assertTrue(VoidPlugin.calledTimes.get() > 0);\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(jre != null && Files.exists(jre)) removeJRE(jre);\n+        if(rtJar != null && Files.exists(rtJar)) Files.delete(rtJar);\n+    }\n+\n+    public static class VoidPlugin implements InstrumentationPlugin {\n+\n+        public static AtomicInteger calledTimes = new AtomicInteger(0);\n+        public static AtomicInteger savedTimes = new AtomicInteger(0);\n+\n+        public static void reset() {\n+            calledTimes.set(0);\n+            savedTimes.set(0);\n+        }\n+\n+        @Override\n+        public MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor) {\n+            calledTimes.incrementAndGet();\n+            return null;\n+        }\n+\n+        @Override\n+        public void instrumentationComplete() throws Exception {\n+            savedTimes.incrementAndGet();\n+        }\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/JREInstrTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.lib;\n+\n+import com.sun.tdk.jcov.Instr;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.MalformedURLException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static java.io.File.pathSeparator;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+public class InstrProxy {\n+    private final Path outputDir;\n+\n+    public InstrProxy(Path outputDir) {\n+        this.outputDir = outputDir;\n+    }\n+\n+    public void copyBytecode(String... classes) throws IOException {\n+        byte[] buf = new byte[1024];\n+        for(String c : classes) {\n+            String classFile = classFile(c);\n+            try(InputStream in = InstrProxy.class.getClassLoader().getResourceAsStream(classFile)) {\n+                Path o = outputDir.resolve(classFile);\n+                if(!Files.exists(o.getParent())) Files.createDirectories(o.getParent());\n+                try(OutputStream out = Files.newOutputStream(o)) {\n+                    int read;\n+                    while((read = in.read(buf)) > 0)\n+                        out.write(buf, 0, read);\n+                }\n+            }\n+        };\n+    }\n+\n+    public int instr(String[] options, Consumer<String> outConsumer, Consumer<String> errConsumer, String... classes) throws IOException, InterruptedException {\n+        if(!Files.exists(outputDir) || !Files.isDirectory(outputDir)) {\n+            Files.createDirectories(outputDir);\n+        }\n+        \/\/this does not work because\n+        \/\/Warning: Add input source(s) to the classpath: -cp jcov.jar:...\n+\/\/        List<String> params = new ArrayList<>();\n+\/\/        params.addAll(List.of(options));\n+\/\/        params.addAll(Arrays.stream(classes).map(c -> outputDir.resolve(classFile(c)).toString()).collect(toList()));\n+\/\/        System.out.println(params.stream().collect(Collectors.joining(\" \")));\n+\/\/        new Instr().run(params.toArray(new String[0]));\n+        List<String> files = Arrays.stream(classes).map(this::classFile)\n+                .map(outputDir::resolve)\n+                .map(Path::toString)\n+                .collect(toList());\n+        List<String> command = new ArrayList<>();\n+        command.add(System.getProperty(\"java.home\") + \"\/bin\/java\");\n+        command.add(\"-Djcov.selftest=true\");\n+        command.add(\"-cp\");\n+        command.add(System.getProperty(\"java.class.path\") +\n+                        pathSeparator + files.stream()\n+                        .collect(joining(pathSeparator)));\n+        command.add(Instr.class.getName());\n+        command.addAll(Arrays.asList(options));\n+        command.addAll(files);\n+        System.out.println(command.stream().collect(joining(\" \")));\n+        ProcessBuilder pb = new ProcessBuilder().command(command.toArray(new String[0]));\n+        if(outConsumer == null)\n+            pb = pb.redirectOutput(ProcessBuilder.Redirect.INHERIT);\n+        if(errConsumer == null)\n+            pb = pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        Process p = pb.start();\n+        if(outConsumer != null) {\n+            try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+                String line;\n+                while((line = in.readLine()) != null)\n+                    outConsumer.accept(line);\n+            }\n+        }\n+        if(errConsumer != null) {\n+            try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getErrorStream()))) {\n+                String line;\n+                while((line = in.readLine()) != null)\n+                    errConsumer.accept(line);\n+            }\n+        }\n+        return p.waitFor();\n+    }\n+\n+    public String classFile(String className) {\n+        return className.replace('.', '\/') + \".class\";\n+    }\n+\n+    public Class runClass(String className, String[] argv)\n+            throws ClassNotFoundException, NoSuchMethodException,\n+            InvocationTargetException, IllegalAccessException {\n+        ClassLoader offOutputDir = new InstrumentedClassLoader();\n+        Class cls = offOutputDir.loadClass(className);\n+        Method m = cls.getMethod(\"main\", new String[0].getClass());\n+        m.invoke(null, (Object)argv);\n+        return cls;\n+    }\n+\n+    private class InstrumentedClassLoader extends ClassLoader {\n+        protected InstrumentedClassLoader() {\n+            super(InstrProxy.class.getClassLoader());\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            Path classFile = outputDir.resolve(classFile(name));\n+            if(Files.exists(classFile)) {\n+                byte[] buf = new byte[1024];\n+                try(InputStream in = Files.newInputStream(classFile)) {\n+                    try(ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                        int read;\n+                        while((read = in.read(buf)) > 0)\n+                            out.write(buf, 0, read);\n+                        return defineClass(name, out.toByteArray(), 0, out.size());\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return super.loadClass(name);\n+        }\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/lib\/InstrProxy.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"}]}