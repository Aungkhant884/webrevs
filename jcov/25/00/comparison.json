{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.InstrumentationPlugin;\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/instrument\/Plugin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import com.sun.tdk.jcov.instrument.asm.InstrumentationPlugin;\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/VoidPlugin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+\n@@ -31,3 +32,0 @@\n-import java.util.Set;\n-import java.util.Map;\n-import java.util.IdentityHashMap;\n@@ -35,1 +33,2 @@\n-\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n@@ -37,1 +36,1 @@\n-import org.objectweb.asm.tree.LabelNode;\n+import java.util.Set;\n@@ -56,1 +55,1 @@\n-    public final Map<DataBlock, LabelNode> blockMap;\n+    private final Set<DataBlock> blocks;\n@@ -64,1 +63,1 @@\n-        blockMap = new IdentityHashMap<DataBlock, LabelNode>();\n+        blocks = Collections.newSetFromMap(new IdentityHashMap<>());\n@@ -72,1 +71,1 @@\n-        blockMap = new IdentityHashMap<DataBlock, LabelNode>();\n+        blocks = Collections.newSetFromMap(new IdentityHashMap<>());\n@@ -79,2 +78,2 @@\n-    public void add(DataBlock blk, LabelNode label) {\n-        blockMap.put(blk, label);\n+    public void add(DataBlock blk) {\n+        blocks.add(blk);\n@@ -87,8 +86,0 @@\n-    public void add(DataBlock blk) {\n-        add(blk, null);\n-    }\n-\n-    public LabelNode getLabel(DataBlock blk) {\n-        return blockMap.get(blk);\n-    }\n-\n@@ -96,1 +87,1 @@\n-        return blockMap.containsKey(blk);\n+        return blocks.contains(blk);\n@@ -108,5 +99,1 @@\n-        return blockMap.keySet();\n-    }\n-\n-    public Set<Map.Entry<DataBlock, LabelNode>> blockLabelSet() {\n-        return blockMap.entrySet();\n+        return blocks;\n@@ -133,2 +120,2 @@\n-        if (ctx.showNonNested && blockMap != null) {\/\/BRANCH only\n-            for (DataBlock block : blockMap.keySet()) {\n+        if (ctx.showNonNested && blocks != null) {\/\/BRANCH only\n+            for (DataBlock block : blocks) {\n@@ -146,1 +133,1 @@\n-        if (blockMap.keySet().size() != other.blocks().size()) {\n+        if (blocks.size() != other.blocks().size()) {\n@@ -148,1 +135,1 @@\n-                    + \"it's merging copy, expected \" + blockMap.keySet().size() + \"; found \" + other.blocks().size(),\n+                    + \"it's merging copy, expected \" + blocks.size() + \"; found \" + other.blocks().size(),\n@@ -163,1 +150,1 @@\n-                        + \"it's merging copy, expected \" + blockMap.keySet().size() + \"; found \" + other.blocks().size(),\n+                        + \"it's merging copy, expected \" + blocks.size() + \"; found \" + other.blocks().size(),\n@@ -172,1 +159,1 @@\n-        mergeDataBlocks(blockMap.keySet(), other.blocks(), dynamicCollected);\n+        mergeDataBlocks(blocks, other.blocks(), dynamicCollected);\n@@ -215,1 +202,1 @@\n-                    return blockMap.keySet().iterator();\n+                    return blocks.iterator();\n@@ -279,1 +266,1 @@\n-        blockMap = new IdentityHashMap<DataBlock, LabelNode>(blockNum);\n+        blocks = Collections.newSetFromMap(new IdentityHashMap<>());\n@@ -285,1 +272,1 @@\n-                    blockMap.put(new DataBlockCatch(rootId, in), null);\n+                    blocks.add(new DataBlockCatch(rootId, in));\n@@ -288,1 +275,1 @@\n-                    blockMap.put(new DataBlockFallThrough(rootId, in), null);\n+                    blocks.add(new DataBlockFallThrough(rootId, in));\n@@ -291,1 +278,1 @@\n-                    blockMap.put(new DataBlockMethEnter(rootId, in), null);\n+                    blocks.add(new DataBlockMethEnter(rootId, in));\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/BasicBlock.java","additions":22,"deletions":35,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1357,1 +1357,1 @@\n-                            for (DataBlock db : bb.blockMap.keySet()) {\n+                            for (DataBlock db : bb.blocks()) {\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/DataRoot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private final Map<DataBlock, LabelNode> blockLabels;\n@@ -77,0 +78,1 @@\n+        blockLabels = new IdentityHashMap<>();\n@@ -183,1 +185,2 @@\n-                        bbTrue.add(blockTrue, nlab);\n+                        bbTrue.add(blockTrue);\n+                        blockLabels.put(blockTrue, nlab);\n@@ -200,1 +203,2 @@\n-                        bbDefault.add(blockDefault, nlab);\n+                        bbDefault.add(blockDefault);\n+                        blockLabels.put(blockDefault, nlab);\n@@ -221,1 +225,2 @@\n-                            bbCase.add(blockCase, nlab);\n+                            bbCase.add(blockCase);\n+                            blockLabels.put(blockCase, nlab);\n@@ -237,1 +242,2 @@\n-                        bbDefault.add(blockDefault, nlab);\n+                        bbDefault.add(blockDefault);\n+                        blockLabels.put(blockDefault, nlab);\n@@ -259,1 +265,2 @@\n-                            bbCase.add(blockCase, nlab);\n+                            bbCase.add(blockCase);\n+                            blockLabels.put(blockCase, nlab);\n@@ -281,1 +288,2 @@\n-                        bbTarget.add(blockTarget, nlab);\n+                        bbTarget.add(blockTarget);\n+                        blockLabels.put(blockTarget, nlab);\n@@ -326,1 +334,2 @@\n-                bbCatch.add(blockCatch, nlab);\n+                bbCatch.add(blockCatch);\n+                blockLabels.put(blockCatch, nlab);\n@@ -453,2 +462,2 @@\n-            Set<Map.Entry<DataBlock, LabelNode>> pairs = bb.blockLabelSet();\n-            int remaining = pairs.size();\n+            Collection<DataBlock> blocks = bb.blocks();\n+            int remaining = blocks.size();\n@@ -465,1 +474,1 @@\n-                assert (bb.getLabel(fallenInto) == null);\n+                assert (blockLabels.get(fallenInto) == null);\n@@ -474,2 +483,1 @@\n-            for (Map.Entry<DataBlock, LabelNode> pair : pairs) {\n-                DataBlock block = pair.getKey();\n+            for (DataBlock block : blocks) {\n@@ -478,1 +486,1 @@\n-                    LabelNode lnode = pair.getValue();\n+                    LabelNode lnode = blockLabels.get(block);\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/asm\/BranchCodeMethodAdapter.java","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+\n+public class Util {\n+    private final Path outputDir;\n+\n+    public Util(Path dir) {\n+        outputDir = dir;\n+    }\n+\n+    public List<Path> copyBytecode(String... classes) throws IOException {\n+        byte[] buf = new byte[1024];\n+        List<Path> result = new ArrayList<>();\n+        for(String c : classes) {\n+            String classFile = classFile(c);\n+            try(InputStream in = getClass().getClassLoader().getResourceAsStream(classFile)) {\n+                Path o = outputDir.resolve(classFile);\n+                result.add(o);\n+                if(!Files.exists(o.getParent())) Files.createDirectories(o.getParent());\n+                try(OutputStream out = Files.newOutputStream(o)) {\n+                    int read;\n+                    while((read = in.read(buf)) > 0)\n+                        out.write(buf, 0, read);\n+                }\n+            }\n+        };\n+        return result;\n+    }\n+\n+    public static Path copyJRE(Path src) throws IOException {\n+        Path dest = Files.createTempDirectory(\"JDK\");\n+        System.out.println(\"Copying a JDK from \" + src + \" to \" + dest);\n+        Files.walk(src).forEach(s -> {\n+            try {\n+                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        return dest;\n+    }\n+\n+    public static Path createRtJar(String prefix, Class collect) throws IOException {\n+        Path dest = Files.createTempFile(prefix, \".jar\");\n+        System.out.println(prefix + \" jar: \" + dest);\n+        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n+            jar.putNextEntry(new JarEntry(collect.getName().replace(\".\", File.separator) + \".class\"));\n+            try (InputStream ci = collect.getClassLoader()\n+                    .getResourceAsStream(collect.getName().replace('.', '\/') + \".class\")) {\n+                byte[] buffer = new byte[1024];\n+                int read;\n+                while((read = ci.read(buffer)) > 0) {\n+                    jar.write(buffer, 0, read);\n+                }\n+            }\n+        }\n+        return dest;\n+    }\n+\n+    public static String classFile(String className) {\n+        return className.replace('.', '\/') + \".class\";\n+    }\n+    public Class runClass(Class className, String[] argv)\n+            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+        return runClass(className.getName(), argv);\n+    }\n+    public Class runClass(String className, String[] argv)\n+            throws ClassNotFoundException, NoSuchMethodException,\n+            InvocationTargetException, IllegalAccessException, InstantiationException {\n+        ClassLoader offOutputDir = new InstrumentedClassLoader();\n+        Class cls = offOutputDir.loadClass(className);\n+        Method m = cls.getMethod(\"main\", new String[0].getClass());\n+        m.invoke(null, (Object)argv);\n+        return cls;\n+    }\n+\n+    private class InstrumentedClassLoader extends ClassLoader {\n+        protected InstrumentedClassLoader() {\n+            super(Util.class.getClassLoader());\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name) throws ClassNotFoundException {\n+            Path classFile = outputDir.resolve(classFile(name));\n+            if(Files.exists(classFile)) {\n+                byte[] buf = new byte[1024];\n+                try(InputStream in = Files.newInputStream(classFile)) {\n+                    try(ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+                        int read;\n+                        while((read = in.read(buf)) > 0)\n+                            out.write(buf, 0, read);\n+                        return defineClass(name, out.toByteArray(), 0, out.size());\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return super.loadClass(name);\n+        }\n+    }\n+    public static void rmRF(Path jre) throws IOException {\n+        System.out.println(\"Removing \" + jre);\n+        if(Files.isRegularFile(jre))\n+            Files.deleteIfExists(jre);\n+        else\n+            Files.walkFileTree(jre, new FileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                    Files.delete(file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                    Files.delete(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/Util.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.instr;\n+\n+import com.sun.tdk.jcov.Instr;\n+import com.sun.tdk.jcov.data.FileFormatException;\n+import com.sun.tdk.jcov.instrument.DataMethod;\n+import com.sun.tdk.jcov.instrument.DataRoot;\n+import com.sun.tdk.jcov.instrument.Util;\n+import com.sun.tdk.jcov.io.Reader;\n+import com.sun.tdk.jcov.runtime.Collect;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class InstrTest {\n+    Path test_dir;\n+    Path template;\n+    int method_slot = -1;\n+    @BeforeClass\n+    public void clean() throws IOException {\n+        System.setProperty(\"jcov.selftest\", \"true\");\n+        Path data_dir = Paths.get(System.getProperty(\"user.dir\"));\n+        test_dir = data_dir.resolve(\"instr_test\");\n+        System.out.println(\"test dir = \" + test_dir);\n+        Util.rmRF(test_dir);\n+        template = test_dir.resolve(\"template.lst\");\n+    }\n+    @Test\n+    public void instrument() throws IOException, InterruptedException, FileFormatException {\n+        List<String> params = new ArrayList<>();\n+        params.add(\"-t\");\n+        params.add(template.toString());\n+        params.add(new Util(test_dir).copyBytecode(UserCode.class.getName()).get(0).toString());\n+        new Instr().run(params.toArray(new String[0]));\n+        DataRoot data = Reader.readXML(template.toString());\n+        DataMethod dm =\n+                data.getPackages().stream().filter(p -> p.getName().equals(\"com\/sun\/tdk\/jcov\/instrument\/instr\")).findAny().get()\n+                .getClasses().stream().filter(c -> c.getName().equals(\"UserCode\")).findAny().get()\n+                .getMethods().stream().filter(m -> m.getName().equals(\"main\")).findAny().get();\n+        method_slot = dm.getSlot();\n+        assertTrue(method_slot > 0);\n+    }\n+\n+    @Test(dependsOnMethods = \"instrument\")\n+    public void run() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n+            IllegalAccessException, IOException, InstantiationException {\n+        new Util(test_dir).runClass(UserCode.class, new String[] {\"+\"});\n+        assertTrue(Collect.wasHit(method_slot));\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        Util.rmRF(test_dir);\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/instr\/InstrTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.instr;\n+\n+public class UserCode {\n+    private static int count = 0;\n+    public static void main(String[] args) {\n+        if(args[0].equals(\"-\")) count--;\n+        else if(args[0].equals(\"+\")) count++;\n+        System.out.println(\"User code is running.\");\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/instr\/UserCode.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-import java.util.Random;\n+import javax.swing.JFrame;\n@@ -31,1 +31,1 @@\n-        new Random().nextInt();\n+        new JFrame();\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/jreinstr\/Code.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import com.sun.tdk.jcov.instrument.Util;\n@@ -42,3 +43,0 @@\n-import java.io.UncheckedIOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.FileVisitor;\n@@ -48,2 +46,0 @@\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.attribute.BasicFileAttributes;\n@@ -62,37 +58,0 @@\n-    private Path copyJRE(Path src) throws IOException, InterruptedException {\n-        Path dest = Files.createTempDirectory(\"JDK\");\n-        System.out.println(\"Copying \" + src + \" to \" + dest);\n-        Files.walk(src).forEach(s -> {\n-            try {\n-                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        });\n-        return dest;\n-    }\n-\n-    private void rmRF(Path jre) throws IOException {\n-        System.out.println(\"Removing \" + jre);\n-        Files.walkFileTree(jre, new FileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override\n-            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                Files.delete(file);\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override\n-            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override\n-            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n-                Files.delete(dir);\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n-    }\n-\n@@ -119,1 +78,1 @@\n-        jre = copyJRE(Paths.get(testJRE));\n+        jre = Util.copyJRE(Paths.get(testJRE));\n@@ -156,2 +115,2 @@\n-        DataPackage pkg = data.getPackages().stream().filter(p -> p.getName().equals(\"java\/util\")).findAny().get();\n-        DataClass cls = pkg.getClasses().stream().filter(c -> c.getName().equals(\"Random\"))\n+        DataPackage pkg = data.getPackages().stream().filter(p -> p.getName().equals(\"javax\/swing\")).findAny().get();\n+        DataClass cls = pkg.getClasses().stream().filter(c -> c.getName().equals(\"JFrame\"))\n@@ -160,1 +119,1 @@\n-                m.getName().equals(\"nextInt\") && m.getVmSignature().equals(\"()I\")\n+                m.getName().equals(\"<init>\") && m.getVmSignature().equals(\"()V\")\n@@ -162,1 +121,1 @@\n-        assertTrue(method.getCount() >= 1);\n+        assertEquals(method.getCount(), 1);\n@@ -166,2 +125,2 @@\n-        if(jre != null && Files.exists(jre)) rmRF(jre);\n-        if(userCode != null && Files.exists(userCode)) rmRF(userCode);\n+        if(jre != null && Files.exists(jre)) Util.rmRF(jre);\n+        if(userCode != null && Files.exists(userCode)) Util.rmRF(userCode);\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/jreinstr\/JREInstrTest.java","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"}]}