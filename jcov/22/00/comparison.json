{"files":[{"patch":"@@ -20,0 +20,1 @@\n+import java.util.Arrays;\n@@ -54,0 +55,3 @@\n+        String runtime = Arrays.stream(System.getProperty(\"java.class.path\").split(File.pathSeparator))\n+                .peek(System.out::println)\n+                .filter(s -> s.endsWith(\"jcov_file_saver.jar\")).findAny().get();\n@@ -61,1 +65,1 @@\n-                .jcovRuntime(System.getProperty(\"jcov.file.saver.jar\"))\n+                .jcovRuntime(runtime)\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Test.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tdk.jcov.instrument.ASMUtils;\n@@ -37,0 +38,2 @@\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n@@ -38,0 +41,1 @@\n+import java.io.UncheckedIOException;\n@@ -40,0 +44,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -94,0 +100,2 @@\n+    boolean fixJavaBase = false;\n+\n@@ -176,0 +184,21 @@\n+            if(fixJavaBase && \"java.base\".equals(moduleName)) {\n+                File moduleInfo = new File(file + File.separator +  \"module-info.class\");\n+                if(!moduleInfo.exists()) throw new IllegalStateException(moduleInfo + \" does not exist!\");\n+                try(FileInputStream fi = new FileInputStream(moduleInfo)) {\n+                    byte[] noHashes = morph.clearHashes(fi.readAllBytes(), cl);\n+                    List<String> packages = new ArrayList<>();\n+                    packages.add(\"com\/sun\/tdk\/jcov\/runtime\");\n+                    if(plugin != null) {\n+                        String pluginRuntimePackage = plugin.collectorPackage();\n+                        if (pluginRuntimePackage != null) {\n+                            pluginRuntimePackage = pluginRuntimePackage.replace('.', '\/');\n+                            packages.add(pluginRuntimePackage);\n+                        }\n+                    }\n+                    byte[] withExports = morph.addExports(noHashes, packages, cl);\n+                    try (FileOutputStream fo = new FileOutputStream(((outDir == null) ? file : outDir) +\n+                            File.separator +  \"module-info.class\")) {\n+                        fo.write(withExports);\n+                    }\n+                }\n+            }\n@@ -296,1 +325,0 @@\n-\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+        instr.fixJavaBase = true;\n+\n@@ -135,5 +137,0 @@\n-                        if (\"java.base\".equals(mod.getName())) {\n-                            File mInfo = new File(modClasses, \"module-info.class\");\n-                            addJCovRuntimeToJavaBase(mInfo, cl);\n-                            updateHashes(mInfo, cl);\n-                        }\n@@ -146,1 +143,0 @@\n-\n@@ -180,59 +176,60 @@\n-            ArrayList<File> jdkImages = new ArrayList<>();\n-            jdkImages.add(toInstrument);\n-            if (addJimages != null) {\n-                Collections.addAll(jdkImages, addJimages);\n-            }\n-\n-            for (File jimageInstr : jdkImages) {\n-                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n-\n-                expandJimage(jimageInstr, tempDirName);\n-\n-                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n-                \/\/still need it\n-                Utils.addToClasspath(new String[]{dirtoInstrument.getAbsolutePath()});\n-                for (File file : getListFiles(dirtoInstrument)) {\n-                    if (file.isDirectory()) {\n-                        Utils.addToClasspath(new String[]{file.getAbsolutePath()});\n-                    }\n-                }\n-\n-                if (jimageInstr.equals(toInstrument)) {\n-                    for (File mod : getListFiles(dirtoInstrument)) {\n-                        if (mod != null && mod.isDirectory()) {\n-\n-                            if (\"java.base\".equals(mod.getName())) {\n-                                instr.instrumentFile(mod.getAbsolutePath(), null, implant.getAbsolutePath(), mod.getName());\n-                            } else {\n-                                instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    for (File mod : getListFiles(dirtoInstrument)) {\n-                        if (mod != null && mod.isDirectory()) {\n-                            instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n-                        }\n-                    }\n-                }\n-                createJimage(dirtoInstrument, jimageInstr.getAbsolutePath() + \"i\");\n-\n-            }\n-            for (File jimageInstr : jdkImages) {\n-\n-                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n-                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n-                if (!Utils.deleteDirectory(dirtoInstrument)) {\n-                    logger.log(Level.SEVERE, \"please, delete \" + tempDirName + \" jimage dir manually\");\n-                }\n-\n-                Utils.copyFile(jimageInstr, new File(jimageInstr.getParent(), jimageInstr.getName() + \".bak\"));\n-\n-                if (!jimageInstr.delete()) {\n-                    logger.log(Level.SEVERE, \"please, delete original jimage manually: \" + jimageInstr);\n-                } else {\n-                    Utils.copyFile(new File(jimageInstr.getAbsolutePath() + \"i\"), jimageInstr);\n-                    new File(jimageInstr.getAbsolutePath() + \"i\").delete();\n-                }\n-\n-            }\n+            throw new RuntimeException(\"This functionality has not yet been implemented\");\n+\/\/            ArrayList<File> jdkImages = new ArrayList<>();\n+\/\/            jdkImages.add(toInstrument);\n+\/\/            if (addJimages != null) {\n+\/\/                Collections.addAll(jdkImages, addJimages);\n+\/\/            }\n+\/\/\n+\/\/            for (File jimageInstr : jdkImages) {\n+\/\/                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n+\/\/\n+\/\/                expandJimage(jimageInstr, tempDirName);\n+\/\/\n+\/\/                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n+\/\/\/\/                still need it\n+\/\/                Utils.addToClasspath(new String[]{dirtoInstrument.getAbsolutePath()});\n+\/\/                for (File file : getListFiles(dirtoInstrument)) {\n+\/\/                    if (file.isDirectory()) {\n+\/\/                        Utils.addToClasspath(new String[]{file.getAbsolutePath()});\n+\/\/                    }\n+\/\/                }\n+\/\/\n+\/\/                if (jimageInstr.equals(toInstrument)) {\n+\/\/                    for (File mod : getListFiles(dirtoInstrument)) {\n+\/\/                        if (mod != null && mod.isDirectory()) {\n+\/\/\n+\/\/                            if (\"java.base\".equals(mod.getName())) {\n+\/\/                                instr.instrumentFile(mod.getAbsolutePath(), null, implant.getAbsolutePath(), mod.getName());\n+\/\/                            } else {\n+\/\/                                instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n+\/\/                            }\n+\/\/                        }\n+\/\/                    }\n+\/\/                } else {\n+\/\/                    for (File mod : getListFiles(dirtoInstrument)) {\n+\/\/                        if (mod != null && mod.isDirectory()) {\n+\/\/                            instr.instrumentFile(mod.getAbsolutePath(), null, null, mod.getName());\n+\/\/                        }\n+\/\/                    }\n+\/\/                }\n+\/\/                createJimage(dirtoInstrument, jimageInstr.getAbsolutePath() + \"i\");\n+\n+\/\/            }\n+\/\/            for (File jimageInstr : jdkImages) {\n+\/\/\n+\/\/                String tempDirName = jimageInstr.getName().substring(0, jimageInstr.getName().indexOf(\".jimage\"));\n+\/\/                File dirtoInstrument = new File(jimageInstr.getParent(), tempDirName);\n+\/\/                if (!Utils.deleteDirectory(dirtoInstrument)) {\n+\/\/                    logger.log(Level.SEVERE, \"please, delete \" + tempDirName + \" jimage dir manually\");\n+\/\/                }\n+\/\/\n+\/\/                Utils.copyFile(jimageInstr, new File(jimageInstr.getParent(), jimageInstr.getName() + \".bak\"));\n+\/\/\n+\/\/                if (!jimageInstr.delete()) {\n+\/\/                    logger.log(Level.SEVERE, \"please, delete original jimage manually: \" + jimageInstr);\n+\/\/                } else {\n+\/\/                    Utils.copyFile(new File(jimageInstr.getAbsolutePath() + \"i\"), jimageInstr);\n+\/\/                    new File(jimageInstr.getAbsolutePath() + \"i\").delete();\n+\/\/                }\n+\/\/\n+\/\/            }\n@@ -241,1 +238,2 @@\n-            instr.instrumentFile(toInstrument.getAbsolutePath(), null, implant.getAbsolutePath());\n+            throw new RuntimeException(\"This functionality has not yet been implemented\");\n+\/\/            instr.instrumentFile(toInstrument.getAbsolutePath(), null, implant.getAbsolutePath());\n@@ -266,2 +264,0 @@\n-        return SUCCESS_EXIT_CODE;\n-    }\n@@ -269,63 +265,1 @@\n-    \/**\n-     * Add com\/sun\/tdk\/jcov\/runtime to the module exports to be visible externally\n-     *\n-     * @param file  module-info.class file of java.base\n-     * @param cl    class loader\n-     *\/\n-    private void addJCovRuntimeToJavaBase(File file, ClassLoader cl) {\n-        try {\n-            updateModuleInfoFile(file, cl, classWriter ->\n-                    new ClassVisitor(ASMUtils.ASM_API_VERSION, classWriter) {\n-                        @Override\n-                        public ModuleVisitor visitModule(String name, int access, String version) {\n-                            ModuleVisitor mv = super.visitModule(name, access, version);\n-                            mv.visitPackage(\"com\/sun\/tdk\/jcov\/runtime\");\n-                            mv.visitExport(\"com\/sun\/tdk\/jcov\/runtime\", 0);\n-                            if(instr.getPlugin() != null) {\n-                                String pluginRuntimePackage = instr.getPlugin().collectorPackage();\n-                                if(pluginRuntimePackage != null) {\n-                                    pluginRuntimePackage = pluginRuntimePackage.replace('.', '\/');\n-                                    mv.visitPackage(pluginRuntimePackage);\n-                                    mv.visitExport(pluginRuntimePackage, 0);\n-                                }\n-                            }\n-                            return mv;\n-                        }\n-                    });\n-        } catch (Exception ex) {\n-            logger.log(Level.SEVERE, \"Can't update java.base\/module-info\", ex);\n-        }\n-    }\n-\n-    \/**\n-     * Remove ModuleHashes attribute to skip a check that there are no qualified exports to upgradeable modules\n-     *\n-     * @param file  module-info.class file of java.base\n-     * @param cl    class loader\n-     *\/\n-    private void updateHashes(File file, ClassLoader cl) {\n-        try {\n-            updateModuleInfoFile(file, cl, classWriter ->\n-                    new ClassVisitor(ASMUtils.ASM_API_VERSION, classWriter) {\n-                        @Override\n-                        public void visitAttribute(final Attribute attribute) {\n-                            if (!attribute.type.equals(\"ModuleHashes\")) {\n-                                super.visitAttribute(attribute);\n-                            }\n-                        }\n-                    });\n-        } catch (Exception ex) {\n-            logger.log(Level.SEVERE, \"Can't remove module hashes from java.base\/module-info\", ex);\n-        }\n-    }\n-\n-    private void updateModuleInfoFile(File file, ClassLoader cl, Function<ClassWriter, ClassVisitor> func) throws Exception {\n-        try( InputStream inputStream = new FileInputStream(file.getCanonicalPath()) ) {\n-            ClassReader cr = new ClassReader(inputStream);\n-            ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, cl);\n-            cr.accept(func.apply(cw), 0);\n-            try(DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(file.getCanonicalPath())) ) {\n-                outputStream.write(cw.toByteArray());\n-                outputStream.flush();\n-            }\n-        }\n+        return SUCCESS_EXIT_CODE;\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/JREInstr.java","additions":65,"deletions":131,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -55,0 +55,4 @@\n+ * The class is resposible to deal with class files and hierarchies of files, such as directories, jars, zips, modules.\n+ * The actual logic of bytecode instrumentation is left for subclasses of this class.\n+ * @see #instrument(byte[], int)\n+ * @see #finishWork()\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/insert\/AbstractUniversalInstrumenter.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/ASMUtils.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,8 @@\n+import org.objectweb.asm.Attribute;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.ModuleVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.util.TraceClassVisitor;\n+\n@@ -38,0 +46,1 @@\n+import java.util.List;\n@@ -42,5 +51,0 @@\n-import org.objectweb.asm.Attribute;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.util.TraceClassVisitor;\n@@ -281,0 +285,31 @@\n+    public byte[] clearHashes(byte[] moduleInfo, ClassLoader loader) {\n+        ClassReader cr = new ClassReader(moduleInfo);\n+        ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, loader);\n+        cr.accept( new ClassVisitor(ASMUtils.ASM_API_VERSION, cw) {\n+            @Override\n+            public void visitAttribute(final Attribute attribute) {\n+                if (!attribute.type.equals(\"ModuleHashes\")) {\n+                    super.visitAttribute(attribute);\n+                }\n+            }\n+        }, 0);\n+        return cw.toByteArray();\n+    }\n+\n+    public byte[] addExports(byte[] moduleInfo, List<String> exports, ClassLoader loader) {\n+        ClassReader cr = new ClassReader(moduleInfo);\n+        ClassWriter cw = new OverriddenClassWriter(cr, ClassWriter.COMPUTE_FRAMES, loader);\n+        cr.accept( new ClassVisitor(ASMUtils.ASM_API_VERSION, cw) {\n+            @Override\n+            public ModuleVisitor visitModule(String name, int access, String version) {\n+                ModuleVisitor mv = super.visitModule(name, access, version);\n+                exports.forEach(e -> {\n+                    mv.visitPackage(e);\n+                    mv.visitExport(e, 0);\n+                });\n+                return mv;\n+            }\n+        }, 0);\n+        return cw.toByteArray();\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/ClassMorph.java","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.jreinstr;\n+\n+public class Code {\n+    public static void main(String[] args) {\n+        System.out.println(\"User code has been executed.\");\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/jreinstr\/Code.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.jreinstr;\n+\n+import com.sun.tdk.jcov.JREInstr;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class JREInstrTest {\n+\n+    Path jre;\n+    Path userCode;\n+\n+    private Path copyJRE(Path src) throws IOException, InterruptedException {\n+        Path dest = Files.createTempDirectory(\"JDK\");\n+        System.out.println(\"Copying \" + src + \" to \" + dest);\n+        Files.walk(src).forEach(s -> {\n+            try {\n+                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        return dest;\n+    }\n+\n+    private void rmRF(Path jre) throws IOException {\n+        System.out.println(\"Removing \" + jre);\n+        Files.walkFileTree(jre, new FileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    static void createUserCode(Path location, Class code) throws IOException {\n+        String fileName = code.getName().replace('.', '\/') + \".class\";\n+        Path classFile = location.resolve(fileName);\n+        Files.createDirectories(classFile.getParent());\n+        try (InputStream ci = code.getClassLoader().getResourceAsStream(fileName);\n+             OutputStream out = Files.newOutputStream(classFile)) {\n+            byte[] buffer = new byte[1024];\n+            int read;\n+            while ((read = ci.read(buffer)) > 0) {\n+                out.write(buffer, 0, read);\n+            }\n+        }\n+    }\n+\n+    @BeforeClass\n+    public void setup() throws IOException, InterruptedException {\n+        String testJRE = System.getProperty(\"test.jre\");\n+        if(testJRE == null) {\n+            testJRE = System.getProperty(\"java.home\");\n+        }\n+        jre = copyJRE(Paths.get(testJRE));\n+        userCode = Paths.get(\"user_code\");\n+        createUserCode(userCode, Code.class);\n+    }\n+\n+    @Test\n+    public void testJREInstr() throws IOException, InterruptedException {\n+        String runtime = Arrays.stream(System.getProperty(\"java.class.path\").split(File.pathSeparator))\n+                .peek(System.out::println)\n+                .filter(s -> s.endsWith(\"jcov_file_saver.jar\")).findAny().get();\n+        String[] params = new String[] {\n+                \"-implantrt\", runtime,\n+                \"-im\", \"java.base\",\n+                jre.toString()};\n+        System.out.println(\"Running JREInstr with \" + Arrays.stream(params).collect(Collectors.joining(\" \")));\n+        long start = System.currentTimeMillis();\n+        assertEquals(new JREInstr().run(params), 0);\n+        \/\/track instrumentation time for the TODO in copyJRE\n+        System.out.println(\"Took \" + (System.currentTimeMillis() - start) + \" to instrument.\");\n+    }\n+\n+    @Test(dependsOnMethods = \"testJREInstr\")\n+    public void testInstrumentation() throws IOException, InterruptedException {\n+        List<String> command = List.of(\n+                jre.toString() + File.separator + \"bin\" + File.separator + \"java\",\n+                \"-cp\", userCode.toAbsolutePath().toString(), Code.class.getName());\n+        System.out.println(command.stream().collect(Collectors.joining(\" \")));\n+        new ProcessBuilder()\n+                .command(command)\n+                .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                .start().waitFor();\n+        assertTrue(Files.exists(Paths.get(\"result.xml\")));\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(jre != null && Files.exists(jre)) rmRF(jre);\n+        if(userCode != null && Files.exists(userCode)) rmRF(userCode);\n+        Files.deleteIfExists(Paths.get(\"result.xml\"));\n+    }\n+\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/jreinstr\/JREInstrTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"}]}