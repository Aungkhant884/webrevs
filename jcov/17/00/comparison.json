{"files":[{"patch":"@@ -330,1 +330,1 @@\n-    <target name=\"test\" depends=\"build-jcov\">\n+    <target name=\"test\" depends=\"build-jcov,build-network.saver\">\n@@ -342,1 +342,1 @@\n-                <path path=\"${testngjar}:${build.dir}\/jcov.jar:${result.dir}\/test\/classes:${jcommanderjar}\"\/>\n+                <path path=\"${testngjar}:${build.dir}\/jcov.jar:${build.dir}\/jcov_network_saver.jar:${result.dir}\/test\/classes:${jcommanderjar}\"\/>\n","filename":"build\/build.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -478,0 +478,4 @@\n+    public InstrumentationPlugin getPlugin() {\n+        return plugin;\n+    }\n+\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,3 @@\n-                        createJMod(mod, jdk, implant.getAbsolutePath());\n+                        createJMod(mod, jdk, implant.getAbsolutePath(),\n+                                (instr.getPlugin() != null && instr.getPlugin().runtime() != null) ?\n+                                    instr.getPlugin().runtime().toString() : null);\n@@ -281,0 +283,8 @@\n+                            if(instr.getPlugin() != null) {\n+                                String pluginRuntimePackage = instr.getPlugin().collectorPackage();\n+                                if(pluginRuntimePackage != null) {\n+                                    pluginRuntimePackage = pluginRuntimePackage.replace('.', '\/');\n+                                    mv.visitPackage(pluginRuntimePackage);\n+                                    mv.visitExport(pluginRuntimePackage, 0);\n+                                }\n+                            }\n@@ -395,1 +405,1 @@\n-        private void createJMod(File jmodDir, File jdk, String rt_path) {\n+    private void createJMod(File jmodDir, File jdk, String rt_path, String pluginPath) {\n@@ -406,1 +416,5 @@\n-                        command.append(\"--class-path \" + rt_path + File.pathSeparator + jmodDir.getName() + File.separator + \"classes \");\n+                        command.append(\"--class-path \" + rt_path);\n+                        if(pluginPath != null) {\n+                            command.append(File.pathSeparator + pluginPath);\n+                        }\n+                        command.append(File.pathSeparator + jmodDir.getName() + File.separator + \"classes \");\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/JREInstr.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.nio.file.Path;\n+\n@@ -36,0 +38,1 @@\n+     * @return A valid method visitor. If no instrumentation needed, must return <code>visitor<\/code> argument.\n@@ -44,0 +47,15 @@\n+\n+    \/**\n+     * For the instrumented code to work independently (i.e. without adding additional classes  to the classpath), some\n+     * classes can be \"implanted\" into the instrumented code.\n+     * @return Path containing the classes to be implanted. Must be in a form which can be added to Java classpath.\n+     *\/\n+    \/\/TODO perhaps this can return a list of classes to be implanted\n+    Path runtime() throws Exception;\n+\n+    \/**\n+     * Name of a package which contains code, that will be called from the instrumented\n+     * code. Such package may need to be exported from a module.\n+     * @return package name\n+     *\/\n+    String collectorPackage();\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/instrument\/InstrumentationPlugin.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.file.Path;\n@@ -96,0 +97,10 @@\n+    @Override\n+    public Path runtime() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String collectorPackage() {\n+        return null;\n+    }\n+\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/FieldsPlugin.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tdk.jcov.instrument.plugin;\n-\n-import com.sun.tdk.jcov.JREInstr;\n-import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n-import com.sun.tdk.jcov.runtime.Collect;\n-import org.objectweb.asm.MethodVisitor;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.FileVisitor;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarOutputStream;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-public class JREInstrTest {\n-\n-    public static final String TIMES_SAVED = \"TIMES SAVED \";\n-    public static final String TIMES_CALLED = \"TIMES CALLED \";\n-\n-    Path rtJar;\n-    Path jre;\n-\n-    private Path copyJRE(Path src) throws IOException {\n-        Path dest = Files.createTempDirectory(\"JDK\");\n-        Files.walk(src).forEach(s -> {\n-            try {\n-                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        });\n-        return dest;\n-    }\n-\n-    private void removeJRE(Path jre) throws IOException {\n-        Files.walkFileTree(jre, new FileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override\n-            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                Files.delete(file);\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override\n-            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n-                return FileVisitResult.CONTINUE;\n-            }\n-            @Override\n-            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n-                Files.delete(dir);\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n-    }\n-\n-    private Path createJCovRtJar() throws IOException {\n-        Path dest = Files.createTempFile(\"jcov-rt-\", \".jar\");\n-        System.out.println(\"rt jar: \" + dest);\n-        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n-            jar.putNextEntry(new JarEntry(Collect.class.getName().replace(\".\", File.separator) + \".class\"));\n-        }\n-        return dest;\n-    }\n-\n-    @BeforeClass\n-    public void setup() throws IOException {\n-        String testJRE = System.getProperty(\"test.jre\");\n-        if(testJRE == null) {\n-            testJRE = System.getProperty(\"java.home\");\n-        }\n-        rtJar = createJCovRtJar();\n-        jre = copyJRE(Paths.get(testJRE));\n-    }\n-\n-    @Test\n-    public void testJREInstr() throws IOException, InterruptedException {\n-        VoidPlugin.reset();\n-        String[] params = new String[] {\n-                \"-implantrt\", rtJar.toString(),\n-                \"-instr_plugin\", VoidPlugin.class.getName(), jre.toString()};\n-        System.out.println(params);\n-        new JREInstr().run(params);\n-        assertEquals(VoidPlugin.savedTimes.intValue(), 1);\n-        assertTrue(VoidPlugin.calledTimes.get() > 0);\n-    }\n-\n-    @AfterClass\n-    public void tearDown() throws IOException {\n-        if(jre != null && Files.exists(jre)) removeJRE(jre);\n-        if(rtJar != null && Files.exists(rtJar)) Files.delete(rtJar);\n-    }\n-\n-    public static class VoidPlugin implements InstrumentationPlugin {\n-\n-        public static AtomicInteger calledTimes = new AtomicInteger(0);\n-        public static AtomicInteger savedTimes = new AtomicInteger(0);\n-\n-        public static void reset() {\n-            calledTimes.set(0);\n-            savedTimes.set(0);\n-        }\n-\n-        @Override\n-        public MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor) {\n-            calledTimes.incrementAndGet();\n-            return null;\n-        }\n-\n-        @Override\n-        public void instrumentationComplete() throws Exception {\n-            savedTimes.incrementAndGet();\n-        }\n-    }\n-}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/JREInstrTest.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin.jreinstr;\n+\n+import java.lang.module.ModuleDescriptor;\n+\n+public class Collect {\n+    public static void collect(Object param) {\n+\n+    }\n+\n+    \/\/this is called from the test to test that the necessary changes has been done by the instarumentation\n+    public static void main(String[] args) {\n+        Object.class.getModule().getDescriptor().exports().stream().filter(e -> !e.isQualified())\n+                .map(ModuleDescriptor.Exports::source)\n+                .forEach(System.out::println);\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/jreinstr\/Collect.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin.jreinstr;\n+\n+import com.sun.tdk.jcov.JREInstr;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class JREInstrTest {\n+\n+    public static final String TIMES_SAVED = \"TIMES SAVED \";\n+    public static final String TIMES_CALLED = \"TIMES CALLED \";\n+\n+    Path rtJar;\n+    Path jre;\n+\n+    private Path copyJRE(Path src) throws IOException, InterruptedException {\n+        Path dest = Files.createTempDirectory(\"JDK\");\n+        System.out.println(\"Copying \" + src + \" to \" + dest);\n+        Files.walk(src).forEach(s -> {\n+            try {\n+                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        return dest;\n+        \/\/TODO make this to work, as it would be a whole lot faster\n+        \/\/a JDK created by jimage can not be used, it fails with\n+        \/\/Command line error: bootmodules.jimage was not found in modules directory\n+\/\/        Path dest = Files.createTempDirectory(\"test_data\");\n+\/\/        Path res = dest.resolve(\"jdk\");\n+\/\/        List<String> command = List.of(\n+\/\/                src.toString() + File.separator + \"bin\" + File.separator + \"jlink\",\n+\/\/                \"--add-modules\",\n+\/\/                \"java.base,java.compiler\",\n+\/\/                \"--output\",\n+\/\/                res.toString()\n+\/\/        );\n+\/\/        System.out.println(command.stream().collect(Collectors.joining(\" \")));\n+\/\/        assertEquals(new ProcessBuilder(command)\n+\/\/                .redirectError(ProcessBuilder.Redirect.INHERIT)\n+\/\/                .redirectInput(ProcessBuilder.Redirect.INHERIT)\n+\/\/                .start().waitFor(), 0);\n+\/\/        return res;\n+    }\n+\n+    private void removeJRE(Path jre) throws IOException {\n+        System.out.println(\"Removing \" + jre);\n+        Files.walkFileTree(jre, new FileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                return FileVisitResult.CONTINUE;\n+            }\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                Files.delete(dir);\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+    }\n+\n+    static Path createRtJar(String prefix, Class collect) throws IOException {\n+        Path dest = Files.createTempFile(prefix, \".jar\");\n+        System.out.println(prefix + \" jar: \" + dest);\n+        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n+            jar.putNextEntry(new JarEntry(collect.getName().replace(\".\", File.separator) + \".class\"));\n+            try (InputStream ci = collect.getClassLoader()\n+                    .getResourceAsStream(collect.getName().replace('.', '\/') + \".class\")) {\n+                byte[] buffer = new byte[1024];\n+                int read;\n+                while((read = ci.read(buffer)) > 0) {\n+                    jar.write(buffer, 0, read);\n+                }\n+            }\n+        }\n+        return dest;\n+    }\n+\n+    @BeforeClass\n+    public void setup() throws IOException, InterruptedException {\n+        String testJRE = System.getProperty(\"test.jre\");\n+        if(testJRE == null) {\n+            testJRE = System.getProperty(\"java.home\");\n+        }\n+        rtJar = createRtJar(\"jcov-rt-\", Collect.class);\n+        jre = copyJRE(Paths.get(testJRE));\n+    }\n+\n+    @Test\n+    public void testJREInstr() throws IOException, InterruptedException {\n+        TestPlugin.reset();\n+        String runtime = Arrays.stream(System.getProperty(\"java.class.path\").split(File.pathSeparator))\n+                .peek(System.out::println)\n+                .filter(s -> s.endsWith(\"jcov_network_saver.jar\")).findAny().get();\n+        String[] params = new String[] {\n+                \"-implantrt\", runtime,\n+                \"-instr_plugin\", TestPlugin.class.getName(),\n+                jre.toString()};\n+        System.out.println(\"Running JREInstr with \" + Arrays.stream(params).collect(Collectors.joining(\" \")));\n+        assertEquals(new JREInstr().run(params), 0);\n+        assertEquals(TestPlugin.savedTimes.intValue(), 1);\n+        assertTrue(TestPlugin.calledTimes.get() > 0);\n+    }\n+\n+    @Test(dependsOnMethods = \"testJREInstr\")\n+    public void testInstrumentation() throws IOException, InterruptedException {\n+        \/\/no classpath necessary for the next call because the class is implanted\n+        List<String> command = List.of(\n+                jre.toString() + File.separator + \"bin\" + File.separator + \"java\",\n+                Collect.class.getName());\n+        System.out.println(command.stream().collect(Collectors.joining(\" \")));\n+        Process p = new ProcessBuilder()\n+                .command(command)\n+                .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                .start();\n+        boolean jcovExported = false;\n+        boolean pluginExported = false;\n+        try(BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            String line;\n+            while((line = in.readLine()) != null && !(jcovExported && pluginExported)) {\n+                System.out.println(line);\n+                if(line.equals(Collect.class.getPackage().getName())) pluginExported = true;\n+                if(line.equals(com.sun.tdk.jcov.runtime.Collect.class.getPackage().getName())) jcovExported = true;\n+            }\n+        }\n+        p.waitFor();\n+        assertTrue(pluginExported && jcovExported);\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(jre != null && Files.exists(jre)) removeJRE(jre);\n+        if(rtJar != null && Files.exists(rtJar)) Files.delete(rtJar);\n+    }\n+\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/jreinstr\/JREInstrTest.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tdk.jcov.instrument.plugin.jreinstr;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import org.objectweb.asm.MethodVisitor;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class TestPlugin implements InstrumentationPlugin {\n+\n+    public static AtomicInteger calledTimes = new AtomicInteger(0);\n+    public static AtomicInteger savedTimes = new AtomicInteger(0);\n+    public static Path rt;\n+\n+    static {\n+        try {\n+            rt = JREInstrTest.createRtJar(\"plugin-rt-\", Collect.class);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    public static void reset() {\n+        calledTimes.set(0);\n+        savedTimes.set(0);\n+    }\n+\n+    @Override\n+    public MethodVisitor methodVisitor(int access, String owner, String name, String desc, MethodVisitor visitor) {\n+        calledTimes.incrementAndGet();\n+        return visitor;\n+    }\n+\n+    @Override\n+    public void instrumentationComplete() throws Exception {\n+        savedTimes.incrementAndGet();\n+    }\n+\n+    @Override\n+    public Path runtime() {\n+        return rt;\n+    }\n+\n+    @Override\n+    public String collectorPackage() {\n+        return Collect.class.getPackage().getName();\n+    }\n+}\n","filename":"test\/unit\/com\/sun\/tdk\/jcov\/instrument\/plugin\/jreinstr\/TestPlugin.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}