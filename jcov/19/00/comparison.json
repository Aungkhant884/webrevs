{"files":[{"patch":"@@ -1,2 +1,2 @@\n-parameter_test\n-out\n+.idea\n+build\n","filename":"plugins\/data_coverage\/.gitignore","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-# Default ignored files\n-\/shelf\/\n-\/workspace.xml\n","filename":"plugins\/data_coverage\/.idea\/.gitignore","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<project version=\"4\">\n-  <component name=\"CompilerConfiguration\">\n-    <wildcardResourcePatterns>\n-      <entry name=\"!?*.java\" \/>\n-      <entry name=\"!?*.form\" \/>\n-      <entry name=\"!?*.class\" \/>\n-      <entry name=\"!?*.groovy\" \/>\n-      <entry name=\"!?*.scala\" \/>\n-      <entry name=\"!?*.flex\" \/>\n-      <entry name=\"!?*.kt\" \/>\n-      <entry name=\"!?*.clj\" \/>\n-    <\/wildcardResourcePatterns>\n-  <\/component>\n-<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/compiler.xml","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<project version=\"4\">\n-  <component name=\"Encoding\">\n-    <file url=\"PROJECT\" charset=\"UTF-8\" \/>\n-  <\/component>\n-<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/encodings.xml","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-<component name=\"libraryTable\">\n-  <library name=\"jcov\">\n-    <CLASSES>\n-      <root url=\"jar:\/\/$PROJECT_DIR$\/..\/..\/JCOV_BUILD\/jcov_3.0\/jcov.jar!\/\" \/>\n-    <\/CLASSES>\n-    <JAVADOC \/>\n-    <SOURCES \/>\n-  <\/library>\n-<\/component>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/libraries\/jcov.xml","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,16 +0,0 @@\n-<component name=\"libraryTable\">\n-  <library name=\"org.testng:testng:7.1.0\" type=\"repository\">\n-    <properties maven-id=\"org.testng:testng:7.1.0\" \/>\n-    <CLASSES>\n-      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/org\/testng\/testng\/7.1.0\/testng-7.1.0.jar!\/\" \/>\n-      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/beust\/jcommander\/1.72\/jcommander-1.72.jar!\/\" \/>\n-      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/google\/inject\/guice\/4.1.0\/guice-4.1.0-no_aop.jar!\/\" \/>\n-      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/javax\/inject\/javax.inject\/1\/javax.inject-1.jar!\/\" \/>\n-      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/aopalliance\/aopalliance\/1.0\/aopalliance-1.0.jar!\/\" \/>\n-      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/com\/google\/guava\/guava\/19.0\/guava-19.0.jar!\/\" \/>\n-      <root url=\"jar:\/\/$MAVEN_REPOSITORY$\/org\/yaml\/snakeyaml\/1.21\/snakeyaml-1.21.jar!\/\" \/>\n-    <\/CLASSES>\n-    <JAVADOC \/>\n-    <SOURCES \/>\n-  <\/library>\n-<\/component>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/libraries\/org_testng_testng_7_1_0.xml","additions":0,"deletions":16,"binary":false,"changes":16,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<project version=\"4\">\n-  <component name=\"MavenBuildProjectComponent\">\n-    <option name=\"mavenExecutable\" value=\"\" \/>\n-    <option name=\"Settings File\" value=\"$USER_HOME$\/.m2\/settings.xml\" \/>\n-    <option name=\"mavenCommandLineParams\" value=\"\" \/>\n-    <option name=\"vmOptions\" value=\"\" \/>\n-    <option name=\"useMavenEmbedder\" value=\"false\" \/>\n-    <option name=\"useFilter\" value=\"false\" \/>\n-    <option name=\"Batch Mode\" value=\"false\" \/>\n-    <option name=\"Check Plugin Updates\" value=\"false\" \/>\n-    <option name=\"Debug\" value=\"false\" \/>\n-    <option name=\"Errors\" value=\"false\" \/>\n-    <option name=\"Fail At End\" value=\"false\" \/>\n-    <option name=\"Fail Fast\" value=\"false\" \/>\n-    <option name=\"Fail Never\" value=\"false\" \/>\n-    <option name=\"Lax Checksums\" value=\"false\" \/>\n-    <option name=\"No Plugin Registry\" value=\"false\" \/>\n-    <option name=\"No Plugin Updates\" value=\"false\" \/>\n-    <option name=\"Non Recursive\" value=\"false\" \/>\n-    <option name=\"Offline\" value=\"false\" \/>\n-    <option name=\"Reactor\" value=\"false\" \/>\n-    <option name=\"Strict Checksums\" value=\"false\" \/>\n-    <option name=\"Update Plugins\" value=\"false\" \/>\n-    <option name=\"Update Snapshots\" value=\"false\" \/>\n-    <option name=\"Skip Tests\" value=\"false\" \/>\n-    <pom-list \/>\n-  <\/component>\n-  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_11\" default=\"true\" project-jdk-name=\"11\" project-jdk-type=\"JavaSDK\">\n-    <output url=\"file:\/\/$PROJECT_DIR$\/out\" \/>\n-  <\/component>\n-<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/misc.xml","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<project version=\"4\">\n-  <component name=\"ProjectModuleManager\">\n-    <modules>\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/data_coverage.iml\" filepath=\"$PROJECT_DIR$\/data_coverage.iml\" \/>\n-    <\/modules>\n-  <\/component>\n-<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/modules.xml","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<project version=\"4\">\n-  <component name=\"VcsDirectoryMappings\">\n-    <mapping directory=\"$PROJECT_DIR$\/..\/..\" vcs=\"Git\" \/>\n-  <\/component>\n-<\/project>\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/.idea\/vcs.xml","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -0,0 +1,86 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n+  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+  This code is free software; you can redistribute it and\/or modify it\n+  under the terms of the GNU General Public License version 2 only, as\n+  published by the Free Software Foundation.  Oracle designates this\n+  particular file as subject to the \"Classpath\" exception as provided\n+  by Oracle in the LICENSE file that accompanied this code.\n+\n+  This code is distributed in the hope that it will be useful, but WITHOUT\n+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+  version 2 for more details (a copy is included in the LICENSE file that\n+  accompanied this code).\n+\n+  You should have received a copy of the GNU General Public License version\n+  2 along with this work; if not, write to the Free Software Foundation,\n+  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+  or visit www.oracle.com if you need additional information or have any\n+  questions.\n+-->\n+<project name=\"SimpleMethodsANCFilter\" default=\"jar\" basedir=\".\">\n+  <!-- set global properties for this build -->\n+  <property name=\"src\" location=\"src\"\/>\n+  <property name=\"test\" location=\"test\"\/>\n+  <property name=\"build\" location=\"build\"\/>\n+  <property name=\"classes\" location=\"${build}\/classes\"\/>\n+  <property name=\"test.classes\" location=\"${build}\/tests\"\/>\n+  <property name=\"test.jar\" location=\"${build}\/tests.jar\"\/>\n+  <property name=\"jar\" location=\"${build}\/DataCoverage.jar\"\/>\n+  <property name=\"test.results\" location=\"${build}\/test_results\"\/>\n+  <property name=\"jcov.jar\" location=\"..\/..\/JCOV_BUILD\/jcov_3.0\/jcov.jar\"\/>\n+  <property name=\"jcov.file.saver.jar\" location=\"..\/..\/JCOV_BUILD\/jcov_3.0\/jcov_file_saver.jar\"\/>\n+  <property name=\"test.includes\" value=\"**\/*Test.class\"\/>\n+  <property name=\"test.excludes\" value=\"\"\/>\n+\n+  <target name=\"compile\">\n+    <available file=\"${jcov.jar}\" property=\"jcov-jar-exists\"\/>\n+    <fail unless=\"jcov-jar-exists\" message=\"There is no ${jcov.jar}\"\/>\n+    <mkdir dir=\"${classes}\"\/>\n+    <javac srcdir=\"${src}\" classpath=\"${jcov.jar}\" destdir=\"${classes}\"\/>\n+  <\/target>\n+\n+  <target name=\"jar\" depends=\"compile\">\n+    <jar jarfile=\"${jar}\" basedir=\"${classes}\"\/>\n+  <\/target>\n+\n+  <target name=\"clean\">\n+    <delete dir=\"${build}\"\/>\n+  <\/target>\n+\n+  <target name=\"compile-test\" depends=\"compile\">\n+    <fail unless=\"testng.classpath\" message=\"Please specify testng.classpath\"\/>\n+    <mkdir dir=\"${test.classes}\"\/>\n+    <javac srcdir=\"${test}\" classpath=\"${classes}:${jcov.jar}:${testng.classpath}\" destdir=\"${test.classes}\" debug=\"true\"\/>\n+    <copy file=\"${test}\/openjdk\/jcov\/data\/instrumentation.properties\" tofile=\"${test.classes}\/openjdk\/jcov\/data\/instrumentation.properties\"\/>\n+  <\/target>\n+\n+  <target name=\"fast-test\">\n+    <antcall target=\"test\" inheritAll=\"true\">\n+      <param name=\"test.excludes\" value=\"**\/jreinstr\/**\/*.class\"\/>\n+    <\/antcall>\n+  <\/target>\n+\n+  <target name=\"test\" depends=\"compile,compile-test\">\n+    <available file=\"${jcov.file.saver.jar}\" property=\"jcov-file-saver-jar-exists\"\/>\n+    <fail unless=\"jcov-file-saver-jar-exists\" message=\"There is no ${jcov.file.saver.jar}\"\/>\n+    <taskdef resource=\"testngtasks\" classpath=\"${testng.classpath}\"\/>\n+    <mkdir dir=\"${test.results}\"\/>\n+    <jar jarfile=\"${test.jar}\" basedir=\"${test.classes}\"\/>\n+    <propertyset id=\"test.bytecode\">\n+      <propertyref name=\"test.classes\"\/>\n+      <propertyref name=\"test.jar\"\/>\n+      <propertyref name=\"jcov.file.saver.jar\"\/>\n+    <\/propertyset>\n+    <testng classpath=\"${classes}:${jcov.jar}:${test.classes}:${testng.classpath}\" outputDir=\"${test.results}\" verbose=\"3\">\n+      <propertyset refid=\"test.bytecode\"\/>\n+      <classfileset dir=\"${test.classes}\" includes=\"${test.includes}\" excludes=\"${test.excludes}\"\/>\n+    <\/testng>\n+  <\/target>\n+<\/project>\n","filename":"plugins\/data_coverage\/build.xml","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -27,0 +27,3 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n@@ -31,3 +34,2 @@\n-import java.util.Objects;\n-\n-import static java.util.stream.Collectors.toMap;\n+import java.util.Properties;\n+import java.util.Set;\n@@ -41,2 +43,10 @@\n-    private static Map<String, String> properties = System.getProperties().entrySet().stream()\n-            .collect(toMap(Object::toString, Objects::toString));\n+    public static final String PROP_FILE =\n+            Env.class.getPackageName().replace('.', '\/') +\n+            \"\/instrumentation.properties\";\n+    \/**\n+     * Prefix for all system property names which will be passed to the VM running JCov calls.\n+     *\/\n+    public static final String JCOV_DATA_ENV_PREFIX = \"jcov.data.\";\n+\n+    public static final String JCOV_DATA_SAVER = \"jcov.data.saver\";\n+    private static final String JCOV_OPTION_FOR_DATA_SAVER = \"jcov.data-saver\";\n@@ -44,2 +54,4 @@\n-    public static Map<String, String> properties() {\n-        return properties;\n+    private static volatile Properties SAVED;\n+\n+    public static void setSystemProperties(Map<String, String> properties) {\n+        properties.forEach((k, v) -> System.setProperty(k, v));\n@@ -48,2 +60,4 @@\n-    public static void properties(Map<String, String> properties) {\n-        Env.properties = properties;\n+    public static void clear(String prefix) {\n+        Set<String> keys = System.getProperties().stringPropertyNames();\n+        keys.stream().filter(k -> k.startsWith(prefix))\n+                .forEach(k -> System.clearProperty(k));\n@@ -53,3 +67,25 @@\n-        String propValue = properties.get(property);\n-        if(propValue != null) return defaultValue;\n-        else return defaultValue;\n+        synchronized(Env.class) {\n+            if (SAVED == null) {\n+                try {\n+                    SAVED = new Properties();\n+                    InputStream in = Env.class.getResourceAsStream(\"\/\" + PROP_FILE);\n+                    if(in != null) {\n+                        SAVED.load(in);\n+                        if(System.getProperty(JCOV_OPTION_FOR_DATA_SAVER) == null) {\n+                            String saver = SAVED.getProperty(JCOV_DATA_SAVER);\n+                            if(saver != null)\n+                                System.setProperty(JCOV_OPTION_FOR_DATA_SAVER, saver);\n+                        }\n+                        System.out.println(\"Using property definitions from \" + PROP_FILE + \":\");\n+                        SAVED.list(System.out);\n+                    }\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                    throw e;\n+                }\n+            }\n+        }\n+        String override = System.getProperty(property);\n+        return (override != null) ? override : SAVED.getProperty(property, defaultValue);\n@@ -57,0 +93,1 @@\n+\n@@ -58,1 +95,1 @@\n-        String propValue = properties.get(property);\n+        String propValue = getStringEnv(property, null);\n@@ -62,0 +99,1 @@\n+\n@@ -64,1 +102,1 @@\n-        String propValue = properties.get(property);\n+        String propValue = getStringEnv(property, null);\n@@ -72,1 +110,1 @@\n-                String[] params = propValue.substring(ob, cb - 1).split(\",\");\n+                String[] params = propValue.substring(ob + 1, cb).split(\",\");\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/Env.java","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n@@ -46,4 +47,0 @@\n-    \/**\n-     * Prefix for all system property names which will be passed to the VM running JCov calls.\n-     *\/\n-    public static final String JCOV_DATA_ENV_PREFIX = \"jcov.data.\";\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/Instrument.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n+\n+public class JREInstr {\n+    private String pluginClass;\n+    private String jcovTemplate;\n+    private String jcovRuntime;\n+\n+    public JREInstr() {\n+    }\n+\n+    public JREInstr clearEnv() {\n+        Env.clear(JCOV_DATA_ENV_PREFIX);\n+        return this;\n+    }\n+\n+    public JREInstr setEnv(Map<String, String> env) {\n+        Env.setSystemProperties(env);\n+        return this;\n+    }\n+\n+    public JREInstr pluginClass(String pluginClass) {\n+        this.pluginClass = pluginClass;\n+        return this;\n+    }\n+\n+    public JREInstr jcovTemplate(String jcovTemplate) {\n+        this.jcovTemplate = jcovTemplate;\n+        return this;\n+    }\n+\n+    public JREInstr jcovRuntime(String jcovRuntime) {\n+        this.jcovRuntime = jcovRuntime;\n+        return this;\n+    }\n+\n+    public int instrument(String jre) throws IOException, InterruptedException {\n+        requireNonNull(jcovRuntime, \"Must specify JCov runtime.\");\n+        requireNonNull(pluginClass, \"Must specify an instrumentation plugin.\");\n+        requireNonNull(jcovTemplate, \"Must specify jcov template location.\");\n+        String[] params = new String[] {\n+                \"-implantrt\", jcovRuntime,\n+                \"-instr_plugin\", pluginClass,\n+                \"-template\", jcovTemplate,\n+                jre};\n+        System.out.println(\"Instrumentation parameters: \" +\n+                Arrays.stream(params).collect(Collectors.joining(\" \")));\n+        return new com.sun.tdk.jcov.JREInstr().run(params);\n+    }\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/JREInstr.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -27,4 +27,0 @@\n-import openjdk.jcov.data.Instrument;\n-\n-import static openjdk.jcov.data.arguments.instrument.Plugin.ARGUMENTS_PREFIX;\n-\n@@ -32,2 +28,0 @@\n-    public static final String DESERIALIZER =\n-            Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \".deserializer\";\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/analysis\/Reader.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,5 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+\n@@ -31,0 +36,23 @@\n+    static List<Plugin.TypeDescriptor> parseDesc(String desc) throws ClassNotFoundException {\n+        if(!desc.startsWith(\"(\")) throw new IllegalArgumentException(\"Not a method descriptor: \" + desc);\n+        int pos = 1;\n+        List<Plugin.TypeDescriptor> res = new ArrayList<>();\n+        while(desc.charAt(pos) != ')') {\n+            char next = desc.charAt(pos);\n+            if(next == 'L') {\n+                int l = pos;\n+                pos = desc.indexOf(\";\", pos) + 1;\n+                res.add(new Plugin.TypeDescriptor(\"L\", desc.substring(l + 1, pos - 1), ALOAD));\n+            } else if(next == '[') {\n+                \/\/TODO can we do better?\n+                res.add(new Plugin.TypeDescriptor(\"[\", \"java\/lang\/Object\", ALOAD));\n+                if(desc.charAt(pos + 1) == 'L') pos = desc.indexOf(\";\", pos) + 1;\n+                else pos = pos + 2;\n+            } else {\n+                res.add(Plugin.primitiveTypes.get(new String(new char[] {next})));\n+                pos++;\n+            }\n+        }\n+        return res;\n+    }\n+\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/instrument\/MethodFilter.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import openjdk.jcov.data.Instrument;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n@@ -31,0 +31,3 @@\n+import openjdk.jcov.data.arguments.runtime.Implantable;\n+import openjdk.jcov.data.arguments.runtime.Saver;\n+import openjdk.jcov.data.arguments.runtime.Serializer;\n@@ -34,0 +37,1 @@\n+import java.io.InputStream;\n@@ -35,0 +39,1 @@\n+import java.nio.file.Files;\n@@ -37,1 +42,0 @@\n-import java.util.ArrayList;\n@@ -39,0 +43,1 @@\n+import java.util.HashSet;\n@@ -41,0 +46,2 @@\n+import java.util.Properties;\n+import java.util.Set;\n@@ -42,0 +49,2 @@\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n@@ -43,1 +52,2 @@\n-import static openjdk.jcov.data.Instrument.JCOV_DATA_ENV_PREFIX;\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n+import static openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER;\n@@ -54,1 +64,1 @@\n-    public static final String COLLECTOR_CLASS = \"openjdk.jcov.data.arguments.runtime.Collect\"\n+    public static final String COLLECTOR_CLASS = Collect.class.getName()\n@@ -65,16 +75,0 @@\n-    \/**\n-     * Property name prefix for all properties used by this plugin. The property names are started with\n-     * <code>Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX<\/code>\n-     *\/\n-    public static final String ARGUMENTS_PREFIX = \"args.\";\n-    \/**\n-     * Name of a property which specifies classname for a class which will be used to \"serialize\" the collected\n-     * values.\n-     *\/\n-    public static final String SERIALIZER =\n-        Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \".serializer\";\n-    \/**\n-     * Name of a property which contains path of the template file.\n-     *\/\n-    public static final String TEMPLATE_FILE =\n-            JCOV_DATA_ENV_PREFIX + \"arguments.template\";\n@@ -85,1 +79,1 @@\n-        JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \"method.filter\";\n+        JCOV_DATA_ENV_PREFIX + Collect.ARGUMENTS_PREFIX + \"method.filter\";\n@@ -92,2 +86,2 @@\n-        public TypeDescriptor(String id, Class cls, int loadOpcode, boolean longOrDouble) {\n-            super(id, cls, loadOpcode, longOrDouble);\n+        public TypeDescriptor(String id, String cls, int loadOpcode) {\n+            super(id, cls, loadOpcode);\n@@ -106,2 +100,2 @@\n-                visitor.visitMethodInsn(INVOKESTATIC, clsName(), \"valueOf\",\n-                        \"(\" + id() + \")L\" + clsName() + \";\", false);\n+                visitor.visitMethodInsn(INVOKESTATIC, cls(), \"valueOf\",\n+                        \"(\" + id() + \")L\" + cls() + \";\", false);\n@@ -117,6 +111,8 @@\n-        primitiveTypes.put(\"I\", new TypeDescriptor(\"I\", Integer.class, ILOAD, false));\n-        primitiveTypes.put(\"J\", new TypeDescriptor(\"J\", Long.class, LLOAD, true));\n-        primitiveTypes.put(\"F\", new TypeDescriptor(\"F\", Float.class, FLOAD, false));\n-        primitiveTypes.put(\"D\", new TypeDescriptor(\"D\", Double.class, DLOAD, true));\n-        primitiveTypes.put(\"Z\", new TypeDescriptor(\"Z\", Boolean.class, ILOAD, false));\n-        primitiveTypes.put(\"B\", new TypeDescriptor(\"B\", Byte.class, ILOAD, false));\n+        primitiveTypes.put(\"S\", new TypeDescriptor(\"S\", Short.class, ILOAD, false, true));\n+        primitiveTypes.put(\"I\", new TypeDescriptor(\"I\", Integer.class, ILOAD, false, true));\n+        primitiveTypes.put(\"J\", new TypeDescriptor(\"J\", Long.class, LLOAD, true, true));\n+        primitiveTypes.put(\"F\", new TypeDescriptor(\"F\", Float.class, FLOAD, false, true));\n+        primitiveTypes.put(\"D\", new TypeDescriptor(\"D\", Double.class, DLOAD, true, true));\n+        primitiveTypes.put(\"Z\", new TypeDescriptor(\"Z\", Boolean.class, ILOAD, false, true));\n+        primitiveTypes.put(\"B\", new TypeDescriptor(\"B\", Byte.class, ILOAD, false, true));\n+        primitiveTypes.put(\"C\", new TypeDescriptor(\"C\", Character.class, ILOAD, false, true));\n@@ -137,1 +133,1 @@\n-        templateFile = Env.getPathEnv(TEMPLATE_FILE, Paths.get(\"template.lst\"));\n+        templateFile = Env.getPathEnv(Collect.COVERAGE_OUT, Paths.get(\"template.lst\"));\n@@ -147,1 +143,0 @@\n-        String method = name + desc;\n@@ -149,16 +144,21 @@\n-            if(methodFilter.accept(access, owner, name, desc)) {\n-                template.get(owner, method);\n-                return new MethodVisitor(ASM6, visitor) {\n-                    @Override\n-                    public void visitCode() {\n-                        try {\n-                            List<TypeDescriptor> params = parseDesc(desc);\n-                            if (params.size() > 0) {\n-                                super.visitLdcInsn(owner);\n-                                super.visitLdcInsn(name);\n-                                super.visitLdcInsn(desc);\n-                                super.visitIntInsn(BIPUSH, params.size());\n-                                super.visitTypeInsn(ANEWARRAY, \"java\/lang\/Object\");\n-                                int stackIndex = ((access & ACC_STATIC) > 0) ? 0 : 1;\n-                                for (int i = 0; i < params.size(); i++) {\n-                                    stackIndex = params.get(i).visit(i, stackIndex, this);\n+            String method = name + desc;\n+            try {\n+                if (methodFilter.accept(access, owner, name, desc)) {\n+                    template.get(owner, method);\n+                    return new MethodVisitor(ASM6, visitor) {\n+                        @Override\n+                        public void visitCode() {\n+                            try {\n+                                List<TypeDescriptor> params = MethodFilter.parseDesc(desc);\n+                                if (params.size() > 0) {\n+                                    super.visitLdcInsn(owner);\n+                                    super.visitLdcInsn(name);\n+                                    super.visitLdcInsn(desc);\n+                                    super.visitIntInsn(BIPUSH, params.size());\n+                                    super.visitTypeInsn(ANEWARRAY, \"java\/lang\/Object\");\n+                                    int stackIndex = ((access & ACC_STATIC) > 0) ? 0 : 1;\n+                                    for (int i = 0; i < params.size(); i++) {\n+                                        stackIndex = params.get(i).visit(i, stackIndex, this);\n+                                    }\n+                                    visitor.visitMethodInsn(INVOKESTATIC, COLLECTOR_CLASS, COLLECTOR_METHOD,\n+                                            COLLECTOR_DESC, false);\n@@ -166,2 +166,2 @@\n-                                visitor.visitMethodInsn(INVOKESTATIC, COLLECTOR_CLASS, COLLECTOR_METHOD,\n-                                        COLLECTOR_DESC, false);\n+                            } catch (Exception e) {\n+                                e.printStackTrace();\n@@ -169,2 +169,1 @@\n-                        } catch (Exception e) {\n-                            e.printStackTrace();\n+                            super.visitCode();\n@@ -172,6 +171,9 @@\n-                        super.visitCode();\n-                    }\n-                };\n-            } else return visitor;\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n+                    };\n+                } else return visitor;\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        } catch(Throwable e) {\n+            \/\/JCov is known for swallowing exceptions\n+            e.printStackTrace();\n+            throw e;\n@@ -181,20 +183,34 @@\n-    public static List<TypeDescriptor> parseDesc(String desc) throws ClassNotFoundException {\n-        if(!desc.startsWith(\"(\")) throw new IllegalArgumentException(\"Not a method descriptor: \" + desc);\n-        int pos = 1;\n-        List<TypeDescriptor> res = new ArrayList<>();\n-        while(desc.charAt(pos) != ')') {\n-            String next = desc.substring(pos, pos + 1);\n-            if(next.equals(\"L\")) {\n-                int l = pos;\n-                pos = desc.indexOf(\";\", pos) + 1;\n-                res.add(new TypeDescriptor(\"L\", Class.forName(desc.substring(l + 1, pos - 1)\n-                        .replace('\/', '.')),\n-                        ALOAD, false, false));\n-            } else if(next.equals(\"[\")) {\n-                \/\/TODO can we do better?\n-                res.add(new TypeDescriptor(\"L\", new Object[0].getClass(),\n-                        ALOAD, false, false));\n-                pos = desc.indexOf(\";\", pos) + 1;\n-            } else {\n-                res.add(primitiveTypes.get(next));\n-                pos++;\n+    @Override\n+    public void instrumentationComplete() throws IOException {\n+        try {\n+            Coverage.write(template, templateFile);\n+        } catch(Throwable e) {\n+            \/\/JCov is known for swallowing exceptions\n+            e.printStackTrace();\n+            throw e;\n+        }\n+    }\n+\n+    private static final Set<Class> runtimeClasses = Set.of(\n+            Collect.class, Coverage.class, Saver.class, Saver.NoRuntimeSerializer.class, Env.class,\n+            Implantable.class, Serializer.class\n+    );\n+\n+    protected List<Class> runtimeClasses() {\n+        return runtimeClasses();\n+    }\n+\n+    @Override\n+    public Path runtime() throws Exception {\n+        try {\n+            Path dest = Files.createTempFile(\"jcov-data\", \".jar\");\n+            Properties toSave = new Properties();\n+            System.getProperties().forEach((k, v) -> {\n+                if(k.toString().startsWith(JCOV_DATA_ENV_PREFIX))\n+                    toSave.setProperty(k.toString(), v.toString());\n+            });\n+            Set<Class> allRuntime = runtimeClasses;\n+            Function<Object, String> serializer = Env.getSPIEnv(SERIALIZER, null);\n+            if(serializer != null && serializer instanceof Implantable) {\n+                allRuntime = new HashSet<>(runtimeClasses);\n+                allRuntime.addAll(((Implantable)serializer).runtime());\n@@ -202,0 +218,22 @@\n+            try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n+                jar.putNextEntry(new JarEntry(Env.PROP_FILE));\n+                toSave.store(jar, \"\");\n+                jar.closeEntry();\n+                for(Class rc : allRuntime) {\n+                    String fileName = rc.getName().replace(\".\", \"\/\") + \".class\";\n+                    jar.putNextEntry(new JarEntry(fileName));\n+                    try (InputStream ci = rc.getClassLoader().getResourceAsStream(fileName)) {\n+                        byte[] buffer = new byte[1024];\n+                        int read;\n+                        while ((read = ci.read(buffer)) > 0) {\n+                            jar.write(buffer, 0, read);\n+                        }\n+                    }\n+                    jar.closeEntry();\n+                }\n+            }\n+            return dest;\n+        } catch(Throwable e) {\n+            \/\/JCov is known for swallowing exceptions\n+            e.printStackTrace();\n+            throw e;\n@@ -203,1 +241,0 @@\n-        return res;\n@@ -207,2 +244,8 @@\n-    public void instrumentationComplete() throws IOException {\n-        Coverage.write(template, templateFile, serializer);\n+    public String collectorPackage() {\n+        try {\n+            return Collect.class.getPackage().getName();\n+        } catch(Throwable e) {\n+            \/\/JCov is known for swallowing exceptions\n+            e.printStackTrace();\n+            throw e;\n+        }\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/instrument\/Plugin.java","additions":125,"deletions":82,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Path;\n@@ -33,2 +35,2 @@\n-\n-import static openjdk.jcov.data.arguments.instrument.Plugin.TEMPLATE_FILE;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n@@ -40,1 +42,26 @@\n-    static final Coverage data;\n+    \/**\n+     * Property name prefix for all properties used by this plugin. The property names are started with\n+     * <code>Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX<\/code>\n+     *\/\n+    public static final String ARGUMENTS_PREFIX = \"args.\";\n+    \/**\n+     * Specifies where to save collected data or instrumentation information.\n+     *\/\n+    public static final String COVERAGE_OUT = Env.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX +\n+            \"coverage\";\n+    \/**\n+     * Specifies where to load previously collected data from. A non-empty value of this property will\n+     * make Collect class to load the data on class loading.\n+     *\/\n+    public static final String COVERAGE_IN = Env.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX +\n+            \"coverage.in\";\n+\n+    \/**\n+     * Name of a property containing a class name of a class of type <code>Function<Object, String><\/code> which will\n+     * be used during the serialization. <code>Object::toString<\/code> is used by default.\n+     *\/\n+    public static final String SERIALIZER = Env.JCOV_DATA_ENV_PREFIX +\n+            Collect.ARGUMENTS_PREFIX + \"serializer\";\n+\n+    static volatile Coverage data;\n+    private volatile static Serializer serializer;\n@@ -42,1 +69,10 @@\n-    static{\n+    static {\n+        if (!Env.getStringEnv(COVERAGE_IN, \"\").isEmpty()) {\n+            try {\n+                Path coverageFile = Env.getPathEnv(COVERAGE_IN, null);\n+                System.out.println(\"Loading data coverage from \" + coverageFile);\n+                data = Coverage.read(coverageFile);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        } else data = new Coverage();\n@@ -44,3 +80,3 @@\n-            data = Coverage.readTemplate(Env.getPathEnv(TEMPLATE_FILE, Paths.get(\"template.lst\")));\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n+            serializer = wrap(Env.getSPIEnv(SERIALIZER, Object::toString));\n+        } catch (ClassNotFoundException|NoSuchMethodException|IllegalAccessException|InvocationTargetException|InstantiationException e) {\n+            throw new RuntimeException(e);\n@@ -50,0 +86,7 @@\n+    private static Serializer wrap(Function<Object, String> function) {\n+        if(function instanceof Serializer)\n+            return (Serializer) function;\n+        else\n+            return new Saver.NoRuntimeSerializer(function);\n+    }\n+\n@@ -53,2 +96,37 @@\n-\/\/                Arrays.stream(params).map(Object::getClass).map(Class::getName).collect(joining(\",\")));\n-        data.get(owner, name + desc).add(Arrays.asList(params));\n+\/\/                Arrays.stream(params).map(Object::getClass).map(Class::getName)\n+\/\/                        .collect(java.util.stream.Collectors.joining(\",\")));\n+\/\/        System.out.println(Arrays.stream(params).map(Objects::toString)\n+\/\/                .collect(Collectors.joining(\",\")));\n+        data.add(owner, name + desc, Arrays.stream(params).map(serializer::apply)\n+                .collect(Collectors.toList()));\n+    }\n+\n+    static int countParams(String desc) {\n+        if(!desc.startsWith(\"(\")) throw new IllegalArgumentException(\"Not a method descriptor: \" + desc);\n+        int pos = 1;\n+        int count = 0;\n+        while(desc.charAt(pos) != ')') {\n+            char next = desc.charAt(pos);\n+            if(next == 'L') {\n+                int l = pos;\n+                pos = desc.indexOf(\";\", pos) + 1;\n+                count++;\n+            } else if(next == '[') {\n+                \/\/TODO can we do better?\n+                count++;\n+                if(desc.charAt(pos + 1) == 'L') pos = desc.indexOf(\";\", pos) + 1;\n+                else pos = pos + 2;\n+            } else {\n+                count++;\n+                pos++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    public static void clearData() {\n+        data.coverage().clear();\n+    }\n+\n+    public static void serializer(Serializer serializer) {\n+        Collect.serializer = serializer;\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Collect.java","additions":87,"deletions":9,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Arrays;\n@@ -37,0 +36,1 @@\n+import java.util.Objects;\n@@ -51,2 +51,15 @@\n-    public static Coverage readTemplate(Path path) throws IOException {\n-        return readImpl(path, s -> null);\n+    public static Coverage read(Path path) throws IOException {\n+        return readImpl(path, s -> s);\n+    }\n+\n+    private static List<String> split(String s) {\n+        List<String> result = new ArrayList<>();\n+        int lci = -1;\n+        for (int ci = 0; ci < s.length(); ci++) {\n+            if(s.charAt(ci) == ',') {\n+                result.add(s.substring(lci + 1, ci));\n+                lci = ci;\n+            }\n+        }\n+        result.add(s.substring(lci + 1));\n+        return result;\n@@ -56,2 +69,2 @@\n-        return Arrays.stream(s.split(\",\"))\n-                .map(v -> v.isEmpty() ? null : deserialize.apply(v))\n+        return split(s).stream()\n+                .map(v -> v.isEmpty() ? \"\" : deserialize.apply(v))\n@@ -72,0 +85,1 @@\n+        String desc = null, name = null, owner = null;\n@@ -76,3 +90,3 @@\n-                String owner = l.substring(0, classEnd);\n-                String name = l.substring(classEnd + 1, descStart);\n-                String desc = l.substring(descStart);\n+                owner = l.substring(0, classEnd);\n+                name = l.substring(classEnd + 1, descStart);\n+                desc = l.substring(descStart);\n@@ -81,1 +95,7 @@\n-                lastData.add(parse(l.substring(DATA_PREFIX.length()), deserializer));\n+                List<? extends Object> values = parse(l.substring(DATA_PREFIX.length()), deserializer);\n+                \/\/TODO this needs to be fixed for arrays\n+\/\/                if(Collect.countParams(desc) != values.size()) {\n+\/\/                    throw new IllegalStateException(\"Incorrect number of parameters for \" +\n+\/\/                            owner + \"#\" + name + desc + \": \" + values.size());\n+\/\/                }\n+                lastData.add(values);\n@@ -92,1 +112,1 @@\n-    public static final void write(Coverage coverage, Path path, Function<Object, String> serializer)\n+    public static final void write(Coverage coverage, Path path\/*, Function<Object, String> serializer*\/)\n@@ -102,0 +122,10 @@\n+                                    String desc = me.getKey().substring(me.getKey().indexOf(\"(\"));\n+                                    List<String> values = dl.stream().map(o -> (String)o)\n+                                            .collect(toList());\n+                                    if(Collect.countParams(desc) != values.size()) {\n+                                        System.err.println(\"Incorect number of params for \" + me.getKey());\n+                                        System.out.println(values.stream().map(Objects::toString)\n+                                                .collect(Collectors.joining(\",\")));\n+                                        throw new IllegalStateException(\"Incorrect number of parameters for \" +\n+                                                me.getKey() + \": \" + values.size());\n+                                    }\n@@ -103,1 +133,1 @@\n-                                            dl.stream().map(d -> serializer.apply(d))\n+                                            values.stream()\/\/.map(d -> serializer.apply(d))\n@@ -121,0 +151,2 @@\n+    private final boolean selfCompacting = true;\n+\n@@ -142,0 +174,10 @@\n+    public void add(String owner, String method, List<? extends Object> params) {\n+        List<List<? extends Object>> methodCov = get(owner, method);\n+        if(methodCov.stream().noneMatch(call -> {\n+            if(call.size() != params.size()) return false;\n+            for (int i = 0; i < call.size(); i++)\n+                if(!Objects.equals(call.get(i), params.get(i))) return false;\n+            return true;\n+        })) methodCov.add(params);\n+    }\n+\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Coverage.java","additions":53,"deletions":11,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.runtime;\n+\n+import java.util.Collection;\n+\n+public interface Implantable {\n+    Collection<Class> runtime();\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Implantable.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import openjdk.jcov.data.Instrument;\n@@ -34,0 +33,1 @@\n+import java.util.Collection;\n@@ -36,3 +36,0 @@\n-import static openjdk.jcov.data.Instrument.JCOV_DATA_ENV_PREFIX;\n-import static openjdk.jcov.data.arguments.instrument.Plugin.ARGUMENTS_PREFIX;\n-\n@@ -41,4 +38,0 @@\n-    \/**\n-     * Name of a property defining where to save the results.\n-     *\/\n-    public static final String RESULT_FILE = JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \"result\";\n@@ -49,2 +42,2 @@\n-    public static final String SERIALIZER =\n-            Instrument.JCOV_DATA_ENV_PREFIX + ARGUMENTS_PREFIX + \".serializer\";\n+\/\/    public static final String SERIALIZER = Env.JCOV_DATA_ENV_PREFIX +\n+\/\/            Collect.ARGUMENTS_PREFIX + \"serializer\";\n@@ -53,1 +46,1 @@\n-    private Function<Object, String> serializer;\n+\/\/    private Serializer serializer;\n@@ -58,2 +51,2 @@\n-        resultFile = Env.getPathEnv(RESULT_FILE, Paths.get(\"result.lst\"));\n-        serializer = Env.getSPIEnv(SERIALIZER, Object::toString);\n+        resultFile = Env.getPathEnv(Collect.COVERAGE_OUT, Paths.get(\"result.lst\"));\n+\/\/        serializer = wrap(Env.getSPIEnv(SERIALIZER, Object::toString));\n@@ -67,4 +60,16 @@\n-    public Saver serializer(Function<Object, String> serializer) {\n-        this.serializer = serializer;\n-        return this;\n-    }\n+\/\/    public Saver serializer(Function<Object, String> function) {\n+\/\/        this.serializer = wrap(function);\n+\/\/        return this;\n+\/\/    }\n+\/\/\n+\/\/    public Saver serializer(Serializer serializer) {\n+\/\/        this.serializer = serializer;\n+\/\/        return this;\n+\/\/    }\n+\/\/\n+\/\/    private static Serializer wrap(Function<Object, String> function) {\n+\/\/        if(function instanceof Serializer)\n+\/\/            return (Serializer) function;\n+\/\/        else\n+\/\/            return new NoRuntimeSerializer(function);\n+\/\/    }\n@@ -74,1 +79,2 @@\n-            Coverage.write(Collect.data, resultFile, serializer);\n+            System.out.println(\"Saving the data info \" + resultFile);\n+            Coverage.write(Collect.data, resultFile\/*, serializer*\/);\n@@ -79,0 +85,18 @@\n+\n+    public static class NoRuntimeSerializer implements Serializer {\n+        private final Function<Object, String> function;\n+\n+        public NoRuntimeSerializer(Function<Object, String> function) {\n+            this.function = function;\n+        }\n+\n+        @Override\n+        public String apply(Object o) {\n+            return function.apply(o);\n+        }\n+\n+        @Override\n+        public Collection<Class> runtime() {\n+            return null;\n+        }\n+    }\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Saver.java","additions":42,"deletions":18,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments.runtime;\n+\n+import java.util.function.Function;\n+\n+public interface Serializer extends Implantable, Function<Object, String> {\n+}\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/arguments\/runtime\/Serializer.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n-    private final Class cls;\n+    private final String cls;\n@@ -38,2 +38,11 @@\n-    public TypeDescriptor(String id, Class cls, int loadOpcode, boolean longOrDouble) {\n-        this(id, cls, loadOpcode, longOrDouble, true);\n+    public static String toVMClassName(Class cls) {\n+        return toVMClassName(cls.getName());\n+    }\n+    public static String toVMClassName(String className) {\n+        return className.replace('.','\/');\n+    }\n+    public TypeDescriptor(String id, Class cls, int loadOpcode) {\n+        this(id, toVMClassName(cls), loadOpcode);\n+    }\n+    public TypeDescriptor(String id, String cls, int loadOpcode) {\n+        this(id, cls, loadOpcode, false, false);\n@@ -42,0 +51,3 @@\n+        this(id, toVMClassName(cls), loadOpcode, longOrDouble, isPrimitive);\n+    }\n+    public TypeDescriptor(String id, String cls, int loadOpcode, boolean longOrDouble, boolean isPrimitive) {\n@@ -53,3 +65,1 @@\n-    public String clsName() { return cls.getName().replace('.','\/'); }\n-\n-    public Class cls() { return cls; }\n+    public String cls() { return cls; }\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/instrument\/TypeDescriptor.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+import openjdk.jcov.data.arguments.runtime.Implantable;\n+\n+import java.util.Collection;\n+import java.util.List;\n@@ -32,1 +36,12 @@\n-public class EnumSerializer implements Function<Object, String> {\n+public class EnumSerializer implements Function<Object, String>, Implantable {\n+\n+    private final String defaultValue;\n+\n+    public EnumSerializer(String value) {\n+        defaultValue = value;\n+    }\n+\n+    public EnumSerializer() {\n+        this(\"NOT_AN_ENUM\");\n+    }\n+\n@@ -38,1 +53,5 @@\n-            return \"\";\n+            return defaultValue;\n+    }\n+\n+    public Collection<Class> runtime() {\n+        return List.of(EnumSerializer.class);\n","filename":"plugins\/data_coverage\/src\/openjdk\/jcov\/data\/serialization\/EnumSerializer.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class EnvTest {\n+    public static final String TEST_PROPERTY = \"jcov.data.test.property\";\n+    public static final String IUNDEFINED_TEST_PROPERTY = \"jcov.data.test.property.undefined\";\n+    @Test\n+    public void defaultsTest() {\n+        assertEquals(Env.getStringEnv(TEST_PROPERTY, \"three\"), \"one\");\n+        System.setProperty(TEST_PROPERTY, \"two\");\n+        assertEquals(Env.getStringEnv(TEST_PROPERTY, \"three\"), \"two\");\n+        assertEquals(Env.getStringEnv(IUNDEFINED_TEST_PROPERTY, \"three\"), \"three\");\n+        System.setProperty(IUNDEFINED_TEST_PROPERTY, \"two\");\n+        assertEquals(Env.getStringEnv(IUNDEFINED_TEST_PROPERTY, \"three\"), \"two\");\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/EnvTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package openjdk.jcov.data.arguments;\n+\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class CoverageTest {\n+    public static final String CLASS1 = \"class1\";\n+    public static final String CLASS2 = \"class2\";\n+    public static final String METHOD11 = \"method11(Ljava\/lang\/Object;Ljava\/lang\/Object;)\";\n+    public static final String PARAM1 = \"param1\";\n+    public static final String PARAM2 = \"param2\";\n+    public static final String PARAM3 = \"param3\";\n+    public static final String PARAM4 = \"param4\";\n+    private Coverage cov = new Coverage();\n+\n+    private void assertContent(Coverage cov) {\n+        assertEquals(cov.coverage().size(), 1);\n+        assertEquals(cov.coverage().keySet().iterator().next(), CLASS1);\n+        Map<String, List<List<?>>> class1Cov = cov.coverage().values().iterator().next();\n+        assertEquals(class1Cov.size(), 1);\n+        assertEquals(class1Cov.keySet().iterator().next(), METHOD11);\n+        List<List<?>> method11Cov = class1Cov.values().iterator().next();\n+        assertEquals(method11Cov.size(), 2);\n+        assertEquals(method11Cov.get(0).get(0), PARAM1);\n+        assertEquals(method11Cov.get(0).get(1), PARAM2);\n+        assertEquals(method11Cov.get(1).get(0), PARAM3);\n+        assertEquals(method11Cov.get(1).get(1), PARAM4);\n+    }\n+\n+    @Test\n+    public void addThings() {\n+        cov.get(CLASS1, METHOD11)\n+                .add(List.of(PARAM1, PARAM2));\n+        cov.get(CLASS1, METHOD11)\n+                .add(List.of(PARAM3, PARAM4));\n+        assertContent(cov);\n+    }\n+\n+    @Test(dependsOnMethods = \"addThings\")\n+    public void saveAndLoad() throws IOException {\n+        Path temp1 = Files.createTempFile(\"coverage1.\", \".lst\");\n+        Path temp2 = Files.createTempFile(\"coverage2.\", \".lst\");\n+        Path temp3 = Files.createTempFile(\"coverage2.\", \".lst\");\n+        Coverage.write(cov, temp1);\n+        Coverage loaded1 = Coverage.read(temp1);\n+        assertContent(loaded1);\n+        Coverage.write(loaded1, temp2);\n+        Coverage loaded2 = Coverage.read(temp2);\n+        assertContent(loaded2);\n+        Coverage.write(loaded2, temp3);\n+        List<String> lines1 = Files.readAllLines(temp1);\n+        List<String> lines2 = Files.readAllLines(temp2);\n+        List<String> lines3 = Files.readAllLines(temp3);\n+        assertEquals(lines1.toArray(), lines2.toArray());\n+        assertEquals(lines1.toArray(), lines3.toArray());\n+        Files.deleteIfExists(temp1);\n+        Files.deleteIfExists(temp2);\n+        Files.deleteIfExists(temp3);\n+    }\n+\n+    @Test(dependsOnMethods = \"saveAndLoad\")\n+    public void add() {\n+        cov.add(CLASS1, METHOD11, List.of(PARAM1, PARAM2));\n+        assertContent(cov);\n+        Coverage newCov = new Coverage();\n+        newCov.add(CLASS1, METHOD11, List.of(PARAM1, PARAM2));\n+        newCov.add(CLASS1, METHOD11, List.of(PARAM3, PARAM4));\n+        assertContent(newCov);\n+        newCov.add(CLASS2, METHOD11, List.of(PARAM1));\n+        assertEquals(newCov.coverage().size(), 2);\n+        assertTrue(newCov.coverage().keySet().contains(CLASS2));\n+        Map<String, List<List<?>>> class1Cov = newCov.coverage().get(CLASS2);\n+        assertEquals(class1Cov.size(), 1);\n+        assertEquals(class1Cov.keySet().iterator().next(), METHOD11);\n+        List<List<?>> method11Cov = class1Cov.values().iterator().next();\n+        assertEquals(method11Cov.size(), 1);\n+        assertEquals(method11Cov.get(0).size(), 1);\n+        assertEquals(method11Cov.get(0).get(0), PARAM1);\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/CoverageTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import openjdk.jcov.data.arguments.instrument.Plugin;\n@@ -33,1 +32,1 @@\n-        return Plugin.parseDesc(desc).stream().anyMatch(td -> {\n+        return MethodFilter.parseDesc(desc).stream().anyMatch(td -> {\n@@ -35,1 +34,1 @@\n-                return Enum.class.isAssignableFrom(Class.forName(td.clsName().replace('\/', '.')));\n+                return Enum.class.isAssignableFrom(Class.forName(td.cls().replace('\/', '.')));\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/enums\/EnumMethodsFilter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import openjdk.jcov.data.arguments.runtime.Collect;\n@@ -32,0 +33,1 @@\n+import openjdk.jcov.data.lib.TestStatusListener;\n@@ -35,0 +37,1 @@\n+import org.testng.annotations.AfterClass;\n@@ -36,0 +39,1 @@\n+import org.testng.annotations.Listeners;\n@@ -46,0 +50,1 @@\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n@@ -47,1 +52,0 @@\n-import static openjdk.jcov.data.arguments.analysis.Reader.DESERIALIZER;\n@@ -49,1 +53,1 @@\n-import static openjdk.jcov.data.arguments.runtime.Saver.RESULT_FILE;\n+import static openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER;\n@@ -53,0 +57,1 @@\n+@Listeners({openjdk.jcov.data.lib.TestStatusListener.class})\n@@ -56,1 +61,0 @@\n-    private Path coverage;\n@@ -62,1 +66,3 @@\n-        test_dir = data_dir.resolve(\"parameter_test\");\n+        test_dir = data_dir.resolve(\"enum_test\");\n+        Util.rfrm(test_dir);\n+        Files.createDirectories(test_dir);\n@@ -64,3 +70,0 @@\n-        coverage = test_dir.resolve(\"coverage.lst\");\n-        Files.deleteIfExists(template);\n-        Files.deleteIfExists(coverage);\n@@ -75,2 +78,3 @@\n-        Env.properties(Map.of(\n-                TEMPLATE_FILE, template.toString(),\n+        Env.clear(JCOV_DATA_ENV_PREFIX);\n+        Env.setSystemProperties(Map.of(\n+                Collect.COVERAGE_OUT, template.toString(),\n@@ -82,1 +86,1 @@\n-        Coverage tmplt = Coverage.readTemplate(template);\n+        Coverage tmplt = Coverage.read(template);\n@@ -85,0 +89,1 @@\n+\n@@ -89,5 +94,5 @@\n-        Env.properties(Map.of(\n-                TEMPLATE_FILE, template.toString(),\n-                RESULT_FILE, coverage.toString(),\n-                SERIALIZER, EnumSerializer.class.getName(),\n-                DESERIALIZER, EnumDeserializer.class.getName() + \"(\" + UserCode.ENum.class.getName()+ \")\"));\n+        Env.clear(JCOV_DATA_ENV_PREFIX);\n+        Env.setSystemProperties(Map.of(\n+                Collect.COVERAGE_IN, template.toString(),\n+                Collect.COVERAGE_OUT, template.toString(),\n+                SERIALIZER, EnumSerializer.class.getName()));\n@@ -95,1 +100,1 @@\n-        Coverage res = Coverage.read(coverage, deserializer);\n+        Coverage res = Coverage.read(template, deserializer);\n@@ -109,0 +114,6 @@\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(TestStatusListener.status) {\n+            Util.rfrm(test_dir);\n+        }\n+    }\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/enums\/EnumTest.java","additions":27,"deletions":16,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-\n+        System.out.println(e);\n@@ -33,1 +33,1 @@\n-\n+        System.out.println(e);\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/enums\/UserCode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+package openjdk.jcov.data.arguments.jreinstr.filepermission;\n+\n+import openjdk.jcov.data.Env;\n+\n+import java.io.File;\n+import java.io.FilePermission;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+public class Main {\n+    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n+        System.getProperties().storeToXML(System.out, \"\");\n+        System.out.println(\"\" + Env.getSPIEnv(openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER, null));\n+        System.getProperties().entrySet().stream()\n+                .forEach(e -> System.out.println(e.getKey() + \" -> \" + e.getValue()));\n+        System.out.println(openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER + \" = \" + System.getProperties().entrySet().stream()\n+                .collect(toMap(Object::toString, Object::toString)).get(openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER));\n+        Path file = Files.createTempFile(\"test\", \".txt\");\n+        FilePermission filePermission = new FilePermission(file.toString(), \"read\");\n+        FilePermission dirPermission = new FilePermission(file.getParent().toString() + \"\/-\", \"read,write\");\n+        System.out.println(dirPermission.implies(filePermission));\n+        Files.delete(file);\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Main.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+package openjdk.jcov.data.arguments.jreinstr.filepermission;\n+\n+import openjdk.jcov.data.arguments.instrument.MethodFilter;\n+\n+import java.io.FilePermission;\n+\n+public class PermissionMethodFilter implements MethodFilter {\n+    @Override\n+    public boolean accept(int access, String owner, String name, String desc) throws Exception {\n+\/\/        return false;\n+        return openjdk.jcov.data.arguments.instrument.MethodFilter.parseDesc(desc).stream()\n+                .anyMatch(td -> td.cls().equals(FilePermission.class.getName().replace('.', '\/')));\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/PermissionMethodFilter.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+package openjdk.jcov.data.arguments.jreinstr.filepermission;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class Plugin extends openjdk.jcov.data.arguments.instrument.Plugin {\n+    public Plugin() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n+        super();\n+    }\n+\n+    @Override\n+    protected List<Class> runtimeClasses() {\n+        ArrayList<Class> result =  new ArrayList<>(super.runtimeClasses());\n+        result.add(Serializer.class);\n+        return result;\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Plugin.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+package openjdk.jcov.data.arguments.jreinstr.filepermission;\n+\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.arguments.runtime.Implantable;\n+\n+import java.io.File;\n+import java.io.FilePermission;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Set;\n+\n+public class Serializer implements openjdk.jcov.data.arguments.runtime.Serializer {\n+    @Override\n+    public String apply(Object o) {\n+        if(o instanceof FilePermission) {\n+            return ((FilePermission)o).getActions();\n+        } else return null;\n+    }\n+\n+    @Override\n+    public Collection<Class> runtime() {\n+        return Set.of(Serializer.class,\n+                Implantable.class);\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        File file = File.createTempFile(\"test\", \".txt\");\n+        file.delete();\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Serializer.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+package openjdk.jcov.data.arguments.jreinstr.filepermission;\n+\n+import openjdk.jcov.data.JREInstr;\n+import openjdk.jcov.data.arguments.runtime.Coverage;\n+import openjdk.jcov.data.arguments.runtime.Saver;\n+import openjdk.jcov.data.lib.TestStatusListener;\n+import openjdk.jcov.data.lib.Util;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+\n+import java.io.File;\n+import java.io.FilePermission;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static openjdk.jcov.data.arguments.instrument.Plugin.METHOD_FILTER;\n+import static openjdk.jcov.data.arguments.runtime.Collect.COVERAGE_OUT;\n+import static openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER;\n+import static openjdk.jcov.data.lib.Util.copyJRE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+@Listeners({TestStatusListener.class})\n+public class Test {\n+    private Path data_dir;\n+    private Path template;\n+    private Path jcov_template;\n+    private Path jcov_result;\n+    private Path jre;\n+    private Path main;\n+    private FileTime templateCreated;\n+\n+    @BeforeClass\n+    public void setup() throws IOException {\n+        jre = copyJRE(Paths.get(System.getProperty(\"test.jre\", System.getProperty(\"java.home\"))));\n+        data_dir = Paths.get(System.getProperty(\"user.dir\"));\n+        template = data_dir.resolve(\"template.lst\");\n+        jcov_template = data_dir.resolve(\"template.xml\");\n+        jcov_result = data_dir.resolve(\"result.xml\");\n+        main = data_dir.resolve(\"Main.java\");\n+    }\n+    @org.testng.annotations.Test\n+    public void instrument() throws IOException, InterruptedException {\n+        Files.deleteIfExists(jcov_template);\n+        Files.deleteIfExists(template);\n+        int status = new JREInstr()\n+                .clearEnv()\n+                .setEnv(Map.of(\n+                        COVERAGE_OUT, template.toString(),\n+                        METHOD_FILTER, PermissionMethodFilter.class.getName(),\n+                        SERIALIZER, Serializer.class.getName()))\n+                .pluginClass(Plugin.class.getName())\n+                .jcovRuntime(System.getProperty(\"jcov.file.saver.jar\"))\n+                .jcovTemplate(jcov_template.toString())\n+                .instrument(jre.toString());\n+        assertEquals(status, 0);\n+        assertTrue(Files.exists(jcov_template), \"Template file: \" + jcov_template);\n+        assertTrue(Files.exists(template), \"Template file: \" + template);\n+        templateCreated = Files.readAttributes(template, BasicFileAttributes.class).lastModifiedTime();\n+    }\n+\n+    @org.testng.annotations.Test(dependsOnMethods = \"instrument\")\n+    public void testInstrumentation() throws IOException, InterruptedException {\n+        Files.write(main, List.of(\n+                \"package openjdk.jcov.data.arguments.jreinstr.filepermission;\",\n+                \"import java.io.FilePermission;\",\n+                \"import java.io.IOException;\",\n+                \"import java.nio.file.Files;\",\n+                \"import java.nio.file.Path;\",\n+                \"public class Main {\",\n+                \"    public static void main(String[] args) throws IOException {\",\n+                \"        Path file = Files.createTempFile(\\\"test\\\", \\\".txt\\\");\",\n+                \"        FilePermission filePermission = new FilePermission(file.toString(), \\\"read\\\");\",\n+                \"        FilePermission dirPermission = new FilePermission(file.getParent().toString() + \\\"\/-\\\", \\\"read,write\\\");\",\n+                \"        System.out.println(dirPermission.implies(filePermission));\",\n+                \"        Files.delete(file);\",\n+                \"    }\",\n+                \"}\"\n+        ));\n+        Files.deleteIfExists(jcov_result);\n+        \/\/no classpath necessary for the next call because the class is implanted\n+        List<String> command = List.of(\n+                jre.toString() + File.separator + \"bin\" + File.separator + \"java\",\n+                \"-Djcov.data-saver=\" + Saver.class.getName(),\n+                main.toString());\n+        System.out.println(command.stream().collect(Collectors.joining(\" \")));\n+        Process p = new ProcessBuilder()\n+                .directory(data_dir.toFile())\n+                .command(command)\n+                .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                .start();\n+        int status = p.waitFor();\n+        assertEquals(status, 0);\n+        assertTrue(Files.exists(jcov_result), \"Result file: \" + jcov_result);\n+        assertTrue(Files.readAttributes(template, BasicFileAttributes.class).lastModifiedTime()\n+                .compareTo(templateCreated) > 0);\n+    }\n+\n+    @org.testng.annotations.Test(dependsOnMethods = \"testInstrumentation\")\n+    public void testCoverage() throws IOException, InterruptedException {\n+        Coverage cov = Coverage.read(template, a -> a);\n+        assertEquals(cov.coverage().get(FilePermission.class.getName().replace('.', '\/'))\n+                .entrySet().stream().filter(e -> e.getKey().startsWith(\"impliesIgnoreMask\"))\n+                .findAny().get().getValue().get(0).get(0), \"read\");\n+    }\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        List<Path> artifacts = List.of(template, jcov_template, template, jcov_result, jre, main);\n+        if(TestStatusListener.status)\n+            for(Path file : artifacts) Util.rfrm(file);\n+        else {\n+            System.out.println(\"Test failed, keeping the artifacts:\");\n+            artifacts.forEach(System.out::println);\n+        }\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/Test.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+package openjdk.jcov.data.arguments.jreinstr.filepermission;\n+\n+import com.sun.tdk.jcov.instrument.InstrumentationPlugin;\n+import org.objectweb.asm.MethodVisitor;\n+\n+import java.nio.file.Path;\n+\n+public class VoidPlugin implements InstrumentationPlugin {\n+\n+    public VoidPlugin() {\n+        super();\n+    }\n+\n+    @Override\n+    public MethodVisitor methodVisitor(int i, String s, String s1, String s2, MethodVisitor visitor) {\n+        return visitor;\n+    }\n+\n+    @Override\n+    public void instrumentationComplete() throws Exception {\n+\n+    }\n+\n+    @Override\n+    public Path runtime() throws Exception {\n+        return null;\n+    }\n+\n+    @Override\n+    public String collectorPackage() {\n+        return null;\n+    }\n+}\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/jreinstr\/filepermission\/VoidPlugin.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.Method;\n@@ -37,1 +36,1 @@\n-        List<Plugin.TypeDescriptor> params = Plugin.parseDesc(desc);\n+        List<Plugin.TypeDescriptor> params = MethodFilter.parseDesc(desc);\n@@ -43,1 +42,1 @@\n-                params.stream().anyMatch(td -> td.cls().isArray());\n+                params.stream().anyMatch(td -> td.id().equals(\"[\"));\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/main\/MainFilter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import openjdk.jcov.data.arguments.instrument.MethodFilter;\n+import openjdk.jcov.data.arguments.enums.EnumTest;\n@@ -31,0 +31,1 @@\n+import openjdk.jcov.data.arguments.runtime.Collect;\n@@ -33,0 +34,1 @@\n+import openjdk.jcov.data.lib.TestStatusListener;\n@@ -34,2 +36,1 @@\n-import openjdk.jcov.data.serialization.EnumDeserializer;\n-import openjdk.jcov.data.serialization.EnumSerializer;\n+import org.testng.annotations.AfterClass;\n@@ -37,0 +38,1 @@\n+import org.testng.annotations.Listeners;\n@@ -44,1 +46,0 @@\n-import java.util.Arrays;\n@@ -49,0 +50,1 @@\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n@@ -50,1 +52,0 @@\n-import static openjdk.jcov.data.arguments.analysis.Reader.DESERIALIZER;\n@@ -52,1 +53,1 @@\n-import static openjdk.jcov.data.arguments.runtime.Saver.RESULT_FILE;\n+import static openjdk.jcov.data.arguments.runtime.Collect.*;\n@@ -55,0 +56,1 @@\n+@Listeners({TestStatusListener.class})\n@@ -57,1 +59,0 @@\n-    private Path template;\n@@ -59,1 +60,0 @@\n-    private MethodFilter mainFilter;\n@@ -64,2 +64,3 @@\n-        test_dir = data_dir.resolve(\"parameter_test\");\n-        template = test_dir.resolve(\"template.lst\");\n+        test_dir = data_dir.resolve(\"main_test\");\n+        Util.rfrm(test_dir);\n+        Files.createDirectories(test_dir);\n@@ -67,6 +68,0 @@\n-        Files.deleteIfExists(template);\n-        mainFilter = new MainFilter();\n-        Env.properties(Map.of(\n-                TEMPLATE_FILE, template.toString(),\n-                JCOV_TEMPLATE, test_dir.resolve(\"template.xml\").toString(),\n-                METHOD_FILTER, MainFilter.class.getName()));\n@@ -75,0 +70,5 @@\n+        Env.clear(JCOV_DATA_ENV_PREFIX);\n+        Env.setSystemProperties(Map.of(\n+                COVERAGE_OUT, coverage.toString(),\n+                JCOV_TEMPLATE, test_dir.resolve(\"template.xml\").toString(),\n+                METHOD_FILTER, MainFilter.class.getName()));\n@@ -78,1 +78,1 @@\n-        return Coverage.readTemplate(template);\n+        return Coverage.read(coverage);\n@@ -81,0 +81,5 @@\n+    public void instrument() throws IOException, InterruptedException {\n+        Coverage tmplt = instrument(UserCode.class);\n+        assertEquals(tmplt.coverage().size(), 0);\n+    }\n+    @Test(dependsOnMethods = \"instrument\")\n@@ -87,6 +92,1 @@\n-    @Test\n-    public void instrument() throws IOException, InterruptedException {\n-        Coverage tmplt = instrument(UserCode.class);\n-        assertEquals(tmplt.coverage().size(), 0);\n-    }\n-    @Test(dependsOnMethods = \"instrument\")\n+    @Test(dependsOnMethods = \"instrumentStatic\")\n@@ -96,5 +96,5 @@\n-        Env.properties(Map.of(\n-                TEMPLATE_FILE, template.toString(),\n-                RESULT_FILE, coverage.toString(),\n-                SERIALIZER, StringArraySerializer.class.getName(),\n-                DESERIALIZER, StringArrayDeserializer.class.getName()));\n+        Env.clear(JCOV_DATA_ENV_PREFIX);\n+        Env.setSystemProperties(Map.of(\n+                COVERAGE_IN, coverage.toString(),\n+                COVERAGE_OUT, coverage.toString(),\n+                SERIALIZER, StringArraySerializer.class.getName()));\n@@ -111,0 +111,4 @@\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(TestStatusListener.status) Util.rfrm(test_dir);\n+    }\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/main\/MainTest.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import openjdk.jcov.data.arguments.runtime.Collect;\n@@ -32,0 +33,1 @@\n+import openjdk.jcov.data.lib.TestStatusListener;\n@@ -33,0 +35,1 @@\n+import org.testng.annotations.AfterClass;\n@@ -34,0 +37,1 @@\n+import org.testng.annotations.Listeners;\n@@ -38,1 +42,0 @@\n-import java.nio.file.Files;\n@@ -44,0 +47,2 @@\n+import static java.util.stream.Collectors.joining;\n+import static openjdk.jcov.data.Env.JCOV_DATA_ENV_PREFIX;\n@@ -45,2 +50,0 @@\n-import static openjdk.jcov.data.arguments.instrument.Plugin.*;\n-import static openjdk.jcov.data.arguments.runtime.Saver.RESULT_FILE;\n@@ -50,0 +53,1 @@\n+@Listeners({openjdk.jcov.data.lib.TestStatusListener.class})\n@@ -53,1 +57,0 @@\n-    Path result;\n@@ -56,2 +59,0 @@\n-        Files.deleteIfExists(Paths.get(\"template.lst\"));\n-        Files.deleteIfExists(Paths.get(\"coverage.lst\"));\n@@ -59,1 +60,2 @@\n-        test_dir = data_dir.resolve(\"parameter_test\");\n+        test_dir = data_dir.resolve(\"arguments_test\");\n+        Util.rfrm(test_dir);\n@@ -61,1 +63,0 @@\n-        result = test_dir.resolve(\"coverage.lst\");\n@@ -65,2 +66,3 @@\n-        Env.properties(Map.of(\n-                TEMPLATE_FILE, template.toString(),\n+        Env.clear(JCOV_DATA_ENV_PREFIX);\n+        Env.setSystemProperties(Map.of(\n+                Collect.COVERAGE_OUT, template.toString(),\n@@ -70,1 +72,11 @@\n-        Coverage tmpl = Coverage.readTemplate(template);\n+        Coverage tmpl = Coverage.read(template);\n+        System.out.println(\"Data:\");\n+        tmpl.coverage().entrySet().forEach(e -> {\n+            System.out.println(e.getKey() + \"->\");\n+            e.getValue().entrySet().forEach(ee -> {\n+                System.out.println(\"  \" + ee.getKey());\n+                ee.getValue().forEach(l -> {\n+                    System.out.println(l.stream().map(Object::toString).collect(joining(\",\")));\n+                });\n+            });\n+        });\n@@ -74,0 +86,1 @@\n+\n@@ -77,3 +90,3 @@\n-        Env.properties(Map.of(\n-                TEMPLATE_FILE, template.toString(),\n-                RESULT_FILE, result.toString()));\n+        Env.clear(JCOV_DATA_ENV_PREFIX);\n+        Env.setSystemProperties(Map.of(\n+                Collect.COVERAGE_OUT, template.toString()));\n@@ -81,1 +94,1 @@\n-        Coverage coverage = Coverage.read(result, a -> a);\n+        Coverage coverage = Coverage.read(template);\n@@ -88,0 +101,6 @@\n+\n+    @AfterClass\n+    public void tearDown() throws IOException {\n+        if(TestStatusListener.status)\n+            Util.rfrm(test_dir);\n+    }\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/arguments\/test\/ArgumentsTest.java","additions":34,"deletions":15,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+jcov.data.test.property=one\n\\ No newline at end of file\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/instrumentation.properties","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+package openjdk.jcov.data.lib;\n+\n+import org.testng.ITestContext;\n+import org.testng.ITestListener;\n+import org.testng.ITestResult;\n+\n+public class TestStatusListener implements ITestListener {\n+\n+    public static volatile boolean status = true;\n+\n+    @Override\n+    public void onTestStart(ITestResult result) { }\n+\n+    @Override\n+    public void onTestSuccess(ITestResult result) { }\n+\n+    @Override\n+    public void onTestFailure(ITestResult result) {\n+        status = false;\n+    }\n+\n+    @Override\n+    public void onTestSkipped(ITestResult result) { }\n+\n+    @Override\n+    public void onTestFailedButWithinSuccessPercentage(ITestResult result) { }\n+\n+    @Override\n+    public void onStart(ITestContext context) { status = true; }\n+\n+    @Override\n+    public void onFinish(ITestContext context) { }\n+}\n+\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/lib\/TestStatusListener.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -28,0 +28,3 @@\n+import openjdk.jcov.data.Env;\n+import openjdk.jcov.data.arguments.runtime.Collect;\n+import openjdk.jcov.data.arguments.runtime.Saver;\n@@ -30,0 +33,1 @@\n+import java.io.File;\n@@ -33,0 +37,1 @@\n+import java.io.UncheckedIOException;\n@@ -35,0 +40,2 @@\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n@@ -37,0 +44,2 @@\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n@@ -39,0 +48,5 @@\n+import java.util.Objects;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+\n+import static openjdk.jcov.data.arguments.runtime.Collect.SERIALIZER;\n@@ -66,0 +80,30 @@\n+    public static Path copyJRE(Path src) throws IOException {\n+        Path dest = Files.createTempDirectory(\"JDK\");\n+        System.out.println(\"Copying a JDK from \" + src + \" to \" + dest);\n+        Files.walk(src).forEach(s -> {\n+            try {\n+                Files.copy(s, dest.resolve(src.relativize(s)), StandardCopyOption.REPLACE_EXISTING);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        });\n+        return dest;\n+    }\n+\n+    public static Path createRtJar(String prefix, Class collect) throws IOException {\n+        Path dest = Files.createTempFile(prefix, \".jar\");\n+        System.out.println(prefix + \" jar: \" + dest);\n+        try(JarOutputStream jar = new JarOutputStream(Files.newOutputStream(dest))) {\n+            jar.putNextEntry(new JarEntry(collect.getName().replace(\".\", File.separator) + \".class\"));\n+            try (InputStream ci = collect.getClassLoader()\n+                    .getResourceAsStream(collect.getName().replace('.', '\/') + \".class\")) {\n+                byte[] buffer = new byte[1024];\n+                int read;\n+                while((read = ci.read(buffer)) > 0) {\n+                    jar.write(buffer, 0, read);\n+                }\n+            }\n+        }\n+        return dest;\n+    }\n+\n@@ -70,1 +114,1 @@\n-            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+            throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n@@ -75,1 +119,4 @@\n-            InvocationTargetException, IllegalAccessException {\n+            InvocationTargetException, IllegalAccessException, InstantiationException {\n+        Collect.clearData();\n+        \/\/TODO an API is really needed for this kind of usage\n+        Collect.serializer(new Saver.NoRuntimeSerializer(Env.getSPIEnv(SERIALIZER, Objects::toString)));\n@@ -109,0 +156,26 @@\n+    public static void rfrm(Path jre) throws IOException {\n+        System.out.println(\"Removing \" + jre);\n+        if(Files.isRegularFile(jre))\n+            Files.deleteIfExists(jre);\n+        else\n+            Files.walkFileTree(jre, new FileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                    Files.delete(file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                    Files.delete(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+    }\n","filename":"plugins\/data_coverage\/test\/openjdk\/jcov\/data\/lib\/Util.java","additions":75,"deletions":2,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -669,1 +669,1 @@\n-                plugin = (InstrumentationPlugin) Class.forName(opts.getValue(DSC_INSTR_PLUGIN))\n+                plugin = (InstrumentationPlugin) Class.forName(pluginClass)\n","filename":"src\/classes\/com\/sun\/tdk\/jcov\/Instr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}