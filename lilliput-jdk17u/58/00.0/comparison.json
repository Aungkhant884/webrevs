{"files":[{"patch":"@@ -11443,1 +11443,0 @@\n-\n@@ -13259,0 +13258,1 @@\n+\n@@ -13330,1 +13330,0 @@\n-\n@@ -14044,0 +14043,292 @@\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_le(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr le\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_ge(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr ge\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n@@ -16004,3 +16295,1 @@\n-instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n+\/\/ Like compI_reg_reg or compI_reg_immI0 but without match rule and second zero parameter.\n@@ -16008,2 +16297,5 @@\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+instruct compI_reg_imm0(rFlagsReg cr, iRegI src)\n+%{\n+  effect(DEF cr, USE src);\n+  ins_cost(INSN_COST);\n+  format %{ \"cmpw $src, 0\" %}\n@@ -16012,4 +16304,1 @@\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::LT);\n+    __ cmpw($src$$Register, 0);\n@@ -16017,2 +16306,1 @@\n-\n-  ins_pipe(icond_reg_reg);\n+  ins_pipe(icmp_reg_imm);\n@@ -16021,1 +16309,1 @@\n-instruct minI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct minI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -16031,20 +16319,1 @@\n-\n-\/\/ FROM HERE\n-instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n-\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n-\n-  ins_encode %{\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::GT);\n-  %}\n-\n-  ins_pipe(icond_reg_reg);\n-%}\n-\n-instruct maxI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct maxI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -16056,0 +16325,1 @@\n+\n@@ -16063,0 +16333,1 @@\n+\n@@ -16835,2 +17106,3 @@\n-       iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3,\n-       iRegINoSp tmp4, iRegINoSp tmp5, iRegINoSp tmp6, rFlagsReg cr)\n+                          iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n+                          iRegINoSp tmp3, iRegINoSp tmp4, iRegINoSp tmp5, iRegINoSp tmp6,\n+                          vRegD_V0 vtmp0, vRegD_V1 vtmp1, rFlagsReg cr)\n@@ -16841,2 +17113,4 @@\n-         TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, TEMP tmp6, KILL cr);\n-  format %{ \"String IndexOf $str1,$cnt1,$str2,$cnt2 -> $result (UU)\" %}\n+         TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, TEMP tmp6,\n+         TEMP vtmp0, TEMP vtmp1, KILL cr);\n+  format %{ \"String IndexOf $str1,$cnt1,$str2,$cnt2 -> $result (UU) \"\n+            \"# KILL $str1 $cnt1 $str2 $cnt2 $tmp1 $tmp2 $tmp3 $tmp4 $tmp5 $tmp6 V0-V1 cr\" %}\n@@ -16856,2 +17130,3 @@\n-       iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3,\n-       iRegINoSp tmp4, iRegINoSp tmp5, iRegINoSp tmp6, rFlagsReg cr)\n+                          iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3,\n+                          iRegINoSp tmp4, iRegINoSp tmp5, iRegINoSp tmp6,\n+                          vRegD_V0 vtmp0, vRegD_V1 vtmp1, rFlagsReg cr)\n@@ -16862,2 +17137,4 @@\n-         TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, TEMP tmp6, KILL cr);\n-  format %{ \"String IndexOf $str1,$cnt1,$str2,$cnt2 -> $result (LL)\" %}\n+         TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, TEMP tmp6,\n+         TEMP vtmp0, TEMP vtmp1, KILL cr);\n+  format %{ \"String IndexOf $str1,$cnt1,$str2,$cnt2 -> $result (LL) \"\n+            \"# KILL $str1 $cnt1 $str2 $cnt2 $tmp1 $tmp2 $tmp3 $tmp4 $tmp5 $tmp6 V0-V1 cr\" %}\n@@ -16877,2 +17154,3 @@\n-       iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2, iRegINoSp tmp3,\n-       iRegINoSp tmp4, iRegINoSp tmp5, iRegINoSp tmp6, rFlagsReg cr)\n+                          iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,iRegINoSp tmp3,\n+                          iRegINoSp tmp4, iRegINoSp tmp5, iRegINoSp tmp6,\n+                          vRegD_V0 vtmp0, vRegD_V1 vtmp1, rFlagsReg cr)\n@@ -16883,2 +17161,4 @@\n-         TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, TEMP tmp6, KILL cr);\n-  format %{ \"String IndexOf $str1,$cnt1,$str2,$cnt2 -> $result (UL)\" %}\n+         TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,\n+         TEMP tmp6, TEMP vtmp0, TEMP vtmp1, KILL cr);\n+  format %{ \"String IndexOf $str1,$cnt1,$str2,$cnt2 -> $result (UL) \"\n+            \"# KILL $str1 cnt1 $str2 $cnt2 $tmp1 $tmp2 $tmp3 $tmp4 $tmp5 $tmp6 V0-V1 cr\" %}\n@@ -16898,2 +17178,2 @@\n-                 immI_le_4 int_cnt2, iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n-                 iRegINoSp tmp3, iRegINoSp tmp4, rFlagsReg cr)\n+                              immI_le_4 int_cnt2, iRegI_R0 result, iRegINoSp tmp1,\n+                              iRegINoSp tmp2, iRegINoSp tmp3, iRegINoSp tmp4, rFlagsReg cr)\n@@ -16905,1 +17185,2 @@\n-  format %{ \"String IndexOf $str1,$cnt1,$str2,$int_cnt2 -> $result (UU)\" %}\n+  format %{ \"String IndexOf $str1,$cnt1,$str2,$int_cnt2 -> $result (UU) \"\n+            \"# KILL $str1 $cnt1 $str2 $tmp1 $tmp2 $tmp3 $tmp4 cr\" %}\n@@ -16919,2 +17200,2 @@\n-                 immI_le_4 int_cnt2, iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n-                 iRegINoSp tmp3, iRegINoSp tmp4, rFlagsReg cr)\n+                              immI_le_4 int_cnt2, iRegI_R0 result, iRegINoSp tmp1,\n+                              iRegINoSp tmp2, iRegINoSp tmp3, iRegINoSp tmp4, rFlagsReg cr)\n@@ -16926,1 +17207,2 @@\n-  format %{ \"String IndexOf $str1,$cnt1,$str2,$int_cnt2 -> $result (LL)\" %}\n+  format %{ \"String IndexOf $str1,$cnt1,$str2,$int_cnt2 -> $result (LL) \"\n+            \"# KILL $str1 $cnt1 $str2 $tmp1 $tmp2 $tmp3 $tmp4 cr\" %}\n@@ -16940,2 +17222,2 @@\n-                 immI_1 int_cnt2, iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n-                 iRegINoSp tmp3, iRegINoSp tmp4, rFlagsReg cr)\n+                              immI_1 int_cnt2, iRegI_R0 result, iRegINoSp tmp1,\n+                              iRegINoSp tmp2, iRegINoSp tmp3, iRegINoSp tmp4, rFlagsReg cr)\n@@ -16947,1 +17229,2 @@\n-  format %{ \"String IndexOf $str1,$cnt1,$str2,$int_cnt2 -> $result (UL)\" %}\n+  format %{ \"String IndexOf $str1,$cnt1,$str2,$int_cnt2 -> $result (UL) \"\n+            \"# KILL $str1 $cnt1 $str2 $tmp1 $tmp2 $tmp3 $tmp4 cr\" %}\n@@ -17032,0 +17315,2 @@\n+                       vRegD_V0 vtmp0, vRegD_V1 vtmp1, vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n+                       vRegD_V4 vtmp4, vRegD_V5 vtmp5, vRegD_V6 vtmp6, vRegD_V7 vtmp7,\n@@ -17036,1 +17321,3 @@\n-  effect(KILL tmp, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  effect(KILL tmp, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, TEMP tmp3,\n+         TEMP vtmp0, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP vtmp5,\n+         TEMP vtmp6, TEMP vtmp7, KILL cr);\n@@ -17038,1 +17325,1 @@\n-  format %{ \"Array Equals $ary1,ary2 -> $result    \/\/ KILL $tmp\" %}\n+  format %{ \"Array Equals $ary1,ary2 -> $result # KILL $ary1 $ary2 $tmp $tmp1 $tmp2 $tmp3 V0-V7 cr\" %}\n@@ -17053,0 +17340,2 @@\n+                       vRegD_V0 vtmp0, vRegD_V1 vtmp1, vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n+                       vRegD_V4 vtmp4, vRegD_V5 vtmp5, vRegD_V6 vtmp6, vRegD_V7 vtmp7,\n@@ -17057,1 +17346,3 @@\n-  effect(KILL tmp, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+  effect(KILL tmp, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, TEMP tmp3,\n+         TEMP vtmp0, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP vtmp5,\n+         TEMP vtmp6, TEMP vtmp7, KILL cr);\n@@ -17059,1 +17350,1 @@\n-  format %{ \"Array Equals $ary1,ary2 -> $result    \/\/ KILL $tmp\" %}\n+  format %{ \"Array Equals $ary1,ary2 -> $result # KILL $ary1 $ary2 $tmp $tmp1 $tmp2 $tmp3 V0-V7 cr\" %}\n@@ -17089,2 +17380,2 @@\n-                         vRegD_V0 tmp1, vRegD_V1 tmp2,\n-                         vRegD_V2 tmp3, vRegD_V3 tmp4,\n+                         vRegD_V0 vtmp0, vRegD_V1 vtmp1, vRegD_V2 vtmp2,\n+                         vRegD_V3 vtmp3, vRegD_V4 vtmp4, vRegD_V5 vtmp5,\n@@ -17094,1 +17385,2 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n+  effect(TEMP vtmp0, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP vtmp5,\n+         USE_KILL src, USE_KILL dst, USE len, KILL cr);\n@@ -17096,1 +17388,1 @@\n-  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL R1, R2, R3, R4\" %}\n+  format %{ \"String Compress $src,$dst,$len -> $result # KILL $src $dst V0-V5 cr\" %}\n@@ -17099,3 +17391,3 @@\n-                           $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n-                           $tmp3$$FloatRegister, $tmp4$$FloatRegister,\n-                           $result$$Register);\n+                           $result$$Register, $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                           $vtmp2$$FloatRegister, $vtmp3$$FloatRegister,\n+                           $vtmp4$$FloatRegister, $vtmp5$$FloatRegister);\n@@ -17103,1 +17395,1 @@\n-  ins_pipe( pipe_slow );\n+  ins_pipe(pipe_slow);\n@@ -17107,2 +17399,3 @@\n-instruct string_inflate(Universe dummy, iRegP_R0 src, iRegP_R1 dst, iRegI_R2 len,\n-                        vRegD_V0 tmp1, vRegD_V1 tmp2, vRegD_V2 tmp3, iRegP_R3 tmp4, rFlagsReg cr)\n+instruct string_inflate(Universe dummy, iRegP_R0 src, iRegP_R1 dst, iRegI_R2 len, iRegP_R3 tmp,\n+                        vRegD_V0 vtmp0, vRegD_V1 vtmp1, vRegD_V2 vtmp2, vRegD_V3 vtmp3,\n+                        vRegD_V4 vtmp4, vRegD_V5 vtmp5, vRegD_V6 vtmp6, rFlagsReg cr)\n@@ -17111,1 +17404,3 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n+  effect(TEMP vtmp0, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3,\n+         TEMP vtmp4, TEMP vtmp5, TEMP vtmp6, TEMP tmp,\n+         USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n@@ -17113,1 +17408,1 @@\n-  format %{ \"String Inflate $src,$dst    \/\/ KILL $tmp1, $tmp2\" %}\n+  format %{ \"String Inflate $src,$dst # KILL $tmp $src $dst $len V0-V6 cr\" %}\n@@ -17116,2 +17411,2 @@\n-                                        $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n-                                        $tmp3$$FloatRegister, $tmp4$$Register);\n+                                        $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                                        $vtmp2$$FloatRegister, $tmp$$Register);\n@@ -17128,2 +17423,2 @@\n-                          vRegD_V0 Vtmp1, vRegD_V1 Vtmp2,\n-                          vRegD_V2 Vtmp3, vRegD_V3 Vtmp4,\n+                          vRegD_V0 vtmp0, vRegD_V1 vtmp1, vRegD_V2 vtmp2,\n+                          vRegD_V3 vtmp3, vRegD_V4 vtmp4, vRegD_V5 vtmp5,\n@@ -17134,2 +17429,2 @@\n-  effect(USE_KILL src, USE_KILL dst, USE_KILL len,\n-         KILL Vtmp1, KILL Vtmp2, KILL Vtmp3, KILL Vtmp4, KILL cr);\n+  effect(USE_KILL src, USE_KILL dst, USE len, KILL vtmp0, KILL vtmp1,\n+         KILL vtmp2, KILL vtmp3, KILL vtmp4, KILL vtmp5, KILL cr);\n@@ -17137,1 +17432,1 @@\n-  format %{ \"Encode array $src,$dst,$len -> $result\" %}\n+  format %{ \"Encode ISO array $src,$dst,$len -> $result # KILL $src $dst V0-V5 cr\" %}\n@@ -17140,2 +17435,4 @@\n-         $result$$Register, $Vtmp1$$FloatRegister,  $Vtmp2$$FloatRegister,\n-         $Vtmp3$$FloatRegister,  $Vtmp4$$FloatRegister);\n+                        $result$$Register, false,\n+                        $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                        $vtmp2$$FloatRegister, $vtmp3$$FloatRegister,\n+                        $vtmp4$$FloatRegister, $vtmp5$$FloatRegister);\n@@ -17143,1 +17440,22 @@\n-  ins_pipe( pipe_class_memory );\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct encode_ascii_array(iRegP_R2 src, iRegP_R1 dst, iRegI_R3 len,\n+                            vRegD_V0 vtmp0, vRegD_V1 vtmp1, vRegD_V2 vtmp2,\n+                            vRegD_V3 vtmp3, vRegD_V4 vtmp4, vRegD_V5 vtmp5,\n+                            iRegI_R0 result, rFlagsReg cr)\n+%{\n+  predicate(((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(USE_KILL src, USE_KILL dst, USE len, KILL vtmp0, KILL vtmp1,\n+         KILL vtmp2, KILL vtmp3, KILL vtmp4, KILL vtmp5, KILL cr);\n+\n+  format %{ \"Encode ASCII array $src,$dst,$len -> $result # KILL $src $dst V0-V5 cr\" %}\n+  ins_encode %{\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n+                        $result$$Register, true,\n+                        $vtmp0$$FloatRegister, $vtmp1$$FloatRegister,\n+                        $vtmp2$$FloatRegister, $vtmp3$$FloatRegister,\n+                        $vtmp4$$FloatRegister, $vtmp5$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_memory);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":399,"deletions":81,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -4560,0 +4560,2 @@\n+\/\/ Clobbers: rscratch1, rscratch2, rflags\n+\/\/ May also clobber v0-v7 when (!UseSimpleArrayEquals && UseSIMDForArrayEquals)\n@@ -5077,2 +5079,19 @@\n-\/\/ Intrinsic for sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray and\n-\/\/ java\/lang\/StringUTF16.compress.\n+\/\/ Intrinsic for\n+\/\/\n+\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n+\/\/     return the number of characters copied.\n+\/\/ - java\/lang\/StringUTF16.compress\n+\/\/     return zero (0) if copy fails, otherwise 'len'.\n+\/\/\n+\/\/ This version always returns the number of characters copied, and does not\n+\/\/ clobber the 'len' register. A successful copy will complete with the post-\n+\/\/ condition: 'res' == 'len', while an unsuccessful copy will exit with the\n+\/\/ post-condition: 0 <= 'res' < 'len'.\n+\/\/\n+\/\/ NOTE: Attempts to use 'ld2' (and 'umaxv' in the ISO part) has proven to\n+\/\/       degrade performance (on Ampere Altra - Neoverse N1), to an extent\n+\/\/       beyond the acceptable, even though the footprint would be smaller.\n+\/\/       Using 'umaxv' in the ASCII-case comes with a small penalty but does\n+\/\/       avoid additional bloat.\n+\/\/\n+\/\/ Clobbers: src, dst, res, rscratch1, rscratch2, rflags\n@@ -5080,3 +5099,4 @@\n-                      Register len, Register result,\n-                      FloatRegister Vtmp1, FloatRegister Vtmp2,\n-                      FloatRegister Vtmp3, FloatRegister Vtmp4)\n+                                      Register len, Register res, bool ascii,\n+                                      FloatRegister vtmp0, FloatRegister vtmp1,\n+                                      FloatRegister vtmp2, FloatRegister vtmp3,\n+                                      FloatRegister vtmp4, FloatRegister vtmp5)\n@@ -5084,97 +5104,8 @@\n-    Label DONE, SET_RESULT, NEXT_32, NEXT_32_PRFM, LOOP_8, NEXT_8, LOOP_1, NEXT_1,\n-        NEXT_32_START, NEXT_32_PRFM_START;\n-    Register tmp1 = rscratch1, tmp2 = rscratch2;\n-\n-      mov(result, len); \/\/ Save initial len\n-\n-      cmp(len, (u1)8); \/\/ handle shortest strings first\n-      br(LT, LOOP_1);\n-      cmp(len, (u1)32);\n-      br(LT, NEXT_8);\n-      \/\/ The following code uses the SIMD 'uzp1' and 'uzp2' instructions\n-      \/\/ to convert chars to bytes\n-      if (SoftwarePrefetchHintDistance >= 0) {\n-        ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-        subs(tmp2, len, SoftwarePrefetchHintDistance\/2 + 16);\n-        br(LE, NEXT_32_START);\n-        b(NEXT_32_PRFM_START);\n-        BIND(NEXT_32_PRFM);\n-          ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-        BIND(NEXT_32_PRFM_START);\n-          prfm(Address(src, SoftwarePrefetchHintDistance));\n-          orr(v4, T16B, Vtmp1, Vtmp2);\n-          orr(v5, T16B, Vtmp3, Vtmp4);\n-          uzp1(Vtmp1, T16B, Vtmp1, Vtmp2);\n-          uzp1(Vtmp3, T16B, Vtmp3, Vtmp4);\n-          uzp2(v5, T16B, v4, v5); \/\/ high bytes\n-          umov(tmp2, v5, D, 1);\n-          fmovd(tmp1, v5);\n-          orr(tmp1, tmp1, tmp2);\n-          cbnz(tmp1, LOOP_8);\n-          stpq(Vtmp1, Vtmp3, dst);\n-          sub(len, len, 32);\n-          add(dst, dst, 32);\n-          add(src, src, 64);\n-          subs(tmp2, len, SoftwarePrefetchHintDistance\/2 + 16);\n-          br(GE, NEXT_32_PRFM);\n-          cmp(len, (u1)32);\n-          br(LT, LOOP_8);\n-        BIND(NEXT_32);\n-          ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-        BIND(NEXT_32_START);\n-      } else {\n-        BIND(NEXT_32);\n-          ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);\n-      }\n-      prfm(Address(src, SoftwarePrefetchHintDistance));\n-      uzp1(v4, T16B, Vtmp1, Vtmp2);\n-      uzp1(v5, T16B, Vtmp3, Vtmp4);\n-      orr(Vtmp1, T16B, Vtmp1, Vtmp2);\n-      orr(Vtmp3, T16B, Vtmp3, Vtmp4);\n-      uzp2(Vtmp1, T16B, Vtmp1, Vtmp3); \/\/ high bytes\n-      umov(tmp2, Vtmp1, D, 1);\n-      fmovd(tmp1, Vtmp1);\n-      orr(tmp1, tmp1, tmp2);\n-      cbnz(tmp1, LOOP_8);\n-      stpq(v4, v5, dst);\n-      sub(len, len, 32);\n-      add(dst, dst, 32);\n-      add(src, src, 64);\n-      cmp(len, (u1)32);\n-      br(GE, NEXT_32);\n-      cbz(len, DONE);\n-\n-    BIND(LOOP_8);\n-      cmp(len, (u1)8);\n-      br(LT, LOOP_1);\n-    BIND(NEXT_8);\n-      ld1(Vtmp1, T8H, src);\n-      uzp1(Vtmp2, T16B, Vtmp1, Vtmp1); \/\/ low bytes\n-      uzp2(Vtmp3, T16B, Vtmp1, Vtmp1); \/\/ high bytes\n-      fmovd(tmp1, Vtmp3);\n-      cbnz(tmp1, NEXT_1);\n-      strd(Vtmp2, dst);\n-\n-      sub(len, len, 8);\n-      add(dst, dst, 8);\n-      add(src, src, 16);\n-      cmp(len, (u1)8);\n-      br(GE, NEXT_8);\n-\n-    BIND(LOOP_1);\n-\n-    cbz(len, DONE);\n-    BIND(NEXT_1);\n-      ldrh(tmp1, Address(post(src, 2)));\n-      tst(tmp1, 0xff00);\n-      br(NE, SET_RESULT);\n-      strb(tmp1, Address(post(dst, 1)));\n-      subs(len, len, 1);\n-      br(GT, NEXT_1);\n-\n-    BIND(SET_RESULT);\n-      sub(result, result, len); \/\/ Return index where we stopped\n-                                \/\/ Return len == 0 if we processed all\n-                                \/\/ characters\n-    BIND(DONE);\n-}\n+  Register cnt = res;\n+  Register max = rscratch1;\n+  Register chk = rscratch2;\n+\n+  prfm(Address(src), PLDL1STRM);\n+  movw(cnt, len);\n+\n+#define ASCII(insn) do { if (ascii) { insn; } } while (0)\n@@ -5182,0 +5113,80 @@\n+  Label LOOP_32, DONE_32, FAIL_32;\n+\n+  BIND(LOOP_32);\n+  {\n+    cmpw(cnt, 32);\n+    br(LT, DONE_32);\n+    ld1(vtmp0, vtmp1, vtmp2, vtmp3, T8H, Address(post(src, 64)));\n+    \/\/ Extract lower bytes.\n+    FloatRegister vlo0 = vtmp4;\n+    FloatRegister vlo1 = vtmp5;\n+    uzp1(vlo0, T16B, vtmp0, vtmp1);\n+    uzp1(vlo1, T16B, vtmp2, vtmp3);\n+    \/\/ Merge bits...\n+    orr(vtmp0, T16B, vtmp0, vtmp1);\n+    orr(vtmp2, T16B, vtmp2, vtmp3);\n+    \/\/ Extract merged upper bytes.\n+    FloatRegister vhix = vtmp0;\n+    uzp2(vhix, T16B, vtmp0, vtmp2);\n+    \/\/ ISO-check on hi-parts (all zero).\n+    \/\/                          ASCII-check on lo-parts (no sign).\n+    FloatRegister vlox = vtmp1; \/\/ Merge lower bytes.\n+                                ASCII(orr(vlox, T16B, vlo0, vlo1));\n+    umov(chk, vhix, D, 1);      ASCII(cmlt(vlox, T16B, vlox));\n+    fmovd(max, vhix);           ASCII(umaxv(vlox, T16B, vlox));\n+    orr(chk, chk, max);         ASCII(umov(max, vlox, B, 0));\n+                                ASCII(orr(chk, chk, max));\n+    cbnz(chk, FAIL_32);\n+    subw(cnt, cnt, 32);\n+    st1(vlo0, vlo1, T16B, Address(post(dst, 32)));\n+    b(LOOP_32);\n+  }\n+  BIND(FAIL_32);\n+  sub(src, src, 64);\n+  BIND(DONE_32);\n+\n+  Label LOOP_8, SKIP_8;\n+\n+  BIND(LOOP_8);\n+  {\n+    cmpw(cnt, 8);\n+    br(LT, SKIP_8);\n+    FloatRegister vhi = vtmp0;\n+    FloatRegister vlo = vtmp1;\n+    ld1(vtmp3, T8H, src);\n+    uzp1(vlo, T16B, vtmp3, vtmp3);\n+    uzp2(vhi, T16B, vtmp3, vtmp3);\n+    \/\/ ISO-check on hi-parts (all zero).\n+    \/\/                          ASCII-check on lo-parts (no sign).\n+                                ASCII(cmlt(vtmp2, T16B, vlo));\n+    fmovd(chk, vhi);            ASCII(umaxv(vtmp2, T16B, vtmp2));\n+                                ASCII(umov(max, vtmp2, B, 0));\n+                                ASCII(orr(chk, chk, max));\n+    cbnz(chk, SKIP_8);\n+\n+    strd(vlo, Address(post(dst, 8)));\n+    subw(cnt, cnt, 8);\n+    add(src, src, 16);\n+    b(LOOP_8);\n+  }\n+  BIND(SKIP_8);\n+\n+#undef ASCII\n+\n+  Label LOOP, DONE;\n+\n+  cbz(cnt, DONE);\n+  BIND(LOOP);\n+  {\n+    Register chr = rscratch1;\n+    ldrh(chr, Address(post(src, 2)));\n+    tst(chr, ascii ? 0xff80 : 0xff00);\n+    br(NE, DONE);\n+    strb(chr, Address(post(dst, 1)));\n+    subs(cnt, cnt, 1);\n+    br(GT, LOOP);\n+  }\n+  BIND(DONE);\n+  \/\/ Return index where we stopped.\n+  subw(res, len, cnt);\n+}\n@@ -5184,0 +5195,1 @@\n+\/\/ Clobbers: src, dst, len, rflags, rscratch1, v0-v6\n@@ -5290,7 +5302,8 @@\n-                                         FloatRegister tmp1Reg, FloatRegister tmp2Reg,\n-                                         FloatRegister tmp3Reg, FloatRegister tmp4Reg,\n-                                         Register result) {\n-  encode_iso_array(src, dst, len, result,\n-                   tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg);\n-  cmp(len, zr);\n-  csel(result, result, zr, EQ);\n+                                         Register res,\n+                                         FloatRegister tmp0, FloatRegister tmp1,\n+                                         FloatRegister tmp2, FloatRegister tmp3,\n+                                         FloatRegister tmp4, FloatRegister tmp5) {\n+  encode_iso_array(src, dst, len, res, false, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5);\n+  \/\/ Adjust result: res == len ? len : 0\n+  cmp(len, res);\n+  csel(res, res, zr, EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":122,"deletions":109,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -1277,3 +1277,4 @@\n-                           FloatRegister tmp1Reg, FloatRegister tmp2Reg,\n-                           FloatRegister tmp3Reg, FloatRegister tmp4Reg,\n-                           Register result);\n+                           Register res,\n+                           FloatRegister vtmp0, FloatRegister vtmp1,\n+                           FloatRegister vtmp2, FloatRegister vtmp3,\n+                           FloatRegister vtmp4, FloatRegister vtmp5);\n@@ -1282,3 +1283,5 @@\n-                        Register len, Register result,\n-                        FloatRegister Vtmp1, FloatRegister Vtmp2,\n-                        FloatRegister Vtmp3, FloatRegister Vtmp4);\n+                        Register len, Register res, bool ascii,\n+                        FloatRegister vtmp0, FloatRegister vtmp1,\n+                        FloatRegister vtmp2, FloatRegister vtmp3,\n+                        FloatRegister vtmp4, FloatRegister vtmp5);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -774,1 +774,0 @@\n-  __ flush();\n@@ -2379,1 +2378,1 @@\n-#ifdef ASSERT0\n+#ifdef ASSERT\n@@ -2381,2 +2380,1 @@\n-    __ ldr(rscratch1, Address(rthread,\n-                              JavaThread::last_Java_fp_offset()));\n+    __ ldr(rscratch1, Address(rthread, JavaThread::last_Java_fp_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1751,6 +1751,0 @@\n-  \/\/ We might be moving to a safepoint.  The thread which calls\n-  \/\/ Interpreter::notice_safepoints() will effectively flush its cache\n-  \/\/ when it makes a system call, but we need to do something to\n-  \/\/ ensure that we see the changed dispatch table.\n-  __ membar(MacroAssembler::LoadLoad);\n-\n@@ -1972,6 +1966,0 @@\n-  \/\/ We might be moving to a safepoint.  The thread which calls\n-  \/\/ Interpreter::notice_safepoints() will effectively flush its cache\n-  \/\/ when it makes a system call, but we need to do something to\n-  \/\/ ensure that we see the changed dispatch table.\n-  __ membar(MacroAssembler::LoadLoad);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3542,1 +3542,1 @@\n-  __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -8027,5 +8027,7 @@\n-  BIND(L_wordByWord);\n-  jcc(Assembler::greaterEqual, L_byteByByteProlog);\n-    crc32(in_out, Address(in1, 0), 4);\n-    addq(in1, 4);\n-    jmp(L_wordByWord);\n+  jccb(Assembler::greaterEqual, L_byteByByteProlog);\n+  align(16);\n+  BIND(L_wordByWord);\n+    crc32(in_out, Address(in1, 0), 8);\n+    addq(in1, 8);\n+    cmpq(in1, tmp1);\n+    jcc(Assembler::less, L_wordByWord);\n@@ -8038,1 +8040,0 @@\n-  BIND(L_byteByByte);\n@@ -8041,0 +8042,1 @@\n+  BIND(L_byteByByte);\n@@ -8044,1 +8046,2 @@\n-    jmp(L_byteByByte);\n+    cmpl(tmp2, in2);\n+    jcc(Assembler::lessEqual, L_byteByByte);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -978,0 +978,2 @@\n+  void ev_add128(XMMRegister xmmdst, XMMRegister xmmsrc1, XMMRegister xmmsrc2,\n+                 int vector_len, KRegister ktmp, Register rscratch = noreg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1001,1 +1001,0 @@\n-  __ flush();\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1035,1 +1035,0 @@\n-  __ flush();\n@@ -3736,0 +3735,2 @@\n+  int divisor = sizeof(julong) * 4;\n+  guarantee(longwords <= 8192 \/ divisor, \"must be\");\n@@ -3737,1 +3738,0 @@\n-  guarantee(total_allocation <= 8192, \"must be\");\n@@ -3765,0 +3765,2 @@\n+  int divisor = sizeof(julong) * 3;\n+  guarantee(longwords <= (8192 \/ divisor), \"must be\");\n@@ -3766,1 +3768,0 @@\n-  guarantee(total_allocation <= 8192, \"must be\");\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,3 @@\n+#ifdef RISCV\n+      assert(false, \"lir_cmove is LIR_Op4 on RISCV\");\n+#endif\n@@ -241,0 +244,3 @@\n+#ifdef RISCV\n+  : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)\n+#else\n@@ -243,0 +249,1 @@\n+#endif\n@@ -250,0 +257,3 @@\n+#ifdef RISCV\n+  LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)\n+#else\n@@ -252,0 +262,1 @@\n+#endif\n@@ -259,0 +270,3 @@\n+#ifdef RISCV\n+  : LIR_Op2(lir_cond_float_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)\n+#else\n@@ -261,0 +275,1 @@\n+#endif\n@@ -282,7 +297,7 @@\n-  switch (_cond) {\n-    case lir_cond_equal:        _cond = lir_cond_notEqual;     break;\n-    case lir_cond_notEqual:     _cond = lir_cond_equal;        break;\n-    case lir_cond_less:         _cond = lir_cond_greaterEqual; break;\n-    case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;\n-    case lir_cond_greaterEqual: _cond = lir_cond_less;         break;\n-    case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;\n+  switch (cond()) {\n+    case lir_cond_equal:        set_cond(lir_cond_notEqual);     break;\n+    case lir_cond_notEqual:     set_cond(lir_cond_equal);        break;\n+    case lir_cond_less:         set_cond(lir_cond_greaterEqual); break;\n+    case lir_cond_lessEqual:    set_cond(lir_cond_greater);      break;\n+    case lir_cond_greaterEqual: set_cond(lir_cond_less);         break;\n+    case lir_cond_greater:      set_cond(lir_cond_lessEqual);    break;\n@@ -516,0 +531,9 @@\n+#ifdef RISCV\n+      assert(opBranch->_tmp1->is_illegal() && opBranch->_tmp2->is_illegal() &&\n+             opBranch->_tmp3->is_illegal() && opBranch->_tmp4->is_illegal() &&\n+             opBranch->_tmp5->is_illegal(), \"not used\");\n+\n+      if (opBranch->_opr1->is_valid()) do_input(opBranch->_opr1);\n+      if (opBranch->_opr2->is_valid()) do_input(opBranch->_opr2);\n+#endif\n+\n@@ -604,0 +628,15 @@\n+#ifdef RISCV\n+      assert(op->as_Op4() != NULL, \"must be\");\n+      LIR_Op4* op4 = (LIR_Op4*)op;\n+\n+      assert(op4->_info == NULL && op4->_tmp1->is_illegal() && op4->_tmp2->is_illegal() &&\n+             op4->_tmp3->is_illegal() && op4->_tmp4->is_illegal() && op4->_tmp5->is_illegal(), \"not used\");\n+      assert(op4->_opr1->is_valid() && op4->_opr2->is_valid() && op4->_result->is_valid(), \"used\");\n+\n+      do_input(op4->_opr1);\n+      do_input(op4->_opr2);\n+      if (op4->_opr3->is_valid()) do_input(op4->_opr3);\n+      if (op4->_opr4->is_valid()) do_input(op4->_opr4);\n+      do_temp(op4->_opr2);\n+      do_output(op4->_result);\n+#else\n@@ -615,0 +654,1 @@\n+#endif\n@@ -1059,0 +1099,6 @@\n+#ifdef RISCV\n+void LIR_Op4::emit_code(LIR_Assembler* masm) {\n+  masm->emit_op4(this);\n+}\n+#endif\n+\n@@ -1102,0 +1148,4 @@\n+#ifdef RISCV\n+  , _cmp_opr1(LIR_OprFact::illegalOpr)\n+  , _cmp_opr2(LIR_OprFact::illegalOpr)\n+#endif\n@@ -1119,0 +1169,32 @@\n+#ifdef RISCV\n+void LIR_List::set_cmp_oprs(LIR_Op* op) {\n+  switch (op->code()) {\n+    case lir_cmp:\n+      _cmp_opr1 = op->as_Op2()->in_opr1();\n+      _cmp_opr2 = op->as_Op2()->in_opr2();\n+      break;\n+    case lir_branch: \/\/ fall through\n+    case lir_cond_float_branch:\n+      assert(op->as_OpBranch()->cond() == lir_cond_always ||\n+            (_cmp_opr1 != LIR_OprFact::illegalOpr && _cmp_opr2 != LIR_OprFact::illegalOpr),\n+            \"conditional branches must have legal operands\");\n+      if (op->as_OpBranch()->cond() != lir_cond_always) {\n+        op->as_Op2()->set_in_opr1(_cmp_opr1);\n+        op->as_Op2()->set_in_opr2(_cmp_opr2);\n+      }\n+      break;\n+    case lir_cmove:\n+      op->as_Op4()->set_in_opr3(_cmp_opr1);\n+      op->as_Op4()->set_in_opr4(_cmp_opr2);\n+      break;\n+#if INCLUDE_ZGC\n+    case lir_zloadbarrier_test:\n+      _cmp_opr1 = FrameMap::as_opr(t1);\n+      _cmp_opr2 = LIR_OprFact::intConst(0);\n+      break;\n+#endif\n+    default:\n+      break;\n+  }\n+}\n+#endif\n@@ -1849,0 +1931,4 @@\n+#ifdef RISCV\n+  in_opr1()->print(out); out->print(\" \");\n+  in_opr2()->print(out); out->print(\" \");\n+#endif\n@@ -1935,0 +2021,3 @@\n+#ifdef RISCV\n+  if (code() == lir_cmp || code() == lir_branch || code() == lir_cond_float_branch) {\n+#else\n@@ -1936,0 +2025,1 @@\n+#endif\n@@ -1986,0 +2076,11 @@\n+#ifdef RISCV\n+\/\/ LIR_Op4\n+void LIR_Op4::print_instr(outputStream* out) const {\n+  print_condition(out, condition()); out->print(\" \");\n+  in_opr1()->print(out);             out->print(\" \");\n+  in_opr2()->print(out);             out->print(\" \");\n+  in_opr3()->print(out);             out->print(\" \");\n+  in_opr4()->print(out);             out->print(\" \");\n+  result_opr()->print(out);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":109,"deletions":8,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -872,0 +872,3 @@\n+#ifdef RISCV\n+class    LIR_Op4;\n+#endif\n@@ -917,0 +920,1 @@\n+#ifndef RISCV\n@@ -919,0 +923,1 @@\n+#endif\n@@ -929,0 +934,4 @@\n+#ifdef RISCV\n+      , lir_branch\n+      , lir_cond_float_branch\n+#endif\n@@ -933,0 +942,1 @@\n+#ifndef RISCV\n@@ -934,0 +944,1 @@\n+#endif\n@@ -961,0 +972,5 @@\n+#ifdef RISCV\n+  , begin_op4\n+      , lir_cmove\n+  , end_op4\n+#endif\n@@ -997,0 +1013,5 @@\n+#if defined(RISCV) && defined(INCLUDE_ZGC)\n+  , begin_opZLoadBarrierTest\n+    , lir_zloadbarrier_test\n+  , end_opZLoadBarrierTest\n+#endif\n@@ -1133,0 +1154,3 @@\n+#ifdef RISCV\n+  virtual LIR_Op4* as_Op4() { return NULL; }\n+#endif\n@@ -1405,41 +1429,0 @@\n-\n-class LIR_OpBranch: public LIR_Op {\n- friend class LIR_OpVisitState;\n-\n- private:\n-  LIR_Condition _cond;\n-  Label*        _label;\n-  BlockBegin*   _block;  \/\/ if this is a branch to a block, this is the block\n-  BlockBegin*   _ublock; \/\/ if this is a float-branch, this is the unorderd block\n-  CodeStub*     _stub;   \/\/ if this is a branch to a stub, this is the stub\n-\n- public:\n-  LIR_OpBranch(LIR_Condition cond, Label* lbl)\n-    : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*) NULL)\n-    , _cond(cond)\n-    , _label(lbl)\n-    , _block(NULL)\n-    , _ublock(NULL)\n-    , _stub(NULL) { }\n-\n-  LIR_OpBranch(LIR_Condition cond, BlockBegin* block);\n-  LIR_OpBranch(LIR_Condition cond, CodeStub* stub);\n-\n-  \/\/ for unordered comparisons\n-  LIR_OpBranch(LIR_Condition cond, BlockBegin* block, BlockBegin* ublock);\n-\n-  LIR_Condition cond()        const              { return _cond;        }\n-  Label*        label()       const              { return _label;       }\n-  BlockBegin*   block()       const              { return _block;       }\n-  BlockBegin*   ublock()      const              { return _ublock;      }\n-  CodeStub*     stub()        const              { return _stub;       }\n-\n-  void          change_block(BlockBegin* b);\n-  void          change_ublock(BlockBegin* b);\n-  void          negate_cond();\n-\n-  virtual void emit_code(LIR_Assembler* masm);\n-  virtual LIR_OpBranch* as_OpBranch() { return this; }\n-  virtual void print_instr(outputStream* out) const PRODUCT_RETURN;\n-};\n-\n@@ -1618,1 +1601,1 @@\n-  LIR_Op2(LIR_Code code, LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, CodeEmitInfo* info = NULL)\n+  LIR_Op2(LIR_Code code, LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, CodeEmitInfo* info = NULL, BasicType type = T_ILLEGAL)\n@@ -1623,1 +1606,1 @@\n-    , _type(T_ILLEGAL)\n+    , _type(type)\n@@ -1630,1 +1613,1 @@\n-    assert(code == lir_cmp || code == lir_assert, \"code check\");\n+    assert(code == lir_cmp || code == lir_assert RISCV_ONLY(|| code == lir_branch || code == lir_cond_float_branch), \"code check\");\n@@ -1662,1 +1645,1 @@\n-    assert(code != lir_cmp && is_in_range(code, begin_op2, end_op2), \"code check\");\n+    assert(code != lir_cmp && RISCV_ONLY(code != lir_branch && code != lir_cond_float_branch &&) is_in_range(code, begin_op2, end_op2), \"code check\");\n@@ -1678,1 +1661,1 @@\n-    assert(code != lir_cmp && is_in_range(code, begin_op2, end_op2), \"code check\");\n+    assert(code != lir_cmp && RISCV_ONLY(code != lir_branch && code != lir_cond_float_branch &&) is_in_range(code, begin_op2, end_op2), \"code check\");\n@@ -1690,0 +1673,3 @@\n+#ifdef RISCV\n+    assert(code() == lir_cmp || code() == lir_branch || code() == lir_cond_float_branch || code() == lir_assert, \"only valid for branch and assert\"); return _condition;\n+#else\n@@ -1691,0 +1677,1 @@\n+#endif\n@@ -1693,0 +1680,3 @@\n+#ifdef RISCV\n+    assert(code() == lir_cmp || code() == lir_branch || code() == lir_cond_float_branch, \"only valid for branch\"); _condition = condition;\n+#else\n@@ -1694,0 +1684,1 @@\n+#endif\n@@ -1707,0 +1698,56 @@\n+#ifdef RISCV\n+class LIR_OpBranch: public LIR_Op2 {\n+#else\n+class LIR_OpBranch: public LIR_Op {\n+#endif\n+ friend class LIR_OpVisitState;\n+\n+ private:\n+#ifndef RISCV\n+  LIR_Condition _cond;\n+#endif\n+  Label*        _label;\n+  BlockBegin*   _block;  \/\/ if this is a branch to a block, this is the block\n+  BlockBegin*   _ublock; \/\/ if this is a float-branch, this is the unordered block\n+  CodeStub*     _stub;   \/\/ if this is a branch to a stub, this is the stub\n+\n+ public:\n+  LIR_OpBranch(LIR_Condition cond, Label* lbl)\n+#ifdef RISCV\n+    : LIR_Op2(lir_branch, cond, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, (CodeEmitInfo*) NULL)\n+#else\n+    : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*) NULL)\n+    , _cond(cond)\n+#endif\n+    , _label(lbl)\n+    , _block(NULL)\n+    , _ublock(NULL)\n+    , _stub(NULL) { }\n+\n+  LIR_OpBranch(LIR_Condition cond, BlockBegin* block);\n+  LIR_OpBranch(LIR_Condition cond, CodeStub* stub);\n+\n+  \/\/ for unordered comparisons\n+  LIR_OpBranch(LIR_Condition cond, BlockBegin* block, BlockBegin* ublock);\n+\n+#ifdef RISCV\n+  LIR_Condition cond()        const              { return condition();  }\n+  void set_cond(LIR_Condition cond)              { set_condition(cond); }\n+#else\n+  LIR_Condition cond()        const              { return _cond;        }\n+  void set_cond(LIR_Condition cond)              { _cond = cond;        }\n+#endif\n+  Label*        label()       const              { return _label;       }\n+  BlockBegin*   block()       const              { return _block;       }\n+  BlockBegin*   ublock()      const              { return _ublock;      }\n+  CodeStub*     stub()        const              { return _stub;        }\n+\n+  void          change_block(BlockBegin* b);\n+  void          change_ublock(BlockBegin* b);\n+  void          negate_cond();\n+\n+  virtual void emit_code(LIR_Assembler* masm);\n+  virtual LIR_OpBranch* as_OpBranch() { return this; }\n+  virtual void print_instr(outputStream* out) const PRODUCT_RETURN;\n+};\n+\n@@ -1770,0 +1817,59 @@\n+#ifdef RISCV\n+class LIR_Op4: public LIR_Op {\n+  friend class LIR_OpVisitState;\n+ protected:\n+  LIR_Opr   _opr1;\n+  LIR_Opr   _opr2;\n+  LIR_Opr   _opr3;\n+  LIR_Opr   _opr4;\n+  BasicType _type;\n+  LIR_Opr   _tmp1;\n+  LIR_Opr   _tmp2;\n+  LIR_Opr   _tmp3;\n+  LIR_Opr   _tmp4;\n+  LIR_Opr   _tmp5;\n+  LIR_Condition _condition;\n+\n+ public:\n+  LIR_Op4(LIR_Code code, LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr opr3, LIR_Opr opr4,\n+          LIR_Opr result, BasicType type)\n+    : LIR_Op(code, result, NULL)\n+    , _opr1(opr1)\n+    , _opr2(opr2)\n+    , _opr3(opr3)\n+    , _opr4(opr4)\n+    , _type(type)\n+    , _tmp1(LIR_OprFact::illegalOpr)\n+    , _tmp2(LIR_OprFact::illegalOpr)\n+    , _tmp3(LIR_OprFact::illegalOpr)\n+    , _tmp4(LIR_OprFact::illegalOpr)\n+    , _tmp5(LIR_OprFact::illegalOpr)\n+    , _condition(condition) {\n+    assert(code == lir_cmove, \"code check\");\n+    assert(type != T_ILLEGAL, \"cmove should have type\");\n+  }\n+\n+  LIR_Opr in_opr1() const                        { return _opr1; }\n+  LIR_Opr in_opr2() const                        { return _opr2; }\n+  LIR_Opr in_opr3() const                        { return _opr3; }\n+  LIR_Opr in_opr4() const                        { return _opr4; }\n+  BasicType type()  const                        { return _type; }\n+  LIR_Opr tmp1_opr() const                       { return _tmp1; }\n+  LIR_Opr tmp2_opr() const                       { return _tmp2; }\n+  LIR_Opr tmp3_opr() const                       { return _tmp3; }\n+  LIR_Opr tmp4_opr() const                       { return _tmp4; }\n+  LIR_Opr tmp5_opr() const                       { return _tmp5; }\n+\n+  LIR_Condition condition() const                { return _condition; }\n+  void set_condition(LIR_Condition condition)    { _condition = condition; }\n+\n+  void set_in_opr1(LIR_Opr opr)                  { _opr1 = opr; }\n+  void set_in_opr2(LIR_Opr opr)                  { _opr2 = opr; }\n+  void set_in_opr3(LIR_Opr opr)                  { _opr3 = opr; }\n+  void set_in_opr4(LIR_Opr opr)                  { _opr4 = opr; }\n+  virtual void emit_code(LIR_Assembler* masm);\n+  virtual LIR_Op4* as_Op4() { return this; }\n+\n+  virtual void print_instr(outputStream* out) const PRODUCT_RETURN;\n+};\n+#endif\n@@ -1822,2 +1928,2 @@\n-  LIR_Opr obj()    const { return _obj;  }\n-  CodeStub* stub() const { return _stub; }\n+  LIR_Opr obj()        const { return _obj;  }\n+  CodeStub* stub()     const { return _stub; }\n@@ -2011,0 +2117,4 @@\n+#ifdef RISCV\n+  LIR_Opr       _cmp_opr1;\n+  LIR_Opr       _cmp_opr2;\n+#endif\n@@ -2023,0 +2133,6 @@\n+#ifdef RISCV\n+    set_cmp_oprs(op);\n+    \/\/ lir_cmp set cmp oprs only on riscv\n+    if (op->code() == lir_cmp) return;\n+#endif\n+\n@@ -2039,0 +2155,4 @@\n+#ifdef RISCV\n+  void set_cmp_oprs(LIR_Op* op);\n+#endif\n+\n@@ -2158,0 +2278,6 @@\n+#ifdef RISCV\n+  void cmove(LIR_Condition condition, LIR_Opr src1, LIR_Opr src2, LIR_Opr dst, BasicType type,\n+             LIR_Opr cmp_opr1 = LIR_OprFact::illegalOpr, LIR_Opr cmp_opr2 = LIR_OprFact::illegalOpr) {\n+    append(new LIR_Op4(lir_cmove, condition, src1, src2, cmp_opr1, cmp_opr2, dst, type));\n+  }\n+#else\n@@ -2161,0 +2287,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":176,"deletions":49,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -1225,1 +1225,2 @@\n-                 reference, LIR_OprFact::intConst(referent_offset), result);\n+                 reference, LIR_OprFact::intConst(referent_offset), result,\n+                 nullptr, info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2273,1 +2273,1 @@\n-class G1ParallelObjectIterator : public ParallelObjectIterator {\n+class G1ParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -2288,1 +2288,1 @@\n-ParallelObjectIterator* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n+ParallelObjectIteratorImpl* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -312,1 +312,4 @@\n-  scope()->tracer()->report_object_count_after_gc(&_is_alive);\n+  {\n+    GCTraceTime(Debug, gc, phases) debug(\"Report Object Count\", scope()->timer());\n+    scope()->tracer()->report_object_count_after_gc(&_is_alive, _heap->workers());\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -201,0 +201,4 @@\n+  if (eden_size > max_eden_size()) {\n+    eden_size = max_eden_size();\n+    survivor_size = (size - eden_size)\/2;\n+  }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,1 +238,4 @@\n-  gc_tracer()->report_object_count_after_gc(&is_alive);\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Report Object Count\", gc_timer());\n+    gc_tracer()->report_object_count_after_gc(&is_alive, nullptr);\n+  }\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -113,0 +113,12 @@\n+ParallelObjectIterator::ParallelObjectIterator(uint thread_num) :\n+  _impl(Universe::heap()->parallel_object_iterator(thread_num))\n+{}\n+\n+ParallelObjectIterator::~ParallelObjectIterator() {\n+  delete _impl;\n+}\n+\n+void ParallelObjectIterator::object_iterate(ObjectClosure* cl, uint worker_id) {\n+  _impl->object_iterate(cl, worker_id);\n+}\n+\n@@ -372,11 +384,0 @@\n-#ifndef PRODUCT\n-void CollectedHeap::check_for_non_bad_heap_word_value(HeapWord* addr, size_t size) {\n-  if (CheckMemoryInitialization && ZapUnusedHeapArea) {\n-    \/\/ please note mismatch between size (in 32\/64 bit words), and ju_addr that always point to a 32 bit word\n-    for (juint* ju_addr = reinterpret_cast<juint*>(addr); ju_addr < reinterpret_cast<juint*>(addr + size); ++ju_addr) {\n-      assert(*ju_addr == badHeapWordVal, \"Found non badHeapWordValue in pre-allocation check\");\n-    }\n-  }\n-}\n-#endif \/\/ PRODUCT\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-class ParallelObjectIterator : public CHeapObj<mtGC> {\n+class ParallelObjectIteratorImpl : public CHeapObj<mtGC> {\n@@ -67,0 +67,1 @@\n+  virtual ~ParallelObjectIteratorImpl() {}\n@@ -68,1 +69,13 @@\n-  virtual ~ParallelObjectIterator() {}\n+};\n+\n+\/\/ User facing parallel object iterator. This is a StackObj, which ensures that\n+\/\/ the _impl is allocated and deleted in the scope of this object. This ensures\n+\/\/ the life cycle of the implementation is as required by ThreadsListHandle,\n+\/\/ which is sometimes used by the root iterators.\n+class ParallelObjectIterator : public StackObj {\n+  ParallelObjectIteratorImpl* _impl;\n+\n+public:\n+  ParallelObjectIterator(uint thread_num);\n+  ~ParallelObjectIterator();\n+  void object_iterate(ObjectClosure* cl, uint worker_id);\n@@ -85,0 +98,1 @@\n+  friend class ParallelObjectIterator;\n@@ -158,2 +172,0 @@\n-  virtual void check_for_non_bad_heap_word_value(HeapWord* addr, size_t size)\n-    PRODUCT_RETURN;\n@@ -386,1 +398,2 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num) {\n+ protected:\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) {\n@@ -390,0 +403,1 @@\n+ public:\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  TraceMemoryManagerStats tmms(gen->gc_manager(), gc_cause());\n+  TraceMemoryManagerStats tmms(gen->gc_manager(), gc_cause(), heap()->is_young_gen(gen) ? \"end of minor GC\" : \"end of major GC\");\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-  void check_for_bad_heap_word_value() const;\n@@ -84,1 +83,0 @@\n-      verify_after();\n@@ -151,16 +149,0 @@\n-void MemAllocator::Allocation::verify_after() {\n-  NOT_PRODUCT(check_for_bad_heap_word_value();)\n-}\n-\n-void MemAllocator::Allocation::check_for_bad_heap_word_value() const {\n-  MemRegion obj_range = _allocator.obj_memory_range(obj());\n-  HeapWord* addr = obj_range.start();\n-  size_t size = obj_range.word_size();\n-  if (CheckMemoryInitialization && ZapUnusedHeapArea) {\n-    for (size_t slot = 0; slot < size; slot += 1) {\n-      assert((*(intptr_t*) (addr + slot)) != ((intptr_t) badHeapWordVal),\n-             \"Found badHeapWordValue in post-allocation check\");\n-    }\n-  }\n-}\n-\n@@ -261,1 +243,0 @@\n-  NOT_PRODUCT(Universe::heap()->check_for_non_bad_heap_word_value(mem, _word_size));\n@@ -409,9 +390,0 @@\n-MemRegion ObjArrayAllocator::obj_memory_range(oop obj) const {\n-  if (_do_zero) {\n-    return MemAllocator::obj_memory_range(obj);\n-  }\n-  ArrayKlass* array_klass = ArrayKlass::cast(_klass);\n-  const size_t hs = align_up(arrayOopDesc::base_offset_in_bytes(array_klass->element_type()), HeapWordSize) \/ HeapWordSize;\n-  return MemRegion(cast_from_oop<HeapWord*>(obj) + hs, _word_size - hs);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -481,2 +481,2 @@\n-  _stw_memory_manager(\"Shenandoah Pauses\", \"end of GC pause\"),\n-  _cycle_memory_manager(\"Shenandoah Cycles\", \"end of GC cycle\"),\n+  _stw_memory_manager(\"Shenandoah Pauses\"),\n+  _cycle_memory_manager(\"Shenandoah Cycles\"),\n@@ -601,0 +601,1 @@\n+    st->cr();\n@@ -1029,4 +1030,7 @@\n-  st->print_cr(\"EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned\");\n-  st->print_cr(\"BTE=bottom\/top\/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data\");\n-  st->print_cr(\"R=root, CP=critical pins, TAMS=top-at-mark-start, UWM=update watermark\");\n-  st->print_cr(\"SN=alloc sequence number\");\n+  st->print_cr(\"Region state: EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HP=pinned humongous start\");\n+  st->print_cr(\"              HC=humongous continuation, CS=collection set, TR=trash, P=pinned, CSP=pinned collection set\");\n+  st->print_cr(\"BTE=bottom\/top\/end, TAMS=top-at-mark-start\");\n+  st->print_cr(\"UWM=update watermark, U=used\");\n+  st->print_cr(\"T=TLAB allocs, G=GCLAB allocs\");\n+  st->print_cr(\"S=shared allocs, L=live data\");\n+  st->print_cr(\"CP=critical pins\");\n@@ -1188,0 +1192,1 @@\n+  tcl->do_thread(_control_thread);\n@@ -1376,1 +1381,1 @@\n-class ShenandoahParallelObjectIterator : public ParallelObjectIterator {\n+class ShenandoahParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -1476,1 +1481,1 @@\n-ParallelObjectIterator* ShenandoahHeap::parallel_object_iterator(uint workers) {\n+ParallelObjectIteratorImpl* ShenandoahHeap::parallel_object_iterator(uint workers) {\n@@ -2130,0 +2135,1 @@\n+  st->cr();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -135,3 +135,1 @@\n-      \/\/ We only check that non-NULL store still updated with non-forwarded reference.\n-      oop witness = cas_oop(fwd, p, obj);\n-      shenandoah_assert_not_forwarded_except(p, witness, (witness == NULL) || (witness == obj));\n+      atomic_update_oop(fwd, p, obj);\n@@ -142,1 +140,46 @@\n-inline oop ShenandoahHeap::cas_oop(oop n, oop* addr, oop c) {\n+\/\/ Atomic updates of heap location. This is only expected to work with updating the same\n+\/\/ logical object with its forwardee. The reason why we need stronger-than-relaxed memory\n+\/\/ ordering has to do with coordination with GC barriers and mutator accesses.\n+\/\/\n+\/\/ In essence, stronger CAS access is required to maintain the transitive chains that mutator\n+\/\/ accesses build by themselves. To illustrate this point, consider the following example.\n+\/\/\n+\/\/ Suppose \"o\" is the object that has a field \"x\" and the reference to \"o\" is stored\n+\/\/ to field at \"addr\", which happens to be Java volatile field. Normally, the accesses to volatile\n+\/\/ field at \"addr\" would be matched with release\/acquire barriers. This changes when GC moves\n+\/\/ the object under mutator feet.\n+\/\/\n+\/\/ Thread 1 (Java)\n+\/\/         \/\/ --- previous access starts here\n+\/\/         ...\n+\/\/   T1.1: store(&o.x, 1, mo_relaxed)\n+\/\/   T1.2: store(&addr, o, mo_release) \/\/ volatile store\n+\/\/\n+\/\/         \/\/ --- new access starts here\n+\/\/         \/\/ LRB: copy and install the new copy to fwdptr\n+\/\/   T1.3: var copy = copy(o)\n+\/\/   T1.4: cas(&fwd, t, copy, mo_release) \/\/ pointer-mediated publication\n+\/\/         <access continues>\n+\/\/\n+\/\/ Thread 2 (GC updater)\n+\/\/   T2.1: var f = load(&fwd, mo_{consume|acquire}) \/\/ pointer-mediated acquisition\n+\/\/   T2.2: cas(&addr, o, f, mo_release) \/\/ this method\n+\/\/\n+\/\/ Thread 3 (Java)\n+\/\/   T3.1: var o = load(&addr, mo_acquire) \/\/ volatile read\n+\/\/   T3.2: if (o != null)\n+\/\/   T3.3:   var r = load(&o.x, mo_relaxed)\n+\/\/\n+\/\/ r is guaranteed to contain \"1\".\n+\/\/\n+\/\/ Without GC involvement, there is synchronizes-with edge from T1.2 to T3.1,\n+\/\/ which guarantees this. With GC involvement, when LRB copies the object and\n+\/\/ another thread updates the reference to it, we need to have the transitive edge\n+\/\/ from T1.4 to T2.1 (that one is guaranteed by forwarding accesses), plus the edge\n+\/\/ from T2.2 to T3.1 (which is brought by this CAS).\n+\/\/\n+\/\/ Note that we do not need to \"acquire\" in these methods, because we do not read the\n+\/\/ failure witnesses contents on any path, and \"release\" is enough.\n+\/\/\n+\n+inline void ShenandoahHeap::atomic_update_oop(oop update, oop* addr, oop compare) {\n@@ -144,1 +187,1 @@\n-  return (oop) Atomic::cmpxchg(addr, c, n);\n+  Atomic::cmpxchg(addr, compare, update, memory_order_release);\n@@ -147,1 +190,1 @@\n-inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, narrowOop c) {\n+inline void ShenandoahHeap::atomic_update_oop(oop update, narrowOop* addr, narrowOop compare) {\n@@ -149,2 +192,2 @@\n-  narrowOop val = CompressedOops::encode(n);\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, c, val));\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, compare, u, memory_order_release);\n@@ -153,1 +196,1 @@\n-inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, oop c) {\n+inline void ShenandoahHeap::atomic_update_oop(oop update, narrowOop* addr, oop compare) {\n@@ -155,3 +198,41 @@\n-  narrowOop cmp = CompressedOops::encode(c);\n-  narrowOop val = CompressedOops::encode(n);\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, cmp, val));\n+  narrowOop c = CompressedOops::encode(compare);\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, c, u, memory_order_release);\n+}\n+\n+inline bool ShenandoahHeap::atomic_update_oop_check(oop update, oop* addr, oop compare) {\n+  assert(is_aligned(addr, HeapWordSize), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  return (oop) Atomic::cmpxchg(addr, compare, update, memory_order_release) == compare;\n+}\n+\n+inline bool ShenandoahHeap::atomic_update_oop_check(oop update, narrowOop* addr, narrowOop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop u = CompressedOops::encode(update);\n+  return (narrowOop) Atomic::cmpxchg(addr, compare, u, memory_order_release) == compare;\n+}\n+\n+inline bool ShenandoahHeap::atomic_update_oop_check(oop update, narrowOop* addr, oop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop c = CompressedOops::encode(compare);\n+  narrowOop u = CompressedOops::encode(update);\n+  return CompressedOops::decode(Atomic::cmpxchg(addr, c, u, memory_order_release)) == compare;\n+}\n+\n+\/\/ The memory ordering discussion above does not apply for methods that store NULLs:\n+\/\/ then, there is no transitive reads in mutator (as we see NULLs), and we can do\n+\/\/ relaxed memory ordering there.\n+\n+inline void ShenandoahHeap::atomic_clear_oop(oop* addr, oop compare) {\n+  assert(is_aligned(addr, HeapWordSize), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  Atomic::cmpxchg(addr, compare, oop(), memory_order_relaxed);\n+}\n+\n+inline void ShenandoahHeap::atomic_clear_oop(narrowOop* addr, oop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop cmp = CompressedOops::encode(compare);\n+  Atomic::cmpxchg(addr, cmp, narrowOop(), memory_order_relaxed);\n+}\n+\n+inline void ShenandoahHeap::atomic_clear_oop(narrowOop* addr, narrowOop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  Atomic::cmpxchg(addr, compare, narrowOop(), memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":93,"deletions":12,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -66,4 +66,0 @@\n-void Klass::replace_java_mirror(oop mirror) {\n-  _java_mirror.replace(mirror);\n-}\n-\n@@ -799,1 +795,1 @@\n-    guarantee(oopDesc::is_oop(java_mirror_no_keepalive()), \"should be instance\");\n+    guarantee(java_lang_Class::is_instance(java_mirror_no_keepalive()), \"should be instance\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,2 +50,5 @@\n-  uintptr_t v = HeapAccess<MO_RELAXED>::load_at(as_oop(), mark_offset_in_bytes());\n-  return markWord(v);\n+  return Atomic::load(&_mark);\n+}\n+\n+markWord oopDesc::mark_acquire() const {\n+  return Atomic::load_acquire(&_mark);\n@@ -62,1 +65,1 @@\n-  HeapAccess<MO_RELAXED>::store_at(as_oop(), mark_offset_in_bytes(), m.value());\n+  Atomic::store(&_mark, m);\n@@ -70,1 +73,1 @@\n-  HeapAccess<MO_RELEASE>::store_at(as_oop(), mark_offset_in_bytes(), m.value());\n+  Atomic::release_store(&_mark, m);\n@@ -78,2 +81,1 @@\n-  uintptr_t v = HeapAccess<>::atomic_cmpxchg_at(as_oop(), mark_offset_in_bytes(), old_mark.value(), new_mark.value());\n-  return markWord(v);\n+  return Atomic::cmpxchg(&_mark, old_mark, new_mark);\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -102,1 +102,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -179,1 +179,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -224,1 +224,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -264,1 +264,1 @@\n-  assert(method != NULL, \"must be valid call site\");\n+  assert(method != nullptr, \"must be valid call site\");\n@@ -270,1 +270,1 @@\n-  _depth  = 1 + (caller == NULL ? 0 : caller->depth());\n+  _depth  = 1 + (caller == nullptr ? 0 : caller->depth());\n@@ -279,1 +279,1 @@\n-  _method(NULL) {\n+  _method(nullptr) {\n@@ -283,1 +283,1 @@\n-  _caller = NULL;\n+  _caller = nullptr;\n@@ -312,1 +312,1 @@\n-    if (p->_method == NULL)          return true;   \/\/ bci is irrelevant\n+    if (p->_method == nullptr)       return true;   \/\/ bci is irrelevant\n@@ -318,1 +318,1 @@\n-    assert(p != NULL && q != NULL, \"depth check ensures we don't run off end\");\n+    assert(p != nullptr && q != nullptr, \"depth check ensures we don't run off end\");\n@@ -339,1 +339,1 @@\n-  for (const JVMState* jvmp = this; jvmp != NULL; jvmp = jvmp->caller()) {\n+  for (const JVMState* jvmp = this; jvmp != nullptr; jvmp = jvmp->caller()) {\n@@ -351,1 +351,1 @@\n-  if (n == NULL) { st->print(\" NULL\"); return; }\n+  if (n == nullptr) { st->print(\" null\"); return; }\n@@ -374,1 +374,1 @@\n-      st->print(\" %s%d]=#NULL\",msg,i);\n+      st->print(\" %s%d]=#null\",msg,i);\n@@ -475,1 +475,1 @@\n-      ciInstanceKlass *iklass = NULL;\n+      ciInstanceKlass *iklass = nullptr;\n@@ -503,1 +503,1 @@\n-        if (iklass != NULL) {\n+        if (iklass != nullptr) {\n@@ -513,1 +513,1 @@\n-          if (iklass != NULL) {\n+          if (iklass != nullptr) {\n@@ -527,1 +527,1 @@\n-  if (caller() != NULL) caller()->format(regalloc, n, st);\n+  if (caller() != nullptr) caller()->format(regalloc, n, st);\n@@ -532,1 +532,1 @@\n-  if (_method != NULL) {\n+  if (_method != nullptr) {\n@@ -544,2 +544,2 @@\n-        if (endcn == NULL)  endcn = strchr(name, '(');\n-        if (endcn == NULL)  endcn = name + strlen(name);\n+        if (endcn == nullptr)  endcn = strchr(name, '(');\n+        if (endcn == nullptr)  endcn = name + strlen(name);\n@@ -558,1 +558,1 @@\n-  if (caller() != NULL)  caller()->dump_spec(st);\n+  if (caller() != nullptr)  caller()->dump_spec(st);\n@@ -564,1 +564,1 @@\n-                  ((caller() == NULL) || (caller()->map() != _map));\n+                  ((caller() == nullptr) || (caller()->map() != _map));\n@@ -569,1 +569,1 @@\n-      while (ex != NULL && ex->len() > ex->req()) {\n+      while (ex != nullptr && ex->len() > ex->req()) {\n@@ -576,1 +576,1 @@\n-  if (caller() != NULL) {\n+  if (caller() != nullptr) {\n@@ -581,1 +581,1 @@\n-  if (_method == NULL) {\n+  if (_method == nullptr) {\n@@ -618,1 +618,1 @@\n-  for (JVMState* p = n; p->_caller != NULL; p = p->_caller) {\n+  for (JVMState* p = n; p->_caller != nullptr; p = p->_caller) {\n@@ -630,1 +630,1 @@\n-  for (JVMState* p = this; p != NULL; p = p->_caller) {\n+  for (JVMState* p = this; p != nullptr; p = p->_caller) {\n@@ -644,1 +644,1 @@\n-  for (JVMState* jvms = this; jvms != NULL; jvms = jvms->caller()) {\n+  for (JVMState* jvms = this; jvms != nullptr; jvms = jvms->caller()) {\n@@ -663,1 +663,1 @@\n-  while (jvms != NULL) {\n+  while (jvms != nullptr) {\n@@ -703,1 +703,1 @@\n-  if (tf() != NULL)  tf()->dump_on(st);\n+  if (tf() != nullptr)  tf()->dump_on(st);\n@@ -705,1 +705,1 @@\n-  if (jvms() != NULL)  jvms()->dump_spec(st);\n+  if (jvms() != nullptr)  jvms()->dump_spec(st);\n@@ -767,1 +767,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -780,1 +780,1 @@\n-  assert((t_oop != NULL), \"sanity\");\n+  assert((t_oop != nullptr), \"sanity\");\n@@ -783,1 +783,1 @@\n-    Node* dest = NULL;\n+    Node* dest = nullptr;\n@@ -796,1 +796,1 @@\n-    guarantee(dest != NULL, \"Call had only one ptr in, broken IR!\");\n+    guarantee(dest != nullptr, \"Call had only one ptr in, broken IR!\");\n@@ -812,1 +812,1 @@\n-      if ((proj == NULL) || (phase->type(proj)->is_instptr()->klass() != boxing_klass)) {\n+      if ((proj == nullptr) || (phase->type(proj)->is_instptr()->klass() != boxing_klass)) {\n@@ -816,1 +816,1 @@\n-    if (is_CallJava() && as_CallJava()->method() != NULL) {\n+    if (is_CallJava() && as_CallJava()->method() != nullptr) {\n@@ -823,2 +823,2 @@\n-      Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : NULL;\n-      if (proj != NULL) {\n+      Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : nullptr;\n+      if (proj != nullptr) {\n@@ -826,1 +826,1 @@\n-        if ((inst_t != NULL) && (!inst_t->klass_is_exact() ||\n+        if ((inst_t != nullptr) && (!inst_t->klass_is_exact() ||\n@@ -834,1 +834,1 @@\n-        if ((inst_t != NULL) && (!inst_t->klass_is_exact() ||\n+        if ((inst_t != nullptr) && (!inst_t->klass_is_exact() ||\n@@ -859,1 +859,1 @@\n-\/\/ or returns NULL if there is no one.\n+\/\/ or returns null if there is no one.\n@@ -861,1 +861,1 @@\n-  Node *cast = NULL;\n+  Node *cast = nullptr;\n@@ -864,2 +864,2 @@\n-  if (p == NULL)\n-    return NULL;\n+  if (p == nullptr)\n+    return nullptr;\n@@ -870,1 +870,1 @@\n-      if (cast != NULL) {\n+      if (cast != nullptr) {\n@@ -889,9 +889,9 @@\n-  projs->fallthrough_proj      = NULL;\n-  projs->fallthrough_catchproj = NULL;\n-  projs->fallthrough_ioproj    = NULL;\n-  projs->catchall_ioproj       = NULL;\n-  projs->catchall_catchproj    = NULL;\n-  projs->fallthrough_memproj   = NULL;\n-  projs->catchall_memproj      = NULL;\n-  projs->resproj               = NULL;\n-  projs->exobj                 = NULL;\n+  projs->fallthrough_proj      = nullptr;\n+  projs->fallthrough_catchproj = nullptr;\n+  projs->fallthrough_ioproj    = nullptr;\n+  projs->catchall_ioproj       = nullptr;\n+  projs->catchall_catchproj    = nullptr;\n+  projs->fallthrough_memproj   = nullptr;\n+  projs->catchall_memproj      = nullptr;\n+  projs->resproj               = nullptr;\n+  projs->exobj                 = nullptr;\n@@ -908,2 +908,2 @@\n-        if (cn != NULL && cn->is_Catch()) {\n-          ProjNode *cpn = NULL;\n+        if (cn != nullptr && cn->is_Catch()) {\n+          ProjNode *cpn = nullptr;\n@@ -931,1 +931,1 @@\n-          assert(projs->exobj == NULL, \"only one\");\n+          assert(projs->exobj == nullptr, \"only one\");\n@@ -953,1 +953,1 @@\n-  assert(projs->fallthrough_proj      != NULL, \"must be found\");\n+  assert(projs->fallthrough_proj      != nullptr, \"must be found\");\n@@ -955,4 +955,4 @@\n-  assert(!do_asserts || projs->fallthrough_catchproj != NULL, \"must be found\");\n-  assert(!do_asserts || projs->fallthrough_memproj   != NULL, \"must be found\");\n-  assert(!do_asserts || projs->fallthrough_ioproj    != NULL, \"must be found\");\n-  assert(!do_asserts || projs->catchall_catchproj    != NULL, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_catchproj != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_memproj   != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_ioproj    != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->catchall_catchproj    != nullptr, \"must be found\");\n@@ -960,2 +960,2 @@\n-    assert(!do_asserts || projs->catchall_memproj    != NULL, \"must be found\");\n-    assert(!do_asserts || projs->catchall_ioproj     != NULL, \"must be found\");\n+    assert(!do_asserts || projs->catchall_memproj    != nullptr, \"must be found\");\n+    assert(!do_asserts || projs->catchall_ioproj     != nullptr, \"must be found\");\n@@ -969,1 +969,1 @@\n-  if (cg != NULL) {\n+  if (cg != nullptr) {\n@@ -978,1 +978,1 @@\n-  if (_name != NULL && strstr(_name, \"arraycopy\") != 0) {\n+  if (_name != nullptr && strstr(_name, \"arraycopy\") != 0) {\n@@ -1006,1 +1006,1 @@\n-    if (old_in != NULL && old_in->is_SafePointScalarObject()) {\n+    if (old_in != nullptr && old_in->is_SafePointScalarObject()) {\n@@ -1020,2 +1020,2 @@\n-  set_jvms(sfpt->jvms() != NULL ? sfpt->jvms()->clone_deep(C) : NULL);\n-  for (JVMState *jvms = this->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+  set_jvms(sfpt->jvms() != nullptr ? sfpt->jvms()->clone_deep(C) : nullptr);\n+  for (JVMState *jvms = this->jvms(); jvms != nullptr; jvms = jvms->caller()) {\n@@ -1033,1 +1033,1 @@\n-  if (method() == NULL) {\n+  if (method() == nullptr) {\n@@ -1070,1 +1070,1 @@\n-  if (can_reshape && cg != NULL) {\n+  if (can_reshape && cg != nullptr) {\n@@ -1081,1 +1081,1 @@\n-        set_generator(NULL);\n+        set_generator(nullptr);\n@@ -1093,1 +1093,1 @@\n-        set_generator(NULL);\n+        set_generator(nullptr);\n@@ -1103,1 +1103,1 @@\n-  if (_name != NULL && !strcmp(_name, \"uncommon_trap\")) {\n+  if (_name != nullptr && !strcmp(_name, \"uncommon_trap\")) {\n@@ -1111,1 +1111,1 @@\n-        call->in(TypeFunc::Parms) != NULL &&\n+        call->in(TypeFunc::Parms) != nullptr &&\n@@ -1125,1 +1125,1 @@\n-  if (_name != NULL) {\n+  if (_name != nullptr) {\n@@ -1159,1 +1159,1 @@\n-  if (can_reshape && cg != NULL) {\n+  if (can_reshape && cg != nullptr) {\n@@ -1192,1 +1192,1 @@\n-      set_generator(NULL);\n+      set_generator(nullptr);\n@@ -1264,1 +1264,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1381,1 +1381,1 @@\n-  assert(n == NULL || n->Opcode() == Op_SafePoint, \"correct value for next_exception\");\n+  assert(n == nullptr || n->Opcode() == Op_SafePoint, \"correct value for next_exception\");\n@@ -1383,1 +1383,1 @@\n-    if (n != NULL)  add_prec(n);\n+    if (n != nullptr)  add_prec(n);\n@@ -1393,1 +1393,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1396,1 +1396,1 @@\n-    assert(n == NULL || n->Opcode() == Op_SafePoint, \"no other uses of prec edges\");\n+    assert(n == nullptr || n->Opcode() == Op_SafePoint, \"no other uses of prec edges\");\n@@ -1405,2 +1405,2 @@\n-  assert(_jvms == NULL || ((uintptr_t)_jvms->map() & 1) || _jvms->map() == this, \"inconsistent JVMState\");\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  assert(_jvms == nullptr || ((uintptr_t)_jvms->map() & 1) || _jvms->map() == this, \"inconsistent JVMState\");\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -1418,1 +1418,1 @@\n-    if (out_c != NULL && !out_c->is_OuterStripMinedLoopEnd()) {\n+    if (out_c != nullptr && !out_c->is_OuterStripMinedLoopEnd()) {\n@@ -1614,1 +1614,1 @@\n-  if (cached != NULL) {\n+  if (cached != nullptr) {\n@@ -1639,1 +1639,1 @@\n-  : CallNode(atype, NULL, TypeRawPtr::BOTTOM)\n+  : CallNode(atype, nullptr, TypeRawPtr::BOTTOM)\n@@ -1663,1 +1663,1 @@\n-  assert(initializer != NULL &&\n+  assert(initializer != nullptr &&\n@@ -1668,1 +1668,1 @@\n-  if (analyzer == NULL) {\n+  if (analyzer == nullptr) {\n@@ -1678,1 +1678,2 @@\n-  Node* mark_node = NULL;\n+  Node* mark_node = nullptr;\n+  \/\/ For now only enable fast locking for non-array types\n@@ -1692,1 +1693,1 @@\n-\/\/ a CastII is appropriate, return NULL.\n+\/\/ a CastII is appropriate, return null.\n@@ -1695,1 +1696,1 @@\n-  assert(length != NULL, \"length is not null\");\n+  assert(length != nullptr, \"length is not null\");\n@@ -1700,1 +1701,1 @@\n-  if (ary_type != NULL && length_type != NULL) {\n+  if (ary_type != nullptr && length_type != nullptr) {\n@@ -1713,1 +1714,1 @@\n-      \/\/ Return NULL if new nodes are not allowed\n+      \/\/ Return null if new nodes are not allowed\n@@ -1715,1 +1716,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1720,1 +1721,1 @@\n-      if (init != NULL) {\n+      if (init != nullptr) {\n@@ -1861,2 +1862,2 @@\n-  if (ctrl == NULL)\n-    return NULL;\n+  if (ctrl == nullptr)\n+    return nullptr;\n@@ -1867,1 +1868,1 @@\n-      if (n == NULL)\n+      if (n == nullptr)\n@@ -1890,2 +1891,2 @@\n-  ProjNode *ctrl_proj = (ctrl->is_Proj()) ? ctrl->as_Proj() : NULL;\n-  if (ctrl_proj != NULL && ctrl_proj->_con == TypeFunc::Control) {\n+  ProjNode *ctrl_proj = (ctrl->is_Proj()) ? ctrl->as_Proj() : nullptr;\n+  if (ctrl_proj != nullptr && ctrl_proj->_con == TypeFunc::Control) {\n@@ -1893,1 +1894,1 @@\n-    if (n != NULL && n->is_Unlock()) {\n+    if (n != nullptr && n->is_Unlock()) {\n@@ -1913,1 +1914,1 @@\n-  LockNode *lock_result = NULL;\n+  LockNode *lock_result = nullptr;\n@@ -1917,1 +1918,1 @@\n-    assert(ctrl != NULL, \"invalid control graph\");\n+    assert(ctrl != nullptr, \"invalid control graph\");\n@@ -1925,1 +1926,1 @@\n-      if (ctrl->req() == 3 && ctrl->in(1) != NULL && ctrl->in(2) != NULL) {\n+      if (ctrl->req() == 3 && ctrl->in(1) != nullptr && ctrl->in(2) != nullptr) {\n@@ -1964,1 +1965,1 @@\n-      Node* lock1_node = NULL;\n+      Node* lock1_node = nullptr;\n@@ -1975,1 +1976,1 @@\n-      if (lock1_node != NULL && lock1_node->is_Lock()) {\n+      if (lock1_node != nullptr && lock1_node->is_Lock()) {\n@@ -2000,1 +2001,1 @@\n-    if (in_node != NULL) {\n+    if (in_node != nullptr) {\n@@ -2065,1 +2066,1 @@\n-  \/\/ perform any generic optimizations first (returns 'this' or NULL)\n+  \/\/ perform any generic optimizations first (returns 'this' or null)\n@@ -2067,1 +2068,1 @@\n-  if (result != NULL)  return result;\n+  if (result != nullptr)  return result;\n@@ -2069,1 +2070,1 @@\n-  if (in(0) && in(0)->is_top())  return NULL;\n+  if (in(0) && in(0)->is_top())  return nullptr;\n@@ -2081,1 +2082,1 @@\n-    if (cgr != NULL && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n@@ -2100,1 +2101,1 @@\n-    if (iter != NULL && !is_eliminated()) {\n+    if (iter != nullptr && !is_eliminated()) {\n@@ -2180,1 +2181,1 @@\n-  return is_nested_lock_region(NULL);\n+  return is_nested_lock_region(nullptr);\n@@ -2183,1 +2184,1 @@\n-\/\/ p is used for access to compilation log; no logging if NULL\n+\/\/ p is used for access to compilation log; no logging if null\n@@ -2196,2 +2197,2 @@\n-  LockNode* unique_lock = NULL;\n-  Node* bad_lock = NULL;\n+  LockNode* unique_lock = nullptr;\n+  Node* bad_lock = nullptr;\n@@ -2206,1 +2207,1 @@\n-    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\", (unique_lock != NULL ? unique_lock : bad_lock));\n+    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\", (unique_lock != nullptr ? unique_lock : bad_lock));\n@@ -2215,1 +2216,1 @@\n-      if (unique_lock != NULL) {\n+      if (unique_lock != nullptr) {\n@@ -2219,1 +2220,1 @@\n-      if (bad_lock != NULL) {\n+      if (bad_lock != nullptr) {\n@@ -2260,1 +2261,1 @@\n-  \/\/ perform any generic optimizations first (returns 'this' or NULL)\n+  \/\/ perform any generic optimizations first (returns 'this' or null)\n@@ -2262,1 +2263,1 @@\n-  if (result != NULL)  return result;\n+  if (result != nullptr)  return result;\n@@ -2264,1 +2265,1 @@\n-  if (in(0) && in(0)->is_top())  return NULL;\n+  if (in(0) && in(0)->is_top())  return nullptr;\n@@ -2277,1 +2278,1 @@\n-    if (cgr != NULL && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n@@ -2292,1 +2293,1 @@\n-  if (C == NULL) {\n+  if (C == nullptr) {\n@@ -2296,1 +2297,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -2299,2 +2300,2 @@\n-    int box_id = box != NULL ? box->_idx : -1;\n-    int obj_id = obj != NULL ? obj->_idx : -1;\n+    int box_id = box != nullptr ? box->_idx : -1;\n+    int obj_id = obj != nullptr ? obj->_idx : -1;\n@@ -2305,1 +2306,1 @@\n-          kind_as_string(), box_id, obj_id, (bad_lock != NULL ? bad_lock->_idx : -1));\n+          kind_as_string(), box_id, obj_id, (bad_lock != nullptr ? bad_lock->_idx : -1));\n@@ -2309,1 +2310,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":134,"deletions":133,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  if (_mach_constant_base_node == NULL) {\n+  if (_mach_constant_base_node == nullptr) {\n@@ -156,1 +156,1 @@\n-    if (cg != NULL) {\n+    if (cg != nullptr) {\n@@ -164,1 +164,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -231,1 +231,1 @@\n-  if (xtty != NULL)  xtty->head(\"statistics type='intrinsic'\");\n+  if (xtty != nullptr)  xtty->head(\"statistics type='intrinsic'\");\n@@ -245,1 +245,1 @@\n-  if (xtty != NULL)  xtty->tail(\"statistics\");\n+  if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -250,1 +250,1 @@\n-    if (xtty != NULL)  xtty->head(\"statistics type='opto'\");\n+    if (xtty != nullptr)  xtty->head(\"statistics type='opto'\");\n@@ -257,1 +257,1 @@\n-    if (xtty != NULL)  xtty->tail(\"statistics\");\n+    if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -295,1 +295,1 @@\n-  useful.map( estimated_worklist_size, NULL );  \/\/ preallocate space\n+  useful.map( estimated_worklist_size, nullptr );  \/\/ preallocate space\n@@ -298,1 +298,1 @@\n-  if (root() != NULL)     { useful.push(root()); }\n+  if (root() != nullptr)  { useful.push(root()); }\n@@ -300,1 +300,1 @@\n-  if( cached_top_node() ) { useful.push(cached_top_node()); }\n+  if (cached_top_node())  { useful.push(cached_top_node()); }\n@@ -348,1 +348,1 @@\n-  assert(dead != NULL && dead->is_Call(), \"sanity\");\n+  assert(dead != nullptr && dead->is_Call(), \"sanity\");\n@@ -437,1 +437,1 @@\n-  if (_modified_nodes != NULL) {\n+  if (_modified_nodes != nullptr) {\n@@ -466,1 +466,1 @@\n-  assert(env->compiler_data() == NULL, \"compile already active?\");\n+  assert(env->compiler_data() == nullptr, \"compile already active?\");\n@@ -470,1 +470,1 @@\n-  compile->set_type_dict(NULL);\n+  compile->set_type_dict(nullptr);\n@@ -474,3 +474,3 @@\n-  compile->set_last_tf(NULL, NULL);\n-  compile->set_indexSet_arena(NULL);\n-  compile->set_indexSet_free_block_list(NULL);\n+  compile->set_last_tf(nullptr, nullptr);\n+  compile->set_indexSet_arena(nullptr);\n+  compile->set_indexSet_free_block_list(nullptr);\n@@ -484,1 +484,1 @@\n-  _compile->env()->set_compiler_data(NULL);\n+  _compile->env()->set_compiler_data(nullptr);\n@@ -554,3 +554,3 @@\n-                  _stub_function(NULL),\n-                  _stub_name(NULL),\n-                  _stub_entry_point(NULL),\n+                  _stub_function(nullptr),\n+                  _stub_name(nullptr),\n+                  _stub_entry_point(nullptr),\n@@ -576,10 +576,10 @@\n-                  _failure_reason(NULL),\n-                  _intrinsics        (comp_arena(), 0, 0, NULL),\n-                  _macro_nodes       (comp_arena(), 8, 0, NULL),\n-                  _predicate_opaqs   (comp_arena(), 8, 0, NULL),\n-                  _skeleton_predicate_opaqs (comp_arena(), 8, 0, NULL),\n-                  _expensive_nodes   (comp_arena(), 8, 0, NULL),\n-                  _for_post_loop_igvn(comp_arena(), 8, 0, NULL),\n-                  _coarsened_locks   (comp_arena(), 8, 0, NULL),\n-                  _congraph(NULL),\n-                  NOT_PRODUCT(_printer(NULL) COMMA)\n+                  _failure_reason(nullptr),\n+                  _intrinsics        (comp_arena(), 0, 0, nullptr),\n+                  _macro_nodes       (comp_arena(), 8, 0, nullptr),\n+                  _predicate_opaqs   (comp_arena(), 8, 0, nullptr),\n+                  _skeleton_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n+                  _expensive_nodes   (comp_arena(), 8, 0, nullptr),\n+                  _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n+                  _coarsened_locks   (comp_arena(), 8, 0, nullptr),\n+                  _congraph(nullptr),\n+                  NOT_PRODUCT(_printer(nullptr) COMMA)\n@@ -590,1 +590,1 @@\n-                  _mach_constant_base_node(NULL),\n+                  _mach_constant_base_node(nullptr),\n@@ -592,6 +592,6 @@\n-                  _initial_gvn(NULL),\n-                  _for_igvn(NULL),\n-                  _late_inlines(comp_arena(), 2, 0, NULL),\n-                  _string_late_inlines(comp_arena(), 2, 0, NULL),\n-                  _boxing_late_inlines(comp_arena(), 2, 0, NULL),\n-                  _vector_reboxing_late_inlines(comp_arena(), 2, 0, NULL),\n+                  _initial_gvn(nullptr),\n+                  _for_igvn(nullptr),\n+                  _late_inlines(comp_arena(), 2, 0, nullptr),\n+                  _string_late_inlines(comp_arena(), 2, 0, nullptr),\n+                  _boxing_late_inlines(comp_arena(), 2, 0, nullptr),\n+                  _vector_reboxing_late_inlines(comp_arena(), 2, 0, nullptr),\n@@ -602,1 +602,1 @@\n-                  _print_inlining_list(NULL),\n+                  _print_inlining_list(nullptr),\n@@ -604,2 +604,2 @@\n-                  _print_inlining_output(NULL),\n-                  _replay_inline_data(NULL),\n+                  _print_inlining_output(nullptr),\n+                  _replay_inline_data(nullptr),\n@@ -624,1 +624,1 @@\n-  TraceTime t2(NULL, &_t_methodCompilation, CITime, false);\n+  TraceTime t2(nullptr, &_t_methodCompilation, CITime, false);\n@@ -685,1 +685,1 @@\n-    CallGenerator* cg = NULL;\n+    CallGenerator* cg = nullptr;\n@@ -708,1 +708,1 @@\n-      if (cg == NULL) {\n+      if (cg == nullptr) {\n@@ -715,1 +715,1 @@\n-    if (cg == NULL) {\n+    if (cg == nullptr) {\n@@ -720,1 +720,1 @@\n-    if ((jvms = cg->generate(jvms)) == NULL) {\n+    if ((jvms = cg->generate(jvms)) == nullptr) {\n@@ -764,1 +764,1 @@\n-  set_default_node_notes(NULL);\n+  set_default_node_notes(nullptr);\n@@ -784,1 +784,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -800,1 +800,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -806,1 +806,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -821,1 +821,1 @@\n-  if (directive->DumpInlineOption && (ilt() != NULL)) {\n+  if (directive->DumpInlineOption && (ilt() != nullptr)) {\n@@ -855,1 +855,1 @@\n-    _method(NULL),\n+    _method(nullptr),\n@@ -859,1 +859,1 @@\n-    _stub_entry_point(NULL),\n+    _stub_entry_point(nullptr),\n@@ -878,3 +878,3 @@\n-    _failure_reason(NULL),\n-    _congraph(NULL),\n-    NOT_PRODUCT(_printer(NULL) COMMA)\n+    _failure_reason(nullptr),\n+    _congraph(nullptr),\n+    NOT_PRODUCT(_printer(nullptr) COMMA)\n@@ -885,1 +885,1 @@\n-    _mach_constant_base_node(NULL),\n+    _mach_constant_base_node(nullptr),\n@@ -887,2 +887,2 @@\n-    _initial_gvn(NULL),\n-    _for_igvn(NULL),\n+    _initial_gvn(nullptr),\n+    _for_igvn(nullptr),\n@@ -892,1 +892,1 @@\n-    _print_inlining_list(NULL),\n+    _print_inlining_list(nullptr),\n@@ -894,2 +894,2 @@\n-    _print_inlining_output(NULL),\n-    _replay_inline_data(NULL),\n+    _print_inlining_output(nullptr),\n+    _replay_inline_data(nullptr),\n@@ -905,2 +905,2 @@\n-  TraceTime t1(NULL, &_t_totalCompilation, CITime, false);\n-  TraceTime t2(NULL, &_t_stubCompilation, CITime, false);\n+  TraceTime t1(nullptr, &_t_totalCompilation, CITime, false);\n+  TraceTime t2(nullptr, &_t_stubCompilation, CITime, false);\n@@ -941,1 +941,1 @@\n-  _regalloc = NULL;\n+  _regalloc = nullptr;\n@@ -943,4 +943,4 @@\n-  _tf      = NULL;  \/\/ filled in later\n-  _top     = NULL;  \/\/ cached later\n-  _matcher = NULL;  \/\/ filled in later\n-  _cfg     = NULL;  \/\/ filled in later\n+  _tf      = nullptr;  \/\/ filled in later\n+  _top     = nullptr;  \/\/ cached later\n+  _matcher = nullptr;  \/\/ filled in later\n+  _cfg     = nullptr;  \/\/ filled in later\n@@ -950,3 +950,3 @@\n-  _node_note_array = NULL;\n-  _default_node_notes = NULL;\n-  DEBUG_ONLY( _modified_nodes = NULL; ) \/\/ Used in Optimize()\n+  _node_note_array = nullptr;\n+  _default_node_notes = nullptr;\n+  DEBUG_ONLY( _modified_nodes = nullptr; ) \/\/ Used in Optimize()\n@@ -954,1 +954,1 @@\n-  _immutable_memory = NULL; \/\/ filled in at first inquiry\n+  _immutable_memory = nullptr; \/\/ filled in at first inquiry\n@@ -963,2 +963,2 @@\n-  \/\/ First set TOP to NULL to give safe behavior during creation of RootNode\n-  set_cached_top_node(NULL);\n+  \/\/ First set TOP to null to give safe behavior during creation of RootNode\n+  set_cached_top_node(nullptr);\n@@ -968,1 +968,1 @@\n-  set_recent_alloc(NULL, NULL);\n+  set_recent_alloc(nullptr, nullptr);\n@@ -1014,1 +1014,1 @@\n-  if (UseRTMLocking && has_method() && (method()->method_data_or_null() != NULL)) {\n+  if (UseRTMLocking && has_method() && (method()->method_data_or_null() != nullptr)) {\n@@ -1034,1 +1034,1 @@\n-                        (comp_arena(), 8, 0, NULL));\n+                        (comp_arena(), 8, 0, nullptr));\n@@ -1056,1 +1056,1 @@\n-  _alias_types[AliasIdxTop]->Init(AliasIdxTop, NULL);\n+  _alias_types[AliasIdxTop]->Init(AliasIdxTop, nullptr);\n@@ -1062,2 +1062,2 @@\n-  \/\/ A NULL adr_type hits in the cache right away.  Preload the right answer.\n-  probe_alias_cache(NULL)->_index = AliasIdxTop;\n+  \/\/ A null adr_type hits in the cache right away.  Preload the right answer.\n+  probe_alias_cache(nullptr)->_index = AliasIdxTop;\n@@ -1088,1 +1088,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1094,1 +1094,1 @@\n-  if (_immutable_memory != NULL) {\n+  if (_immutable_memory != nullptr) {\n@@ -1106,1 +1106,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1112,1 +1112,1 @@\n-  if (tn != NULL)  verify_top(tn);\n+  if (tn != nullptr)  verify_top(tn);\n@@ -1117,3 +1117,3 @@\n-  if (_top != NULL)     _top->setup_is_top();\n-  if (old_top != NULL)  old_top->setup_is_top();\n-  assert(_top == NULL || top()->is_top(), \"\");\n+  if (_top != nullptr)     _top->setup_is_top();\n+  if (old_top != nullptr)  old_top->setup_is_top();\n+  assert(_top == nullptr || top()->is_top(), \"\");\n@@ -1132,2 +1132,2 @@\n-  \/\/ Return if CompileLog is NULL and PrintIdealNodeCount is false.\n-  if ((_log == NULL) && (! PrintIdealNodeCount)) {\n+  \/\/ Return if CompileLog is null and PrintIdealNodeCount is false.\n+  if ((_log == nullptr) && (! PrintIdealNodeCount)) {\n@@ -1151,1 +1151,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -1161,1 +1161,1 @@\n-          if (_log != NULL) {\n+          if (_log != nullptr) {\n@@ -1172,1 +1172,1 @@\n-        if (_log != NULL) {\n+        if (_log != nullptr) {\n@@ -1181,1 +1181,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -1187,1 +1187,1 @@\n-  if (_modified_nodes != NULL && !_inlining_incrementally && !n->is_Con()) {\n+  if (_modified_nodes != nullptr && !_inlining_incrementally && !n->is_Con()) {\n@@ -1193,1 +1193,1 @@\n-  if (_modified_nodes != NULL) {\n+  if (_modified_nodes != nullptr) {\n@@ -1201,1 +1201,1 @@\n-  if (tn != NULL) {\n+  if (tn != nullptr) {\n@@ -1204,1 +1204,1 @@\n-    assert(tn->in(0) != NULL, \"must have live top node\");\n+    assert(tn->in(0) != nullptr, \"must have live top node\");\n@@ -1213,1 +1213,1 @@\n-  guarantee(arr != NULL, \"\");\n+  guarantee(arr != nullptr, \"\");\n@@ -1228,1 +1228,1 @@\n-  if (source == NULL || dest == NULL)  return false;\n+  if (source == nullptr || dest == nullptr)  return false;\n@@ -1235,1 +1235,1 @@\n-  if (dest != NULL && dest != source && dest->debug_orig() == NULL) {\n+  if (dest != nullptr && dest != source && dest->debug_orig() == nullptr) {\n@@ -1240,1 +1240,1 @@\n-  if (node_note_array() == NULL)\n+  if (node_note_array() == nullptr)\n@@ -1246,1 +1246,1 @@\n-  if (source_notes == NULL || source_notes->is_clear())  return false;\n+  if (source_notes == nullptr || source_notes->is_clear())  return false;\n@@ -1248,1 +1248,1 @@\n-  if (dest_notes == NULL || dest_notes->is_clear()) {\n+  if (dest_notes == nullptr || dest_notes->is_clear()) {\n@@ -1281,1 +1281,1 @@\n-  bool is_known_inst = tj->isa_oopptr() != NULL &&\n+  bool is_known_inst = tj->isa_oopptr() != nullptr &&\n@@ -1337,1 +1337,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,offset);\n@@ -1341,1 +1341,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,offset);\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,offset);\n@@ -1353,1 +1353,1 @@\n-    if (ptr == TypePtr::NotNull || ta->klass_is_exact() || ta->speculative() != NULL) {\n+    if (ptr == TypePtr::NotNull || ta->klass_is_exact() || ta->speculative() != nullptr) {\n@@ -1378,1 +1378,1 @@\n-    if (to->speculative() != NULL) {\n+    if (to->speculative() != nullptr) {\n@@ -1386,1 +1386,1 @@\n-        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, NULL, offset);\n+        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, nullptr, offset);\n@@ -1392,1 +1392,1 @@\n-        to = NULL;\n+        to = nullptr;\n@@ -1401,1 +1401,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, offset, to->instance_id());\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, nullptr, offset, to->instance_id());\n@@ -1403,1 +1403,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, NULL, offset);\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, nullptr, offset);\n@@ -1503,2 +1503,2 @@\n-  _field = NULL;\n-  _element = NULL;\n+  _field = nullptr;\n+  _element = nullptr;\n@@ -1506,2 +1506,2 @@\n-  const TypeOopPtr *atoop = (at != NULL) ? at->isa_oopptr() : NULL;\n-  if (atoop != NULL && atoop->is_known_instance()) {\n+  const TypeOopPtr *atoop = (at != nullptr) ? at->isa_oopptr() : nullptr;\n+  if (atoop != nullptr && atoop->is_known_instance()) {\n@@ -1516,1 +1516,1 @@\n-  if (element() != NULL) {\n+  if (element() != nullptr) {\n@@ -1519,1 +1519,1 @@\n-  } if (field() != NULL) {\n+  } if (field() != nullptr) {\n@@ -1540,1 +1540,1 @@\n-  if (field() != NULL && tjp) {\n+  if (field() != nullptr && tjp) {\n@@ -1593,1 +1593,1 @@\n-  if (adr_type == NULL)             return alias_type(AliasIdxTop);\n+  if (adr_type == nullptr)          return alias_type(AliasIdxTop);\n@@ -1626,1 +1626,1 @@\n-    if (no_create)  return NULL;\n+    if (no_create)  return nullptr;\n@@ -1673,1 +1673,1 @@\n-      if (tinst->const_oop() != NULL &&\n+      if (tinst->const_oop() != nullptr &&\n@@ -1683,2 +1683,2 @@\n-      assert(field == NULL ||\n-             original_field == NULL ||\n+      assert(field == nullptr ||\n+             original_field == nullptr ||\n@@ -1689,1 +1689,1 @@\n-      if (field != NULL)  alias_type(idx)->set_field(field);\n+      if (field != nullptr)  alias_type(idx)->set_field(field);\n@@ -1700,1 +1700,1 @@\n-  if (face->_adr_type == NULL) {\n+  if (face->_adr_type == nullptr) {\n@@ -1730,1 +1730,1 @@\n-  if (adr_type == NULL)             return true;\n+  if (adr_type == nullptr)             return true;\n@@ -1733,1 +1733,1 @@\n-  return find_alias_type(adr_type, true, NULL) != NULL;\n+  return find_alias_type(adr_type, true, nullptr) != nullptr;\n@@ -1740,1 +1740,1 @@\n-  if (adr_type == NULL)                 return true;  \/\/ NULL serves as TypePtr::TOP\n+  if (adr_type == nullptr)              return true;  \/\/ null serves as TypePtr::TOP\n@@ -1758,1 +1758,1 @@\n-  if (adr_type == NULL)                 return false; \/\/ NULL serves as TypePtr::TOP\n+  if (adr_type == nullptr)              return false; \/\/ null serves as TypePtr::TOP\n@@ -1953,1 +1953,1 @@\n-        if (do_print_inlining || log() != NULL) {\n+        if (do_print_inlining || log() != nullptr) {\n@@ -2006,1 +2006,1 @@\n-  \/\/ Tracking and verification of modified nodes is disabled by setting \"_modified_nodes == NULL\"\n+  \/\/ Tracking and verification of modified nodes is disabled by setting \"_modified_nodes == nullptr\"\n@@ -2009,1 +2009,1 @@\n-  assert(_modified_nodes == NULL, \"not allowed\");\n+  assert(_modified_nodes == nullptr, \"not allowed\");\n@@ -2044,1 +2044,1 @@\n-  if (r != NULL) {\n+  if (r != nullptr) {\n@@ -2047,1 +2047,1 @@\n-      if (n != NULL && n->is_SafePoint()) {\n+      if (n != nullptr && n->is_SafePoint()) {\n@@ -2182,1 +2182,1 @@\n-    if (congraph() != NULL && macro_count() > 0) {\n+    if (congraph() != nullptr && macro_count() > 0) {\n@@ -2290,1 +2290,1 @@\n-  DEBUG_ONLY( _modified_nodes = NULL; )\n+  DEBUG_ONLY( _modified_nodes = nullptr; )\n@@ -2515,1 +2515,1 @@\n-  assert(n != NULL, \"\");\n+  assert(n != nullptr, \"\");\n@@ -2857,1 +2857,1 @@\n-            if (mem->in(i) != NULL) {\n+            if (mem->in(i) != nullptr) {\n@@ -2910,1 +2910,1 @@\n-    assert( n->in(0) != NULL || alias_idx != Compile::AliasIdxRaw ||\n+    assert( n->in(0) != nullptr || alias_idx != Compile::AliasIdxRaw ||\n@@ -3106,2 +3106,2 @@\n-      bool is_oop   = t->isa_oopptr() != NULL;\n-      bool is_klass = t->isa_klassptr() != NULL;\n+      bool is_oop   = t->isa_oopptr() != nullptr;\n+      bool is_klass = t->isa_klassptr() != nullptr;\n@@ -3111,1 +3111,1 @@\n-        Node* nn = NULL;\n+        Node* nn = nullptr;\n@@ -3120,1 +3120,1 @@\n-          if (m!= NULL && m->Opcode() == op &&\n+          if (m!= nullptr && m->Opcode() == op &&\n@@ -3126,1 +3126,1 @@\n-        if (nn != NULL) {\n+        if (nn != nullptr) {\n@@ -3143,1 +3143,1 @@\n-                assert(out_j == NULL || !out_j->is_AddP() || out_j->in(AddPNode::Base) != addp,\n+                assert(out_j == nullptr || !out_j->is_AddP() || out_j->in(AddPNode::Base) != addp,\n@@ -3167,1 +3167,1 @@\n-    if (n->in(0) != NULL) {\n+    if (n->in(0) != nullptr) {\n@@ -3202,1 +3202,1 @@\n-        \/\/ a narrow oop directly and do implicit NULL check in address:\n+        \/\/ a narrow oop directly and do implicit null check in address:\n@@ -3208,1 +3208,1 @@\n-        \/\/ use it to do implicit NULL check in address:\n+        \/\/ use it to do implicit null check in address:\n@@ -3215,1 +3215,1 @@\n-        \/\/ to keep the information to which NULL check the new DecodeN node\n+        \/\/ to keep the information to which null check the new DecodeN node\n@@ -3246,1 +3246,1 @@\n-      Node* new_in2 = NULL;\n+      Node* new_in2 = nullptr;\n@@ -3261,1 +3261,1 @@\n-          \/\/ will generated code for implicit NULL checks for compressed oops.\n+          \/\/ will generated code for implicit null checks for compressed oops.\n@@ -3267,1 +3267,1 @@\n-          \/\/    CmpP base_reg, NULL\n+          \/\/    CmpP base_reg, nullptr\n@@ -3274,1 +3274,1 @@\n-          \/\/    CmpN narrow_oop_reg, NULL\n+          \/\/    CmpN narrow_oop_reg, nullptr\n@@ -3278,1 +3278,1 @@\n-          \/\/ and the uncommon path (== NULL) will use narrow_oop_reg directly\n+          \/\/ and the uncommon path (== nullptr) will use narrow_oop_reg directly\n@@ -3302,1 +3302,1 @@\n-      if (new_in2 != NULL) {\n+      if (new_in2 != nullptr) {\n@@ -3320,1 +3320,1 @@\n-    assert(n->in(0) == NULL || (UseCompressedOops && !Matcher::narrow_oop_use_complex_address()), \"no control\");\n+    assert(n->in(0) == nullptr || (UseCompressedOops && !Matcher::narrow_oop_use_complex_address()), \"no control\");\n@@ -3355,1 +3355,1 @@\n-        if (non_io_proj  != NULL) {\n+        if (non_io_proj  != nullptr) {\n@@ -3368,1 +3368,1 @@\n-      assert(unique_in != NULL, \"\");\n+      assert(unique_in != nullptr, \"\");\n@@ -3372,1 +3372,1 @@\n-        assert(m != NULL, \"\");\n+        assert(m != nullptr, \"\");\n@@ -3374,1 +3374,1 @@\n-          unique_in = NULL;\n+          unique_in = nullptr;\n@@ -3376,1 +3376,1 @@\n-      if (unique_in != NULL) {\n+      if (unique_in != nullptr) {\n@@ -3494,1 +3494,1 @@\n-      if (t != NULL && t->is_con()) {\n+      if (t != nullptr && t->is_con()) {\n@@ -3500,1 +3500,1 @@\n-        if (t == NULL || t->_lo < 0 || t->_hi > (int)mask) {\n+        if (t == nullptr || t->_lo < 0 || t->_hi > (int)mask) {\n@@ -3554,1 +3554,1 @@\n-          if (k == NULL) {\n+          if (k == nullptr) {\n@@ -3611,2 +3611,2 @@\n-      if (m != NULL && !frc._visited.test_set(m->_idx)) {\n-        if (m->is_SafePoint() && m->as_SafePoint()->jvms() != NULL) {\n+      if (m != nullptr && !frc._visited.test_set(m->_idx)) {\n+        if (m->is_SafePoint() && m->as_SafePoint()->jvms() != nullptr) {\n@@ -3646,1 +3646,1 @@\n-    assert(jvms != NULL, \"sanity\");\n+    assert(jvms != nullptr, \"sanity\");\n@@ -3717,1 +3717,1 @@\n-    _expensive_nodes.at(i)->set_req(0, NULL);\n+    _expensive_nodes.at(i)->set_req(0, nullptr);\n@@ -3810,1 +3810,1 @@\n-        if (in != NULL) {\n+        if (in != nullptr) {\n@@ -3848,1 +3848,1 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : NULL;\n+  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : nullptr;\n@@ -3871,1 +3871,1 @@\n-      int mcount = (logmd == NULL)? -1: (int)logmd->trap_count(reason);\n+      int mcount = (logmd == nullptr)? -1: (int)logmd->trap_count(reason);\n@@ -3902,1 +3902,1 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : NULL;\n+  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : nullptr;\n@@ -4030,1 +4030,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -4033,1 +4033,1 @@\n-  if (_failure_reason == NULL) {\n+  if (_failure_reason == nullptr) {\n@@ -4041,1 +4041,1 @@\n-  _root = NULL;  \/\/ flush the graph, too\n+  _root = nullptr;  \/\/ flush the graph, too\n@@ -4052,2 +4052,2 @@\n-    C = NULL;\n-    _log = NULL;\n+    C = nullptr;\n+    _log = nullptr;\n@@ -4055,1 +4055,1 @@\n-  if (_log != NULL) {\n+  if (_log != nullptr) {\n@@ -4068,1 +4068,1 @@\n-    _log = NULL;\n+    _log = nullptr;\n@@ -4082,1 +4082,1 @@\n-  if (_log != NULL) {\n+  if (_log != nullptr) {\n@@ -4156,1 +4156,1 @@\n-  if (sizetype != NULL) index_max = sizetype->_hi - 1;\n+  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n@@ -4165,1 +4165,1 @@\n-  if (ctrl != NULL) {\n+  if (ctrl != nullptr) {\n@@ -4237,1 +4237,1 @@\n-          (print_inlining_current()->cg() != NULL ||\n+          (print_inlining_current()->cg() != nullptr ||\n@@ -4244,1 +4244,1 @@\n-      if (print_inlining_current()->cg() != NULL) {\n+      if (print_inlining_current()->cg() != nullptr) {\n@@ -4286,1 +4286,1 @@\n-    assert(_print_inlining_list != NULL, \"process_print_inlining should be called only once.\");\n+    assert(_print_inlining_list != nullptr, \"process_print_inlining should be called only once.\");\n@@ -4291,1 +4291,1 @@\n-      DEBUG_ONLY(_print_inlining_list->at_put(i, NULL));\n+      DEBUG_ONLY(_print_inlining_list->at_put(i, nullptr));\n@@ -4295,1 +4295,1 @@\n-    _print_inlining_list = NULL;\n+    _print_inlining_list = nullptr;\n@@ -4306,1 +4306,1 @@\n-  if (_print_inlining_output != NULL) {\n+  if (_print_inlining_output != nullptr) {\n@@ -4312,1 +4312,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -4316,1 +4316,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -4326,1 +4326,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -4332,1 +4332,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -4347,1 +4347,1 @@\n-  if (C->log() != NULL) {\n+  if (C->log() != nullptr) {\n@@ -4357,1 +4357,1 @@\n-  if (inl_tree != NULL) {\n+  if (inl_tree != nullptr) {\n@@ -4458,1 +4458,1 @@\n-      igvn.replace_input_of(n, 0, NULL);\n+      igvn.replace_input_of(n, 0, nullptr);\n@@ -4467,1 +4467,1 @@\n-    igvn.replace_input_of(n, 0, NULL);\n+    igvn.replace_input_of(n, 0, nullptr);\n@@ -4486,1 +4486,1 @@\n-    n->set_req(0, NULL);\n+    n->set_req(0, nullptr);\n@@ -4634,1 +4634,1 @@\n-      assert((t == NULL) || (t == t->remove_speculative()), \"no more speculative types\");\n+      assert((t == nullptr) || (t == t->remove_speculative()), \"no more speculative types\");\n@@ -4798,1 +4798,1 @@\n-  if (n != NULL) {\n+  if (n != nullptr) {\n@@ -4801,1 +4801,1 @@\n-    ss.print_raw(\": NULL\");\n+    ss.print_raw(\": nullptr\");\n@@ -4813,1 +4813,1 @@\n-  if (_method != NULL && should_print(level)) {\n+  if (_method != nullptr && should_print(level)) {\n@@ -4821,2 +4821,2 @@\n-IdealGraphPrinter* Compile::_debug_file_printer = NULL;\n-IdealGraphPrinter* Compile::_debug_network_printer = NULL;\n+IdealGraphPrinter* Compile::_debug_file_printer = nullptr;\n+IdealGraphPrinter* Compile::_debug_network_printer = nullptr;\n@@ -4874,1 +4874,1 @@\n-  if (_debug_file_printer == NULL) {\n+  if (_debug_file_printer == nullptr) {\n@@ -4884,1 +4884,1 @@\n-  if (_debug_network_printer == NULL) {\n+  if (_debug_network_printer == nullptr) {\n@@ -4899,1 +4899,1 @@\n-  if (type != NULL && phase->type(value)->higher_equal(type)) {\n+  if (type != nullptr && phase->type(value)->higher_equal(type)) {\n@@ -4902,1 +4902,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":209,"deletions":209,"binary":false,"changes":418,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -83,1 +83,1 @@\n-    is_available = compiler != NULL && compiler->is_intrinsic_supported(mh, is_virtual) &&\n+    is_available = compiler != nullptr && compiler->is_intrinsic_supported(mh, is_virtual) &&\n@@ -97,1 +97,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -170,1 +170,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -204,1 +204,1 @@\n-    return slow_ctl; \/\/ Could be NULL if the check folds.\n+    return slow_ctl; \/\/ Could be null if the check folds.\n@@ -229,1 +229,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -751,2 +751,2 @@\n-\/\/ or NULL if it is obvious that the slow path can never be taken.\n-\/\/ Also, if region and the slow control are not NULL, the slow edge\n+\/\/ or null if it is obvious that the slow path can never be taken.\n+\/\/ Also, if region and the slow control are not null, the slow edge\n@@ -757,1 +757,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -764,1 +764,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -772,1 +772,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -775,1 +775,1 @@\n-  if (region != NULL)\n+  if (region != nullptr)\n@@ -794,1 +794,1 @@\n-    return NULL;                \/\/ already stopped\n+    return nullptr;                \/\/ already stopped\n@@ -796,1 +796,1 @@\n-    return NULL;                \/\/ index is already adequately typed\n+    return nullptr;                \/\/ index is already adequately typed\n@@ -800,1 +800,1 @@\n-  if (is_neg != NULL && pos_index != NULL) {\n+  if (is_neg != nullptr && pos_index != nullptr) {\n@@ -828,1 +828,1 @@\n-    return NULL;                \/\/ already stopped\n+    return nullptr;                \/\/ already stopped\n@@ -831,1 +831,1 @@\n-    return NULL;                \/\/ common case of whole-array copy\n+    return nullptr;                \/\/ common case of whole-array copy\n@@ -874,1 +874,1 @@\n-  Node* thread_obj_handle = LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(), TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  Node* thread_obj_handle = LoadNode::make(_gvn, nullptr, immutable_memory(), p, p->bottom_type()->is_ptr(), TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n@@ -886,1 +886,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -904,1 +904,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -960,2 +960,2 @@\n-    Node* if_ne = generate_slow_guard(bol, NULL);\n-    if (if_ne != NULL) {\n+    Node* if_ne = generate_slow_guard(bol, nullptr);\n+    if (if_ne != nullptr) {\n@@ -1113,1 +1113,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1159,1 +1159,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1165,2 +1165,2 @@\n-    Node* if_lt = generate_slow_guard(bol, NULL);\n-    if (if_lt != NULL) {\n+    Node* if_lt = generate_slow_guard(bol, nullptr);\n+    if (if_lt != nullptr) {\n@@ -1192,2 +1192,2 @@\n-  Node* if_gt = generate_slow_guard(bol, NULL);\n-  if (if_gt != NULL) {\n+  Node* if_gt = generate_slow_guard(bol, nullptr);\n+  if (if_gt != nullptr) {\n@@ -1201,2 +1201,2 @@\n-    Node* if_zero = generate_slow_guard(bol, NULL);\n-    if (if_zero != NULL) {\n+    Node* if_zero = generate_slow_guard(bol, nullptr);\n+    if (if_zero != nullptr) {\n@@ -1210,1 +1210,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1258,2 +1258,2 @@\n-  Node* if_lt = generate_slow_guard(bol, NULL);\n-  if (if_lt != NULL) {\n+  Node* if_lt = generate_slow_guard(bol, nullptr);\n+  if (if_lt != nullptr) {\n@@ -1334,1 +1334,1 @@\n-  Node* count = NULL;\n+  Node* count = nullptr;\n@@ -1341,1 +1341,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -1384,1 +1384,1 @@\n-  Node* newcopy = NULL;\n+  Node* newcopy = nullptr;\n@@ -1418,1 +1418,1 @@\n-    guarantee(alloc != NULL, \"created above\");\n+    guarantee(alloc != nullptr, \"created above\");\n@@ -1518,1 +1518,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -1551,1 +1551,1 @@\n-  Node* ch = is_store ? argument(2) : NULL;\n+  Node* ch = is_store ? argument(2) : nullptr;\n@@ -1595,1 +1595,1 @@\n-      n = _gvn.transform(new RoundDoubleNode(NULL, n));\n+      n = _gvn.transform(new RoundDoubleNode(nullptr, n));\n@@ -1611,1 +1611,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -1632,1 +1632,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -1652,1 +1652,1 @@\n-  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : NULL;\n+  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : nullptr;\n@@ -1654,1 +1654,1 @@\n-  const TypePtr* no_memory_effects = NULL;\n+  const TypePtr* no_memory_effects = nullptr;\n@@ -1657,1 +1657,1 @@\n-                                 a, top(), b, b ? top() : NULL);\n+                                 a, top(), b, b ? top() : nullptr);\n@@ -1672,1 +1672,1 @@\n-  if (d != NULL) {\n+  if (d != nullptr) {\n@@ -1692,1 +1692,1 @@\n-      Node* if_pow = generate_slow_guard(test, NULL);\n+      Node* if_pow = generate_slow_guard(test, nullptr);\n@@ -1697,1 +1697,1 @@\n-      if (if_pow != NULL) {\n+      if (if_pow != nullptr) {\n@@ -1699,1 +1699,1 @@\n-        address target = StubRoutines::dpow() != NULL ? StubRoutines::dpow() :\n+        address target = StubRoutines::dpow() != nullptr ? StubRoutines::dpow() :\n@@ -1701,1 +1701,1 @@\n-        const TypePtr* no_memory_effects = NULL;\n+        const TypePtr* no_memory_effects = nullptr;\n@@ -1722,1 +1722,1 @@\n-  return StubRoutines::dpow() != NULL ?\n+  return StubRoutines::dpow() != nullptr ?\n@@ -1733,1 +1733,1 @@\n-    return StubRoutines::dsin() != NULL ?\n+    return StubRoutines::dsin() != nullptr ?\n@@ -1737,1 +1737,1 @@\n-    return StubRoutines::dcos() != NULL ?\n+    return StubRoutines::dcos() != nullptr ?\n@@ -1741,1 +1741,1 @@\n-    return StubRoutines::dtan() != NULL ?\n+    return StubRoutines::dtan() != nullptr ?\n@@ -1745,1 +1745,1 @@\n-    return StubRoutines::dlog() != NULL ?\n+    return StubRoutines::dlog() != nullptr ?\n@@ -1749,1 +1749,1 @@\n-    return StubRoutines::dlog10() != NULL ?\n+    return StubRoutines::dlog10() != nullptr ?\n@@ -1764,1 +1764,1 @@\n-    return StubRoutines::dexp() != NULL ?\n+    return StubRoutines::dexp() != nullptr ?\n@@ -1802,1 +1802,1 @@\n-  Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, NULL, TypeRawPtr::BOTTOM, argument(0));\n+  Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, nullptr, TypeRawPtr::BOTTOM, argument(0));\n@@ -2064,2 +2064,2 @@\n-  if (base != NULL)  base_type = _gvn.type(base)->isa_ptr();\n-  if (base_type == NULL) {\n+  if (base != nullptr)  base_type = _gvn.type(base)->isa_ptr();\n+  if (base_type == nullptr) {\n@@ -2069,1 +2069,1 @@\n-    \/\/ Since this is a NULL+long form, we have to switch to a rawptr.\n+    \/\/ Since this is a null+long form, we have to switch to a rawptr.\n@@ -2082,1 +2082,1 @@\n-    if (offset_type != NULL &&\n+    if (offset_type != nullptr &&\n@@ -2092,1 +2092,1 @@\n-    \/\/ Otherwise, it might either be oop+off or NULL+addr.\n+    \/\/ Otherwise, it might either be oop+off or null+addr.\n@@ -2157,1 +2157,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -2179,1 +2179,1 @@\n-  ciKlass* sharpened_klass = NULL;\n+  ciKlass* sharpened_klass = nullptr;\n@@ -2182,1 +2182,1 @@\n-  if (alias_type->field() != NULL) {\n+  if (alias_type->field() != nullptr) {\n@@ -2192,1 +2192,1 @@\n-      if (elem_type != NULL) {\n+      if (elem_type != nullptr) {\n@@ -2200,1 +2200,1 @@\n-  if (sharpened_klass != NULL && sharpened_klass->is_loaded()) {\n+  if (sharpened_klass != nullptr && sharpened_klass->is_loaded()) {\n@@ -2212,1 +2212,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2311,1 +2311,1 @@\n-  \/\/ Can base be NULL? Otherwise, always on-heap access.\n+  \/\/ Can base be null? Otherwise, always on-heap access.\n@@ -2318,1 +2318,1 @@\n-  Node* val = is_store ? argument(4) : NULL;\n+  Node* val = is_store ? argument(4) : nullptr;\n@@ -2377,1 +2377,1 @@\n-    if (tjp != NULL) {\n+    if (tjp != nullptr) {\n@@ -2392,1 +2392,1 @@\n-    Node* p = NULL;\n+    Node* p = nullptr;\n@@ -2395,1 +2395,1 @@\n-    if (heap_base_oop != top() && field != NULL && field->is_constant() && !mismatched) {\n+    if (heap_base_oop != top() && field != nullptr && field->is_constant() && !mismatched) {\n@@ -2400,1 +2400,1 @@\n-    if (p == NULL) { \/\/ Could not constant fold the load\n+    if (p == nullptr) { \/\/ Could not constant fold the load\n@@ -2405,2 +2405,2 @@\n-           heap_base_oop == top() ||                  \/\/ - heap_base_oop is NULL or\n-           (can_access_non_heap && field == NULL))    \/\/ - heap_base_oop is potentially NULL\n+           heap_base_oop == top() ||                  \/\/ - heap_base_oop is null or\n+           (can_access_non_heap && field == nullptr)) \/\/ - heap_base_oop is potentially null\n@@ -2425,1 +2425,1 @@\n-      p = gvn().transform(new CastP2XNode(NULL, p));\n+      p = gvn().transform(new CastP2XNode(nullptr, p));\n@@ -2560,5 +2560,5 @@\n-  Node* receiver = NULL;\n-  Node* base     = NULL;\n-  Node* offset   = NULL;\n-  Node* oldval   = NULL;\n-  Node* newval   = NULL;\n+  Node* receiver = nullptr;\n+  Node* base     = nullptr;\n+  Node* offset   = nullptr;\n+  Node* oldval   = nullptr;\n+  Node* newval   = nullptr;\n@@ -2582,1 +2582,1 @@\n-      oldval   = NULL;\n+      oldval   = nullptr;\n@@ -2625,1 +2625,1 @@\n-        if (tjp != NULL) {\n+        if (tjp != nullptr) {\n@@ -2650,1 +2650,1 @@\n-    \/\/ Transformation of a value which could be NULL pointer (CastPP #NULL)\n+    \/\/ Transformation of a value which could be null pointer (CastPP #null)\n@@ -2656,1 +2656,1 @@\n-    if (oldval != NULL && _gvn.type(oldval) == TypePtr::NULL_PTR) {\n+    if (oldval != nullptr && _gvn.type(oldval) == TypePtr::NULL_PTR) {\n@@ -2662,1 +2662,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -2728,1 +2728,1 @@\n-  if (klsptr == NULL) {\n+  if (klsptr == nullptr) {\n@@ -2794,1 +2794,1 @@\n-  Node* kls = load_klass_from_mirror(cls, false, NULL, 0);\n+  Node* kls = load_klass_from_mirror(cls, false, nullptr, 0);\n@@ -2798,1 +2798,1 @@\n-  Node* test = NULL;\n+  Node* test = nullptr;\n@@ -2806,1 +2806,1 @@\n-    Node* inst = make_load(NULL, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n+    Node* inst = make_load(nullptr, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n@@ -2822,1 +2822,1 @@\n-  const TypePtr* no_memory_effects = NULL;\n+  const TypePtr* no_memory_effects = nullptr;\n@@ -2858,1 +2858,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n@@ -2888,1 +2888,1 @@\n-    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n@@ -2955,1 +2955,1 @@\n-  Node* junk = NULL;\n+  Node* junk = nullptr;\n@@ -2964,1 +2964,1 @@\n-  Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  Node* load = make_load(nullptr, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n@@ -2975,1 +2975,1 @@\n-\/\/ If the region is NULL, force never_see_null = true.\n+\/\/ If the region is null, force never_see_null = true.\n@@ -2981,1 +2981,1 @@\n-  if (region == NULL)  never_see_null = true;\n+  if (region == nullptr)  never_see_null = true;\n@@ -2984,1 +2984,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n@@ -2987,1 +2987,1 @@\n-  if (region != NULL) {\n+  if (region != nullptr) {\n@@ -3003,1 +3003,1 @@\n-  Node* mods = make_load(NULL, modp, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* mods = make_load(nullptr, modp, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3069,1 +3069,1 @@\n-  if (mirror_con == NULL)  return false;  \/\/ cannot happen?\n+  if (mirror_con == nullptr)  return false;  \/\/ cannot happen?\n@@ -3122,1 +3122,1 @@\n-    query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3127,1 +3127,1 @@\n-    if (generate_interface_guard(kls, region) != NULL)\n+    if (generate_interface_guard(kls, region) != nullptr)\n@@ -3136,1 +3136,1 @@\n-    if (generate_array_guard(kls, region) != NULL)\n+    if (generate_array_guard(kls, region) != nullptr)\n@@ -3149,1 +3149,1 @@\n-    if (generate_hidden_class_guard(kls, region) != NULL)\n+    if (generate_hidden_class_guard(kls, region) != nullptr)\n@@ -3164,1 +3164,1 @@\n-    if (generate_interface_guard(kls, region) != NULL)\n+    if (generate_interface_guard(kls, region) != nullptr)\n@@ -3167,1 +3167,1 @@\n-    if (generate_array_guard(kls, region) != NULL)\n+    if (generate_array_guard(kls, region) != nullptr)\n@@ -3172,1 +3172,1 @@\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+    kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n@@ -3187,1 +3187,1 @@\n-    query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3209,1 +3209,1 @@\n-  if (mirror_con == NULL) {\n+  if (mirror_con == nullptr) {\n@@ -3212,1 +3212,1 @@\n-  if (obj == NULL || obj->is_top()) {\n+  if (obj == nullptr || obj->is_top()) {\n@@ -3220,1 +3220,1 @@\n-  if (tm != NULL && tm->is_klass() &&\n+  if (tm != nullptr && tm->is_klass() &&\n@@ -3255,1 +3255,1 @@\n-  \/\/ Not-subtype or the mirror's klass ptr is NULL (in case it is a primitive).\n+  \/\/ Not-subtype or the mirror's klass ptr is null (in case it is a primitive).\n@@ -3326,1 +3326,1 @@\n-    Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);\n+    Node* kls = LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, adr_type, kls_type);\n@@ -3376,1 +3376,1 @@\n-    if (ctl == NULL || ctl == top()) {\n+    if (ctl == nullptr || ctl == top()) {\n@@ -3379,1 +3379,1 @@\n-    } else if (phi->in(i) == NULL) {\n+    } else if (phi->in(i) == nullptr) {\n@@ -3394,1 +3394,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3409,1 +3409,1 @@\n-  if (layout_val == NULL) {\n+  if (layout_val == nullptr) {\n@@ -3414,1 +3414,1 @@\n-      return NULL;                       \/\/ never a branch\n+      return nullptr;                       \/\/ never a branch\n@@ -3417,1 +3417,1 @@\n-      if (region != NULL)\n+      if (region != nullptr)\n@@ -3475,1 +3475,1 @@\n-    CallJavaNode* slow_call = NULL;\n+    CallJavaNode* slow_call = nullptr;\n@@ -3478,1 +3478,1 @@\n-      slow_call = generate_method_call(vmIntrinsics::_allocateUninitializedArray, false, false);\n+      slow_call = generate_method_call(vmIntrinsics::_allocateUninitializedArray, false, false, true);\n@@ -3480,1 +3480,1 @@\n-      slow_call = generate_method_call_static(vmIntrinsics::_newArray);\n+      slow_call = generate_method_call_static(vmIntrinsics::_newArray, true);\n@@ -3527,1 +3527,1 @@\n-  Node* non_array = generate_non_array_guard(load_object_klass(array), NULL);\n+  Node* non_array = generate_non_array_guard(load_object_klass(array), nullptr);\n@@ -3529,1 +3529,1 @@\n-  if (non_array != NULL) {\n+  if (non_array != nullptr) {\n@@ -3560,1 +3560,1 @@\n-  Node* newcopy = NULL;\n+  Node* newcopy = nullptr;\n@@ -3575,1 +3575,1 @@\n-    Node* klass_node = load_klass_from_mirror(array_type_mirror, false, NULL, 0);\n+    Node* klass_node = load_klass_from_mirror(array_type_mirror, false, nullptr, 0);\n@@ -3584,1 +3584,1 @@\n-    if (not_objArray != NULL) {\n+    if (not_objArray != nullptr) {\n@@ -3641,1 +3641,1 @@\n-          if (t_original->speculative_type() != NULL) {\n+          if (t_original->speculative_type() != nullptr) {\n@@ -3705,1 +3705,1 @@\n-  Node* target_call = make_load(NULL, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  Node* target_call = make_load(nullptr, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n@@ -3725,1 +3725,1 @@\n-LibraryCallKit::generate_method_call(vmIntrinsics::ID method_id, bool is_virtual, bool is_static) {\n+LibraryCallKit::generate_method_call(vmIntrinsicID method_id, bool is_virtual, bool is_static, bool res_not_null) {\n@@ -3734,0 +3734,8 @@\n+  if (res_not_null) {\n+    assert(tf->return_type() == T_OBJECT, \"\");\n+    const TypeTuple* range = tf->range();\n+    const Type** fields = TypeTuple::fields(range->cnt());\n+    fields[TypeFunc::Parms] = range->field_at(TypeFunc::Parms)->filter_speculative(TypePtr::NOTNULL);\n+    const TypeTuple* new_range = TypeTuple::make(range->cnt(), fields);\n+    tf = TypeFunc::make(tf->domain(), new_range);\n+  }\n@@ -3789,1 +3797,1 @@\n-  Node* obj = NULL;\n+  Node* obj = nullptr;\n@@ -3833,1 +3841,1 @@\n-  \/\/ The control of the load must be NULL. Otherwise, the load can move before\n+  \/\/ The control of the load must be null. Otherwise, the load can move before\n@@ -3835,1 +3843,1 @@\n-  Node* no_ctrl = NULL;\n+  Node* no_ctrl = nullptr;\n@@ -3883,1 +3891,1 @@\n-    CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static);\n+    CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static, false);\n@@ -3942,1 +3950,1 @@\n-  for (int n = 1; caller_jvms != NULL; caller_jvms = caller_jvms->caller(), n++) {\n+  for (int n = 1; caller_jvms != nullptr; caller_jvms = caller_jvms->caller(), n++) {\n@@ -3999,1 +4007,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -4151,1 +4159,1 @@\n-  assert(obj_size != NULL, \"\");\n+  assert(obj_size != nullptr, \"\");\n@@ -4155,1 +4163,1 @@\n-  AllocateNode* alloc = NULL;\n+  AllocateNode* alloc = nullptr;\n@@ -4161,1 +4169,1 @@\n-    guarantee(alloc != NULL && alloc->maybe_set_complete(&_gvn), \"\");\n+    guarantee(alloc != nullptr && alloc->maybe_set_complete(&_gvn), \"\");\n@@ -4172,1 +4180,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -4221,1 +4229,1 @@\n-        obj_type->speculative_type() != NULL &&\n+        obj_type->speculative_type() != nullptr &&\n@@ -4254,2 +4262,2 @@\n-    Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);\n-    if (array_ctl != NULL) {\n+    Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)nullptr);\n+    if (array_ctl != nullptr) {\n@@ -4260,1 +4268,1 @@\n-      Node* obj_size  = NULL;\n+      Node* obj_size  = nullptr;\n@@ -4267,2 +4275,2 @@\n-        Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);\n-        if (is_obja != NULL) {\n+        Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)nullptr);\n+        if (is_obja != nullptr) {\n@@ -4334,1 +4342,1 @@\n-      Node* obj_size  = NULL;\n+      Node* obj_size  = nullptr;\n@@ -4338,1 +4346,1 @@\n-      Node* alloc_obj = new_instance(obj_klass, NULL, &obj_size, \/*deoptimize_on_exception=*\/true);\n+      Node* alloc_obj = new_instance(obj_klass, nullptr, &obj_size, \/*deoptimize_on_exception=*\/true);\n@@ -4353,1 +4361,1 @@\n-      CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual);\n+      CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual, false, true);\n@@ -4382,1 +4390,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -4426,1 +4434,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4462,1 +4470,1 @@\n-  if (saved_jvms_before_guards != NULL && !stopped()) {\n+  if (saved_jvms_before_guards != nullptr && !stopped()) {\n@@ -4465,1 +4473,1 @@\n-    assert(alloc != NULL, \"only with a tightly coupled allocation\");\n+    assert(alloc != nullptr, \"only with a tightly coupled allocation\");\n@@ -4494,1 +4502,1 @@\n-    Node* prev_cast = NULL;\n+    Node* prev_cast = nullptr;\n@@ -4500,1 +4508,1 @@\n-        if (prev_cast == NULL) {\n+        if (prev_cast == nullptr) {\n@@ -4528,1 +4536,1 @@\n-    if (ary_type->isa_aryptr() && length_type != NULL) {\n+    if (ary_type->isa_aryptr() && length_type != nullptr) {\n@@ -4623,4 +4631,4 @@\n-  \/\/ if alloc == NULL we don't have to worry about a tightly coupled allocation so we can emit all needed guards\n-  \/\/ if saved_jvms_before_guards != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation\n-  \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we can't emit any guards\n-  bool can_emit_guards = (alloc == NULL || saved_jvms_before_guards != NULL);\n+  \/\/ if alloc == null we don't have to worry about a tightly coupled allocation so we can emit all needed guards\n+  \/\/ if saved_jvms_before_guards is not null (then alloc is not null) then we can handle guards and a tightly coupled allocation\n+  \/\/ if saved_jvms_before_guards is null and alloc is not null, we can't emit any guards\n+  bool can_emit_guards = (alloc == nullptr || saved_jvms_before_guards != nullptr);\n@@ -4642,1 +4650,1 @@\n-  src  = saved_jvms_before_guards != NULL ? null_check_oop(src, &null_ctl, true, true) : null_check(src, T_ARRAY);\n+  src  = saved_jvms_before_guards != nullptr ? null_check_oop(src, &null_ctl, true, true) : null_check(src, T_ARRAY);\n@@ -4647,1 +4655,1 @@\n-    \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we don't emit any\n+    \/\/ if saved_jvms_before_guards is null and alloc is not null, we don't emit any\n@@ -4665,1 +4673,1 @@\n-  bool has_src = (top_src != NULL && top_src->klass() != NULL);\n+  bool has_src = (top_src != nullptr && top_src->klass() != nullptr);\n@@ -4667,1 +4675,1 @@\n-  bool has_dest = (top_dest != NULL && top_dest->klass() != NULL);\n+  bool has_dest = (top_dest != nullptr && top_dest->klass() != nullptr);\n@@ -4683,1 +4691,1 @@\n-    ciKlass* src_k = NULL;\n+    ciKlass* src_k = nullptr;\n@@ -4686,1 +4694,1 @@\n-      if (src_k != NULL && src_k->is_array_klass()) {\n+      if (src_k != nullptr && src_k->is_array_klass()) {\n@@ -4691,1 +4699,1 @@\n-    ciKlass* dest_k = NULL;\n+    ciKlass* dest_k = nullptr;\n@@ -4694,1 +4702,1 @@\n-      if (dest_k != NULL && dest_k->is_array_klass()) {\n+      if (dest_k != nullptr && dest_k->is_array_klass()) {\n@@ -4705,1 +4713,1 @@\n-        has_src = (top_src != NULL && top_src->klass() != NULL);\n+        has_src = (top_src != nullptr && top_src->klass() != nullptr);\n@@ -4712,1 +4720,1 @@\n-        has_dest = (top_dest != NULL && top_dest->klass() != NULL);\n+        has_dest = (top_dest != nullptr && top_dest->klass() != nullptr);\n@@ -4737,1 +4745,1 @@\n-        if (src_k != NULL && src_k->is_array_klass()) {\n+        if (src_k != nullptr && src_k->is_array_klass()) {\n@@ -4743,1 +4751,1 @@\n-        if (dest_k != NULL && dest_k->is_array_klass()) {\n+        if (dest_k != nullptr && dest_k->is_array_klass()) {\n@@ -4761,1 +4769,1 @@\n-  if (saved_jvms_before_guards != NULL) {\n+  if (saved_jvms_before_guards != nullptr) {\n@@ -4840,1 +4848,1 @@\n-  ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,\n+  ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != nullptr, negative_length_guard_generated,\n@@ -4867,2 +4875,2 @@\n-  if (stopped())             return NULL;  \/\/ no fast path\n-  if (C->AliasLevel() == 0)  return NULL;  \/\/ no MergeMems around\n+  if (stopped())             return nullptr;  \/\/ no fast path\n+  if (C->AliasLevel() == 0)  return nullptr;  \/\/ no MergeMems around\n@@ -4871,1 +4879,1 @@\n-  if (alloc == NULL)  return NULL;\n+  if (alloc == nullptr)  return nullptr;\n@@ -4878,1 +4886,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4882,1 +4890,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4889,1 +4897,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -4985,1 +4993,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5095,1 +5103,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5144,1 +5152,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5192,1 +5200,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5252,1 +5260,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5305,2 +5313,2 @@\n-  address stubAddr = NULL;\n-  const char* stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char* stubName = nullptr;\n@@ -5309,1 +5317,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5441,1 +5449,1 @@\n-      call_stub_path = generate_guard(bol_gt, NULL, PROB_MIN);\n+      call_stub_path = generate_guard(bol_gt, nullptr, PROB_MIN);\n@@ -5466,1 +5474,1 @@\n-  if (call_stub_path != NULL) {\n+  if (call_stub_path != nullptr) {\n@@ -5604,2 +5612,2 @@\n-  Node* table = load_field_from_object(NULL, \"byteTable\", \"[I\", \/*decorators*\/ IN_HEAP, \/*is_static*\/ true, crc32c_class);\n-  assert (table != NULL, \"wrong version of java.util.zip.CRC32C\");\n+  Node* table = load_field_from_object(nullptr, \"byteTable\", \"[I\", \/*decorators*\/ IN_HEAP, \/*is_static*\/ true, crc32c_class);\n+  assert (table != nullptr, \"wrong version of java.util.zip.CRC32C\");\n@@ -5797,2 +5805,2 @@\n-                                        decorators, \/*is_static*\/ false, NULL);\n-  if (result == NULL) return false;\n+                                        decorators, \/*is_static*\/ false, nullptr);\n+  if (result == nullptr) return false;\n@@ -5820,2 +5828,2 @@\n-                                          decorators, \/*is_static*\/ false, NULL);\n-  if (referent == NULL) return false;\n+                                          decorators, \/*is_static*\/ false, nullptr);\n+  if (referent == nullptr) return false;\n@@ -5852,1 +5860,1 @@\n-  if (fromKls == NULL) {\n+  if (fromKls == nullptr) {\n@@ -5854,1 +5862,1 @@\n-    assert(tinst != NULL, \"obj is null\");\n+    assert(tinst != nullptr, \"obj is null\");\n@@ -5865,1 +5873,1 @@\n-  if (field == NULL) return (Node *) NULL;\n+  if (field == nullptr) return (Node *) nullptr;\n@@ -5901,1 +5909,1 @@\n-  if (fromKls == NULL) {\n+  if (fromKls == nullptr) {\n@@ -5903,1 +5911,1 @@\n-    assert(tinst != NULL, \"obj is null\");\n+    assert(tinst != nullptr, \"obj is null\");\n@@ -5915,1 +5923,1 @@\n-  assert(field != NULL, \"undefined field\");\n+  assert(field != nullptr, \"undefined field\");\n@@ -5934,1 +5942,1 @@\n-  address stubAddr = NULL;\n+  address stubAddr = nullptr;\n@@ -5950,1 +5958,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -5972,2 +5980,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -5981,1 +5989,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -5993,2 +6001,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -6010,1 +6018,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -6033,2 +6041,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -6045,1 +6053,1 @@\n-  if (embeddedCipherObj == NULL) return false;\n+  if (embeddedCipherObj == nullptr) return false;\n@@ -6049,1 +6057,1 @@\n-  assert(tinst != NULL, \"CBC obj is null\");\n+  assert(tinst != nullptr, \"CBC obj is null\");\n@@ -6062,1 +6070,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -6066,1 +6074,1 @@\n-  if (objRvec == NULL) return false;\n+  if (objRvec == nullptr) return false;\n@@ -6083,2 +6091,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -6101,1 +6109,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -6121,2 +6129,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -6133,1 +6141,1 @@\n-  if (embeddedCipherObj == NULL) return false;\n+  if (embeddedCipherObj == nullptr) return false;\n@@ -6137,1 +6145,1 @@\n-  assert(tinst != NULL, \"ECB obj is null\");\n+  assert(tinst != nullptr, \"ECB obj is null\");\n@@ -6150,1 +6158,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -6169,2 +6177,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -6175,1 +6183,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -6195,2 +6203,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -6206,1 +6214,1 @@\n-  if (embeddedCipherObj == NULL) return false;\n+  if (embeddedCipherObj == nullptr) return false;\n@@ -6209,1 +6217,1 @@\n-  assert(tinst != NULL, \"CTR obj is null\");\n+  assert(tinst != nullptr, \"CTR obj is null\");\n@@ -6220,1 +6228,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -6223,1 +6231,1 @@\n-  if (obj_counter == NULL) return false;\n+  if (obj_counter == nullptr) return false;\n@@ -6227,1 +6235,1 @@\n-  if (saved_encCounter == NULL) return false;\n+  if (saved_encCounter == nullptr) return false;\n@@ -6251,3 +6259,3 @@\n-  assert (objSessionK != NULL, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n-  if (objSessionK == NULL) {\n-    return (Node *) NULL;\n+  assert (objSessionK != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n+  if (objSessionK == nullptr) {\n+    return (Node *) nullptr;\n@@ -6259,2 +6267,2 @@\n-  assert (objAESCryptKey != NULL, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n-  if (objAESCryptKey == NULL) return (Node *) NULL;\n+  assert (objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n+  if (objAESCryptKey == nullptr) return (Node *) nullptr;\n@@ -6277,1 +6285,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -6290,1 +6298,1 @@\n-  assert(tinst != NULL, \"CBCobj is null\");\n+  assert(tinst != nullptr, \"CBCobj is null\");\n@@ -6312,1 +6320,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -6316,1 +6324,1 @@\n-    return instof_false;  \/\/ even if it is NULL\n+    return instof_false;  \/\/ even if it is null\n@@ -6326,1 +6334,1 @@\n-  Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);\n+  Node* src_dest_conjoint = generate_guard(bool_src_dest, nullptr, PROB_MIN);\n@@ -6343,1 +6351,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -6353,1 +6361,1 @@\n-  assert(tinst != NULL, \"ECBobj is null\");\n+  assert(tinst != nullptr, \"ECBobj is null\");\n@@ -6370,1 +6378,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -6374,1 +6382,1 @@\n-    return instof_false;  \/\/ even if it is NULL\n+    return instof_false;  \/\/ even if it is null\n@@ -6385,1 +6393,1 @@\n-  Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);\n+  Node* src_dest_conjoint = generate_guard(bool_src_dest, nullptr, PROB_MIN);\n@@ -6403,1 +6411,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -6413,1 +6421,1 @@\n-  assert(tinst != NULL, \"CTRobj is null\");\n+  assert(tinst != nullptr, \"CTRobj is null\");\n@@ -6429,1 +6437,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -6431,1 +6439,1 @@\n-  return instof_false; \/\/ even if it is NULL\n+  return instof_false; \/\/ even if it is null\n@@ -6454,1 +6462,1 @@\n-  assert(state_start, \"state is NULL\");\n+  assert(state_start, \"state is null\");\n@@ -6456,1 +6464,1 @@\n-  assert(subkeyH_start, \"subkeyH is NULL\");\n+  assert(subkeyH_start, \"subkeyH is null\");\n@@ -6458,1 +6466,1 @@\n-  assert(data_start, \"data is NULL\");\n+  assert(data_start, \"data is null\");\n@@ -6488,1 +6496,1 @@\n-  assert(src_start, \"source array is NULL\");\n+  assert(src_start, \"source array is null\");\n@@ -6490,1 +6498,1 @@\n-  assert(dest_start, \"destination array is NULL\");\n+  assert(dest_start, \"destination array is null\");\n@@ -6521,1 +6529,1 @@\n-  assert(src_start, \"source array is NULL\");\n+  assert(src_start, \"source array is null\");\n@@ -6523,1 +6531,1 @@\n-  assert(dest_start, \"destination array is NULL\");\n+  assert(dest_start, \"destination array is null\");\n@@ -6572,2 +6580,2 @@\n-  Node* state = NULL;\n-  Node* digest_length = NULL;\n+  Node* state = nullptr;\n+  Node* digest_length = nullptr;\n@@ -6608,1 +6616,1 @@\n-    if (digest_length == NULL) return false;\n+    if (digest_length == nullptr) return false;\n@@ -6614,1 +6622,1 @@\n-  if (state == NULL) return false;\n+  if (state == nullptr) return false;\n@@ -6616,2 +6624,2 @@\n-  assert(stubAddr != NULL, \"Stub is generated\");\n-  if (stubAddr == NULL) return false;\n+  assert(stubAddr != nullptr, \"Stub is generated\");\n+  if (stubAddr == nullptr) return false;\n@@ -6621,1 +6629,1 @@\n-  if (digest_length == NULL) {\n+  if (digest_length == nullptr) {\n@@ -6645,1 +6653,1 @@\n-  Node* digestBase_obj = argument(0); \/\/ The receiver was checked for NULL already.\n+  Node* digestBase_obj = argument(0); \/\/ The receiver was checked for null already.\n@@ -6665,3 +6673,3 @@\n-  const char* klass_digestBase_name = NULL;\n-  const char* stub_name = NULL;\n-  address     stub_addr = NULL;\n+  const char* klass_digestBase_name = nullptr;\n+  const char* stub_name = nullptr;\n+  address     stub_addr = nullptr;\n@@ -6711,3 +6719,3 @@\n-  if (klass_digestBase_name != NULL) {\n-    assert(stub_addr != NULL, \"Stub is generated\");\n-    if (stub_addr == NULL) return false;\n+  if (klass_digestBase_name != nullptr) {\n+    assert(stub_addr != nullptr, \"Stub is generated\");\n+    if (stub_addr == nullptr) return false;\n@@ -6717,1 +6725,1 @@\n-    assert(tinst != NULL, \"digestBase_obj is not instance???\");\n+    assert(tinst != nullptr, \"digestBase_obj is not instance???\");\n@@ -6738,1 +6746,1 @@\n-  if (state == NULL) return false;\n+  if (state == nullptr) return false;\n@@ -6740,1 +6748,1 @@\n-  Node* digest_length = NULL;\n+  Node* digest_length = nullptr;\n@@ -6743,1 +6751,1 @@\n-    if (digest_length == NULL) return false;\n+    if (digest_length == nullptr) return false;\n@@ -6748,1 +6756,1 @@\n-  if (digest_length == NULL) {\n+  if (digest_length == nullptr) {\n@@ -6777,2 +6785,2 @@\n-  assert (digest_state != NULL, \"wrong version of sun.security.provider.MD5\/SHA\/SHA2\/SHA5\/SHA3\");\n-  if (digest_state == NULL) return (Node *) NULL;\n+  assert (digest_state != nullptr, \"wrong version of sun.security.provider.MD5\/SHA\/SHA2\/SHA5\/SHA3\");\n+  if (digest_state == nullptr) return (Node *) nullptr;\n@@ -6788,1 +6796,1 @@\n-  assert (digest_length != NULL, \"sanity\");\n+  assert (digest_length != nullptr, \"sanity\");\n@@ -6802,1 +6810,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -6807,1 +6815,1 @@\n-  assert(tinst != NULL, \"digestBaseObj is null\");\n+  assert(tinst != nullptr, \"digestBaseObj is null\");\n@@ -6810,1 +6818,1 @@\n-  const char* klass_name = NULL;\n+  const char* klass_name = nullptr;\n@@ -6846,2 +6854,2 @@\n-  ciKlass* klass = NULL;\n-  if (klass_name != NULL) {\n+  ciKlass* klass = nullptr;\n+  if (klass_name != nullptr) {\n@@ -6850,1 +6858,1 @@\n-  if ((klass == NULL) || !klass->is_loaded()) {\n+  if ((klass == nullptr) || !klass->is_loaded()) {\n@@ -6861,1 +6869,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -6863,1 +6871,1 @@\n-  return instof_false;  \/\/ even if it is NULL\n+  return instof_false;  \/\/ even if it is null\n@@ -6868,4 +6876,4 @@\n-  Node *a = NULL;\n-  Node *b = NULL;\n-  Node *c = NULL;\n-  Node* result = NULL;\n+  Node *a = nullptr;\n+  Node *b = nullptr;\n+  Node *c = nullptr;\n+  Node* result = nullptr;\n@@ -6898,1 +6906,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -6931,1 +6939,1 @@\n-  if ( md != NULL && md->is_mature() && md->invocation_count() > 0 ) {\n+  if ( md != nullptr && md->is_mature() && md->invocation_count() > 0 ) {\n@@ -6957,3 +6965,3 @@\n-  Node *a = NULL;\n-  Node *b = NULL;\n-  Node *n = NULL;\n+  Node *a = nullptr;\n+  Node *b = nullptr;\n+  Node *n = nullptr;\n@@ -6990,2 +6998,2 @@\n-  const TypeAryPtr* ary = NULL;\n-  ciArray* aobj = NULL;\n+  const TypeAryPtr* ary = nullptr;\n+  ciArray* aobj = nullptr;\n@@ -6993,2 +7001,2 @@\n-      && (ary = counts->bottom_type()->isa_aryptr()) != NULL\n-      && (aobj = ary->const_oop()->as_array()) != NULL\n+      && (ary = counts->bottom_type()->isa_aryptr()) != nullptr\n+      && (aobj = ary->const_oop()->as_array()) != nullptr\n@@ -7000,1 +7008,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -7081,1 +7089,1 @@\n-  int   layout_is_con = (layout_val == NULL);\n+  int   layout_is_con = (layout_val == nullptr);\n@@ -7129,2 +7137,2 @@\n-    Node* array_ctl = generate_array_guard(klass_node, NULL);\n-    if (array_ctl != NULL) {\n+    Node* array_ctl = generate_array_guard(klass_node, nullptr);\n+    if (array_ctl != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":318,"deletions":310,"binary":false,"changes":628,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-    } else if (j >= req && uin == NULL) {\n+    } else if (j >= req && uin == nullptr) {\n@@ -85,1 +85,1 @@\n-  assert(old != NULL, \"sanity\");\n+  assert(old != nullptr, \"sanity\");\n@@ -145,3 +145,3 @@\n-  if (parm0 != NULL)  call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL)  call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL)  call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm0 != nullptr)  call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr)  call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr)  call->init_req(TypeFunc::Parms+2, parm2);\n@@ -187,1 +187,1 @@\n-        ArrayCopyNode* ac = NULL;\n+        ArrayCopyNode* ac = nullptr;\n@@ -189,1 +189,1 @@\n-          if (ac != NULL) {\n+          if (ac != nullptr) {\n@@ -227,1 +227,1 @@\n-        if (init != NULL) {\n+        if (init != nullptr) {\n@@ -236,1 +236,1 @@\n-      Node* adr = NULL;\n+      Node* adr = nullptr;\n@@ -249,1 +249,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -259,1 +259,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -278,1 +278,1 @@\n-  Node* res = NULL;\n+  Node* res = nullptr;\n@@ -296,2 +296,2 @@\n-      Node* adr = NULL;\n-      const TypePtr* adr_type = NULL;\n+      Node* adr = nullptr;\n+      const TypePtr* adr_type = nullptr;\n@@ -321,1 +321,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -329,1 +329,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -336,1 +336,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -343,1 +343,1 @@\n-\/\/ Returns the computed Phi, or NULL if it cannot compute it.\n+\/\/ Returns the computed Phi, or null if it cannot compute it.\n@@ -361,1 +361,1 @@\n-  if (new_phi != NULL)\n+  if (new_phi != nullptr)\n@@ -365,1 +365,1 @@\n-    return NULL; \/\/ Give up: phi tree too deep\n+    return nullptr; \/\/ Give up: phi tree too deep\n@@ -371,1 +371,1 @@\n-  GrowableArray <Node *> values(length, length, NULL);\n+  GrowableArray <Node *> values(length, length, nullptr);\n@@ -374,1 +374,1 @@\n-  PhiNode *phi = new PhiNode(mem->in(0), phi_type, NULL, mem->_idx, instance_id, alias_idx, offset);\n+  PhiNode *phi = new PhiNode(mem->in(0), phi_type, nullptr, mem->_idx, instance_id, alias_idx, offset);\n@@ -380,1 +380,1 @@\n-    if (in == NULL || in->is_top()) {\n+    if (in == nullptr || in->is_top()) {\n@@ -392,2 +392,2 @@\n-      if (val == NULL) {\n-        return NULL;  \/\/ can't find a value on this path\n+      if (val == nullptr) {\n+        return nullptr;  \/\/ can't find a value on this path\n@@ -409,2 +409,2 @@\n-        if (val == NULL) {\n-          return NULL;\n+        if (val == nullptr) {\n+          return nullptr;\n@@ -418,1 +418,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -421,2 +421,2 @@\n-        if (res == NULL) {\n-          return NULL;\n+        if (res == nullptr) {\n+          return nullptr;\n@@ -428,1 +428,1 @@\n-        return NULL;  \/\/ unknown node on this path\n+        return nullptr;  \/\/ unknown node on this path\n@@ -460,1 +460,1 @@\n-      return NULL;  \/\/ found a loop, give up\n+      return nullptr;  \/\/ found a loop, give up\n@@ -467,1 +467,1 @@\n-      if (mem == NULL) {\n+      if (mem == nullptr) {\n@@ -476,1 +476,1 @@\n-      assert(atype != NULL, \"address type must be oopptr\");\n+      assert(atype != nullptr, \"address type must be oopptr\");\n@@ -483,1 +483,1 @@\n-      Node *unique_input = NULL;\n+      Node *unique_input = nullptr;\n@@ -487,1 +487,1 @@\n-        if (n == NULL || n == top || n == mem) {\n+        if (n == nullptr || n == top || n == mem) {\n@@ -489,1 +489,1 @@\n-        } else if (unique_input == NULL) {\n+        } else if (unique_input == nullptr) {\n@@ -496,1 +496,1 @@\n-      if (unique_input != NULL && unique_input != top) {\n+      if (unique_input != nullptr && unique_input != top) {\n@@ -508,1 +508,1 @@\n-  if (mem != NULL) {\n+  if (mem != nullptr) {\n@@ -521,1 +521,1 @@\n-      if (phi != NULL) {\n+      if (phi != nullptr) {\n@@ -543,1 +543,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -550,2 +550,2 @@\n-  NOT_PRODUCT( const char* fail_eliminate = NULL; )\n-  DEBUG_ONLY( Node* disq_node = NULL; )\n+  NOT_PRODUCT( const char* fail_eliminate = nullptr; )\n+  DEBUG_ONLY( Node* disq_node = nullptr; )\n@@ -555,2 +555,2 @@\n-  const TypeOopPtr* res_type = NULL;\n-  if (res == NULL) {\n+  const TypeOopPtr* res_type = nullptr;\n+  if (res == nullptr) {\n@@ -563,1 +563,1 @@\n-    if (res_type == NULL) {\n+    if (res_type == nullptr) {\n@@ -575,1 +575,1 @@\n-  if (can_eliminate && res != NULL) {\n+  if (can_eliminate && res != nullptr) {\n@@ -619,1 +619,1 @@\n-        if (sfptMem == NULL || sfptMem->is_top()) {\n+        if (sfptMem == nullptr || sfptMem->is_top()) {\n@@ -621,1 +621,1 @@\n-          NOT_PRODUCT(fail_eliminate = \"NULL or TOP memory\";)\n+          NOT_PRODUCT(fail_eliminate = \"null or TOP memory\";)\n@@ -651,1 +651,1 @@\n-      if (res == NULL)\n+      if (res == nullptr)\n@@ -657,1 +657,1 @@\n-      if (res == NULL)\n+      if (res == nullptr)\n@@ -662,1 +662,1 @@\n-      if (disq_node != NULL) {\n+      if (disq_node != nullptr) {\n@@ -678,1 +678,1 @@\n-  ciInstanceKlass* iklass = NULL;\n+  ciInstanceKlass* iklass = nullptr;\n@@ -683,1 +683,1 @@\n-  ciType* elem_type = NULL;\n+  ciType* elem_type = nullptr;\n@@ -686,3 +686,3 @@\n-  assert(res == NULL || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n-  const TypeOopPtr* res_type = NULL;\n-  if (res != NULL) { \/\/ Could be NULL when there are no users\n+  assert(res == nullptr || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n+  const TypeOopPtr* res_type = nullptr;\n+  if (res != nullptr) { \/\/ Could be null when there are no users\n@@ -692,1 +692,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -716,1 +716,1 @@\n-    assert(sfpt->jvms() != NULL, \"missed JVMS\");\n+    assert(sfpt->jvms() != nullptr, \"missed JVMS\");\n@@ -732,2 +732,2 @@\n-      ciField* field = NULL;\n-      if (iklass != NULL) {\n+      ciField* field = nullptr;\n+      if (iklass != nullptr) {\n@@ -747,1 +747,1 @@\n-        } else if (field != NULL && field->is_static_constant()) {\n+        } else if (field != nullptr && field->is_static_constant()) {\n@@ -753,1 +753,1 @@\n-          assert(field_type != NULL, \"field singleton type must be consistent\");\n+          assert(field_type != nullptr, \"field singleton type must be consistent\");\n@@ -768,1 +768,1 @@\n-      if (field_val == NULL) {\n+      if (field_val == nullptr) {\n@@ -806,1 +806,1 @@\n-          if (field != NULL) {\n+          if (field != nullptr) {\n@@ -817,1 +817,1 @@\n-          if (res == NULL)\n+          if (res == nullptr)\n@@ -852,1 +852,1 @@\n-  if (ctl_proj != NULL) {\n+  if (ctl_proj != nullptr) {\n@@ -855,1 +855,1 @@\n-  if (mem_proj != NULL) {\n+  if (mem_proj != nullptr) {\n@@ -863,1 +863,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -942,1 +942,1 @@\n-  if (_callprojs.resproj != NULL && _callprojs.resproj->outcnt() != 0) {\n+  if (_callprojs.resproj != nullptr && _callprojs.resproj->outcnt() != 0) {\n@@ -962,1 +962,1 @@\n-        if (ctrl_proj != NULL) {\n+        if (ctrl_proj != nullptr) {\n@@ -965,1 +965,1 @@\n-          \/\/ If the InitializeNode has no memory out, it will die, and tmp will become NULL\n+          \/\/ If the InitializeNode has no memory out, it will die, and tmp will become null\n@@ -967,1 +967,1 @@\n-          assert(tmp == NULL || tmp == _callprojs.fallthrough_catchproj, \"allocation control projection\");\n+          assert(tmp == nullptr || tmp == _callprojs.fallthrough_catchproj, \"allocation control projection\");\n@@ -971,1 +971,1 @@\n-        if (mem_proj != NULL) {\n+        if (mem_proj != nullptr) {\n@@ -988,1 +988,1 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n+  if (_callprojs.fallthrough_catchproj != nullptr) {\n@@ -991,1 +991,1 @@\n-  if (_callprojs.fallthrough_memproj != NULL) {\n+  if (_callprojs.fallthrough_memproj != nullptr) {\n@@ -994,1 +994,1 @@\n-  if (_callprojs.catchall_memproj != NULL) {\n+  if (_callprojs.catchall_memproj != nullptr) {\n@@ -997,1 +997,1 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n+  if (_callprojs.fallthrough_ioproj != nullptr) {\n@@ -1000,1 +1000,1 @@\n-  if (_callprojs.catchall_ioproj != NULL) {\n+  if (_callprojs.catchall_ioproj != nullptr) {\n@@ -1003,1 +1003,1 @@\n-  if (_callprojs.catchall_catchproj != NULL) {\n+  if (_callprojs.catchall_catchproj != nullptr) {\n@@ -1025,1 +1025,1 @@\n-  if (!alloc->_is_scalar_replaceable && (!boxing_alloc || (res != NULL))) {\n+  if (!alloc->_is_scalar_replaceable && (!boxing_alloc || (res != nullptr))) {\n@@ -1037,1 +1037,1 @@\n-    assert(res == NULL, \"sanity\");\n+    assert(res == nullptr, \"sanity\");\n@@ -1051,1 +1051,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1055,1 +1055,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -1078,1 +1078,1 @@\n-  if (!C->eliminate_boxing() || boxing->proj_out_or_null(TypeFunc::Parms) != NULL) {\n+  if (!C->eliminate_boxing() || boxing->proj_out_or_null(TypeFunc::Parms) != nullptr) {\n@@ -1082,1 +1082,1 @@\n-  assert(boxing->result_cast() == NULL, \"unexpected boxing node result\");\n+  assert(boxing->result_cast() == nullptr, \"unexpected boxing node result\");\n@@ -1089,1 +1089,1 @@\n-  assert(t != NULL, \"sanity\");\n+  assert(t != nullptr, \"sanity\");\n@@ -1092,1 +1092,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1096,1 +1096,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -1145,1 +1145,1 @@\n-  mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt, MemNode::unordered);\n+  mem = StoreNode::make(_igvn, ctl, mem, adr, nullptr, value, bt, MemNode::unordered);\n@@ -1218,1 +1218,1 @@\n-  assert(ctrl != NULL, \"must have control\");\n+  assert(ctrl != nullptr, \"must have control\");\n@@ -1223,4 +1223,4 @@\n-  Node *result_region = NULL;\n-  Node *result_phi_rawmem = NULL;\n-  Node *result_phi_rawoop = NULL;\n-  Node *result_phi_i_o = NULL;\n+  Node *result_region = nullptr;\n+  Node *result_phi_rawmem = nullptr;\n+  Node *result_phi_rawoop = nullptr;\n+  Node *result_phi_i_o = nullptr;\n@@ -1238,1 +1238,1 @@\n-    initial_slow_test = NULL;\n+    initial_slow_test = nullptr;\n@@ -1247,1 +1247,1 @@\n-    initial_slow_test = NULL;\n+    initial_slow_test = nullptr;\n@@ -1250,1 +1250,1 @@\n-  bool allocation_has_use = (alloc->result_cast() != NULL);\n+  bool allocation_has_use = (alloc->result_cast() != nullptr);\n@@ -1253,1 +1253,1 @@\n-    if (init != NULL) {\n+    if (init != nullptr) {\n@@ -1256,1 +1256,1 @@\n-    if (expand_fast_path && (initial_slow_test == NULL)) {\n+    if (expand_fast_path && (initial_slow_test == nullptr)) {\n@@ -1264,1 +1264,1 @@\n-        if (res != NULL) {\n+        if (res != nullptr) {\n@@ -1277,1 +1277,1 @@\n-  Node *slow_region = NULL;\n+  Node *slow_region = nullptr;\n@@ -1281,1 +1281,1 @@\n-  if (initial_slow_test != NULL ) {\n+  if (initial_slow_test != nullptr ) {\n@@ -1334,1 +1334,1 @@\n-      Node* needgc_ctrl = NULL;\n+      Node* needgc_ctrl = nullptr;\n@@ -1337,1 +1337,1 @@\n-      intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;\n+      intx prefetch_lines = length != nullptr ? AllocatePrefetchLines : AllocateInstancePrefetchLines;\n@@ -1343,1 +1343,1 @@\n-      if (initial_slow_test != NULL) {\n+      if (initial_slow_test != nullptr) {\n@@ -1362,1 +1362,1 @@\n-      assert (initial_slow_test != NULL, \"sanity\");\n+      assert (initial_slow_test != nullptr, \"sanity\");\n@@ -1388,1 +1388,1 @@\n-  if (length != NULL) {\n+  if (length != nullptr) {\n@@ -1398,1 +1398,1 @@\n-  if (valid_length_test != NULL) {\n+  if (valid_length_test != nullptr) {\n@@ -1427,1 +1427,1 @@\n-  if (expand_fast_path && _callprojs.fallthrough_memproj != NULL) {\n+  if (expand_fast_path && _callprojs.fallthrough_memproj != nullptr) {\n@@ -1432,2 +1432,2 @@\n-  if (_callprojs.catchall_memproj != NULL ) {\n-    if (_callprojs.fallthrough_memproj == NULL) {\n+  if (_callprojs.catchall_memproj != nullptr ) {\n+    if (_callprojs.fallthrough_memproj == nullptr) {\n@@ -1446,1 +1446,1 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n+  if (_callprojs.fallthrough_ioproj != nullptr) {\n@@ -1451,2 +1451,2 @@\n-  if (_callprojs.catchall_ioproj != NULL ) {\n-    if (_callprojs.fallthrough_ioproj == NULL) {\n+  if (_callprojs.catchall_ioproj != nullptr ) {\n+    if (_callprojs.fallthrough_ioproj == nullptr) {\n@@ -1476,1 +1476,1 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n+  if (_callprojs.fallthrough_catchproj != nullptr) {\n@@ -1484,1 +1484,1 @@\n-  if (_callprojs.resproj == NULL) {\n+  if (_callprojs.resproj == nullptr) {\n@@ -1513,1 +1513,1 @@\n-  if (_callprojs.resproj != NULL) {\n+  if (_callprojs.resproj != nullptr) {\n@@ -1523,1 +1523,1 @@\n-  if (_callprojs.fallthrough_catchproj != NULL) {\n+  if (_callprojs.fallthrough_catchproj != nullptr) {\n@@ -1527,1 +1527,1 @@\n-  if (_callprojs.catchall_catchproj != NULL) {\n+  if (_callprojs.catchall_catchproj != nullptr) {\n@@ -1531,1 +1531,1 @@\n-  if (_callprojs.fallthrough_proj != NULL) {\n+  if (_callprojs.fallthrough_proj != nullptr) {\n@@ -1536,1 +1536,1 @@\n-  if (_callprojs.fallthrough_memproj != NULL) {\n+  if (_callprojs.fallthrough_memproj != nullptr) {\n@@ -1540,1 +1540,1 @@\n-  if (_callprojs.fallthrough_ioproj != NULL) {\n+  if (_callprojs.fallthrough_ioproj != nullptr) {\n@@ -1544,1 +1544,1 @@\n-  if (_callprojs.catchall_memproj != NULL) {\n+  if (_callprojs.catchall_memproj != nullptr) {\n@@ -1548,1 +1548,1 @@\n-  if (_callprojs.catchall_ioproj != NULL) {\n+  if (_callprojs.catchall_ioproj != nullptr) {\n@@ -1582,2 +1582,2 @@\n-    (init == NULL || !init->is_complete_with_arraycopy())) {\n-    if (init == NULL || init->req() < InitializeNode::RawStores) {\n+    (init == nullptr || !init->is_complete_with_arraycopy())) {\n+    if (init == nullptr || init->req() < InitializeNode::RawStores) {\n@@ -1626,1 +1626,1 @@\n-      if (init_ctrl != NULL) {\n+      if (init_ctrl != nullptr) {\n@@ -1629,1 +1629,1 @@\n-      if (init_mem != NULL) {\n+      if (init_mem != nullptr) {\n@@ -1687,1 +1687,1 @@\n-  if (length != NULL) {         \/\/ Arrays need length field\n+  if (length != nullptr) {         \/\/ Arrays need length field\n@@ -1697,1 +1697,1 @@\n-  if (init == NULL) {\n+  if (init == nullptr) {\n@@ -1883,1 +1883,1 @@\n-  expand_allocate_common(alloc, NULL,\n+  expand_allocate_common(alloc, nullptr,\n@@ -1885,1 +1885,1 @@\n-                         OptoRuntime::new_instance_Java(), NULL);\n+                         OptoRuntime::new_instance_Java(), nullptr);\n@@ -1895,1 +1895,1 @@\n-  if (init != NULL && init->is_complete_with_arraycopy() &&\n+  if (init != nullptr && init->is_complete_with_arraycopy() &&\n@@ -1929,1 +1929,1 @@\n-      oldbox->as_BoxLock()->is_simple_lock_region(NULL, obj, NULL)) {\n+      oldbox->as_BoxLock()->is_simple_lock_region(nullptr, obj, nullptr)) {\n@@ -2021,1 +2021,1 @@\n-      if (alock->jvms() != NULL) {\n+      if (alock->jvms() != nullptr) {\n@@ -2049,1 +2049,1 @@\n-          if (C->log() != NULL)\n+          if (C->log() != nullptr)\n@@ -2107,1 +2107,1 @@\n-  guarantee(ctrl != NULL, \"missing control projection, cannot replace_node() with NULL\");\n+  guarantee(ctrl != nullptr, \"missing control projection, cannot replace_node() with null\");\n@@ -2113,2 +2113,2 @@\n-         _callprojs.fallthrough_proj != NULL &&\n-         _callprojs.fallthrough_memproj != NULL,\n+         _callprojs.fallthrough_proj != nullptr &&\n+         _callprojs.fallthrough_memproj != nullptr,\n@@ -2126,1 +2126,1 @@\n-    assert(membar != NULL && membar->Opcode() == Op_MemBarAcquireLock, \"\");\n+    assert(membar != nullptr && membar->Opcode() == Op_MemBarAcquireLock, \"\");\n@@ -2369,2 +2369,2 @@\n-                                  OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,\n-                                  obj, box, NULL);\n+                                  OptoRuntime::complete_monitor_locking_Java(), nullptr, slow_path,\n+                                  obj, box, nullptr);\n@@ -2378,2 +2378,2 @@\n-  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n-         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs.fallthrough_ioproj == nullptr && _callprojs.catchall_ioproj == nullptr &&\n+         _callprojs.catchall_memproj == nullptr && _callprojs.catchall_catchproj == nullptr, \"Unexpected projection from Lock\");\n@@ -2444,2 +2444,2 @@\n-  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n-         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs.fallthrough_ioproj == nullptr && _callprojs.catchall_ioproj == nullptr &&\n+         _callprojs.catchall_memproj == nullptr && _callprojs.catchall_catchproj == nullptr, \"Unexpected projection from Lock\");\n@@ -2468,1 +2468,1 @@\n-  assert(check->in(SubTypeCheckNode::Control) == NULL, \"should be pinned\");\n+  assert(check->in(SubTypeCheckNode::Control) == nullptr, \"should be pinned\");\n@@ -2487,1 +2487,1 @@\n-    Node* subklass = NULL;\n+    Node* subklass = nullptr;\n@@ -2492,1 +2492,1 @@\n-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), k_adr, TypeInstPtr::KLASS));\n@@ -2495,1 +2495,1 @@\n-    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, NULL, _igvn);\n+    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn);\n@@ -2624,1 +2624,1 @@\n-               ifn->proj_out(1)->is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, \"\");\n+               ifn->proj_out(1)->is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != nullptr, \"\");\n@@ -2681,1 +2681,1 @@\n-    if (_igvn.type(n) == Type::TOP || (n->in(0) != NULL && n->in(0)->is_top())) {\n+    if (_igvn.type(n) == Type::TOP || (n->in(0) != nullptr && n->in(0)->is_top())) {\n@@ -2734,1 +2734,1 @@\n-    if (_igvn.type(n) == Type::TOP || (n->in(0) != NULL && n->in(0)->is_top())) {\n+    if (_igvn.type(n) == Type::TOP || (n->in(0) != nullptr && n->in(0)->is_top())) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":155,"deletions":155,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-  if (adr == NULL)  return NULL; \/\/ node is dead\n-  const TypePtr* cross_check = NULL;\n+  if (adr == nullptr)  return nullptr; \/\/ node is dead\n+  const TypePtr* cross_check = nullptr;\n@@ -75,1 +75,1 @@\n-  if (adr != NULL) {\n+  if (adr != nullptr) {\n@@ -85,1 +85,1 @@\n-  if (in(Address) == NULL)  return; \/\/ node is dead\n+  if (in(Address) == nullptr)  return; \/\/ node is dead\n@@ -88,2 +88,2 @@\n-  const TypePtr* _adr_type = NULL;\n-  if (in(Address) != NULL)\n+  const TypePtr* _adr_type = nullptr;\n+  if (in(Address) != nullptr)\n@@ -111,2 +111,2 @@\n-  if (adr_type == NULL) {\n-    st->print(\"NULL\");\n+  if (adr_type == nullptr) {\n+    st->print(\"null\");\n@@ -116,1 +116,1 @@\n-    Compile::AliasType* atp = NULL;\n+    Compile::AliasType* atp = nullptr;\n@@ -118,1 +118,1 @@\n-    if (atp == NULL)\n+    if (atp == nullptr)\n@@ -142,1 +142,1 @@\n-  assert((t_oop != NULL), \"sanity\");\n+  assert((t_oop != nullptr), \"sanity\");\n@@ -145,2 +145,2 @@\n-                             (load != NULL) && load->is_Load() &&\n-                             (phase->is_IterGVN() != NULL);\n+                             (load != nullptr) && load->is_Load() &&\n+                             (phase->is_IterGVN() != nullptr);\n@@ -151,1 +151,1 @@\n-  Node *prev = NULL;\n+  Node *prev = nullptr;\n@@ -172,1 +172,1 @@\n-        if ((alloc == NULL) || (alloc->_idx == instance_id)) {\n+        if ((alloc == nullptr) || (alloc->_idx == instance_id)) {\n@@ -185,1 +185,1 @@\n-        ArrayCopyNode* ac = NULL;\n+        ArrayCopyNode* ac = nullptr;\n@@ -201,1 +201,1 @@\n-      result = step_through_mergemem(phase, result->as_MergeMem(), t_oop, NULL, tty);\n+      result = step_through_mergemem(phase, result->as_MergeMem(), t_oop, nullptr, tty);\n@@ -209,1 +209,1 @@\n-  if (t_oop == NULL)\n+  if (t_oop == nullptr)\n@@ -214,1 +214,1 @@\n-  if (is_instance && igvn != NULL && result->is_Phi()) {\n+  if (is_instance && igvn != nullptr && result->is_Phi()) {\n@@ -239,1 +239,1 @@\n-    bool consistent =  adr_check == NULL || adr_check->empty() ||\n+    bool consistent =  adr_check == nullptr || adr_check->empty() ||\n@@ -242,1 +242,1 @@\n-    if( !consistent && adr_check != NULL && !adr_check->empty() &&\n+    if( !consistent && adr_check != nullptr && !adr_check->empty() &&\n@@ -253,2 +253,2 @@\n-      if( adr_check == NULL ) {\n-        st->print(\"NULL\");\n+      if( adr_check == nullptr ) {\n+        st->print(\"null\");\n@@ -299,3 +299,3 @@\n-  if (ctl && can_reshape && igvn != NULL) {\n-    Node* bol = NULL;\n-    Node* cmp = NULL;\n+  if (ctl && can_reshape && igvn != nullptr) {\n+    Node* bol = nullptr;\n+    Node* cmp = nullptr;\n@@ -309,2 +309,2 @@\n-        (bol != NULL && igvn->_worklist.member(bol)) ||\n-        (cmp != NULL && igvn->_worklist.member(cmp)) ) {\n+        (bol != nullptr && igvn->_worklist.member(bol)) ||\n+        (cmp != nullptr && igvn->_worklist.member(cmp)) ) {\n@@ -314,1 +314,1 @@\n-      return NodeSentinel; \/\/ caller will return NULL\n+      return NodeSentinel; \/\/ caller will return null\n@@ -319,1 +319,1 @@\n-  if (phase->type( mem ) == Type::TOP) return NodeSentinel; \/\/ caller will return NULL\n+  if (phase->type( mem ) == Type::TOP) return NodeSentinel; \/\/ caller will return null\n@@ -322,1 +322,1 @@\n-  if (can_reshape && igvn != NULL && igvn->_worklist.member(mem)) {\n+  if (can_reshape && igvn != nullptr && igvn->_worklist.member(mem)) {\n@@ -326,1 +326,1 @@\n-    return NodeSentinel; \/\/ caller will return NULL\n+    return NodeSentinel; \/\/ caller will return null\n@@ -331,1 +331,1 @@\n-  if (t_adr == Type::TOP)              return NodeSentinel; \/\/ caller will return NULL\n+  if (t_adr == Type::TOP)              return NodeSentinel; \/\/ caller will return null\n@@ -336,1 +336,1 @@\n-    assert(ctl != NULL, \"unsafe accesses should be control dependent\");\n+    assert(ctl != nullptr, \"unsafe accesses should be control dependent\");\n@@ -351,1 +351,1 @@\n-  if (can_reshape && igvn != NULL &&\n+  if (can_reshape && igvn != nullptr &&\n@@ -357,1 +357,1 @@\n-    return NodeSentinel; \/\/ caller will return NULL\n+    return NodeSentinel; \/\/ caller will return null\n@@ -367,1 +367,1 @@\n-  Node* base = NULL;\n+  Node* base = nullptr;\n@@ -371,1 +371,1 @@\n-  if (base != NULL && phase->type(base)->higher_equal(TypePtr::NULL_PTR) &&\n+  if (base != nullptr && phase->type(base)->higher_equal(TypePtr::NULL_PTR) &&\n@@ -375,1 +375,1 @@\n-    return NodeSentinel; \/\/ caller will return NULL\n+    return NodeSentinel; \/\/ caller will return null\n@@ -406,1 +406,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -417,1 +417,1 @@\n-  if (dom == NULL || dom->is_top() || sub == NULL || sub->is_top())\n+  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n@@ -422,1 +422,1 @@\n-  if (dom == NULL || dom->is_top())\n+  if (dom == nullptr || dom->is_top())\n@@ -439,1 +439,1 @@\n-  \/\/ 'sub' should have sub->in(0) != NULL.\n+  \/\/ 'sub' should have sub->in(0) != nullptr.\n@@ -446,1 +446,1 @@\n-  if (sub == NULL || sub->is_top())\n+  if (sub == nullptr || sub->is_top())\n@@ -474,1 +474,1 @@\n-        if (n == NULL || n->is_top())\n+        if (n == nullptr || n->is_top())\n@@ -488,1 +488,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -497,1 +497,1 @@\n-          if (m == NULL || m->is_top())\n+          if (m == nullptr || m->is_top())\n@@ -519,1 +519,1 @@\n-  if (a1 == NULL && a2 == NULL) {           \/\/ neither an allocation\n+  if (a1 == nullptr && a2 == nullptr) {           \/\/ neither an allocation\n@@ -521,1 +521,1 @@\n-  } else if (a1 != NULL && a2 != NULL) {    \/\/ both allocations\n+  } else if (a1 != nullptr && a2 != nullptr) {    \/\/ both allocations\n@@ -523,1 +523,1 @@\n-  } else if (a1 != NULL) {                  \/\/ one allocation a1\n+  } else if (a1 != nullptr) {                  \/\/ one allocation a1\n@@ -526,1 +526,1 @@\n-  } else { \/\/(a2 != NULL)                   \/\/ one allocation a2\n+  } else { \/\/(a2 != null)                   \/\/ one allocation a2\n@@ -540,1 +540,1 @@\n-\/\/ Otherwise return NULL.\n+\/\/ Otherwise return null.\n@@ -543,1 +543,1 @@\n-  if (ac != NULL) {\n+  if (ac != nullptr) {\n@@ -551,1 +551,1 @@\n-    if (ary_t != NULL && ld_addp->is_AddP()) {\n+    if (ary_t != nullptr && ld_addp->is_AddP()) {\n@@ -567,2 +567,2 @@\n-    \/\/ dependent on the runtime range check. This is achieved by returning NULL.\n-  } else if (mem->is_Proj() && mem->in(0) != NULL && mem->in(0)->is_ArrayCopy()) {\n+    \/\/ dependent on the runtime range check. This is achieved by returning null.\n+  } else if (mem->is_Proj() && mem->in(0) != nullptr && mem->in(0)->is_ArrayCopy()) {\n@@ -594,1 +594,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -598,1 +598,1 @@\n-  if (mem->is_Proj() && mem->in(0) != NULL && (mem->in(0)->Opcode() == Op_MemBarStoreStore ||\n+  if (mem->is_Proj() && mem->in(0) != nullptr && (mem->in(0)->Opcode() == Op_MemBarStoreStore ||\n@@ -600,1 +600,1 @@\n-    if (ld_alloc != NULL) {\n+    if (ld_alloc != nullptr) {\n@@ -603,3 +603,3 @@\n-      ArrayCopyNode* ac = NULL;\n-      if (mb->in(0) != NULL && mb->in(0)->is_Proj() &&\n-          mb->in(0)->in(0) != NULL && mb->in(0)->in(0)->is_ArrayCopy()) {\n+      ArrayCopyNode* ac = nullptr;\n+      if (mb->in(0) != nullptr && mb->in(0)->is_Proj() &&\n+          mb->in(0)->in(0) != nullptr && mb->in(0)->in(0)->is_ArrayCopy()) {\n@@ -617,1 +617,1 @@\n-      if (ac != NULL && ac->is_clonebasic()) {\n+      if (ac != nullptr && ac->is_clonebasic()) {\n@@ -619,1 +619,1 @@\n-        if (alloc != NULL && alloc == ld_alloc) {\n+        if (alloc != nullptr && alloc == ld_alloc) {\n@@ -625,1 +625,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -649,1 +649,1 @@\n-    return NULL;            \/\/ cannot unalias unless there are precise offsets\n+    return nullptr;            \/\/ cannot unalias unless there are precise offsets\n@@ -667,1 +667,1 @@\n-      if (st_base == NULL)\n+      if (st_base == nullptr)\n@@ -710,1 +710,1 @@\n-      if (st_alloc == NULL)\n+      if (st_alloc == nullptr)\n@@ -716,1 +716,1 @@\n-      else if (alloc != NULL)\n+      else if (alloc != nullptr)\n@@ -741,1 +741,1 @@\n-    } else if (find_previous_arraycopy(phase, alloc, mem, false) != NULL) {\n+    } else if (find_previous_arraycopy(phase, alloc, mem, false) != nullptr) {\n@@ -748,1 +748,1 @@\n-    } else if (addr_t != NULL && addr_t->is_known_instance_field()) {\n+    } else if (addr_t != nullptr && addr_t->is_known_instance_field()) {\n@@ -758,1 +758,1 @@\n-        ArrayCopyNode* ac = NULL;\n+        ArrayCopyNode* ac = nullptr;\n@@ -785,1 +785,1 @@\n-  return NULL;              \/\/ bail out\n+  return nullptr;              \/\/ bail out\n@@ -792,1 +792,1 @@\n-  if (t == Type::TOP)  return NULL; \/\/ does not touch memory any more?\n+  if (t == Type::TOP)  return nullptr; \/\/ does not touch memory any more?\n@@ -794,1 +794,1 @@\n-  if (!VerifyAliases || VMError::is_error_reported() || Node::in_dump())  cross_check = NULL;\n+  if (!VerifyAliases || VMError::is_error_reported() || Node::in_dump())  cross_check = nullptr;\n@@ -797,2 +797,2 @@\n-  if (tp == NULL) {\n-    assert(cross_check == NULL || cross_check == TypePtr::BOTTOM, \"expected memory type must be wide\");\n+  if (tp == nullptr) {\n+    assert(cross_check == nullptr || cross_check == TypePtr::BOTTOM, \"expected memory type must be wide\");\n@@ -804,1 +804,1 @@\n-    if (cross_check != NULL &&\n+    if (cross_check != nullptr &&\n@@ -886,1 +886,1 @@\n-  assert( ctl != NULL || C->get_alias_index(adr_type) != Compile::AliasIdxRaw ||\n+  assert( ctl != nullptr || C->get_alias_index(adr_type) != Compile::AliasIdxRaw ||\n@@ -890,1 +890,1 @@\n-  LoadNode* load = NULL;\n+  LoadNode* load = nullptr;\n@@ -916,1 +916,1 @@\n-  assert(load != NULL, \"LoadNode should have been created\");\n+  assert(load != nullptr, \"LoadNode should have been created\");\n@@ -942,2 +942,2 @@\n-  if ((atp != NULL) && (atp->index() >= Compile::AliasIdxRaw)) {\n-    bool non_volatile = (atp->field() != NULL) && !atp->field()->is_volatile();\n+  if ((atp != nullptr) && (atp->index() >= Compile::AliasIdxRaw)) {\n+    bool non_volatile = (atp->field() != nullptr) && !atp->field()->is_volatile();\n@@ -945,1 +945,1 @@\n-                         (tp != NULL) && (tp->isa_aryptr() != NULL) &&\n+                         (tp != nullptr) && (tp->isa_aryptr() != nullptr) &&\n@@ -962,1 +962,1 @@\n-  if (ac != NULL) {\n+  if (ac != nullptr) {\n@@ -970,1 +970,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -976,1 +976,1 @@\n-      assert(ld_alloc != NULL, \"need an alloc\");\n+      assert(ld_alloc != nullptr, \"need an alloc\");\n@@ -1017,1 +1017,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1034,1 +1034,1 @@\n-  Compile::AliasType* atp = (tp != NULL) ? phase->C->alias_type(tp) : NULL;\n+  Compile::AliasType* atp = (tp != nullptr) ? phase->C->alias_type(tp) : nullptr;\n@@ -1038,1 +1038,1 @@\n-    Node* result = NULL;\n+    Node* result = nullptr;\n@@ -1075,1 +1075,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -1090,5 +1090,5 @@\n-        if (ld_base == NULL)                                   return NULL;\n-        if (st_base == NULL)                                   return NULL;\n-        if (!ld_base->eqv_uncast(st_base, \/*keep_deps=*\/true)) return NULL;\n-        if (ld_off != st_off)                                  return NULL;\n-        if (ld_off == Type::OffsetBot)                         return NULL;\n+        if (ld_base == nullptr)                                return nullptr;\n+        if (st_base == nullptr)                                return nullptr;\n+        if (!ld_base->eqv_uncast(st_base, \/*keep_deps=*\/true)) return nullptr;\n+        if (ld_off != st_off)                                  return nullptr;\n+        if (ld_off == Type::OffsetBot)                         return nullptr;\n@@ -1110,1 +1110,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1117,1 +1117,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1134,1 +1134,1 @@\n-        if (ReduceBulkZeroing || find_array_copy_clone(phase, ld_alloc, in(MemNode::Memory)) == NULL) {\n+        if (ReduceBulkZeroing || find_array_copy_clone(phase, ld_alloc, in(MemNode::Memory)) == nullptr) {\n@@ -1150,1 +1150,1 @@\n-      if ((alloc != NULL) && (alloc == ld_alloc)) {\n+      if ((alloc != nullptr) && (alloc == ld_alloc)) {\n@@ -1153,1 +1153,1 @@\n-        if (st != NULL) {\n+        if (st != nullptr) {\n@@ -1161,1 +1161,1 @@\n-        (tp != NULL) && tp->is_ptr_to_boxed_value()) {\n+        (tp != nullptr) && tp->is_ptr_to_boxed_value()) {\n@@ -1166,1 +1166,1 @@\n-      if (base != NULL && base->is_Proj() &&\n+      if (base != nullptr && base->is_Proj() &&\n@@ -1177,1 +1177,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1186,1 +1186,1 @@\n-    if( t_oop != NULL &&\n+    if( t_oop != nullptr &&\n@@ -1240,1 +1240,1 @@\n-      if (base == NULL) {\n+      if (base == nullptr) {\n@@ -1261,1 +1261,1 @@\n-  const Type* rt = NULL;\n+  const Type* rt = nullptr;\n@@ -1269,1 +1269,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1279,1 +1279,1 @@\n-  const Type* rt = NULL;\n+  const Type* rt = nullptr;\n@@ -1289,1 +1289,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1313,1 +1313,1 @@\n-  if (raw_type == NULL) {\n+  if (raw_type == nullptr) {\n@@ -1347,1 +1347,1 @@\n-  if (raw_type == NULL) {\n+  if (raw_type == nullptr) {\n@@ -1365,1 +1365,1 @@\n-  if ((base == NULL) || base->is_Phi()) {\n+  if ((base == nullptr) || base->is_Phi()) {\n@@ -1369,1 +1369,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1381,1 +1381,1 @@\n-      return NULL; \/\/ Complex address\n+      return nullptr; \/\/ Complex address\n@@ -1385,1 +1385,1 @@\n-    if ((cache_base != NULL) && cache_base->is_DecodeN()) {\n+    if ((cache_base != nullptr) && cache_base->is_DecodeN()) {\n@@ -1389,1 +1389,1 @@\n-    if ((cache_base != NULL) && cache_base->is_Con()) {\n+    if ((cache_base != nullptr) && cache_base->is_Con()) {\n@@ -1391,1 +1391,1 @@\n-      if ((base_type != NULL) && base_type->is_autobox_cache()) {\n+      if ((base_type != nullptr) && base_type->is_autobox_cache()) {\n@@ -1416,1 +1416,1 @@\n-              return NULL; \/\/ should not happen since cache is array indexed by value\n+              return nullptr; \/\/ should not happen since cache is array indexed by value\n@@ -1420,1 +1420,1 @@\n-              return NULL; \/\/ should not happen since cache is array indexed by value\n+              return nullptr; \/\/ should not happen since cache is array indexed by value\n@@ -1472,1 +1472,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1477,1 +1477,1 @@\n-  if (region == NULL) {\n+  if (region == nullptr) {\n@@ -1483,1 +1483,1 @@\n-    if (rc == NULL || phase->type(rc) == Type::TOP)\n+    if (rc == nullptr || phase->type(rc) == Type::TOP)\n@@ -1486,1 +1486,1 @@\n-    if (in == NULL || phase->type(in) == Type::TOP)\n+    if (in == nullptr || phase->type(in) == Type::TOP)\n@@ -1497,1 +1497,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1503,1 +1503,1 @@\n-  assert((t_oop != NULL) &&\n+  assert((t_oop != nullptr) &&\n@@ -1510,1 +1510,1 @@\n-  bool base_is_phi = (base != NULL) && base->is_Phi();\n+  bool base_is_phi = (base != nullptr) && base->is_Phi();\n@@ -1512,1 +1512,1 @@\n-                           (base != NULL) && (base == address->in(AddPNode::Base)) &&\n+                           (base != nullptr) && (base == address->in(AddPNode::Base)) &&\n@@ -1517,1 +1517,1 @@\n-    return NULL; \/\/ memory is not Phi\n+    return nullptr; \/\/ memory is not Phi\n@@ -1522,1 +1522,1 @@\n-      return NULL; \/\/ Wait stable graph\n+      return nullptr; \/\/ Wait stable graph\n@@ -1547,1 +1547,1 @@\n-      return NULL; \/\/ Wait stable graph\n+      return nullptr; \/\/ Wait stable graph\n@@ -1554,1 +1554,1 @@\n-          return NULL; \/\/ Wait stable graph\n+          return nullptr; \/\/ Wait stable graph\n@@ -1566,1 +1566,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1576,1 +1576,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1582,1 +1582,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1590,1 +1590,1 @@\n-      return NULL; \/\/ complex graph\n+      return nullptr; \/\/ complex graph\n@@ -1606,1 +1606,1 @@\n-  Node* phi = new PhiNode(region, this_type, NULL, mem->_idx, this_iid, this_index, this_offset);\n+  Node* phi = new PhiNode(region, this_type, nullptr, mem->_idx, this_iid, this_index, this_offset);\n@@ -1609,1 +1609,1 @@\n-    Node* the_clone = NULL;\n+    Node* the_clone = nullptr;\n@@ -1612,1 +1612,1 @@\n-        in != NULL && in->is_OuterStripMinedLoop()) {\n+        in != nullptr && in->is_OuterStripMinedLoop()) {\n@@ -1616,1 +1616,1 @@\n-    if (in == NULL || in == C->top()) {\n+    if (in == nullptr || in == C->top()) {\n@@ -1625,1 +1625,1 @@\n-        x->set_req(0, NULL);\n+        x->set_req(0, nullptr);\n@@ -1677,1 +1677,1 @@\n-    if (x != the_clone && the_clone != NULL) {\n+    if (x != the_clone && the_clone != nullptr) {\n@@ -1692,2 +1692,2 @@\n-    if (alloc != NULL && mem->is_Proj() &&\n-        mem->in(0) != NULL &&\n+    if (alloc != nullptr && mem->is_Proj() &&\n+        mem->in(0) != nullptr &&\n@@ -1695,1 +1695,1 @@\n-        alloc->initialization()->proj_out_or_null(0) != NULL) {\n+        alloc->initialization()->proj_out_or_null(0) != nullptr) {\n@@ -1699,1 +1699,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1710,1 +1710,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1713,1 +1713,1 @@\n-  if (p)  return (p == NodeSentinel) ? NULL : p;\n+  if (p)  return (p == NodeSentinel) ? nullptr : p;\n@@ -1724,1 +1724,1 @@\n-  if( ctrl != NULL && ctrl->Opcode() == Op_SafePoint &&\n+  if( ctrl != nullptr && ctrl->Opcode() == Op_SafePoint &&\n@@ -1735,1 +1735,1 @@\n-  if (base != NULL\n+  if (base != nullptr\n@@ -1738,1 +1738,1 @@\n-    if (in(MemNode::Control) != NULL\n+    if (in(MemNode::Control) != nullptr\n@@ -1743,1 +1743,1 @@\n-      set_req(MemNode::Control, NULL);\n+      set_req(MemNode::Control, nullptr);\n@@ -1751,1 +1751,1 @@\n-  if (can_reshape && (addr_t != NULL)) {\n+  if (can_reshape && (addr_t != nullptr)) {\n@@ -1756,1 +1756,1 @@\n-      if (phase->type( opt_mem ) == Type::TOP) return NULL;\n+      if (phase->type( opt_mem ) == Type::TOP) return nullptr;\n@@ -1760,1 +1760,1 @@\n-    if ((t_oop != NULL) &&\n+    if ((t_oop != nullptr) &&\n@@ -1764,1 +1764,1 @@\n-      assert(igvn != NULL, \"must be PhaseIterGVN when can_reshape is true\");\n+      assert(igvn != nullptr, \"must be PhaseIterGVN when can_reshape is true\");\n@@ -1768,1 +1768,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1772,1 +1772,1 @@\n-      if (result != NULL) return result;\n+      if (result != nullptr) return result;\n@@ -1776,1 +1776,1 @@\n-        if (result != NULL) return result;\n+        if (result != nullptr) return result;\n@@ -1784,1 +1784,1 @@\n-  if (in(0) != NULL && !adr_type()->isa_rawptr() && can_reshape) {\n+  if (in(0) != nullptr && !adr_type()->isa_rawptr() && can_reshape) {\n@@ -1789,1 +1789,1 @@\n-          use->in(0) != NULL &&\n+          use->in(0) != nullptr &&\n@@ -1793,1 +1793,1 @@\n-        for (int i = 0; i < 10 && ctl != NULL; i++) {\n+        for (int i = 0; i < 10 && ctl != nullptr; i++) {\n@@ -1817,1 +1817,1 @@\n-  if (prev_mem != NULL) {\n+  if (prev_mem != nullptr) {\n@@ -1819,1 +1819,1 @@\n-    if (value != NULL) {\n+    if (value != nullptr) {\n@@ -1824,1 +1824,1 @@\n-  if (prev_mem != NULL && prev_mem != in(MemNode::Memory)) {\n+  if (prev_mem != nullptr && prev_mem != in(MemNode::Memory)) {\n@@ -1842,1 +1842,1 @@\n-  return progress ? this : NULL;\n+  return progress ? this : nullptr;\n@@ -1876,1 +1876,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1887,1 +1887,1 @@\n-  if (tp == NULL || tp->empty())  return Type::TOP;\n+  if (tp == nullptr || tp->empty())  return Type::TOP;\n@@ -1910,1 +1910,1 @@\n-      if (aobj != NULL && off_beyond_header && adr->is_AddP() && off != Type::OffsetBot) {\n+      if (aobj != nullptr && off_beyond_header && adr->is_AddP() && off != Type::OffsetBot) {\n@@ -1915,1 +1915,1 @@\n-        if (con_type != NULL) {\n+        if (con_type != nullptr) {\n@@ -1936,2 +1936,2 @@\n-    if ((t->isa_int() == NULL) && (t->isa_long() == NULL)\n-        && (_type->isa_vect() == NULL)\n+    if ((t->isa_int() == nullptr) && (t->isa_long() == nullptr)\n+        && (_type->isa_vect() == nullptr)\n@@ -1952,1 +1952,1 @@\n-          if ((base != NULL) && base->is_DecodeN()) {\n+          if ((base != nullptr) && base->is_DecodeN()) {\n@@ -1956,1 +1956,1 @@\n-          if ((base != NULL) && base->is_Con()) {\n+          if ((base != nullptr) && base->is_Con()) {\n@@ -1958,1 +1958,1 @@\n-            if ((base_type != NULL) && base_type->is_autobox_cache()) {\n+            if ((base_type != nullptr) && base_type->is_autobox_cache()) {\n@@ -1980,1 +1980,1 @@\n-    if (!is_mismatched_access() && off != Type::OffsetBot && const_oop != NULL && const_oop->is_instance()) {\n+    if (!is_mismatched_access() && off != Type::OffsetBot && const_oop != nullptr && const_oop->is_instance()) {\n@@ -1982,1 +1982,1 @@\n-      if (con_type != NULL) {\n+      if (con_type != nullptr) {\n@@ -2004,1 +2004,1 @@\n-    if (tkls != NULL && !StressReflectiveCode) {\n+    if (tkls != nullptr && !StressReflectiveCode) {\n@@ -2015,1 +2015,1 @@\n-  if (tkls != NULL && !StressReflectiveCode) {\n+  if (tkls != nullptr && !StressReflectiveCode) {\n@@ -2045,1 +2045,1 @@\n-      if (aift != NULL)  return aift;\n+      if (aift != nullptr)  return aift;\n@@ -2094,2 +2094,2 @@\n-  bool is_instance = (tinst != NULL) && tinst->is_known_instance_field();\n-  bool is_boxed_value = (tinst != NULL) && tinst->is_ptr_to_boxed_value();\n+  bool is_instance = (tinst != nullptr) && tinst->is_known_instance_field();\n+  bool is_boxed_value = (tinst != nullptr) && tinst->is_ptr_to_boxed_value();\n@@ -2098,1 +2098,1 @@\n-    if (value != NULL && value->is_Con()) {\n+    if (value != nullptr && value->is_Con()) {\n@@ -2104,1 +2104,1 @@\n-  bool is_vect = (_type->isa_vect() != NULL);\n+  bool is_vect = (_type->isa_vect() != nullptr);\n@@ -2118,1 +2118,1 @@\n-  if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking) && !UseCompactObjectHeaders) {\n+  if (alloc != nullptr && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking) && !UseCompactObjectHeaders) {\n@@ -2141,1 +2141,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2154,1 +2154,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2175,1 +2175,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2188,1 +2188,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2209,1 +2209,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2222,1 +2222,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2243,1 +2243,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2256,1 +2256,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2273,1 +2273,1 @@\n-  assert(adr_type != NULL, \"expecting TypeKlassPtr\");\n+  assert(adr_type != nullptr, \"expecting TypeKlassPtr\");\n@@ -2309,1 +2309,1 @@\n-  if (tinst != NULL) {\n+  if (tinst != nullptr) {\n@@ -2319,1 +2319,1 @@\n-      if (t != NULL) {\n+      if (t != nullptr) {\n@@ -2330,1 +2330,1 @@\n-          \/\/ a primitive Class (e.g., int.class) has NULL for a klass field\n+          \/\/ a primitive Class (e.g., int.class) has null for a klass field\n@@ -2363,1 +2363,1 @@\n-  if( tary != NULL ) {\n+  if( tary != nullptr ) {\n@@ -2365,1 +2365,1 @@\n-    if (tary_klass != NULL   \/\/ can be NULL when at BOTTOM or TOP\n+    if (tary_klass != nullptr   \/\/ can be null when at BOTTOM or TOP\n@@ -2398,1 +2398,1 @@\n-  if (tkls != NULL && !StressReflectiveCode) {\n+  if (tkls != nullptr && !StressReflectiveCode) {\n@@ -2442,1 +2442,1 @@\n-  if (base == NULL)     return this;\n+  if (base == nullptr)     return this;\n@@ -2444,1 +2444,1 @@\n-  if (toop == NULL)     return this;\n+  if (toop == nullptr)     return this;\n@@ -2456,1 +2456,1 @@\n-    if (allocated_klass != NULL) {\n+    if (allocated_klass != nullptr) {\n@@ -2477,1 +2477,1 @@\n-        if (tkls != NULL && !tkls->empty()\n+        if (tkls != nullptr && !tkls->empty()\n@@ -2537,1 +2537,1 @@\n-  if (p)  return (p == NodeSentinel) ? NULL : p;\n+  if (p)  return (p == NodeSentinel) ? nullptr : p;\n@@ -2544,1 +2544,1 @@\n-  if (base == NULL)     return NULL;\n+  if (base == nullptr)     return nullptr;\n@@ -2546,1 +2546,1 @@\n-  if (tary == NULL)     return NULL;\n+  if (tary == nullptr)     return nullptr;\n@@ -2552,1 +2552,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -2562,1 +2562,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2576,1 +2576,1 @@\n-  if (base == NULL)     return this;\n+  if (base == nullptr)     return this;\n@@ -2578,1 +2578,1 @@\n-  if (tary == NULL)     return this;\n+  if (tary == nullptr)     return this;\n@@ -2584,1 +2584,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -2606,1 +2606,1 @@\n-         ctl != NULL, \"raw memory operations should have control edge\");\n+         ctl != nullptr, \"raw memory operations should have control edge\");\n@@ -2636,1 +2636,1 @@\n-    return (StoreNode*)NULL;\n+    return (StoreNode*)nullptr;\n@@ -2660,1 +2660,1 @@\n-  if (p)  return (p == NodeSentinel) ? NULL : p;\n+  if (p)  return (p == NodeSentinel) ? nullptr : p;\n@@ -2718,1 +2718,1 @@\n-      if (moved != NULL) {\n+      if (moved != nullptr) {\n@@ -2739,1 +2739,1 @@\n-  return NULL;                  \/\/ No further progress\n+  return nullptr;                  \/\/ No further progress\n@@ -2796,1 +2796,1 @@\n-      if (prev_mem != NULL) {\n+      if (prev_mem != nullptr) {\n@@ -2798,1 +2798,1 @@\n-        if (prev_val != NULL && prev_val == val) {\n+        if (prev_val != nullptr && prev_val == val) {\n@@ -2808,1 +2808,1 @@\n-  if (result != this && igvn != NULL) {\n+  if (result != this && igvn != nullptr) {\n@@ -2810,1 +2810,1 @@\n-    if (trailing != NULL) {\n+    if (trailing != nullptr) {\n@@ -2813,1 +2813,1 @@\n-      assert(t_oop == NULL || t_oop->is_known_instance_field(), \"only for non escaping objects\");\n+      assert(t_oop == nullptr || t_oop->is_known_instance_field(), \"only for non escaping objects\");\n@@ -2849,1 +2849,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2873,1 +2873,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2884,1 +2884,1 @@\n-  if (adr_oop == NULL)\n+  if (adr_oop == nullptr)\n@@ -2899,1 +2899,1 @@\n-    MemBarNode* trailing_mb = NULL;\n+    MemBarNode* trailing_mb = nullptr;\n@@ -2905,1 +2905,1 @@\n-          assert(trailing_mb == NULL, \"only one\");\n+          assert(trailing_mb == nullptr, \"only one\");\n@@ -2920,1 +2920,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2931,1 +2931,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2934,1 +2934,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2946,1 +2946,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2949,1 +2949,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2973,1 +2973,1 @@\n-  if (progress != NULL) return progress;\n+  if (progress != nullptr) return progress;\n@@ -2982,1 +2982,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3001,1 +3001,1 @@\n-  if (in(0) == NULL || phase->type(in(0)) == Type::TOP) {\n+  if (in(0) == nullptr || phase->type(in(0)) == Type::TOP) {\n@@ -3057,1 +3057,1 @@\n-  MemBarNode* trailing = NULL;\n+  MemBarNode* trailing = nullptr;\n@@ -3063,1 +3063,1 @@\n-        assert(trailing == NULL, \"only one\");\n+        assert(trailing == nullptr, \"only one\");\n@@ -3084,1 +3084,1 @@\n-LoadStoreConditionalNode::LoadStoreConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex ) : LoadStoreNode(c, mem, adr, val, NULL, TypeInt::BOOL, 5) {\n+LoadStoreConditionalNode::LoadStoreConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex ) : LoadStoreNode(c, mem, adr, val, nullptr, TypeInt::BOOL, 5) {\n@@ -3101,1 +3101,1 @@\n-  if (adr == NULL)  return NULL; \/\/ node is dead\n+  if (adr == nullptr)  return nullptr; \/\/ node is dead\n@@ -3121,1 +3121,1 @@\n-  if (_is_large) return NULL;\n+  if (_is_large) return nullptr;\n@@ -3125,2 +3125,2 @@\n-  if (!t)  return NULL;\n-  if (!t->is_con())  return NULL;\n+  if (!t)  return nullptr;\n+  if (!t->is_con())  return nullptr;\n@@ -3133,1 +3133,1 @@\n-  if (size <= 0 || size % unit != 0)  return NULL;\n+  if (size <= 0 || size % unit != 0)  return nullptr;\n@@ -3140,1 +3140,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3142,1 +3142,1 @@\n-  if (!IdealizeClearArrayNode) return NULL;\n+  if (!IdealizeClearArrayNode) return nullptr;\n@@ -3144,1 +3144,1 @@\n-  if( phase->type(mem)==Type::TOP ) return NULL;\n+  if( phase->type(mem)==Type::TOP ) return nullptr;\n@@ -3147,1 +3147,1 @@\n-  if( at==Type::TOP ) return NULL;\n+  if( at==Type::TOP ) return nullptr;\n@@ -3150,1 +3150,1 @@\n-  if (atp == NULL)  atp = TypePtr::BOTTOM;\n+  if (atp == nullptr)  atp = TypePtr::BOTTOM;\n@@ -3180,1 +3180,1 @@\n-  assert(alloc != NULL, \"should have allocation\");\n+  assert(alloc != nullptr, \"should have allocation\");\n@@ -3187,1 +3187,1 @@\n-  if (init != NULL)\n+  if (init != nullptr)\n@@ -3276,1 +3276,1 @@\n-  : MultiNode(TypeFunc::Parms + (precedent == NULL? 0: 1)),\n+  : MultiNode(TypeFunc::Parms + (precedent == nullptr? 0: 1)),\n@@ -3287,1 +3287,1 @@\n-  if (precedent != NULL)\n+  if (precedent != nullptr)\n@@ -3312,1 +3312,1 @@\n-  default: ShouldNotReachHere(); return NULL;\n+  default: ShouldNotReachHere(); return nullptr;\n@@ -3323,1 +3323,1 @@\n-    if (leading != NULL) {\n+    if (leading != nullptr) {\n@@ -3328,1 +3328,1 @@\n-  if (proj_out_or_null(TypeFunc::Memory) != NULL) {\n+  if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n@@ -3331,1 +3331,1 @@\n-  if (proj_out_or_null(TypeFunc::Control) != NULL) {\n+  if (proj_out_or_null(TypeFunc::Control) != nullptr) {\n@@ -3343,1 +3343,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3355,1 +3355,1 @@\n-      if ((my_mem != NULL) && (opc == Op_MemBarAcquire) && (my_mem->outcnt() == 1)) {\n+      if ((my_mem != nullptr) && (opc == Op_MemBarAcquire) && (my_mem->outcnt() == 1)) {\n@@ -3367,1 +3367,1 @@\n-          my_mem = NULL;\n+          my_mem = nullptr;\n@@ -3371,1 +3371,1 @@\n-      if (my_mem != NULL && my_mem->is_Mem()) {\n+      if (my_mem != nullptr && my_mem->is_Mem()) {\n@@ -3374,1 +3374,1 @@\n-        if( t_oop != NULL && t_oop->is_known_instance_field() &&\n+        if( t_oop != nullptr && t_oop->is_known_instance_field() &&\n@@ -3383,1 +3383,1 @@\n-      if ((alloc != NULL) && alloc->is_Allocate() &&\n+      if ((alloc != nullptr) && alloc->is_Allocate() &&\n@@ -3398,1 +3398,1 @@\n-  return progress ? this : NULL;\n+  return progress ? this : nullptr;\n@@ -3418,1 +3418,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3448,1 +3448,1 @@\n-      trailing = NULL;\n+      trailing = nullptr;\n@@ -3463,1 +3463,1 @@\n-      if (trailing != NULL && !seen.test_set(trailing->_idx)) {\n+      if (trailing != nullptr && !seen.test_set(trailing->_idx)) {\n@@ -3489,4 +3489,4 @@\n-  while (leading != NULL && (!leading->is_MemBar() || !leading->as_MemBar()->leading())) {\n-    while (leading == NULL || leading->is_top() || seen.test_set(leading->_idx)) {\n-      leading = NULL;\n-      while (regions.size() > 0 && leading == NULL) {\n+  while (leading != nullptr && (!leading->is_MemBar() || !leading->as_MemBar()->leading())) {\n+    while (leading == nullptr || leading->is_top() || seen.test_set(leading->_idx)) {\n+      leading = nullptr;\n+      while (regions.size() > 0 && leading == nullptr) {\n@@ -3502,1 +3502,1 @@\n-      if (leading == NULL) {\n+      if (leading == nullptr) {\n@@ -3504,1 +3504,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -3523,1 +3523,1 @@\n-        if (in != NULL && !in->is_top()) {\n+        if (in != nullptr && !in->is_top()) {\n@@ -3533,1 +3533,1 @@\n-        if (in != NULL && !in->is_top()) {\n+        if (in != nullptr && !in->is_top()) {\n@@ -3539,1 +3539,1 @@\n-  assert(found == 1 || (found == 0 && leading == NULL), \"consistency check failed\");\n+  assert(found == 1 || (found == 0 && leading == nullptr), \"consistency check failed\");\n@@ -3541,2 +3541,2 @@\n-  if (leading == NULL) {\n-    return NULL;\n+  if (leading == nullptr) {\n+    return nullptr;\n@@ -3652,1 +3652,1 @@\n-  \/\/ Note:  allocation() can be NULL, for secondary initialization barriers\n+  \/\/ Note:  allocation() can be null, for secondary initialization barriers\n@@ -3698,1 +3698,1 @@\n-  if (init == NULL || init->is_complete())  return false;\n+  if (init == nullptr || init->is_complete())  return false;\n@@ -3728,1 +3728,1 @@\n-  if (base == NULL)     return -1;  \/\/ something is dead,\n+  if (base == nullptr)  return -1;  \/\/ something is dead,\n@@ -3751,1 +3751,1 @@\n-    if (n == NULL)      continue;   \/\/ (can this really happen?)\n+    if (n == nullptr)   continue;   \/\/ (can this really happen?)\n@@ -3764,1 +3764,1 @@\n-    if (ctl != NULL && !ctl->is_top()) {\n+    if (ctl != nullptr && !ctl->is_top()) {\n@@ -3780,1 +3780,1 @@\n-      if (m == NULL || m == n || m->is_top())  continue;\n+      if (m == nullptr || m == n || m->is_top())  continue;\n@@ -3799,1 +3799,1 @@\n-  if (!(ctl != NULL && ctl->is_Proj() && ctl->in(0) == this))\n+  if (!(ctl != nullptr && ctl->is_Proj() && ctl->in(0) == this))\n@@ -3807,1 +3807,1 @@\n-  if (alloc == NULL)\n+  if (alloc == nullptr)\n@@ -3835,1 +3835,1 @@\n-    Node* unique_merge = NULL;\n+    Node* unique_merge = nullptr;\n@@ -3845,1 +3845,1 @@\n-        } else if (n->in(0) != NULL && n->in(0) != ctl) {\n+        } else if (n->in(0) != nullptr && n->in(0) != ctl) {\n@@ -3867,1 +3867,1 @@\n-            if (other_t_adr != NULL) {\n+            if (other_t_adr != nullptr) {\n@@ -3878,1 +3878,1 @@\n-                if (base != NULL) {\n+                if (base != nullptr) {\n@@ -3923,1 +3923,1 @@\n-  assert(allocation() != NULL, \"must be present\");\n+  assert(allocation() != nullptr, \"must be present\");\n@@ -3975,1 +3975,1 @@\n-    return NULL;                \/\/ something is dead\n+    return nullptr;              \/\/ something is dead\n@@ -4019,1 +4019,1 @@\n-  if (start < 0)  return NULL;\n+  if (start < 0)  return nullptr;\n@@ -4025,2 +4025,2 @@\n-  if (i == 0)  return NULL;     \/\/ bail out\n-  Node* prev_mem = NULL;        \/\/ raw memory for the captured store\n+  if (i == 0)  return nullptr;  \/\/ bail out\n+  Node* prev_mem = nullptr;     \/\/ raw memory for the captured store\n@@ -4058,1 +4058,1 @@\n-  assert(check_st == new_st || check_st == NULL, \"must be findable\");\n+  assert(check_st == new_st || check_st == nullptr, \"must be findable\");\n@@ -4186,1 +4186,1 @@\n-        if (con != 0 && st != NULL && st->Opcode() == Op_StoreI) {\n+        if (con != 0 && st != nullptr && st->Opcode() == Op_StoreI) {\n@@ -4195,1 +4195,1 @@\n-          nodes[j] = NULL;      \/\/ undo nodes[j] = st\n+          nodes[j] = nullptr;   \/\/ undo nodes[j] = st\n@@ -4232,1 +4232,1 @@\n-    assert(old != NULL, \"need the prior store\");\n+    assert(old != nullptr, \"need the prior store\");\n@@ -4309,1 +4309,1 @@\n-  if (C->log() != NULL)\n+  if (C->log() != nullptr)\n@@ -4380,1 +4380,1 @@\n-  assert(allocation() != NULL, \"must be present\");\n+  assert(allocation() != nullptr, \"must be present\");\n@@ -4483,1 +4483,1 @@\n-    const Type* val = NULL;\n+    const Type* val = nullptr;\n@@ -4509,2 +4509,2 @@\n-      assert(alloc != NULL, \"must be present\");\n-      if (alloc != NULL && alloc->Opcode() == Op_Allocate) {\n+      assert(alloc != nullptr, \"must be present\");\n+      if (alloc != nullptr && alloc->Opcode() == Op_Allocate) {\n@@ -4532,1 +4532,1 @@\n-  assert(allocation() != NULL, \"must be present\");\n+  assert(allocation() != nullptr, \"must be present\");\n@@ -4608,1 +4608,1 @@\n-\/\/ MergeMem nodes never (?) have control inputs, so in(0) is NULL.\n+\/\/ MergeMem nodes never (?) have control inputs, so in(0) is null.\n@@ -4661,1 +4661,1 @@\n-  \/\/ set_input(0, NULL);  \/\/ no control input\n+  \/\/ set_input(0, nullptr);  \/\/ no control input\n@@ -4670,1 +4670,1 @@\n-  if( new_base != NULL && new_base->is_MergeMem() ) {\n+  if( new_base != nullptr && new_base->is_MergeMem() ) {\n@@ -4720,1 +4720,1 @@\n-  Node *progress = NULL;\n+  Node *progress = nullptr;\n@@ -4726,1 +4726,1 @@\n-    return NULL; \/\/ Dead memory path.\n+    return nullptr; \/\/ Dead memory path.\n@@ -4729,1 +4729,1 @@\n-  if (old_base != NULL && old_base->is_MergeMem())\n+  if (old_base != nullptr && old_base->is_MergeMem())\n@@ -4732,1 +4732,1 @@\n-    old_mbase = NULL;\n+    old_mbase = nullptr;\n@@ -4783,1 +4783,1 @@\n-    if (old_mem != NULL && old_mem->is_MergeMem())\n+    if (old_mem != nullptr && old_mem->is_MergeMem())\n@@ -4786,1 +4786,1 @@\n-      old_mmem = NULL;\n+      old_mmem = nullptr;\n@@ -4801,1 +4801,1 @@\n-    else if (old_mmem != NULL) {\n+    else if (old_mmem != nullptr) {\n@@ -4836,1 +4836,1 @@\n-    if( m != NULL &&\n+    if( m != nullptr &&\n@@ -4898,1 +4898,1 @@\n-    Node* mem = (in(i) != NULL) ? memory_at(i) : base_mem;\n+    Node* mem = (in(i) != nullptr) ? memory_at(i) : base_mem;\n@@ -4922,1 +4922,1 @@\n-  assert(n != NULL, \"\");\n+  assert(n != nullptr, \"\");\n@@ -4932,1 +4932,1 @@\n-    assert(n_adr_type != NULL, \"new memory must have a well-defined adr_type\");\n+    assert(n_adr_type != nullptr, \"new memory must have a well-defined adr_type\");\n@@ -4969,2 +4969,2 @@\n-           || n == NULL || n->bottom_type() == Type::TOP\n-           || n->adr_type() == NULL \/\/ address is TOP\n+           || n == nullptr || n->bottom_type() == Type::TOP\n+           || n->adr_type() == nullptr \/\/ address is TOP\n@@ -5012,1 +5012,1 @@\n-  if (other != NULL) {\n+  if (other != nullptr) {\n@@ -5023,1 +5023,1 @@\n-  if (base_mem != NULL && !base_mem->is_top()) {\n+  if (base_mem != nullptr && !base_mem->is_top()) {\n@@ -5053,1 +5053,1 @@\n-    assert(in(i) != NULL, \"sane slice\");\n+    assert(in(i) != nullptr, \"sane slice\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":323,"deletions":323,"binary":false,"changes":646,"status":"modified"},{"patch":"@@ -235,3 +235,3 @@\n-    _oop_map_set(NULL),\n-    _scratch_buffer_blob(NULL),\n-    _scratch_locs_memory(NULL),\n+    _oop_map_set(nullptr),\n+    _scratch_buffer_blob(nullptr),\n+    _scratch_locs_memory(nullptr),\n@@ -243,1 +243,1 @@\n-    _node_bundling_base(NULL),\n+    _node_bundling_base(nullptr),\n@@ -247,1 +247,1 @@\n-    _block(NULL),\n+    _block(nullptr),\n@@ -250,1 +250,1 @@\n-  if (C->stub_name() == NULL) {\n+  if (C->stub_name() == nullptr) {\n@@ -256,2 +256,2 @@\n-  C->set_output(NULL);\n-  if (_scratch_buffer_blob != NULL) {\n+  C->set_output(nullptr);\n+  if (_scratch_buffer_blob != nullptr) {\n@@ -356,1 +356,1 @@\n-  if (cb == NULL || C->failing()) {\n+  if (cb == nullptr || C->failing()) {\n@@ -377,1 +377,1 @@\n-  return (C->stub_function() == NULL &&\n+  return (C->stub_function() == nullptr &&\n@@ -387,1 +387,1 @@\n-  return (C->stub_function() == NULL && C->has_java_calls());\n+  return (C->stub_function() == nullptr && C->has_java_calls());\n@@ -593,2 +593,2 @@\n-      MachNode* mach = (idx == -1) ? NULL: block->get_node(idx)->as_Mach();\n-      if (mach != NULL && mach->may_be_short_branch()) {\n+      MachNode* mach = (idx == -1) ? nullptr: block->get_node(idx)->as_Mach();\n+      if (mach != nullptr && mach->may_be_short_branch()) {\n@@ -658,1 +658,1 @@\n-      if (mach != NULL && (mach->may_be_short_branch() ||\n+      if (mach != nullptr && (mach->may_be_short_branch() ||\n@@ -724,1 +724,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -729,1 +729,1 @@\n-  assert(sv_for_node_id(objs, sv->id()) == NULL, \"Precondition\");\n+  assert(sv_for_node_id(objs, sv->id()) == nullptr, \"Precondition\");\n@@ -758,1 +758,1 @@\n-    if (sv == NULL) {\n+    if (sv == nullptr) {\n@@ -846,1 +846,1 @@\n-      array->append(new ConstantOopWriteValue(NULL));\n+      array->append(new ConstantOopWriteValue(nullptr));\n@@ -854,1 +854,1 @@\n-        array->append(new ConstantOopWriteValue(NULL));\n+        array->append(new ConstantOopWriteValue(nullptr));\n@@ -947,1 +947,1 @@\n-    mcall = NULL;\n+    mcall = nullptr;\n@@ -972,1 +972,1 @@\n-  \/\/ Do not skip safepoints with a NULL method, they need monitor info\n+  \/\/ Do not skip safepoints with a null method, they need monitor info\n@@ -985,1 +985,1 @@\n-    ciMethod* method = jvms->has_method() ? jvms->method() : NULL;\n+    ciMethod* method = jvms->has_method() ? jvms->method() : nullptr;\n@@ -988,2 +988,2 @@\n-    int num_locs = (method == NULL) ? 0 : jvms->loc_size();\n-    int num_exps = (method == NULL) ? 0 : jvms->stk_size();\n+    int num_locs = (method == nullptr) ? 0 : jvms->loc_size();\n+    int num_exps = (method == nullptr) ? 0 : jvms->stk_size();\n@@ -991,1 +991,1 @@\n-    assert(method == NULL || jvms->bci() < 0 || num_locs == method->max_locals(),\n+    assert(method == nullptr || jvms->bci() < 0 || num_locs == method->max_locals(),\n@@ -1026,1 +1026,1 @@\n-      ScopeValue *scval = NULL;\n+      ScopeValue *scval = nullptr;\n@@ -1031,1 +1031,1 @@\n-        if (scval == NULL) {\n+        if (scval == nullptr) {\n@@ -1117,1 +1117,1 @@\n-      _pending_jvms = NULL;\n+      _pending_jvms = nullptr;\n@@ -1125,2 +1125,2 @@\n-      if (nn == NULL || nn->jvms() == NULL)  return;\n-      if (_pending_jvms != NULL &&\n+      if (nn == nullptr || nn->jvms() == nullptr)  return;\n+      if (_pending_jvms != nullptr &&\n@@ -1131,1 +1131,1 @@\n-        if (_pending_jvms != NULL &&\n+        if (_pending_jvms != nullptr &&\n@@ -1135,1 +1135,1 @@\n-        _pending_jvms = NULL;\n+        _pending_jvms = nullptr;\n@@ -1137,1 +1137,1 @@\n-          \/\/ This is the only way _pending_jvms can become non-NULL:\n+          \/\/ This is the only way _pending_jvms can become non-null:\n@@ -1146,1 +1146,1 @@\n-      if (_pending_jvms != NULL &&\n+      if (_pending_jvms != nullptr &&\n@@ -1151,1 +1151,1 @@\n-      _pending_jvms = NULL;\n+      _pending_jvms = nullptr;\n@@ -1155,1 +1155,1 @@\n-      if (_pending_jvms != NULL) {\n+      if (_pending_jvms != nullptr) {\n@@ -1158,1 +1158,1 @@\n-      _pending_jvms = NULL;\n+      _pending_jvms = nullptr;\n@@ -1167,1 +1167,1 @@\n-  _pending_jvms = NULL;\n+  _pending_jvms = nullptr;\n@@ -1178,1 +1178,1 @@\n-    ciMethod* method = jvms->has_method() ? jvms->method() : NULL;\n+    ciMethod* method = jvms->has_method() ? jvms->method() : nullptr;\n@@ -1276,1 +1276,1 @@\n-  if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+  if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1278,1 +1278,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1333,1 +1333,1 @@\n-  int* node_offsets      = NULL;\n+  int* node_offsets      = nullptr;\n@@ -1339,1 +1339,1 @@\n-  if (node_offsets != NULL) {\n+  if (node_offsets != nullptr) {\n@@ -1362,1 +1362,1 @@\n-  Node* delay_slot = NULL;\n+  Node* delay_slot = nullptr;\n@@ -1403,1 +1403,1 @@\n-        assert(delay_slot == NULL, \"no use of delay slot node\");\n+        assert(delay_slot == nullptr, \"no use of delay slot node\");\n@@ -1453,1 +1453,1 @@\n-          if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+          if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1482,1 +1482,1 @@\n-            if (sfn->jvms()->method() == NULL) {\n+            if (sfn->jvms()->method() == nullptr) {\n@@ -1509,1 +1509,1 @@\n-            assert(delay_slot == NULL, \"not expecting delay slot node\");\n+            assert(delay_slot == nullptr, \"not expecting delay slot node\");\n@@ -1574,1 +1574,1 @@\n-            if (oop_store == NULL) continue;\n+            if (oop_store == nullptr) continue;\n@@ -1605,1 +1605,1 @@\n-      if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+      if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1612,1 +1612,1 @@\n-      if ((node_offsets != NULL) && (n->_idx < node_offset_limit)) {\n+      if ((node_offsets != nullptr) && (n->_idx < node_offset_limit)) {\n@@ -1668,1 +1668,1 @@\n-        guarantee(delay_slot != NULL, \"expecting delay slot node\");\n+        guarantee(delay_slot != nullptr, \"expecting delay slot node\");\n@@ -1675,1 +1675,1 @@\n-        if ((node_offsets != NULL) && (delay_slot->_idx < node_offset_limit)) {\n+        if ((node_offsets != nullptr) && (delay_slot->_idx < node_offset_limit)) {\n@@ -1684,1 +1684,1 @@\n-          if (!mach->is_MachCall() && mach->as_MachSafePoint()->jvms()->method() == NULL) {\n+          if (!mach->is_MachCall() && mach->as_MachSafePoint()->jvms()->method() == nullptr) {\n@@ -1686,1 +1686,1 @@\n-            delay_slot = NULL;\n+            delay_slot = nullptr;\n@@ -1701,1 +1701,1 @@\n-        delay_slot = NULL;\n+        delay_slot = nullptr;\n@@ -1789,1 +1789,1 @@\n-  if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+  if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1809,1 +1809,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -1813,1 +1813,1 @@\n-      if (C->method() != NULL) {\n+      if (C->method() != nullptr) {\n@@ -1816,1 +1816,1 @@\n-      } else if (C->stub_name() != NULL) {\n+      } else if (C->stub_name() != nullptr) {\n@@ -1823,1 +1823,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -1841,1 +1841,1 @@\n-    Node *n = NULL;\n+    Node *n = nullptr;\n@@ -1902,1 +1902,1 @@\n-      _handler_table.add_subtable(call_return, &handler_bcis, NULL, &handler_pcos);\n+      _handler_table.add_subtable(call_return, &handler_bcis, nullptr, &handler_pcos);\n@@ -1940,1 +1940,1 @@\n-          _next_node(NULL),\n+          _next_node(nullptr),\n@@ -2191,1 +2191,1 @@\n-      tty->print(\"#   ChooseNodeToBundle: NULL\\n\");\n+      tty->print(\"#   ChooseNodeToBundle: null\\n\");\n@@ -2193,1 +2193,1 @@\n-    return (NULL);\n+    return (nullptr);\n@@ -2542,1 +2542,1 @@\n-  _unconditional_delay_slot = NULL;\n+  _unconditional_delay_slot = nullptr;\n@@ -2604,1 +2604,1 @@\n-  Block *succ_bb = NULL;\n+  Block *succ_bb = nullptr;\n@@ -2706,1 +2706,1 @@\n-      guarantee(n != NULL, \"no nodes available\");\n+      guarantee(n != nullptr, \"no nodes available\");\n@@ -2781,1 +2781,1 @@\n-    _reg_node.map(def,NULL); \/\/ Kill live USEs\n+    _reg_node.map(def,nullptr); \/\/ Kill live USEs\n@@ -2858,1 +2858,1 @@\n-  if ((pinch == NULL) || _cfg->get_block_for_node(pinch) != b || \/\/ No pinch-point yet?\n+  if ((pinch == nullptr) || _cfg->get_block_for_node(pinch) != b || \/\/ No pinch-point yet?\n@@ -2868,1 +2868,1 @@\n-  Node *later_def = NULL;\n+  Node *later_def = nullptr;\n@@ -2890,1 +2890,1 @@\n-      pinch->init_req(0, C->top());     \/\/ set not NULL for the next call\n+      pinch->init_req(0, C->top());     \/\/ set not null for the next call\n@@ -2892,1 +2892,1 @@\n-      later_def = NULL;           \/\/ and no later def\n+      later_def = nullptr;           \/\/ and no later def\n@@ -2911,1 +2911,1 @@\n-        pinch->set_req(0,NULL);  \/\/\n+        pinch->set_req(0,nullptr);  \/\/\n@@ -2929,1 +2929,1 @@\n-  if ((pinch != NULL) && _cfg->get_block_for_node(pinch) == b &&\n+  if ((pinch != nullptr) && _cfg->get_block_for_node(pinch) == b &&\n@@ -2981,1 +2981,1 @@\n-  \/\/ compilation.  _reg_node is lazily initialized; it either contains a NULL,\n+  \/\/ compilation.  _reg_node is lazily initialized; it either contains a null,\n@@ -2983,1 +2983,1 @@\n-  \/\/ block.  Leftover node from some prior block is treated like a NULL (no\n+  \/\/ block.  Leftover node from some prior block is treated like a null (no\n@@ -2988,1 +2988,1 @@\n-  Node* end_node         = (_bb_end-1 >= _bb_start) ? b->get_node(last_safept) : NULL;\n+  Node* end_node         = (_bb_end-1 >= _bb_start) ? b->get_node(last_safept) : nullptr;\n@@ -3106,1 +3106,1 @@\n-    if ((pinch != NULL) && pinch->Opcode() == Op_Node &&\n+    if ((pinch != nullptr) && pinch->Opcode() == Op_Node &&\n@@ -3108,1 +3108,1 @@\n-        (pinch->req() == pinch->len() || pinch->in(pinch->req()) == NULL) ) {\n+        (pinch->req() == pinch->len() || pinch->in(pinch->req()) == nullptr) ) {\n@@ -3111,1 +3111,1 @@\n-      _reg_node.map(k, NULL);\n+      _reg_node.map(k, nullptr);\n@@ -3146,1 +3146,1 @@\n-  pinch->set_req(0, NULL);\n+  pinch->set_req(0, nullptr);\n@@ -3199,1 +3199,1 @@\n-  if ((blob != NULL) && (const_size <= _scratch_const_size)) {\n+  if ((blob != nullptr) && (const_size <= _scratch_const_size)) {\n@@ -3202,1 +3202,1 @@\n-    if (blob != NULL) {\n+    if (blob != nullptr) {\n@@ -3213,1 +3213,1 @@\n-    if (scratch_buffer_blob() == NULL) {\n+    if (scratch_buffer_blob() == nullptr) {\n@@ -3243,1 +3243,1 @@\n-  assert(blob != NULL, \"Initialize BufferBlob at start\");\n+  assert(blob != nullptr, \"Initialize BufferBlob at start\");\n@@ -3252,1 +3252,1 @@\n-  assert(locs_buf != NULL, \"sanity\");\n+  assert(locs_buf != nullptr, \"sanity\");\n@@ -3265,1 +3265,1 @@\n-  Label*   saveL = NULL;\n+  Label*   saveL = nullptr;\n@@ -3291,1 +3291,1 @@\n-  } else if (C->stub_function() != NULL) {\n+  } else if (C->stub_function() != nullptr) {\n@@ -3342,1 +3342,1 @@\n-    if (C->log() != NULL) { \/\/ Print code cache state into compiler log\n+    if (C->log() != nullptr) { \/\/ Print code cache state into compiler log\n@@ -3349,1 +3349,1 @@\n-  if (code_buffer() == NULL) {\n+  if (code_buffer() == nullptr) {\n@@ -3367,1 +3367,1 @@\n-      assert(rs != NULL && rs->is_runtime_stub(), \"sanity check\");\n+      assert(rs != nullptr && rs->is_runtime_stub(), \"sanity check\");\n@@ -3410,1 +3410,1 @@\n-  if (pcs != NULL) {\n+  if (pcs != nullptr) {\n@@ -3429,1 +3429,1 @@\n-  Node *n = NULL;\n+  Node *n = nullptr;\n@@ -3440,1 +3440,1 @@\n-    if ((pcs != NULL) && (n->_idx < pc_limit)) {\n+    if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n@@ -3455,1 +3455,1 @@\n-    Node *delay = NULL;\n+    Node *delay = nullptr;\n@@ -3487,1 +3487,1 @@\n-        if ((pcs != NULL) && (n->_idx < pc_limit)) {\n+        if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n@@ -3504,1 +3504,1 @@\n-        guarantee(delay != NULL, \"no unconditional delay instruction\");\n+        guarantee(delay != nullptr, \"no unconditional delay instruction\");\n@@ -3509,1 +3509,1 @@\n-        if ((pcs != NULL) && (n->_idx < pc_limit)) {\n+        if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n@@ -3520,1 +3520,1 @@\n-        delay = NULL;\n+        delay = nullptr;\n@@ -3531,1 +3531,1 @@\n-    assert(cut_short || delay == NULL, \"no unconditional delay branch\");\n+    assert(cut_short || delay == nullptr, \"no unconditional delay branch\");\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":102,"deletions":102,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-  \/\/ If \"objs\" contains an ObjectValue whose id is \"id\", returns it, else NULL.\n+  \/\/ If \"objs\" contains an ObjectValue whose id is \"id\", returns it, else null.\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,16 +95,16 @@\n-address OptoRuntime::_new_instance_Java                           = NULL;\n-address OptoRuntime::_new_array_Java                              = NULL;\n-address OptoRuntime::_new_array_nozero_Java                       = NULL;\n-address OptoRuntime::_multianewarray2_Java                        = NULL;\n-address OptoRuntime::_multianewarray3_Java                        = NULL;\n-address OptoRuntime::_multianewarray4_Java                        = NULL;\n-address OptoRuntime::_multianewarray5_Java                        = NULL;\n-address OptoRuntime::_multianewarrayN_Java                        = NULL;\n-address OptoRuntime::_vtable_must_compile_Java                    = NULL;\n-address OptoRuntime::_complete_monitor_locking_Java               = NULL;\n-address OptoRuntime::_monitor_notify_Java                         = NULL;\n-address OptoRuntime::_monitor_notifyAll_Java                      = NULL;\n-address OptoRuntime::_rethrow_Java                                = NULL;\n-\n-address OptoRuntime::_slow_arraycopy_Java                         = NULL;\n-address OptoRuntime::_register_finalizer_Java                     = NULL;\n+address OptoRuntime::_new_instance_Java                           = nullptr;\n+address OptoRuntime::_new_array_Java                              = nullptr;\n+address OptoRuntime::_new_array_nozero_Java                       = nullptr;\n+address OptoRuntime::_multianewarray2_Java                        = nullptr;\n+address OptoRuntime::_multianewarray3_Java                        = nullptr;\n+address OptoRuntime::_multianewarray4_Java                        = nullptr;\n+address OptoRuntime::_multianewarray5_Java                        = nullptr;\n+address OptoRuntime::_multianewarrayN_Java                        = nullptr;\n+address OptoRuntime::_vtable_must_compile_Java                    = nullptr;\n+address OptoRuntime::_complete_monitor_locking_Java               = nullptr;\n+address OptoRuntime::_monitor_notify_Java                         = nullptr;\n+address OptoRuntime::_monitor_notifyAll_Java                      = nullptr;\n+address OptoRuntime::_rethrow_Java                                = nullptr;\n+\n+address OptoRuntime::_slow_arraycopy_Java                         = nullptr;\n+address OptoRuntime::_register_finalizer_Java                     = nullptr;\n@@ -129,1 +129,1 @@\n-  if (var == NULL) { return false; }\n+  if (var == nullptr) { return false; }\n@@ -180,1 +180,1 @@\n-  assert(rs != NULL && rs->is_runtime_stub(), \"not a runtime stub\");\n+  assert(rs != nullptr && rs->is_runtime_stub(), \"not a runtime stub\");\n@@ -302,1 +302,1 @@\n-  if ((len > 0) && (result != NULL) &&\n+  if ((len > 0) && (result != nullptr) &&\n@@ -611,1 +611,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -616,1 +616,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -760,1 +760,1 @@\n-    fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+    fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -802,1 +802,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -823,1 +823,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -978,1 +978,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1024,1 +1024,1 @@\n-  fields[TypeFunc::Parms+0] = NULL;\n+  fields[TypeFunc::Parms+0] = nullptr;\n@@ -1044,1 +1044,1 @@\n-  fields[TypeFunc::Parms+0] = NULL;\n+  fields[TypeFunc::Parms+0] = nullptr;\n@@ -1132,1 +1132,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL;\n+  fields[TypeFunc::Parms + 0] = nullptr;\n@@ -1172,1 +1172,1 @@\n-    fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+    fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1193,1 +1193,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n@@ -1230,1 +1230,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1264,2 +1264,2 @@\n-  assert(current->exception_oop() != NULL, \"exception oop is found\");\n-  address handler_address = NULL;\n+  assert(current->exception_oop() != nullptr, \"exception oop is found\");\n+  address handler_address = nullptr;\n@@ -1298,1 +1298,1 @@\n-  assert(nm != NULL, \"No NMethod found\");\n+  assert(nm != nullptr, \"No NMethod found\");\n@@ -1336,1 +1336,1 @@\n-        force_unwind ? NULL : nm->handler_for_exception_and_pc(exception, pc);\n+        force_unwind ? nullptr : nm->handler_for_exception_and_pc(exception, pc);\n@@ -1338,1 +1338,1 @@\n-      if (handler_address == NULL) {\n+      if (handler_address == nullptr) {\n@@ -1341,1 +1341,1 @@\n-        assert (handler_address != NULL, \"must have compiled handler\");\n+        assert (handler_address != nullptr, \"must have compiled handler\");\n@@ -1387,2 +1387,2 @@\n-  nmethod* nm = NULL;\n-  address handler_address = NULL;\n+  nmethod* nm = nullptr;\n+  address handler_address = nullptr;\n@@ -1401,1 +1401,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -1437,4 +1437,0 @@\n-\n-  \/\/ Enable WXWrite: the function called directly by compiled code.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n-\n@@ -1449,1 +1445,1 @@\n-  assert (exception != NULL, \"should have thrown a NULLPointerException\");\n+  assert (exception != nullptr, \"should have thrown a NullPointerException\");\n@@ -1582,1 +1578,1 @@\n-NamedCounter * volatile OptoRuntime::_named_counters = NULL;\n+NamedCounter * volatile OptoRuntime::_named_counters = nullptr;\n@@ -1644,1 +1640,1 @@\n-    ciMethod* m = jvms->has_method() ? jvms->method() : NULL;\n+    ciMethod* m = jvms->has_method() ? jvms->method() : nullptr;\n@@ -1652,1 +1648,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -1673,1 +1669,1 @@\n-    c->set_next(NULL);\n+    c->set_next(nullptr);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":46,"deletions":50,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-Dict* Type::_shared_type_dict = NULL;\n+Dict* Type::_shared_type_dict = nullptr;\n@@ -136,2 +136,2 @@\n-  if (type == NULL) {\n-    return NULL;\n+  if (type == nullptr) {\n+    return nullptr;\n@@ -161,1 +161,1 @@\n-\/\/ Otherwise or if the arrays have different dimensions, return NULL.\n+\/\/ Otherwise or if the arrays have different dimensions, return null.\n@@ -165,4 +165,4 @@\n-  if (e1) *e1 = NULL;\n-  if (e2) *e2 = NULL;\n-  const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1->isa_aryptr();\n-  const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2->isa_aryptr();\n+  if (e1) *e1 = nullptr;\n+  if (e2) *e2 = nullptr;\n+  const TypeAryPtr* a1tap = (a1 == nullptr) ? nullptr : a1->isa_aryptr();\n+  const TypeAryPtr* a2tap = (a2 == nullptr) ? nullptr : a2->isa_aryptr();\n@@ -170,1 +170,1 @@\n-  if (a1tap != NULL && a2tap != NULL) {\n+  if (a1tap != nullptr && a2tap != nullptr) {\n@@ -249,1 +249,1 @@\n-        const Type* con_type = NULL;\n+        const Type* con_type = nullptr;\n@@ -273,1 +273,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -276,1 +276,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -315,1 +315,1 @@\n-    return NULL; \/\/ wrong offset\n+    return nullptr; \/\/ wrong offset\n@@ -327,1 +327,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -333,1 +333,1 @@\n-  if (type != NULL && type->is_instance_klass() && off >= InstanceMirrorKlass::offset_of_static_fields()) {\n+  if (type != nullptr && type->is_instance_klass() && off >= InstanceMirrorKlass::offset_of_static_fields()) {\n@@ -340,2 +340,2 @@\n-  if (field == NULL) {\n-    return NULL; \/\/ Wrong offset\n+  if (field == nullptr) {\n+    return nullptr; \/\/ Wrong offset\n@@ -349,1 +349,1 @@\n-    return NULL; \/\/ Non-constant field\n+    return nullptr; \/\/ Non-constant field\n@@ -355,1 +355,1 @@\n-  } else if (holder != NULL) {\n+  } else if (holder != nullptr) {\n@@ -363,1 +363,1 @@\n-    return NULL; \/\/ Not a constant\n+    return nullptr; \/\/ Not a constant\n@@ -378,1 +378,1 @@\n-  if (con_type != NULL && field->is_call_site_target()) {\n+  if (con_type != nullptr && field->is_call_site_target()) {\n@@ -550,1 +550,1 @@\n-  TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);\n+  TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, nullptr, OffsetBot);\n@@ -567,1 +567,1 @@\n-  TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL \/* current->env()->Object_klass() *\/, false, arrayOopDesc::length_offset_in_bytes());\n+  TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), nullptr \/* current->env()->Object_klass() *\/, false, arrayOopDesc::length_offset_in_bytes());\n@@ -569,1 +569,1 @@\n-  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n+  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n@@ -579,1 +579,1 @@\n-    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n+    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Type::OffsetBot);\n@@ -589,2 +589,2 @@\n-  \/\/ Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.\n-  TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;\n+  \/\/ Nobody should ask _array_body_type[T_NARROWOOP]. Use null as assert.\n+  TypeAryPtr::_array_body_type[T_NARROWOOP] = nullptr;\n@@ -662,1 +662,1 @@\n-  _zero_type[T_CONFLICT]= NULL;\n+  _zero_type[T_CONFLICT]= nullptr;\n@@ -697,1 +697,1 @@\n-  current->set_type_dict(NULL);\n+  current->set_type_dict(nullptr);\n@@ -702,1 +702,1 @@\n-  assert(current->type_arena() != NULL, \"must have created type arena\");\n+  assert(current->type_arena() != nullptr, \"must have created type arena\");\n@@ -704,1 +704,1 @@\n-  if (_shared_type_dict == NULL) {\n+  if (_shared_type_dict == nullptr) {\n@@ -786,1 +786,1 @@\n-  if( this_ptr == NULL || t_ptr == NULL )\n+  if( this_ptr == nullptr || t_ptr == nullptr )\n@@ -805,3 +805,3 @@\n-  const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()->speculative() : NULL;\n-  const TypePtr* t_spec = t->isa_ptr() != NULL ? t->is_ptr()->speculative() : NULL;\n-  if (this_spec != NULL && t_spec != NULL) {\n+  const TypePtr* this_spec = isa_ptr() != nullptr ? is_ptr()->speculative() : nullptr;\n+  const TypePtr* t_spec = t->isa_ptr() != nullptr ? t->is_ptr()->speculative() : nullptr;\n+  if (this_spec != nullptr && t_spec != nullptr) {\n@@ -813,1 +813,1 @@\n-  if (this_spec != NULL && this_spec->interface_vs_oop_helper(t)) {\n+  if (this_spec != nullptr && this_spec->interface_vs_oop_helper(t)) {\n@@ -816,1 +816,1 @@\n-  if (t_spec != NULL && interface_vs_oop_helper(t_spec)) {\n+  if (t_spec != nullptr && interface_vs_oop_helper(t_spec)) {\n@@ -1564,1 +1564,1 @@\n-  if (old == NULL)  return this;\n+  if (old == nullptr)  return this;\n@@ -1566,1 +1566,1 @@\n-  if (ot == NULL)  return this;\n+  if (ot == nullptr)  return this;\n@@ -1595,1 +1595,1 @@\n-  if (ft == NULL || ft->empty())\n+  if (ft == nullptr || ft->empty())\n@@ -1828,1 +1828,1 @@\n-  if (old == NULL)  return this;\n+  if (old == nullptr)  return this;\n@@ -1830,1 +1830,1 @@\n-  if (ot == NULL)  return this;\n+  if (ot == nullptr)  return this;\n@@ -1859,1 +1859,1 @@\n-  if (ft == NULL || ft->empty())\n+  if (ft == nullptr || ft->empty())\n@@ -1893,1 +1893,1 @@\n-    if (n >= x + 10000)  return NULL;\n+    if (n >= x + 10000)  return nullptr;\n@@ -1896,1 +1896,1 @@\n-    if (n <= x - 10000)  return NULL;\n+    if (n <= x - 10000)  return nullptr;\n@@ -1914,1 +1914,1 @@\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(max_juint, \"maxuint\", buf, n)) != nullptr)\n@@ -1916,1 +1916,1 @@\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(max_jint, \"maxint\", buf, n)) != nullptr)\n@@ -1918,1 +1918,1 @@\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(min_jint, \"minint\", buf, n)) != nullptr)\n@@ -2008,1 +2008,1 @@\n-  if (recv != NULL) {\n+  if (recv != nullptr) {\n@@ -2272,1 +2272,1 @@\n-    if(this_ptr != NULL && t_ptr != NULL) {\n+    if(this_ptr != nullptr && t_ptr != NULL) {\n@@ -2310,1 +2310,1 @@\n-  const TypeOopPtr*  toop = NULL;\n+  const TypeOopPtr*  toop = nullptr;\n@@ -2339,7 +2339,7 @@\n-const TypeVect *TypeVect::VECTA = NULL; \/\/ vector length agnostic\n-const TypeVect *TypeVect::VECTS = NULL; \/\/  32-bit vectors\n-const TypeVect *TypeVect::VECTD = NULL; \/\/  64-bit vectors\n-const TypeVect *TypeVect::VECTX = NULL; \/\/ 128-bit vectors\n-const TypeVect *TypeVect::VECTY = NULL; \/\/ 256-bit vectors\n-const TypeVect *TypeVect::VECTZ = NULL; \/\/ 512-bit vectors\n-const TypeVect *TypeVect::VECTMASK = NULL; \/\/ predicate\/mask vector\n+const TypeVect *TypeVect::VECTA = nullptr; \/\/ vector length agnostic\n+const TypeVect *TypeVect::VECTS = nullptr; \/\/  32-bit vectors\n+const TypeVect *TypeVect::VECTD = nullptr; \/\/  64-bit vectors\n+const TypeVect *TypeVect::VECTX = nullptr; \/\/ 128-bit vectors\n+const TypeVect *TypeVect::VECTY = nullptr; \/\/ 256-bit vectors\n+const TypeVect *TypeVect::VECTZ = nullptr; \/\/ 512-bit vectors\n+const TypeVect *TypeVect::VECTMASK = nullptr; \/\/ predicate\/mask vector\n@@ -2370,1 +2370,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2530,1 +2530,1 @@\n-  if (res->isa_ptr() == NULL) {\n+  if (res->isa_ptr() == nullptr) {\n@@ -2535,2 +2535,2 @@\n-  if (res_ptr->speculative() != NULL) {\n-    \/\/ type->speculative() == NULL means that speculation is no better\n+  if (res_ptr->speculative() != nullptr) {\n+    \/\/ type->speculative() is null means that speculation is no better\n@@ -2541,1 +2541,1 @@\n-    \/\/ type and set speculative to NULL if it is the case.\n+    \/\/ type and set speculative to null if it is the case.\n@@ -2656,1 +2656,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -2660,1 +2660,1 @@\n-  return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);\n+  return make(AnyPtr, _ptr, _offset, nullptr, _inline_depth);\n@@ -2668,1 +2668,1 @@\n-  if (speculative() == NULL) {\n+  if (speculative() == nullptr) {\n@@ -2685,1 +2685,1 @@\n-      (spec_oopptr == NULL || !spec_oopptr->klass_is_exact())) {\n+      (spec_oopptr == nullptr || !spec_oopptr->klass_is_exact())) {\n@@ -2695,2 +2695,2 @@\n-  if (_speculative == NULL) {\n-    return NULL;\n+  if (_speculative == nullptr) {\n+    return nullptr;\n@@ -2707,2 +2707,2 @@\n-  bool this_has_spec = (_speculative != NULL);\n-  bool other_has_spec = (other->speculative() != NULL);\n+  bool this_has_spec = (_speculative != nullptr);\n+  bool other_has_spec = (other->speculative() != nullptr);\n@@ -2711,1 +2711,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2756,1 +2756,1 @@\n-  if (_speculative == NULL || other->speculative() == NULL) {\n+  if (_speculative == nullptr || other->speculative() == nullptr) {\n@@ -2771,1 +2771,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -2784,2 +2784,2 @@\n-  if (_speculative == NULL) {\n-    return NULL;\n+  if (_speculative == nullptr) {\n+    return nullptr;\n@@ -2794,1 +2794,1 @@\n-  if (_speculative != NULL && _speculative->isa_oopptr()) {\n+  if (_speculative != nullptr && _speculative->isa_oopptr()) {\n@@ -2800,1 +2800,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2807,1 +2807,1 @@\n-  if (_speculative != NULL) {\n+  if (_speculative != nullptr) {\n@@ -2815,1 +2815,1 @@\n-  if (_speculative != NULL) {\n+  if (_speculative != nullptr) {\n@@ -2828,1 +2828,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2843,1 +2843,1 @@\n-  if (exact_kls == NULL) {\n+  if (exact_kls == nullptr) {\n@@ -2850,1 +2850,1 @@\n-  if (speculative_type() == NULL) {\n+  if (speculative_type() == nullptr) {\n@@ -2893,1 +2893,1 @@\n-  if (ptr_kind == ProfileAlwaysNull && speculative() != NULL && speculative()->isa_oopptr()) {\n+  if (ptr_kind == ProfileAlwaysNull && speculative() != nullptr && speculative()->isa_oopptr()) {\n@@ -2901,1 +2901,1 @@\n-  \"TopPTR\",\"AnyNull\",\"Constant\",\"NULL\",\"NotNull\",\"BotPTR\"\n+  \"TopPTR\",\"AnyNull\",\"Constant\",\"null\",\"NotNull\",\"BotPTR\"\n@@ -2906,1 +2906,1 @@\n-  if( _ptr == Null ) st->print(\"NULL\");\n+  if( _ptr == Null ) st->print(\"null\");\n@@ -2919,1 +2919,1 @@\n-  if (_speculative != NULL) {\n+  if (_speculative != nullptr) {\n@@ -2960,1 +2960,1 @@\n-  assert( ptr != Null, \"Use TypePtr for NULL\" );\n+  assert( ptr != Null, \"Use TypePtr for null\" );\n@@ -2965,1 +2965,1 @@\n-  assert( bits, \"Use TypePtr for NULL\" );\n+  assert( bits, \"Use TypePtr for null\" );\n@@ -2972,1 +2972,1 @@\n-  assert( ptr != Null, \"Use TypePtr for NULL\" );\n+  assert( ptr != Null, \"Use TypePtr for null\" );\n@@ -3060,1 +3060,1 @@\n-  return NULL;                  \/\/ Lint noise\n+  return nullptr;                  \/\/ Lint noise\n@@ -3108,1 +3108,1 @@\n-    } else if (klass() == NULL) {\n+    } else if (klass() == nullptr) {\n@@ -3135,2 +3135,2 @@\n-          ciField* field = NULL;\n-          if (const_oop() != NULL) {\n+          ciField* field = nullptr;\n+          if (const_oop() != nullptr) {\n@@ -3140,1 +3140,1 @@\n-          if (field != NULL) {\n+          if (field != nullptr) {\n@@ -3150,1 +3150,1 @@\n-          if (field != NULL) {\n+          if (field != nullptr) {\n@@ -3174,1 +3174,1 @@\n-  ciObject* o = NULL;\n+  ciObject* o = nullptr;\n@@ -3207,1 +3207,1 @@\n-  if (k == NULL)\n+  if (k == nullptr)\n@@ -3289,1 +3289,1 @@\n-  assert(const_oop() == NULL,             \"no constants here\");\n+  assert(const_oop() == nullptr,             \"no constants here\");\n@@ -3299,1 +3299,1 @@\n-    assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+    assert((deps != nullptr) == (C->method() != nullptr && C->method()->code_size() > 0), \"sanity\");\n@@ -3307,1 +3307,1 @@\n-          && deps != NULL && UseUniqueSubclasses) {\n+          && deps != nullptr && UseUniqueSubclasses) {\n@@ -3309,1 +3309,1 @@\n-        if (sub != NULL) {\n+        if (sub != nullptr) {\n@@ -3315,1 +3315,1 @@\n-      if (!klass_is_exact && try_for_exact && deps != NULL &&\n+      if (!klass_is_exact && try_for_exact && deps != nullptr &&\n@@ -3322,1 +3322,1 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, nullptr, 0);\n@@ -3330,1 +3330,1 @@\n-    \/\/ slam NULLs down in the subarrays.\n+    \/\/ slam nulls down in the subarrays.\n@@ -3343,1 +3343,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3360,1 +3360,1 @@\n-      return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);\n+      return TypeInstPtr::make(TypePtr::NotNull, klass, true, nullptr, 0);\n@@ -3369,1 +3369,1 @@\n-    \/\/ slam NULLs down in the subarrays.\n+    \/\/ slam nulls down in the subarrays.\n@@ -3390,1 +3390,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3470,1 +3470,1 @@\n-  if (one == NULL || two == NULL) {\n+  if (one == nullptr || two == nullptr) {\n@@ -3525,1 +3525,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -3529,1 +3529,1 @@\n-  return make(_ptr, _offset, _instance_id, NULL, _inline_depth);\n+  return make(_ptr, _offset, _instance_id, nullptr, _inline_depth);\n@@ -3609,2 +3609,2 @@\n-   assert(k != NULL &&\n-          (k->is_loaded() || o == NULL),\n+   assert(k != nullptr &&\n+          (k->is_loaded() || o == nullptr),\n@@ -3624,1 +3624,1 @@\n-  \/\/ Either const_oop() is NULL or else ptr is Constant\n+  \/\/ Either const_oop() is null or else ptr is Constant\n@@ -3628,1 +3628,1 @@\n-  assert( ptr != Null, \"NULL pointers are not typed\" );\n+  assert( ptr != Null, \"null pointers are not typed\" );\n@@ -3652,1 +3652,1 @@\n-  assert((const_oop() != NULL), \"should be called only for constant object\");\n+  assert((const_oop() != nullptr), \"should be called only for constant object\");\n@@ -3667,1 +3667,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3724,1 +3724,1 @@\n-      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, instance_id, speculative, depth); }\n+      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, nullptr, off, instance_id, speculative, depth); }\n@@ -3792,1 +3792,1 @@\n-                  (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : nullptr), offset, instance_id, speculative, depth);\n@@ -3820,1 +3820,1 @@\n-                  (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : nullptr), offset, instance_id, speculative, depth);\n@@ -3859,1 +3859,1 @@\n-      return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);\n+      return make(ptr, klass(), klass_is_exact(), nullptr, off, instance_id, speculative, depth);\n@@ -3922,1 +3922,1 @@\n-      ciObject* o = NULL;  \/\/ the Constant value, if any\n+      ciObject* o = nullptr;  \/\/ the Constant value, if any\n@@ -3957,1 +3957,1 @@\n-    ciKlass *subtype = NULL;\n+    ciKlass *subtype = nullptr;\n@@ -3988,1 +3988,1 @@\n-      \/\/ NotNull if they do (neither constant is NULL; that is a special case\n+      \/\/ NotNull if they do (neither constant is null; that is a special case\n@@ -3990,1 +3990,1 @@\n-      ciObject* o = NULL;             \/\/ Assume not constant when done\n+      ciObject* o = nullptr;             \/\/ Assume not constant when done\n@@ -3994,1 +3994,1 @@\n-        if (this_oop != NULL && tinst_oop != NULL &&\n+        if (this_oop != nullptr && tinst_oop != nullptr &&\n@@ -4016,1 +4016,1 @@\n-    return make(ptr, k, false, NULL, off, instance_id, speculative, depth);\n+    return make(ptr, k, false, nullptr, off, instance_id, speculative, depth);\n@@ -4027,1 +4027,1 @@\n-  if( const_oop() == NULL )  return NULL;\n+  if( const_oop() == nullptr )  return nullptr;\n@@ -4030,1 +4030,1 @@\n-  if( klass() != ciEnv::current()->Class_klass() )  return NULL;\n+  if( klass() != ciEnv::current()->Class_klass() )  return nullptr;\n@@ -4119,1 +4119,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -4124,1 +4124,1 @@\n-              _instance_id, NULL, _inline_depth);\n+              _instance_id, nullptr, _inline_depth);\n@@ -4155,1 +4155,1 @@\n-  assert(!(k == NULL && ary->_elem->isa_int()),\n+  assert(!(k == nullptr && ary->_elem->isa_int()),\n@@ -4159,1 +4159,1 @@\n-  return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))->hashcons();\n+  return (TypeAryPtr*)(new TypeAryPtr(ptr, nullptr, ary, k, xk, offset, instance_id, false, speculative, inline_depth))->hashcons();\n@@ -4166,1 +4166,1 @@\n-  assert(!(k == NULL && ary->_elem->isa_int()),\n+  assert(!(k == nullptr && ary->_elem->isa_int()),\n@@ -4169,1 +4169,1 @@\n-  if (!xk)  xk = (o != NULL) || ary->ary_must_be_exact();\n+  if (!xk)  xk = (o != nullptr) || ary->ary_must_be_exact();\n@@ -4212,1 +4212,1 @@\n-\/\/ Return NULL if the resulting int type becomes empty.\n+\/\/ Return null if the resulting int type becomes empty.\n@@ -4244,1 +4244,1 @@\n-  assert(new_size != NULL, \"\");\n+  assert(new_size != nullptr, \"\");\n@@ -4259,1 +4259,1 @@\n-  if (stable_dimension > 1 && elem_ptr != NULL && elem_ptr->isa_aryptr()) {\n+  if (stable_dimension > 1 && elem_ptr != nullptr && elem_ptr->isa_aryptr()) {\n@@ -4274,1 +4274,1 @@\n-  if (elem_ptr != NULL && elem_ptr->isa_aryptr())\n+  if (elem_ptr != nullptr && elem_ptr->isa_aryptr())\n@@ -4283,1 +4283,1 @@\n-  if (etype == NULL)  return this;\n+  if (etype == nullptr)  return this;\n@@ -4343,1 +4343,1 @@\n-      return make(ptr, (ptr == Constant ? const_oop() : NULL),\n+      return make(ptr, (ptr == Constant ? const_oop() : nullptr),\n@@ -4373,1 +4373,1 @@\n-      return make(ptr, (ptr == Constant ? const_oop() : NULL),\n+      return make(ptr, (ptr == Constant ? const_oop() : nullptr),\n@@ -4392,1 +4392,1 @@\n-    ciKlass* lazy_klass = NULL;\n+    ciKlass* lazy_klass = nullptr;\n@@ -4396,1 +4396,1 @@\n-      if (_klass == NULL)\n+      if (_klass == nullptr)\n@@ -4398,1 +4398,1 @@\n-      else if (tap->_klass == NULL || tap->_klass == _klass) {\n+      else if (tap->_klass == nullptr || tap->_klass == _klass) {\n@@ -4411,1 +4411,1 @@\n-          tap->_klass != NULL  && this->_klass != NULL   &&\n+          tap->_klass != nullptr  && this->_klass != nullptr   &&\n@@ -4421,1 +4421,1 @@\n-      return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);\n+      return make(NotNull, nullptr, tary, lazy_klass, false, off, InstanceBot, speculative, depth);\n@@ -4438,1 +4438,1 @@\n-        if( tap->const_oop() != NULL && !o->equals(tap->const_oop()) ) {\n+        if( tap->const_oop() != nullptr && !o->equals(tap->const_oop()) ) {\n@@ -4441,1 +4441,1 @@\n-          o = NULL;\n+          o = nullptr;\n@@ -4464,1 +4464,1 @@\n-      return make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n+      return make(ptr, nullptr, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n@@ -4489,1 +4489,1 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, nullptr,offset, instance_id, speculative, depth);\n@@ -4503,1 +4503,1 @@\n-          return make(ptr, (ptr == Constant ? const_oop() : NULL),\n+          return make(ptr, (ptr == Constant ? const_oop() : nullptr),\n@@ -4515,1 +4515,1 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, nullptr, offset, instance_id, speculative, depth);\n@@ -4598,1 +4598,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -4602,1 +4602,1 @@\n-  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);\n+  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _instance_id, nullptr, _inline_depth);\n@@ -4639,1 +4639,1 @@\n-  if (tc != NULL) {\n+  if (tc != nullptr) {\n@@ -4770,1 +4770,1 @@\n-  if (one == NULL || two == NULL) {\n+  if (one == nullptr || two == nullptr) {\n@@ -4803,1 +4803,1 @@\n-  if (ft == NULL || ft->empty())\n+  if (ft == nullptr || ft->empty())\n@@ -4904,1 +4904,1 @@\n-    return make(ptr, NULL, offset);\n+    return make(ptr, nullptr, offset);\n@@ -4951,1 +4951,1 @@\n-  assert(m == NULL || !m->is_klass(), \"wrong type\");\n+  assert(m == nullptr || !m->is_klass(), \"wrong type\");\n@@ -4971,1 +4971,1 @@\n-  assert( k != NULL, \"Expect a non-NULL klass\");\n+  assert( k != nullptr, \"Expect a non-nullptr klass\");\n@@ -5012,1 +5012,1 @@\n-    if (!empty() && ktkp != NULL && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n+    if (!empty() && ktkp != nullptr && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n@@ -5020,1 +5020,1 @@\n-  if (ftkp != NULL && ktkp != NULL &&\n+  if (ftkp != nullptr && ktkp != nullptr &&\n@@ -5034,1 +5034,1 @@\n-  ciKlass* k_ary = NULL;\n+  ciKlass* k_ary = nullptr;\n@@ -5043,1 +5043,1 @@\n-  if ((tinst = el->isa_instptr()) != NULL) {\n+  if ((tinst = el->isa_instptr()) != nullptr) {\n@@ -5046,1 +5046,1 @@\n-  } else if ((tary = el->isa_aryptr()) != NULL) {\n+  } else if ((tary = el->isa_aryptr()) != nullptr) {\n@@ -5050,1 +5050,1 @@\n-    if (k_elem != NULL)\n+    if (k_elem != nullptr)\n@@ -5056,1 +5056,1 @@\n-    \/\/ Leave k_ary at NULL.\n+    \/\/ Leave k_ary at null.\n@@ -5109,1 +5109,1 @@\n-    if (UseCompressedOops && k_ary != NULL && k_ary->is_obj_array_klass() &&\n+    if (UseCompressedOops && k_ary != nullptr && k_ary->is_obj_array_klass() &&\n@@ -5145,1 +5145,1 @@\n-  \/\/return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);\n+  \/\/return TypeInstPtr::make(TypePtr::NotNull, k, xk, nullptr, 0);\n@@ -5147,1 +5147,1 @@\n-  guarantee(toop != NULL, \"need type for given klass\");\n+  guarantee(toop != nullptr, \"need type for given klass\");\n@@ -5257,1 +5257,1 @@\n-      \/\/ NotNull if they do (neither constant is NULL; that is a special case\n+      \/\/ NotNull if they do (neither constant is null; that is a special case\n@@ -5359,1 +5359,1 @@\n-  if (tf != NULL)  return tf;  \/\/ The hit rate here is almost 50%.\n+  if (tf != nullptr)  return tf;  \/\/ The hit rate here is almost 50%.\n@@ -5362,1 +5362,1 @@\n-    domain = TypeTuple::make_domain(NULL, method->signature());\n+    domain = TypeTuple::make_domain(nullptr, method->signature());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":175,"deletions":175,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -832,12 +832,14 @@\n-    ThreadsListHandle tlh;\n-    JavaThread* thr = NULL;\n-    oop java_thread = NULL;\n-    (void) tlh.cv_internal_thread_to_JavaThread(jthread, &thr, &java_thread);\n-    if (java_thread != NULL) {\n-      \/\/ This is a valid oop.\n-      if (thr != NULL) {\n-        \/\/ The JavaThread is alive.\n-        Parker* p = thr->parker();\n-        HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n-        p->unpark();\n-      }\n+    oop thread_oop = JNIHandles::resolve_non_null(jthread);\n+    \/\/ Get the JavaThread* stored in the java.lang.Thread object _before_\n+    \/\/ the embedded ThreadsListHandle is constructed so we know if the\n+    \/\/ early life stage of the JavaThread* is protected. We use acquire\n+    \/\/ here to ensure that if we see a non-nullptr value, then we also\n+    \/\/ see the main ThreadsList updates from the JavaThread* being added.\n+    FastThreadsListHandle ftlh(thread_oop, java_lang_Thread::thread_acquire(thread_oop));\n+    JavaThread* thr = ftlh.protected_java_thread();\n+    if (thr != nullptr) {\n+      \/\/ The still live JavaThread* is protected by the FastThreadsListHandle\n+      \/\/ so it is safe to access.\n+      Parker* p = thr->parker();\n+      HOTSPOT_THREAD_UNPARK((uintptr_t) p);\n+      p->unpark();\n@@ -845,2 +847,1 @@\n-  } \/\/ ThreadsListHandle is destroyed here.\n-\n+  } \/\/ FastThreadsListHandle is destroyed here.\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,2 @@\n-\/\/ EXPERIMENTAL flags are in support of features that are not\n-\/\/    part of the officially supported product, but are available\n+\/\/ EXPERIMENTAL flags are in support of features that may not be\n+\/\/    an officially supported part of a product, but may be available\n@@ -78,0 +78,2 @@\n+\/\/    Refer to the documentation of any products using this code for details\n+\/\/    on support and fitness for production.\n@@ -83,2 +85,1 @@\n-\/\/    and they are not supported on production loads, except under explicit\n-\/\/    direction from support engineers.\n+\/\/    Refer to the documentation of any products using this code for details.\n@@ -923,4 +924,0 @@\n-                                                                            \\\n-  notproduct(bool, CheckMemoryInitialization, false,                        \\\n-          \"Check memory initialization\")                                    \\\n-                                                                            \\\n@@ -992,3 +989,0 @@\n-  product(bool, EnableThreadSMRExtraValidityChecks, true, DIAGNOSTIC,       \\\n-             \"Enable Thread SMR extra validity checks\")                     \\\n-                                                                            \\\n@@ -1386,0 +1380,4 @@\n+  product(int, ErrorLogPrintCodeLimit, 3, DIAGNOSTIC,                       \\\n+          \"max number of compiled code units to print in error log\")        \\\n+          range(0, VMError::max_error_log_print_code)                       \\\n+                                                                            \\\n@@ -2013,1 +2011,1 @@\n-  product(intx, ArchiveRelocationMode, 0, DIAGNOSTIC,                       \\\n+  product(intx, ArchiveRelocationMode, 1, DIAGNOSTIC,                       \\\n@@ -2015,2 +2013,2 @@\n-           \"unsuccessful, map at alternative address (default); \"           \\\n-           \"(1) always map at alternative address; \"                        \\\n+           \"unsuccessful, map at alternative address; \"                     \\\n+           \"(1) always map at alternative address (default); \"              \\\n@@ -2115,0 +2113,7 @@\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 0, EXPERIMENTAL,                    \\\n+          \"Interval, in ms, at which the JVM will trim the native heap if \" \\\n+          \"the platform supports that. Lower values will reclaim memory \"   \\\n+          \"more eagerly at the cost of higher overhead. A value of 0 \"      \\\n+          \"(default) disables native heap trimming.\")                       \\\n+          range(0, UINT_MAX)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -818,1 +819,1 @@\n-  markWord mark = obj->mark();\n+  markWord mark = obj->mark_acquire();\n@@ -826,1 +827,1 @@\n-    markWord mark = obj->mark();\n+    markWord mark = obj->mark_acquire();\n@@ -860,1 +861,1 @@\n-        while (obj->mark() == markWord::INFLATING()) {\n+        while (obj->mark_acquire() == markWord::INFLATING()) {\n@@ -1339,1 +1340,1 @@\n-  markWord mark = obj->mark();\n+  markWord mark = obj->mark_acquire();\n@@ -1354,1 +1355,1 @@\n-    const markWord mark = object->mark();\n+    const markWord mark = object->mark_acquire();\n@@ -1738,0 +1739,2 @@\n+    NativeHeapTrimmer::SuspendMark sm(\"monitor deletion\");\n+\n@@ -1870,1 +1873,1 @@\n-    \/\/ level at a safepoint in ObjectSynchronizer::do_safepoint_work().\n+    \/\/ level at a safepoint in SafepointSynchronize::do_cleanup_tasks.\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -660,1 +661,3 @@\n-  else                                { st->print(\"Thread\"); }\n+  else if (this == AsyncLogWriter::instance()) {\n+    st->print(\"%s\", this->name());\n+  } else                                { st->print(\"Thread\"); }\n@@ -1346,2 +1349,3 @@\n-  \/\/ to complete once we've done the notify_all below\n-  java_lang_Thread::set_thread(threadObj(), NULL);\n+  \/\/ to complete once we've done the notify_all below. Needs a release() to obey Java Memory Model\n+  \/\/ requirements.\n+  java_lang_Thread::release_set_thread(threadObj(), NULL);\n@@ -2271,1 +2275,0 @@\n-  java_lang_Thread::set_thread(thread_oop(), this);\n@@ -2287,0 +2290,5 @@\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList. We don't want to wait for the release when the\n+  \/\/ Theads_lock is dropped somewhere in the caller since the JavaThread*\n+  \/\/ is already visible to JVM\/TI via the ThreadsList.\n+  java_lang_Thread::release_set_thread(thread_oop(), this);\n@@ -2298,0 +2306,19 @@\n+\/\/ Print current stack trace for checked JNI warnings and JNI fatal errors.\n+\/\/ This is the external format, selecting the platform\n+\/\/ as applicable, and allowing for a native-only stack.\n+void JavaThread::print_jni_stack() {\n+  assert(this == JavaThread::current(), \"Can't print stack of other threads\");\n+  if (!has_last_Java_frame()) {\n+    ResourceMark rm(this);\n+    char* buf = NEW_RESOURCE_ARRAY_RETURN_NULL(char, O_BUFLEN);\n+    if (buf == nullptr) {\n+      tty->print_cr(\"Unable to print native stack - out of memory\");\n+      return;\n+    }\n+    frame f = os::current_frame();\n+    VMError::print_native_stack(tty, f, this,\n+                                buf, O_BUFLEN);\n+  } else {\n+    print_stack_on(tty);\n+  }\n+}\n@@ -3077,0 +3104,4 @@\n+  if (NativeHeapTrimmer::enabled()) {\n+    NativeHeapTrimmer::initialize();\n+  }\n+\n@@ -4019,0 +4050,43 @@\n+\n+\/\/ Starts the target JavaThread as a daemon of the given priority, and\n+\/\/ bound to the given java.lang.Thread instance.\n+\/\/ The Threads_lock is held for the duration.\n+void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                       Handle thread_oop, ThreadPriority prio) {\n+\n+  assert(target->osthread()!= NULL, \"target thread is not properly initialized\");\n+\n+  MutexLocker mu(current, Threads_lock);\n+\n+  \/\/ Initialize the fields of the thread_oop first.\n+  if (prio != NoPriority) {\n+    java_lang_Thread::set_priority(thread_oop(), prio);\n+    \/\/ Note: we don't call os::set_priority here. Possibly we should,\n+    \/\/ else all threads should call it themselves when they first run.\n+  }\n+\n+  java_lang_Thread::set_daemon(thread_oop());\n+\n+  \/\/ Now bind the thread_oop to the target JavaThread.\n+  target->set_threadObj(thread_oop());\n+\n+  Threads::add(target); \/\/ target is now visible for safepoint\/handshake\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList. We don't want to wait for the release when the\n+  \/\/ Theads_lock is dropped when the 'mu' destructor is run since the\n+  \/\/ JavaThread* is already visible to JVM\/TI via the ThreadsList.\n+  java_lang_Thread::release_set_thread(thread_oop(), target); \/\/ isAlive == true now\n+  Thread::start(target);\n+}\n+\n+void JavaThread::vm_exit_on_osthread_failure(JavaThread* thread) {\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources. However, since this must work\n+  \/\/ for critical system threads just check and abort if this fails.\n+  if (thread->osthread() == nullptr) {\n+    \/\/ This isn't really an OOM condition, but historically this is what\n+    \/\/ we report.\n+    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n+                                  os::native_thread_creation_failed_msg());\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":78,"deletions":4,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-\n@@ -658,0 +657,25 @@\n+\n+ private:\n+  bool _in_asgct = false;\n+ public:\n+  bool in_asgct() const { return _in_asgct; }\n+  void set_in_asgct(bool value) { _in_asgct = value; }\n+  static bool current_in_asgct() {\n+    Thread *cur = Thread::current_or_null_safe();\n+    return cur != nullptr && cur->in_asgct();\n+  }\n+};\n+\n+class ThreadInAsgct {\n+ private:\n+  Thread* _thread;\n+ public:\n+  ThreadInAsgct(Thread* thread) : _thread(thread) {\n+    assert(thread != nullptr, \"invariant\");\n+    assert(!thread->in_asgct(), \"invariant\");\n+    thread->set_in_asgct(true);\n+  }\n+  ~ThreadInAsgct() {\n+    assert(_thread->in_asgct(), \"invariant\");\n+    _thread->set_in_asgct(false);\n+  }\n@@ -1432,0 +1456,4 @@\n+  \/\/ Print current stack trace for checked JNI warnings and JNI fatal errors.\n+  \/\/ This is the external format from above, but selecting the platform\n+  \/\/ as applicable.\n+  void print_jni_stack();\n@@ -1632,0 +1660,9 @@\n+  \/\/ Helper function to start a VM-internal daemon thread.\n+  \/\/ E.g. ServiceThread, NotificationThread, CompilerThread etc.\n+  static void start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                    Handle thread_oop, ThreadPriority prio);\n+\n+  \/\/ Helper function to do vm_exit_on_initialization for osthread\n+  \/\/ resource allocation failure.\n+  static void vm_exit_on_osthread_failure(JavaThread* thread);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -327,0 +327,3 @@\n+#define PROPERFMT             SIZE_FORMAT \"%s\"\n+#define PROPERFMTARGS(s)      byte_size_in_proper_unit(s), proper_unit_for_byte_size(s)\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import sun.jvm.hotspot.runtime.linux_riscv64.LinuxRISCV64JavaThreadPDAccess;\n@@ -116,0 +117,2 @@\n+            } else if (cpu.equals(\"riscv64\")) {\n+                access = new LinuxRISCV64JavaThreadPDAccess();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -504,6 +504,2 @@\n-    if (minObjAlignmentInBytes == 8) {\n-      logMinObjAlignmentInBytes = 3;\n-    } else if (minObjAlignmentInBytes == 16) {\n-      logMinObjAlignmentInBytes = 4;\n-    } else {\n-      throw new RuntimeException(\"Object alignment \" + minObjAlignmentInBytes + \" not yet supported\");\n+    if ((minObjAlignmentInBytes & (minObjAlignmentInBytes - 1)) != 0) {\n+      throw new RuntimeException(\"Object alignment \" + minObjAlignmentInBytes + \" is not power of two\");\n@@ -512,0 +508,2 @@\n+    logMinObjAlignmentInBytes = Integer.numberOfTrailingZeros(minObjAlignmentInBytes);\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABPromotion.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -34,1 +34,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -58,1 +58,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -62,1 +62,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -86,1 +86,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -90,1 +90,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -114,1 +114,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -118,1 +118,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -146,1 +146,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -150,1 +150,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -178,1 +178,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -182,1 +182,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -210,1 +210,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -214,1 +214,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -242,1 +242,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -246,1 +246,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -275,1 +275,1 @@\n- * @build sun.hotspot.WhiteBox\n+ * @build jdk.test.whitebox.WhiteBox\n@@ -279,1 +279,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -300,1 +300,1 @@\n-import sun.hotspot.WhiteBox;\n+import jdk.test.whitebox.WhiteBox;\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"}]}