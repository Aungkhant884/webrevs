{"files":[{"patch":"@@ -7488,1 +7488,1 @@\n-instruct loadNKlassLilliput(iRegNNoSp dst, memory4 mem, rFlagsReg cr)\n+instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory4 mem, rFlagsReg cr)\n@@ -7497,13 +7497,1 @@\n-    assert($mem$$disp == oopDesc::klass_offset_in_bytes(), \"expect correct offset\");\n-    assert($mem$$index$$Register == noreg, \"expect no index\");\n-    Register dst = $dst$$Register;\n-    Register obj = $mem$$base$$Register;\n-    C2LoadNKlassStub* stub = new (Compile::current()->comp_arena()) C2LoadNKlassStub(dst);\n-    Compile::current()->output()->add_stub(stub);\n-    __ ldr(dst, Address(obj, oopDesc::mark_offset_in_bytes()));\n-    \/\/ NOTE: We can't use tbnz here, because the target is sometimes too far away\n-    \/\/ and cannot be encoded.\n-    __ tst(dst, markWord::monitor_value);\n-    __ br(Assembler::NE, stub->entry());\n-    __ bind(stub->continuation());\n-    __ lsr(dst, dst, markWord::klass_shift);\n+    __ load_nklass_compact($dst$$Register, $mem$$base$$Register, $mem$$index$$Register, $mem$$scale, $mem$$disp);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/c2_CodeStubs.hpp\"\n@@ -29,0 +30,2 @@\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/output.hpp\"\n@@ -878,0 +881,27 @@\n+\n+void C2_MacroAssembler::load_nklass_compact(Register dst, Register obj, Register index, int scale, int disp) {\n+  C2LoadNKlassStub* stub = new (Compile::current()->comp_arena()) C2LoadNKlassStub(dst);\n+  Compile::current()->output()->add_stub(stub);\n+\n+  \/\/ Note: Don't clobber obj anywhere in that method!\n+\n+  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n+  \/\/ obj-start, so that we can load from the object's mark-word instead. Usually the address\n+  \/\/ comes as obj-start in obj and klass_offset_in_bytes in disp. However, sometimes C2\n+  \/\/ emits code that pre-computes obj-start + klass_offset_in_bytes into a register, and\n+  \/\/ then passes that register as obj and 0 in disp. The following code extracts the base\n+  \/\/ and offset to load the mark-word.\n+  int offset = oopDesc::mark_offset_in_bytes() + disp - oopDesc::klass_offset_in_bytes();\n+  if (index == noreg) {\n+    ldr(dst, Address(obj, offset));\n+  } else {\n+    lea(dst, Address(obj, index, Address::lsl(scale)));\n+    ldr(dst, Address(dst, offset));\n+  }\n+  \/\/ NOTE: We can't use tbnz here, because the target is sometimes too far away\n+  \/\/ and cannot be encoded.\n+  tst(dst, markWord::monitor_value);\n+  br(Assembler::NE, stub->entry());\n+  bind(stub->continuation());\n+  lsr(dst, dst, markWord::klass_shift);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  void load_nklass_compact(Register dst, Register obj, Register index, int scale, int disp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4008,0 +4008,22 @@\n+\n+#ifdef _LP64\n+void C2_MacroAssembler::load_nklass_compact_c2(Register dst, Register obj, Register index, Address::ScaleFactor scale, int disp) {\n+  C2LoadNKlassStub* stub = new (Compile::current()->comp_arena()) C2LoadNKlassStub(dst);\n+  Compile::current()->output()->add_stub(stub);\n+\n+  \/\/ Note: Don't clobber obj anywhere in that method!\n+\n+  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n+  \/\/ obj-start, so that we can load from the object's mark-word instead. Usually the address\n+  \/\/ comes as obj-start in obj and klass_offset_in_bytes in disp. However, sometimes C2\n+  \/\/ emits code that pre-computes obj-start + klass_offset_in_bytes into a register, and\n+  \/\/ then passes that register as obj and 0 in disp. The following code extracts the base\n+  \/\/ and offset to load the mark-word.\n+  int offset = oopDesc::mark_offset_in_bytes() + disp - oopDesc::klass_offset_in_bytes();\n+  movq(dst, Address(obj, index, scale, offset));\n+  testb(dst, markWord::monitor_value);\n+  jcc(Assembler::notZero, stub->entry());\n+  bind(stub->continuation());\n+  shrq(dst, markWord::klass_shift);\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -281,0 +281,2 @@\n+  void load_nklass_compact_c2(Register dst, Register obj, Register index, Address::ScaleFactor scale, int disp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5206,1 +5206,1 @@\n-instruct loadNKlassLilliput(rRegN dst, indOffset8 mem, rFlagsReg cr)\n+instruct loadNKlassCompactHeaders(rRegN dst, indOffset8 mem, rFlagsReg cr)\n@@ -5214,11 +5214,3 @@\n-    assert($mem$$disp == oopDesc::klass_offset_in_bytes(), \"expect correct offset 4, but got: %d\", $mem$$disp);\n-    assert($mem$$index == 4, \"expect no index register: %d\", $mem$$index);\n-    Register dst = $dst$$Register;\n-    Register obj = $mem$$base$$Register;\n-    C2LoadNKlassStub* stub = new (Compile::current()->comp_arena()) C2LoadNKlassStub(dst);\n-    Compile::current()->output()->add_stub(stub);\n-    __ movq(dst, Address(obj, oopDesc::mark_offset_in_bytes()));\n-    __ testb(dst, markWord::monitor_value);\n-    __ jcc(Assembler::notZero, stub->entry());\n-    __ bind(stub->continuation());\n-    __ shrq(dst, markWord::klass_shift);\n+    Register index = $mem$$index != 4 ? $mem$$index$$Register : noreg;\n+    Address::ScaleFactor sf = $mem$$index != 4 ? static_cast<Address::ScaleFactor>($mem$$scale) : Address::no_scale;\n+    __ load_nklass_compact_c2($dst$$Register, $mem$$base$$Register, index, sf, $mem$$disp);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"}]}