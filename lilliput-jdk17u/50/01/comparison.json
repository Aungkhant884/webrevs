{"files":[{"patch":"@@ -363,1 +363,1 @@\n-                                                  oop const old, Klass* klass, size_t word_sz, uint age,\n+                                                  Klass* klass, size_t word_sz, uint age,\n@@ -378,1 +378,0 @@\n-                                                   oop old,\n@@ -402,1 +401,1 @@\n-      report_promotion_event(*dest_attr, old, klass, word_sz, age, obj_ptr, node_index);\n+      report_promotion_event(*dest_attr, klass, word_sz, age, obj_ptr, node_index);\n@@ -427,9 +426,7 @@\n-  Klass* klass;\n-#ifdef _LP64\n-  if (UseCompactObjectHeaders) {\n-    klass = old_mark.safe_klass();\n-  } else\n-#endif\n-  {\n-    klass = old->klass();\n-  }\n+  \/\/ NOTE: With compact headers, it is not safe to load the Klass* from o, because\n+  \/\/ that would access the mark-word, and the mark-word might change at any time by\n+  \/\/ concurrent promotion. The promoted mark-word would point to the forwardee, which\n+  \/\/ may not yet have completed copying. Therefore we must load the Klass* from\n+  \/\/ the mark-word that we have already loaded. This is safe, because we have checked\n+  \/\/ that this is not yet forwarded in the caller.\n+  Klass* klass = old->forward_safe_klass(old_mark);\n@@ -448,1 +445,1 @@\n-    obj_ptr = allocate_copy_slow(&dest_attr, old, klass, word_sz, age, node_index);\n+    obj_ptr = allocate_copy_slow(&dest_attr, klass, word_sz, age, node_index);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -175,1 +175,0 @@\n-                               oop old,\n@@ -209,1 +208,1 @@\n-                              oop const old, Klass* klass, size_t word_sz, uint age,\n+                              Klass* klass, size_t word_sz, uint age,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,2 @@\n-  inline void promotion_trace_event(oop new_obj, oop old_obj, Klass* klass, size_t obj_size,\n+  inline void promotion_trace_event(oop new_obj, oop old_obj,\n+                                    Klass* klass, size_t obj_size,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-inline void PSPromotionManager::promotion_trace_event(oop new_obj, oop old_obj, Klass* klass,\n-                                                      size_t obj_size,\n+inline void PSPromotionManager::promotion_trace_event(oop new_obj, oop old_obj,\n+                                                      Klass* klass, size_t obj_size,\n@@ -163,9 +163,7 @@\n-  Klass* klass;\n-#ifdef _LP64\n-  if (UseCompactObjectHeaders) {\n-    klass = test_mark.safe_klass();\n-  } else\n-#endif\n-  {\n-    klass = o->klass();\n-  }\n+  \/\/ NOTE: With compact headers, it is not safe to load the Klass* from o, because\n+  \/\/ that would access the mark-word, and the mark-word might change at any time by\n+  \/\/ concurrent promotion. The promoted mark-word would point to the forwardee, which\n+  \/\/ may not yet have completed copying. Therefore we must load the Klass* from\n+  \/\/ the mark-word that we have already loaded. This is safe, because we have checked\n+  \/\/ that this is not yet forwarded in the caller.\n+  Klass* klass = o->forward_safe_klass(test_mark);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,13 +44,1 @@\n-#ifdef _LP64\n-  if (UseCompactObjectHeaders) {\n-    markWord real_mark = mark;\n-    if (real_mark.has_displaced_mark_helper()) {\n-      real_mark = real_mark.displaced_mark_helper();\n-    }\n-    Klass* klass = real_mark.klass();\n-    obj->set_mark(klass->prototype_header().set_marked());\n-  } else\n-#endif\n-  {\n-    obj->set_mark(markWord::prototype().set_marked());\n-  }\n+  obj->set_mark(obj->prototype_mark().set_marked());\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -85,15 +85,1 @@\n-#ifdef _LP64\n-    if (UseCompactObjectHeaders) {\n-      oop forwardee = obj->forwardee();\n-      markWord header = forwardee->mark();\n-      if (header.has_displaced_mark_helper()) {\n-        header = header.displaced_mark_helper();\n-      }\n-      assert(UseCompressedClassPointers, \"assume +UseCompressedClassPointers\");\n-      narrowKlass nklass = header.narrow_klass();\n-      obj->set_mark(markWord::prototype().set_narrow_klass(nklass));\n-    } else\n-#endif\n-    {\n-      PreservedMarks::init_forwarded_mark(obj);\n-    }\n+    PreservedMarks::init_forwarded_mark(obj);\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  obj->init_mark();\n+  obj->forward_safe_init_mark();\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -201,1 +200,1 @@\n-  Klass* obj_klass = ShenandoahObjectUtils::klass(obj);\n+  Klass* obj_klass = obj->forward_safe_klass();\n@@ -233,1 +232,1 @@\n-    if (obj_klass != ShenandoahObjectUtils::klass(fwd)) {\n+    if (obj_klass != fwd->forward_safe_klass()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -206,1 +205,1 @@\n-  size_t size = ShenandoahObjectUtils::size(p);\n+  size_t size = p->forward_safe_size();\n@@ -423,1 +422,1 @@\n-    size_t size = ShenandoahObjectUtils::size(obj);\n+    size_t size = obj->forward_safe_size();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-\n-class Klass;\n-\n-class ShenandoahObjectUtils : public AllStatic {\n-public:\n-#ifdef _LP64\n-  static inline markWord stable_mark(oop obj);\n-#endif\n-  static inline Klass* klass(oop obj);\n-  static inline size_t size(oop obj);\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.hpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n-\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahObjectUtils.hpp\"\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/markWord.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/objectMonitor.inline.hpp\"\n-#include \"runtime\/thread.hpp\"\n-\n-\/\/ This is a variant of oopDesc::actual_mark(), which does the same thing, but also\n-\/\/ handles forwarded objects. This is intended to be used by concurrent evacuation only. No other\n-\/\/ code is supposed to observe from-space objects.\n-#ifdef _LP64\n-markWord ShenandoahObjectUtils::stable_mark(oop obj) {\n-  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  assert(heap->is_in(obj), \"object not in heap: \" PTR_FORMAT, p2i(obj));\n-  markWord mark = obj->mark_acquire();\n-\n-  assert(!mark.is_being_inflated(), \"can not be inflating\");\n-\n-  \/\/ The mark can be in one of the following states:\n-  \/\/ *  Marked       - object is forwarded, try again on forwardee\n-  \/\/ *  Inflated     - just return mark from inflated monitor\n-  \/\/ *  Fast-locked  - return mark\n-  \/\/ *  Neutral      - return mark\n-\n-  \/\/ Most common cases first.\n-  if (mark.is_neutral() || mark.is_fast_locked()) {\n-    return mark;\n-  }\n-\n-  \/\/ If object is already forwarded, then resolve it, and try again.\n-  if (mark.is_marked()) {\n-    if (heap->is_full_gc_move_in_progress()) {\n-      \/\/ In these cases, we want to return the header as-is: the Klass* would not be overloaded.\n-      return mark;\n-    }\n-    obj = cast_to_oop(mark.decode_pointer());\n-    return stable_mark(obj);\n-  }\n-\n-  \/\/ CASE: inflated\n-  assert(mark.has_monitor(), \"must be monitor-locked at this point\");\n-  \/\/ It is safe to access the object monitor because all Java and GC worker threads\n-  \/\/ participate in the monitor deflation protocol (i.e, they react to handshakes and STS requests).\n-  ObjectMonitor* inf = mark.monitor();\n-  markWord dmw = inf->header();\n-  assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n-  return dmw;\n-}\n-#endif\n-\n-Klass* ShenandoahObjectUtils::klass(oop obj) {\n-  if (!UseCompactObjectHeaders) {\n-    return obj->klass();\n-  }\n-#ifdef _LP64\n-  markWord header = stable_mark(obj);\n-  assert(header.narrow_klass() != 0, \"klass must not be NULL: \" INTPTR_FORMAT, header.value());\n-  return header.klass();\n-#else\n-  return obj->klass();\n-#endif\n-}\n-\n-size_t ShenandoahObjectUtils::size(oop obj) {\n-  if (!UseCompactObjectHeaders) {\n-    return obj->size();\n-  }\n- Klass* kls = klass(obj);\n-  return obj->size_given_klass(kls);\n-}\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.inline.hpp","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -101,1 +100,1 @@\n-      if (is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n+      if (is_instance_ref_klass(obj->forward_safe_klass())) {\n@@ -128,1 +127,1 @@\n-    Klass* obj_klass = ShenandoahObjectUtils::klass(obj);\n+    Klass* obj_klass = obj->forward_safe_klass();\n@@ -143,1 +142,1 @@\n-        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + ShenandoahObjectUtils::size(obj)) <= obj_reg->top(),\n+        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj->forward_safe_size()) <= obj_reg->top(),\n@@ -147,1 +146,1 @@\n-        size_t humongous_end = humongous_start + (ShenandoahObjectUtils::size(obj) >> ShenandoahHeapRegion::region_size_words_shift());\n+        size_t humongous_end = humongous_start + (obj->forward_safe_size() >> ShenandoahHeapRegion::region_size_words_shift());\n@@ -164,1 +163,1 @@\n-          Atomic::add(&_ld[obj_reg->index()], (uint) ShenandoahObjectUtils::size(obj), memory_order_relaxed);\n+          Atomic::add(&_ld[obj_reg->index()], (uint) obj->forward_safe_size(), memory_order_relaxed);\n@@ -205,1 +204,1 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + ShenandoahObjectUtils::size(fwd)) <= fwd_reg->top(),\n+      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd->forward_safe_size()) <= fwd_reg->top(),\n@@ -308,1 +307,1 @@\n-    Klass* klass = ShenandoahObjectUtils::klass(obj);\n+    Klass* klass = obj->forward_safe_klass();\n@@ -589,1 +588,1 @@\n-    if (!is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n+    if (!is_instance_ref_klass(obj->forward_safe_klass())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -391,0 +391,1 @@\n+  inline markWord actual_mark() const;\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,9 @@\n+markWord markWord::actual_mark() const {\n+  assert(UseCompactObjectHeaders, \"only safe when using compact headers\");\n+  if (has_displaced_mark_helper()) {\n+    return displaced_mark_helper();\n+  } else {\n+    return *this;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -75,0 +75,3 @@\n+  \/\/ Returns the prototype mark that should be used for this object.\n+  inline markWord prototype_mark() const;\n+\n@@ -112,0 +115,14 @@\n+  \/\/ The following set of methods is used to access the mark-word and related\n+  \/\/ properties when the object may be forwarded. Be careful where and when\n+  \/\/ using this method. It assumes that the forwardee is installed in\n+  \/\/ the header as a plain pointer (or self-forwarded). In particular,\n+  \/\/ those methods can not deal with the sliding-forwarding that is used\n+  \/\/ in Serial, G1 and Shenandoah full-GCs.\n+private:\n+  inline Klass*   forward_safe_klass_impl(markWord m) const;\n+public:\n+  inline Klass*   forward_safe_klass() const;\n+  inline size_t   forward_safe_size();\n+  inline Klass*   forward_safe_klass(markWord m) const;\n+  inline void     forward_safe_init_mark();\n+\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -95,0 +95,8 @@\n+markWord oopDesc::prototype_mark() const {\n+  if (UseCompactObjectHeaders) {\n+    return klass()->prototype_header();\n+  } else {\n+    return markWord::prototype();\n+  }\n+}\n+\n@@ -252,0 +260,47 @@\n+#ifdef _LP64\n+Klass* oopDesc::forward_safe_klass_impl(markWord m) const {\n+  assert(UseCompactObjectHeaders, \"Only get here with compact headers\");\n+  if (m.is_marked()) {\n+    oop fwd = forwardee(m);\n+    markWord m2 = fwd->mark();\n+    assert(!m2.is_marked() || m2.self_forwarded(), \"no double forwarding: this: \" PTR_FORMAT \" (\" INTPTR_FORMAT \"), fwd: \" PTR_FORMAT \" (\" INTPTR_FORMAT \")\", p2i(this), m.value(), p2i(fwd), m2.value());\n+    m = m2;\n+  }\n+  return m.actual_mark().klass();\n+}\n+#endif\n+\n+Klass* oopDesc::forward_safe_klass(markWord m) const {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    return forward_safe_klass_impl(m);\n+  } else\n+#endif\n+  {\n+    return klass();\n+  }\n+}\n+\n+Klass* oopDesc::forward_safe_klass() const {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    return forward_safe_klass_impl(mark());\n+  } else\n+#endif\n+  {\n+    return klass();\n+  }\n+}\n+\n+size_t oopDesc::forward_safe_size() {\n+  return size_given_klass(forward_safe_klass());\n+}\n+\n+void oopDesc::forward_safe_init_mark() {\n+  if (UseCompactObjectHeaders) {\n+    set_mark(forward_safe_klass()->prototype_header());\n+  } else {\n+    set_mark(markWord::prototype());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"}]}