{"files":[{"patch":"@@ -972,11 +972,10 @@\n-  {\n-    owning_thread = ObjectSynchronizer::get_lock_owner(tlh.list(), hobj);\n-\n-    if (owning_thread != NULL) {  \/\/ monitor is owned\n-      \/\/ The recursions field of a monitor does not reflect recursions\n-      \/\/ as lightweight locks before inflating the monitor are not included.\n-      \/\/ We have to count the number of recursive monitor entries the hard way.\n-      \/\/ We pass a handle to survive any GCs along the way.\n-      ret.entry_count = count_locked_objects(owning_thread, hobj);\n-    }\n-    \/\/ implied else: entry_count == 0\n+  owning_thread = ObjectSynchronizer::get_lock_owner(tlh.list(), hobj);\n+  if (owning_thread != NULL) {  \/\/ monitor is owned\n+    Handle th(current_thread, owning_thread->threadObj());\n+    ret.owner = (jthread)jni_reference(calling_thread, th);\n+\n+    \/\/ The recursions field of a monitor does not reflect recursions\n+    \/\/ as lightweight locks before inflating the monitor are not included.\n+    \/\/ We have to count the number of recursive monitor entries the hard way.\n+    \/\/ We pass a handle to survive any GCs along the way.\n+    ret.entry_count = count_locked_objects(owning_thread, hobj);\n@@ -984,0 +983,1 @@\n+  \/\/ implied else: entry_count == 0\n@@ -986,1 +986,4 @@\n-  if (mon != NULL) {\n+  markWord mark = hobj->mark();\n+  if (mark.has_monitor()) {\n+    mon = mark.monitor();\n+    assert(mon != NULL, \"must have monitor\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"}]}