{"files":[{"patch":"@@ -83,0 +83,1 @@\n+\n@@ -87,1 +88,2 @@\n-  }  else {\n+    _reference_stack[_depth] = reference;\n+  } else {\n@@ -91,0 +93,6 @@\n+    _mark_bits->mark_obj(pointee);\n+    _reference_stack[_depth] = reference;\n+    \/\/ is the pointee a sample object?\n+    if (pointee->mark().is_marked()) {\n+      add_chain();\n+    }\n@@ -92,9 +100,0 @@\n-  _reference_stack[_depth] = reference;\n-  _mark_bits->mark_obj(pointee);\n-  assert(_mark_bits->is_marked(pointee), \"invariant\");\n-\n-  \/\/ is the pointee a sample object?\n-  if (pointee->mark().is_marked()) {\n-    add_chain();\n-  }\n-\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"jfr\/leakprofiler\/sampling\/objectSample.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -39,9 +41,0 @@\n-EdgeStore::EdgeStore() : _edges(NULL) {\n-  _edges = new EdgeHashTable(this);\n-}\n-\n-EdgeStore::~EdgeStore() {\n-  assert(_edges != NULL, \"invariant\");\n-  delete _edges;\n-}\n-\n@@ -227,1 +220,80 @@\n-\/\/ Install the immediate edge into the mark word of the leak candidate object\n+static GrowableArray<const StoredEdge*>* _leak_context_edges = nullptr;\n+\n+EdgeStore::EdgeStore() : _edges(new EdgeHashTable(this)) {}\n+\n+EdgeStore::~EdgeStore() {\n+  assert(_edges != NULL, \"invariant\");\n+  delete _edges;\n+  delete _leak_context_edges;\n+  _leak_context_edges = nullptr;\n+}\n+\n+static int leak_context_edge_idx(const ObjectSample* sample) {\n+  assert(sample != nullptr, \"invariant\");\n+  return static_cast<int>(sample->object()->mark().value()) >> markWord::lock_bits;\n+}\n+\n+bool EdgeStore::has_leak_context(const ObjectSample* sample) const {\n+  const int idx = leak_context_edge_idx(sample);\n+  if (idx == 0) {\n+    return false;\n+  }\n+  assert(idx > 0, \"invariant\");\n+  assert(_leak_context_edges != nullptr, \"invariant\");\n+  assert(idx < _leak_context_edges->length(), \"invariant\");\n+  assert(_leak_context_edges->at(idx) != nullptr, \"invariant\");\n+  return true;\n+}\n+\n+const StoredEdge* EdgeStore::get(const ObjectSample* sample) const {\n+  assert(sample != nullptr, \"invariant\");\n+  if (_leak_context_edges != nullptr) {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+    const int idx = leak_context_edge_idx(sample);\n+    if (idx > 0) {\n+      assert(idx < _leak_context_edges->length(), \"invariant\");\n+      const StoredEdge* const edge =_leak_context_edges->at(idx);\n+      assert(edge != nullptr, \"invariant\");\n+      return edge;\n+    }\n+  }\n+  return get(UnifiedOopRef::encode_in_native(sample->object_addr()));\n+}\n+\n+#ifdef ASSERT\n+\/\/ max_idx to ensure idx fit in lower 32-bits of markword together with lock bits.\n+static constexpr const int max_idx =  right_n_bits(32 - markWord::lock_bits);\n+\n+static void store_idx_precondition(oop sample_object, int idx) {\n+  assert(sample_object != NULL, \"invariant\");\n+  assert(sample_object->mark().is_marked(), \"invariant\");\n+  assert(idx > 0, \"invariant\");\n+  assert(idx <= max_idx, \"invariant\");\n+}\n+#endif\n+\n+static void store_idx_in_markword(oop sample_object, int idx) {\n+  DEBUG_ONLY(store_idx_precondition(sample_object, idx);)\n+  const markWord idx_mark_word(sample_object->mark().value() | idx << markWord::lock_bits);\n+  sample_object->set_mark(idx_mark_word);\n+  assert(sample_object->mark().is_marked(), \"must still be marked\");\n+}\n+\n+static const int initial_size = 64;\n+\n+static int save(const StoredEdge* edge) {\n+  assert(edge != nullptr, \"invariant\");\n+  if (_leak_context_edges == nullptr) {\n+    _leak_context_edges = new (ResourceObj::C_HEAP, mtTracing)GrowableArray<const StoredEdge*>(initial_size, mtTracing);\n+    _leak_context_edges->append(nullptr); \/\/ next idx now at 1, for disambiguation in markword.\n+  }\n+  return _leak_context_edges->append(edge);\n+}\n+\n+\/\/ We associate the leak context edge with the leak candidate object by saving the\n+\/\/ edge in an array and storing the array idx (shifted) into the markword of the candidate object.\n+static void associate_with_candidate(const StoredEdge* leak_context_edge) {\n+  assert(leak_context_edge != nullptr, \"invariant\");\n+  store_idx_in_markword(leak_context_edge->pointee(), save(leak_context_edge));\n+}\n+\n@@ -232,4 +304,1 @@\n-  oop sample_object = edge->pointee();\n-  assert(sample_object != NULL, \"invariant\");\n-  assert(sample_object->mark().is_marked(), \"invariant\");\n-  sample_object->set_mark(markWord::from_pointer(leak_context_edge));\n+  associate_with_candidate(leak_context_edge);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.cpp","additions":84,"deletions":15,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+class ObjectSample;\n@@ -82,0 +83,1 @@\n+  const StoredEdge* get(const ObjectSample* sample) const;\n@@ -93,0 +95,1 @@\n+  bool has_leak_context(const ObjectSample* sample) const;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-    if (!sample->object()->mark().is_marked()) {\n+    if (edge_store->has_leak_context(sample)) {\n@@ -140,12 +140,1 @@\n-  traceid gc_root_id = 0;\n-  const Edge* edge = NULL;\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    if (!sample->object()->mark().is_marked()) {\n-      edge = (const Edge*)(sample->object())->mark().to_pointer();\n-    }\n-  }\n-  if (edge == NULL) {\n-    edge = edge_store->get(UnifiedOopRef::encode_in_native(sample->object_addr()));\n-  } else {\n-    gc_root_id = edge_store->gc_root_id(edge);\n-  }\n+  const StoredEdge* const edge = edge_store->get(sample);\n@@ -153,0 +142,1 @@\n+  assert(edge->pointee() == sample->object(), \"invariant\");\n@@ -155,0 +145,1 @@\n+  const traceid gc_root_id = edge->gc_root_id();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,7 +46,0 @@\n-  if (UseCompactObjectHeaders) {\n-    \/\/ Leak profiler is broken with Lilliput, forcefully disable it.\n-    \/\/ See JDK-8275415 for more details.\n-    log_warning(jfr)(\"Leak profiler does not work with compact object headers, disabling.\");\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/leakProfiler.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-  assert(!UseCompactObjectHeaders, \"should not be here: broken with compact object headers\");\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,34 +55,0 @@\n-#\n-# JFR heap iteration is unsafe, disabled and prints warnings\n-#\n-jdk\/jfr\/event\/oldobject\/TestAllocationTime.java                                     8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestArrayInformation.java                                   8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestCircularReference.java                                  8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestClassLoaderLeak.java                                    8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestFieldInformation.java                                   8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestG1.java                                                 8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestObjectDescription.java                                  8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestHeapDeep.java                                           8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestHeapShallow.java                                        8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestLastKnownHeapUsage.java                                 8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestListenerLeak.java                                       8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestLargeRootSet.java                                       8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestMetadataRetention.java                                  8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestParallel.java                                           8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestReferenceChainLimit.java                                8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestSanityDefault.java                                      8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestSerial.java                                             8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestShenandoah.java                                         8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestThreadLocalLeak.java                                    8308296 generic-all\n-jdk\/jfr\/event\/oldobject\/TestZ.java                                                  8308296 generic-all\n-jdk\/jfr\/event\/gc\/objectcount\/TestObjectCountAfterGCEventWithG1ConcurrentMark.java   8308296 generic-all\n-jdk\/jfr\/event\/gc\/objectcount\/TestObjectCountAfterGCEventWithG1FullCollection.java   8308296 generic-all\n-jdk\/jfr\/event\/gc\/objectcount\/TestObjectCountAfterGCEventWithSerial.java             8308296 generic-all\n-jdk\/jfr\/event\/gc\/objectcount\/TestObjectCountEvent.java                              8308296 generic-all\n-jdk\/jfr\/event\/gc\/objectcount\/TestObjectCountAfterGCEventWithParallelOld.java        8308296 generic-all\n-jdk\/jfr\/jcmd\/TestJcmdDump.java                                                      8308296 generic-all\n-jdk\/jfr\/jcmd\/TestJcmdDumpPathToGCRoots.java                                         8308296 generic-all\n-jdk\/jfr\/startupargs\/TestOldObjectQueueSize.java                                     8308296 generic-all\n-jdk\/jfr\/startupargs\/TestStartupMessage.java                                         8308296 generic-all\n-\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-lilliput.txt","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"}]}