{"files":[{"patch":"@@ -85,1 +85,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -1607,2 +1607,0 @@\n-  _forwarding = new SlidingForwarding(heap_rs.region(), HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n-\n@@ -1780,0 +1778,2 @@\n+  SlidingForwarding::initialize(heap_rs.region(), HeapRegion::GrainWords);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-class SlidingForwarding;\n@@ -241,2 +240,0 @@\n-  SlidingForwarding* _forwarding;\n-\n@@ -272,4 +269,0 @@\n-  SlidingForwarding* forwarding() const {\n-    return _forwarding;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -205,0 +205,2 @@\n+  SlidingForwarding::begin();\n+\n@@ -210,0 +212,2 @@\n+\n+  SlidingForwarding::end();\n@@ -314,2 +318,0 @@\n-  _heap->forwarding()->clear();\n-\n@@ -319,1 +321,0 @@\n-  \/\/ TODO: Disabled for now because it violates sliding-forwarding assumption.\n@@ -321,3 +322,3 @@\n-  \/\/ if (!task.has_freed_regions()) {\n-  \/\/   task.prepare_serial_compaction();\n-  \/\/ }\n+  if (!task.has_freed_regions()) {\n+    task.prepare_serial_compaction();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-  const SlidingForwarding* const forwarding = G1CollectedHeap::heap()->forwarding();\n-  marker->preserved_stack()->adjust_during_full_gc(forwarding);\n+  marker->preserved_stack()->adjust_during_full_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  if (!obj->is_forwarded()) {\n+  if (!SlidingForwarding::is_forwarded(obj)) {\n@@ -69,1 +69,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(_forwarding->forwardee(obj));\n+  HeapWord* destination = cast_from_oop<HeapWord*>(SlidingForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class SlidingForwarding;\n@@ -54,1 +53,0 @@\n-    const SlidingForwarding* const _forwarding;\n@@ -57,3 +55,1 @@\n-    G1CompactRegionClosure(G1CMBitMap* bitmap) :\n-      _bitmap(bitmap),\n-      _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n+    G1CompactRegionClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-void G1FullGCCompactionPoint::forward(SlidingForwarding* const forwarding, oop object, size_t size) {\n+void G1FullGCCompactionPoint::forward(oop object, size_t size) {\n@@ -107,1 +107,1 @@\n-    forwarding->forward_to(object, cast_to_oop(_compaction_top));\n+    SlidingForwarding::forward_to(object, cast_to_oop(_compaction_top));\n@@ -109,1 +109,1 @@\n-    assert(!object->is_forwarded(), \"should not be forwarded\");\n+    assert(!SlidingForwarding::is_forwarded(object), \"should not be forwarded\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-class SlidingForwarding;\n@@ -55,1 +54,1 @@\n-  void forward(SlidingForwarding* const forwarding, oop object, size_t size);\n+  void forward(oop object, size_t size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -36,1 +35,0 @@\n-class SlidingForwarding;\n@@ -84,1 +82,0 @@\n-  const SlidingForwarding* const _forwarding;\n@@ -88,3 +85,1 @@\n-  G1AdjustClosure(G1FullCollector* collector) :\n-    _collector(collector),\n-    _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n+  G1AdjustClosure(G1FullCollector* collector) : _collector(collector) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  if (!obj->is_forwarded()) {\n+  if (!SlidingForwarding::is_forwarded(obj)) {\n@@ -94,1 +94,1 @@\n-  oop forwardee = _forwarding->forwardee(obj);\n+  oop forwardee = SlidingForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-    _cp(cp), _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n+    _cp(cp) { }\n@@ -165,1 +165,1 @@\n-  _cp->forward(_forwarding, object, size);\n+  _cp->forward(object, size);\n@@ -170,1 +170,0 @@\n-  ShouldNotReachHere();\n@@ -173,4 +172,6 @@\n-  \/*\n-  oop forwarded_to = obj->forwardee();\n-  if (forwarded_to != NULL && !_current->is_in(forwarded_to)) {\n-    return obj->size();\n+  if (SlidingForwarding::is_forwarded(obj)) {\n+    oop forwarded_to = SlidingForwarding::forwardee(obj);\n+    assert(forwarded_to != NULL, \"must have forwardee\");\n+    if (!_current->is_in(forwarded_to)) {\n+      return obj->size();\n+    }\n@@ -178,1 +179,0 @@\n-\n@@ -181,1 +181,1 @@\n-  _cp->forward(_forwarding, obj, size);\n+  _cp->forward(obj, size);\n@@ -184,2 +184,0 @@\n-  *\/\n-  return 0;\n@@ -206,2 +204,1 @@\n-  ShouldNotReachHere(); \/\/ Disabled in Lilliput.\n-  \/\/ GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare Serial Compaction\", collector()->scope()->timer());\n+  GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare Serial Compaction\", collector()->scope()->timer());\n@@ -212,1 +209,0 @@\n-  \/*\n@@ -219,1 +215,0 @@\n-  *\/\n@@ -223,1 +218,0 @@\n-  \/*\n@@ -239,1 +233,0 @@\n-  *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-class SlidingForwarding;\n@@ -80,1 +79,0 @@\n-    SlidingForwarding* const _forwarding;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -683,1 +683,1 @@\n-  \/\/_preserved_marks_set.get()->push_if_necessary(old, old->mark());\n+  _preserved_marks_set.get()->push_if_necessary(old, old->mark());\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -96,0 +97,2 @@\n+  SlidingForwarding::begin();\n+\n@@ -114,0 +117,2 @@\n+  SlidingForwarding::end();\n+\n@@ -274,2 +279,0 @@\n-  AdjustPointerClosure adjust_pointer_closure(gch->forwarding());\n-  CLDToOopClosure adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_strong);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -66,0 +65,1 @@\n+CLDToOopClosure    MarkSweep::adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_strong);\n@@ -147,2 +147,2 @@\n-void PreservedMark::adjust_pointer(const SlidingForwarding* const forwarding) {\n-  MarkSweep::adjust_pointer(forwarding, &_obj);\n+void PreservedMark::adjust_pointer() {\n+  MarkSweep::adjust_pointer(&_obj);\n@@ -176,2 +176,1 @@\n-void MarkSweep::adjust_marks() {\n-  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n+AdjustPointerClosure MarkSweep::adjust_pointer_closure;\n@@ -179,0 +178,1 @@\n+void MarkSweep::adjust_marks() {\n@@ -184,1 +184,1 @@\n-    _preserved_marks[i].adjust_pointer(forwarding);\n+    _preserved_marks[i].adjust_pointer();\n@@ -191,1 +191,1 @@\n-    adjust_pointer(forwarding, p);\n+    adjust_pointer(p);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-class SlidingForwarding;\n@@ -128,0 +127,2 @@\n+  static AdjustPointerClosure adjust_pointer_closure;\n+  static CLDToOopClosure      adjust_cld_closure;\n@@ -144,1 +145,1 @@\n-  static int adjust_pointers(const SlidingForwarding* const forwarding, oop obj);\n+  static int adjust_pointers(oop obj);\n@@ -152,1 +153,1 @@\n-  template <class T> static inline void adjust_pointer(const SlidingForwarding* const forwarding, T* p);\n+  template <class T> static inline void adjust_pointer(T* p);\n@@ -188,2 +189,0 @@\n-private:\n-  const SlidingForwarding* const _forwarding;\n@@ -191,1 +190,0 @@\n-  AdjustPointerClosure(const SlidingForwarding* forwarding) : _forwarding(forwarding) {}\n@@ -209,1 +207,1 @@\n-  void adjust_pointer(const SlidingForwarding* const forwarding);\n+  void adjust_pointer();\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -90,1 +90,1 @@\n-template <class T> inline void MarkSweep::adjust_pointer(const SlidingForwarding* const forwarding, T* p) {\n+template <class T> inline void MarkSweep::adjust_pointer(T* p) {\n@@ -96,3 +96,2 @@\n-    markWord header = obj->mark();\n-    if (header.is_marked()) {\n-      oop new_obj = forwarding->forwardee(obj);\n+    if (SlidingForwarding::is_forwarded(obj)) {\n+      oop new_obj = SlidingForwarding::forwardee(obj);\n@@ -107,1 +106,1 @@\n-void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(_forwarding, p); }\n+void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(p); }\n@@ -112,3 +111,2 @@\n-inline int MarkSweep::adjust_pointers(const SlidingForwarding* const forwarding, oop obj) {\n-  AdjustPointerClosure cl(forwarding);\n-  return obj->oop_iterate_size(&cl);\n+inline int MarkSweep::adjust_pointers(oop obj) {\n+  return obj->oop_iterate_size(&MarkSweep::adjust_pointer_closure);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -692,1 +692,4 @@\n-          range(0, max_juint)\n+          range(0, max_juint)                                               \\\n+                                                                            \\\n+  product(bool, UseAltGCForwarding, false, EXPERIMENTAL,                    \\\n+          \"Use alternative GC forwarding that preserves object headers\")    \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-  _forwarding = new SlidingForwarding(_reserved);\n@@ -142,0 +141,2 @@\n+  SlidingForwarding::initialize(_reserved, SpaceAlignment \/ HeapWordSize);\n+\n@@ -1117,1 +1118,0 @@\n-  _forwarding->clear();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-class SlidingForwarding;\n@@ -92,2 +91,0 @@\n-  SlidingForwarding* _forwarding;\n-\n@@ -337,4 +334,0 @@\n-  SlidingForwarding* forwarding() const {\n-    return _forwarding;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-\/\/ TODO: This method is unused, except in the gunit test. Change the test\n-\/\/ to exercise the updated method below instead, and remove this one.\n@@ -51,14 +49,2 @@\n-    if (obj->is_forwarded()) {\n-      elem->set_oop(obj->forwardee());\n-    }\n-  }\n-}\n-\n-void PreservedMarks::adjust_during_full_gc(const SlidingForwarding* const forwarding) {\n-  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n-  while (!iter.is_empty()) {\n-    OopAndMarkWord* elem = iter.next_addr();\n-\n-    oop obj = elem->get_oop();\n-    if (obj->is_forwarded()) {\n-      elem->set_oop(forwarding->forwardee(obj));\n+    if (SlidingForwarding::is_forwarded(obj)) {\n+      elem->set_oop(SlidingForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class SlidingForwarding;\n@@ -67,2 +66,0 @@\n-  \/\/ TODO: This method is unused, except in the gunit test. Change the test\n-  \/\/ to exercise the updated method below instead, and remove this one.\n@@ -71,2 +68,0 @@\n-  void adjust_during_full_gc(const SlidingForwarding* const forwarding);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -26,0 +27,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -27,0 +29,3 @@\n+#include \"utilities\/fastHash.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -28,1 +33,2 @@\n-#ifdef _LP64\n+\/\/ We cannot use 0, because that may already be a valid base address in zero-based heaps.\n+\/\/ 0x1 is safe because heap base addresses must be aligned by much larger alignment\n@@ -30,1 +36,0 @@\n-#endif\n@@ -32,1 +37,11 @@\n-SlidingForwarding::SlidingForwarding(MemRegion heap)\n+HeapWord* SlidingForwarding::_heap_start = nullptr;\n+size_t SlidingForwarding::_region_size_words = 0;\n+size_t SlidingForwarding::_heap_start_region_bias = 0;\n+size_t SlidingForwarding::_num_regions = 0;\n+uint SlidingForwarding::_region_size_bytes_shift = 0;\n+uintptr_t SlidingForwarding::_region_mask = 0;\n+HeapWord** SlidingForwarding::_biased_bases[SlidingForwarding::NUM_TARGET_REGIONS] = { nullptr, nullptr };\n+HeapWord** SlidingForwarding::_bases_table = nullptr;\n+SlidingForwarding::FallbackTable* SlidingForwarding::_fallback_table = nullptr;\n+\n+void SlidingForwarding::initialize(MemRegion heap, size_t region_size_words) {\n@@ -34,7 +49,27 @@\n-        : _heap_start(heap.start()),\n-          _num_regions(((heap.end() - heap.start()) >> NUM_COMPRESSED_BITS) + 1),\n-          _region_size_words_shift(NUM_COMPRESSED_BITS),\n-          _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * 2, mtGC)) {\n-  assert(_region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n-#else\n-  {\n+  if (UseAltGCForwarding) {\n+    _heap_start = heap.start();\n+\n+    \/\/ If the heap is small enough to fit directly into the available offset bits,\n+    \/\/ and we are running Serial GC, we can treat the whole heap as a single region\n+    \/\/ if it happens to be aligned to allow biasing.\n+    size_t rounded_heap_size = round_up_power_of_2(heap.byte_size());\n+\n+    if (UseSerialGC && (heap.word_size() <= (1 << NUM_OFFSET_BITS)) &&\n+        is_aligned((uintptr_t)_heap_start, rounded_heap_size)) {\n+      _num_regions = 1;\n+      _region_size_words = heap.word_size();\n+      _region_size_bytes_shift = log2i_exact(rounded_heap_size);\n+    } else {\n+      _num_regions = align_up(pointer_delta(heap.end(), heap.start()), region_size_words) \/ region_size_words;\n+      _region_size_words = region_size_words;\n+      _region_size_bytes_shift = log2i_exact(_region_size_words) + LogHeapWordSize;\n+    }\n+    _heap_start_region_bias = (uintptr_t)_heap_start >> _region_size_bytes_shift;\n+    _region_mask = ~((uintptr_t(1) << _region_size_bytes_shift) - 1);\n+\n+    guarantee((_heap_start_region_bias << _region_size_bytes_shift) == (uintptr_t)_heap_start, \"must be aligned: _heap_start_region_bias: \" SIZE_FORMAT \", _region_size_byte_shift: %u, _heap_start: \" PTR_FORMAT, _heap_start_region_bias, _region_size_bytes_shift, p2i(_heap_start));\n+\n+    assert(_region_size_words >= 1, \"regions must be at least a word large\");\n+    assert(_bases_table == nullptr, \"should not be initialized yet\");\n+    assert(_fallback_table == nullptr, \"should not be initialized yet\");\n+  }\n@@ -44,1 +79,1 @@\n-SlidingForwarding::SlidingForwarding(MemRegion heap, size_t region_size_words_shift)\n+void SlidingForwarding::begin() {\n@@ -46,7 +81,13 @@\n-        : _heap_start(heap.start()),\n-          _num_regions(((heap.end() - heap.start()) >> region_size_words_shift) + 1),\n-          _region_size_words_shift(region_size_words_shift),\n-          _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * (ONE << NUM_REGION_BITS), mtGC)) {\n-  assert(region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n-#else\n-  {\n+  if (UseAltGCForwarding) {\n+    assert(_bases_table == nullptr, \"should not be initialized yet\");\n+    assert(_fallback_table == nullptr, \"should not be initialized yet\");\n+\n+    size_t max = _num_regions * NUM_TARGET_REGIONS;\n+    _bases_table = NEW_C_HEAP_ARRAY(HeapWord*, max, mtGC);\n+    HeapWord** biased_start = _bases_table - _heap_start_region_bias;\n+    _biased_bases[0] = biased_start;\n+    _biased_bases[1] = biased_start + _num_regions;\n+    for (size_t i = 0; i < max; i++) {\n+      _bases_table[i] = UNUSED_BASE;\n+    }\n+  }\n@@ -56,1 +97,1 @@\n-SlidingForwarding::~SlidingForwarding() {\n+void SlidingForwarding::end() {\n@@ -58,1 +99,7 @@\n-  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n+  if (UseAltGCForwarding) {\n+    assert(_bases_table != nullptr, \"should be initialized\");\n+    FREE_C_HEAP_ARRAY(HeapWord*, _bases_table);\n+    _bases_table = nullptr;\n+    delete _fallback_table;\n+    _fallback_table = nullptr;\n+  }\n@@ -62,5 +109,44 @@\n-void SlidingForwarding::clear() {\n-#ifdef _LP64\n-  size_t max = _num_regions * (ONE << NUM_REGION_BITS);\n-  for (size_t i = 0; i < max; i++) {\n-    _target_base_table[i] = UNUSED_BASE;\n+void SlidingForwarding::fallback_forward_to(HeapWord* from, HeapWord* to) {\n+  if (_fallback_table == nullptr) {\n+    _fallback_table = new FallbackTable();\n+  }\n+  _fallback_table->forward_to(from, to);\n+}\n+\n+HeapWord* SlidingForwarding::fallback_forwardee(HeapWord* from) {\n+  assert(_fallback_table != nullptr, \"fallback table must be present\");\n+  return _fallback_table->forwardee(from);\n+}\n+\n+SlidingForwarding::FallbackTable::FallbackTable() {\n+  for (uint i = 0; i < TABLE_SIZE; i++) {\n+    _table[i]._next = nullptr;\n+    _table[i]._from = nullptr;\n+    _table[i]._to   = nullptr;\n+  }\n+}\n+\n+SlidingForwarding::FallbackTable::~FallbackTable() {\n+  for (uint i = 0; i < TABLE_SIZE; i++) {\n+    FallbackTableEntry* entry = _table[i]._next;\n+    while (entry != nullptr) {\n+      FallbackTableEntry* next = entry->_next;\n+      FREE_C_HEAP_OBJ(entry);\n+      entry = next;\n+    }\n+  }\n+}\n+\n+size_t SlidingForwarding::FallbackTable::home_index(HeapWord* from) {\n+  uint64_t val = reinterpret_cast<uint64_t>(from);\n+  uint64_t hash = FastHash::get_hash64(val, UCONST64(0xAAAAAAAAAAAAAAAA));\n+  return hash >> (64 - log2i_exact(TABLE_SIZE));\n+}\n+\n+void SlidingForwarding::FallbackTable::forward_to(HeapWord* from, HeapWord* to) {\n+  size_t idx = home_index(from);\n+  FallbackTableEntry* head = &_table[idx];\n+#ifdef ASSERT\n+  \/\/ Search existing entry in chain starting at idx.\n+  for (FallbackTableEntry* entry = head; entry != nullptr; entry = entry->_next) {\n+    assert(entry->_from != from, \"Don't re-forward entries into the fallback-table\");\n@@ -69,0 +155,18 @@\n+  \/\/ No entry found, create new one and insert after head.\n+  FallbackTableEntry* new_entry = NEW_C_HEAP_OBJ(FallbackTableEntry, mtGC);\n+  *new_entry = *head;\n+  head->_next = new_entry;\n+  head->_from = from;\n+  head->_to   = to;\n+}\n+\n+HeapWord* SlidingForwarding::FallbackTable::forwardee(HeapWord* from) const {\n+  size_t idx = home_index(from);\n+  const FallbackTableEntry* entry = &_table[idx];\n+  while (entry != nullptr) {\n+    if (entry->_from == from) {\n+      return entry->_to;\n+    }\n+    entry = entry->_next;\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":129,"deletions":25,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -34,3 +36,6 @@\n- * that has been specifically designed for sliding compaction GCs.\n- * It avoids overriding the compressed class pointer in the upper bits of the header, which would otherwise\n- * be lost. SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n+ * that has been specifically designed for sliding compaction GCs and compact object headers. With compact object\n+ * headers, we store the compressed class pointer in the header, which would be overwritten by full forwarding\n+ * pointer, if we allow the legacy forwarding code to act. This would lose the class information for the object,\n+ * which is required later in GC cycle to iterate the reference fields and get the object size for copying.\n+ *\n+ * SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n@@ -39,4 +44,11 @@\n- * We divide the heap into number of logical regions. Each region spans maximum of 2^NUM_BITS words.\n- * We take advantage of the fact that sliding compaction can forward objects from one region to a maximum of\n- * two regions (including itself, but that does not really matter). We need 1 bit to indicate which region is forwarded\n- * into. We also currently require the two lowest header bits to indicate that the object is forwarded.\n+ * We divide the heap into number of logical regions. Each region spans maximum of 2^NUM_OFFSET_BITS words.\n+ *\n+ * The key advantage of sliding compaction for encoding efficiency: it can forward objects from one region to a\n+ * maximum of two regions. This is an intuitive property: when we slide the compact region full of data, it can\n+ * only span two adjacent regions. This property allows us to use the off-side table to record the addresses of\n+ * two target regions. The table holds N*2 entries for N logical regions. For each region, it gives the base\n+ * address of the two target regions, or a special placeholder if not used. A single bit in forwarding would\n+ * indicate to which of the two \"to\" regions the object is forwarded into.\n+ *\n+ * This encoding efficiency allows to store the forwarding information in the object header _together_ with the\n+ * compressed class pointer.\n@@ -44,2 +56,1 @@\n- * For addressing, we need a table with N*2 entries, for N logical regions. For each region, it gives the base\n- * address of the two target regions, or a special placeholder if not used.\n+ * When recording the sliding forwarding, the mark word would look roughly like this:\n@@ -47,11 +58,8 @@\n- * Adding a forwarding then works as follows:\n- * Given an original address 'orig', and a 'target' address:\n- * - Look-up first target base of region of orig. If not yet used,\n- *   establish it to be the base of region of target address. Use that base in step 3.\n- * - Else, if first target base is already used, check second target base. This must either be unused, or the\n- *   base of the region of our target address. If unused, establish it to be the base of the region of our target\n- *   address. Use that base for next step.\n- * - Now we found a base address. Encode the target address with that base into lowest NUM_BITS bits, and shift\n- *   that up by 3 bits. Set the 3rd bit if we used the secondary target base, otherwise leave it at 0. Set the\n- *   lowest two bits to indicate that the object has been forwarded. Store that in the lowest NUM_BITS+3 bits of the\n- *   original object's header.\n+ *   64                              32                                0\n+ *    [................................OOOOOOOOOOOOOOOOOOOOOOOOOOOOAFTT]\n+ *                                                                    ^----- normal lock bits, would record \"object is forwarded\"\n+ *                                                                  ^------- fallback bit (explained below)\n+ *                                                                 ^-------- alternate region select\n+ *                                     ^------------------------------------ in-region offset\n+ *     ^-------------------------------------------------------------------- protected area, *not touched* by this code, useful for\n+ *                                                                           compressed class pointer with compact object headers\n@@ -59,5 +67,20 @@\n- * Similarily, looking up the target address, given an original object address works as follows:\n- * - Load lowest NUM_BITS + 3 from original object header. Extract target region bit and compressed address bits.\n- * - Depending on target region bit, load base address from the target base table by looking up the corresponding entry\n- *   for the region of the original object.\n- * - Decode the target address by using the target base address and the compressed address bits.\n+ * Adding a forwarding then generally works as follows:\n+ *   1. Compute the \"to\" offset in the \"to\" region, this gives \"offset\".\n+ *   2. Check if the primary \"from\" offset at base table contains \"to\" region base, use it.\n+ *      If not usable, continue to next step. If usable, set \"alternate\" = \"false\" and jump to (4).\n+ *   3. Check if the alternate \"from\" offset at base table contains \"to\" region base, use it.\n+ *      This gives us \"alternate\" = \"true\". This should always complete for sliding forwarding.\n+ *   4. Compute the mark word from \"offset\" and \"alternate\", write it out\n+ *\n+ * Similarly, looking up the target address, given an original object address generally works as follows:\n+ *   1. Load the mark from object, and decode \"offset\" and \"alternate\" from there\n+ *   2. Compute the \"from\" base offset from the object\n+ *   3. Look up \"to\" region base from the base table either at primary or alternate indices, using \"alternate\" flag\n+ *   4. Compute the \"to\" address from \"to\" region base and \"offset\"\n+ *\n+ * This algorithm is broken by G1 last-ditch serial compaction: there, object from a single region can be\n+ * forwarded to multiple, more than two regions. To deal with that, we initialize a fallback-hashtable for\n+ * storing those extra forwardings, and set another bit in the header to indicate that the forwardee is not\n+ * encoded but should be looked-up in the hashtable. G1 serial compaction is not very common - it is the\n+ * last-last-ditch GC that is used when the JVM is scrambling to squeeze more space out of the heap, and at\n+ * that point, ultimate performance is no longer the main concern.\n@@ -65,3 +88,1 @@\n-\n-class SlidingForwarding : public CHeapObj<mtGC> {\n-#ifdef _LP64\n+class SlidingForwarding : public AllStatic {\n@@ -69,1 +90,0 @@\n-  static const int NUM_REGION_BITS = 1;\n@@ -71,3 +91,55 @@\n-  static const uintptr_t ONE = 1ULL;\n-\n-  static const size_t NUM_REGIONS = ONE << NUM_REGION_BITS;\n+  \/*\n+   * A simple hash-table that acts as fallback for the sliding forwarding.\n+   * This is used in the case of G1 serial compaction, which violates the\n+   * assumption of sliding forwarding that each object of any region is only\n+   * ever forwarded to one of two target regions. At this point, the GC is\n+   * scrambling to free up more Java heap memory, and therefore performance\n+   * is not the major concern.\n+   *\n+   * The implementation is a straightforward open hashtable.\n+   * It is a single-threaded (not thread-safe) implementation, and that\n+   * is sufficient because G1 serial compaction is single-threaded.\n+   *\/\n+  class FallbackTable : public CHeapObj<mtGC>{\n+  private:\n+    struct FallbackTableEntry {\n+      FallbackTableEntry* _next;\n+      HeapWord* _from;\n+      HeapWord* _to;\n+    };\n+\n+    static const uint TABLE_SIZE = 1024;\n+    FallbackTableEntry _table[TABLE_SIZE];\n+\n+    static size_t home_index(HeapWord* from);\n+\n+  public:\n+    FallbackTable();\n+    ~FallbackTable();\n+\n+    void forward_to(HeapWord* from, HeapWord* to);\n+    HeapWord* forwardee(HeapWord* from) const;\n+  };\n+\n+  static const uintptr_t MARK_LOWER_HALF_MASK = right_n_bits(32);\n+\n+  \/\/ We need the lowest two bits to indicate a forwarded object.\n+  \/\/ The next bit indicates that the forwardee should be looked-up in a fallback-table.\n+  static const int FALLBACK_SHIFT = markWord::lock_bits;\n+  static const int FALLBACK_BITS = 1;\n+  static const int FALLBACK_MASK = right_n_bits(FALLBACK_BITS) << FALLBACK_SHIFT;\n+\n+  \/\/ Next bit selects the target region\n+  static const int ALT_REGION_SHIFT = FALLBACK_SHIFT + FALLBACK_BITS;\n+  static const int ALT_REGION_BITS = 1;\n+  \/\/ This will be \"2\" always, but expose it as named constant for clarity\n+  static const size_t NUM_TARGET_REGIONS = 1 << ALT_REGION_BITS;\n+\n+  \/\/ The offset bits start then\n+  static const int OFFSET_BITS_SHIFT = ALT_REGION_SHIFT + ALT_REGION_BITS;\n+\n+  \/\/ How many bits we use for the offset\n+  static const int NUM_OFFSET_BITS = 32 - OFFSET_BITS_SHIFT;\n+\n+  \/\/ Indicates an unused base address in the target base table.\n+  static HeapWord* const UNUSED_BASE;\n@@ -75,2 +147,2 @@\n-  \/\/ We need the lowest three bits to indicate a forwarded object and self-forwarding.\n-  static const int BASE_SHIFT = 3;\n+  static HeapWord*      _heap_start;\n+  static size_t         _region_size_words;\n@@ -78,2 +150,4 @@\n-  \/\/ The compressed address bits start here.\n-  static const int COMPRESSED_BITS_SHIFT = BASE_SHIFT + NUM_REGION_BITS;\n+  static size_t         _heap_start_region_bias;\n+  static size_t         _num_regions;\n+  static uint           _region_size_bytes_shift;\n+  static uintptr_t      _region_mask;\n@@ -81,3 +155,4 @@\n-  \/\/ How many bits we use for the compressed pointer (we are going to need one more bit to indicate target region, and\n-  \/\/ two lowest bits to mark objects as forwarded)\n-  static const int NUM_COMPRESSED_BITS = 32 - BASE_SHIFT - NUM_REGION_BITS;\n+  \/\/ The target base table memory.\n+  static HeapWord**     _bases_table;\n+  \/\/ Entries into the target base tables, biased to the start of the heap.\n+  static HeapWord**     _biased_bases[NUM_TARGET_REGIONS];\n@@ -85,3 +160,1 @@\n-  \/\/ Indicates an usused base address in the target base table. We cannot use 0, because that may already be\n-  \/\/ a valid base address in zero-based heaps. 0x1 is safe because heap base addresses must be aligned by 2^X.\n-  static HeapWord* const UNUSED_BASE;\n+  static FallbackTable* _fallback_table;\n@@ -89,4 +162,1 @@\n-  HeapWord*  const _heap_start;\n-  size_t     const _num_regions;\n-  size_t     const _region_size_words_shift;\n-  HeapWord** const _target_base_table;\n+  static inline size_t biased_region_index_containing(HeapWord* addr);\n@@ -94,2 +164,2 @@\n-  inline size_t region_index_containing(HeapWord* addr) const;\n-  inline bool region_contains(HeapWord* region_base, HeapWord* addr) const;\n+  static inline uintptr_t encode_forwarding(HeapWord* from, HeapWord* to);\n+  static inline HeapWord* decode_forwarding(HeapWord* from, uintptr_t encoded);\n@@ -97,2 +167,2 @@\n-  inline uintptr_t encode_forwarding(HeapWord* original, HeapWord* target);\n-  inline HeapWord* decode_forwarding(HeapWord* original, uintptr_t encoded) const;\n+  static void fallback_forward_to(HeapWord* from, HeapWord* to);\n+  static HeapWord* fallback_forwardee(HeapWord* from);\n@@ -100,1 +170,2 @@\n-#endif\n+  static inline void forward_to_impl(oop from, oop to);\n+  static inline oop forwardee_impl(oop from);\n@@ -103,3 +174,7 @@\n-  SlidingForwarding(MemRegion heap);\n-  SlidingForwarding(MemRegion heap, size_t num_regions);\n-  ~SlidingForwarding();\n+  static void initialize(MemRegion heap, size_t region_size_words);\n+\n+  static void begin();\n+  static void end();\n+\n+  static inline bool is_forwarded(oop obj);\n+  static inline bool is_not_forwarded(oop obj);\n@@ -107,3 +182,2 @@\n-  void clear();\n-  inline void forward_to(oop original, oop target);\n-  inline oop forwardee(oop original) const;\n+  static inline void forward_to(oop from, oop to);\n+  static inline oop forwardee(oop from);\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":131,"deletions":57,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -27,0 +28,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -31,6 +34,2 @@\n-#ifdef _LP64\n-size_t SlidingForwarding::region_index_containing(HeapWord* addr) const {\n-  assert(addr >= _heap_start, \"sanity: addr: \" PTR_FORMAT \" heap base: \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n-  size_t index = ((size_t) (addr - _heap_start)) >> _region_size_words_shift;\n-  assert(index < _num_regions, \"Region index is in bounds: \" PTR_FORMAT, p2i(addr));\n-  return index;\n+inline bool SlidingForwarding::is_forwarded(oop obj) {\n+  return obj->is_forwarded();\n@@ -39,2 +38,2 @@\n-bool SlidingForwarding::region_contains(HeapWord* region_base, HeapWord* addr) const {\n-  return uintptr_t(addr - region_base) < (ONE << _region_size_words_shift);\n+inline bool SlidingForwarding::is_not_forwarded(oop obj) {\n+  return !obj->is_forwarded();\n@@ -43,0 +42,3 @@\n+size_t SlidingForwarding::biased_region_index_containing(HeapWord* addr) {\n+  return (uintptr_t)addr >> _region_size_bytes_shift;\n+}\n@@ -44,20 +46,28 @@\n-uintptr_t SlidingForwarding::encode_forwarding(HeapWord* original, HeapWord* target) {\n-  size_t orig_idx = region_index_containing(original);\n-  size_t base_table_idx = orig_idx * 2;\n-  size_t target_idx = region_index_containing(target);\n-  HeapWord* encode_base;\n-  uintptr_t region_idx;\n-  for (region_idx = 0; region_idx < NUM_REGIONS; region_idx++) {\n-    encode_base = _target_base_table[base_table_idx + region_idx];\n-    if (encode_base == UNUSED_BASE) {\n-      encode_base = _heap_start + target_idx * (ONE << _region_size_words_shift);\n-      _target_base_table[base_table_idx + region_idx] = encode_base;\n-      break;\n-    } else if (region_contains(encode_base, target)) {\n-      break;\n-    }\n-  }\n-  if (region_idx >= NUM_REGIONS) {\n-    tty->print_cr(\"target: \" PTR_FORMAT, p2i(target));\n-    for (region_idx = 0; region_idx < NUM_REGIONS; region_idx++) {\n-      tty->print_cr(\"region_idx: \" INTPTR_FORMAT \", encode_base: \" PTR_FORMAT, region_idx, p2i(_target_base_table[base_table_idx + region_idx]));\n+uintptr_t SlidingForwarding::encode_forwarding(HeapWord* from, HeapWord* to) {\n+  static_assert(NUM_TARGET_REGIONS == 2, \"Only implemented for this amount\");\n+\n+  size_t from_reg_idx = biased_region_index_containing(from);\n+  HeapWord* to_region_base = (HeapWord*)((uintptr_t)to & _region_mask);\n+\n+  HeapWord** base = &_biased_bases[0][from_reg_idx];\n+  uintptr_t alternate = 0;\n+  if (*base == to_region_base) {\n+    \/\/ Primary is good\n+  } else if (*base == UNUSED_BASE) {\n+    \/\/ Primary is free\n+    *base = to_region_base;\n+  } else {\n+    base = &_biased_bases[1][from_reg_idx];\n+    if (*base == to_region_base) {\n+      \/\/ Alternate is good\n+    } else if (*base == UNUSED_BASE) {\n+      \/\/ Alternate is free\n+      *base = to_region_base;\n+    } else {\n+      \/\/ Both primary and alternate are not fitting\n+      \/\/ This happens only in the following rare situations:\n+      \/\/ - In Serial GC, sometimes when compact-top switches spaces, because the\n+      \/\/   region boudaries are virtual and objects can cross regions\n+      \/\/ - In G1 serial compaction, because tails of various compaction chains\n+      \/\/   are distributed across the remainders of already compacted regions.\n+      return (1 << FALLBACK_SHIFT) | markWord::marked_value;\n@@ -65,0 +75,1 @@\n+    alternate = 1;\n@@ -66,7 +77,12 @@\n-  assert(region_idx < NUM_REGIONS, \"need to have found an encoding base\");\n-  assert(target >= encode_base, \"target must be above encode base, target:\" PTR_FORMAT \", encoded_base: \" PTR_FORMAT \",  target_idx: \" SIZE_FORMAT \", heap start: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT,\n-         p2i(target), p2i(encode_base), target_idx, p2i(_heap_start), region_idx);\n-  assert(region_contains(encode_base, target), \"region must contain target: original: \" PTR_FORMAT \", target: \" PTR_FORMAT \", encode_base: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT, p2i(original), p2i(target), p2i(encode_base), region_idx);\n-  uintptr_t encoded = (((uintptr_t)(target - encode_base)) << COMPRESSED_BITS_SHIFT) |\n-                      (region_idx << BASE_SHIFT) | markWord::marked_value;\n-  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n+\n+  size_t offset = pointer_delta(to, to_region_base);\n+  assert(offset < _region_size_words, \"Offset should be within the region. from: \" PTR_FORMAT\n+         \", to: \" PTR_FORMAT \", to_region_base: \" PTR_FORMAT \", offset: \" SIZE_FORMAT,\n+         p2i(from), p2i(to), p2i(to_region_base), offset);\n+\n+  uintptr_t encoded = (offset << OFFSET_BITS_SHIFT) |\n+                      (alternate << ALT_REGION_SHIFT) |\n+                      markWord::marked_value;\n+\n+  assert(to == decode_forwarding(from, encoded), \"must be reversible\");\n+  assert((encoded & ~MARK_LOWER_HALF_MASK) == 0, \"must encode to lowest 32 bits\");\n@@ -76,7 +92,16 @@\n-HeapWord* SlidingForwarding::decode_forwarding(HeapWord* original, uintptr_t encoded) const {\n-  assert((encoded & markWord::marked_value) == markWord::marked_value, \"must be marked as forwarded\");\n-  size_t orig_idx = region_index_containing(original);\n-  size_t region_idx = (encoded >> BASE_SHIFT) & right_n_bits(NUM_REGION_BITS);\n-  size_t base_table_idx = orig_idx * 2 + region_idx;\n-  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n-  assert(decoded >= _heap_start, \"must be above heap start, encoded: \" INTPTR_FORMAT \", region_idx: \" SIZE_FORMAT \", base: \" PTR_FORMAT, encoded, region_idx, p2i(_target_base_table[base_table_idx]));\n+HeapWord* SlidingForwarding::decode_forwarding(HeapWord* from, uintptr_t encoded) {\n+  assert((encoded & markWord::lock_mask_in_place) == markWord::marked_value, \"must be marked as forwarded\");\n+  assert((encoded & FALLBACK_MASK) == 0, \"must not be fallback-forwarded\");\n+  assert((encoded & ~MARK_LOWER_HALF_MASK) == 0, \"must decode from lowest 32 bits\");\n+  size_t alternate = (encoded >> ALT_REGION_SHIFT) & right_n_bits(ALT_REGION_BITS);\n+  assert(alternate < NUM_TARGET_REGIONS, \"Sanity\");\n+  uintptr_t offset = (encoded >> OFFSET_BITS_SHIFT);\n+\n+  size_t from_idx = biased_region_index_containing(from);\n+  HeapWord* base = _biased_bases[alternate][from_idx];\n+  assert(base != UNUSED_BASE, \"must not be unused base\");\n+  HeapWord* decoded = base + offset;\n+  assert(decoded >= _heap_start,\n+         \"Address must be above heap start. encoded: \" INTPTR_FORMAT \", alt_region: \" SIZE_FORMAT \", base: \" PTR_FORMAT,\n+         encoded, alternate, p2i(base));\n+\n@@ -85,1 +110,0 @@\n-#endif\n@@ -87,5 +111,16 @@\n-void SlidingForwarding::forward_to(oop original, oop target) {\n-#ifdef _LP64\n-  markWord header = original->mark();\n-  if (header.has_displaced_mark_helper()) {\n-    header = header.displaced_mark_helper();\n+inline void SlidingForwarding::forward_to_impl(oop from, oop to) {\n+  assert(_bases_table != nullptr, \"call begin() before forwarding\");\n+\n+  markWord from_header = from->mark();\n+  if (from_header.has_displaced_mark_helper()) {\n+    from_header = from_header.displaced_mark_helper();\n+  }\n+\n+  HeapWord* from_hw = cast_from_oop<HeapWord*>(from);\n+  HeapWord* to_hw   = cast_from_oop<HeapWord*>(to);\n+  uintptr_t encoded = encode_forwarding(from_hw, to_hw);\n+  markWord new_header = markWord((from_header.value() & ~MARK_LOWER_HALF_MASK) | encoded);\n+  from->set_mark(new_header);\n+\n+  if ((encoded & FALLBACK_MASK) != 0) {\n+    fallback_forward_to(from_hw, to_hw);\n@@ -93,6 +128,9 @@\n-  uintptr_t encoded = encode_forwarding(cast_from_oop<HeapWord*>(original), cast_from_oop<HeapWord*>(target));\n-  assert((encoded & markWord::klass_mask_in_place) == 0, \"encoded forwardee must not overlap with Klass*: \" PTR_FORMAT, encoded);\n-  header = markWord((header.value() & markWord::klass_mask_in_place) | encoded);\n-  original->set_mark(header);\n-#else\n-  original->forward_to(target);\n+}\n+\n+inline void SlidingForwarding::forward_to(oop obj, oop fwd) {\n+#ifdef _LP64\n+  if (UseAltGCForwarding) {\n+    assert(_bases_table != nullptr, \"expect sliding forwarding initialized\");\n+    forward_to_impl(obj, fwd);\n+    assert(forwardee(obj) == fwd, \"must be forwarded to correct forwardee\");\n+  } else\n@@ -100,0 +138,17 @@\n+  {\n+    obj->forward_to(fwd);\n+  }\n+}\n+\n+inline oop SlidingForwarding::forwardee_impl(oop from) {\n+  assert(_bases_table != nullptr, \"call begin() before asking for forwarding\");\n+\n+  markWord header = from->mark();\n+  HeapWord* from_hw = cast_from_oop<HeapWord*>(from);\n+  if ((header.value() & FALLBACK_MASK) != 0) {\n+    HeapWord* to = fallback_forwardee(from_hw);\n+    return cast_to_oop(to);\n+  }\n+  uintptr_t encoded = header.value() & MARK_LOWER_HALF_MASK;\n+  HeapWord* to = decode_forwarding(from_hw, encoded);\n+  return cast_to_oop(to);\n@@ -102,1 +157,1 @@\n-oop SlidingForwarding::forwardee(oop original) const {\n+inline oop SlidingForwarding::forwardee(oop obj) {\n@@ -104,6 +159,4 @@\n-  markWord header = original->mark();\n-  uintptr_t encoded = header.value() & ~markWord::klass_mask_in_place;\n-  HeapWord* forwardee = decode_forwarding(cast_from_oop<HeapWord*>(original), encoded);\n-  return cast_to_oop(forwardee);\n-#else\n-  return original->forwardee();\n+  if (UseAltGCForwarding) {\n+    assert(_bases_table != nullptr, \"expect sliding forwarding initialized\");\n+    return forwardee_impl(obj);\n+  } else\n@@ -111,0 +164,3 @@\n+  {\n+    return obj->forwardee();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":117,"deletions":61,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-                                    CompactPoint* cp, HeapWord* compact_top, SlidingForwarding* const forwarding) {\n+                                    CompactPoint* cp, HeapWord* compact_top) {\n@@ -374,1 +374,1 @@\n-    forwarding->forward_to(q, cast_to_oop(compact_top));\n+    SlidingForwarding::forward_to(q, cast_to_oop(compact_top));\n@@ -380,1 +380,1 @@\n-    assert(!q->is_forwarded(), \"should not be forwarded\");\n+    assert(SlidingForwarding::is_not_forwarded(q), \"should not be forwarded\");\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-class SlidingForwarding;\n@@ -436,1 +435,1 @@\n-                    HeapWord* compact_top, SlidingForwarding* const forwarding);\n+                    HeapWord* compact_top);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -167,1 +166,0 @@\n-  SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -173,1 +171,1 @@\n-      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top, forwarding);\n+      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top);\n@@ -189,1 +187,1 @@\n-        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top, forwarding);\n+        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top);\n@@ -228,1 +226,0 @@\n-  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -240,1 +237,1 @@\n-      size_t size = MarkSweep::adjust_pointers(forwarding, cast_to_oop(cur_obj));\n+      size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_obj));\n@@ -322,2 +319,0 @@\n-  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n-\n@@ -337,1 +332,1 @@\n-      HeapWord* compaction_top = cast_from_oop<HeapWord*>(forwarding->forwardee(cast_to_oop(cur_obj)));\n+      HeapWord* compaction_top = cast_from_oop<HeapWord*>(SlidingForwarding::forwardee(cast_to_oop(cur_obj)));\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -192,1 +192,0 @@\n-    heap->forwarding()->clear();\n@@ -227,0 +226,2 @@\n+    SlidingForwarding::begin();\n+\n@@ -241,0 +242,1 @@\n+    SlidingForwarding::end();\n@@ -304,3 +306,2 @@\n-  PreservedMarks*    const _preserved_marks;\n-  SlidingForwarding* const _forwarding;\n-  ShenandoahHeap*    const _heap;\n+  PreservedMarks*          const _preserved_marks;\n+  ShenandoahHeap*          const _heap;\n@@ -318,1 +319,0 @@\n-    _forwarding(ShenandoahHeap::heap()->forwarding()),\n@@ -372,1 +372,1 @@\n-    _forwarding->forward_to(p, cast_to_oop(_compact_point));\n+    SlidingForwarding::forward_to(p, cast_to_oop(_compact_point));\n@@ -446,1 +446,0 @@\n-  SlidingForwarding* forwarding = heap->forwarding();\n@@ -481,1 +480,1 @@\n-        forwarding->forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n+        SlidingForwarding::forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -732,2 +731,1 @@\n-  ShenandoahHeap*           const _heap;\n-  const SlidingForwarding*  const _forwarding;\n+  ShenandoahHeap* const _heap;\n@@ -742,2 +740,2 @@\n-      if (obj->is_forwarded()) {\n-        oop forw = _forwarding->forwardee(obj);\n+      if (SlidingForwarding::is_forwarded(obj)) {\n+        oop forw = SlidingForwarding::forwardee(obj);\n@@ -752,1 +750,0 @@\n-    _forwarding(_heap->forwarding()),\n@@ -812,2 +809,1 @@\n-    const SlidingForwarding* const forwarding = ShenandoahHeap::heap()->forwarding();\n-    _preserved_marks->get(worker_id)->adjust_during_full_gc(forwarding);\n+    _preserved_marks->get(worker_id)->adjust_during_full_gc();\n@@ -843,3 +839,2 @@\n-  ShenandoahHeap*          const _heap;\n-  const SlidingForwarding* const _forwarding;\n-  uint                     const _worker_id;\n+  ShenandoahHeap* const _heap;\n+  uint            const _worker_id;\n@@ -849,1 +844,1 @@\n-    _heap(ShenandoahHeap::heap()), _forwarding(_heap->forwarding()), _worker_id(worker_id) {}\n+    _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}\n@@ -854,1 +849,1 @@\n-    if (p->is_forwarded()) {\n+    if (SlidingForwarding::is_forwarded(p)) {\n@@ -856,1 +851,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(_forwarding->forwardee(p));\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(SlidingForwarding::forwardee(p));\n@@ -951,1 +946,0 @@\n-  const SlidingForwarding* const forwarding = heap->forwarding();\n@@ -957,1 +951,1 @@\n-      if (!old_obj->is_forwarded()) {\n+      if (SlidingForwarding::is_not_forwarded(old_obj)) {\n@@ -966,1 +960,1 @@\n-      size_t new_start = heap->heap_region_index_containing(forwarding->forwardee(old_obj));\n+      size_t new_start = heap->heap_region_index_containing(SlidingForwarding::forwardee(old_obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -195,2 +195,0 @@\n-  _forwarding = new SlidingForwarding(_heap_region, ShenandoahHeapRegion::region_size_words_shift());\n-\n@@ -407,0 +405,2 @@\n+  SlidingForwarding::initialize(_heap_region, ShenandoahHeapRegion::region_size_words());\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-class SlidingForwarding;\n@@ -231,1 +230,0 @@\n-  SlidingForwarding* _forwarding;\n@@ -248,2 +246,0 @@\n-  SlidingForwarding* forwarding() const { return _forwarding; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -411,0 +412,1 @@\n+#ifdef _LP64\n@@ -412,1 +414,3 @@\n-    return mask_bits(value(), self_forwarded_mask_in_place) != 0;\n+    bool self_fwd = mask_bits(value(), self_forwarded_mask_in_place) != 0;\n+    assert(!self_fwd || UseAltGCForwarding, \"Only set self-fwd bit when using alt GC forwarding\");\n+    return self_fwd;\n@@ -416,0 +420,1 @@\n+    assert(UseAltGCForwarding, \"Only call this with alt GC forwarding\");\n@@ -418,0 +423,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -260,1 +260,0 @@\n-  inline bool cas_forward_to(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -312,0 +313,1 @@\n+  assert(p != cast_to_oop(this) || !UseAltGCForwarding, \"Must not be called with self-forwarding\");\n@@ -318,8 +320,0 @@\n-\/\/ Used by parallel scavengers\n-bool oopDesc::cas_forward_to(oop p, markWord compare, atomic_memory_order order) {\n-  verify_forwardee(p);\n-  markWord m = markWord::encode_pointer_as_mark(p);\n-  assert(m.decode_pointer() == p, \"encoding must be reversable\");\n-  return cas_set_mark(m, compare, order) == compare;\n-}\n-\n@@ -328,12 +322,12 @@\n-  verify_forwardee(this);\n-  markWord m = mark();\n-  \/\/ If mark is displaced, we need to preserve the Klass* from real header.\n-  assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n-  if (m.has_displaced_mark_helper()) {\n-    m = m.displaced_mark_helper();\n-  }\n-  m = m.set_self_forwarded();\n-  assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversable\");\n-  set_mark(m);\n-#else\n-  forward_to(oop(this));\n+  if (UseAltGCForwarding) {\n+    markWord m = mark();\n+    \/\/ If mark is displaced, we need to preserve the real header during GC.\n+    \/\/ It will be restored to the displaced header after GC.\n+    assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+    if (m.has_displaced_mark_helper()) {\n+      m = m.displaced_mark_helper();\n+    }\n+    m = m.set_self_forwarded();\n+    assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversible\");\n+    set_mark(m);\n+  } else\n@@ -341,0 +335,3 @@\n+  {\n+    forward_to(oop(this));\n+  }\n@@ -344,0 +341,1 @@\n+  assert(p != cast_to_oop(this) || !UseAltGCForwarding, \"Must not be called with self-forwarding\");\n@@ -357,18 +355,18 @@\n-  verify_forwardee(this);\n-  markWord m = compare;\n-  \/\/ If mark is displaced, we need to preserve the Klass* from real header.\n-  assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n-  if (m.has_displaced_mark_helper()) {\n-    m = m.displaced_mark_helper();\n-  }\n-  m = m.set_self_forwarded();\n-  assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversable\");\n-  markWord old_mark = cas_set_mark(m, compare, order);\n-  if (old_mark == compare) {\n-    return NULL;\n-  } else {\n-    assert(old_mark.is_marked(), \"must be marked here\");\n-    return forwardee(old_mark);\n-  }\n-#else\n-  return forward_to_atomic(oop(this), compare, order);\n+  if (UseAltGCForwarding) {\n+   markWord m = compare;\n+    \/\/ If mark is displaced, we need to preserve the real header during GC.\n+    \/\/ It will be restored to the displaced header after GC.\n+    assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+    if (m.has_displaced_mark_helper()) {\n+      m = m.displaced_mark_helper();\n+    }\n+    m = m.set_self_forwarded();\n+    assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversible\");\n+    markWord old_mark = cas_set_mark(m, compare, order);\n+    if (old_mark == compare) {\n+      return nullptr;\n+    } else {\n+      assert(old_mark.is_marked(), \"must be marked here\");\n+      return forwardee(old_mark);\n+    }\n+  } else\n@@ -376,7 +374,3 @@\n-}\n-\n-\/\/ Note that the forwardee is not the same thing as the displaced_mark.\n-\/\/ The forwardee is used when copying during scavenge and mark-sweep.\n-\/\/ It does need to clear the low two locking- and GC-related bits.\n-oop oopDesc::forwardee() const {\n-  return forwardee(mark());\n+  {\n+    return forward_to_atomic(cast_to_oop(this), compare, order);\n+  }\n@@ -386,1 +380,1 @@\n-  assert(header.is_marked(), \"must be forwarded\");\n+  assert(header.is_marked(), \"only decode when actually forwarded\");\n@@ -393,1 +387,0 @@\n-    assert(header.is_marked(), \"only decode when actually forwarded\");\n@@ -398,0 +391,7 @@\n+\/\/ Note that the forwardee is not the same thing as the displaced_mark.\n+\/\/ The forwardee is used when copying during scavenge and mark-sweep.\n+\/\/ It does need to clear the low two locking- and GC-related bits.\n+oop oopDesc::forwardee() const {\n+  return forwardee(mark());\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":47,"deletions":47,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -3171,0 +3171,3 @@\n+  if (UseCompactObjectHeaders && !UseAltGCForwarding) {\n+    FLAG_SET_DEFAULT(UseAltGCForwarding, true);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -52,1 +53,1 @@\n-  static markWord originalMark() { return markWord(markWord::unlocked_value); }\n+  static markWord originalMark() { return markWord(markWord::lock_mask_in_place); }\n@@ -69,0 +70,2 @@\n+  FlagSetting fs(UseAltGCForwarding, false);\n+\n@@ -92,3 +95,0 @@\n-  \/\/ TODO: This is the only use of PM::adjust_during_full_gc().\n-  \/\/ GCs use the variant with a forwarding structure here,\n-  \/\/ test that variant, and remove the method.\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"unittest.hpp\"\n+\n+#ifdef _LP64\n+#ifndef PRODUCT\n+\n+static uintptr_t make_mark(uintptr_t target_region, uintptr_t offset) {\n+  return (target_region) << 3 | (offset << 4) | 3 \/* forwarded *\/;\n+}\n+\n+static uintptr_t make_fallback() {\n+  return ((uintptr_t(1) << 2) \/* fallback *\/ | 3 \/* forwarded *\/);\n+}\n+\n+\/\/ Test simple forwarding within the same region.\n+TEST_VM(SlidingForwarding, simple) {\n+  FlagSetting fs(UseAltGCForwarding, true);\n+  HeapWord fakeheap[32] = { nullptr };\n+  HeapWord* heap = align_up(fakeheap, 8 * sizeof(HeapWord));\n+  oop obj1 = cast_to_oop(&heap[2]);\n+  oop obj2 = cast_to_oop(&heap[0]);\n+  SlidingForwarding::initialize(MemRegion(&heap[0], &heap[16]), 8);\n+  obj1->set_mark(markWord::prototype());\n+  SlidingForwarding::begin();\n+\n+  SlidingForwarding::forward_to(obj1, obj2);\n+  ASSERT_EQ(obj1->mark().value(), make_mark(0 \/* target_region *\/, 0 \/* offset *\/));\n+  ASSERT_EQ(SlidingForwarding::forwardee(obj1), obj2);\n+\n+  SlidingForwarding::end();\n+}\n+\n+\/\/ Test forwardings crossing 2 regions.\n+TEST_VM(SlidingForwarding, tworegions) {\n+  FlagSetting fs(UseAltGCForwarding, true);\n+  HeapWord fakeheap[32] = { nullptr };\n+  HeapWord* heap = align_up(fakeheap, 8 * sizeof(HeapWord));\n+  oop obj1 = cast_to_oop(&heap[14]);\n+  oop obj2 = cast_to_oop(&heap[2]);\n+  oop obj3 = cast_to_oop(&heap[10]);\n+  SlidingForwarding::initialize(MemRegion(&heap[0], &heap[16]), 8);\n+  obj1->set_mark(markWord::prototype());\n+  SlidingForwarding::begin();\n+\n+  SlidingForwarding::forward_to(obj1, obj2);\n+  ASSERT_EQ(obj1->mark().value(), make_mark(0 \/* target_region *\/, 2 \/* offset *\/));\n+  ASSERT_EQ(SlidingForwarding::forwardee(obj1), obj2);\n+\n+  SlidingForwarding::forward_to(obj1, obj3);\n+  ASSERT_EQ(obj1->mark().value(), make_mark(1 \/* target_region *\/, 2 \/* offset *\/));\n+  ASSERT_EQ(SlidingForwarding::forwardee(obj1), obj3);\n+\n+  SlidingForwarding::end();\n+}\n+\n+\/\/ Test fallback forwardings crossing 4 regions.\n+TEST_VM(SlidingForwarding, fallback) {\n+  FlagSetting fs(UseAltGCForwarding, true);\n+  HeapWord fakeheap[32] = { nullptr };\n+  HeapWord* heap = align_up(fakeheap, 8 * sizeof(HeapWord));\n+  oop s_obj1 = cast_to_oop(&heap[12]);\n+  oop s_obj2 = cast_to_oop(&heap[13]);\n+  oop s_obj3 = cast_to_oop(&heap[14]);\n+  oop s_obj4 = cast_to_oop(&heap[15]);\n+  oop t_obj1 = cast_to_oop(&heap[2]);\n+  oop t_obj2 = cast_to_oop(&heap[4]);\n+  oop t_obj3 = cast_to_oop(&heap[10]);\n+  oop t_obj4 = cast_to_oop(&heap[12]);\n+  SlidingForwarding::initialize(MemRegion(&heap[0], &heap[16]), 4);\n+  s_obj1->set_mark(markWord::prototype());\n+  s_obj2->set_mark(markWord::prototype());\n+  s_obj3->set_mark(markWord::prototype());\n+  s_obj4->set_mark(markWord::prototype());\n+  SlidingForwarding::begin();\n+\n+  SlidingForwarding::forward_to(s_obj1, t_obj1);\n+  ASSERT_EQ(s_obj1->mark().value(), make_mark(0 \/* target_region *\/, 2 \/* offset *\/));\n+  ASSERT_EQ(SlidingForwarding::forwardee(s_obj1), t_obj1);\n+\n+  SlidingForwarding::forward_to(s_obj2, t_obj2);\n+  ASSERT_EQ(s_obj2->mark().value(), make_mark(1 \/* target_region *\/, 0 \/* offset *\/));\n+  ASSERT_EQ(SlidingForwarding::forwardee(s_obj2), t_obj2);\n+\n+  SlidingForwarding::forward_to(s_obj3, t_obj3);\n+  ASSERT_EQ(s_obj3->mark().value(), make_fallback());\n+  ASSERT_EQ(SlidingForwarding::forwardee(s_obj3), t_obj3);\n+\n+  SlidingForwarding::forward_to(s_obj4, t_obj4);\n+  ASSERT_EQ(s_obj4->mark().value(), make_fallback());\n+  ASSERT_EQ(SlidingForwarding::forwardee(s_obj4), t_obj4);\n+\n+  SlidingForwarding::end();\n+}\n+\n+#endif \/\/ PRODUCT\n+#endif \/\/ _LP64\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_slidingForwarding.cpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @test TestSystemGCWithG1\n+ * @test id=default\n@@ -36,0 +36,11 @@\n+\n+\/*\n+ * @test id=alt-forwarding\n+ * @key stress\n+ * @bug 8190703\n+ * @library \/\n+ * @requires vm.gc.G1\n+ * @requires (vm.bits == \"64\")\n+ * @summary Stress the G1 GC full GC by allocating objects of different lifetimes concurrently with System.gc().\n+ * @run main\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:+UseAltGCForwarding -Xlog:gc*=info -Xmx512m -XX:+UseG1GC gc.stress.systemgc.TestSystemGCWithG1 270\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithG1.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @test TestSystemGCWithSerial\n+ * @test id=default\n@@ -36,0 +36,31 @@\n+\n+\/*\n+ * @test id=alt-forwarding\n+ * @key stress\n+ * @bug 8190703\n+ * @library \/\n+ * @requires vm.gc.Serial\n+ * @summary Stress the Serial GC full GC by allocating objects of different lifetimes concurrently with System.gc().\n+ * @run main\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:+UseAltGCForwarding -Xlog:gc*=info -Xmx512m -XX:+UseSerialGC gc.stress.systemgc.TestSystemGCWithSerial 270\n+ *\/\n+\n+\/*\n+ * @test id=alt-forwarding-unaligned\n+ * @key stress\n+ * @bug 8190703\n+ * @library \/\n+ * @requires vm.gc.Serial\n+ * @summary Stress the Serial GC full GC by allocating objects of different lifetimes concurrently with System.gc().\n+ * @run main\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:+UseAltGCForwarding -Xlog:gc*=info -Xmx700m -XX:+UseSerialGC gc.stress.systemgc.TestSystemGCWithSerial 270\n+ *\/\n+\n+\/*\n+ * @test id=alt-forwarding-large-heap\n+ * @key stress\n+ * @bug 8190703\n+ * @library \/\n+ * @requires vm.gc.Serial\n+ * @requires (vm.bits == \"64\") & (os.maxMemory >= 6G)\n+ * @summary Stress the Serial GC full GC by allocating objects of different lifetimes concurrently with System.gc().\n+ * @run main\/othervm\/timeout=300 -XX:+UnlockExperimentalVMOptions -XX:+UseAltGCForwarding -Xlog:gc*=info -Xmx6g -XX:+UseSerialGC gc.stress.systemgc.TestSystemGCWithSerial 270\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithSerial.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -44,0 +44,17 @@\n+\/*\n+ * @test id=alt-forwarding\n+ * @key stress\n+ * @library \/\n+ * @requires vm.gc.Shenandoah\n+ * @summary Stress the Shenandoah GC full GC by allocating objects of different lifetimes concurrently with System.gc().\n+ *\n+ * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC -XX:+UseAltGCForwarding\n+ *      -XX:+ShenandoahVerify\n+ *      gc.stress.systemgc.TestSystemGCWithShenandoah 270\n+ *\n+ * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseShenandoahGC\n+ *      gc.stress.systemgc.TestSystemGCWithShenandoah 270\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithShenandoah.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}