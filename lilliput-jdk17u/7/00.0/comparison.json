{"files":[{"patch":"@@ -3457,1 +3457,2 @@\n-        if (con < (address)(uintptr_t)os::vm_page_size()) {\n+        if (! __ is_valid_AArch64_address(con) ||\n+            con < (address)(uintptr_t)os::vm_page_size()) {\n@@ -4964,1 +4965,1 @@\n-  \/\/match(iRegP_R5);\n+  match(iRegP_R5);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3956,0 +3956,46 @@\n+\n+void C2_MacroAssembler::rearrange_bytes(XMMRegister dst, XMMRegister shuffle, XMMRegister src, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, KRegister ktmp,\n+                                        int vlen_enc) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  \/\/ Byte shuffles are inlane operations and indices are determined using\n+  \/\/ lower 4 bit of each shuffle lane, thus all shuffle indices are\n+  \/\/ normalized to index range 0-15. This makes sure that all the multiples\n+  \/\/ of an index value are placed at same relative position in 128 bit\n+  \/\/ lane i.e. elements corresponding to shuffle indices 16, 32 and 64\n+  \/\/ will be 16th element in their respective 128 bit lanes.\n+  movl(rtmp, 16);\n+  evpbroadcastb(xtmp1, rtmp, vlen_enc);\n+\n+  \/\/ Compute a mask for shuffle vector by comparing indices with expression INDEX < 16,\n+  \/\/ Broadcast first 128 bit lane across entire vector, shuffle the vector lanes using\n+  \/\/ original shuffle indices and move the shuffled lanes corresponding to true\n+  \/\/ mask to destination vector.\n+  evpcmpb(ktmp, k0, shuffle, xtmp1, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp2, src, src, 0x0, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp2, shuffle, false, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 16 && INDEX < 32\n+  \/\/ and broadcasting second 128 bit lane.\n+  evpcmpb(ktmp, k0, shuffle,  xtmp1, Assembler::nlt, true, vlen_enc);\n+  vpsllq(xtmp2, xtmp1, 0x1, vlen_enc);\n+  evpcmpb(ktmp, ktmp, shuffle, xtmp2, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp3, src, src, 0x55, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp3, shuffle, true, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 32 && INDEX < 48\n+  \/\/ and broadcasting third 128 bit lane.\n+  evpcmpb(ktmp, k0, shuffle,  xtmp2, Assembler::nlt, true, vlen_enc);\n+  vpaddb(xtmp1, xtmp1, xtmp2, vlen_enc);\n+  evpcmpb(ktmp, ktmp, shuffle,  xtmp1, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp3, src, src, 0xAA, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp3, shuffle, true, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 48 && INDEX < 64\n+  \/\/ and broadcasting third 128 bit lane.\n+  evpcmpb(ktmp, k0, shuffle,  xtmp1, Assembler::nlt, true, vlen_enc);\n+  vpsllq(xtmp2, xtmp2, 0x1, vlen_enc);\n+  evpcmpb(ktmp, ktmp, shuffle,  xtmp2, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp3, src, src, 0xFF, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp3, shuffle, true, vlen_enc);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -277,0 +277,3 @@\n+  void rearrange_bytes(XMMRegister dst, XMMRegister shuffle, XMMRegister src, XMMRegister xtmp1,\n+                       XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, KRegister ktmp, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -296,0 +296,2 @@\n+#define REWRITE_AT_PC(val) \\\n+    *pc = val;\n@@ -392,0 +394,75 @@\n+#define MAYBE_POST_FIELD_ACCESS(obj) {                              \\\n+  if (JVMTI_ENABLED) {                                              \\\n+    int* count_addr;                                                \\\n+    \/* Check to see if a field modification watch has been set *\/   \\\n+    \/* before we take the time to call into the VM. *\/              \\\n+    count_addr = (int*)JvmtiExport::get_field_access_count_addr();  \\\n+    if (*count_addr > 0) {                                          \\\n+      oop target;                                                   \\\n+      if ((Bytecodes::Code)opcode == Bytecodes::_getstatic) {       \\\n+        target = NULL;                                              \\\n+      } else {                                                      \\\n+        target = obj;                                               \\\n+      }                                                             \\\n+      CALL_VM(InterpreterRuntime::post_field_access(THREAD,         \\\n+                                  target, cache),                   \\\n+                                  handle_exception);                \\\n+    }                                                               \\\n+  }                                                                 \\\n+}\n+\n+#define MAYBE_POST_FIELD_MODIFICATION(obj) {                        \\\n+  if (JVMTI_ENABLED) {                                              \\\n+    int* count_addr;                                                \\\n+    \/* Check to see if a field modification watch has been set *\/   \\\n+    \/* before we take the time to call into the VM.            *\/   \\\n+    count_addr = (int*)JvmtiExport::get_field_modification_count_addr(); \\\n+    if (*count_addr > 0) {                                          \\\n+      oop target;                                                   \\\n+      if ((Bytecodes::Code)opcode == Bytecodes::_putstatic) {       \\\n+        target = NULL;                                              \\\n+      } else {                                                      \\\n+        target = obj;                                               \\\n+      }                                                             \\\n+      CALL_VM(InterpreterRuntime::post_field_modification(THREAD,   \\\n+                                  target, cache,                    \\\n+                                  (jvalue*)STACK_SLOT(-1)),         \\\n+                                  handle_exception);                \\\n+    }                                                               \\\n+  }                                                                 \\\n+}\n+\n+static inline int fast_get_type(TosState tos) {\n+  switch (tos) {\n+    case ztos:\n+    case btos: return Bytecodes::_fast_bgetfield;\n+    case ctos: return Bytecodes::_fast_cgetfield;\n+    case stos: return Bytecodes::_fast_sgetfield;\n+    case itos: return Bytecodes::_fast_igetfield;\n+    case ltos: return Bytecodes::_fast_lgetfield;\n+    case ftos: return Bytecodes::_fast_fgetfield;\n+    case dtos: return Bytecodes::_fast_dgetfield;\n+    case atos: return Bytecodes::_fast_agetfield;\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n+  }\n+}\n+\n+static inline int fast_put_type(TosState tos) {\n+  switch (tos) {\n+    case ztos: return Bytecodes::_fast_zputfield;\n+    case btos: return Bytecodes::_fast_bputfield;\n+    case ctos: return Bytecodes::_fast_cputfield;\n+    case stos: return Bytecodes::_fast_sputfield;\n+    case itos: return Bytecodes::_fast_iputfield;\n+    case ltos: return Bytecodes::_fast_lputfield;\n+    case ftos: return Bytecodes::_fast_fputfield;\n+    case dtos: return Bytecodes::_fast_dputfield;\n+    case atos: return Bytecodes::_fast_aputfield;\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n+  }\n+}\n+\n@@ -400,3 +477,5 @@\n-\/\/ Instantiate two variants of the method for future linking.\n-template void BytecodeInterpreter::run<true>(interpreterState istate);\n-template void BytecodeInterpreter::run<false>(interpreterState istate);\n+\/\/ Instantiate variants of the method for future linking.\n+template void BytecodeInterpreter::run<false, false>(interpreterState istate);\n+template void BytecodeInterpreter::run<false,  true>(interpreterState istate);\n+template void BytecodeInterpreter::run< true, false>(interpreterState istate);\n+template void BytecodeInterpreter::run< true,  true>(interpreterState istate);\n@@ -404,1 +483,1 @@\n-template<bool JVMTI_ENABLED>\n+template<bool JVMTI_ENABLED, bool REWRITE_BYTECODES>\n@@ -500,2 +579,2 @@\n-\/* 0xC8 *\/ &&opc_goto_w,        &&opc_jsr_w,            &&opc_breakpoint,     &&opc_default,\n-\/* 0xCC *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n+\/* 0xC8 *\/ &&opc_goto_w,        &&opc_jsr_w,            &&opc_breakpoint,     &&opc_fast_agetfield,\n+\/* 0xCC *\/ &&opc_fast_bgetfield,&&opc_fast_cgetfield,   &&opc_fast_dgetfield, &&opc_fast_fgetfield,\n@@ -503,4 +582,4 @@\n-\/* 0xD0 *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n-\/* 0xD4 *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n-\/* 0xD8 *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n-\/* 0xDC *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n+\/* 0xD0 *\/ &&opc_fast_igetfield,&&opc_fast_lgetfield,   &&opc_fast_sgetfield, &&opc_fast_aputfield,\n+\/* 0xD4 *\/ &&opc_fast_bputfield,&&opc_fast_zputfield,   &&opc_fast_cputfield, &&opc_fast_dputfield,\n+\/* 0xD8 *\/ &&opc_fast_fputfield,&&opc_fast_iputfield,   &&opc_fast_lputfield, &&opc_fast_sputfield,\n+\/* 0xDC *\/ &&opc_fast_aload_0,  &&opc_fast_iaccess_0,   &&opc_fast_aaccess_0, &&opc_fast_faccess_0,\n@@ -508,1 +587,1 @@\n-\/* 0xE0 *\/ &&opc_default,       &&opc_default,          &&opc_default,        &&opc_default,\n+\/* 0xE0 *\/ &&opc_fast_iload,    &&opc_fast_iload2,      &&opc_fast_icaload,   &&opc_fast_invokevfinal,\n@@ -755,0 +834,26 @@\n+      {\n+        if (REWRITE_BYTECODES) {\n+          \/\/ Attempt to rewrite iload, iload -> fast_iload2\n+          \/\/                    iload, caload -> fast_icaload\n+          \/\/ Normal iloads will be rewritten to fast_iload to avoid checking again.\n+          switch (*(pc + 2)) {\n+            case Bytecodes::_fast_iload:\n+              REWRITE_AT_PC(Bytecodes::_fast_iload2);\n+              break;\n+            case Bytecodes::_caload:\n+              REWRITE_AT_PC(Bytecodes::_fast_icaload);\n+              break;\n+            case Bytecodes::_iload:\n+              \/\/ Wait until rewritten to _fast_iload.\n+              break;\n+            default:\n+              \/\/ Last iload in a (potential) series, don't check again.\n+              REWRITE_AT_PC(Bytecodes::_fast_iload);\n+          }\n+        }\n+        \/\/ Normal iload handling.\n+        SET_STACK_SLOT(LOCALS_SLOT(pc[1]), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(2, 1);\n+      }\n+\n+      CASE(_fast_iload):\n@@ -759,0 +864,5 @@\n+      CASE(_fast_iload2):\n+          SET_STACK_SLOT(LOCALS_SLOT(pc[1]), 0);\n+          SET_STACK_SLOT(LOCALS_SLOT(pc[3]), 1);\n+          UPDATE_PC_AND_TOS_AND_CONTINUE(4, 2);\n+\n@@ -769,5 +879,0 @@\n-      CASE(_aload_##num):                                               \\\n-          VERIFY_OOP(LOCALS_OBJECT(num));                               \\\n-          SET_STACK_OBJECT(LOCALS_OBJECT(num), 0);                      \\\n-          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);                         \\\n-                                                                        \\\n@@ -786,4 +891,47 @@\n-          OPC_LOAD_n(0);\n-          OPC_LOAD_n(1);\n-          OPC_LOAD_n(2);\n-          OPC_LOAD_n(3);\n+      OPC_LOAD_n(0);\n+      OPC_LOAD_n(1);\n+      OPC_LOAD_n(2);\n+      OPC_LOAD_n(3);\n+\n+#undef  OPC_ALOAD_n\n+#define OPC_ALOAD_n(num)                                                \\\n+      CASE(_aload_##num): {                                             \\\n+          oop obj = LOCALS_OBJECT(num);                                 \\\n+          VERIFY_OOP(obj);                                              \\\n+          SET_STACK_OBJECT(obj, 0);                                     \\\n+          UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);                         \\\n+      }\n+\n+      CASE(_aload_0):\n+      {\n+        \/* Maybe rewrite if following bytecode is one of the supported _fast_Xgetfield bytecodes. *\/\n+        if (REWRITE_BYTECODES) {\n+          switch (*(pc + 1)) {\n+            case Bytecodes::_fast_agetfield:\n+              REWRITE_AT_PC(Bytecodes::_fast_aaccess_0);\n+              break;\n+            case Bytecodes::_fast_fgetfield:\n+              REWRITE_AT_PC(Bytecodes::_fast_faccess_0);\n+              break;\n+            case Bytecodes::_fast_igetfield:\n+              REWRITE_AT_PC(Bytecodes::_fast_iaccess_0);\n+              break;\n+            case Bytecodes::_getfield: {\n+              \/* Otherwise, do nothing here, wait until it gets rewritten to _fast_Xgetfield.\n+               * Unfortunately, this punishes volatile field access, because it never gets\n+               * rewritten. *\/\n+              break;\n+            }\n+            default:\n+              REWRITE_AT_PC(Bytecodes::_fast_aload_0);\n+              break;\n+          }\n+        }\n+        VERIFY_OOP(LOCALS_OBJECT(0));\n+        SET_STACK_OBJECT(LOCALS_OBJECT(0), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);\n+      }\n+\n+      OPC_ALOAD_n(1);\n+      OPC_ALOAD_n(2);\n+      OPC_ALOAD_n(3);\n@@ -1321,5 +1469,1 @@\n-      \/* Every array access byte-code starts out like this *\/\n-\/\/        arrayOopDesc* arrObj = (arrayOopDesc*)STACK_OBJECT(arrayOff);\n-#define ARRAY_INTRO(arrayOff)                                                  \\\n-      arrayOop arrObj = (arrayOop)STACK_OBJECT(arrayOff);                      \\\n-      jint     index  = STACK_INT(arrayOff + 1);                               \\\n+#define ARRAY_INDEX_CHECK(arrObj, index)                                       \\\n@@ -1337,0 +1481,7 @@\n+      \/* Every array access byte-code starts out like this *\/\n+\/\/        arrayOopDesc* arrObj = (arrayOopDesc*)STACK_OBJECT(arrayOff);\n+#define ARRAY_INTRO(arrayOff)                                                  \\\n+      arrayOop arrObj = (arrayOop)STACK_OBJECT(arrayOff);                      \\\n+      jint     index  = STACK_INT(arrayOff + 1);                               \\\n+      ARRAY_INDEX_CHECK(arrObj, index)\n+\n@@ -1376,0 +1527,9 @@\n+      CASE(_fast_icaload): {\n+          \/\/ Custom fast access for iload,caload pair.\n+          arrayOop arrObj = (arrayOop) STACK_OBJECT(-1);\n+          jint index = LOCALS_INT(pc[1]);\n+          ARRAY_INDEX_CHECK(arrObj, index);\n+          SET_STACK_INT(*(jchar *)(((address) arrObj->base(T_CHAR)) + index * sizeof(jchar)), -1);\n+          UPDATE_PC_AND_TOS_AND_CONTINUE(3, 0);\n+      }\n+\n@@ -1549,20 +1709,0 @@\n-          if (JVMTI_ENABLED) {\n-            int *count_addr;\n-            oop obj;\n-            \/\/ Check to see if a field modification watch has been set\n-            \/\/ before we take the time to call into the VM.\n-            count_addr = (int *)JvmtiExport::get_field_access_count_addr();\n-            if ( *count_addr > 0 ) {\n-              if ((Bytecodes::Code)opcode == Bytecodes::_getstatic) {\n-                obj = NULL;\n-              } else {\n-                obj = STACK_OBJECT(-1);\n-                VERIFY_OOP(obj);\n-              }\n-              CALL_VM(InterpreterRuntime::post_field_access(THREAD,\n-                                          obj,\n-                                          cache),\n-                                          handle_exception);\n-            }\n-          }\n-\n@@ -1577,0 +1717,5 @@\n+            \/\/ Check if we can rewrite non-volatile _getfield to one of the _fast_Xgetfield.\n+            if (REWRITE_BYTECODES && !cache->is_volatile()) {\n+              \/\/ Rewrite current BC to _fast_Xgetfield.\n+              REWRITE_AT_PC(fast_get_type(cache->flag_state()));\n+            }\n@@ -1579,0 +1724,2 @@\n+          MAYBE_POST_FIELD_ACCESS(obj);\n+\n@@ -1673,27 +1820,0 @@\n-          if (JVMTI_ENABLED) {\n-            int *count_addr;\n-            oop obj;\n-            \/\/ Check to see if a field modification watch has been set\n-            \/\/ before we take the time to call into the VM.\n-            count_addr = (int *)JvmtiExport::get_field_modification_count_addr();\n-            if ( *count_addr > 0 ) {\n-              if ((Bytecodes::Code)opcode == Bytecodes::_putstatic) {\n-                obj = NULL;\n-              }\n-              else {\n-                if (cache->is_long() || cache->is_double()) {\n-                  obj = STACK_OBJECT(-3);\n-                } else {\n-                  obj = STACK_OBJECT(-2);\n-                }\n-                VERIFY_OOP(obj);\n-              }\n-\n-              CALL_VM(InterpreterRuntime::post_field_modification(THREAD,\n-                                          obj,\n-                                          cache,\n-                                          (jvalue *)STACK_SLOT(-1)),\n-                                          handle_exception);\n-            }\n-          }\n-\n@@ -1718,0 +1838,6 @@\n+\n+            \/\/ Check if we can rewrite non-volatile _putfield to one of the _fast_Xputfield.\n+            if (REWRITE_BYTECODES && !cache->is_volatile()) {\n+              \/\/ Rewrite current BC to _fast_Xputfield.\n+              REWRITE_AT_PC(fast_put_type(cache->flag_state()));\n+            }\n@@ -1720,0 +1846,2 @@\n+          MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n@@ -2281,0 +2409,4 @@\n+              if (REWRITE_BYTECODES) {\n+                \/\/ Rewrite to _fast_invokevfinal.\n+                REWRITE_AT_PC(Bytecodes::_fast_invokevfinal);\n+              }\n@@ -2415,0 +2547,323 @@\n+      CASE(_fast_agetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        VERIFY_OOP(obj->obj_field(field_offset));\n+        SET_STACK_OBJECT(obj->obj_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_bgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->byte_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_cgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->char_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_dgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_DOUBLE(obj->double_field(field_offset), 0);\n+        MORE_STACK(1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_fgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_FLOAT(obj->float_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_igetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->int_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_lgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_LONG(obj->long_field(field_offset), 0);\n+        MORE_STACK(1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_sgetfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = STACK_OBJECT(-1);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->short_field(field_offset), -1);\n+        UPDATE_PC_AND_CONTINUE(3);\n+      }\n+\n+      CASE(_fast_aputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->obj_field_put(field_offset, STACK_OBJECT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_bputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->byte_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_zputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->byte_field_put(field_offset, (STACK_INT(-1) & 1)); \/\/ only store LSB\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_cputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->char_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_dputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-3);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->double_field_put(field_offset, STACK_DOUBLE(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -3);\n+      }\n+\n+      CASE(_fast_fputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->float_field_put(field_offset, STACK_FLOAT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_iputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->int_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_lputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-3);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->long_field_put(field_offset, STACK_LONG(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -3);\n+      }\n+\n+      CASE(_fast_sputfield): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        oop obj = STACK_OBJECT(-2);\n+        CHECK_NULL(obj);\n+\n+        MAYBE_POST_FIELD_MODIFICATION(obj);\n+\n+        int field_offset = cache->f2_as_index();\n+        obj->short_field_put(field_offset, STACK_INT(-1));\n+\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(3, -2);\n+      }\n+\n+      CASE(_fast_aload_0): {\n+        oop obj = LOCALS_OBJECT(0);\n+        VERIFY_OOP(obj);\n+        SET_STACK_OBJECT(obj, 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(1, 1);\n+      }\n+\n+      CASE(_fast_aaccess_0): {\n+        u2 index = Bytes::get_native_u2(pc+2);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = LOCALS_OBJECT(0);\n+        CHECK_NULL(obj);\n+        VERIFY_OOP(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        VERIFY_OOP(obj->obj_field(field_offset));\n+        SET_STACK_OBJECT(obj->obj_field(field_offset), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(4, 1);\n+      }\n+\n+      CASE(_fast_iaccess_0): {\n+        u2 index = Bytes::get_native_u2(pc+2);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = LOCALS_OBJECT(0);\n+        CHECK_NULL(obj);\n+        VERIFY_OOP(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_INT(obj->int_field(field_offset), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(4, 1);\n+      }\n+\n+      CASE(_fast_faccess_0): {\n+        u2 index = Bytes::get_native_u2(pc+2);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        int field_offset = cache->f2_as_index();\n+\n+        oop obj = LOCALS_OBJECT(0);\n+        CHECK_NULL(obj);\n+        VERIFY_OOP(obj);\n+\n+        MAYBE_POST_FIELD_ACCESS(obj);\n+\n+        SET_STACK_FLOAT(obj->float_field(field_offset), 0);\n+        UPDATE_PC_AND_TOS_AND_CONTINUE(4, 1);\n+      }\n+\n+      CASE(_fast_invokevfinal): {\n+        u2 index = Bytes::get_native_u2(pc+1);\n+        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+\n+        assert(cache->is_resolved(Bytecodes::_invokevirtual), \"Should be resolved before rewriting\");\n+\n+        istate->set_msg(call_method);\n+\n+        CHECK_NULL(STACK_OBJECT(-(cache->parameter_size())));\n+        Method* callee = cache->f2_as_vfinal_method();\n+        istate->set_callee(callee);\n+        if (JVMTI_ENABLED && THREAD->is_interp_only_mode()) {\n+          istate->set_callee_entry_point(callee->interpreter_entry());\n+        } else {\n+          istate->set_callee_entry_point(callee->from_interpreted_entry());\n+        }\n+        istate->set_bcp_advance(3);\n+        UPDATE_PC_AND_RETURN(0);\n+      }\n+\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":527,"deletions":72,"binary":false,"changes":599,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-void Compile::remove_useless_nodes(Unique_Node_List &useful) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n@@ -426,1 +426,1 @@\n-      record_for_igvn(n->unique_out());\n+      worklist->push(n->unique_out());\n@@ -436,0 +436,5 @@\n+#ifdef ASSERT\n+  if (_modified_nodes != NULL) {\n+    _modified_nodes->remove_useless_nodes(useful.member_set());\n+  }\n+#endif\n@@ -2760,0 +2765,2 @@\n+    cfg.remove_unreachable_blocks();\n+    cfg.verify_dominator_tree();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -940,1 +940,1 @@\n-  void              remove_useless_nodes (Unique_Node_List &useful);\n+  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,3 +60,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-#include \"gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp\"\n-#endif\n@@ -579,0 +576,1 @@\n+    BarrierSetC2 *bs = BarrierSet::barrier_set()->barrier_set_c2();\n@@ -595,2 +593,1 @@\n-          if (!n->is_Store() && n->Opcode() != Op_CastP2X\n-              SHENANDOAHGC_ONLY(&& (!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n))) ) {\n+          if (!n->is_Store() && n->Opcode() != Op_CastP2X && !bs->is_gc_pre_barrier_node(n)) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -548,1 +548,1 @@\n-  product(ccstr, NativeMemoryTracking, \"off\",                               \\\n+  product(ccstr, NativeMemoryTracking, DEBUG_ONLY(\"summary\") NOT_DEBUG(\"off\"), \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1436,0 +1436,6 @@\n+static inline bool is_excluded(const Klass* monitor_klass) {\n+  assert(monitor_klass != nullptr, \"invariant\");\n+  NOT_JFR_RETURN_(false);\n+  JFR_ONLY(return vmSymbols::jfr_chunk_rotation_monitor() == monitor_klass->name());\n+}\n+\n@@ -1443,1 +1449,5 @@\n-  event->set_monitorClass(monitor->object()->klass());\n+  const Klass* monitor_klass = monitor->object()->klass();\n+  if (is_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java 8241293 macosx-x64\n@@ -112,1 +111,0 @@\n-resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8262386 generic-all\n@@ -141,1 +139,0 @@\n-vmTestbase\/nsk\/monitoring\/MemoryPoolMBean\/isCollectionUsageThresholdExceeded\/isexceeded003\/TestDescription.java 8153598 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-        \/\/ (Note: ccs size shall be rounded up to the minimum size of 4m since metaspace reservations\n-        \/\/  are done in a 4m granularity. Note that this is **reserved** size and does not affect rss.\n+        \/\/ (Note: ccs size are rounded up to the next larger root chunk boundary (16m).\n+        \/\/ Note that this is **reserved** size and does not affect rss.\n@@ -74,1 +74,1 @@\n-        output.shouldMatch(\"Compressed class space.*4194304\")\n+        output.shouldMatch(\"Compressed class space.*16777216\")\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassSpaceSize.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n@@ -34,3 +34,1 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n+import java.util.*;\n@@ -45,1 +43,1 @@\n- * @library \/test\/lib \/\n+ * @library \/test\/lib \/testlibrary_tests \/\n@@ -54,1 +52,7 @@\n-    private static final List<Exception> exceptions = new ArrayList<>();\n+    private static final Map<Exception, String> exceptions = new LinkedHashMap<>();\n+    private static final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private static final ByteArrayOutputStream baosErr = new ByteArrayOutputStream();\n+    private static final PrintStream ps = new PrintStream(baos);\n+    private static final PrintStream psErr = new PrintStream(baosErr);\n+    private static final PrintStream oldOut = System.out;\n+    private static final PrintStream oldErr = System.err;\n@@ -57,2 +61,3 @@\n-        System.out.println(TestFramework.getLastTestVMOutput());\n-        exceptions.add(e);\n+        System.out.flush();\n+        System.err.flush();\n+        exceptions.put(e, baos + System.lineSeparator() + baosErr);\n@@ -62,3 +67,3 @@\n-        runFailOnTestsArgs(BadFailOnConstraint.create(AndOr1.class, \"test1(int)\", 1, \"CallStaticJava\"), \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UsePerfData\", \"-XX:+UseTLAB\");\n-        runFailOnTestsArgs(BadFailOnConstraint.create(AndOr1.class, \"test2()\", 1, \"CallStaticJava\"), \"-XX:TLABRefillWasteFraction=50\", \"-XX:-UsePerfData\", \"-XX:+UseTLAB\");\n-\n+        \/\/ Redirect System.out and System.err to reduce noise.\n+        System.setOut(ps);\n+        System.setErr(psErr);\n@@ -70,0 +75,3 @@\n+        runCheck(new String[] {\"-XX:TLABRefillWasteFraction=50\", \"-XX:+UsePerfData\", \"-XX:+UseTLAB\"}, BadFailOnConstraint.create(AndOr1.class, \"test1(int)\", 1, \"CallStaticJava\"));\n+        runCheck(new String[] {\"-XX:TLABRefillWasteFraction=50\", \"-XX:-UsePerfData\", \"-XX:+UseTLAB\"}, BadFailOnConstraint.create(AndOr1.class, \"test2()\", 1, \"CallStaticJava\"));\n+\n@@ -225,6 +233,0 @@\n-        \/\/ Redirect stdout to stream and then check if we find required IR encoding read from socket.\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        PrintStream ps = new PrintStream(baos);\n-        PrintStream old = System.out;\n-        System.setOut(ps);\n-\n@@ -233,1 +235,1 @@\n-            shouldNotReach();\n+            Utils.shouldHaveThrownException(baos.toString());\n@@ -236,1 +238,1 @@\n-                boolean failed = false;\n+                StringBuilder failures = new StringBuilder();\n@@ -244,2 +246,1 @@\n-                    exceptions.add(new RuntimeException(\"Could not find all both() methods, expected 7 but found \" + bothCount));\n-                    failed = true;\n+                    failures.append(\"- Could not find all both() methods, expected 7 but found \").append(bothCount).append(System.lineSeparator());\n@@ -252,1 +253,3 @@\n-                    Asserts.assertFalse(match.contains(\"PrintOptoAssembly\"), \"Cannot contain opto assembly: \" + output);\n+                    if (match.contains(\"PrintOptoAssembly\")) {\n+                        failures.append(\"Cannot contain opto assembly: \").append(System.lineSeparator()).append(match);\n+                    }\n@@ -256,2 +259,1 @@\n-                    exceptions.add(new RuntimeException(\"Could not find all ideal() methods, expected 7 but found \" + count));\n-                    failed = true;\n+                    failures.append(\"- Could not find all ideal() methods, expected 7 but found \").append(count).append(System.lineSeparator());\n@@ -264,1 +266,3 @@\n-                    Asserts.assertFalse(match.contains(\"PrintIdeal\"), \"Cannot contain opto assembly: \" + output);\n+                    if (match.contains(\"PrintIdeal\")) {\n+                        failures.append(\"Cannot contain print assembly: \").append(System.lineSeparator()).append(match);\n+                    }\n@@ -268,2 +272,1 @@\n-                    exceptions.add(new RuntimeException(\"Could not find all opto() methods, expected 7 but found \" + count));\n-                    failed = true;\n+                    failures.append(\"- Could not find all opto() methods, expected 7 but found \").append(count).append(System.lineSeparator());\n@@ -271,3 +274,2 @@\n-                if (failed) {\n-                    System.err.println(TestFramework.getLastTestVMOutput());\n-                    System.err.println(output);\n+                if (!failures.isEmpty()) {\n+                    addException(new RuntimeException(failures.toString()));\n@@ -285,2 +287,1 @@\n-        baos.reset();\n-        findIrIds(output, \"testMatchAllIf50\", 0, 21);\n+        findIrIds(output, \"testMatchAllIf50\", 1, 22);\n@@ -292,3 +293,2 @@\n-        baos.reset();\n-        findIrIds(output, \"testMatchAllIf50\", 4, 6, 13, 18);\n-        findIrIds(output, \"testMatchNoneIf50\", 0, 3, 8, 10, 17, 22);\n+        findIrIds(output, \"testMatchAllIf50\", 5, 7, 14, 19);\n+        findIrIds(output, \"testMatchNoneIf50\", 1, 4, 9, 11, 18, 23);\n@@ -299,4 +299,4 @@\n-        baos.reset();\n-        findIrIds(output, \"testMatchAllIf50\", 7, 12, 19, 21);\n-        findIrIds(output, \"testMatchNoneIf50\", 4, 7, 11, 16, 20, 22);\n-        System.setOut(old);\n+        findIrIds(output, \"testMatchAllIf50\", 8, 13, 20, 22);\n+        findIrIds(output, \"testMatchNoneIf50\", 5, 8, 12, 17, 21, 23);\n+        System.setOut(oldOut);\n+        System.setErr(oldErr);\n@@ -305,3 +305,8 @@\n-            System.err.println(\"TestIRMatching failed with one or more exceptions:\");\n-            for (Exception e : exceptions) {\n-                System.err.println(e.getMessage());\n+            System.err.println(\"TestIRMatching failed with \" + exceptions.size() + \" exception(s):\");\n+            int i = 1;\n+            System.err.println(\"************************\");\n+            for (Map.Entry<Exception, String> entry : exceptions.entrySet()) {\n+                System.err.println(\"***** Exception \" + String.format(\"%02d\", i++) +\" *****\");\n+                System.err.println(\"************************\");\n+\n+                Exception e = entry.getKey();\n@@ -309,1 +314,16 @@\n-                System.err.println(\"---------\");\n+                System.err.println();\n+                System.err.println(\"===== OUTPUT ======\");\n+                System.err.println(entry.getValue());\n+                System.err.println(\"MESSAGE: \" + e.getMessage());\n+                System.err.println(\"************************\");\n+            }\n+            i = 1;\n+            System.err.println(\"====================================\");\n+            System.err.println(\"********************\");\n+            System.err.println(\"***** OVERVIEW *****\");\n+            System.err.println(\"********************\");\n+            for (Map.Entry<Exception, String> entry : exceptions.entrySet()) {\n+                Exception e = entry.getKey();\n+                System.err.print((i++) + \") \");\n+                entry.getKey().printStackTrace(System.err);\n+                System.err.println(\"********************\");\n@@ -311,1 +331,1 @@\n-            throw new RuntimeException(\"TestIRMatching failed with one or more exceptions - check stderr and stdout\");\n+            throw new RuntimeException(\"TestIRMatching failed with \" + exceptions.size() + \" exception(s) - check stderr and stdout\");\n@@ -315,0 +335,6 @@\n+    private static void runFramework(TestFramework framework) {\n+        baos.reset();\n+        baosErr.reset();\n+        framework.start();\n+    }\n+\n@@ -317,1 +343,1 @@\n-            new TestFramework(clazz).addFlags(args).start();\n+            runFramework(new TestFramework(clazz).addFlags(args));\n@@ -324,1 +350,1 @@\n-        new TestFramework(clazz).addFlags(args).start();\n+        runFramework(new TestFramework(clazz).addFlags(args));\n@@ -329,2 +355,6 @@\n-            new TestFramework(constraints[0].getKlass()).addFlags(args).start(); \/\/ All constraints have the same class.\n-            shouldNotReach();\n+            TestFramework framework = new TestFramework(constraints[0].getKlass()); \/\/ All constraints have the same class.\n+            if (args != null) {\n+                framework.addFlags(args);\n+            }\n+            runFramework(framework);\n+            Utils.shouldHaveThrownException(baos.toString());\n@@ -339,8 +369,1 @@\n-        try {\n-            TestFramework.run(constraints[0].getKlass()); \/\/ All constraints have the same class.\n-            shouldNotReach();\n-        } catch (IRViolationException e) {\n-            checkConstraints(e, constraints);\n-        } catch (Exception e) {\n-            addException(e);\n-        }\n+        runCheck(null, constraints);\n@@ -356,1 +379,1 @@\n-            System.out.println(TestFramework.getLastTestVMOutput());\n+            System.out.println(e.getCompilations());\n@@ -358,17 +381,1 @@\n-            exceptions.add(e1);\n-        }\n-    }\n-\n-    \/\/ Single constraint\n-    private static void runFailOnTestsArgs(Constraint constraint, String... args) {\n-        try {\n-            new TestFramework(constraint.getKlass()).addFlags(args).start(); \/\/ All constraints have the same class.\n-            shouldNotReach();\n-        } catch (IRViolationException e) {\n-            try {\n-                constraint.checkConstraint(e);\n-            } catch (Exception e1) {\n-                addException(e);\n-            }\n-        } catch (Exception e) {\n-            addException(e);\n+            addException(e1);\n@@ -378,4 +385,0 @@\n-    public static void shouldNotReach() {\n-        throw new ShouldNotReachException(\"Framework did not fail but it should have!\");\n-    }\n-\n@@ -393,2 +396,3 @@\n-        Asserts.assertTrue(output.contains(builder.toString()), \"Could not find encoding: \\\"\" + builder.toString()\n-                                                                + System.lineSeparator());\n+        if (!output.contains(builder.toString())) {\n+            addException(new RuntimeException(\"Could not find encoding: \\\"\" + builder + System.lineSeparator()));\n+        }\n@@ -548,1 +552,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}) \/\/ Index 1\n@@ -552,1 +556,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=50\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=50\"}) \/\/ Index 5\n@@ -555,1 +559,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=50\"}) \/\/ Index 7\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=50\"}) \/\/ Index 8\n@@ -561,1 +565,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<51\"}) \/\/ Index 13\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<51\"}) \/\/ Index 14\n@@ -569,1 +573,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  49\"}) \/\/ Index 21\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  49\"}) \/\/ Index 22\n@@ -574,1 +578,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"49\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"49\"}) \/\/ Index 1\n@@ -578,1 +582,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\"}) \/\/ Index 5\n@@ -582,1 +586,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=49\"}) \/\/ Index 8\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=49\"}) \/\/ Index 9\n@@ -585,1 +589,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=51\"}) \/\/ Index 11\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=51\"}) \/\/ Index 12\n@@ -591,1 +595,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<50\"}) \/\/ Index 17\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<50\"}) \/\/ Index 18\n@@ -596,1 +600,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  50\"}) \/\/ Index 22\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  50\"}) \/\/ Index 23\n@@ -812,1 +816,1 @@\n-    @IR(counts = {IRNode.LOAD, \"!= 1\"})\n+    @IR(counts = {IRNode.LOAD, \"!= 1\"}) \/\/ fail\n@@ -819,1 +823,1 @@\n-    @IR(counts = {IRNode.LOAD, \"1\"})\n+    @IR(counts = {IRNode.LOAD, \"1\"}) \/\/ fail\n@@ -827,2 +831,2 @@\n-    @IR(counts = {IRNode.LOAD, \"0\"})\n-    @IR(counts = {IRNode.STORE, \" <= 0\"})\n+    @IR(counts = {IRNode.LOAD, \"0\"}) \/\/ fail\n+    @IR(counts = {IRNode.STORE, \" <= 0\"}) \/\/ fail\n@@ -1452,6 +1456,0 @@\n-class ShouldNotReachException extends RuntimeException {\n-    ShouldNotReachException(String s) {\n-        super(s);\n-    }\n-}\n-\n@@ -1518,1 +1516,1 @@\n-        Asserts.assertTrue(matched, toString() + \" should have been matched\");\n+        Asserts.assertTrue(matched, this + \" should have been matched\");\n@@ -1736,1 +1734,1 @@\n-        matchesList.add(\"but found \" + foundCount);\n+        matchesList.add(\"Failed comparison: [found] \" + foundCount);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":102,"deletions":104,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2020, 2022, Red Hat, Inc. All rights reserved.\n@@ -267,0 +267,30 @@\n+\/*\n+ * @test\n+ * @summary Test for fInst.getObjectSize with large arrays\n+ * @library \/test\/lib\n+ * @requires vm.bits == 64\n+ * @requires vm.debug\n+ * @requires os.maxMemory >= 10G\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run build GetObjectSizeIntrinsicsTest\n+ * @run shell MakeJAR.sh basicAgent\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -Xmx8g\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -Xint\n+ *                   -javaagent:basicAgent.jar GetObjectSizeIntrinsicsTest GetObjectSizeIntrinsicsTest large\n+ *\n+ * @run main\/othervm -Xmx8g\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -Xbatch -XX:TieredStopAtLevel=1\n+ *                   -javaagent:basicAgent.jar GetObjectSizeIntrinsicsTest GetObjectSizeIntrinsicsTest large\n+ *\n+ * @run main\/othervm -Xmx8g\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -Xbatch -XX:-TieredCompilation\n+ *                   -javaagent:basicAgent.jar GetObjectSizeIntrinsicsTest GetObjectSizeIntrinsicsTest large\n+ *\/\n+\n@@ -274,2 +304,2 @@\n-    static final Boolean compressedOops = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompressedOops\");\n-    static final int REF_SIZE = (compressedOops == null || compressedOops == true) ?  4 : 8;\n+    static final Boolean COMPRESSED_OOPS = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompressedOops\");\n+    static final long REF_SIZE = (COMPRESSED_OOPS == null || COMPRESSED_OOPS == true) ? 4 : 8;\n@@ -280,1 +310,9 @@\n-    public GetObjectSizeIntrinsicsTest(String name) {\n+    static final int SMALL_ARRAY_SIZE = 1024;\n+\n+    \/\/ These should overflow 4G size boundary\n+    static final int LARGE_INT_ARRAY_SIZE = 1024*1024*1024 + 1024;\n+    static final int LARGE_OBJ_ARRAY_SIZE = (4096\/(int)REF_SIZE)*1024*1024 + 1024;\n+\n+    final String mode;\n+\n+    public GetObjectSizeIntrinsicsTest(String name, String mode) {\n@@ -282,0 +320,1 @@\n+        this.mode = mode;\n@@ -285,1 +324,1 @@\n-        new GetObjectSizeIntrinsicsTest(args[0]).runTest();\n+        new GetObjectSizeIntrinsicsTest(args[0], (args.length >= 2 ? args[1] : \"\")).runTest();\n@@ -315,3 +354,3 @@\n-        testSize_newSmallByteArray();\n-        testSize_localSmallByteArray();\n-        testSize_fieldSmallByteArray();\n+        testSize_newSmallIntArray();\n+        testSize_localSmallIntArray();\n+        testSize_fieldSmallIntArray();\n@@ -323,0 +362,5 @@\n+        if (mode.equals(\"large\")) {\n+            testSize_localLargeIntArray();\n+            testSize_localLargeObjArray();\n+        }\n+\n@@ -326,1 +370,1 @@\n-    private static int roundUp(int v, int a) {\n+    private static long roundUp(long v, long a) {\n@@ -331,1 +375,1 @@\n-        int expected = roundUp(8, OBJ_ALIGN);\n+        long expected = roundUp(8, OBJ_ALIGN);\n@@ -338,1 +382,1 @@\n-        int expected = roundUp(8, OBJ_ALIGN);\n+        long expected = roundUp(8, OBJ_ALIGN);\n@@ -348,1 +392,1 @@\n-        int expected = roundUp(8, OBJ_ALIGN);\n+        long expected = roundUp(8, OBJ_ALIGN);\n@@ -354,2 +398,2 @@\n-    private void testSize_newSmallByteArray() {\n-        int expected = roundUp(1024 + 16, OBJ_ALIGN);\n+    private void testSize_newSmallIntArray() {\n+        long expected = roundUp(4L*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -357,1 +401,1 @@\n-            assertEquals(expected, fInst.getObjectSize(new byte[1024]));\n+            assertEquals(expected, fInst.getObjectSize(new int[SMALL_ARRAY_SIZE]));\n@@ -361,3 +405,3 @@\n-    private void testSize_localSmallByteArray() {\n-        byte[] arr = new byte[1024];\n-        int expected = roundUp(arr.length + 16, OBJ_ALIGN);\n+    private void testSize_localSmallIntArray() {\n+        int[] arr = new int[SMALL_ARRAY_SIZE];\n+        long expected = roundUp(4L*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -369,1 +413,1 @@\n-    static byte[] smallArr = new byte[1024];\n+    static int[] smallArr = new int[SMALL_ARRAY_SIZE];\n@@ -371,2 +415,2 @@\n-    private void testSize_fieldSmallByteArray() {\n-        int expected = roundUp(smallArr.length + 16, OBJ_ALIGN);\n+    private void testSize_fieldSmallIntArray() {\n+        long expected = roundUp(4L*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -379,1 +423,1 @@\n-        int expected = roundUp(1024*REF_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -381,1 +425,1 @@\n-            assertEquals(expected, fInst.getObjectSize(new Object[1024]));\n+            assertEquals(expected, fInst.getObjectSize(new Object[SMALL_ARRAY_SIZE]));\n@@ -386,2 +430,2 @@\n-        Object[] arr = new Object[1024];\n-        int expected = roundUp(arr.length*REF_SIZE + 16, OBJ_ALIGN);\n+        Object[] arr = new Object[SMALL_ARRAY_SIZE];\n+        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -393,1 +437,1 @@\n-    static Object[] smallObjArr = new Object[1024];\n+    static Object[] smallObjArr = new Object[SMALL_ARRAY_SIZE];\n@@ -396,1 +440,1 @@\n-        int expected = roundUp(smallArr.length*REF_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -402,0 +446,16 @@\n+    private void testSize_localLargeIntArray() {\n+        int[] arr = new int[LARGE_INT_ARRAY_SIZE];\n+        long expected = roundUp(4L*LARGE_INT_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        for (int c = 0; c < ITERS; c++) {\n+            assertEquals(expected, fInst.getObjectSize(arr));\n+        }\n+    }\n+\n+    private void testSize_localLargeObjArray() {\n+        Object[] arr = new Object[LARGE_OBJ_ARRAY_SIZE];\n+        long expected = roundUp(REF_SIZE*LARGE_OBJ_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        for (int c = 0; c < ITERS; c++) {\n+            assertEquals(expected, fInst.getObjectSize(arr));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":87,"deletions":27,"binary":false,"changes":114,"status":"modified"}]}