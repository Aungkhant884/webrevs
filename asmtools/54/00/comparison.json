{"files":[{"patch":"@@ -88,1 +88,1 @@\n-        lastInstr = zeroInstr = new Instr(methodData.pool, environment);\n+        lastInstr = zeroInstr = new Instr(methodData, environment);\n@@ -323,1 +323,1 @@\n-        Instr newInstr = new Instr(methodData.pool, environment).set(curPC, environment.getPosition(), opcode, arg, arg2);\n+        Instr newInstr = new Instr(methodData, environment).set(curPC, environment.getPosition(), opcode, arg, arg2);\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/CodeAttr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import static org.openjdk.asmtools.asmutils.HexUtils.toHex;\n@@ -37,0 +38,5 @@\n+\n+    \/\/ References to Method's name,signature CP cells\n+    \/\/ that will be used to build a warning message while writing a binary if necessary\n+    private final ConstCell<?> nameCell, sigCell;\n+\n@@ -45,1 +51,1 @@\n-    public Instr(ConstantPool pool, JasmEnvironment environment) {\n+    public Instr(MethodData methodData, JasmEnvironment environment) {\n@@ -47,1 +53,4 @@\n-        this.pool = pool;\n+        this.pool = methodData.getPool();\n+        \/\/ for message purposes only\n+        this.nameCell = methodData.nameCell;\n+        this.sigCell = methodData.sigCell;\n@@ -62,1 +71,2 @@\n-            if( cell.ref == null || arg.cpIndex == 0) { \/\/ Corner case cell[0] has value but its reference is wrong\n+            if( cell.ref == null || arg.cpIndex == 0) {\n+                \/\/ Corner case cell[0] has value but its reference is wrong\n@@ -112,1 +122,1 @@\n-\/\/env.traceln(\"instr:\"+opcNamesTab[opc]+\" len=\"+opcLen+\" arg:\"+iarg);\n+                \/\/env.traceln(\"instr:\"+opcNamesTab[opc]+\" len=\"+opcLen+\" arg:\"+iarg);\n@@ -155,0 +165,6 @@\n+                        if(iarg > 0xff) {                   \/\/ unsigned byte\n+                            environment.warning(\"warn.instruction.operand.value.overflow\",\n+                                    getMethodSignature(), opc.parseKey(),\n+                                    toHex(iarg),\n+                                    \"unsigned 8-bit value 0xFF\");\n+                        }\n@@ -158,0 +174,6 @@\n+                        if( iarg > Short.MAX_VALUE ) {      \/\/ signed short\n+                            environment.warning(\"warn.instruction.operand.value.overflow\",\n+                                    getMethodSignature(), opc.parseKey(),\n+                                    toHex(iarg),\n+                                    \"signed 16-bit value \" + toHex(Short.MAX_VALUE));\n+                        }\n@@ -161,0 +183,6 @@\n+                        if( iarg > Short.MAX_VALUE ) {      \/\/ signed short\n+                            environment.warning(\"warn.instruction.operand.value.overflow\",\n+                                    getMethodSignature(), opc.parseKey(),\n+                                    toHex(iarg),\n+                                    \"signed 16-bit value \" + toHex(Short.MAX_VALUE));\n+                        }\n@@ -166,0 +194,6 @@\n+                        if( iarg > Integer.MAX_VALUE ) {    \/\/ signed int\n+                            environment.warning(\"warn.instruction.operand.value.overflow\",\n+                                    getMethodSignature(), opc.parseKey(),\n+                                    toHex(iarg),\n+                                    \"signed 32-bit value \" + toHex(Integer.MAX_VALUE));\n+                        }\n@@ -188,0 +222,1 @@\n+    }\n@@ -189,0 +224,7 @@\n+    \/**\n+     * @return the current method signature in the form \"MethodName\"\"MethodSignature\" like testMethod(II)V\n+     * for using in warning messages\n+     *\/\n+    private String getMethodSignature() {\n+        String res = this.nameCell.ref.value != null ? this.nameCell.ref.value.toString() : \"#\" + this.nameCell.cpIndex;\n+        return res + (this.sigCell.ref.value != null ? this.sigCell.ref.value.toString() : \":#\" + this.sigCell.cpIndex);\n@@ -190,1 +232,0 @@\n-} \/\/ end Instr\n@@ -192,0 +233,1 @@\n+} \/\/ end Instr\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/Instr.java","additions":48,"deletions":6,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -127,1 +127,0 @@\n-err.invalid.class.struct={0}_attribute structure accepts only class(es)\n@@ -146,1 +145,1 @@\n-warn.invalid.modifier.intmth.less.52=In a class file whose version number is less than 52.0, each method of interface must be abstract public only  {0}\n+warn.invalid.modifier.intmth.less.52=In a class file whose version number is less than 52.0, each method of interface must be abstract public only {0}\n@@ -152,0 +151,2 @@\n+#Code attribute\n+warn.instruction.operand.value.overflow={0} - The instruction ''{1}'' uses the argument {2} that exceeds allowed {3}\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/i18n.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}