{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-     * Parses the first argument and deligates execution to an appropriate tool\n+     * Parses the first argument and delegates execution to an appropriate tool\n","filename":"src\/org\/openjdk\/asmtools\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.stream.Collectors;\n@@ -40,1 +41,1 @@\n-    \/\/ placeholder - bootstrap_method_attr_index\n+    \/\/ methodAttrIndex - bootstrap_method_attr_index\n@@ -43,10 +44,1 @@\n-    protected BootstrapMethodData clone(int placeholder) {\n-        BootstrapMethodData instance = new BootstrapMethodData(this.bootstrapMethodHandle, arguments);\n-        instance.cpIndex = placeholder;\n-        return instance;\n-    }\n-\n-    \/\/ placeholder - bootstrap_method_attr_index\n-    \/\/ The value of the bootstrap_method_attr_index item must be a valid index into the bootstrap_methods array\n-    \/\/ of the bootstrap method table of this class file (ยง4.7.23).\n-    public BootstrapMethodData(int placeholder) {\n+    public BootstrapMethodData(int methodAttrIndex) {\n@@ -56,1 +48,1 @@\n-        this.cpIndex = placeholder;\n+        super.cpIndex = methodAttrIndex;\n@@ -63,1 +55,1 @@\n-    public boolean isPlaceholder() {\n+    public boolean hasMethodAttrIndex() {\n@@ -67,0 +59,8 @@\n+    public void setMethodAttrIndex(int methodAttrIndex) {\n+        super.cpIndex = methodAttrIndex;\n+    }\n+\n+    public int getMethodAttrIndex() {\n+        return super.cpIndex;\n+\n+    }\n@@ -76,0 +76,8 @@\n+    @Override\n+    public String toString() {\n+        return String.format(\"{MethodHandle:%s Arguments:%s}\",\n+                bootstrapMethodHandle == null || bootstrapMethodHandle.cpIndex == NotSet ? \" n\/a\" : \" #\" + bootstrapMethodHandle.cpIndex,\n+                arguments == null || arguments.isEmpty() ? \"{}\" :\n+                        \"{ \" + arguments.stream().map(a -> String.format(\"#%d\", a.cpIndex)).collect(Collectors.joining(\", \")) + \" }\");\n+    }\n+\n@@ -83,1 +91,1 @@\n-        return Objects.equals(arguments, that.arguments);\n+        return this.cpIndex == that.cpIndex & Objects.equals(arguments, that.arguments);\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/BootstrapMethodData.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n-import java.nio.file.FileSystems;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n@@ -39,0 +40,1 @@\n+import static org.openjdk.asmtools.jasm.Indexer.NotSet;\n@@ -151,1 +153,1 @@\n-     * this method links the Constant_InvokeDynamic Constant_Dynamic\n+     * this method links the Constant_InvokeDynamic|Constant_Dynamic\n@@ -156,18 +158,11 @@\n-        if (bootstrapMethodsAttr == null) {\n-            return;\n-        }\n-\n-        environment.traceln(\"relinkBootstrapMethods\");\n-\n-        for (ConstCell cell : pool) {\n-            ConstValue ref = null;\n-            if (cell != null) {\n-                ref = cell.ref;\n-            }\n-            if (ref != null\n-                    && (ref.tag == CONSTANT_INVOKEDYNAMIC || ref.tag == CONSTANT_DYNAMIC)) {\n-                \/\/ Find only the Constant\n-                ConstantPool.ConstValue_BootstrapMethod refval = (ConstantPool.ConstValue_BootstrapMethod) ref;\n-                BootstrapMethodData bsmdata = refval.bsmData();\n-                \/\/ only care about BSM Data that were placeholders\n-                if (bsmdata != null && bsmdata.isPlaceholder()) {\n+        if (bootstrapMethodsAttr != null) {\n+            ArrayList<ConstCell<?>> cells = pool.getPoolValuesByRefType(CONSTANT_INVOKEDYNAMIC, CONSTANT_DYNAMIC);\n+            environment.traceln(\"relinkBSMs: %d items\", cells.size());\n+            for (ConstCell<?> cell : cells) {\n+                ConstantPool.ConstValue_BootstrapMethod refVal = (ConstantPool.ConstValue_BootstrapMethod) cell.ref;\n+                BootstrapMethodData bsmData = refVal.bsmData();\n+                if (refVal.isSet() & refVal.value.ref == null) {\n+                    ConstCell c = pool.getCell(((ConstCell) refVal.value).cpIndex);\n+                    refVal.setValue(c);\n+                }\n+                if (bsmData != null && bsmData.hasMethodAttrIndex()) {\n@@ -175,7 +170,5 @@\n-                    int bsmindex = bsmdata.cpIndex;\n-                    if (bsmindex < 0 || bsmindex > bootstrapMethodsAttr.size()) {\n-                        \/\/ bad BSM index --\n-                        \/\/ give a warning, but place the index in the arg anyway\n-                        environment.traceln(\"Warning: (ClassData.relinkBootstrapMethods()): Bad bootstrapMethods index: \" + bsmindex);\n-                        \/\/ env.error(\"const.bsmindex\", bsmindex);\n-                        bsmdata.cpIndex = bsmindex;\n+                    int methodAttrIndex = bsmData.getMethodAttrIndex();\n+                    if (methodAttrIndex < 0 || methodAttrIndex > bootstrapMethodsAttr.size()) {\n+                        \/\/ bad BSM index - give a warning, but place the index in the arg anyway\n+                        environment.warning(\"warn.bootstrapmethod.attr.bad\", methodAttrIndex);\n+                        bsmData.setMethodAttrIndex(methodAttrIndex);\n@@ -184,1 +177,1 @@\n-                        refval.setBsmData(bootstrapMethodsAttr.get(bsmindex));\n+                        refVal.setBsmData(bootstrapMethodsAttr.get(methodAttrIndex), methodAttrIndex);\n@@ -191,23 +184,10 @@\n-    protected void numberBootstrapMethods() {\n-        environment.traceln(\"Numbering Bootstrap Methods\");\n-        if (bootstrapMethodsAttr == null) {\n-            return;\n-        }\n-        boolean duplicateExists = false;\n-        \/\/ remove duplicates in BootstrapMethod_Attribute if found\n-        \/\/ Fix 7902888: Excess entries in BootstrapMethods with the same bsm, bsmKind, bsmArgs\n-        ArrayList<ConstCell<?>> list = this.getPool().getPoolCellsByType(CONSTANT_DYNAMIC, CONSTANT_INVOKEDYNAMIC);\n-        BootstrapMethodData[] bsmAttributes = new BootstrapMethodData[list.size()];\n-        HashMap<BootstrapMethodData, Integer> bsmHashMap = new HashMap<>();\n-        int index = 0;\n-        \/\/\n-        for (int i = 0; i < list.size(); i++) {\n-            ConstantPool.ConstValue_BootstrapMethod cell = (ConstantPool.ConstValue_BootstrapMethod) list.get(i).ref;\n-            BootstrapMethodData bsmData = ((ConstantPool.ConstValue_BootstrapMethod) list.get(i).ref).bsmData();\n-            if (bsmHashMap.keySet().contains(bsmData)) {\n-                duplicateExists = true;\n-                cell.setBsmData(bsmAttributes[bsmHashMap.get(bsmData)]);\n-            } else {\n-                bsmAttributes[i] = bsmData.clone(index++);\n-                cell.setBsmData(bsmAttributes[i]);\n-                bsmHashMap.put(bsmData, i);\n+    \/**\n+     * Finds first BSM data element by value in a collection\n+     *\/\n+    private <T extends Collection<BootstrapMethodData>> int getFirstIndex(T collection, BootstrapMethodData bsmData) {\n+        if (!collection.isEmpty()) {\n+            BootstrapMethodData[] array = collection.toArray(BootstrapMethodData[]::new);\n+            for (int i = 0; i < array.length; i++) {\n+                if (bsmData.equalsByValue(array[i])) {\n+                    return i;\n+                }\n@@ -216,2 +196,36 @@\n-        if( duplicateExists ) {\n-            bootstrapMethodsAttr.replaceAll(Arrays.stream(bsmAttributes).filter(i -> i != null).toList());\n+        return NotSet;\n+    }\n+\n+    \/**\n+     * Relinks BSM data (BootstrapMethod Attribute) and Constant Pool Constant_InvokeDynamic|Constant_Dynamic entries if\n+     * at least one CP cell has undefined method attribute index also the method removes duplicates in BootstrapMethod\n+     * Attribute if found\n+     *\/\n+    private void uniquifyBootstrapMethods() {\n+        if (bootstrapMethodsAttr != null) {\n+            int index = 0;\n+            final List<BootstrapMethodData> cpBsmList = this.getPool().\n+                    getPoolCellsByType(CONSTANT_DYNAMIC, CONSTANT_INVOKEDYNAMIC).\n+                    stream().map(item -> ((ConstantPool.ConstValue_BootstrapMethod) item.ref).\n+                            bsmData()).toList();\n+            if (cpBsmList.stream().anyMatch(item -> !item.hasMethodAttrIndex())) {\n+                environment.traceln(\"numberBSM: %d items\", cpBsmList.size());\n+                \/\/ remove duplicates in BootstrapMethod_Attribute if found\n+                \/\/ Fix 7902888: Excess entries in BootstrapMethods with the same bsm, bsmKind, bsmArgs\n+                final ArrayList<BootstrapMethodData> newBsmList = new ArrayList<>(cpBsmList.size());\n+                for (int i = 0; i < cpBsmList.size(); i++) {\n+                    BootstrapMethodData bsmData = cpBsmList.get(i);\n+                    int cachedIndex = getFirstIndex(newBsmList, bsmData);\n+                    if (cachedIndex != NotSet) {\n+                        bsmData.setMethodAttrIndex(cachedIndex);\n+                    } else {\n+                        if (getFirstIndex(this.bootstrapMethodsAttr, bsmData) == NotSet) {\n+                            environment.warning(\"warn.bootstrapmethod.attr.expected\", bsmData.toString());\n+                        } else {\n+                            bsmData.setMethodAttrIndex(index++);\n+                        }\n+                        newBsmList.add(bsmData);\n+                    }\n+                }\n+                bootstrapMethodsAttr.replaceAll(newBsmList);\n+            }\n@@ -311,1 +325,0 @@\n-        environment.traceln(\"addBootstrapMethod\");\n@@ -316,0 +329,1 @@\n+        environment.traceln(\"addBootstrapMethod: \" + bsmData.toString());\n@@ -348,1 +362,1 @@\n-                        addAll(fields.stream().map(f->f.getInitialValue())),\n+                        addAll(fields.stream().map(f -> f.getInitialValue())),\n@@ -350,1 +364,1 @@\n-        numberBootstrapMethods();\n+        uniquifyBootstrapMethods();\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ClassData.java","additions":71,"deletions":57,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -47,0 +47,5 @@\n+    public ConstValue<T> setValue(T value) {\n+        this.value = value;\n+        return this;\n+    }\n+\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ConstValue.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Consumer;\n@@ -176,4 +177,3 @@\n-        \/\/ used to fix CP refs when a constant pool is constructed by refs alone.\n-        environment.traceln(\"Fixing CP for explicit Constant Entries.\");\n-        \/\/ simply iterate through the pool.\n-        environment.traceln(\"fixRefsInPool %d items\", pool.size());\n+        \/\/ Simply iterating through the pool the method is used to fix CP refs\n+        \/\/ when a constant pool is constructed by refs alone.\n+        environment.traceln(\"fixRefsInPool: Fixing CP for %d explicit Constant Entries\", pool.size());\n@@ -189,4 +189,3 @@\n-        \/\/ used to fix CP Indexes when a constant pool is constructed by values alone.\n-        environment.traceln(\"Fixing CP for explicit Constant Entries.\");\n-        \/\/ simply iterate through the pool.\n-        environment.traceln(\"fixIndexesInPool %d items\", pool.size());\n+        \/\/ Simply iterate through the pool the method is used to fix CP Indexes\n+        \/\/ when a constant pool is constructed by values alone.\n+        environment.traceln(\"fixIndexesInPool: Fixing CP for %d explicit Constant Entries.\", pool.size());\n@@ -217,1 +216,0 @@\n-     *\n@@ -311,1 +309,0 @@\n-                environment.traceln(\"setCell: new ConstCell\");\n@@ -313,0 +310,1 @@\n+                environment.traceln(\"setCell: new ConstCell %s\", cell.toString());\n@@ -496,0 +494,5 @@\n+    public ArrayList<ConstCell<?>> getPoolValuesByRefType(ClassFileConst.ConstType... types) {\n+        return pool.stream().filter(c->c.ref != null && c.getType().oneOf(types)).\n+                collect(Collectors.toCollection(ArrayList::new));\n+    }\n+\n@@ -881,0 +884,5 @@\n+        public void setBsmData(BootstrapMethodData bsmData, int methodAttrIndex) {\n+            this.bsmData = bsmData;\n+            this.bsmData.cpIndex = methodAttrIndex;\n+        }\n+\n@@ -930,1 +938,1 @@\n-     * that is produced by invocation of a bootstrap method in the course of an ldc instruction, among others.\n+     * that is produced by invocation of a bootstrap method in the course of a ldc instruction, among others.\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ConstantPool.java","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-class DataVectorAttr<T extends DataWriter> extends AttrData implements Iterable<T> {\n+class DataVectorAttr<T extends DataWriter> extends AttrData implements Collection<T> {\n@@ -75,3 +75,33 @@\n-    public void add(T element) {\n-        if (element != null)\n-            elements.add(element);\n+    @Override\n+    public boolean add(T element) {\n+        return elements.add(element);\n+    }\n+\n+    @Override\n+    public boolean remove(Object o) {\n+        return elements.remove(o);\n+    }\n+\n+    @Override\n+    public boolean containsAll(Collection<?> c) {\n+        return elements.containsAll(c);\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends T> c) {\n+        return elements.addAll(c);\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> c) {\n+        return elements.removeAll(c);\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> c) {\n+        return elements.retainAll(c);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        elements.clear();\n@@ -85,2 +115,2 @@\n-    public void put(int i, T element) {\n-        elements.set(i, element);\n+    public T set(int i, T element) {\n+        return elements.set(i, element);\n@@ -91,0 +121,10 @@\n+    @Override\n+    public boolean isEmpty() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean contains(Object o) {\n+        return false;\n+    }\n+\n@@ -105,0 +145,12 @@\n+    @Override\n+    public Object[] toArray() {\n+        return elements.toArray();\n+    }\n+\n+    @Override\n+    public <V> V[] toArray(V[] a) {\n+        return elements.toArray(a);\n+    }\n+\n+    public Stream<T> stream() { return elements.stream(); };\n+\n@@ -126,1 +178,0 @@\n-\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/DataVectorAttr.java","additions":58,"deletions":7,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n@@ -89,0 +91,22 @@\n+    \/**\n+     * Deprecated method to support external tools having it\n+     *\n+     * @param ref      A stream to which to write reference output\n+     * @param toolName the tool's name (ignored)\n+     *\/\n+    @Deprecated\n+    public Main(PrintWriter ref, String toolName) {\n+        super(new ToolOutput.PrintWriterOutput(ref));\n+    }\n+\n+    \/**\n+     * Deprecated method to support external tools having it\n+     *\n+     * @param out      A stream to which to write reference output\n+     * @param toolName the tool's name (ignored)\n+     *\/\n+    @Deprecated\n+    public Main(PrintStream out, String toolName) {\n+        this(new PrintWriter(out), toolName);\n+    }\n+\n@@ -95,0 +119,6 @@\n+    \/\/ Run jasm compiler with args\n+    public synchronized boolean compile(String... argv) {\n+        parseArgs(argv);\n+        return this.compile() == OK;\n+    }\n+\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/Main.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-        methodParameters.put(paramNum, new MethodParameterData(access, name));\n+        methodParameters.set(paramNum, new MethodParameterData(access, name));\n@@ -211,1 +211,0 @@\n-\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/MethodData.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-    private void parseConstDef() throws IOException {\n+    private void parseConstDef() {\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/Parser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,0 +174,3 @@\n+warn.bootstrapmethod.attr.bad=Bad bootstrap method attribute index {0}\n+warn.bootstrapmethod.attr.expected=Invoke dynamic \\\"{0}\\\" has undefined method attribute index\n+\n@@ -223,1 +226,1 @@\n-err.invalid.type=Invalid type of Constant Pool Constant {0}\n\\ No newline at end of file\n+err.invalid.type=Invalid type of Constant Pool Constant {0}\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/i18n.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n@@ -75,0 +77,22 @@\n+    \/**\n+     * Deprecated method to support external tools having it\n+     *\n+     * @param ref      A stream to which to write reference output\n+     * @param toolName the tool's name (ignored)\n+     *\/\n+    @Deprecated\n+    public Main(PrintWriter ref, String toolName) {\n+        super(new ToolOutput.PrintWriterOutput(ref));\n+    }\n+\n+    \/**\n+     * Deprecated method to support external tools having it\n+     *\n+     * @param out      A stream to which to write reference output\n+     * @param toolName the tool's name (ignored)\n+     *\/\n+    @Deprecated\n+    public Main(PrintStream out, String toolName) {\n+        this(new PrintWriter(out), toolName);\n+    }\n+\n@@ -93,0 +117,6 @@\n+    \/\/ Run jcoder compiler with args\n+    public synchronized boolean compile(String... argv) {\n+        parseArgs(argv);\n+        return this.compile() == OK;\n+    }\n+\n","filename":"src\/org\/openjdk\/asmtools\/jcoder\/Main.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}