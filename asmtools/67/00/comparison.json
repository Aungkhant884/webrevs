{"files":[{"patch":"@@ -156,0 +156,8 @@\n+    <tr>\n+      <td>\n+        <a href=\"https:\/\/bugs.openjdk.org\/browse\/CODETOOLS-7903558\">CODETOOLS-7903558<\/a>\n+      <\/td>\n+      <td>\n+        jasm: Add support this_class, super_class value(s)\n+      <\/td>\n+    <\/tr>\n","filename":"README.html","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-PRODUCT_BUILDNUMBER = 08\n+PRODUCT_BUILDNUMBER = 09\n","filename":"build\/productinfo.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import org.openjdk.asmtools.asmutils.Pair;\n@@ -30,1 +31,3 @@\n-import java.io.*;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n@@ -36,0 +39,1 @@\n+import static org.openjdk.asmtools.jasm.ClassData.CoreClasses.PLACE.HEADER;\n@@ -57,1 +61,0 @@\n-    ConstCell<?> this_class, super_class;\n@@ -59,0 +62,2 @@\n+    \/\/ Core classes of the class file: this_class, super_class\n+    CoreClasses coreClasses = new CoreClasses();\n@@ -60,1 +65,0 @@\n-\n@@ -62,1 +66,0 @@\n-\n@@ -105,2 +108,2 @@\n-        this.this_class = this_class;\n-        this.super_class = super_class;\n+        this.coreClasses.this_class(HEADER, this_class);\n+        this.coreClasses.super_class(HEADER, super_class);\n@@ -123,1 +126,1 @@\n-        this.super_class = new ConstCell(0);\n+        this.coreClasses.super_class(HEADER, new ConstCell(0));\n@@ -169,1 +172,1 @@\n-                    ConstCell c = pool.getCell(((ConstCell) refVal.value).cpIndex);\n+                    ConstCell<?> c = pool.getCell(((ConstCell<?>) refVal.value).cpIndex);\n@@ -319,1 +322,1 @@\n-        return pool.findCell(ConstType.CONSTANT_METHODREF, this_class, pool.findCell(nape));\n+        return pool.findCell(ConstType.CONSTANT_METHODREF, coreClasses.this_class(), pool.findCell(nape));\n@@ -367,2 +370,2 @@\n-        if (super_class == null) {\n-            super_class = pool.findClassCell(\"java\/lang\/Object\");\n+        if (coreClasses.super_class() == null) {\n+            coreClasses.super_class(pool.findClassCell(\"java\/lang\/Object\"));\n@@ -371,2 +374,2 @@\n-        super_class = pool.specifyCell(super_class);\n-        this_class = pool.specifyCell(this_class);\n+        coreClasses.specifyClasses(pool);\n+        coreClasses.cleanConstantPool(pool);\n@@ -380,5 +383,4 @@\n-            ConstantPool.ConstValue_Class this_class_value = (ConstantPool.ConstValue_Class) this_class.ref;\n-            ConstantPool.ConstValue_UTF8 this_class_name = this_class_value.value.ref;\n-            myClassName = this_class_name.value;\n-            environment.traceln(\"this_class  = \" + this_class);\n-            environment.traceln(\"super_class = \" + super_class);\n+            myClassName = coreClasses.getFileName();\n+            environment.traceln(\"ClassFileName = \" + myClassName);\n+            environment.traceln(\"this_class    = \" + coreClasses.this_class());\n+            environment.traceln(\"super_class   = \" + coreClasses.super_class());\n@@ -401,1 +403,1 @@\n-        this.this_class = pool.findClassCell(this.myClassName);\n+        coreClasses.this_class(pool.findClassCell(this.myClassName));\n@@ -403,1 +405,1 @@\n-        this.super_class = pool.findClassCell(\"java\/lang\/Object\");\n+        coreClasses.super_class(pool.findClassCell(\"java\/lang\/Object\"));\n@@ -405,2 +407,2 @@\n-        super_class = pool.specifyCell(super_class);\n-        this_class = pool.specifyCell(this_class);\n+        coreClasses.super_class(pool.specifyCell(coreClasses.super_class()));\n+        coreClasses.this_class(pool.specifyCell(coreClasses.this_class()));\n@@ -413,1 +415,1 @@\n-        this.this_class = pool.findClassCell(this.myClassName);\n+        coreClasses.this_class(pool.findClassCell(this.myClassName));\n@@ -415,1 +417,1 @@\n-        this_class = pool.specifyCell(this_class);\n+        coreClasses.this_class(pool.specifyCell(coreClasses.this_class()));\n@@ -424,1 +426,1 @@\n-     *    It applies to DataVectorAttr<AnnotationData>\n+     * It applies to DataVectorAttr<AnnotationData>\n@@ -426,2 +428,2 @@\n-     *    assigns their cpIndexes instead of  undefined indexes.\n-     *    It works for DataVectorAttr<?>\n+     * assigns their cpIndexes instead of  undefined indexes.\n+     * It works for DataVectorAttr<?>\n@@ -433,2 +435,2 @@\n-            if( attributes != null ) {\n-                if ( attributes instanceof DataVectorAttr<?>) {\n+            if (attributes != null) {\n+                if (attributes instanceof DataVectorAttr<?>) {\n@@ -436,2 +438,2 @@\n-                            map(e->(ConstantPoolDataVisitor)e).forEach(v->v.visit(pool));\n-                } else if( attributes instanceof AttrData ) {\n+                            map(e -> (ConstantPoolDataVisitor) e).forEach(v -> v.visit(pool));\n+                } else if (attributes instanceof AttrData) {\n@@ -466,2 +468,2 @@\n-        out.writeShort(this_class.cpIndex);\n-        out.writeShort(super_class.cpIndex);\n+        out.writeShort(coreClasses.this_class().cpIndex);\n+        out.writeShort(coreClasses.super_class().cpIndex);\n@@ -686,0 +688,115 @@\n+\n+    \/**\n+     * Container holds 2 pairs of core classes: this_class, super_class, and functionality to get output file name.\n+     *  jasm supports the values:\n+     *  [CLASS_MODIFIERS] class|interface CLASSNAME [ extends SUPERCLASSNAME ] { \/\/ HEADER\n+     *  this_class[:]  (#ID | IDENT); \/\/ CLASSNAME                                  CLASSFILE\n+     *  super_class[:] (#ID | IDENT); \/\/ SUPERCLASSNAME                             CLASSFILE\n+     *\/\n+    public static class CoreClasses {\n+        public enum PLACE {\n+            \/\/ A place where this_class, super_class pair is defined.\n+            HEADER, CLASSFILE\n+        }\n+\n+        private String fileName;\n+\n+        \/\/ This and Super classes  are defined on the top in the header:\n+        \/\/ [CLASS_MODIFIERS] class|interface CLASSNAME [ extends SUPERCLASSNAME ] { \/\/ HEADER\n+        \/\/\n+        \/\/ public super class #11 extends #14 version 66:0\n+        \/\/ public super class package\/ClassName extends package\/SuperClassName version 66:0\n+        Pair<ConstCell<?>, ConstCell<?>> header = new Pair<>(null, null);\n+        \/\/ This and Super classes are defined in a class file:\n+        \/\/ this_class[:]  (#ID | IDENT);    \/\/ CLASSNAME                               CLASSFILE\n+        \/\/ super_class[:] (#ID | IDENT);   \/\/ SUPERCLASSNAME                           CLASSFILE\n+        \/\/\n+        \/\/ this_class  #7;                 \/\/ package\/ClassName\n+        \/\/ super_class java\/lang\/Object;   \/\/ java\/lang\/Object\n+        Pair<ConstCell<?>, ConstCell<?>> classfile = new Pair<>(null, null);\n+\n+        public void this_class(PLACE where, ConstCell<?> this_class) {\n+            if (where == PLACE.CLASSFILE) {\n+                classfile.first = this_class;\n+            } else {\n+                header.first = this_class;\n+            }\n+        }\n+\n+        public void super_class(PLACE where, ConstCell<?> super_class) {\n+            if (where == PLACE.CLASSFILE) {\n+                classfile.second = super_class;\n+            } else {\n+                header.second = super_class;\n+            }\n+        }\n+\n+        public void this_class(ConstCell<?> this_class) {\n+            if (classfile.first != null) {\n+                classfile.first = this_class;\n+            } else {\n+                header.first = this_class;\n+            }\n+        }\n+\n+        public void super_class(ConstCell<?> super_class) {\n+            if (classfile.second != null) {\n+                classfile.second = super_class;\n+            } else {\n+                header.second = super_class;\n+            }\n+        }\n+\n+        public ConstCell<?> this_class() {\n+            return (classfile.first != null) ? classfile.first : header.first;\n+        }\n+\n+        public ConstCell<?> super_class() {\n+            return (classfile.second != null) ? classfile.second : header.second;\n+        }\n+\n+        public String getFileName() {\n+            if (fileName == null) {\n+                fileName = calculateFileName();\n+            }\n+            return fileName;\n+        }\n+\n+        private String calculateFileName() {\n+            if (header.first != null) {\n+                ConstantPool.ConstValue_Class this_class_value = (ConstantPool.ConstValue_Class) header.first.ref;\n+                ConstantPool.ConstValue_UTF8 this_class_name = this_class_value.value.ref;\n+                this.fileName = this_class_name.value;\n+                return this_class_name.value;\n+            }\n+            return null;\n+        }\n+\n+        \/**\n+         * If jasm file contains this_class\/super_class value then this value overwrites the class\/super class defined on the top:\n+         * \"public super class ClassName extends #9 version 66:0 {\"\n+         * ie just added to ConstantPool classes: ClassName && #9 should be removed\n+         *\n+         * @param constantPool constant pool\n+         *\/\n+        public void cleanConstantPool(ConstantPool constantPool) {\n+            if (classfile.first != null && classfile.first.cpIndex != header.first.cpIndex) {\n+                calculateFileName();\n+                constantPool.removeClassCell((ConstCell<ConstantPool.ConstValue_Class>)header.first);\n+            }\n+            if (classfile.second != null && header.second != null &&\n+                    classfile.second.cpIndex != header.second.cpIndex) {\n+                constantPool.removeClassCell((ConstCell<ConstantPool.ConstValue_Class>)header.second);\n+            }\n+        }\n+        public void specifyClasses(ConstantPool constantPool) {\n+            if (header.first != null)\n+                header.first = constantPool.specifyCell(header.first);\n+            if (header.second != null)\n+                header.second = constantPool.specifyCell(header.second);\n+            if (classfile.first != null)\n+                classfile.first = constantPool.specifyCell(classfile.first);\n+            if (classfile.second != null)\n+                classfile.second = constantPool.specifyCell(classfile.second);\n+        }\n+    }\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ClassData.java","additions":150,"deletions":33,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+    \/\/ status flag\n+    private int flag;\n@@ -50,0 +52,8 @@\n+    public int getFlag() {\n+        return flag;\n+    }\n+    public ConstCell<V> setFlag(int flag) {\n+        this.flag = flag;\n+        return this;\n+    }\n+\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ConstCell.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+    static final int PROCESSED = 2;\n+    static final int NON_PROCESSED = 0;\n+\n@@ -278,0 +281,44 @@\n+    private void delete(int cpx) {\n+        environment.traceln(\"delete cell(\" + cpx + \")\");\n+        Consumer<ConstCell<?>> op = cell -> {\n+            if (cell.getFlag() == NON_PROCESSED) {\n+                if (cell.cpIndex > cpx) {\n+                    cell.cpIndex--;\n+                    environment.traceln(\"\\tcell from \" + (cell.cpIndex + 1) + \" to \" + cell);\n+                }\n+                cell.setFlag(PROCESSED);\n+            }\n+        };\n+        for (int i = 1; i < pool.size(); i++) {\n+            if (i != cpx) {\n+                ConstCell<?> constCell = uncheckedGetCell(i);\n+                this.traverseConstantCell(constCell, op);\n+            }\n+        }\n+        pool.remove(cpx);\n+        pool.forEach(cell -> cell.setFlag(NON_PROCESSED));\n+    }\n+\n+    private void traverseConstantCell(ConstCell<?> constCell, Consumer<ConstCell<?>> op) {\n+        if (constCell != null && constCell instanceof ConstCell<?>) {\n+            if (constCell instanceof ConstCell) {\n+                if (op != null)\n+                    op.accept(constCell);\n+                ConstValue<?> constValue = constCell.ref;\n+                if (constValue != null) {\n+                    switch (constValue.tag) {\n+                        case CONSTANT_CLASS, CONSTANT_STRING, CONSTANT_MODULE, CONSTANT_PACKAGE, CONSTANT_METHODTYPE,\n+                                CONSTANT_DYNAMIC, CONSTANT_INVOKEDYNAMIC -> {\n+                            traverseConstantCell((ConstCell<?>) constValue.value, op);\n+                        }\n+                        case CONSTANT_METHODHANDLE, CONSTANT_NAMEANDTYPE, CONSTANT_FIELDREF, CONSTANT_METHODREF, CONSTANT_INTERFACEMETHODREF -> {\n+                            Pair<ConstCell<?>, ConstCell<?>> pair = (Pair<ConstCell<?>, ConstCell<?>>) constValue.value;\n+                            traverseConstantCell(pair.first, op);\n+                            traverseConstantCell(pair.second, op);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -319,1 +366,1 @@\n-            if(   getBounds().in(cell.cpIndex) ) {\n+            if (getBounds().in(cell.cpIndex)) {\n@@ -490,2 +537,2 @@\n-    public ArrayList<ConstCell<?>>  getPoolCellsByType(ClassFileConst.ConstType... types) {\n-    return pool.stream().filter(c->c.getType().oneOf(types)).collect(Collectors.toCollection(ArrayList::new));\n+    public ArrayList<ConstCell<?>> getPoolCellsByType(ClassFileConst.ConstType... types) {\n+        return pool.stream().filter(c -> c.getType().oneOf(types)).collect(Collectors.toCollection(ArrayList::new));\n@@ -495,1 +542,1 @@\n-        return pool.stream().filter(c->c.ref != null && c.getType().oneOf(types)).\n+        return pool.stream().filter(c -> c.ref != null && c.getType().oneOf(types)).\n@@ -499,0 +546,37 @@\n+    \/**\n+     * Removes ClassCell entry from the Constant Pool\n+     *\n+     * @param cell the Constant Pool cell ConstCell<ConstValue_Class>\n+     *\/\n+    public void removeClassCell(ConstCell<ConstValue_Class> cell) {\n+        int indCls, indUtf8 = 0;\n+        if (cell != null) {\n+            if (cell.getType() == CONSTANT_CLASS) {\n+                if (cell.ref != null) {\n+                    ConstCell<ConstValue_UTF8> utf8Cell = cell.ref.value;\n+                    if (!isAllowedToBeDelete(utf8Cell))\n+                        return;\n+                    indUtf8 = utf8Cell.cpIndex;\n+                }\n+                indCls = cell.cpIndex;\n+                this.delete(indCls);\n+                this.delete(indCls > indUtf8 ? indUtf8 : indUtf8 - 1);\n+            } else {\n+                environment.warning(\"warn.cannot.delete.class.cell\", cell);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * @return true if the class name belongs to JDK public API\n+     *\/\n+    private boolean isAllowedToBeDelete(ConstCell<ConstValue_UTF8> utf8Cell) {\n+        if (utf8Cell.ref.value != null) {\n+            String className = utf8Cell.ref.value;\n+            if (className.startsWith(\"java\/\") || className.startsWith(\"javax\/\"))\n+                \/\/  className.startsWith(\"jdk\/\") || className.startsWith(\"com\/sun\/tools\/\") || className.startsWith(\"org\/w3c\"))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ConstantPool.java","additions":88,"deletions":4,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -260,0 +260,3 @@\n+\n+        THIS_CLASS          (85, \"this_class\",  \"this_class\",      EnumSet.of(TokenType.DECLARATION), KeywordType.KEYWORD),\n+        SUPER_CLASS         (86, \"super_class\", \"super_class\",     EnumSet.of(TokenType.DECLARATION), KeywordType.KEYWORD),\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/JasmTokens.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import static org.openjdk.asmtools.jasm.ClassData.CoreClasses.PLACE.CLASSFILE;\n@@ -305,1 +306,1 @@\n-        environment.error(scanner.pos, \"err.name.expected\", scanner.token);\n+        environment.error(scanner.pos, \"err.name.expected\", \"\\\"\" + scanner.token + \"\\\"\");\n@@ -971,0 +972,14 @@\n+    \/**\n+     *  Parse class reference used by statements:\n+     *  this_class[:]    (CPINDEX | STRING);\n+     *  super_class[:]   (CPINDEX | STRING);\n+     *\/\n+    private void parseClassRef(Consumer<ConstCell<?>> consumer) {\n+        traceMethodInfoLn(\"Begin\");\n+        if( scanner.token == COLON ) {\n+            scanner.scan();\n+        }\n+        ConstCell nm = cpParser.parseConstRef(ConstType.CONSTANT_CLASS, null, true);\n+        consumer.accept(nm);\n+    }\n+\n@@ -1468,1 +1483,3 @@\n-                case STRINGVAL -> fileExtension = scanner.stringValue;\n+                \/\/ CLASS token added to allow:\n+                \/\/ class ClassName.class version 45:0 {..}\n+                case STRINGVAL, CLASS -> fileExtension = scanner.stringValue;\n@@ -1471,1 +1488,1 @@\n-                    environment.error(scanner.pos, \"err.name.expected\");\n+                    environment.error(scanner.pos, \"err.name.expected\", \"\\\"\" + scanner.token.parseKey() + \"\\\"\");\n@@ -1478,1 +1495,1 @@\n-            environment.error(scanner.prevPos, \"err.token.expected\", OPEN.parseKey());\n+            environment.error(scanner.prevPos, \"err.token.expected\", \"\\\"\" + OPEN.parseKey() + \"\\\"\");\n@@ -1663,1 +1680,1 @@\n-            environment.error(scanner.pos, \"err.name.expected\");\n+            environment.error(scanner.pos, \"err.name.expected\", \"\\\"\" + scanner.token + \"\\\"\");\n@@ -1967,0 +1984,11 @@\n+                case THIS_CLASS -> {\n+                    scanner.scan();\n+                    parseClassRef(constCell -> classData.coreClasses.this_class(CLASSFILE, constCell));\n+                    scanner.expect(SEMICOLON);\n+                }\n+                case SUPER_CLASS -> {\n+                    scanner.scan();\n+                    parseClassRef(constCell -> classData.coreClasses.super_class(CLASSFILE, constCell));\n+                    scanner.expect(SEMICOLON);\n+                }\n+                \/\/\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/Parser.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -503,2 +503,3 @@\n-                    if (parser.classData.this_class.isSet() || parser.classData.this_class.ref == null) {\n-                        ClassCell = (ConstCell<ConstValue_Class>) parser.classData.this_class;\n+                    if (parser.classData.coreClasses.this_class().isSet() ||\n+                            parser.classData.coreClasses.this_class().ref == null) {\n+                        ClassCell = (ConstCell<ConstValue_Class>) parser.classData.coreClasses.this_class();\n@@ -506,1 +507,1 @@\n-                        ClassCell = parser.pool.findCell((ConstValue_Class) parser.classData.this_class.ref);\n+                        ClassCell = parser.pool.findCell((ConstValue_Class) parser.classData.coreClasses.this_class().ref);\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ParserCP.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-err.value.expected=Value expected near {0}\n+err.value.expected=Value expected near \\\"{0}\\\"\n@@ -82,0 +82,1 @@\n+warn.cannot.delete.class.cell=Cannot delete Constant Pool entry \\\"{0}\\\" because only class cells are accepted\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/i18n.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-                environment.error(scanner.prevPos, \"err.name.expected\");\n+                environment.error(scanner.prevPos, \"err.name.expected\", \"\\\"\" + scanner.token.parsekey() + \"\\\"\");\n","filename":"src\/org\/openjdk\/asmtools\/jcoder\/Jcoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        org.openjdk.asmtools.jasm.Main jasm = new org.openjdk.asmtools.jasm.Main(output, log, file, \"-v\");\n+        org.openjdk.asmtools.jasm.Main jasm = new org.openjdk.asmtools.jasm.Main(output, log, file, \"-v\", \"-nowarn\");\n","filename":"test\/java\/org\/openjdk\/asmtools\/jasm\/MultipleFilesInSingleJasmTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static org.openjdk.asmtools.lib.action.EAsmTools.Tool.TOOL_PASSED;\n+\n@@ -38,1 +40,1 @@\n-    final int TOOL_PASSED = 0;\n+\n","filename":"test\/java\/org\/openjdk\/asmtools\/jasm\/case7903405\/NegativeJasmTests.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.jasm.case7903558;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.openjdk.asmtools.lib.LogAndTextResults;\n+import org.openjdk.asmtools.lib.action.CompileAction;\n+import org.openjdk.asmtools.lib.action.GenerateAction;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static org.openjdk.asmtools.lib.action.EAsmTools.Tool.TOOL_PASSED;\n+\n+\/**\n+ * This is the test for the issue CODETOOLS-7903558 (https:\/\/bugs.openjdk.org\/browse\/CODETOOLS-7903558)\n+ * \"jasm: add support this_class, super_class value(s)\"\n+ * <p>\n+ * asm tool should support the values:\n+ * this_class[:]  (#ID | IDENT); \/\/ CLASSNAME\n+ * super_class[:] (#ID | IDENT); \/\/ SUPERCLASSNAME\n+ * <p>\n+ * Then the command `java -jar asmtools.jar jasm -d . FILE.jasm` where the jasm file is as follows:\n+ * class FILENAME.data {\n+ * this_class CLASSNAME;\n+ * super_class SUPERCLASSNAME;\n+ * }\n+ * will produce a binary file `FILENAME.data` which, after decompiling (`java -jar asmtools.jar jdis FILENAME.data`), will be:\n+ * <p>\n+ * super class CLASSNAME extends SUPERCLASSNAME version 45:0 {}\n+ *\/\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class Tests {\n+    private CompileAction compiler;\n+    private GenerateAction generator;\n+    private File resourceDir;\n+    private File resultDir;\n+\n+    private static Stream<Arguments> getTestParameters() {\n+        return Stream.of(\n+                \/\/ Detailed jasm\n+                Arguments.of(\"JasmFile01.g.jasm\", \"FileName01.class\", \"ClassName01 extends java\/lang\/String\"),\n+                Arguments.of(\"JasmFile02.g.jasm\", \"FileName02.data\", \"ClassName02 extends java\/lang\/String\"),\n+                Arguments.of(\"JasmFile03.g.jasm\", \"FileName03.class\", \"ClassName03 extends package\/SuperClassName03\"),\n+                Arguments.of(\"JasmFile04.g.jasm\", \"FileName04.obj\", \"ClassName04 extends package\/SuperClassName04\"),\n+                \/\/ short version\n+                Arguments.of(\"JasmFile01.jasm\", \"FileName01.class\", \"ClassName01 extends java\/lang\/String\"),\n+                Arguments.of(\"JasmFile02.jasm\", \"FileName02.data\", \"ClassName02 extends java\/lang\/String\"),\n+                Arguments.of(\"JasmFile03.jasm\", \"FileName03.class\", \"ClassName03 extends package\/SuperClassName03\"),\n+                Arguments.of(\"JasmFile04.jasm\", \"FileName04.obj\", \"ClassName04 version\")\n+        );\n+    }\n+\n+    @BeforeAll\n+    public void init() throws IOException {\n+        resultDir = Files.createTempDirectory(\"JdisJasmWorks\").toFile();\n+        resultDir.deleteOnExit();\n+        resourceDir = new File(this.getClass().getResource(\"JasmFile01.g.jasm\").getFile()).getParentFile();\n+        compiler = new CompileAction();\n+        compiler.setToolArgs(\"-d\", resultDir.getAbsolutePath());\n+        generator = new GenerateAction();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getTestParameters\")\n+    public void moduleInfoTest(String resourceName, String outputFileName, String jasmSubString) {\n+        \/\/ jasm to class on the disk\n+        compiler.getJasmResult(List.of(resourceDir + File.separator + resourceName));\n+        Path resultPath = Path.of(resultDir + File.separator + outputFileName);\n+        Assertions.assertTrue(Files.exists(resultPath), format(\"Result file not found: %s%n\", resultPath));\n+        \/\/ class to jasm\n+        LogAndTextResults textResult = generator.getJdisResult(List.of(resultPath.toString()));\n+        Assertions.assertEquals(textResult.result, TOOL_PASSED);\n+        \/\/ expected substrings\n+        String str = textResult.output.toString().substring(0, 80);\n+        Assertions.assertTrue(str.contains(jasmSubString), format(\"%s not found in %s%n\", jasmSubString, str));\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/asmtools\/jasm\/case7903558\/Tests.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -69,0 +69,2 @@\n+        int TOOL_PASSED = 0;\n+\n","filename":"test\/java\/org\/openjdk\/asmtools\/lib\/action\/EAsmTools.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+public super class FileName01.class version 66:0\n+{\n+  const #1  = Method      #2.#3;          \/\/ java\/lang\/Object.\"<init>\":\"()V\"\n+  const #2  = class       #4;             \/\/ java\/lang\/Object\n+  const #3  = NameAndType #5:#6;          \/\/ \"<init>\":\"()V\"\n+  const #4  = Utf8        \"java\/lang\/Object\";\n+  const #5  = Utf8        \"<init>\";\n+  const #6  = Utf8        \"()V\";\n+  const #7  = class        #10;            \/\/ ClassName\n+  const #8  = Utf8         \"java\/lang\/String\";\n+  const #9 = class         #8;             \/\/ java\/lang\/String\n+  const #10  = Utf8        \"ClassName01\";\n+  const #11  = Utf8        \"Code\";\n+  const #12 = Utf8        \"LineNumberTable\";\n+  const #13 = Utf8        \"m\";\n+  const #14 = Utf8        \"JasmFile.g.jasm\";\n+  const #15 = Utf8        \"SourceFile\";\n+\n+   this_class:  #7;                       \/\/ ClassName01\n+   super_class  #9;                       \/\/ java\/lang\/String\n+\n+  public Method #5:#6                     \/\/ \"<init>\":\"()V\"\n+    stack  1 locals  1\n+  {\n+     0:    aload_0;\n+     1:    invokespecial     #1;          \/\/ Method java\/lang\/Object.\"<init>\":\"()V\"\n+     4:    return;\n+  }\n+  private static Method #13:#6            \/\/ m:\"()V\"\n+    stack  0 locals  0\n+  {\n+     0:    return;\n+  }\n+\n+  SourceFile #14;                         \/\/ JasmFile01.g.jasm\n+}\n","filename":"test\/resources\/org\/openjdk\/asmtools\/jasm\/case7903558\/JasmFile01.g.jasm","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+public super class FileName01.class version 66:0\n+{\n+  this_class   ClassName01;\n+  super_class  java\/lang\/String;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack  1 locals  1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+  private static Method m:\"()V\"\n+    stack  0 locals  0\n+  {\n+         return;\n+  }\n+\n+  SourceFile               \"JasmFile.g.jasm\";\n+} \/\/ end Class ClassName01 compiled from \"JasmFile.g.jasm\"\n","filename":"test\/resources\/org\/openjdk\/asmtools\/jasm\/case7903558\/JasmFile01.jasm","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+public super class FileName02.data version 66:0\n+{\n+  const #1  = Method      #2.#3;          \/\/ java\/lang\/Object.\"<init>\":\"()V\"\n+  const #2  = class       #4;             \/\/ java\/lang\/Object\n+  const #3  = NameAndType #5:#6;          \/\/ \"<init>\":\"()V\"\n+  const #4  = Utf8        \"java\/lang\/Object\";\n+  const #5  = Utf8        \"<init>\";\n+  const #6  = Utf8        \"()V\";\n+  const #7  = class        #10;            \/\/ ClassName is not used\n+  const #8  = Utf8         \"java\/lang\/String\";\n+  const #9 = class         #8;             \/\/ java\/lang\/String\n+  const #10  = Utf8        \"ClassName\";\n+  const #11  = Utf8        \"Code\";\n+  const #12 = Utf8        \"LineNumberTable\";\n+  const #13 = Utf8        \"m\";\n+  const #14 = Utf8        \"JasmFile.g.jasm\";\n+  const #15 = Utf8        \"SourceFile\";\n+\n+   this_class:  ClassName02;\n+   super_class  #9;                       \/\/ java\/lang\/String\n+\n+  public Method #5:#6                     \/\/ \"<init>\":\"()V\"\n+    stack  1 locals  1\n+  {\n+     0:    aload_0;\n+     1:    invokespecial     #1;          \/\/ Method java\/lang\/Object.\"<init>\":\"()V\"\n+     4:    return;\n+  }\n+  private static Method #13:#6            \/\/ m:\"()V\"\n+    stack  0 locals  0\n+  {\n+     0:    return;\n+  }\n+\n+  SourceFile #14;                         \/\/ JasmFile02.g.jasm\n+}\n","filename":"test\/resources\/org\/openjdk\/asmtools\/jasm\/case7903558\/JasmFile02.g.jasm","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+public super class FileName02.data extends java\/lang\/String version 66:0\n+{\n+  this_class   ClassName02;\n+  super_class  java\/lang\/String;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack  1 locals  1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+  private static Method m:\"()V\"\n+    stack  0 locals  0\n+  {\n+         return;\n+  }\n+\n+  SourceFile               \"JasmFile.g.jasm\";\n+} \/\/ end Class ClassName01 compiled from \"JasmFile.g.jasm\"\n","filename":"test\/resources\/org\/openjdk\/asmtools\/jasm\/case7903558\/JasmFile02.jasm","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+public super class FileName03 extends package\/ClassName version 66:0\n+{\n+  const #1  = Method      #2.#3;          \/\/ java\/lang\/Object.\"<init>\":\"()V\"\n+  const #2  = class       #4;             \/\/ java\/lang\/Object\n+  const #3  = NameAndType #5:#6;          \/\/ \"<init>\":\"()V\"\n+  const #4  = Utf8        \"java\/lang\/Object\";\n+  const #5  = Utf8        \"<init>\";\n+  const #6  = Utf8        \"()V\";\n+  const #7  = class        #10;            \/\/ ClassName03\n+  const #8  = Utf8         \"package\/SuperClassName03\";\n+  const #9 = class         #8;             \/\/ package\/SuperClassName03\n+  const #10  = Utf8        \"ClassName03\";\n+  const #11  = Utf8        \"Code\";\n+  const #12 = Utf8        \"LineNumberTable\";\n+  const #13 = Utf8        \"m\";\n+  const #14 = Utf8        \"JasmFile.g.jasm\";\n+  const #15 = Utf8        \"SourceFile\";\n+\n+   this_class:  #7;                       \/\/ ClassName03\n+   super_class  #9;                       \/\/ package\/SuperClassName03\n+\n+  public Method #5:#6                     \/\/ \"<init>\":\"()V\"\n+    stack  1 locals  1\n+  {\n+     0:    aload_0;\n+     1:    invokespecial     #1;          \/\/ Method java\/lang\/Object.\"<init>\":\"()V\"\n+     4:    return;\n+  }\n+  private static Method #13:#6            \/\/ m:\"()V\"\n+    stack  0 locals  0\n+  {\n+     0:    return;\n+  }\n+\n+  SourceFile #14;                         \/\/ JasmFile03.g.jasm\n+}\n","filename":"test\/resources\/org\/openjdk\/asmtools\/jasm\/case7903558\/JasmFile03.g.jasm","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+public super class FileName03.class extends java\/lang\/String version 66:0\n+{\n+  this_class   ClassName03;\n+  super_class  package\/SuperClassName03;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack  1 locals  1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+  private static Method m:\"()V\"\n+    stack  0 locals  0\n+  {\n+         return;\n+  }\n+\n+  SourceFile               \"JasmFile.g.jasm\";\n+} \/\/ end Class ClassName01 compiled from \"JasmFile.g.jasm\"\n","filename":"test\/resources\/org\/openjdk\/asmtools\/jasm\/case7903558\/JasmFile03.jasm","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+public super class FileName04.obj extends #2 version 66:0\n+{\n+  const #1  = Method      #2.#3;          \/\/ java\/lang\/Object.\"<init>\":\"()V\"\n+  const #2  = class       #4;             \/\/ java\/lang\/Object\n+  const #3  = NameAndType #5:#6;          \/\/ \"<init>\":\"()V\"\n+  const #4  = Utf8        \"java\/lang\/Object\";\n+  const #5  = Utf8        \"<init>\";\n+  const #6  = Utf8        \"()V\";\n+  const #7  = class        #10;            \/\/ ClassName03               -- ignored\n+  const #8  = Utf8         \"package\/SuperClassName03\";\n+  const #9 = class         #8;             \/\/ package\/SuperClassName03  -- ignored\n+  const #10  = Utf8        \"ClassName03\";\n+  const #11  = Utf8        \"Code\";\n+  const #12 = Utf8        \"LineNumberTable\";\n+  const #13 = Utf8        \"m\";\n+  const #14 = Utf8        \"JasmFile.g.jasm\";\n+  const #15 = Utf8        \"SourceFile\";\n+\n+   this_class:  ClassName04;\n+   super_class  package\/SuperClassName04;\n+\n+  public Method #5:#6                     \/\/ \"<init>\":\"()V\"\n+    stack  1 locals  1\n+  {\n+     0:    aload_0;\n+     1:    invokespecial     #1;          \/\/ Method java\/lang\/Object.\"<init>\":\"()V\"\n+     4:    return;\n+  }\n+  private static Method #13:#6            \/\/ m:\"()V\"\n+    stack  0 locals  0\n+  {\n+     0:    return;\n+  }\n+\n+  SourceFile #14;                         \/\/ JasmFile03.g.jasm\n+}\n","filename":"test\/resources\/org\/openjdk\/asmtools\/jasm\/case7903558\/JasmFile04.g.jasm","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+public super class FileName04.obj extends package\/SuperClassName04 version 66:0\n+{\n+  this_class:   ClassName04;\n+  super_class:  java\/lang\/Object;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack  1 locals  1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  private static Method m:\"()V\"\n+    stack  0 locals  0\n+  {\n+         return;\n+  }\n+\n+  SourceFile               \"JasmFile.g.jasm\";\n+} \/\/ end Class ClassName04 compiled from \"JasmFile.g.jasm\"\n","filename":"test\/resources\/org\/openjdk\/asmtools\/jasm\/case7903558\/JasmFile04.jasm","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"}]}