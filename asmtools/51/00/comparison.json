{"files":[{"patch":"@@ -45,2 +45,2 @@\n-        margin-bottom: 10px; margin-left: 0px; \n-        padding-bottom: 5px; padding-left: 5px \n+        margin-bottom: 10px; margin-left: 0px;\n+        padding-bottom: 5px; padding-left: 5px\n@@ -51,1 +51,1 @@\n-  padding-top: 5px; padding-right: 10px; \n+  padding-top: 5px; padding-right: 10px;\n@@ -65,1 +65,1 @@\n-td p \n+td p\n@@ -72,1 +72,1 @@\n-td h1 {  text-align: center \n+td h1 {  text-align: center\n@@ -74,1 +74,1 @@\n-td h2 {  text-align: center; padding-top: 0px \n+td h2 {  text-align: center; padding-top: 0px\n@@ -78,1 +78,1 @@\n-td h4 {  text-align: center; padding-top: 0px \n+td h4 {  text-align: center; padding-top: 0px\n@@ -80,1 +80,1 @@\n-table.Code { margin-bottom: 0.5em; border: 0; \n+table.Code { margin-bottom: 0.5em; border: 0;\n@@ -84,1 +84,1 @@\n-               border: 1px solid  #1E475B; \n+               border: 1px solid  #1E475B;\n@@ -148,1 +148,1 @@\n-<a href=\"https:\/\/wiki.openjdk.java.net\/display\/CodeTools\/Main\">CodeTools<\/a> project) \n+<a href=\"https:\/\/wiki.openjdk.java.net\/display\/CodeTools\/Main\">CodeTools<\/a> project)\n@@ -168,1 +168,1 @@\n-       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902525\">CODETOOLS-7902525<\/a> \n+       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902525\">CODETOOLS-7902525<\/a>\n@@ -176,1 +176,1 @@\n-       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902524\">CODETOOLS-7902524<\/a> \n+       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902524\">CODETOOLS-7902524<\/a>\n@@ -199,1 +199,1 @@\n-       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902618\">CODETOOLS-7902618<\/a> \n+       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902618\">CODETOOLS-7902618<\/a>\n@@ -207,1 +207,1 @@\n-       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902643\">CODETOOLS-7902643<\/a> \n+       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902643\">CODETOOLS-7902643<\/a>\n@@ -215,1 +215,1 @@\n-       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902644\">CODETOOLS-7902644<\/a> \n+       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902644\">CODETOOLS-7902644<\/a>\n@@ -223,1 +223,1 @@\n-       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902648\">CODETOOLS-7902648<\/a> \n+       <a href=\"https:\/\/bugs.openjdk.java.net\/browse\/CODETOOLS-7902648\">CODETOOLS-7902648<\/a>\n@@ -285,1 +285,1 @@\n-<pre>java -jar ${ASMTOOLSHOME}\/asmtools.jar TOOL FILE<br>   [TOOL=\"jasm\" | \"jdis\" | \"jcoder\" | jdec | jcdec]<br>   [FILE=xxx.jasm (for jasm command) | xxx.jcod (for jcod command) | xxx.class for jdis, jdec, or jcdec command]<br><br><\/pre>\n+<pre>java -jar ${ASMTOOLSHOME}\/asmtools.jar TOOL FILE<br>   [TOOL=\"jasm\" | \"jdis\" | \"jcoder\" | \"jdec\"]<br>   [FILE=xxx.jasm (for jasm command) | xxx.jcod (for jcod command) | xxx.class for jdis, jdec command]<br><br><\/pre>\n@@ -306,1 +306,1 @@\n-Assembler Syntax and tool usage is covered in the \n+Assembler Syntax and tool usage is covered in the\n@@ -316,1 +316,1 @@\n-Many attributes (in the class file, as specified by the \n+Many attributes (in the class file, as specified by the\n","filename":"README.html","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-src\/main\/resources\/org\/openjdk\/asmtools\/jcdec\/i18n.properties=..\/..\/..\/..\/..\/..\/..\/..\/src\/org\/openjdk\/asmtools\/jcdec\/i18n.properties\n@@ -79,2 +78,0 @@\n-\n-\n","filename":"maven\/mvngen.sh","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public static final I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(Main.class);\n+    public static final I18NResourceBundle sharedI18n = I18NResourceBundle.getBundleForClass(org.openjdk.asmtools.Main.class);\n@@ -48,1 +48,1 @@\n-            usage(i18n.getString(\"main.error.no_arguments\"), 1);\n+            usage(sharedI18n.getString(\"main.error.no_arguments\"), 1);\n@@ -67,2 +67,0 @@\n-            } else if (cmd.equals(\"jcdec\")) {\n-                jcdec(newArgs);\n@@ -70,1 +68,1 @@\n-                usage(i18n.getString(\"main.error.unknown_tool\", cmd), 1);\n+                usage(sharedI18n.getString(\"main.error.unknown_tool\", cmd), 1);\n@@ -82,1 +80,1 @@\n-        System.err.println(i18n.getString(\"main.usage\", \"asmtools.jar\"));\n+        System.err.println(sharedI18n.getString(\"main.usage\", \"asmtools.jar\"));\n@@ -103,7 +101,0 @@\n-    \/**\n-     * Invokes jcdec main class with passed arguments\n-     *\/\n-    public static void jcdec(String... args) {\n-        org.openjdk.asmtools.jcdec.Main.main(args);\n-    }\n-\n","filename":"src\/org\/openjdk\/asmtools\/Main.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,2 +44,7 @@\n-    public CompilerLogger(ToolOutput.DualStreamToolOutput oser) {\n-        super(oser);\n+    \/**\n+     * @param programName the tool name\n+     * @param cls         the environment class of the tool for which to obtain the resource bundle\n+     * @param outerLog    the logger stream\n+     *\/\n+    public CompilerLogger(String programName, Class<?> cls, ToolOutput.DualStreamToolOutput outerLog) {\n+        super(programName, cls, outerLog);\n@@ -52,1 +57,1 @@\n-            if (EMessageKind.isFromResourceBundle(id))\n+            if (EMessageKind.isFromResourceBundle(id)) {\n@@ -54,2 +59,5 @@\n-            else\n-                message = new Message(WARNING, args.length == 0 ? id : format(id, args));\n+            } else {\n+                insert(where, new Message(WARNING, args.length == 0 ? id : format(id, args)));\n+            }\n+        } else {\n+            insert(where, message);\n@@ -57,1 +65,0 @@\n-        insert(where, message);\n@@ -64,1 +71,1 @@\n-            if (EMessageKind.isFromResourceBundle(id))\n+            if (EMessageKind.isFromResourceBundle(id)) {\n@@ -66,2 +73,5 @@\n-            else\n-                message = new Message(ERROR, args.length == 0 ? id : format(id, args));\n+            } else {\n+                insert(where, new Message(ERROR, args.length == 0 ? id : format(id, args)));\n+            }\n+        } else {\n+            insert(where, message);\n@@ -69,1 +79,0 @@\n-        insert(where, message);\n@@ -76,1 +85,1 @@\n-            if (EMessageKind.isFromResourceBundle(id))\n+            if (EMessageKind.isFromResourceBundle(id)) {\n@@ -78,1 +87,1 @@\n-            else\n+            } else {\n@@ -80,0 +89,1 @@\n+            }\n@@ -123,1 +133,1 @@\n-     * @return 0 if there are no errors otherwise a numner of errors\n+     * @return 0 if there are no errors otherwise a number of errors\n@@ -125,1 +135,1 @@\n-    public int flush(boolean printTotals) {\n+    public synchronized int flush(boolean printTotals) {\n@@ -130,0 +140,1 @@\n+        ToolOutput output = getOutputs().getSToolObject();\n@@ -134,2 +145,4 @@\n-                ToolOutput output = msg.kind() == ERROR ? getOutputs().getEToolObject() : getOutputs().getSToolObject();\n-                nErrors += msg.kind() == ERROR ? 1 : 0;\n+                if( msg.kind() == ERROR ) {\n+                    output = getOutputs().getEToolObject();\n+                    nErrors++;\n+                }\n@@ -146,5 +159,0 @@\n-                output.flush();\n-                try {\n-                    Thread.sleep(100);\n-                } catch (InterruptedException ignore) {\n-                }\n@@ -153,1 +161,2 @@\n-        if (printTotals && (nWarnings != 0 || nErrors != 0)) {\n+        ToolOutput.DualStreamToolOutput totalOutput = (printTotals) ? getOutputs() : null;\n+        if (printTotals) {\n@@ -155,1 +164,1 @@\n-                getOutputs().printe(format(\"%d warning(s)%s\", nWarnings, nErrors != 0 ? \", \" : \"\"));\n+                totalOutput.printe(format(\"%d warning(s)%s\", nWarnings, nErrors != 0 ? \", \" : \"\\n\"));\n@@ -157,2 +166,9 @@\n-                getOutputs().printlne(format(\"%d error(s)\", nErrors));\n-            getOutputs().flush();\n+                totalOutput.printlne(format(\"%d error(s)\", nErrors));\n+        }\n+\n+        synchronized (output) {\n+            output.flush();\n+            if( totalOutput != null ) {\n+                totalOutput.flush();\n+            }\n+            container.clear();\n@@ -160,1 +176,1 @@\n-        container.clear();\n+\n@@ -180,1 +196,1 @@\n-                    new Message(ERROR, EMessageFormatter.LONG.apply(ERROR,\n+                    new Message(ERROR, EMessageFormatter.LONG.apply(ERROR, this.getProgramName(),\n@@ -185,2 +201,3 @@\n-        addToContainer(where, new Message(message.kind(), where == NOWHERE ? EMessageFormatter.VERBOSE.apply(message) :\n-                EMessageFormatter.LONG.apply(message)));\n+        addToContainer(where, new Message(message.kind(), where == NOWHERE ?\n+                EMessageFormatter.VERBOSE.apply(this.getProgramName(), message) :\n+                EMessageFormatter.LONG.apply(this.getProgramName(), message)));\n","filename":"src\/org\/openjdk\/asmtools\/common\/CompilerLogger.java","additions":46,"deletions":29,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -29,2 +29,7 @@\n-    public DecompilerLogger(ToolOutput.DualStreamToolOutput oser) {\n-        super(oser);\n+    \/**\n+     * @param programName the tool name\n+     * @param cls         the environment class of the tool for which to obtain the resource bundle\n+     * @param outerLog    the logger stream\n+     *\/\n+    public DecompilerLogger(String programName, Class cls, ToolOutput.DualStreamToolOutput outerLog) {\n+        super(programName, cls, outerLog);\n@@ -38,0 +43,6 @@\n+    @Override\n+    public void error(Throwable exception) {\n+        super.printErrorLn(ToolLogger.EMessageFormatter.VERBOSE.apply(super.getProgramName(),\n+                new ToolLogger.Message(EMessageKind.ERROR, super.getProgramName(), exception.getMessage())));\n+    }\n+\n@@ -46,1 +57,1 @@\n-                println(EMessageFormatter.LONG.apply(EMessageKind.WARNING, format(id, args)));\n+                println(EMessageFormatter.LONG.apply(EMessageKind.WARNING, super.getProgramName(), format(id, args)));\n@@ -49,1 +60,1 @@\n-            println(EMessageFormatter.LONG.apply(EMessageKind.WARNING, message));\n+            println(EMessageFormatter.LONG.apply(EMessageKind.WARNING, super.getProgramName(), message));\n@@ -59,0 +70,1 @@\n+                        super.getProgramName(),\n@@ -61,1 +73,1 @@\n-                printErrorLn(EMessageFormatter.VERBOSE.apply(EMessageKind.ERROR, format(id, args)));\n+                printErrorLn(EMessageFormatter.VERBOSE.apply(EMessageKind.ERROR, super.getProgramName(), format(id, args)));\n@@ -64,1 +76,1 @@\n-            printErrorLn(EMessageFormatter.VERBOSE.apply(EMessageKind.ERROR, message));\n+            printErrorLn(EMessageFormatter.VERBOSE.apply(EMessageKind.ERROR, super.getProgramName(), message));\n@@ -73,1 +85,1 @@\n-                printErrorLn(EMessageFormatter.VERBOSE.apply(EMessageKind.ERROR,\n+                printErrorLn(EMessageFormatter.VERBOSE.apply(EMessageKind.ERROR, super.getProgramName(),\n","filename":"src\/org\/openjdk\/asmtools\/common\/DecompilerLogger.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import org.openjdk.asmtools.util.I18NResourceBundle;\n-\n@@ -39,1 +37,1 @@\n-    public final static int OK     = 0;\n+    public final static int OK = 0;\n@@ -54,3 +52,4 @@\n-\n-    protected Environment(Builder builder, I18NResourceBundle i18n) {\n-        ToolLogger.setResources(builder.programName, i18n);\n+    \/**\n+     * @param builder the environment builder\n+     *\/\n+    protected Environment(Builder builder) {\n@@ -92,2 +91,2 @@\n-        if( traceFlag )\n-            ILogger.super.traceln(id,args);\n+        if (traceFlag)\n+            ILogger.super.traceln(id, args);\n@@ -98,2 +97,2 @@\n-        if( traceFlag )\n-            ILogger.super.trace(id,args);\n+        if (traceFlag)\n+            ILogger.super.trace(id, args);\n@@ -158,1 +157,0 @@\n-        protected String programName;\n@@ -160,2 +158,1 @@\n-        public Builder(String programName, ToolOutput toolOutput, T toolLogger) {\n-            this.programName = programName;\n+        public Builder(ToolOutput toolOutput, T toolLogger) {\n","filename":"src\/org\/openjdk\/asmtools\/common\/Environment.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,4 +30,4 @@\n-    public FormatError(String id, Object... args) {\n-        super( args.length == 0 ? id :  ToolLogger.getResourceString(id,args) == null ?\n-                                        \"(i18n.properties) The message '\" + id + \"' not found\" :\n-                                        ToolLogger.getResourceString(id,args));\n+    public <T extends ToolLogger> FormatError(T logger, String id, Object... args) {\n+        super(args.length == 0 ? id : logger.getResourceString(id, args) == null ?\n+                \"(i18n.properties) The message '\" + id + \"' not found\" :\n+                logger.getResourceString(id, args));\n","filename":"src\/org\/openjdk\/asmtools\/common\/FormatError.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    \/\/ A logged message isn't attached to a position of a parsed file\/\n+    \/\/ A logged message isn't attached to a position of a parsed file\n@@ -14,1 +14,1 @@\n-    default void warning(int where, String id, Object... args) {\n+    default String getResourceString(String id, Object... args) {\n@@ -17,0 +17,1 @@\n+    default void warning(int where, String id, Object... args) { throw new NotImplementedException(); }\n@@ -65,0 +66,1 @@\n+\n@@ -76,1 +78,0 @@\n-\n","filename":"src\/org\/openjdk\/asmtools\/common\/ILogger.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-    \/\/ private final long tm = System.currentTimeMillis();\n-\n","filename":"src\/org\/openjdk\/asmtools\/common\/Tool.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.HashMap;\n@@ -30,1 +31,0 @@\n-import java.util.function.BiFunction;\n@@ -33,0 +33,1 @@\n+import static org.openjdk.asmtools.Main.sharedI18n;\n@@ -38,3 +39,26 @@\n-    private static String programName;\n-    private static I18NResourceBundle i18n;\n-    private static I18NResourceBundle sharedI18n = I18NResourceBundle.getBundleForClass(org.openjdk.asmtools.Main.class);\n+    class ToolResources {\n+        private final static HashMap<String, I18NResourceBundle> resources = new HashMap<>();\n+\n+        public ToolResources(String programName, Class cls) {\n+            if (!ToolResources.resources.containsKey(programName)) {\n+                ToolResources.resources.put(programName, I18NResourceBundle.getBundleForClass(cls));\n+            }\n+        }\n+\n+        public void setWarn(boolean value) {\n+            ToolResources.resources.get(ToolLogger.this.programName).setWarn(value);\n+        }\n+\n+        public String getString(String id, Object... args) {\n+            return ToolResources.resources.get(ToolLogger.this.programName).getString(id, args);\n+        }\n+\n+        public boolean containsKey(String key) {\n+            return ToolResources.resources.get(ToolLogger.this.programName).containsKey(key);\n+        }\n+    }\n+\n+    private final String programName;\n+\n+    private ToolResources toolResources;\n+\n@@ -49,3 +73,0 @@\n-    protected ToolLogger(ToolOutput.DualStreamToolOutput outerLog) {\n-        this.outerLog = outerLog;\n-    }\n@@ -53,7 +74,10 @@\n-    static void setResources(String programName, I18NResourceBundle i18n) {\n-        ToolLogger.programName = programName;\n-        ToolLogger.i18n = i18n;\n-    }\n-\n-    public static String getProgramName() {\n-        return programName;\n+    \/**\n+     * @param programName the tool name\n+     * @param cls         the environment class of the tool for which to obtain the resource bundle\n+     * @param outerLog    the logger stream\n+     *\/\n+    public ToolLogger(String programName, Class cls, ToolOutput.DualStreamToolOutput outerLog) {\n+        \/\/ Set Resource bundle for the tool\n+        this.toolResources = new ToolResources(programName, cls);\n+        this.programName = programName;\n+        this.outerLog = outerLog;\n@@ -62,3 +86,3 @@\n-    public static String getResourceString(String id, Object... args) {\n-        String r = null;\n-        i18n.setWarn(false);\n+    public String getResourceString(String id, Object... args) {\n+        String resString;\n+        toolResources.setWarn(false);\n@@ -66,1 +90,1 @@\n-            r = i18n.getString(id, args);\n+            resString = toolResources.getString(id, args);\n@@ -68,1 +92,1 @@\n-            i18n.setWarn(true);\n+            toolResources.setWarn(true);\n@@ -70,2 +94,2 @@\n-        if (r == null || r.equals(id)) {\n-            r = sharedI18n.getString(id, args);\n+        if (resString == null || resString.equals(id)) {\n+            resString = sharedI18n.getString(id, args);\n@@ -73,1 +97,1 @@\n-        if (r == null || r.equals(id)) {\n+        if (resString == null || resString.equals(id)) {\n@@ -75,1 +99,1 @@\n-            r = i18n.getString(id, args);\n+            resString = toolResources.getString(id, args);\n@@ -77,1 +101,1 @@\n-        return r;\n+        return resString;\n@@ -89,1 +113,1 @@\n-            if (ToolLogger.i18n.containsKey(prefix + id) || ToolLogger.sharedI18n.containsKey(prefix + id)) {\n+            if (toolResources.containsKey(prefix + id) || sharedI18n.containsKey(prefix + id)) {\n@@ -118,0 +142,9 @@\n+    public String getProgramName() {\n+        return programName;\n+    }\n+\n+\n+    @FunctionalInterface\n+    private interface TriFunction<A, B, C, R> {\n+        R apply(A a, B b, C c);\n+    }\n@@ -120,8 +153,8 @@\n-        SHORT((severity, message) -> format(\"%s\", message)),\n-        LONG((severity, message) -> format(\"%s: %s\", severity.longForm(), message)),\n-        VERBOSE((severity, message) -> severity == INFO ? message : format(\"%-5s-%6s: %s\",\n-                ToolLogger.getProgramName(), severity.shortForm(), message));\n-        final private BiFunction<EMessageKind, String, String> func;\n-\n-        EMessageFormatter(BiFunction<EMessageKind, String, String> func) {\n-            this.func = func;\n+        SHORT((severity, name, message) -> format(\"%s\", message)),\n+        LONG((severity, name, message) -> format(\"%s: %s\", severity.longForm(), message)),\n+        VERBOSE((severity, name, message) -> severity == INFO ? message : format(\"%-7s-%6s: %s\",\n+                name, severity.shortForm(), message));\n+        final private TriFunction<EMessageKind, String, String, String> triFunc;\n+\n+        EMessageFormatter(TriFunction<EMessageKind, String, String, String> func) {\n+            this.triFunc = func;\n@@ -130,2 +163,2 @@\n-        public String apply(EMessageKind kind, String format, Object... args) {\n-            return func.apply(kind, format(format, args));\n+        public String apply(EMessageKind kind, String name, String format, Object... args) {\n+            return triFunc.apply(kind, name, format(format, args));\n@@ -134,2 +167,2 @@\n-        public String apply(Message message) {\n-            return message.notFound() ? \"\" : func.apply(message.kind(), message.text());\n+        public String apply(String name, Message message) {\n+            return message.notFound() ? \"\" : triFunc.apply(message.kind(), name, message.text());\n","filename":"src\/org\/openjdk\/asmtools\/common\/ToolLogger.java","additions":70,"deletions":37,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-\\   where toolName one of: jasm, jdis, jcoder, jdec, jcdec \\n\\\n+\\   where toolName one of: jasm, jdis, jcoder, jdec \\n\\\n@@ -37,1 +37,1 @@\n-err.does_not_exist=The output directory {0} does not exist\n+err.does_not_exist=The output directory ''{0}'' does not exist\n@@ -40,1 +40,1 @@\n-\\     -d <directory>  Specify where to place generated class files\n+\\     -d <directory> Specify where to place generated class files\n@@ -42,1 +42,1 @@\n-\\     -v       Print additional information\n+\\     -v Print additional information\n@@ -44,1 +44,1 @@\n-\\     -t       Print debug, trace information\n+\\     -t Print debug, trace information\n@@ -46,1 +46,1 @@\n-\\     -version Print the program version\n\\ No newline at end of file\n+\\     -version Print the program version\n","filename":"src\/org\/openjdk\/asmtools\/i18n.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,6 +25,1 @@\n-import org.openjdk.asmtools.common.CompilerLogger;\n-import org.openjdk.asmtools.common.EMessageKind;\n-import org.openjdk.asmtools.common.Environment;\n-import org.openjdk.asmtools.common.ToolInput;\n-import org.openjdk.asmtools.common.ToolOutput;\n-import org.openjdk.asmtools.util.I18NResourceBundle;\n+import org.openjdk.asmtools.common.*;\n@@ -34,1 +29,0 @@\n-import java.io.PrintWriter;\n@@ -40,1 +34,1 @@\n-public class JasmEnvironment extends Environment<CompilerLogger>  {\n+public class JasmEnvironment extends Environment<CompilerLogger> {\n@@ -44,2 +38,5 @@\n-    private JasmEnvironment(Builder<JasmEnvironment, CompilerLogger> builder, I18NResourceBundle i18n) {\n-        super(builder, i18n);\n+    \/**\n+     * @param builder the jasm environment builder\n+     *\/\n+    private JasmEnvironment(Builder<JasmEnvironment, CompilerLogger> builder) {\n+        super(builder);\n@@ -62,3 +59,3 @@\n-    public void warning(int where, String id, Object... args) { getLogger().warning(where, id, args); }\n-    @Override\n-    public void error(int where, String id, Object... args) { getLogger().error(where, id, args); }\n+    public void warning(int where, String id, Object... args) {\n+        getLogger().warning(where, id, args);\n+    }\n@@ -67,1 +64,3 @@\n-    public void warning(String id, Object... args) { getLogger().warning(NOWHERE, id, args); }\n+    public void error(int where, String id, Object... args) {\n+        getLogger().error(where, id, args);\n+    }\n@@ -70,1 +69,3 @@\n-    public void error(String id, Object... args) { getLogger().error(NOWHERE, id, args); }\n+    public void warning(String id, Object... args) {\n+        getLogger().warning(NOWHERE, id, args);\n+    }\n@@ -72,0 +73,4 @@\n+    @Override\n+    public void error(String id, Object... args) {\n+        getLogger().error(NOWHERE, id, args);\n+    }\n@@ -89,1 +94,2 @@\n-     * @param id id of a string resource in I18NResourceBundle\n+     *\n+     * @param id   id of a string resource in I18NResourceBundle\n@@ -100,0 +106,1 @@\n+     *\n@@ -101,2 +108,2 @@\n-     * @param id id of a string resource in I18NResourceBundle\n-     * @param args arguments referenced by the format specifiers in the resource string\n+     * @param id    id of a string resource in I18NResourceBundle\n+     * @param args  arguments referenced by the format specifiers in the resource string\n@@ -115,1 +122,3 @@\n-    public int flush(boolean printTotals) { return super.getLogger().flush(printTotals); }\n+    public int flush(boolean printTotals) {\n+        return super.getLogger().flush(printTotals);\n+    }\n@@ -136,1 +145,1 @@\n-            super(\"jasm\", toolOutput, new CompilerLogger(logger));\n+            super(toolOutput, new CompilerLogger(\"jasm\", JasmEnvironment.class, logger));\n@@ -141,1 +150,1 @@\n-            return new JasmEnvironment(this, I18NResourceBundle.getBundleForClass(this.getClass()) );\n+            return new JasmEnvironment(this);\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/JasmEnvironment.java","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static public enum KeywordType {\n+    public enum KeywordType {\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/JasmTokens.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/JasmTool.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Collections;\n@@ -85,4 +86,2 @@\n-        for(ToolInput toolInput: toolInputs){\n-            fileList.add(toolInput);\n-        }\n-        parseArgs(new String[0]);\n+        Collections.addAll(fileList, toolInputs);\n+        parseArgs();\n@@ -198,3 +197,2 @@\n-                    case org.openjdk.asmtools.Main.DUAL_LOG_SWITCH -> {\n-                        this.environment.setOutputs(new ToolOutput.DualOutputStreamOutput());\n-                    }\n+                    case org.openjdk.asmtools.Main.DUAL_LOG_SWITCH ->\n+                            this.environment.setOutputs(new ToolOutput.DualOutputStreamOutput());\n@@ -255,4 +253,1 @@\n-                    case org.openjdk.asmtools.Main.STDIN_SWITCH -> {\n-                        addStdIn();\n-                        break;\n-                    }\n+                    case org.openjdk.asmtools.Main.STDIN_SWITCH -> addStdIn();\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/Main.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -495,1 +495,1 @@\n-            environment.error(scanner.pos, \"int.expected\");\n+            environment.error(scanner.pos, \"err.int.expected\");\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/Parser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-                            environment.error(scanner.pos, \"type.expected\");\n+                            environment.error(scanner.pos, \"err.array.type.expected\");\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ParserInstr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import org.openjdk.asmtools.common.ToolLogger;\n@@ -32,2 +31,0 @@\n-import static org.openjdk.asmtools.common.EMessageKind.ERROR;\n-import static org.openjdk.asmtools.common.ToolLogger.getResourceString;\n@@ -69,1 +66,2 @@\n-        Objects.requireNonNull(stackFrameType, () -> getResourceString( \"err.obj.is.null\", \"String stackFrameType\"));\n+        Objects.requireNonNull(stackFrameType,\n+                () -> this.environment.getLogger().getResourceString(\"err.obj.is.null\", \"String stackFrameType\"));\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/StackMapData.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-\\     -nowrite              Do not write generated class files\n+\\     -nowrite Do not write generated class files\n@@ -29,1 +29,1 @@\n-\\     -strict               Consider warnings as errors\n+\\     -strict Consider warnings as errors\n@@ -31,1 +31,1 @@\n-\\     -nowarn               Do not print warnings\n+\\     -nowarn Do not print warnings\n@@ -33,1 +33,1 @@\n-\\     -cv <major.minor>     Set operating class file version (by default {0}.{1})\n+\\     -cv <major.minor> Set operating class file version (by default {0}.{1})\n@@ -35,1 +35,1 @@\n-\\     -fixcv <major.minor>  Override class file version in source file(s)\n+\\     -fixcv <major.minor> Override class file version in source file(s)\n@@ -100,0 +100,1 @@\n+err.array.type.expected=Array type code expected\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/i18n.properties","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,959 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.asmtools.jcdec;\n-\n-import static org.openjdk.asmtools.common.Environment.OK;\n-import static org.openjdk.asmtools.jcoder.JcodTokens.*;\n-\n-import org.openjdk.asmtools.common.ToolOutput;\n-import org.openjdk.asmtools.util.I18NResourceBundle;\n-import org.openjdk.asmtools.util.ProductInfo;\n-import java.io.DataInputStream;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-\n-\/**\n- * Main program of the JavaCard DeCoder\n- *\n- *\/\n-public class Main {\n-\n-    \/*-------------------------------------------------------- *\/\n-    \/* Main Fields *\/\n-    \/**\n-     * Name of the program.\n-     *\/\n-    String program;\n-\n-    public static final I18NResourceBundle i18n\n-            = I18NResourceBundle.getBundleForClass(Main.class);\n-    \/**\n-     * The stream where error message are printed.\n-     *\/\n-    ToolOutput out;\n-    boolean DebugFlag = false;\n-    boolean printDetails = false;\n-    int shift = 0;\n-    private static final char hexTable[] = {\n-        '0', '1', '2', '3', '4', '5', '6', '7',\n-        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n-    };\n-    \/*-------------------------------------------------------- *\/\n-\n-    static String toHex(long val, int width) {\n-        StringBuffer s = new StringBuffer();\n-        for (int i = width * 2 - 1; i >= 0; i--) {\n-            s.append(hexTable[((int) (val >> (4 * i))) & 0xF]);\n-        }\n-        return \"0x\" + s.toString();\n-    }\n-\n-    static String toHex(long val) {\n-        int width;\n-        for (width = 8; width > 0; width--) {\n-            if ((val >> (width - 1) * 8) != 0) {\n-                break;\n-            }\n-        }\n-        return toHex(val, width);\n-    }\n-\n-    void printByteHex(ToolOutput out, int b) {\n-        out.prints(hexTable[(b >> 4) & 0xF]);\n-        out.prints(hexTable[b & 0xF]);\n-    }\n-\n-    \/*========================================================*\/\n-    void out_begin(String s) {\n-        for (int i = 0; i < shift; i++) {\n-            out.prints(\"  \");\n-        }\n-        out.printlns(s);\n-        shift++;\n-    }\n-\n-    void out_print(String s) {\n-        for (int i = 0; i < shift; i++) {\n-            out.prints(\"  \");\n-        }\n-        out.prints(s);\n-    }\n-\n-    void out_println(String s) {\n-        for (int i = 0; i < shift; i++) {\n-            out.prints(\"  \");\n-        }\n-        out.printlns(s);\n-    }\n-\n-    void out_end(String s) {\n-        shift--;\n-        for (int i = 0; i < shift; i++) {\n-            out.prints(\"  \");\n-        }\n-        out.printlns(s);\n-    }\n-\n-    String startArray(int length) {\n-        return \"[\" + (printDetails ? Integer.toString(length) : \"\") + \"]\";\n-    }\n-\n-    void printBytes(DataInputStream in, int len) throws IOException {\n-        try {\n-            for (int i = 0; i < len; i++) {\n-                if (i % 8 == 0) {\n-                    out_print(\"0x\");\n-                }\n-                printByteHex(out, in.readByte());\n-                if (i % 8 == 7) {\n-                    out.printlns(\";\");\n-                }\n-            }\n-        } finally {\n-            if (len % 8 != 0) {\n-                out.printlns(\";\");\n-            }\n-        }\n-    }\n-\n-    \/*========================================================*\/\n-    static final int EXPORT_MAGIC = 0x00FACADE;\n-    static final int HEADER_MAGIC = 0xDECAFFED;\n-    static String[] compNames = {\n-        \"Header\",\n-        \"Directory\",\n-        \"Applet\",\n-        \"Import\",\n-        \"ConstantPool\",\n-        \"Class\",\n-        \"Method\",\n-        \"StaticField\",\n-        \"RefLocation\",\n-        \"Export\",\n-        \"Descriptor\"\n-    };\n-\n-    static String compName(int compNum) {\n-        try {\n-            return compNames[compNum - 1];\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            return \"tag \" + compNum + \"???\";\n-        }\n-    }\n-    String[] cPoolStrings;\n-\n-    void decodeAttr(DataInputStream in) throws IOException {\n-        int name_cpx = in.readUnsignedShort(), len = in.readInt();\n-        String AttrName = null;\n-        String endingComment = \"Attr(#\" + name_cpx + \")\";\n-        try {\n-            endingComment = AttrName = cPoolStrings[name_cpx];\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-        }\n-        if (printDetails) {\n-            out_begin(\"Attr(#\" + name_cpx + \", \" + len + \") { \/\/ \" + AttrName);\n-        } else {\n-            out_begin(\"Attr(#\" + name_cpx + \") { \/\/ \" + AttrName);\n-        }\n-        if (AttrName == null) {\n-            printBytes(in, len);\n-        } else if (AttrName.equals(\"ConstantValue\")) {\n-            if (len != 2) {\n-                out_println(\"\/\/ invalid length of ConstantValue attr: \" + len + \" (should be 2)\");\n-                printBytes(in, len);\n-            } else {\n-                out_println(\"#\" + in.readUnsignedShort() + \";\");\n-            }\n-        } else {\n-            printBytes(in, len);\n-        }\n-        out_end(\"} \/\/ end \" + endingComment);\n-    }\n-\n-    void decodeExp(String inpName) throws IOException {\n-        DataInputStream in = new DataInputStream(new FileInputStream(inpName));\n-        out_println(\"file \" + inpName);\n-        out_begin(\"{  \/\/ export file\");\n-\n-        int magic = in.readInt();\n-        out_print(toHex(magic, 4) + \";  \/\/ \");\n-        if (magic != EXPORT_MAGIC) {\n-            out.prints(\"wrong magic: 0x\" + Integer.toString(EXPORT_MAGIC, 16) + \" expected\");\n-        } else {\n-            out_print(\"magic\");\n-        }\n-        out.printlns(\"\");\n-        out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n-        out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n-\n-        int cp_count = in.readUnsignedShort();\n-        cPoolStrings = new String[cp_count];\n-        out_begin(startArray(cp_count) + \" { \/\/  Constant Pool\");\n-        for (int i = 0; i < cp_count; i++) {\n-            int tag = in.readUnsignedByte();\n-            ConstType tg = constType(tag);\n-            switch (tg) {\n-                case CONSTANT_UTF8:\n-                    out_print(\"Utf8 \\\"\");\n-\n-                    StringBuffer sb = new StringBuffer();\n-                    String s = in.readUTF();\n-                    cPoolStrings[i] = s;\n-                    for (int k = 0; k < s.length(); k++) {\n-                        char c = s.charAt(k);\n-                        switch (c) {\n-                            case '\\t':\n-                                sb.append('\\\\').append('t');\n-                                break;\n-                            case '\\n':\n-                                sb.append('\\\\').append('n');\n-                                break;\n-                            case '\\r':\n-                                sb.append('\\\\').append('r');\n-                                break;\n-                            case '\\\"':\n-                                sb.append('\\\\').append('\\\"');\n-                                break;\n-                            default:\n-                                sb.append(c);\n-                        }\n-                    }\n-                    out.printlns(sb.append(\"\\\"; \/\/ #\").append(i).toString());\n-                    break;\n-\n-                case CONSTANT_INTEGER:\n-                    out_println(\"int \" + toHex(in.readInt(), 4) + \"; \/\/ #\" + i);\n-                    break;\n-\n-                case CONSTANT_CLASS:\n-                    out_println(\"class #\" + in.readUnsignedShort() + \"; \/\/ #\" + i);\n-                    break;\n-\n-                case CONSTANT_JAVACARD_PACKAGE:\n-                    out_begin(\"package { \/\/ #\" + i);\n-                    out_println(toHex(in.readUnsignedByte(), 1) + \";  \/\/ flags\");\n-                    out_println(\"#\" + in.readUnsignedShort() + \"; \/\/ name\");\n-                    out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n-                    out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n-                    int aid_len = in.readUnsignedByte();\n-                    out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n-                    printBytes(in, aid_len);\n-                    out_end(\"};\"); \/\/ Bytes[]\n-                    out_end(\"};\"); \/\/ package info\n-                    break;\n-\n-                default:\n-                    throw new Error(\"invalid constant type: \" + tag);\n-            }\n-        }\n-        ;\n-        out_end(\"} \/\/ Constant pool\");\n-        out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this package\");\n-        int class_count = in.readUnsignedByte();\n-        out_begin(startArray(class_count) + \"b { \/\/  classes\");\n-        for (int i = 0; i < class_count; i++) {\n-            out_begin(\"{ \/\/ class \" + i);\n-\n-            out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n-\n-            int flags = in.readUnsignedShort();\n-            out_print(\"0x\");\n-            printByteHex(out, flags >> 8);\n-            printByteHex(out, flags);\n-            out.printlns(\"; \/\/ flags\");\n-\n-            out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this class\");\n-\n-            int sup_count = in.readUnsignedShort();\n-            out_begin(startArray(sup_count) + \" { \/\/ supers\");\n-            for (int k = 0; k < sup_count; k++) {\n-                out_println(\"#\" + in.readUnsignedShort() + \";\");\n-            }\n-            out_end(\"} \/\/ supers\");\n-\n-            int int_count = in.readUnsignedByte();\n-            out_begin(startArray(int_count) + \"b { \/\/ interfaces\");\n-            for (int k = 0; k < int_count; k++) {\n-                out_println(\"#\" + in.readUnsignedShort() + \";\");\n-            }\n-            out_end(\"} \/\/ interfaces\");\n-\n-            int field_count = in.readUnsignedShort();\n-            out_begin(startArray(field_count) + \" { \/\/ fields\");\n-            for (int k = 0; k < field_count; k++) {\n-                out_begin(\"{ \/\/ field \" + k);\n-                out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n-\n-                int f_flags = in.readUnsignedShort();\n-                out_print(\"0x\");\n-                printByteHex(out, f_flags >> 8);\n-                printByteHex(out, f_flags);\n-                out.printlns(\"; \/\/ flags\");\n-\n-                out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this field name\");\n-                out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this field descriptor\");\n-\n-                int attr_count = in.readUnsignedShort();\n-                out_begin(startArray(attr_count) + \" { \/\/ Attributes\");\n-                for (int ai = 0; ai < attr_count; ai++) {\n-                    decodeAttr(in);\n-                }\n-                out_end(\"} \/\/ Attributes\");\n-                out_end(\"};\");\n-            }\n-            out_end(\"} \/\/ fields\");\n-\n-            int mth_count = in.readUnsignedShort();\n-            out_begin(startArray(mth_count) + \" { \/\/ methods\");\n-            for (int k = 0; k < mth_count; k++) {\n-                out_begin(\"{ \/\/ method \" + k);\n-                out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n-\n-                int mth_flags = in.readUnsignedShort();\n-                out_print(\"0x\");\n-                printByteHex(out, mth_flags >> 8);\n-                printByteHex(out, mth_flags);\n-                out.printlns(\"; \/\/ flags\");\n-\n-                out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this method name\");\n-                out_println(\"#\" + in.readUnsignedShort() + \";  \/\/ this method descriptor\");\n-                out_end(\"};\");\n-            }\n-            out_end(\"} \/\/ methods\");\n-            out_end(\"};\");\n-        }\n-        out_end(\"} \/\/ classes\");\n-        endComponent(in);\n-    }\n-\n-    DataInputStream beginComponent(String inpName) throws IOException {\n-        DataInputStream in = new DataInputStream(new FileInputStream(inpName));\n-        out_println(\"file \" + inpName);\n-\n-        int tag = in.readUnsignedByte();\n-        out_print(\"Component(\" + tag);\n-        int size = in.readUnsignedShort();\n-        if (printDetails) {\n-            out.prints(\", \" + size);\n-        }\n-        out_begin(\") { \/\/ \" + compName(tag));\n-        return in;\n-    }\n-\n-    void endComponent(DataInputStream in) throws IOException {\n-        out_end(\"};\"); \/\/ Component\n-        int avail = in.available();\n-        if (avail > 0) {\n-            out.printlns(\"=========== extra bytes:\");\n-            for (int k = 0; k < 8; k++) {\n-                printBytes(in, avail >= 8 ? 8 : avail);\n-                avail = in.available();\n-                if (avail == 0) {\n-                    break;\n-                }\n-            }\n-            if (avail > 0) {\n-                out.printlns(\"  there is also \" + avail + \" bytes available\");\n-            }\n-        }\n-        in.close();\n-    }\n-\n-    ArrayList<Integer> methodsLengths = null;\n-    ArrayList<Integer> methodsOffsets = null;\n-\n-    void decodeHeader(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        int magic = in.readInt();\n-        out_print(toHex(magic, 4) + \";  \/\/ \");\n-        if (magic != HEADER_MAGIC) {\n-            out.prints(\"wrong magic: 0x\" + Integer.toString(HEADER_MAGIC, 16) + \" expected\");\n-        } else {\n-            out_print(\"magic\");\n-        }\n-        out.printlns(\"\");\n-        out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n-        out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n-        out_println(toHex(in.readUnsignedByte(), 1) + \";  \/\/ flags\");\n-\n-        out_begin(\"{  \/\/ package info\");\n-        out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n-        out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n-        int aid_len = in.readUnsignedByte();\n-        out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n-        printBytes(in, aid_len);\n-        out_end(\"};\"); \/\/ Bytes[]\n-        out_end(\"};\"); \/\/ package info\n-        endComponent(in);\n-    }\n-\n-    void decodeDirectory(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        int i;\n-        out_begin(\"{  \/\/ component sizes\");\n-        for (i = 0; i < 11; i++) {\n-            out_println(in.readUnsignedShort() + \";  \/\/ \" + (i + 1));\n-        }\n-        out_end(\"};\");\n-\n-        out_begin(\"{  \/\/ static field size\");\n-        out_println(in.readUnsignedShort() + \";  \/\/ image size\");\n-        out_println(in.readUnsignedShort() + \";  \/\/ array init count\");\n-        out_println(in.readUnsignedShort() + \";  \/\/ array init size\");\n-        out_end(\"};\");\n-\n-        out_println(in.readUnsignedByte() + \"b;  \/\/ import count\");\n-        out_println(in.readUnsignedByte() + \"b;  \/\/ applet count\");\n-\n-        int custom_count = in.readUnsignedByte();\n-        out_begin(startArray(custom_count) + \"b { \/\/ custom components\");\n-        for (i = 0; i < custom_count; i++) {\n-            out_print(\"Comp(\" + in.readUnsignedByte());  \/\/ tag;\n-            int size2 = in.readUnsignedShort();\n-            if (printDetails) {\n-                out_print(\", \" + size2);\n-            }\n-            out_begin(\") {\");\n-            int aid_len = in.readUnsignedByte();\n-            out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n-            printBytes(in, aid_len);\n-            out_end(\"};\");\n-            out_end(\"};\");\n-        }\n-        out_end(\"};\");\n-\n-        endComponent(in);\n-    }\n-\n-    void decodeApplet(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        int applet_count = in.readUnsignedByte();\n-        out_begin(startArray(applet_count) + \"b { \/\/ applets\");\n-        for (int i = 0; i < applet_count; i++) {\n-            out_begin(\"{ \/\/ applet \" + i);\n-            int aid_len = in.readUnsignedByte();\n-            out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n-            printBytes(in, aid_len);\n-            out_end(\"};\"); \/\/ Bytes[]\n-            out_println(in.readUnsignedShort() + \";  \/\/ install method offset\");\n-            out_end(\"};\"); \/\/ applet\n-        }\n-        out_end(\"};\"); \/\/ applets\n-        endComponent(in);\n-    }\n-\n-    void decodeImport(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        int package_count = in.readUnsignedByte();\n-        out_begin(startArray(package_count) + \"b { \/\/  packages\");\n-        for (int i = 0; i < package_count; i++) {\n-            out_begin(\"{ \/\/ package \" + i);\n-            out_println(in.readUnsignedByte() + \"b;  \/\/ minor version\");\n-            out_println(in.readUnsignedByte() + \"b;  \/\/ major version\");\n-            int aid_len = in.readUnsignedByte();\n-            out_begin(\"Bytes\" + startArray(aid_len) + \"b {\");\n-            printBytes(in, aid_len);\n-            out_end(\"};\"); \/\/ Bytes[]\n-            out_end(\"};\"); \/\/ package info\n-        }\n-        out_end(\"};\"); \/\/  package info\n-        endComponent(in);\n-    }\n-\n-    static String[] refNames = {\n-        \"Classref\",\n-        \"InstanceFieldref\",\n-        \"VirtualMethodref\",\n-        \"SuperMethodref\",\n-        \"StaticFieldref\",\n-        \"StaticMethodref\"\n-    };\n-\n-    void decodeConstantPool(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        int items_count = in.readUnsignedShort();\n-        out_begin(startArray(items_count) + \" { \/\/  items\");\n-        for (int i = 0; i < items_count; i++) {\n-            int tag = in.readUnsignedByte();\n-            int info1 = in.readUnsignedByte(),\n-                    info2 = in.readUnsignedByte(),\n-                    info3 = in.readUnsignedByte();\n-            out_print(tag + \"b \");\n-            if ((tag > 0) && (tag <= 6)) {\n-                if ((info1 & 0x80) == 0) {\n-                    if (tag <= 4) {\n-                        out_print(((info1 << 8) | info2) + \" \" + info3 + \"b;\");\n-                    } else {\n-                        out_print(info1 + \"b \" + ((info2 << 8) | info3) + \";\");\n-                    }\n-                    out.prints(\" \/\/ internal \");\n-                } else {\n-                    out.prints(info1 + \"b \" + info2 + \"b \" + info3 + \"b;\");\n-                    out.prints(\" \/\/ external \");\n-                }\n-                out.printlns(refNames[tag - 1]);\n-            } else {\n-                out.prints(info1 + \"b \" + info2 + \"b \" + info3 + \"b;\");\n-                out.printlns(\" \/\/ unknown tag \");\n-            }\n-        }\n-        out_end(\"};\"); \/\/  CP array\n-        endComponent(in);\n-    }\n-\n-    void printClassref(DataInputStream in) throws IOException {\n-        int info1 = in.readUnsignedByte(),\n-                info2 = in.readUnsignedByte();\n-        if ((info1 & 0x80) == 0) {\n-            out_print(((info1 << 8) | info2) + \";\");\n-            out_print(\" \/\/ internal \");\n-        } else {\n-            out_print(info1 + \"b \" + info2 + \"b;\");\n-            out_print(\" \/\/ external \");\n-        }\n-        out_println(\" Classref \");\n-    }\n-\n-    void decodeClass(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        for (int i = 0; in.available() > 0; i++) {\n-            out_begin(\"{ \/\/ class \" + i);\n-            int bitfield = in.readUnsignedByte();\n-            int interface_count = bitfield & 0x0F;\n-            out_print(\"0x\");\n-            printByteHex(out, bitfield);\n-            out.printlns(\"; \/\/ bitfield\");\n-            if ((bitfield & 0x80) != 0) {\n-                \/\/ interface\n-                for (int k = 0; k < interface_count; k++) {\n-                    printClassref(in);\n-                }\n-            } else {\n-                \/\/ class\n-                printClassref(in);\n-                out_println(in.readUnsignedByte() + \"b;  \/\/ declared instance size\");\n-                out_println(in.readUnsignedByte() + \"b;  \/\/ first reference token\");\n-                out_println(in.readUnsignedByte() + \"b;  \/\/ reference count\");\n-                out_println(in.readUnsignedByte() + \"b;  \/\/ public method table base\");\n-                int pumrc = in.readUnsignedByte();\n-                out_println(pumrc + \"b;  \/\/ public method table count\");\n-                out_println(in.readUnsignedByte() + \"b;  \/\/ package method table base\");\n-                int pamrc = in.readUnsignedByte();\n-                out_println(pamrc + \"b;  \/\/ package method table count\");\n-                out_begin(\"{ \/\/ public method table\");\n-                for (int k = 0; k < pumrc; k++) {\n-                    out_println(in.readUnsignedShort() + \";\");\n-                }\n-                out_end(\"};\");\n-                out_begin(\"{ \/\/ package method table\");\n-                for (int k = 0; k < pamrc; k++) {\n-                    out_println(in.readUnsignedShort() + \";\");\n-                }\n-                out_end(\"};\");\n-                out_begin(\"{ \/\/ implemented interfaces\");\n-                for (int k = 0; k < interface_count; k++) {\n-                    out_begin(\"{ \/\/ interface \" + k);\n-                    printClassref(in);\n-                    int count = in.readUnsignedByte();\n-                    out_begin(\"Bytes\" + startArray(count) + \"b {\");\n-                    printBytes(in, count);\n-                    out_end(\"};\"); \/\/ Bytes[]\n-                    out_end(\"};\");\n-                }\n-                out_end(\"};\");\n-            }\n-            out_end(\"};\");\n-        }\n-        endComponent(in);\n-    }\n-\n-    void decodeDescriptor(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        methodsLengths = new ArrayList<>();\n-        methodsOffsets = new ArrayList<>();\n-        int class_count = in.readUnsignedByte();\n-        out_begin(startArray(class_count) + \"b { \/\/ classes\");\n-        for (int c = 0; c < class_count; c++) {\n-            out_begin(\"{ \/\/ class \" + c);\n-            out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n-            out_print(\"0x\");\n-            printByteHex(out, in.readUnsignedByte());\n-            out.printlns(\"; \/\/ flags\");\n-            printClassref(in);\n-            int icount = in.readUnsignedByte();\n-            out_println(icount + \"b; \/\/ interface count\");\n-            int fcount = in.readUnsignedShort();\n-            out_println(fcount + \"; \/\/ field count\");\n-            int mcount = in.readUnsignedShort();\n-            out_println(mcount + \"; \/\/ method count\");\n-            if (icount != 0) {\n-                out_begin(\"{ \/\/ interfaces\");\n-                for (int i = 0; i < icount; i++) {\n-                    printClassref(in);\n-                }\n-                out_end(\"};\");\n-            }\n-            for (int i = 0; i < fcount; i++) {\n-                out_begin(\"{ \/\/ field \" + i);\n-                out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n-                int flags = in.readUnsignedByte();\n-                out_print(\"0x\");\n-                printByteHex(out, flags);\n-                out.printlns(\"; \/\/ flags\");\n-                if ((flags & 0x08) == 0) {\n-                    printClassref(in);\n-                    out_println(in.readUnsignedByte() + \"b; \/\/ token\");\n-                } else { \/\/ static field\n-                    int info1 = in.readUnsignedByte(),\n-                            info2 = in.readUnsignedByte(),\n-                            info3 = in.readUnsignedByte();\n-                    if ((info1 & 0x80) == 0) {\n-                        out_print(info1 + \"b \" + ((info2 << 8) | info3) + \";\");\n-                        out.printlns(\" \/\/ internal field\");\n-                    } else {\n-                        out.prints(info1 + \"b \" + info2 + \"b \" + info3 + \"b;\");\n-                        out.printlns(\" \/\/ external field\");\n-                    }\n-                }\n-                int type = in.readUnsignedShort();\n-                if ((type & 0x8000) == 0) {\n-                    out_println(type + \"; \/\/ reference type\");\n-                } else {\n-                    out_print(\"0x\");\n-                    printByteHex(out, type >> 8);\n-                    printByteHex(out, type);\n-                    out.printlns(\"; \/\/ primitive type\");\n-                }\n-                out_end(\"};\");\n-            }\n-            for (int i = 0; i < mcount; i++) {\n-                int token = in.readUnsignedByte();\n-                int flags = in.readUnsignedByte();\n-                int m_offset = in.readUnsignedShort();\n-                int t_offset = in.readUnsignedShort();\n-                int bytecode_count = in.readUnsignedShort();\n-                if (m_offset != 0) {\n-                    out_begin(\"{ \/\/ method \" + i + \" (\" + methodsLengths.size() + \")\");\n-                    methodsLengths.add(bytecode_count);\n-                    methodsOffsets.add(m_offset);\n-                } else {\n-                    out_begin(\"{ \/\/ method \" + i);\n-                }\n-                out_println(token + \"b; \/\/ token\");\n-                out_print(\"0x\");\n-                printByteHex(out, flags);\n-                out.printlns(\"; \/\/ flags\");\n-                out_println(m_offset + \"; \/\/ method offset\");\n-                out_println(t_offset + \"; \/\/ type offset\");\n-                out_println(bytecode_count + \"; \/\/ bytecode count\");\n-                out_println(in.readUnsignedShort() + \"; \/\/ exception handler count\");\n-                out_println(in.readUnsignedShort() + \"; \/\/ exception handler index\");\n-                out_end(\"};\");\n-            }\n-            out_end(\"};\"); \/\/ class i\n-        }\n-        out_end(\"}; \/\/ classes\");\n-\n-        int cp_count = in.readUnsignedShort();\n-        out_begin(startArray(cp_count) + \" { \/\/ constant pool types\");\n-        for (int i = 0; i < cp_count; i++) {\n-            int type = in.readUnsignedShort();\n-            if (type == 0xFFFF) {\n-                out_println(\"0xFFFF;\");\n-            } else {\n-                out_println(type + \"; \");\n-            }\n-        }\n-        out_end(\"}; \/\/ constant pool types\");\n-\n-        out_begin(\"{ \/\/ type descriptors\");\n-        for (int i = 0; in.available() > 0; i++) {\n-            int nibble_count = in.readUnsignedByte();\n-            out_print(nibble_count + \"b; \");\n-            printBytes(in, (nibble_count + 1) \/ 2);\n-        }\n-        out_end(\"}; \/\/ type descriptors\");\n-        endComponent(in);\n-    }\n-\n-    void decodeMethod(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        int handler_count = in.readUnsignedByte();\n-        out_begin(startArray(handler_count) + \"b { \/\/ exception handlers\");\n-        for (int i = 0; i < handler_count; i++) {\n-            out_print(in.readUnsignedShort() + \", \");\n-            int bitfield = in.readUnsignedShort();\n-            out.prints(\"0x\");\n-            printByteHex(out, bitfield >> 8);\n-            printByteHex(out, bitfield);\n-            out.prints(\", \" + in.readUnsignedShort() + \", \");\n-            out.printlns(in.readUnsignedShort() + \"; \/\/ handler \" + i);\n-        }\n-        out_end(\"};\"); \/\/ handlers\n-\n-        if (methodsLengths == null) {\n-            out.printlns(\"\/\/ Descriptor.cap absent - methods not printed\");\n-        } else {\n-            int f_offset = 1 + handler_count * 8;\n-            for (int i = 0; i < methodsLengths.size(); i++) {\n-                out_begin(\"{ \/\/ method \" + i);\n-                int m_offset = methodsOffsets.get(i);\n-                if (m_offset != f_offset) {\n-                    out.printlns(\"file offset=\" + f_offset + \" but m_offset=\" + m_offset);\n-                    break;\n-                }\n-                int bitfield = in.readUnsignedByte();\n-                if ((bitfield & 0x80) == 0) {\n-                    out_print(\"0x\");\n-                    printByteHex(out, bitfield);\n-                    out.printlns(\"; \/\/ flags, max_stack\");\n-                    out_print(\"0x\");\n-                    printByteHex(out, in.readUnsignedByte());\n-                    out.printlns(\"; \/\/ nargs, max_locals\");\n-                    f_offset += 2;\n-                } else {\n-                    out_print(\"0x\");\n-                    printByteHex(out, bitfield);\n-                    out.printlns(\"; \/\/ flags, padding\");\n-                    out_println(in.readUnsignedByte() + \"b; \/\/ max_stack\");\n-                    out_println(in.readUnsignedByte() + \"b; \/\/ nargs\");\n-                    out_println(in.readUnsignedByte() + \"b; \/\/ max_locals\");\n-                    f_offset += 4;\n-                }\n-                int bytecode_count = methodsLengths.get(i);\n-                out_begin(\"{ \/\/ bytecodes\");\n-                printBytes(in, bytecode_count);\n-                f_offset += bytecode_count;\n-                out_end(\"};\");\n-                out_end(\"};\");\n-            }\n-        }\n-\n-        endComponent(in);\n-    }\n-\n-    void decodeStaticField(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        int image_size = in.readUnsignedShort();\n-        out_println(image_size + \"; \/\/ image size\");\n-        int reference_count = in.readUnsignedShort();\n-        out_println(reference_count + \"; \/\/ reference count\");\n-        int array_init_count = in.readUnsignedShort();\n-        out_begin(startArray(array_init_count) + \" { \/\/ array_init_info\");\n-        for (int i = 0; i < array_init_count; i++) {\n-            out_println(in.readUnsignedByte() + \"b \/\/ type \");\n-            int count = in.readUnsignedShort();\n-            out_begin(\"Bytes\" + startArray(count) + \"s { \/\/ values\");\n-            printBytes(in, count);\n-            out_end(\"};\"); \/\/ Bytes[]\n-        }\n-        out_end(\"};\"); \/\/ array_init_info\n-        int default_value_count = in.readUnsignedShort();\n-        out_println(default_value_count + \"; \/\/ default value count\");\n-        int non_default_value_count = in.readUnsignedShort();\n-        out_begin(\"Bytes\" + startArray(non_default_value_count) + \"s { \/\/ non default values\");\n-        printBytes(in, non_default_value_count);\n-        out_end(\"};\"); \/\/ Bytes[]\n-\n-        endComponent(in);\n-    }\n-\n-    void decodeRefLocation(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-\n-        int byte_index_count = in.readUnsignedShort();\n-        out_begin(\"Bytes\" + startArray(byte_index_count) + \"s { \/\/ offsets to byte indices\");\n-        printBytes(in, byte_index_count);\n-        out_end(\"};\"); \/\/ Bytes[]\n-\n-        byte_index_count = in.readUnsignedShort();\n-        out_begin(\"Bytes\" + startArray(byte_index_count) + \"s { \/\/ offsets to byte2 indices\");\n-        printBytes(in, byte_index_count);\n-        out_end(\"};\"); \/\/ Bytes[]\n-\n-        endComponent(in);\n-    }\n-\n-    void decodeExport(String inpName) throws IOException {\n-        DataInputStream in = beginComponent(inpName);\n-        int class_count = in.readUnsignedByte();\n-        out_begin(startArray(class_count) + \"b { \/\/ classes\");\n-        for (int i = 0; i < class_count; i++) {\n-            out_begin(\"{ \/\/ class \" + i);\n-            out_println(in.readUnsignedShort() + \"; \/\/ class offset\");\n-            int fcount = in.readUnsignedByte();\n-            out_println(fcount + \"b; \/\/ static field count\");\n-            int mcount = in.readUnsignedByte();\n-            out_println(mcount + \"b; \/\/ static method count\");\n-            out_begin(\"{ \/\/ static field offsets\");\n-            for (int j = 0; j < fcount; j++) {\n-                out_println(in.readUnsignedShort() + \"; \/\/ field \" + j + \" offset\");\n-            }\n-            out_end(\"};\");\n-            out_begin(\"{ \/\/ static method offsets\");\n-            for (int j = 0; j < mcount; j++) {\n-                out_println(in.readUnsignedShort() + \"; \/\/ method \" + j + \" offset\");\n-            }\n-            out_end(\"};\");\n-            out_end(\"};\"); \/\/ class i\n-        }\n-        out_end(\"};\"); \/\/ classes\n-        endComponent(in);\n-    }\n-    \/*========================================================*\/\n-\n-    \/**\n-     * Constructor.\n-     *\/\n-    public Main(ToolOutput out, String program) {\n-        this.out = out;\n-        this.program = program;\n-    }\n-\n-    public void error(String msg) {\n-        out.printlns(program + \": \" + msg);\n-    }\n-\n-    \/**\n-     * Usage\n-     *\/\n-    public void usage() {\n-        out.printlns(i18n.getString(\"jcdec.usage\"));\n-        out.printlns(i18n.getString(\"jcdec.opt.g\"));\n-        out.printlns(i18n.getString(\"jcdec.opt.version\"));\n-    }\n-\n-    \/**\n-     * Run the decoder\n-     *\/\n-    public synchronized boolean decode(String... argv) {\n-\/\/      int flags = F_WARNINGS;\n-        long tm = System.currentTimeMillis();\n-        ArrayList<String> vargs = new ArrayList<>();\n-        ArrayList<String> vj = new ArrayList<>();\n-        boolean nowrite = false;\n-        int addOptions = 0;\n-\n-        \/\/ Parse arguments\n-        for (int i = 0; i < argv.length; i++) {\n-            String arg = argv[i];\n-            if (arg.equals(\"-g\")) {\n-                printDetails = true;\n-                vargs.add(arg);\n-            } else if (arg.equals(\"-v\")) {\n-                DebugFlag = true;\n-                vargs.add(arg);\n-                out.printlns(\"arg[\" + i + \"]=\" + argv[i] + \"\/verbose\");\n-            } else if (arg.equals(org.openjdk.asmtools.Main.VERSION_SWITCH)) {\n-                out.printlns(ProductInfo.FULL_VERSION);\n-                System.exit(OK);\n-            } else if (arg.startsWith(\"-\")) {\n-\/\/out.printlns(\"arg[\"+i+\"]=\"+argv[i]+\"\/invalid flag\");\n-                error(i18n.getString(\"jcdec.error.invalid_flag\", arg));\n-                usage();\n-                return false;\n-            } else {\n-                vargs.add(arg);\n-                vj.add(arg);\n-            }\n-        }\n-\n-        if (vj.isEmpty()) {\n-            usage();\n-            return false;\n-        }\n-\n-\/\/        String[] names = new String[vj.size()];\n-\/\/        vj.copyInto(names);\n-        String[] names = null;\n-        names = vj.toArray(names);\n-decode:\n-        for (int k = 0; k < names.length; k++) {\n-            String inpname = names[k];\n-            try {\n-                if (inpname.endsWith(\".cap\")) {\n-                    String shortName = inpname.substring(0, inpname.length() - 4);\n-                    if (shortName.endsWith(\"Header\")) {\n-                        decodeHeader(inpname);\n-                    } else if (shortName.endsWith(\"Directory\")) {\n-                        decodeDirectory(inpname);\n-                    } else if (shortName.endsWith(\"Applet\")) {\n-                        decodeApplet(inpname);\n-                    } else if (shortName.endsWith(\"Import\")) {\n-                        decodeImport(inpname);\n-                    } else if (shortName.endsWith(\"ConstantPool\")) {\n-                        decodeConstantPool(inpname);\n-                    } else if (shortName.endsWith(\"Class\")) {\n-                        decodeClass(inpname);\n-                    } else if (shortName.endsWith(\"Descriptor\")) {\n-                        decodeDescriptor(inpname);\n-                    } else if (shortName.endsWith(\"Method\")) {\n-                        decodeMethod(inpname);\n-                    } else if (shortName.endsWith(\"StaticField\")) {\n-                        decodeStaticField(inpname);\n-                    } else if (shortName.endsWith(\"RefLocation\")) {\n-                        decodeRefLocation(inpname);\n-                    } else if (shortName.endsWith(\"Export\")) {\n-                        decodeExport(inpname);\n-                    } else {\n-                        continue decode;\n-                    }\n-                    out.printlns(\"\");\n-                } else if (inpname.endsWith(\".exp\")) {\n-                    decodeExp(inpname);\n-                    out.printlns(\"\");\n-                }\n-                continue decode;\n-            } catch (FileNotFoundException ee) {\n-                error(i18n.getString(\"jcdec.error.cannot_read\", inpname));\n-            } catch (Error ee) {\n-                ee.printStackTrace();\n-                error(i18n.getString(\"jcdec.error.fatal_error\"));\n-            } catch (Exception ee) {\n-                ee.printStackTrace();\n-                error(i18n.getString(\"jcdec.error.fatal_exceptPrintWriter ion\"));\n-            }\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Main program\n-     *\/\n-    public static void main(String... argv) {\n-        Main decoder = new Main(new ToolOutput.EscapedPrintStreamOutput(System.out), \"jcdec\");\n-        System.exit(decoder.decode(argv) ? 0 : 1);\n-    }\n-}\n","filename":"src\/org\/openjdk\/asmtools\/jcdec\/Main.java","additions":0,"deletions":959,"binary":false,"changes":959,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-# Copyright (c) 2014 Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-jcdec.error.invalid_flag=invalid flag: \" {0}\n-jcdec.error.fatal_error=fatal error\n-jcdec.error.fatal_exception=fatal exception\n-jcdec.error.cannot_read=cannot read {0}\n-jcdec.usage=\\\n-Usage: java -jar asmtools.jar jcdec [options] FILE.class... > FILE.jcod\\n\\\n-where possible options include:\n-# jcdec currently do not support shared resources\n-jcdec.opt.g=\\\n-\\     -g:  detailed output format\n-jcdec.opt.version=\\\n-\\     -version:  print version number and date\n-\n","filename":"src\/org\/openjdk\/asmtools\/jcdec\/i18n.properties","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -674,1 +674,1 @@\n-                            environment.error(scanner.pos, \"toplevel.expected\");\n+                            environment.error(scanner.pos, \"err.toplevel.expected\");\n","filename":"src\/org\/openjdk\/asmtools\/jcoder\/Jcoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,9 +25,6 @@\n-import org.openjdk.asmtools.common.CompilerLogger;\n-import org.openjdk.asmtools.common.EMessageKind;\n-import org.openjdk.asmtools.common.Environment;\n-import org.openjdk.asmtools.common.NotImplementedException;\n-import org.openjdk.asmtools.common.ToolInput;\n-import org.openjdk.asmtools.common.ToolOutput;\n-import org.openjdk.asmtools.util.I18NResourceBundle;\n-\n-import java.io.*;\n+import org.openjdk.asmtools.common.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -42,2 +39,5 @@\n-    private JcoderEnvironment(Builder<JcoderEnvironment, CompilerLogger> builder, I18NResourceBundle i18n) {\n-        super(builder, i18n);\n+    \/**\n+     * @param builder the jcoder environment builder\n+     *\/\n+    private JcoderEnvironment(Builder<JcoderEnvironment, CompilerLogger> builder) {\n+        super(builder);\n@@ -115,1 +115,1 @@\n-            super(\"jcoder\", toolOutput, new CompilerLogger(log));\n+            super(toolOutput, new CompilerLogger(\"jcoder\", JcoderEnvironment.class, log));\n@@ -120,1 +120,1 @@\n-            return new JcoderEnvironment(this, I18NResourceBundle.getBundleForClass(this.getClass()));\n+            return new JcoderEnvironment(this);\n@@ -131,1 +131,1 @@\n-        private int chpos;\n+        private int chPos;\n@@ -136,1 +136,1 @@\n-            chpos = LINEINC;\n+            chPos = LINEINC;\n@@ -144,2 +144,2 @@\n-            pos = chpos;\n-            chpos += OFFSETINC;\n+            pos = chPos;\n+            chPos += OFFSETINC;\n@@ -167,1 +167,1 @@\n-                    chpos += OFFSETINC;\n+                    chPos += OFFSETINC;\n@@ -169,1 +169,1 @@\n-                        chpos += OFFSETINC;\n+                        chPos += OFFSETINC;\n@@ -174,1 +174,1 @@\n-                    for (int i = 0; i < 4; i++, chpos += OFFSETINC, c = in.read()) {\n+                    for (int i = 0; i < 4; i++, chPos += OFFSETINC, c = in.read()) {\n@@ -190,1 +190,1 @@\n-                    chpos += LINEINC;\n+                    chPos += LINEINC;\n@@ -197,1 +197,1 @@\n-                        chpos += OFFSETINC;\n+                        chPos += OFFSETINC;\n@@ -199,1 +199,1 @@\n-                    chpos += LINEINC;\n+                    chPos += LINEINC;\n","filename":"src\/org\/openjdk\/asmtools\/jcoder\/JcoderEnvironment.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.PrintWriter;\n-\n@@ -32,1 +30,0 @@\n-\n","filename":"src\/org\/openjdk\/asmtools\/jcoder\/JcoderTool.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Collections;\n@@ -71,4 +72,2 @@\n-        for(ToolInput toolInput: toolInputs){\n-            fileList.add(toolInput);\n-        }\n-        parseArgs(new String[0]);\n+        Collections.addAll(fileList, toolInputs);\n+        parseArgs();\n","filename":"src\/org\/openjdk\/asmtools\/jcoder\/Main.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-            environment.error(inputFile.pos, \"invalid.number\", Character.toString((char) ch));\n+            environment.error(inputFile.pos, \"err.invalid.number\", Character.toString((char) ch));\n@@ -312,1 +312,1 @@\n-            environment.error(pos, \"overflow\");\n+            environment.error(pos, \"err.overflow\");\n","filename":"src\/org\/openjdk\/asmtools\/jcoder\/Scanner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-\\     -nowrite        Do not write generated class files\n+\\     -nowrite Do not write generated class files\n@@ -29,1 +29,1 @@\n-\\     -ignore         Ignore non-fatal error(s) that suppress writing class files\n+\\     -ignore Ignore non-fatal error(s) that suppress writing class files\n","filename":"src\/org\/openjdk\/asmtools\/jcoder\/i18n.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,2 @@\n-                throw new FormatError(\"err.file.empty\", environment.getSimpleInputFileName());\n+                throw new FormatError(environment.getLogger(),\n+                        \"err.file.empty\", environment.getSimpleInputFileName());\n@@ -1220,1 +1221,0 @@\n-\n","filename":"src\/org\/openjdk\/asmtools\/jdec\/ClassData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import org.openjdk.asmtools.util.I18NResourceBundle;\n-\n-import java.io.PrintWriter;\n@@ -41,2 +38,5 @@\n-    private JdecEnvironment(Builder<JdecEnvironment, DecompilerLogger> builder, I18NResourceBundle i18n) {\n-        super(builder, i18n);\n+    \/**\n+     * @param builder the jdec environment builder\n+     *\/\n+    private JdecEnvironment(Builder<JdecEnvironment, DecompilerLogger> builder) {\n+        super(builder);\n@@ -58,1 +58,1 @@\n-        getToolOutput().printlns(( args == null || args.length == 0) ? format : format(format, args));\n+        getToolOutput().printlns((args == null || args.length == 0) ? format : format(format, args));\n@@ -68,1 +68,1 @@\n-        getToolOutput().prints(( args == null || args.length == 0) ? format : format(format, args));\n+        getToolOutput().prints((args == null || args.length == 0) ? format : format(format, args));\n@@ -76,1 +76,0 @@\n-\n@@ -80,1 +79,1 @@\n-            super(\"jdec\", toolOutput, new DecompilerLogger(log));\n+            super(toolOutput, new DecompilerLogger(\"jdec\", JdecEnvironment.class, log));\n@@ -85,1 +84,1 @@\n-            return new JdecEnvironment(this, I18NResourceBundle.getBundleForClass(this.getClass()));\n+            return new JdecEnvironment(this);\n","filename":"src\/org\/openjdk\/asmtools\/jdec\/JdecEnvironment.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import org.openjdk.asmtools.common.uEscWriter;\n@@ -30,1 +29,0 @@\n-import java.io.PrintWriter;\n","filename":"src\/org\/openjdk\/asmtools\/jdec\/JdecTool.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Collections;\n@@ -44,4 +45,2 @@\n-        for(ToolInput toolInput: toolInputs){\n-            fileList.add(toolInput);\n-        }\n-        parseArgs(new String[0]);\n+        Collections.addAll(fileList, toolInputs);\n+        parseArgs();\n@@ -72,22 +71,0 @@\n-\/\/    public static final I18NResourceBundle i18n\n-\/\/            = I18NResourceBundle.getBundleForClass(Main.class);\n-\/\/    int printFlags = 0;\n-\/\/\n-\/\/    public Main(PrintWriter out, PrintWriter err, String programName) {\n-\/\/        super(out, err, programName);\n-\/\/        printCannotReadMsg = (fname) ->\n-\/\/                error(i18n.getString(\"jdec.error.cannot_read\", fname));\n-\/\/    }\n-\/\/\n-\/\/    public Main(PrintStream out, String program) {\n-\/\/        this(new PrintWriter(out), new PrintWriter(System.err), program);\n-\/\/    }\n-\/\/\n-\/\/    \/**\n-\/\/     * Main program\n-\/\/     *\/\n-\/\/    public static void main(String... argv) {\n-\/\/        Main decoder = new Main(new PrintWriter(new uEscWriter(System.out)), new PrintWriter(System.err), \"jdec\");\n-\/\/        System.exit(decoder.decode(argv) ? 0 : 1);\n-\/\/    }\n-\n@@ -160,8 +137,0 @@\n-\/\/                DataInputStream dataInputStream = getDataInputStream(inpname);\n-\/\/                if (dataInputStream == null)\n-\/\/                    return false;\n-\/\/                ClassData cc = new ClassData(dataInputStream, printFlags, toolOutput);\n-\/\/                cc.DebugFlag = VerboseFlag.getAsBoolean();\n-\/\/                cc.decodeClass(inpname);\n-\/\/                toolOutput.flush();\n-\/\/                continue;\n@@ -190,33 +159,0 @@\n-\n-\/\/        long tm = System.currentTimeMillis();\n-\/\/        ArrayList<String> vargs = new ArrayList<>();\n-\/\/        ArrayList<String> vj = new ArrayList<>();\n-\/\/        boolean nowrite = false;\n-\/\/        int addOptions = 0;\n-\/\/\n-\/\/\n-\/\/\n-\/\/        String[] names = new String[0];\n-\/\/        names = vj.toArray(names);\n-\/\/        for (String inpname : names) {\n-\/\/            try {\n-\/\/                DataInputStream dataInputStream = getDataInputStream(inpname);\n-\/\/                if (dataInputStream == null)\n-\/\/                    return false;\n-\/\/                ClassData cc = new ClassData(dataInputStream, printFlags, toolOutput);\n-\/\/                cc.DebugFlag = VerboseFlag.getAsBoolean();\n-\/\/                cc.decodeClass(inpname);\n-\/\/                toolOutput.flush();\n-\/\/                continue;\n-\/\/            } catch (Error ee) {\n-\/\/                if (VerboseFlag.getAsBoolean())\n-\/\/                    ee.printStackTrace();\n-\/\/                error(i18n.getString(\"jdec.error.fatal_error\"));\n-\/\/            } catch (Exception ee) {\n-\/\/                if (VerboseFlag.getAsBoolean())\n-\/\/                    ee.printStackTrace();\n-\/\/                error(i18n.getString(\"jdec.error.fatal_exception\"));\n-\/\/            }\n-\/\/            return false;\n-\/\/        }\n-\/\/        return true;\n","filename":"src\/org\/openjdk\/asmtools\/jdec\/Main.java","additions":4,"deletions":68,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -89,1 +89,2 @@\n-            default -> throw new FormatError(\"err.unknown.tag\", isPrintableChar(tg) ? tg : '?', Integer.toHexString(tg));\n+            default -> throw new FormatError(data.environment.getLogger(),\n+                    \"err.unknown.tag\", isPrintableChar(tg) ? tg : '?', Integer.toHexString(tg));\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/AnnotationElement.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,1 +195,2 @@\n-                    throw new FormatError(\"err.invalid.attribute.length\", \"SourceFile_attribute\", attributeLength);\n+                    throw new FormatError(environment.getLogger(),\n+                            \"err.invalid.attribute.length\", \"SourceFile_attribute\", attributeLength);\n@@ -206,1 +207,2 @@\n-                    throw new FormatError(\"err.invalid.attribute.length\", \"InnerClasses_attribute\", attributeLength);\n+                    throw new FormatError(environment.getLogger(),\n+                            \"err.invalid.attribute.length\", \"InnerClasses_attribute\", attributeLength);\n@@ -291,1 +293,1 @@\n-            throw new FormatError(\"err.eof\");\n+            throw new FormatError(environment.getLogger(),\"err.eof\");\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/ClassData.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    private void readStackMap(DataInputStream in) throws IOException {\n+    private void readStackMapEntity(StackMapData.EAttributeType type, DataInputStream in) throws IOException {\n@@ -158,1 +158,0 @@\n-        environment.traceln(\"CodeAttr:  Stack_Map: attrLength=%d num=%d\", len, stack_map_len);\n@@ -160,1 +159,2 @@\n-        StackMapData.prevFramePC = 0;\n+        environment.traceln(\"CodeAttr:  %s: attrLength=%d num=%d\", type.getName(), len, stack_map_len);\n+        int prevFrame_pc = 0;\n@@ -162,12 +162,3 @@\n-            stack_map.add(new StackMapData(StackMapData.EDataType.STACKMAP, this, in));\n-        }\n-    }\n-\n-    private void readStackMapTable(DataInputStream in) throws IOException {\n-        int len = in.readInt(); \/\/ attr_length\n-        int stack_map_len = in.readUnsignedShort();\n-        environment.traceln(\"CodeAttr:  Stack_Map_Table: attrLength=%d num=%d\", len, stack_map_len);\n-        stack_map = new ArrayList<>(stack_map_len);\n-        StackMapData.prevFramePC = 0;\n-        for (int k = 0; k < stack_map_len; k++) {\n-            stack_map.add(new StackMapData(StackMapData.EDataType.STACKMAPTABLE, this, in));\n+            StackMapData stackMapData =  new StackMapData(type, k == 0, prevFrame_pc, this, in);\n+            prevFrame_pc = stackMapData.getFramePC();\n+            stack_map.add(stackMapData);\n@@ -230,2 +221,2 @@\n-                    case ATT_StackMap -> readStackMap(in);\n-                    case ATT_StackMapTable -> readStackMapTable(in);\n+                    case ATT_StackMap -> readStackMapEntity(StackMapData.EAttributeType.STACKMAP, in);\n+                    case ATT_StackMapTable -> readStackMapEntity(StackMapData.EAttributeType.STACKMAPTABLE, in);\n@@ -311,1 +302,1 @@\n-            getInstructionAttribute(entry.start_pc).stackMapEntry = entry;\n+            getInstructionAttribute(entry.frame_pc).stackMapEntry = entry;\n@@ -455,1 +446,1 @@\n-                    breakPositions.addAll(Set.of(3));\n+                    breakPositions.add(3);\n@@ -463,1 +454,1 @@\n-                    breakPositions.addAll(Set.of(3));\n+                    breakPositions.add(3);\n@@ -745,1 +736,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/CodeData.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-                    throw new FormatError(\"err.invalid.attribute.length\",\n+                    throw new FormatError(environment.getLogger(),\n+                            \"err.invalid.attribute.length\",\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/FieldData.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import static org.openjdk.asmtools.jdis.StackMapData.EDataType.STACKMAPTABLE;\n+import static org.openjdk.asmtools.jdis.StackMapData.EAttributeType.STACKMAPTABLE;\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/InstructionAttr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import org.openjdk.asmtools.common.EMessageKind;\n@@ -28,1 +27,0 @@\n-import org.openjdk.asmtools.common.ToolLogger;\n@@ -30,3 +28,0 @@\n-import org.openjdk.asmtools.util.I18NResourceBundle;\n-\n-import java.io.PrintWriter;\n@@ -36,3 +31,5 @@\n-\n-    private JdisEnvironment(Builder<JdisEnvironment, DecompilerLogger> builder, I18NResourceBundle i18n) {\n-        super(builder, i18n);\n+    \/**\n+     * @param builder the jdis environment builder\n+     *\/\n+    private JdisEnvironment(Builder<JdisEnvironment, DecompilerLogger> builder) {\n+        super(builder);\n@@ -46,8 +43,1 @@\n-    @Override\n-    public void error(Throwable exception) {\n-        printErrorLn(ToolLogger.EMessageFormatter.VERBOSE.apply(\n-                new ToolLogger.Message(EMessageKind.ERROR, exception.getMessage())));\n-    }\n-\n-\n-    static class JDecBuilder extends Environment.Builder<JdisEnvironment, DecompilerLogger> {\n+    static class JdisBuilder extends Environment.Builder<JdisEnvironment, DecompilerLogger> {\n@@ -55,2 +45,2 @@\n-        public JDecBuilder(ToolOutput toolOutput, ToolOutput.DualStreamToolOutput outerLog) {\n-            super(\"jdis\", toolOutput, new DecompilerLogger(outerLog));\n+        public JdisBuilder(ToolOutput toolOutput, ToolOutput.DualStreamToolOutput outerLog) {\n+            super(toolOutput, new DecompilerLogger(\"jdis\", JdisEnvironment.class, outerLog));\n@@ -61,1 +51,1 @@\n-            return new JdisEnvironment(this, I18NResourceBundle.getBundleForClass(this.getClass()));\n+            return new JdisEnvironment(this);\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/JdisEnvironment.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import org.openjdk.asmtools.jdis.JdisEnvironment.JDecBuilder;\n+import org.openjdk.asmtools.jdis.JdisEnvironment.JdisBuilder;\n@@ -41,1 +41,1 @@\n-        JDecBuilder builder = new JDecBuilder(toolOutput, outerLog);\n+        JdisBuilder builder = new JdisBuilder(toolOutput, outerLog);\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/JdisTool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -228,1 +228,2 @@\n-                        throw new FormatError(\"err.invalid.attribute.length\",  tag.printValue(), attrLength);\n+                        throw new FormatError(environment.getLogger(),\n+                                \"err.invalid.attribute.length\",  tag.printValue(), attrLength);\n@@ -235,2 +236,2 @@\n-                        throw new FormatError(\"err.invalid.attribute.length\",\n-                                tag.printValue(), attrLength);\n+                        throw new FormatError(environment.getLogger(),\n+                                \"err.invalid.attribute.length\", tag.printValue(), attrLength);\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/MemberData.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-            throw new FormatError(\"err.invalid_header\");\n+            throw new FormatError(environment.getLogger(), \"err.invalid_header\");\n@@ -129,1 +129,1 @@\n-            throw new FormatError(\"err.invalid_requires\");\n+            throw new FormatError(environment.getLogger(), \"err.invalid_requires\");\n@@ -153,1 +153,1 @@\n-            throw new FormatError(\"err.invalid_exports\");\n+            throw new FormatError(environment.getLogger(), \"err.invalid_exports\");\n@@ -177,1 +177,1 @@\n-            throw new FormatError(\"err.invalid_opens\");\n+            throw new FormatError(environment.getLogger(), \"err.invalid_opens\");\n@@ -190,1 +190,1 @@\n-            throw new FormatError(\"err.invalid_uses\");\n+            throw new FormatError(environment.getLogger(), \"err.invalid_uses\");\n@@ -209,1 +209,1 @@\n-            throw new FormatError(\"err.invalid_provides\");\n+            throw new FormatError(environment.getLogger(), \"err.invalid_provides\");\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/ModuleData.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,1 +51,2 @@\n-            throw new FormatError(\"err.invalid.attribute.length\", EAttribute.ATT_Signature.printValue(), attribute_length);\n+            throw new FormatError(environment.getLogger(),\n+                    \"err.invalid.attribute.length\", EAttribute.ATT_Signature.printValue(), attribute_length);\n@@ -75,3 +76,3 @@\n-    public Pair<String,String> getPrintInfo(Function<Integer, Boolean> checkRange) {\n-        return new Pair<>( format(\":#%d\",index),\n-                checkRange.apply(index) ?  format(\":%s\",pool.StringValue(index)) : \":?? invalid index\");\n+    public Pair<String, String> getPrintInfo(Function<Integer, Boolean> checkRange) {\n+        return new Pair<>(format(\":#%d\", index),\n+                checkRange.apply(index) ? format(\":%s\", pool.StringValue(index)) : \":?? invalid index\");\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/SignatureData.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,4 +38,1 @@\n-\n-    static int prevFramePC = 0;\n-\n-    EDataType type;\n+    EAttributeType type;\n@@ -43,1 +40,2 @@\n-    int start_pc;\n+    int frame_pc;\n+    int offset;\n@@ -47,1 +45,10 @@\n-    public StackMapData(EDataType type, CodeData code, DataInputStream in) throws IOException {\n+    \/**\n+     * @param type          either Implicit stack map attribute or the StackMapTable attribute\n+     * @param firstStackMap is it an entries[0] in the stack_map_frame structure? i.e. Does the StackMapData describe\n+     *                      the second stack map frame of the method?\n+     * @param prevFrame_pc  the bytecode offset of the previous entry (entries[current_index-1])\n+     * @param code          the code attribute where this attribute is located\n+     * @param in            the input stream\n+     * @throws IOException  the exception if something went wrong\n+     *\/\n+    public StackMapData(EAttributeType type, boolean firstStackMap, int prevFrame_pc, CodeData code, DataInputStream in) throws IOException {\n@@ -50,2 +57,2 @@\n-        if (type == EDataType.STACKMAP) {\n-            start_pc = in.readUnsignedShort();\n+        if (type == EAttributeType.STACKMAP) {\n+            frame_pc = in.readUnsignedShort();\n@@ -55,1 +62,1 @@\n-                    start_pc, mapToHexString(lockMap), mapToHexString(stackMap));\n+                    frame_pc, mapToHexString(lockMap), mapToHexString(stackMap));\n@@ -59,1 +66,0 @@\n-            int offset = 0;\n@@ -108,2 +114,5 @@\n-            start_pc = prevFramePC == 0 ? offset : prevFramePC + offset + 1;\n-            prevFramePC = start_pc;\n+            if( prevFrame_pc == 0 && firstStackMap) {\n+                frame_pc = offset;\n+            } else {\n+                frame_pc = prevFrame_pc + offset + 1;\n+            }\n@@ -113,0 +122,7 @@\n+    \/**\n+     * @return the bytecode offset at which a stack map frame applies\n+     *\/\n+    public int getFramePC() {\n+        return frame_pc;\n+    }\n+\n@@ -125,1 +141,1 @@\n-                        throw new FormatError(s);\n+                        throw new FormatError(environment.getLogger(), s);\n@@ -140,1 +156,19 @@\n-    enum EDataType {STACKMAP, STACKMAPTABLE}\n+    \/*\n+     *  In a class file whose version number is 50.0 or above, if a method's Code attribute does not have a StackMapTable attribute,\n+     *  it has an implicit stack map attribute (chapter 4.10.1). This implicit stack map attribute is equivalent to a StackMapTable\n+     *  attribute with number_of_entries equal to zero.\n+     *\/\n+    enum EAttributeType {\n+        \/\/ Implicit stack map attribute\n+        \/\/ This implicit stack map attribute is equivalent to a StackMapTable attribute with number_of_entries equal to zero.\n+        STACKMAP(\"ImplicitStackMap\"),\n+        \/\/ The StackMapTable attribute\n+        STACKMAPTABLE(\"StackMapTable\");\n+        private final String name;\n+        EAttributeType(String name) {\n+            this.name = name;\n+        }\n+        public String getName() {\n+            return name;\n+        }\n+    }\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/StackMapData.java","additions":48,"deletions":14,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-\\     -g       Generate a detailed output format\n+\\     -g Generate a detailed output format\n@@ -30,1 +30,1 @@\n-\\     -sl      Print source lines in comments if a source file is in the same folder\n+\\     -sl Print source lines in comments if a source file is in the same folder\n@@ -32,1 +32,1 @@\n-\\     -lt      Print source line numbers in comments\n+\\     -lt Print source line numbers in comments\n@@ -34,1 +34,1 @@\n-\\     -lv      Print local variable table(s)\n+\\     -lv Print local variable table(s)\n@@ -36,1 +36,1 @@\n-\\     -hx      Generate floating-point constants in hexadecimal format\n+\\     -hx Generate floating-point constants in hexadecimal format\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/i18n.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -64,13 +64,13 @@\n-    \/**\n-     * Get an entry from the resource bundle. If the resource cannot be found, a message\n-     * is printed to the console and the result will be a string containing the method\n-     * parameters.\n-     *\n-     * @param key the name of the entry to be returned\n-     * @param arg an argument to be formatted into the result using\n-     * {@link java.text.MessageFormat#format}\n-     * @return the formatted string\n-     *\/\n-    public String getString(String key, Object arg) {\n-        return getString(key, new Object[]{arg});\n-    }\n+\/\/    \/**\n+\/\/     * Get an entry from the resource bundle. If the resource cannot be found, a message\n+\/\/     * is printed to the console and the result will be a string containing the method\n+\/\/     * parameters.\n+\/\/     *\n+\/\/     * @param key the name of the entry to be returned\n+\/\/     * @param arg an argument to be formatted into the result using\n+\/\/     * {@link java.text.MessageFormat#format}\n+\/\/     * @return the formatted string\n+\/\/     *\/\n+\/\/    public String getString(String key, Object arg) {\n+\/\/        return getString(key, new Object[]{arg});\n+\/\/    }\n@@ -138,1 +138,1 @@\n-                System.err.println(\"WARNING: missing resource: \\\"\" + key + \" for \\\"\" + name);\n+                System.err.println(\"WARNING: resource: '\" + key + \"' not found in \" + name);\n","filename":"src\/org\/openjdk\/asmtools\/util\/I18NResourceBundle.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+package org.openjdk.asmtools;\n+\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.openjdk.asmtools.common.CompileAction;\n+import org.opentest4j.MultipleFailuresError;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class SequenceCallsTests {\n+    final String TEST_RESOURCE_FOLDER = \"sequence\" + File.separator;\n+\n+    private List<Error> errors = Collections.synchronizedList(new ArrayList<>());\n+\n+    CompileAction sequenceCompiler;\n+    File resourceDir;\n+    HashMap<String, List<List<String>>> cases = new HashMap<>() {{\n+        put(\"jasm\",\n+                List.of(\n+                        List.of(\"EnclMethTest.jcod\"),\n+                        List.of(\"ConstantPoolTestDummy.jasm\"),\n+                        List.of(\"Not_Found_1.jasm\"),\n+                        List.of(\"nonvoidinit.jasm\", \"nonvoidinit.jasm\"),\n+                        List.of(\"Not_Found_2.jasm\"),\n+                        List.of(\"TestInterface01n01.jasm\")\n+                )\n+        );\n+        put(\"jcoder\",\n+                List.of(\n+                        List.of(\"EnclMethTest.jcod\"),\n+                        List.of(\"ConstantPoolTestDummy.jasm\"),\n+                        List.of(\"Not_Found_I.jcod\"),\n+                        List.of(\"module-info.jcod\"),\n+                        List.of(\"atrcod00402m1n.jcod\", \"stackmap00601m1n.jcod\"),\n+                        List.of(\"Not_Found_II.jcod\")\n+                )\n+        );\n+    }};\n+\n+    @BeforeAll\n+    public void init() throws IOException {\n+        String resName = TEST_RESOURCE_FOLDER + \"EnclMethTest.jcod\";        \/\/ must exist to get a correct path to files\n+        File file = new File(this.getClass().getResource(resName).getFile());\n+        resourceDir = file.getParentFile();\n+        sequenceCompiler = new CompileAction();\n+    }\n+\n+    public class CaseExecutor implements Runnable {\n+        private AtomicInteger counter = new AtomicInteger(0);\n+\n+        public void run() throws MultipleFailuresError {\n+            int index = counter.getAndIncrement();\n+            List<String> jasmFiles = cases.get(\"jasm\").get(index).stream().\n+                    map(f -> resourceDir + File.separator + f).collect(Collectors.toList());\n+            List<String> jcodFiles = cases.get(\"jcoder\").get(index).stream().\n+                    map(f -> resourceDir + File.separator + f).collect(Collectors.toList());\n+            if (index % 2 == 0) {\n+                assertAll(() -> sequenceCompiler.jasm(jasmFiles),\n+                        () -> sequenceCompiler.jcoder(jcodFiles));\n+            } else {\n+                assertAll(() -> sequenceCompiler.jcoder(jcodFiles),\n+                        () -> sequenceCompiler.jasm(jasmFiles));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCompilersWithConcurrency() throws InterruptedException {\n+        int numberOfThreads = cases.get(\"jasm\").size();\n+        ExecutorService service = Executors.newFixedThreadPool(numberOfThreads);\n+        CountDownLatch latch = new CountDownLatch(numberOfThreads);\n+        CaseExecutor caseExecutor = new CaseExecutor();\n+        for (int i = 0; i < numberOfThreads; i++) {\n+            service.execute(() -> {\n+                        try {\n+                            caseExecutor.run();\n+                        } catch (MultipleFailuresError error) {\n+                            errors.add(error);\n+                        }\n+                        latch.countDown();\n+                    }\n+            );\n+        }\n+        latch.await();\n+        \/\/\n+        assertEquals(6,\n+                errors.stream().mapToInt(e -> ((MultipleFailuresError) e).getFailures().size()).sum(),\n+                \"Expected 4 missing & 2 wrong format files.\");\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/asmtools\/SequenceCallsTests.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+package org.openjdk.asmtools.common;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class CompileAction {\n+\n+    private final File destDir;\n+\n+    public CompileAction() throws IOException {\n+        destDir = Files.createTempDirectory(\"compile\").toFile();\n+        destDir.deleteOnExit();\n+    }\n+\n+    public CompileAction(File destDir) {\n+        this.destDir = destDir;\n+    }\n+\n+    public void jasm(List<String> files) {\n+        action(\"jasm\", files);\n+    }\n+\n+    public void jcoder(List<String> files) {\n+        action(\"jcoder\", files);\n+    }\n+\n+\n+    private void action(String toolName, List<String> files) {\n+        if (files.isEmpty())\n+            fail(toolName + \": no files\");\n+        List<String> toolArgs = new ArrayList<>();\n+        toolArgs.add(\"-d\");\n+        toolArgs.add(destDir.getPath());\n+        toolArgs.addAll(files);\n+        try {\n+            String toolClassName = \"org.openjdk.asmtools.\" + toolName + \".Main\";\n+            Class<?> toolClass = Class.forName(toolClassName);\n+            Constructor<?> constr = toolClass.getConstructor(PrintStream.class, String.class);\n+            PrintStream ps = new PrintStream(System.out);\n+            Object tool = constr.newInstance(ps, toolName);\n+            Method m = toolClass.getMethod(\"compile\", String[].class);\n+            Object r = m.invoke(tool, new Object[]{toolArgs.toArray(new String[0])});\n+            if (r instanceof Boolean) {\n+                boolean ok = (Boolean) r;\n+                if (!ok) {\n+                    fail(toolName + \" failed\");\n+                }\n+                System.out.println(toolName + \" OK\");\n+            } else\n+                fail(\"unexpected result from \" + toolName + \": \" + r.toString());\n+        } catch (ClassNotFoundException e) {\n+            fail(\"can't find \" + toolName);\n+        } catch (ReflectiveOperationException t) {\n+            fail(\"error invoking \" + toolName + \": \" + t);\n+        }\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/asmtools\/common\/CompileAction.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package  jdk\/internal\/reflect\/constantPool;\n+\n+super public    #2; \/\/class ConstantPoolTestDummy\n+    version 52:0\n+{\n+\n+\/\/ Actually, only first 13 constant pool entries are actually used by the class\n+\/\/ and its methods. All the rest are added just for the testing of getTagAt method\n+\/\/ and getNameAndTypeRefIndexAt method.\n+\n+const #1 = Method   #3.#10; \/\/  java\/lang\/Object.\"<init>\":\"()V\"\n+const #2 = class    #11;    \/\/  ConstantPoolTestDummy\n+const #3 = class    #12;    \/\/  java\/lang\/Object\n+const #4 = Asciz    \"<init>\";\n+const #5 = Asciz    \"()V\";\n+const #6 = Asciz    \"Code\";\n+const #7 = Asciz    \"LineNumberTable\";\n+const #8 = Asciz    \"SourceFile\";\n+const #9 = Asciz    \"ConstantPoolTestDummy.java\";\n+const #10 = NameAndType #4:#5;  \/\/  \"<init>\":\"()V\"\n+const #11 = Asciz   \"jdk\/internal\/reflect\/constantPool\/ConstantPoolTestDummy\";\n+const #12 = Asciz   \"java\/lang\/Object\";\n+const #13 = long    6l;\n+const #15 = int     1;\n+const #16 = InterfaceMethod #17.#18;    \/\/  java\/lang\/Runnable.run:\"()V\"\n+const #17 = class   #19;    \/\/  java\/lang\/Runnable\n+const #18 = NameAndType #20:#5;    \/\/  run:\"()V\"\n+const #19 = Asciz   \"java\/lang\/Runnable\";\n+const #20 = Asciz   \"run\";\n+const #21 = double   1.45d;\n+const #23 = String   #24;    \/\/  \"Hello\"\n+const #24 = Asciz   \"Hello\";\n+const #25 = InvokeDynamic   0:#26;  \/\/  REF_invokeStatic:java\/lang\/invoke\/LambdaMetafactory.metafactory:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\":accept:\"()Ljava\/util\/function\/Consumer;\" MethodType \"(Ljava\/lang\/Object;)V\", MethodHandle REF_invokeVirtual:java\/lang\/Object.toString:\"()Ljava\/lang\/String;\", MethodType \"(Ljava\/lang\/Object;)V\"\n+const #26 = NameAndType #27:#28;    \/\/  accept:\"()Ljava\/util\/function\/Consumer;\"\n+const #27 = Asciz   \"accept\";\n+const #28 = Asciz   \"()Ljava\/util\/function\/Consumer;\";\n+const #29 = MethodHandle    6:#32;  \/\/  REF_invokeStatic:java\/lang\/invoke\/LambdaMetafactory.metafactory:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"\n+const #30 = MethodType  #33;    \/\/  \"(Ljava\/lang\/Object;)V\"\n+const #31 = MethodHandle    5:#34;  \/\/  REF_invokeVirtual:java\/lang\/Object.toString:\"()Ljava\/lang\/String;\"\n+const #32 = Method  #35.#36;    \/\/  java\/lang\/invoke\/LambdaMetafactory.metafactory:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"\n+const #33 = Asciz   \"(Ljava\/lang\/Object;)V\";\n+const #34 = Method  #3.#37; \/\/  java\/lang\/Object.toString:\"()Ljava\/lang\/String;\"\n+const #35 = class   #38;    \/\/  java\/lang\/invoke\/LambdaMetafactory\n+const #36 = NameAndType #39:#40;    \/\/  metafactory:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"\n+const #37 = NameAndType #41:#42;    \/\/  toString:\"()Ljava\/lang\/String;\"\n+const #38 = Asciz   \"java\/lang\/invoke\/LambdaMetafactory\";\n+const #39 = Asciz   \"metafactory\";\n+const #40 = Asciz   \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\";\n+const #41 = Asciz   \"toString\";\n+const #42 = Asciz   \"()Ljava\/lang\/String;\";\n+const #43 = class   #46;    \/\/  java\/lang\/invoke\/MethodHandles$Lookup\n+const #44 = Asciz   \"Lookup\";\n+const #45 = class   #47;    \/\/  java\/lang\/invoke\/MethodHandles\n+const #46 = Asciz   \"java\/lang\/invoke\/MethodHandles$Lookup\";\n+const #47 = Asciz   \"java\/lang\/invoke\/MethodHandles\";\n+const #48 = Field    #2.#49;    \/\/  jdk\/internal\/reflect\/constantPool\/ConstantPoolTestDummy.myField:\"I\"\n+const #49 = NameAndType #50:#51;    \/\/  myField:\"I\"\n+const #50 = Asciz   \"myField\";\n+const #51 = Asciz   \"I\";\n+const #52 = float   1.34f;\n+\n+public Method #4:#5  \/\/ \"<init>\":\"()V\"\n+\n+    stack 1 locals 1\n+{\n+3   0:  aload_0;\n+    1:  invokespecial   #1; \/\/  Method java\/lang\/Object.\"<init>\":\"()V\";\n+    4:  return;\n+}\n+\n+public static final InnerClass #44= #43 of #45; \/\/Lookup=class java\/lang\/invoke\/MethodHandles$Lookup of class java\/lang\/invoke\/MethodHandles\n+\n+BootstrapMethod #29 #30 #31 #30;\n+\n+} \/\/ end Class ConstantPoolTestDummy\n","filename":"test\/resources\/org\/openjdk\/asmtools\/sequence\/ConstantPoolTestDummy.jasm","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This test has a EnclosingMethod attribute with an illegal\n+ * attribute_length field value of 6.  This should cause a\n+ * java.lang.ClassFormatError exception to be thrown.\n+ *\/\n+\n+class EnclMethTest {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  52; \/\/ version\n+  [22] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #3 #14; \/\/ #1     at 0x0A\n+    Method #4 #15; \/\/ #2     at 0x0F\n+    class #16; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"this$0\"; \/\/ #5     at 0x1A\n+    Utf8 \"La;\"; \/\/ #6     at 0x23\n+    Utf8 \"Synthetic\"; \/\/ #7     at 0x29\n+    Utf8 \"<init>\"; \/\/ #8     at 0x35\n+    Utf8 \"(Ljava\/lang\/Object;)V\"; \/\/ #9     at 0x3E\n+    Utf8 \"Code\"; \/\/ #10     at 0x56\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x5D\n+    Utf8 \"SourceFile\"; \/\/ #12     at 0x6F\n+    Utf8 \"a.java\"; \/\/ #13     at 0x7C\n+    NameAndType #5 #6; \/\/ #14     at 0x85\n+    NameAndType #8 #20; \/\/ #15     at 0x8A\n+    Utf8 \"EnclMethTest\"; \/\/ #16     at 0x8F\n+    Utf8 \"Loc\"; \/\/ #17     at 0x9E\n+    Utf8 \"InnerClasses\"; \/\/ #18     at 0xA4\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB3\n+    Utf8 \"()V\"; \/\/ #20     at 0xC6\n+    Utf8 \"EnclosingMethod\"; \/\/ #21     at 0xCC\n+  } \/\/ Constant Pool\n+\n+  0x0000; \/\/ access\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xE8\n+      0x0000; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#7, 0) { \/\/ Synthetic at 0xF0\n+        } \/\/ end Synthetic\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0xF8\n+      0x0001; \/\/ access\n+      #8; \/\/ name_cpx\n+      #20; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#10, 17) { \/\/ Code at 0x0100\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB70002B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [0] { \/\/ Attributes\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#12, 2) { \/\/ SourceFile at 0x0119\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#18, 10) { \/\/ InnerClasses at 0x0121\n+      [1] { \/\/ InnerClasses\n+        #3 #0 #17 0; \/\/  at 0x0131\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#21, 6) { \/\/ EnclosingMethod at 0x0131\n+      \/\/ invalid length of EnclosingMethod attr: 6 (should be 4) !!\n+      0x0004000F;\n+    } \/\/ end EnclosingMethod\n+  } \/\/ Attributes\n+} \/\/ end class EnclMethTest\n","filename":"test\/resources\/org\/openjdk\/asmtools\/sequence\/EnclMethTest.jcod","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n+package  javasoft\/sqe\/tests\/api\/java\/lang\/invoke\/MethodHandles\/Lookup;\n+\n+interface  TestInterface01n01 version 51:0\n+{\n+  public static final Field iField:I\t= int 255;\n+\n+  public abstract Method getTestResult:\"()I\";\n+  public Method xAA:\"()I\"\n+\tstack 1 locals 1\n+  {\n+\t\tsipush\t170;\n+\t\tireturn;\n+  }\n+  public static Method xBB:\"()I\"\n+\tstack 1 locals 0\n+  {\n+\t\tsipush\t187;\n+\t\tireturn;\n+  }\n+\n+} \/\/ end Class TestInterface01n01\n","filename":"test\/resources\/org\/openjdk\/asmtools\/sequence\/TestInterface01n01.jasm","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Ident: @(#)atrcod00402m1n.jcod generated from: @(#)atrcod00402m.jmpp 1.8 99\/10\/07\n+ *\n+ * Copyright 1999 Sun Microsystems, Inc. All rights reserved.\n+ * SUN PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+\n+\n+\n+class javasoft\/sqe\/tests\/vm\/classfmt\/atr\/atrcod004\/atrcod00402m1\/atrcod00402m1n {\n+  0xCAFEBABE;\n+  3; \/\/ minor version\n+  45; \/\/ version\n+\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #12; \/\/ #1 \n+    class #6; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #14 #15; \/\/ #4\n+    Utf8 \"ConstantValue\"; \/\/ #5\n+    Utf8 \"javasoft\/sqe\/tests\/vm\/classfmt\/atr\/atrcod004\/atrcod00402m1\/atrcod00402m1n\"; \/\/\n+    Utf8 \"Exceptions\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"LocalVariables\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11 at 0x92\n+    Utf8 \"java\/lang\/Object\"; \/\/ #12\n+    Utf8 \"attr003.jcod\"; \/\/ #13\n+    Utf8 \"<init>\"; \/\/ #14\n+    Utf8 \"()V\"; \/\/ #15\n+  } \/\/ Constant Pool\n+\n+  0x0001; \/\/ access\n+  #2;\/\/ this_cpx\n+  #1;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ fields\n+  } \/\/ fields\n+\n+  [] { \/\/ methods\n+    { \/\/ Member at 0xD4\n+      0x0001; \/\/ access\n+      #14; \/\/ name_cpx\n+      #15; \/\/ sig_cpx\n+      [] {  \/\/ Attributes\n+        Attr(#11) { \/\/ Code \n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+\/* right:\n+          Bytes[5] {\n+end right *\/\n+\/\/ wrong:\n+          Bytes[10] {\n+\/\/ end wrong\n+            0x2AB70003B1;\n+          };\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] {  \/\/ Attributes\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [] {  \/\/ Attributes\n+  } \/\/ Attributes\n+}\n+\n+\n","filename":"test\/resources\/org\/openjdk\/asmtools\/sequence\/atrcod00402m1n.jcod","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Ident: @(#)module-info.jcod generated from:%W% %E%\n+ *\n+ * Copyright (c) 1996, 2018 Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+module module-info {\n+    0xCAFEBABE;\/\/ magic\n+    0;\/\/ minor class version\n+    53;\/\/ major class version\n+    []s{\n+        {  };\/\/ first element is empty\n+        Utf8 \"javasoft\/sqe\/jck\/tests\/vm\/atrmmc00101m012\/Main0012\";\/\/ #1\n+        class #1;\/\/ #2\n+        Utf8 \"module-info\";\/\/ #3\n+        class #3;\/\/ #4\n+        Utf8 \"Module\";\/\/ #5\n+        Utf8 \"module012\";\/\/ #6\n+        Module #6;\/\/ #7\n+        Utf8 \"java.base\";\/\/ #8\n+        Module #8;\/\/ #9\n+        Utf8 \"javasoft\/sqe\/jck\/tests\/vm\/atrmmc00101m012\";\/\/ #10\n+        Package #10;\/\/ #11\n+        Utf8 \"ModuleMainClass\";\/\/ #12\n+        Utf8 \"UNUSED_DUMMY_ATTRIBUTE\";\/\/ #13\n+        String #13;\/\/ #14\n+    };\n+    0x8000;\/\/  module\n+    #4;\/\/ this_class{\"module-info\"}\n+    #0;\/\/ super_class#0\n+    \/\/ interfaces\n+    []s{\n+    \n+    };\n+    \/\/ fields\n+    []s{\n+    \n+    };\n+    \/\/ methods\n+    []s{\n+    \n+    };\n+    \/\/ class attributes\n+    []s{\n+        \/\/ attribute \"Module\"\n+        Attr(#5) {\n+            #7;\/\/ module_name_index {\"module012\"}\n+            0x0000;\n+            #0;\/\/ module_version_index #0\n+            \/\/ requires\n+            []s{\n+                { #9 0x0020 #0 };\n+            };\n+            \/\/ exports\n+            []s{\n+                { #11 0x0000 []s{} };\n+            };\n+            \/\/ opens\n+            []s{\n+                { #11 0x0000 []s{} };\n+            };\n+            \/\/ uses\n+            [0]s{\n+            \n+            };\n+            \/\/ provides\n+            [0]s{\n+            \n+            };\n+        };\n+        \/\/test attribute \"ModuleMainClass\"\n+        \/\/attribute_length, 1 less\n+        Attr(#12, 1) {\n+            #2;\/\/ {\"javasoft\/sqe\/jck\/tests\/vm\/atrmmc00101m012\/Main0012\"}\n+        };\n+\n+\n+    };\n+} \/\/ end of module-info\n","filename":"test\/resources\/org\/openjdk\/asmtools\/sequence\/module-info.jcod","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package org\/openjdk\/asmtools\/sequence;\n+\n+\/\/ Interface containing  non-void <init> method.\n+public interface nonvoidinit version 50:0\n+{\n+    public abstract Method \"<init>\":\"()I\";\n+\n+} \/\/ end Class nonvoidinit\n","filename":"test\/resources\/org\/openjdk\/asmtools\/sequence\/nonvoidinit.jasm","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Ident: @(#)stackmap00601m1n.jcod generated from: @(#)stackmap00601m.jmpp 1.9 06\/06\/06\n+ *\n+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.\n+ * SUN PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+\n+\n+\n+class javasoft\/sqe\/tests\/vm\/cldc\/classfmt\/stackmap006\/stackmap00601m1\/stackmap00601m1n {\n+  0xCAFEBABE;\n+  0;\n+  50;\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #3 #5; \/\/ #1    \n+    Utf8 \"StackMapTable\"; \/\/ #2    \n+    class #4; \/\/ #3    \n+    Utf8 \"java\/lang\/Object\"; \/\/ #4    \n+    NameAndType #10 #7; \/\/ #5    \n+    Utf8 \"SourceFile\"; \/\/ #6    \n+    Utf8 \"()V\"; \/\/ #7    \n+    Utf8 \"Code\"; \/\/ #8    \n+    Utf8 \"a.jasm\"; \/\/ #9    \n+    Utf8 \"<init>\"; \/\/ #10    \n+    class #12; \/\/ #11    \n+    Utf8 \"javasoft\/sqe\/tests\/vm\/cldc\/classfmt\/stackmap006\/stackmap00601m1\/stackmap00601m1n\"; \/\/ #12    \n+  } \/\/ Constant Pool\n+\n+  0x0000; \/\/ access\n+  #11;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ fields\n+  } \/\/ fields\n+\n+  [] { \/\/ methods\n+    { \/\/ Member\n+      0x0001; \/\/ access\n+      #10; \/\/ name_cpx\n+      #7; \/\/ sig_cpx\n+      [] { \/\/ Attributes\n+        Attr(#8) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_stack_items\n+          Bytes[]{\n+            0x2AB70001B1000000;\n+            0x0000000000B1;\n+          };\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#2) { \/\/ StackMap\n+                [] { \/\/\n+\/* right:\n+                  255b,  5, []{}, []{B};\n+end right *\/\n+\/\/ wrong:\n+                  255b,  5, []{}, [0]{B};\n+\/\/ end wrong\n+                }\n+            } \/\/ end StackMap\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#6) { \/\/ SourceFile\n+      #9;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class javasoft\/sqe\/tests\/vm\/cldc\/classfmt\/stackmap006\/stackmap00601m1\/stackmap00601m1n\n+\n+\n","filename":"test\/resources\/org\/openjdk\/asmtools\/sequence\/stackmap00601m1n.jcod","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package org\/openjdk\/asmtools\/sequence;\n+\n+\/\/ Interface containing void <init> method.\n+public interface voidinit version 50:0\n+{\n+    public abstract Method \"<init>\":\"()V\";\n+\n+} \/\/ end Class voidinit\n","filename":"test\/resources\/org\/openjdk\/asmtools\/sequence\/voidinit.jasm","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"}]}