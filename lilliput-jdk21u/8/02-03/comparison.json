{"files":[{"patch":"@@ -201,0 +201,5 @@\n+    if (UseCompactObjectHeaders) {\n+      \/\/ With compact headers, arrays have a 32bit alignment gap after the length.\n+      assert(arrayOopDesc::length_offset_in_bytes() == 8, \"check length offset\");\n+      strw(zr, Address(obj, arrayOopDesc::length_offset_in_bytes() + sizeof(jint)));\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3572,1 +3572,0 @@\n-      assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n@@ -3582,1 +3581,0 @@\n-        assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n@@ -3584,0 +3582,5 @@\n+        if (!is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong)) {\n+          __ strw(zr, Address(__ post(r2, BytesPerInt)));\n+          __ sub(r3, r3, BytesPerInt);\n+          __ cbz(r3, initialize_header);\n+        }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -185,0 +185,8 @@\n+#ifdef _LP64\n+    if (!is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerWord)) {\n+      assert(is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerInt), \"must be 4-byte aligned\");\n+      movl(Address(obj, arrayOopDesc::header_size_in_bytes()), 0);\n+    }\n+#else\n+    assert(is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerInt), \"must be 4-byte aligned\");\n+#endif\n@@ -291,13 +299,0 @@\n-  \/\/ Clear leading 4 bytes, if necessary.\n-  \/\/ TODO: This could perhaps go into initialize_body() and also clear the leading 4 bytes\n-  \/\/ for non-array objects, thereby replacing the klass-gap clearing code in initialize_header().\n-  int base_offset = base_offset_in_bytes;\n-#ifdef _LP64\n-  if (!is_aligned(base_offset, BytesPerWord)) {\n-    assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n-    movl(Address(obj, base_offset), 0);\n-    base_offset += BytesPerInt;\n-  }\n-#endif\n-  assert(is_aligned(base_offset, BytesPerWord), \"must be word aligned\");\n-\n@@ -306,1 +301,4 @@\n-  initialize_body(obj, arr_size, base_offset, len_zero);\n+  \/\/ We align-up the header size to word-size, because we clear the\n+  \/\/ possible alignment gap in initialize_header().\n+  int hdr_size = align_up(base_offset_in_bytes, BytesPerWord);\n+  initialize_body(obj, arr_size, hdr_size, len_zero);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -4036,2 +4036,1 @@\n-      assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n-      __ decrement(rdx, oopDesc::base_offset_in_bytes());\n+      __ decrement(rdx, align_up(oopDesc::base_offset_in_bytes(), BytesPerLong));\n@@ -4063,2 +4062,1 @@\n-      assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n-      int header_size = oopDesc::base_offset_in_bytes();\n+      int header_size = align_up(oopDesc::base_offset_in_bytes(), BytesPerLong);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}