{"files":[{"patch":"@@ -201,5 +201,0 @@\n-    if (UseCompactObjectHeaders) {\n-      \/\/ With compact headers, arrays have a 32bit alignment gap after the length.\n-      assert(arrayOopDesc::length_offset_in_bytes() == 8, \"check length offset\");\n-      strw(zr, Address(obj, arrayOopDesc::length_offset_in_bytes() + sizeof(jint)));\n-    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4330,1 +4330,1 @@\n-  \/\/ Fast-path: shift and decode Klass*.\n+  \/\/ Fast-path: shift to get narrowKlass.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3572,0 +3572,1 @@\n+      assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n@@ -3581,0 +3582,1 @@\n+        assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n@@ -3582,5 +3584,0 @@\n-        if (!is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong)) {\n-          __ strw(zr, Address(__ post(r2, BytesPerInt)));\n-          __ sub(r3, r3, BytesPerInt);\n-          __ cbz(r3, initialize_header);\n-        }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -974,1 +974,1 @@\n-                      align_up(arrayOopDesc::header_size_in_bytes(), HeapWordSize) \/ HeapWordSize,\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,8 +185,0 @@\n-#ifdef _LP64\n-    if (!is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerWord)) {\n-      assert(is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerInt), \"must be 4-byte aligned\");\n-      movl(Address(obj, arrayOopDesc::header_size_in_bytes()), 0);\n-    }\n-#else\n-    assert(is_aligned(arrayOopDesc::header_size_in_bytes(), BytesPerInt), \"must be 4-byte aligned\");\n-#endif\n@@ -229,3 +221,2 @@\n-  if (UseCompactObjectHeaders) {\n-    assert(hdr_size_in_bytes == 8, \"check object headers size\");\n-  }\n+  assert(!UseCompactObjectHeaders || hdr_size_in_bytes == 8, \"check object headers size\");\n+\n@@ -299,0 +290,13 @@\n+  \/\/ Clear leading 4 bytes, if necessary.\n+  \/\/ TODO: This could perhaps go into initialize_body() and also clear the leading 4 bytes\n+  \/\/ for non-array objects, thereby replacing the klass-gap clearing code in initialize_header().\n+  int base_offset = base_offset_in_bytes;\n+#ifdef _LP64\n+  if (!is_aligned(base_offset, BytesPerWord)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"must be 4-byte aligned\");\n+    movl(Address(obj, base_offset), 0);\n+    base_offset += BytesPerInt;\n+  }\n+#endif\n+  assert(is_aligned(base_offset, BytesPerWord), \"must be word aligned\");\n+\n@@ -301,4 +305,1 @@\n-  \/\/ We align-up the header size to word-size, because we clear the\n-  \/\/ possible alignment gap in initialize_header().\n-  int hdr_size = align_up(base_offset_in_bytes, BytesPerWord);\n-  initialize_body(obj, arr_size, hdr_size, len_zero);\n+  initialize_body(obj, arr_size, base_offset, len_zero);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -4036,1 +4036,2 @@\n-      __ decrement(rdx, align_up(oopDesc::base_offset_in_bytes(), BytesPerLong));\n+      assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n+      __ decrement(rdx, oopDesc::base_offset_in_bytes());\n@@ -4062,1 +4063,2 @@\n-      int header_size = align_up(oopDesc::base_offset_in_bytes(), BytesPerLong);\n+      assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n+      int header_size = oopDesc::base_offset_in_bytes();\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -257,0 +257,2 @@\n+  \/\/ Parallel GC claims with a release - so other threads might access this object\n+  \/\/ after claiming and they should see the \"completed\" object.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -405,2 +405,0 @@\n-\/\/ Should only be called with constants as argument\n-\/\/ (will not constant fold otherwise)\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    oopDesc::release_set_mark(mem, _klass->prototype_header().set_marked());\n+    arrayOopDesc::release_set_mark(mem, _klass->prototype_header().set_marked());\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,6 +442,1 @@\n-\n-  \/\/ With compact object headers, we can test for the explicit offset within\n-  \/\/ the header to figure out if compiler code is accessing the class. See\n-  \/\/ more discussion in C2, TypeOopPtr::klass_offset_in_bytes().\n-  int klass_offset = UseCompactObjectHeaders ? 4 : oopDesc::klass_offset_in_bytes();\n-  if (offset == klass_offset) {\n+  if (offset == oopDesc::klass_offset_in_bytes()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -348,1 +348,3 @@\n-    return (int)offset_of(oopDesc, _metadata._klass);\n+    {\n+      return (int)offset_of(oopDesc, _metadata._klass);\n+    }\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-    set_mark(prototype_mark());\n+    set_mark(klass()->prototype_header());\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1402,1 +1402,1 @@\n-        _offset != oopDesc::klass_offset_in_bytes()) {\n+        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}