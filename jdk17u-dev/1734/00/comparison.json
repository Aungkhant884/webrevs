{"files":[{"patch":"@@ -294,0 +294,11 @@\n+  const size_t ps = page_size(false, 8);\n+  \/\/ Print warning if using large pages but not able to use the size given\n+  if (UseLargePages) {\n+    const size_t lg_ps = page_size(false, 1);\n+    if (ps < lg_ps) {\n+      log_warning(codecache)(\"Code cache size too small for \" PROPERFMT \" pages. \"\n+                             \"Reverting to smaller page size (\" PROPERFMT \").\",\n+                             PROPERFMTARGS(lg_ps), PROPERFMTARGS(ps));\n+    }\n+  }\n+\n@@ -296,1 +307,1 @@\n-  const size_t alignment = MAX2(page_size(false, 8), (size_t) os::vm_allocation_granularity());\n+  const size_t alignment = MAX2(ps, (size_t) os::vm_allocation_granularity());\n@@ -308,1 +319,1 @@\n-  ReservedCodeSpace rs = reserve_heap_memory(cache_size);\n+  ReservedCodeSpace rs = reserve_heap_memory(cache_size, ps);\n@@ -335,1 +346,1 @@\n-ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size) {\n+ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size, size_t rs_ps) {\n@@ -337,1 +348,0 @@\n-  const size_t rs_ps = page_size();\n@@ -976,1 +986,1 @@\n-    ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize);\n+    ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize, page_size(false, 8));\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  static ReservedCodeSpace reserve_heap_memory(size_t size);  \/\/ Reserves one continuous chunk of memory for the CodeHeaps\n+  static ReservedCodeSpace reserve_heap_memory(size_t size, size_t rs_ps);  \/\/ Reserves one continuous chunk of memory for the CodeHeaps\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304954\n+ * @summary Code cache reservation should gracefully downgrade to using smaller pages if the code cache size is too small to host the requested page size.\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc != \"Z\"\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseLargePages -XX:LargePageSizeInBytes=1g compiler.codecache.CheckLargePages\n+ *\/\n+\n+package compiler.codecache;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class CheckLargePages {\n+    private final static WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) throws Exception {\n+        final boolean largePages = WHITE_BOX.getBooleanVMFlag(\"UseLargePages\");\n+        final long largePageSize = WHITE_BOX.getVMLargePageSize();\n+        if (largePages && (largePageSize == 1024 * 1024 * 1024)) {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                    \"-XX:+UseLargePages\",\n+                    \"-XX:+SegmentedCodeCache\",\n+                    \"-XX:InitialCodeCacheSize=2g\",\n+                    \"-XX:ReservedCodeCacheSize=2g\",\n+                    \"-XX:LargePageSizeInBytes=1g\",\n+                    \"-Xlog:pagesize=info\",\n+                    \"-version\");\n+            OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+            out.shouldMatch(\"Code cache size too small for \\\\S* pages\\\\. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\");\n+            out.shouldHaveExitValue(0);\n+            \/\/ Parse page sizes to find next biggest page\n+            String sizes = out.firstMatch(\"Usable page sizes:(.*)\", 1);\n+            List<Long> sizeList = Arrays.stream(sizes.trim().split(\"\\\\s*,\\\\s*\")).map(CheckLargePages::parseMemoryString).sorted().toList();\n+            final int smallerPageSizeIndex = sizeList.indexOf(largePageSize) - 1;\n+            Asserts.assertGreaterThanOrEqual(smallerPageSizeIndex, 0);\n+            final long smallerPageSize = sizeList.get(smallerPageSizeIndex);\n+            \/\/ Retrieve reverted page size from code cache warning\n+            String revertedSizeString = out.firstMatch(\"Code cache size too small for (\\\\S*) pages. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\", 2);\n+            Asserts.assertEquals(parseMemoryString(revertedSizeString), smallerPageSize);\n+        } else {\n+            System.out.println(\"1GB large pages not supported: UseLargePages=\" + largePages +\n+                    (largePages ? \", largePageSize=\" + largePageSize : \"\") + \". Skipping\");\n+        }\n+    }\n+\n+    public static long parseMemoryString(String value) {\n+        value = value.toUpperCase();\n+        long multiplier = 1;\n+        if (value.endsWith(\"B\")) {\n+            multiplier = 1;\n+        } else if (value.endsWith(\"K\")) {\n+            multiplier = 1024;\n+        } else if (value.endsWith(\"M\")) {\n+            multiplier = 1024 * 1024;\n+        } else if (value.endsWith(\"G\")) {\n+            multiplier = 1024 * 1024 * 1024;\n+        } else {\n+            throw new IllegalArgumentException(\"Expected memory string '\" + value + \"'to end with either of: B, K, M, G\");\n+        }\n+\n+        long longValue = Long.parseUnsignedLong(value.substring(0, value.length() - 1));\n+\n+        return longValue * multiplier;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckLargePages.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}