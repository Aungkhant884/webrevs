{"files":[{"patch":"@@ -57,1 +57,0 @@\n-    DEBUG_ONLY(verify_raw_mem(C->root());)\n@@ -967,1 +966,1 @@\n-void ShenandoahBarrierC2Support::call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr, Node*& result_mem, Node* raw_mem,\n+void ShenandoahBarrierC2Support::call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr,\n@@ -972,7 +971,0 @@\n-  \/\/ The slow path stub consumes and produces raw memory in addition\n-  \/\/ to the existing memory edges\n-  Node* base = find_bottom_mem(ctrl, phase);\n-  MergeMemNode* mm = MergeMemNode::make(base);\n-  mm->set_memory_at(Compile::AliasIdxRaw, raw_mem);\n-  phase->register_new_node(mm, ctrl);\n-\n@@ -1016,1 +1008,1 @@\n-  call->init_req(TypeFunc::Memory, mm);\n+  call->init_req(TypeFunc::Memory, phase->C->top());\n@@ -1024,2 +1016,0 @@\n-  result_mem = new ProjNode(call, TypeFunc::Memory);\n-  phase->register_new_node(result_mem, call);\n@@ -1344,1 +1334,0 @@\n-\n@@ -1348,2 +1337,0 @@\n-    Node* init_raw_mem = raw_mem;\n-    Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);\n@@ -1362,1 +1349,0 @@\n-    Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);\n@@ -1375,1 +1361,0 @@\n-    raw_mem_phi->init_req(_heap_stable, raw_mem);\n@@ -1387,1 +1372,0 @@\n-      raw_mem_phi->init_req(_not_cset, raw_mem);\n@@ -1391,1 +1375,0 @@\n-      raw_mem_phi->del_req(_not_cset);\n@@ -1432,1 +1415,1 @@\n-    call_lrb_stub(ctrl, val, addr, result_mem, raw_mem, lrb->decorators(), phase);\n+    call_lrb_stub(ctrl, val, addr, lrb->decorators(), phase);\n@@ -1435,1 +1418,0 @@\n-    raw_mem_phi->init_req(_evac_path, result_mem);\n@@ -1440,1 +1422,0 @@\n-    phase->register_new_node(raw_mem_phi, region);\n@@ -1453,1 +1434,1 @@\n-      assert(n != init_raw_mem, \"should leave input raw mem above the barrier\");\n+      assert(n != raw_mem, \"should leave input raw mem above the barrier\");\n@@ -1457,8 +1438,0 @@\n-\n-    \/\/ The slow path call produces memory: hook the raw memory phi\n-    \/\/ from the expanded load reference barrier with the rest of the graph\n-    \/\/ which may require adding memory phis at every post dominated\n-    \/\/ region and at enclosing loop heads. Use the memory state\n-    \/\/ collected in memory_nodes to fix the memory graph. Update that\n-    \/\/ memory state as we go.\n-    fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);\n@@ -1905,99 +1878,0 @@\n-#ifdef ASSERT\n-void ShenandoahBarrierC2Support::verify_raw_mem(RootNode* root) {\n-  const bool trace = false;\n-  ResourceMark rm;\n-  Unique_Node_List nodes;\n-  Unique_Node_List controls;\n-  Unique_Node_List memories;\n-\n-  nodes.push(root);\n-  for (uint next = 0; next < nodes.size(); next++) {\n-    Node *n  = nodes.at(next);\n-    if (ShenandoahBarrierSetC2::is_shenandoah_lrb_call(n)) {\n-      controls.push(n);\n-      if (trace) { tty->print(\"XXXXXX verifying\"); n->dump(); }\n-      for (uint next2 = 0; next2 < controls.size(); next2++) {\n-        Node *m = controls.at(next2);\n-        for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n-          Node* u = m->fast_out(i);\n-          if (u->is_CFG() && !u->is_Root() &&\n-              !(u->Opcode() == Op_CProj && u->in(0)->Opcode() == Op_NeverBranch && u->as_Proj()->_con == 1) &&\n-              !(u->is_Region() && u->unique_ctrl_out()->Opcode() == Op_Halt)) {\n-            if (trace) { tty->print(\"XXXXXX pushing control\"); u->dump(); }\n-            controls.push(u);\n-          }\n-        }\n-      }\n-      memories.push(n->as_Call()->proj_out(TypeFunc::Memory));\n-      for (uint next2 = 0; next2 < memories.size(); next2++) {\n-        Node *m = memories.at(next2);\n-        assert(m->bottom_type() == Type::MEMORY, \"\");\n-        for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n-          Node* u = m->fast_out(i);\n-          if (u->bottom_type() == Type::MEMORY && (u->is_Mem() || u->is_ClearArray())) {\n-            if (trace) { tty->print(\"XXXXXX pushing memory\"); u->dump(); }\n-            memories.push(u);\n-          } else if (u->is_LoadStore()) {\n-            if (trace) { tty->print(\"XXXXXX pushing memory\"); u->find_out_with(Op_SCMemProj)->dump(); }\n-            memories.push(u->find_out_with(Op_SCMemProj));\n-          } else if (u->is_MergeMem() && u->as_MergeMem()->memory_at(Compile::AliasIdxRaw) == m) {\n-            if (trace) { tty->print(\"XXXXXX pushing memory\"); u->dump(); }\n-            memories.push(u);\n-          } else if (u->is_Phi()) {\n-            assert(u->bottom_type() == Type::MEMORY, \"\");\n-            if (u->adr_type() == TypeRawPtr::BOTTOM || u->adr_type() == TypePtr::BOTTOM) {\n-              assert(controls.member(u->in(0)), \"\");\n-              if (trace) { tty->print(\"XXXXXX pushing memory\"); u->dump(); }\n-              memories.push(u);\n-            }\n-          } else if (u->is_SafePoint() || u->is_MemBar()) {\n-            for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n-              Node* uu = u->fast_out(j);\n-              if (uu->bottom_type() == Type::MEMORY) {\n-                if (trace) { tty->print(\"XXXXXX pushing memory\"); uu->dump(); }\n-                memories.push(uu);\n-              }\n-            }\n-          }\n-        }\n-      }\n-      for (uint next2 = 0; next2 < controls.size(); next2++) {\n-        Node *m = controls.at(next2);\n-        if (m->is_Region()) {\n-          bool all_in = true;\n-          for (uint i = 1; i < m->req(); i++) {\n-            if (!controls.member(m->in(i))) {\n-              all_in = false;\n-              break;\n-            }\n-          }\n-          if (trace) { tty->print(\"XXX verifying %s\", all_in ? \"all in\" : \"\"); m->dump(); }\n-          bool found_phi = false;\n-          for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax && !found_phi; j++) {\n-            Node* u = m->fast_out(j);\n-            if (u->is_Phi() && memories.member(u)) {\n-              found_phi = true;\n-              for (uint i = 1; i < u->req() && found_phi; i++) {\n-                Node* k = u->in(i);\n-                if (memories.member(k) != controls.member(m->in(i))) {\n-                  found_phi = false;\n-                }\n-              }\n-            }\n-          }\n-          assert(found_phi || all_in, \"\");\n-        }\n-      }\n-      controls.clear();\n-      memories.clear();\n-    }\n-    for( uint i = 0; i < n->len(); ++i ) {\n-      Node *m = n->in(i);\n-      if (m != NULL) {\n-        nodes.push(m);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":4,"deletions":130,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-  static void verify_raw_mem(RootNode* root);\n@@ -64,1 +63,1 @@\n-  static void call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr, Node*& result_mem, Node* raw_mem,\n+  static void call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}