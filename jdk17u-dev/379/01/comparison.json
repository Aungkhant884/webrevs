{"files":[{"patch":"@@ -621,0 +621,18 @@\n+    case Op_Blackhole: {\n+      \/\/ All blackhole pointer arguments are globally escaping.\n+      \/\/ Only do this if there is at least one pointer argument.\n+      \/\/ Do not add edges during first iteration because some could be\n+      \/\/ not defined yet, defer to final step.\n+      for (uint i = 0; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in != nullptr) {\n+          const Type* at = _igvn->type(in);\n+          if (!at->isa_ptr()) continue;\n+\n+          add_local_var(n, PointsToNode::GlobalEscape);\n+          delayed_worklist->push(n);\n+          break;\n+        }\n+      }\n+      break;\n+    }\n@@ -792,0 +810,20 @@\n+    case Op_Blackhole: {\n+      \/\/ All blackhole pointer arguments are globally escaping.\n+      for (uint i = 0; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in != nullptr) {\n+          const Type* at = _igvn->type(in);\n+          if (!at->isa_ptr()) continue;\n+\n+          if (in->is_AddP()) {\n+            in = get_addp_base(in);\n+          }\n+\n+          PointsToNode* ptn = ptnode_adr(in->_idx);\n+          assert(ptn != nullptr, \"should be defined already\");\n+          set_escape_state(ptn, PointsToNode::GlobalEscape);\n+          add_edge(n_ptn, ptn);\n+        }\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -80,0 +80,9 @@\n+\n+        \/\/ Test calling static methods through instance method to exercise\n+        \/\/ unusual intrinsic shapes.\n+        TESTS.put(\"bh_is_int_0\",    BlackholeIntrinsicTest::test_is_int_0);\n+        TESTS.put(\"bh_is_Object_0\", BlackholeIntrinsicTest::test_is_Object_0);\n+        TESTS.put(\"bh_is_int_1\",    BlackholeIntrinsicTest::test_is_int_1);\n+        TESTS.put(\"bh_is_Object_1\", BlackholeIntrinsicTest::test_is_Object_1);\n+        TESTS.put(\"bh_is_int_2\",    BlackholeIntrinsicTest::test_is_int_2);\n+        TESTS.put(\"bh_is_Object_2\", BlackholeIntrinsicTest::test_is_Object_2);\n@@ -165,0 +174,7 @@\n+    private static void test_is_int_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_is_int_0();\n+        }\n+    }\n+\n@@ -189,0 +205,7 @@\n+    private static void test_is_Object_0() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_is_Object_0();\n+        }\n+    }\n+\n@@ -219,0 +242,7 @@\n+    private static void test_is_int_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_is_int_1(c);\n+        }\n+    }\n+\n@@ -244,0 +274,8 @@\n+    private static void test_is_Object_1() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o = new Object();\n+            t.bh_is_Object_1(o);\n+        }\n+    }\n+\n@@ -274,0 +312,7 @@\n+    private static void test_is_int_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            t.bh_is_int_2(c, c + 1);\n+        }\n+    }\n+\n@@ -299,0 +344,9 @@\n+\n+    private static void test_is_Object_2() {\n+        BlackholeTarget t = new BlackholeTarget();\n+        for (int c = 0; c < CYCLES; c++) {\n+            Object o1 = new Object();\n+            Object o2 = new Object();\n+            t.bh_is_Object_2(o1, o2);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeIntrinsicTest.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+    public static void    bh_is_int_0()              {}\n+    public static void    bh_is_Object_0()           {}\n+\n@@ -61,0 +64,3 @@\n+    public static void    bh_is_int_1(int v)         {}\n+    public static void    bh_is_Object_1(Object v)   {}\n+\n@@ -81,0 +87,3 @@\n+    public static void    bh_is_int_2(int v1, int v2)            {}\n+    public static void    bh_is_Object_2(Object v1, Object v2)   {}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeTarget.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8284848\n+ * @requires vm.compiler2.enabled\n+ * @summary Blackhole arguments are globally escaping, thus preventing advanced EA optimizations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.blackhole.BlackholeStoreStoreEATest\n+ *\/\n+\n+package compiler.c2.irTests.blackhole;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+public class BlackholeStoreStoreEATest {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=blackhole,compiler.c2.irTests.blackhole.BlackholeStoreStoreEATest::blackhole\"\n+        );\n+    }\n+\n+    \/*\n+     * Negative test is not possible: the StoreStore barrier is still in, even if we just do dontinline.\n+     * Positive test: check that blackhole keeps the StoreStore barrier in.\n+     *\/\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    static void testBlackholed() {\n+        Object o = new Object();\n+        blackhole(o);\n+    }\n+\n+    static void blackhole(Object o) {}\n+\n+    @Run(test = \"testBlackholed\")\n+    static void runBlackholed() {\n+        testBlackholed();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/blackhole\/BlackholeStoreStoreEATest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8284848\n+ * @requires vm.compiler2.enabled\n+ * @summary Blackhole arguments are globally escaping, thus preventing advanced EA optimizations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.blackhole.BlackholeSyncEATest\n+ *\/\n+\n+package compiler.c2.irTests.blackhole;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+public class BlackholeSyncEATest {\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileCommand=blackhole,compiler.c2.irTests.blackhole.BlackholeSyncEATest::blackhole\",\n+            \"-XX:CompileCommand=dontinline,compiler.c2.irTests.blackhole.BlackholeSyncEATest::dontinline\"\n+        );\n+    }\n+\n+    \/*\n+     * Negative test: check that dontinline method still allows EA to eliminate the synchronization.\n+     *\/\n+\n+    @Test\n+    @IR(failOn = {IRNode.FAST_LOCK, IRNode.FAST_UNLOCK})\n+    static void testDontline() {\n+        Object o = new Object();\n+        synchronized (o) {}\n+        dontinline(o);\n+    }\n+\n+    static void dontinline(Object o) {}\n+\n+    @Run(test = \"testDontline\")\n+    static void runDontinline() {\n+        testDontline();\n+    }\n+\n+    \/*\n+     * Positive test: check that blackhole keeps the synchronization in.\n+     *\/\n+\n+    @Test\n+    @IR(counts = {IRNode.FAST_LOCK, \"1\"})\n+    @IR(counts = {IRNode.FAST_UNLOCK, \"1\"})\n+    static void testBlackholed() {\n+        Object o = new Object();\n+        synchronized (o) {}\n+        blackhole(o);\n+    }\n+\n+    static void blackhole(Object o) {}\n+\n+    @Run(test = \"testBlackholed\")\n+    static void runBlackholed() {\n+        testBlackholed();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/blackhole\/BlackholeSyncEATest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -136,0 +136,1 @@\n+    public static final String MEMBAR_STORESTORE = START + \"MemBarStoreStore\" + MID + END;\n@@ -141,0 +142,3 @@\n+    public static final String FAST_LOCK   = START + \"FastLock\" + MID + END;\n+    public static final String FAST_UNLOCK = START + \"FastUnlock\" + MID + END;\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}