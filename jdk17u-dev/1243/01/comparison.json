{"files":[{"patch":"@@ -183,4 +183,2 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock); \/\/ add_to_hierarchy asserts this.\n-    SystemDictionary::add_to_hierarchy(result);\n-  }\n+  SystemDictionary::add_to_hierarchy(THREAD, result);\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -856,6 +857,3 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock);\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    add_to_hierarchy(k);\n-    \/\/ But, do not add to dictionary.\n-  }\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  add_to_hierarchy(THREAD, k);\n+  \/\/ But, do not add to dictionary.\n@@ -1438,1 +1436,2 @@\n-  \/\/ Add the new class. We need recompile lock during update of CHA.\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  add_to_hierarchy(THREAD, k);\n@@ -1441,4 +1440,0 @@\n-\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    add_to_hierarchy(k);\n-\n@@ -1565,2 +1560,1 @@\n-\/\/ is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in\n-\/\/ before a new class is used.\n+\/\/ is grabbed, to ensure that the compiler is not using the class hierarchy.\n@@ -1568,1 +1562,1 @@\n-void SystemDictionary::add_to_hierarchy(InstanceKlass* k) {\n+void SystemDictionary::add_to_hierarchy(Thread* current, InstanceKlass* k) {\n@@ -1570,3 +1564,5 @@\n-  if (Universe::is_fully_initialized()) {\n-    assert_locked_or_safepoint(Compile_lock);\n-  }\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"must NOT be at safepoint\");\n+\n+  DeoptimizationScope deopt_scope;\n+  {\n+    MutexLocker ml(current, Compile_lock);\n@@ -1574,4 +1570,4 @@\n-  k->set_init_state(InstanceKlass::loaded);\n-  \/\/ make sure init_state store is already done.\n-  \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n-  \/\/ Access ordering is used to add to hierarchy.\n+    k->set_init_state(InstanceKlass::loaded);\n+    \/\/ make sure init_state store is already done.\n+    \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n+    \/\/ Access ordering is used to add to hierarchy.\n@@ -1579,3 +1575,3 @@\n-  \/\/ Link into hierachy.\n-  k->append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n-  k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n+    \/\/ Link into hierarchy.\n+    k->append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n+    k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n@@ -1583,4 +1579,5 @@\n-  \/\/ Now flush all code that depended on old class hierarchy.\n-  \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n-  if (Universe::is_fully_initialized()) {\n-    CodeCache::flush_dependents_on(k);\n+    \/\/ Now mark all code that depended on old class hierarchy.\n+    \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n+    if (Universe::is_fully_initialized()) {\n+      CodeCache::mark_dependents_on(&deopt_scope, k);\n+    }\n@@ -1588,0 +1585,2 @@\n+  \/\/ Perform the deopt handshake outside Compile_lock.\n+  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":27,"deletions":28,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -398,2 +398,2 @@\n-  \/\/ Setup link to hierarchy\n-  static void add_to_hierarchy(InstanceKlass* k);\n+  \/\/ Setup link to hierarchy and deoptimize\n+  static void add_to_hierarchy(Thread* current, InstanceKlass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1187,2 +1187,1 @@\n-    MutexLocker mu_r(current, Compile_lock); \/\/ add_to_hierarchy asserts this.\n-    SystemDictionary::add_to_hierarchy(k);\n+    SystemDictionary::add_to_hierarchy(current, k);\n@@ -1745,2 +1744,3 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock);\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  SystemDictionary::add_to_hierarchy(THREAD, loaded_lambda);\n+  \/\/ But, do not add to dictionary.\n@@ -1748,4 +1748,0 @@\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    SystemDictionary::add_to_hierarchy(loaded_lambda);\n-    \/\/ But, do not add to dictionary.\n-  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-  SystemDictionary::add_to_hierarchy(klass);\n+  SystemDictionary::add_to_hierarchy(THREAD, klass);\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1022,1 +1022,1 @@\n-int CodeCache::mark_for_deoptimization(KlassDepChange& changes) {\n+void CodeCache::mark_for_deoptimization(DeoptimizationScope* deopt_scope, KlassDepChange& changes) {\n@@ -1024,1 +1024,0 @@\n-  int number_of_marked_CodeBlobs = 0;\n@@ -1036,1 +1035,1 @@\n-    number_of_marked_CodeBlobs += InstanceKlass::cast(d)->mark_dependent_nmethods(changes);\n+    InstanceKlass::cast(d)->mark_dependent_nmethods(deopt_scope, changes);\n@@ -1048,2 +1047,0 @@\n-\n-  return number_of_marked_CodeBlobs;\n@@ -1111,1 +1108,1 @@\n-int CodeCache::mark_dependents_for_evol_deoptimization() {\n+void CodeCache::mark_dependents_for_evol_deoptimization(DeoptimizationScope* deopt_scope) {\n@@ -1117,1 +1114,0 @@\n-  int number_of_marked_CodeBlobs = 0;\n@@ -1125,1 +1121,1 @@\n-      nm->mark_for_deoptimization();\n+      deopt_scope->mark(nm);\n@@ -1127,1 +1123,0 @@\n-      number_of_marked_CodeBlobs++;\n@@ -1130,4 +1125,0 @@\n-\n-  \/\/ return total count of nmethods marked for deoptimization, if zero the caller\n-  \/\/ can skip deoptimization\n-  return number_of_marked_CodeBlobs;\n@@ -1136,1 +1127,1 @@\n-void CodeCache::mark_all_nmethods_for_evol_deoptimization() {\n+void CodeCache::mark_all_nmethods_for_evol_deoptimization(DeoptimizationScope* deopt_scope) {\n@@ -1142,1 +1133,1 @@\n-      nm->mark_for_deoptimization();\n+      deopt_scope->mark(nm);\n@@ -1150,13 +1141,0 @@\n-\/\/ Flushes compiled methods dependent on redefined classes, that have already been\n-\/\/ marked for deoptimization.\n-void CodeCache::flush_evol_dependents() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-\n-  \/\/ CodeCache can only be updated by a thread_in_VM and they will all be\n-  \/\/ stopped during the safepoint so CodeCache will be safe to update without\n-  \/\/ holding the CodeCache_lock.\n-\n-  \/\/ At least one nmethod has been marked for deoptimization\n-\n-  Deoptimization::deoptimize_all_marked();\n-}\n@@ -1166,1 +1144,1 @@\n-void CodeCache::mark_all_nmethods_for_deoptimization() {\n+void CodeCache::mark_all_nmethods_for_deoptimization(DeoptimizationScope* deopt_scope) {\n@@ -1172,1 +1150,1 @@\n-      nm->mark_for_deoptimization();\n+      deopt_scope->mark(nm);\n@@ -1177,1 +1155,1 @@\n-int CodeCache::mark_for_deoptimization(Method* dependee) {\n+void CodeCache::mark_for_deoptimization(DeoptimizationScope* deopt_scope, Method* dependee) {\n@@ -1179,1 +1157,0 @@\n-  int number_of_marked_CodeBlobs = 0;\n@@ -1186,2 +1163,1 @@\n-      nm->mark_for_deoptimization();\n-      number_of_marked_CodeBlobs++;\n+      deopt_scope->mark(nm);\n@@ -1190,2 +1166,0 @@\n-\n-  return number_of_marked_CodeBlobs;\n@@ -1205,2 +1179,2 @@\n-\/\/ Flushes compiled methods dependent on dependee.\n-void CodeCache::flush_dependents_on(InstanceKlass* dependee) {\n+\/\/ Marks compiled methods dependent on dependee.\n+void CodeCache::mark_dependents_on(DeoptimizationScope* deopt_scope, InstanceKlass* dependee) {\n@@ -1211,1 +1185,0 @@\n-  int marked = 0;\n@@ -1215,1 +1188,1 @@\n-    marked = mark_for_deoptimization(changes);\n+    mark_for_deoptimization(deopt_scope, changes);\n@@ -1219,6 +1192,1 @@\n-    marked = mark_for_deoptimization(changes);\n-  }\n-\n-  if (marked > 0) {\n-    \/\/ At least one nmethod has been marked for deoptimization\n-    Deoptimization::deoptimize_all_marked();\n+    mark_for_deoptimization(deopt_scope, changes);\n@@ -1228,4 +1196,3 @@\n-\/\/ Flushes compiled methods dependent on dependee\n-void CodeCache::flush_dependents_on_method(const methodHandle& m_h) {\n-  \/\/ --- Compile_lock is not held. However we are at a safepoint.\n-  assert_locked_or_safepoint(Compile_lock);\n+\/\/ Marks compiled methods dependent on dependee\n+void CodeCache::mark_dependents_on_method_for_breakpoint(const methodHandle& m_h) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n@@ -1233,0 +1200,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1234,3 +1202,2 @@\n-  if (mark_for_deoptimization(m_h()) > 0) {\n-    Deoptimization::deoptimize_all_marked();\n-  }\n+  mark_for_deoptimization(&deopt_scope, m_h());\n+  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":20,"deletions":53,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+class DeoptimizationScope;\n@@ -265,1 +266,1 @@\n-  static int  mark_for_deoptimization(KlassDepChange& changes);\n+  static void mark_for_deoptimization(DeoptimizationScope* deopt_scope, KlassDepChange& changes);\n@@ -268,2 +269,2 @@\n-  static void mark_all_nmethods_for_deoptimization();\n-  static int  mark_for_deoptimization(Method* dependee);\n+  static void mark_all_nmethods_for_deoptimization(DeoptimizationScope* deopt_scope);\n+  static void mark_for_deoptimization(DeoptimizationScope* deopt_scope, Method* dependee);\n@@ -272,2 +273,2 @@\n-  \/\/ Flushing and deoptimization\n-  static void flush_dependents_on(InstanceKlass* dependee);\n+  \/\/ Marks dependents during classloading\n+  static void mark_dependents_on(DeoptimizationScope* deopt_scope, InstanceKlass* dependee);\n@@ -278,3 +279,2 @@\n-  static int  mark_dependents_for_evol_deoptimization();\n-  static void mark_all_nmethods_for_evol_deoptimization();\n-  static void flush_evol_dependents();\n+  static void mark_dependents_for_evol_deoptimization(DeoptimizationScope* deopt_scope);\n+  static void mark_all_nmethods_for_evol_deoptimization(DeoptimizationScope* deopt_scope);\n@@ -285,1 +285,1 @@\n-  static void flush_dependents_on_method(const methodHandle& dependee);\n+  static void mark_dependents_on_method_for_breakpoint(const methodHandle& dependee);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    _deoptimization_generation(0),\n@@ -67,0 +68,1 @@\n+    _deoptimization_generation(0),\n@@ -116,0 +118,1 @@\n+\n@@ -119,1 +122,1 @@\n-  _mark_for_deoptimization_status = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);\n+  _mark_for_deoptimization_status = inc_recompile_counts ? deoptimize : deoptimize_noupdate;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+  friend class DeoptimizationScope;\n@@ -147,1 +148,1 @@\n-  enum MarkForDeoptimizationStatus {\n+  enum MarkForDeoptimizationStatus : u1 {\n@@ -154,0 +155,2 @@\n+  \/\/ Used to track in which deoptimize handshake this method will be deoptimized.\n+  uint64_t                      _deoptimization_generation;\n@@ -175,0 +178,1 @@\n+\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -686,2 +686,0 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) = 0;\n-\n@@ -784,4 +782,0 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) {\n-    nm->mark_for_deoptimization(\/*inc_recompile_counts=*\/true);\n-  }\n-\n@@ -826,4 +820,0 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) {\n-    nm->mark_for_deoptimization(\/*inc_recompile_counts=*\/false);\n-  }\n-\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -64,1 +65,1 @@\n-\/\/ deoptimization.  Returns the number of nmethods found.\n+\/\/ deoptimization.\n@@ -66,2 +67,1 @@\n-int DependencyContext::mark_dependent_nmethods(DepChange& changes) {\n-  int found = 0;\n+void DependencyContext::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, DepChange& changes) {\n@@ -72,7 +72,13 @@\n-    if (b->count() > 0 && nm->is_alive() && !nm->is_marked_for_deoptimization() && nm->check_dependency_on(changes)) {\n-      if (TraceDependencies) {\n-        ResourceMark rm;\n-        tty->print_cr(\"Marked for deoptimization\");\n-        changes.print();\n-        nm->print();\n-        nm->print_dependencies();\n+    if (b->count() > 0 && nm->is_alive()) { \/\/ TODO: check if is_alive needed\n+      if (nm->is_marked_for_deoptimization()){\n+        deopt_scope->dependent(nm);\n+      }\n+      else if (nm->check_dependency_on(changes)) {\n+        if (TraceDependencies) {\n+          ResourceMark rm;\n+          tty->print_cr(\"Marked for deoptimization\");\n+          changes.print();\n+          nm->print();\n+          nm->print_dependencies();\n+        }\n+        deopt_scope->mark(nm, !changes.is_call_site_change());\n@@ -80,2 +86,0 @@\n-      changes.mark_for_deoptimization(nm);\n-      found++;\n@@ -84,1 +88,0 @@\n-  return found;\n@@ -231,0 +234,17 @@\n+void DependencyContext::remove_and_mark_for_deoptimization_all_dependents(DeoptimizationScope* deopt_scope) {\n+  nmethodBucket* b = dependencies_not_unloading();\n+  set_dependencies(nullptr);\n+  while (b != nullptr) {\n+    nmethod* nm = b->get_nmethod();\n+    if (b->count() > 0) {\n+      \/\/ Also count already (concurrently) marked nmethods to make sure\n+      \/\/ deoptimization is triggered before execution in this thread continues.\n+      nm->mark_for_deoptimization();\n+      deopt_scope->mark(nm);\n+    }\n+    nmethodBucket* next = b->next_not_unloading();\n+    release(b);\n+    b = next;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class DeoptimizationScope;\n@@ -120,1 +121,1 @@\n-  int  mark_dependent_nmethods(DepChange& changes);\n+  void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, DepChange& changes);\n@@ -124,0 +125,1 @@\n+  void remove_and_mark_for_deoptimization_all_dependents(DeoptimizationScope* deopt_scope);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1553,1 +1553,4 @@\n-    Deoptimization::deoptimize_all_marked(nm);\n+    DeoptimizationScope deopt_scope;\n+    deopt_scope.mark(nm);\n+    nm->make_not_entrant();\n+    deopt_scope.deoptimize_marked();    \n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -959,7 +960,6 @@\n-      if (UseVtableBasedCHA) {\n-        MutexLocker ml(THREAD, Compile_lock);\n-        set_init_state(linked);\n-\n-        \/\/ Now flush all code that assume the class is not linked.\n-        if (Universe::is_fully_initialized()) {\n-          CodeCache::flush_dependents_on(this);\n+      if (UseVtableBasedCHA && Universe::is_fully_initialized()) {\n+        DeoptimizationScope deopt_scope;\n+        {\n+          MutexLocker ml(THREAD, Compile_lock);\n+          set_init_state(linked);\n+          CodeCache::mark_dependents_on(&deopt_scope, this);\n@@ -967,1 +967,4 @@\n-      } else {\n+        \/\/ Perform the deopt handshake outside Compile_lock.\n+        deopt_scope.deoptimize_marked();\n+      }\n+      else {\n@@ -970,0 +973,1 @@\n+\n@@ -2328,2 +2332,2 @@\n-int InstanceKlass::mark_dependent_nmethods(KlassDepChange& changes) {\n-  return dependencies().mark_dependent_nmethods(changes);\n+void InstanceKlass::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, KlassDepChange& changes) {\n+  dependencies().mark_dependent_nmethods(deopt_scope, changes);\n@@ -2655,1 +2659,1 @@\n-  ik->dependencies().remove_all_dependents();\n+  ik->dependencies().remove_all_dependents(); \/\/TODO: consider remove_and_mark_for_deoptimization_all_dependents()\n@@ -3308,1 +3312,1 @@\n-int InstanceKlass::mark_osr_nmethods(const Method* m) {\n+int InstanceKlass::mark_osr_nmethods(DeoptimizationScope* deopt_scope, const Method* m) {\n@@ -3316,1 +3320,1 @@\n-      osr->mark_for_deoptimization();\n+      deopt_scope->mark(osr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+class DeoptimizationScope;\n@@ -955,1 +956,1 @@\n-  int  mark_dependent_nmethods(KlassDepChange& changes);\n+  void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, KlassDepChange& changes);\n@@ -965,1 +966,1 @@\n-  int mark_osr_nmethods(const Method* m);\n+  int mark_osr_nmethods(DeoptimizationScope* deopt_scope, const Method* m);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2006,1 +2006,1 @@\n-    CodeCache::flush_dependents_on_method(mh);\n+    CodeCache::mark_dependents_on_method_for_breakpoint(mh);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -882,4 +882,0 @@\n-  int mark_osr_nmethods() {\n-    return method_holder()->mark_osr_nmethods(this);\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4105,1 +4105,1 @@\n-  bool deopt_needed;\n+  DeoptimizationScope deopt_scope;\n@@ -4109,0 +4109,1 @@\n+    CodeCache::mark_all_nmethods_for_evol_deoptimization(&deopt_scope);\n@@ -4110,2 +4111,0 @@\n-    CodeCache::mark_all_nmethods_for_evol_deoptimization();\n-    deopt_needed = true;\n@@ -4113,3 +4112,2 @@\n-    int deopt = CodeCache::mark_dependents_for_evol_deoptimization();\n-    log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt);\n-    deopt_needed = (deopt != 0);\n+    CodeCache::mark_dependents_for_evol_deoptimization(&deopt_scope);\n+    log_debug(redefine, class, nmethod)(\"Marked dependent nmethods for deopt\");\n@@ -4118,3 +4116,1 @@\n-  if (deopt_needed) {\n-    CodeCache::flush_evol_dependents();\n-  }\n+  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1072,1 +1072,1 @@\n-void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {\n+void MethodHandles::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, Handle call_site, Handle target) {\n@@ -1075,1 +1075,0 @@\n-  int marked = 0;\n@@ -1079,1 +1078,1 @@\n-    MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -1083,5 +1082,1 @@\n-    marked = deps.mark_dependent_nmethods(changes);\n-  }\n-  if (marked > 0) {\n-    \/\/ At least one nmethod has been marked for deoptimization.\n-    Deoptimization::deoptimize_all_marked();\n+    deps.mark_dependent_nmethods(deopt_scope, changes);\n@@ -1383,0 +1378,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1386,1 +1382,1 @@\n-    MethodHandles::flush_dependent_nmethods(call_site, target);\n+    MethodHandles::mark_dependent_nmethods(&deopt_scope, call_site, target);\n@@ -1388,0 +1384,3 @@\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n@@ -1395,0 +1394,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1398,1 +1398,1 @@\n-    MethodHandles::flush_dependent_nmethods(call_site, target);\n+    MethodHandles::mark_dependent_nmethods(&deopt_scope, call_site, target);\n@@ -1400,0 +1400,3 @@\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n@@ -1489,0 +1492,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1490,14 +1494,7 @@\n-    \/\/ Walk all nmethods depending on this call site.\n-    MutexLocker mu1(thread, Compile_lock);\n-\n-    int marked = 0;\n-    {\n-      NoSafepointVerifier nsv;\n-      MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n-      marked = deps.remove_all_dependents();\n-    }\n-    if (marked > 0) {\n-      \/\/ At least one nmethod has been marked for deoptimization\n-      Deoptimization::deoptimize_all_marked();\n-    }\n+    NoSafepointVerifier nsv;\n+    MutexLocker ml(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n+    deps.remove_and_mark_for_deoptimization_all_dependents(&deopt_scope);\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  static void flush_dependent_nmethods(Handle call_site, Handle target);\n+  static void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, Handle call_site, Handle target);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -784,2 +784,3 @@\n-  CodeCache::mark_all_nmethods_for_deoptimization();\n-  Deoptimization::deoptimize_all_marked();\n+  DeoptimizationScope deopt_scope;\n+  CodeCache::mark_all_nmethods_for_deoptimization(&deopt_scope);\n+  deopt_scope.deoptimize_marked();\n@@ -792,11 +793,15 @@\n-  MutexLocker mu(Compile_lock);\n-  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n-  if (is_osr) {\n-    result += mh->mark_osr_nmethods();\n-  } else if (mh->code() != NULL) {\n-    mh->code()->mark_for_deoptimization();\n-    ++result;\n-  }\n-  result += CodeCache::mark_for_deoptimization(mh());\n-  if (result > 0) {\n-    Deoptimization::deoptimize_all_marked();\n+\n+  DeoptimizationScope deopt_scope;\n+  {\n+    MutexLocker mu(Compile_lock);\n+    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+    if (is_osr) {\n+      result += mh->method_holder()->mark_osr_nmethods(&deopt_scope, mh());\n+    } else {\n+      MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+      if (mh->code() != nullptr) {\n+        deopt_scope.mark(mh->code());\n+        ++result;\n+      }\n+    }\n+    CodeCache::mark_for_deoptimization(&deopt_scope, mh());\n@@ -804,0 +809,3 @@\n+\n+  deopt_scope.deoptimize_marked();\n+\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -95,0 +95,113 @@\n+uint64_t DeoptimizationScope::_committed_deopt_gen = 0;\n+uint64_t DeoptimizationScope::_active_deopt_gen    = 1;\n+bool     DeoptimizationScope::_committing_in_progress = false;\n+\n+DeoptimizationScope::DeoptimizationScope() : _required_gen(0) {\n+  DEBUG_ONLY(_deopted = false;)\n+\n+  MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  \/\/ If there is nothing to deopt _required_gen is the same as comitted.\n+  _required_gen = DeoptimizationScope::_committed_deopt_gen;\n+}\n+\n+DeoptimizationScope::~DeoptimizationScope() {\n+  assert(_deopted, \"Deopt not executed\");\n+}\n+\n+void DeoptimizationScope::mark(CompiledMethod* cm, bool inc_recompile_counts) {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ If it's already marked but we still need it to be deopted.\n+  if (cm->is_marked_for_deoptimization()) {\n+    dependent(cm);\n+    return;\n+  }\n+\n+  cm->_mark_for_deoptimization_status = inc_recompile_counts ? CompiledMethod::deoptimize : CompiledMethod::deoptimize_noupdate;\n+\n+  \/\/ Make sure active is not committed\n+  assert(DeoptimizationScope::_committed_deopt_gen < DeoptimizationScope::_active_deopt_gen, \"Must be\");\n+  assert(cm->_deoptimization_generation == 0, \"Is already marked\");\n+\n+  cm->_deoptimization_generation = DeoptimizationScope::_active_deopt_gen;\n+  _required_gen                  = DeoptimizationScope::_active_deopt_gen;\n+}\n+\n+void DeoptimizationScope::dependent(CompiledMethod* cm) {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+  \/\/ A method marked by someone else may have a _required_gen lower than what we marked with.\n+  \/\/ Therefore only store it if it's higher than _required_gen.\n+  if (_required_gen < cm->_deoptimization_generation) {\n+    _required_gen = cm->_deoptimization_generation;\n+  }\n+}\n+\n+void DeoptimizationScope::deoptimize_marked() {\n+  assert(!_deopted, \"Already deopted\");\n+\n+  \/\/ We are not alive yet.\n+  if (!Universe::is_fully_initialized()) {\n+    DEBUG_ONLY(_deopted = true;)\n+    return;\n+  }\n+\n+  \/\/ Safepoints are a special case, handled here.\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    DeoptimizationScope::_committed_deopt_gen = DeoptimizationScope::_active_deopt_gen;\n+    DeoptimizationScope::_active_deopt_gen++;\n+    Deoptimization::deoptimize_all_marked();\n+    DEBUG_ONLY(_deopted = true;)\n+    return;\n+  }\n+\n+  uint64_t comitting = 0;\n+  bool wait = false;\n+  while (true) {\n+    {\n+      MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+      \/\/ First we check if we or someone else already deopted the gen we want.\n+      if (DeoptimizationScope::_committed_deopt_gen >= _required_gen) {\n+        DEBUG_ONLY(_deopted = true;)\n+        return;\n+      }\n+      if (!_committing_in_progress) {\n+        \/\/ The version we are about to commit.\n+        comitting = DeoptimizationScope::_active_deopt_gen;\n+        \/\/ Make sure new marks use a higher gen.\n+        DeoptimizationScope::_active_deopt_gen++;\n+        _committing_in_progress = true;\n+        wait = false;\n+      } else {\n+        \/\/ Another thread is handshaking and committing a gen.\n+        wait = true;\n+      }\n+    }\n+    if (wait) {\n+      \/\/ Wait and let the concurrent handshake be performed.\n+      ThreadBlockInVM tbivm(JavaThread::current());\n+      os::naked_yield();\n+    } else {\n+      \/\/ Performs the handshake.\n+      Deoptimization::deoptimize_all_marked(); \/\/ May safepoint and an additional deopt may have occurred.\n+      DEBUG_ONLY(_deopted = true;)\n+      {\n+        MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                       Mutex::_no_safepoint_check_flag);\n+        \/\/ Make sure that committed doesn't go backwards.\n+        \/\/ Should only happen if we did a deopt during a safepoint above.\n+        if (DeoptimizationScope::_committed_deopt_gen < comitting) {\n+          DeoptimizationScope::_committed_deopt_gen = comitting;\n+        }\n+        _committing_in_progress = false;\n+\n+        assert(DeoptimizationScope::_committed_deopt_gen >= _required_gen, \"Must be\");\n+\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -43,0 +43,26 @@\n+class DeoptimizationScope {\n+ private:\n+  \/\/ What gen we have done the deopt handshake for.\n+  static uint64_t _committed_deopt_gen;\n+  \/\/ What gen to mark a method with, hence larger than _committed_deopt_gen.\n+  static uint64_t _active_deopt_gen;\n+  \/\/ Indicate an in-progress deopt handshake.\n+  static bool     _committing_in_progress;\n+\n+  \/\/ The required gen we need to execute\/wait for\n+  uint64_t _required_gen;\n+  DEBUG_ONLY(bool _deopted;)\n+\n+ public:\n+  DeoptimizationScope();\n+  ~DeoptimizationScope();\n+  \/\/ Mark a method, if already marked as dependent.\n+  void mark(CompiledMethod* cm, bool inc_recompile_counts = true);\n+  \/\/ Record this as a dependent method.\n+  void dependent(CompiledMethod* cm);\n+\n+  \/\/ Execute the deoptimization.\n+  \/\/ Make the nmethods not entrant, stackwalks and patch return pcs and sets post call nops.\n+  void deoptimize_marked();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}