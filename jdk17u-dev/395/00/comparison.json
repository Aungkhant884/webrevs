{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## The FreeType Project: Freetype v2.10.4\n+## The FreeType Project: Freetype v2.12.0\n","filename":"src\/java.desktop\/share\/legal\/freetype.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-This is important because presently on Linux and Solaris the build\n+This is important because presently on Linux the build\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/UPDATING.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftconfig.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -780,0 +780,12 @@\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_OTSVG_H\n+   *\n+   * @description:\n+   *   A macro used in `#include` statements to name the file containing the\n+   *   FreeType~2 API which handles the OpenType 'SVG~' glyphs.\n+   *\/\n+#define FT_OTSVG_H  <freetype\/otsvg.h>\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftheader.h","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+\/\/ FT_USE_MODULE( FT_Driver_ClassRec, bdf_driver_class )\n@@ -25,1 +26,0 @@\n-FT_USE_MODULE( FT_Renderer_Class, ft_raster1_renderer_class )\n@@ -28,1 +28,4 @@\n-\/\/ FT_USE_MODULE( FT_Driver_ClassRec, bdf_driver_class )\n+FT_USE_MODULE( FT_Renderer_Class, ft_raster1_renderer_class )\n+\/\/ FT_USE_MODULE( FT_Renderer_Class, ft_sdf_renderer_class )\n+\/\/ FT_USE_MODULE( FT_Renderer_Class, ft_bitmap_sdf_renderer_class )\n+\/\/ FT_USE_MODULE( FT_Renderer_Class, ft_svg_renderer_class )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftmodule.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -108,2 +108,1 @@\n-   *                       cff:no-stem-darkening=1 \\\n-   *                       autofitter:warping=1\n+   *                       cff:no-stem-darkening=1\n@@ -223,0 +222,4 @@\n+   *\n+   *   If you use the GNU make build system directly (that is, without the\n+   *   `configure` script) and you define this macro, you also have to pass\n+   *   `SYSTEM_ZLIB=yes` as an argument to make.\n@@ -434,0 +437,17 @@\n+  \/**************************************************************************\n+   *\n+   * Logging\n+   *\n+   *   Compiling FreeType in debug or trace mode makes FreeType write error\n+   *   and trace log messages to `stderr`.  Enabling this macro\n+   *   automatically forces the `FT_DEBUG_LEVEL_ERROR` and\n+   *   `FT_DEBUG_LEVEL_TRACE` macros and allows FreeType to write error and\n+   *   trace log messages to a file instead of `stderr`.  For writing logs\n+   *   to a file, FreeType uses an the external `dlg` library (the source\n+   *   code is in `src\/dlg`).\n+   *\n+   *   This option needs a C99 compiler.\n+   *\/\n+\/* #define FT_DEBUG_LOGGING *\/\n+\n+\n@@ -510,0 +530,14 @@\n+  \/**************************************************************************\n+   *\n+   * OpenType SVG Glyph Support\n+   *\n+   *   Setting this macro enables support for OpenType SVG glyphs.  By\n+   *   default, FreeType can only fetch SVG documents.  However, it can also\n+   *   render them if external rendering hook functions are plugged in at\n+   *   runtime.\n+   *\n+   *   More details on the hooks can be found in file `otsvg.h`.\n+   *\/\n+\/* #define FT_CONFIG_OPTION_SVG *\/\n+\n+\n@@ -895,18 +929,0 @@\n-  \/**************************************************************************\n-   *\n-   * Compile 'autofit' module with warp hinting.  The idea of the warping\n-   * code is to slightly scale and shift a glyph within a single dimension so\n-   * that as much of its segments are aligned (more or less) on the grid.  To\n-   * find out the optimal scaling and shifting value, various parameter\n-   * combinations are tried and scored.\n-   *\n-   * You can switch warping on and off with the `warping` property of the\n-   * auto-hinter (see file `ftdriver.h` for more information; by default it\n-   * is switched off).\n-   *\n-   * This experimental option is not active if the rendering mode is\n-   * `FT_RENDER_MODE_LIGHT`.\n-   *\/\n-#define AF_CONFIG_OPTION_USE_WARPER\n-\n-\n@@ -964,0 +980,15 @@\n+  \/*\n+   * The TT_SUPPORT_COLRV1 macro is defined to indicate to clients that this\n+   * version of FreeType has support for 'COLR' v1 API.  This definition is\n+   * useful to FreeType clients that want to build in support for 'COLR' v1\n+   * depending on a tip-of-tree checkout before it is officially released in\n+   * FreeType, and while the feature cannot yet be tested against using\n+   * version macros.  Don't change this macro.  This may be removed once the\n+   * feature is in a FreeType release version and version macros can be used\n+   * to test for availability.\n+   *\/\n+#ifdef TT_CONFIG_OPTION_COLOR_LAYERS\n+#define  TT_SUPPORT_COLRV1\n+#endif\n+\n+\n@@ -992,1 +1023,0 @@\n-FT_END_HEADER\n@@ -994,0 +1024,1 @@\n+FT_END_HEADER\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftoption.h","additions":53,"deletions":22,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n@@ -46,1 +46,2 @@\n-   * platforms the library has been tested on.\n+   * platforms the library has been tested on.  We also check `ULLONG_MAX`\n+   * to see whether we can use 64-bit `long long` later on.\n@@ -69,0 +70,9 @@\n+#ifdef LLONG_MAX\n+#define FT_LLONG_MAX   LLONG_MAX\n+#endif\n+#ifdef LLONG_MIN\n+#define FT_LLONG_MIN   LLONG_MIN\n+#endif\n+#ifdef ULLONG_MAX\n+#define FT_ULLONG_MAX  ULLONG_MAX\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/ftstdlib.h","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -63,0 +63,12 @@\n+#ifndef FT_SIZEOF_LONG_LONG\n+\n+  \/* The size of a `long long` type if available *\/\n+#if defined( FT_ULLONG_MAX ) && FT_ULLONG_MAX >= 0xFFFFFFFFFFFFFFFFULL\n+#define FT_SIZEOF_LONG_LONG  ( 64 \/ FT_CHAR_BIT )\n+#else\n+#define FT_SIZEOF_LONG_LONG  0\n+#endif\n+\n+#endif \/* !defined(FT_SIZEOF_LONG_LONG) *\/\n+\n+\n@@ -177,2 +189,1 @@\n-  \/* determine whether we have a 64-bit `int` type for platforms without *\/\n-  \/* Autoconf                                                            *\/\n+  \/* determine whether we have a 64-bit integer type *\/\n@@ -181,2 +192,0 @@\n-  \/* `FT_LONG64` must be defined if a 64-bit type is available *\/\n-#define FT_LONG64\n@@ -186,0 +195,5 @@\n+#elif FT_SIZEOF_LONG_LONG >= ( 64 \/ FT_CHAR_BIT )\n+\n+#define FT_INT64   long long int\n+#define FT_UINT64  unsigned long long int\n+\n@@ -195,7 +209,1 @@\n-#if defined( __STDC_VERSION__ ) && __STDC_VERSION__ >= 199901L\n-\n-#define FT_LONG64\n-#define FT_INT64   long long int\n-#define FT_UINT64  unsigned long long int\n-\n-#elif defined( _MSC_VER ) && _MSC_VER >= 900 \/* Visual C++ (and Intel C++) *\/\n+#if defined( _MSC_VER ) && _MSC_VER >= 900 \/* Visual C++ (and Intel C++) *\/\n@@ -204,1 +212,0 @@\n-#define FT_LONG64\n@@ -214,1 +221,0 @@\n-#define FT_LONG64\n@@ -218,1 +224,1 @@\n-#elif defined( __WATCOMC__ )   \/* Watcom C++ *\/\n+#elif defined( __WATCOMC__ ) && __WATCOMC__ >= 1100  \/* Watcom C++ *\/\n@@ -220,1 +226,2 @@\n-  \/* Watcom doesn't provide 64-bit data types *\/\n+#define FT_INT64   long long int\n+#define FT_UINT64  unsigned long long int\n@@ -224,1 +231,0 @@\n-#define FT_LONG64\n@@ -231,1 +237,0 @@\n-#define FT_LONG64\n@@ -235,1 +240,1 @@\n-#endif \/* __STDC_VERSION__ >= 199901L *\/\n+#endif \/* !__STDC__ *\/\n@@ -239,1 +244,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/integer-types.h","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/mac-support.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020 by\n+ * Copyright (C) 2020-2022 by\n@@ -106,0 +106,1 @@\n+\n@@ -118,0 +119,17 @@\n+  \/*\n+   * Support for casts in both C and C++.\n+   *\/\n+#ifdef __cplusplus\n+#define FT_STATIC_CAST( type, var )       static_cast<type>(var)\n+#define FT_REINTERPRET_CAST( type, var )  reinterpret_cast<type>(var)\n+\n+#define FT_STATIC_BYTE_CAST( type, var )                         \\\n+          static_cast<type>( static_cast<unsigned char>( var ) )\n+#else\n+#define FT_STATIC_CAST( type, var )       (type)(var)\n+#define FT_REINTERPRET_CAST( type, var )  (type)(var)\n+\n+#define FT_STATIC_BYTE_CAST( type, var )  (type)(unsigned char)(var)\n+#endif\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/config\/public-macros.h","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -33,0 +33,28 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   preamble\n+   *\n+   * @title:\n+   *   Preamble\n+   *\n+   * @abstract:\n+   *   What FreeType is and isn't\n+   *\n+   * @description:\n+   *   FreeType is a library that provides access to glyphs in font files.  It\n+   *   scales the glyph images and their metrics to a requested size, and it\n+   *   rasterizes the glyph images to produce pixel or subpixel alpha coverage\n+   *   bitmaps.\n+   *\n+   *   Note that FreeType is _not_ a text layout engine.  You have to use\n+   *   higher-level libraries like HarfBuzz, Pango, or ICU for that.\n+   *\n+   *   Note also that FreeType does _not_ perform alpha blending or\n+   *   compositing the resulting bitmaps or pixmaps by itself.  Use your\n+   *   favourite graphics library (for example, Cairo or Skia) to further\n+   *   process FreeType's output.\n+   *\n+   *\/\n+\n+\n@@ -128,0 +156,3 @@\n+   *   FT_FACE_FLAG_SVG\n+   *   FT_FACE_FLAG_SBIX\n+   *   FT_FACE_FLAG_SBIX_OVERLAY\n@@ -136,0 +167,3 @@\n+   *   FT_HAS_SVG\n+   *   FT_HAS_SBIX\n+   *   FT_HAS_SBIX_OVERLAY\n@@ -179,0 +213,1 @@\n+   *   FT_Get_Transform\n@@ -199,0 +234,1 @@\n+   *   FT_LOAD_SBITS_ONLY\n@@ -496,3 +532,3 @@\n-   *   An @FT_Face has one _active_ @FT_Size object that is used by functions\n-   *   like @FT_Load_Glyph to determine the scaling transformation that in\n-   *   turn is used to load and hint glyphs and metrics.\n+   *   An @FT_Face has one _active_ `FT_Size` object that is used by\n+   *   functions like @FT_Load_Glyph to determine the scaling transformation\n+   *   that in turn is used to load and hint glyphs and metrics.\n@@ -500,1 +536,2 @@\n-   *   You can use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size\n+   *   A newly created `FT_Size` object contains only meaningless zero values.\n+   *   You must use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size\n@@ -502,1 +539,2 @@\n-   *   values) of the active @FT_Size.\n+   *   values) of the active `FT_Size`.  Otherwise, the scaling and hinting\n+   *   will not be performed.\n@@ -590,5 +628,6 @@\n-#define FT_ENC_TAG( value, a, b, c, d )         \\\n-          value = ( ( (FT_UInt32)(a) << 24 ) |  \\\n-                    ( (FT_UInt32)(b) << 16 ) |  \\\n-                    ( (FT_UInt32)(c) <<  8 ) |  \\\n-                      (FT_UInt32)(d)         )\n+\n+#define FT_ENC_TAG( value, a, b, c, d )                             \\\n+          value = ( ( FT_STATIC_BYTE_CAST( FT_UInt32, a ) << 24 ) | \\\n+                    ( FT_STATIC_BYTE_CAST( FT_UInt32, b ) << 16 ) | \\\n+                    ( FT_STATIC_BYTE_CAST( FT_UInt32, c ) <<  8 ) | \\\n+                      FT_STATIC_BYTE_CAST( FT_UInt32, d )         )\n@@ -704,5 +743,10 @@\n-   *   By default, FreeType enables a Unicode charmap and tags it with\n-   *   `FT_ENCODING_UNICODE` when it is either provided or can be generated\n-   *   from PostScript glyph name dictionaries in the font file.  All other\n-   *   encodings are considered legacy and tagged only if explicitly defined\n-   *   in the font file.  Otherwise, `FT_ENCODING_NONE` is used.\n+   *   When loading a font, FreeType makes a Unicode charmap active if\n+   *   possible (either if the font provides such a charmap, or if FreeType\n+   *   can synthesize one from PostScript glyph name dictionaries; in either\n+   *   case, the charmap is tagged with `FT_ENCODING_UNICODE`).  If such a\n+   *   charmap is synthesized, it is placed at the first position of the\n+   *   charmap array.\n+   *\n+   *   All other encodings are considered legacy and tagged only if\n+   *   explicitly defined in the font file.  Otherwise, `FT_ENCODING_NONE` is\n+   *   used.\n@@ -1196,0 +1240,13 @@\n+   *\n+   *   FT_FACE_FLAG_SVG ::\n+   *     [Since 2.12] The face has an 'SVG~' OpenType table.\n+   *\n+   *   FT_FACE_FLAG_SBIX ::\n+   *     [Since 2.12] The face has an 'sbix' OpenType table *and* outlines.\n+   *     For such fonts, @FT_FACE_FLAG_SCALABLE is not set by default to\n+   *     retain backward compatibility.\n+   *\n+   *   FT_FACE_FLAG_SBIX_OVERLAY ::\n+   *     [Since 2.12] The face has an 'sbix' OpenType table where outlines\n+   *     should be drawn on top of bitmap strikes.\n+   *\n@@ -1213,0 +1270,3 @@\n+#define FT_FACE_FLAG_SVG               ( 1L << 16 )\n+#define FT_FACE_FLAG_SBIX              ( 1L << 17 )\n+#define FT_FACE_FLAG_SBIX_OVERLAY      ( 1L << 18 )\n@@ -1453,0 +1513,118 @@\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_HAS_SVG\n+   *\n+   * @description:\n+   *   A macro that returns true whenever a face object contains an 'SVG~'\n+   *   OpenType table.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+#define FT_HAS_SVG( face ) \\\n+          ( !!( (face)->face_flags & FT_FACE_FLAG_SVG ) )\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_HAS_SBIX\n+   *\n+   * @description:\n+   *   A macro that returns true whenever a face object contains an 'sbix'\n+   *   OpenType table *and* outline glyphs.\n+   *\n+   *   Currently, FreeType only supports bitmap glyphs in PNG format for this\n+   *   table (i.e., JPEG and TIFF formats are unsupported, as are\n+   *   Apple-specific formats not part of the OpenType specification).\n+   *\n+   * @note:\n+   *   For backward compatibility, a font with an 'sbix' table is treated as\n+   *   a bitmap-only face.  Using @FT_Open_Face with\n+   *   @FT_PARAM_TAG_IGNORE_SBIX, an application can switch off 'sbix'\n+   *   handling so that the face is treated as an ordinary outline font with\n+   *   scalable outlines.\n+   *\n+   *   Here is some pseudo code that roughly illustrates how to implement\n+   *   'sbix' handling according to the OpenType specification.\n+   *\n+   * ```\n+   *   if ( FT_HAS_SBIX( face ) )\n+   *   {\n+   *     \/\/ open font as a scalable one without sbix handling\n+   *     FT_Face       face2;\n+   *     FT_Parameter  param = { FT_PARAM_TAG_IGNORE_SBIX, NULL };\n+   *     FT_Open_Args  args  = { FT_OPEN_PARAMS | ...,\n+   *                             ...,\n+   *                             1, &param };\n+   *\n+   *\n+   *     FT_Open_Face( library, &args, 0, &face2 );\n+   *\n+   *     <sort `face->available_size` as necessary into\n+   *      `preferred_sizes`[*]>\n+   *\n+   *     for ( i = 0; i < face->num_fixed_sizes; i++ )\n+   *     {\n+   *       size = preferred_sizes[i].size;\n+   *\n+   *       error = FT_Set_Pixel_Sizes( face, size, size );\n+   *       <error handling omitted>\n+   *\n+   *       \/\/ check whether we have a glyph in a bitmap strike\n+   *       error = FT_Load_Glyph( face,\n+   *                              glyph_index,\n+   *                              FT_LOAD_SBITS_ONLY          |\n+   *                              FT_LOAD_BITMAP_METRICS_ONLY );\n+   *       if ( error == FT_Err_Invalid_Argument )\n+   *         continue;\n+   *       else if ( error )\n+   *         <other error handling omitted>\n+   *       else\n+   *         break;\n+   *     }\n+   *\n+   *     if ( i != face->num_fixed_sizes )\n+   *       <load embedded bitmap with `FT_Load_Glyph`,\n+   *        scale it, display it, etc.>\n+   *\n+   *     if ( i == face->num_fixed_sizes  ||\n+   *          FT_HAS_SBIX_OVERLAY( face ) )\n+   *       <use `face2` to load outline glyph with `FT_Load_Glyph`,\n+   *        scale it, display it on top of the bitmap, etc.>\n+   *   }\n+   * ```\n+   *\n+   * [*] Assuming a target value of 400dpi and available strike sizes 100,\n+   * 200, 300, and 400dpi, a possible order might be [400, 200, 300, 100]:\n+   * scaling 200dpi to 400dpi usually gives better results than scaling\n+   * 300dpi to 400dpi; it is also much faster.  However, scaling 100dpi to\n+   * 400dpi can yield a too pixelated result, thus the preference might be\n+   * 300dpi over 100dpi.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+#define FT_HAS_SBIX( face ) \\\n+          ( !!( (face)->face_flags & FT_FACE_FLAG_SBIX ) )\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_HAS_SBIX_OVERLAY\n+   *\n+   * @description:\n+   *   A macro that returns true whenever a face object contains an 'sbix'\n+   *   OpenType table with bit~1 in its `flags` field set, instructing the\n+   *   application to overlay the bitmap strike with the corresponding\n+   *   outline glyph.  See @FT_HAS_SBIX for pseudo code how to use it.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+#define FT_HAS_SBIX_OVERLAY( face ) \\\n+          ( !!( (face)->face_flags & FT_FACE_FLAG_SBIX_OVERLAY ) )\n+\n+\n@@ -2068,1 +2246,2 @@\n-   *     A pointer to an 8-bit file pathname.  The pointer is not owned by\n+   *     A pointer to an 8-bit file pathname, which must be a C~string (i.e.,\n+   *     no null bytes except at the very end).  The pointer is not owned by\n@@ -2087,2 +2266,1 @@\n-   *   The stream type is determined by the contents of `flags` that are\n-   *   tested in the following order by @FT_Open_Face:\n+   *   The stream type is determined by the contents of `flags`:\n@@ -2101,0 +2279,3 @@\n+   *   If none of the above bits are set or if multiple are set at the same\n+   *   time, the flags are invalid and @FT_Open_Face fails.\n+   *\n@@ -2153,0 +2334,7 @@\n+   *   The `pathname` string should be recognizable as such by a standard\n+   *   `fopen` call on your system; in particular, this means that `pathname`\n+   *   must not contain null bytes.  If that is not sufficient to address all\n+   *   file name possibilities (for example, to handle wide character file\n+   *   names on Windows in UTF-16 encoding) you might use @FT_Open_Face to\n+   *   pass a memory array or a stream object instead.\n+   *\n@@ -2273,0 +2461,4 @@\n+   *   If `FT_OPEN_STREAM` is set in `args->flags`, the stream in\n+   *   `args->stream` is automatically closed before this function returns\n+   *   any error (including `FT_Err_Invalid_Argument`).\n+   *\n@@ -2431,0 +2623,1 @@\n+   *\n@@ -2655,2 +2848,2 @@\n-   *   to normalize zero-valued widths, heights, or resolutions (which lead\n-   *   to errors in most cases).\n+   *   to normalize zero-valued widths, heights, or resolutions, which are\n+   *   treated as @FT_LOAD_NO_SCALE.\n@@ -2772,1 +2965,1 @@\n-   *     constants can be used to control the glyph loading process (e.g.,\n+   *     flags can be used to control the glyph loading process (e.g.,\n@@ -2780,2 +2973,4 @@\n-   *   The loaded glyph may be transformed.  See @FT_Set_Transform for the\n-   *   details.\n+   *   For proper scaling and hinting, the active @FT_Size object owned by\n+   *   the face has to be meaningfully initialized by calling\n+   *   @FT_Set_Char_Size before this function, for example.  The loaded\n+   *   glyph may be transformed.  See @FT_Set_Transform for the details.\n@@ -2871,0 +3066,2 @@\n+   *     This flag is also assumed if @FT_Size owned by the face was not\n+   *     properly initialized.\n@@ -2901,0 +3098,9 @@\n+   *   FT_LOAD_SBITS_ONLY ::\n+   *     [Since 2.12] This is the opposite of @FT_LOAD_NO_BITMAP, more or\n+   *     less: @FT_Load_Glyph returns `FT_Err_Invalid_Argument` if the face\n+   *     contains a bitmap strike for the given size (or the strike selected\n+   *     by @FT_Select_Size) but there is no glyph in the strike.\n+   *\n+   *     Note that this load flag was part of FreeType since version 2.0.6\n+   *     but previously tagged as internal.\n+   *\n@@ -2957,10 +3163,18 @@\n-   *     Load colored glyphs.  There are slight differences depending on the\n-   *     font format.\n-   *\n-   *     [Since 2.5] Load embedded color bitmap images.  The resulting color\n-   *     bitmaps, if available, will have the @FT_PIXEL_MODE_BGRA format,\n-   *     with pre-multiplied color channels.  If the flag is not set and\n-   *     color bitmaps are found, they are converted to 256-level gray\n-   *     bitmaps, using the @FT_PIXEL_MODE_GRAY format.\n-   *\n-   *     [Since 2.10, experimental] If the glyph index contains an entry in\n+   *     Load colored glyphs.  FreeType searches in the following order;\n+   *     there are slight differences depending on the font format.\n+   *\n+   *     [Since 2.5] Load embedded color bitmap images (provided\n+   *     @FT_LOAD_NO_BITMAP is not set).  The resulting color bitmaps, if\n+   *     available, have the @FT_PIXEL_MODE_BGRA format, with pre-multiplied\n+   *     color channels.  If the flag is not set and color bitmaps are found,\n+   *     they are converted to 256-level gray bitmaps, using the\n+   *     @FT_PIXEL_MODE_GRAY format.\n+   *\n+   *     [Since 2.12] If the glyph index maps to an entry in the face's\n+   *     'SVG~' table, load the associated SVG document from this table and\n+   *     set the `format` field of @FT_GlyphSlotRec to @FT_GLYPH_FORMAT_SVG.\n+   *     Note that FreeType itself can't render SVG documents; however, the\n+   *     library provides hooks to seamlessly integrate an external renderer.\n+   *     See sections @ot_svg_driver and @svg_fonts for more.\n+   *\n+   *     [Since 2.10, experimental] If the glyph index maps to an entry in\n@@ -2971,1 +3185,3 @@\n-   *     is mainly for convenience; for full control of color layers use\n+   *     is mainly for convenience and works only for glyphs in 'COLR' v0\n+   *     tables (or glyphs in 'COLR' v1 tables that exclusively use v0\n+   *     features).  For full control of color layers use\n@@ -3022,9 +3238,9 @@\n-#define FT_LOAD_NO_SCALE                     ( 1L << 0 )\n-#define FT_LOAD_NO_HINTING                   ( 1L << 1 )\n-#define FT_LOAD_RENDER                       ( 1L << 2 )\n-#define FT_LOAD_NO_BITMAP                    ( 1L << 3 )\n-#define FT_LOAD_VERTICAL_LAYOUT              ( 1L << 4 )\n-#define FT_LOAD_FORCE_AUTOHINT               ( 1L << 5 )\n-#define FT_LOAD_CROP_BITMAP                  ( 1L << 6 )\n-#define FT_LOAD_PEDANTIC                     ( 1L << 7 )\n-#define FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH  ( 1L << 9 )\n+#define FT_LOAD_NO_SCALE                     ( 1L << 0  )\n+#define FT_LOAD_NO_HINTING                   ( 1L << 1  )\n+#define FT_LOAD_RENDER                       ( 1L << 2  )\n+#define FT_LOAD_NO_BITMAP                    ( 1L << 3  )\n+#define FT_LOAD_VERTICAL_LAYOUT              ( 1L << 4  )\n+#define FT_LOAD_FORCE_AUTOHINT               ( 1L << 5  )\n+#define FT_LOAD_CROP_BITMAP                  ( 1L << 6  )\n+#define FT_LOAD_PEDANTIC                     ( 1L << 7  )\n+#define FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH  ( 1L << 9  )\n@@ -3035,0 +3251,1 @@\n+#define FT_LOAD_SBITS_ONLY                   ( 1L << 14 )\n@@ -3044,2 +3261,2 @@\n-#define FT_LOAD_ADVANCE_ONLY                 ( 1L << 8 )\n-#define FT_LOAD_SBITS_ONLY                   ( 1L << 14 )\n+#define FT_LOAD_ADVANCE_ONLY                 ( 1L << 8  )\n+#define FT_LOAD_SVG_ONLY                     ( 1L << 23 )\n@@ -3135,1 +3352,1 @@\n-#define FT_LOAD_TARGET_( x )   ( (FT_Int32)( (x) & 15 ) << 16 )\n+#define FT_LOAD_TARGET_( x )   ( FT_STATIC_CAST( FT_Int32, (x) & 15 ) << 16 )\n@@ -3154,1 +3371,2 @@\n-#define FT_LOAD_TARGET_MODE( x )  ( (FT_Render_Mode)( ( (x) >> 16 ) & 15 ) )\n+#define FT_LOAD_TARGET_MODE( x )                               \\\n+          FT_STATIC_CAST( FT_Render_Mode, ( (x) >> 16 ) & 15 )\n@@ -3175,1 +3393,2 @@\n-   *     A pointer to the translation vector.  Use `NULL` for the null vector.\n+   *     A pointer to the translation vector.  Use `NULL` for the null\n+   *     vector.\n@@ -3179,1 +3398,1 @@\n-   *   @FT_Matrix coefficients are only 16.16 fixed point values, which can\n+   *   @FT_Matrix coefficients are only 16.16 fixed-point values, which can\n@@ -3198,0 +3417,33 @@\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Transform\n+   *\n+   * @description:\n+   *   Return the transformation that is applied to glyph images when they\n+   *   are loaded into a glyph slot through @FT_Load_Glyph.  See\n+   *   @FT_Set_Transform for more details.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the source face object.\n+   *\n+   * @output:\n+   *   matrix ::\n+   *     A pointer to a transformation's 2x2 matrix.  Set this to NULL if you\n+   *     are not interested in the value.\n+   *\n+   *   delta ::\n+   *     A pointer a translation vector.  Set this to NULL if you are not\n+   *     interested in the value.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Get_Transform( FT_Face     face,\n+                    FT_Matrix*  matrix,\n+                    FT_Vector*  delta );\n+\n+\n@@ -3216,0 +3468,4 @@\n+   *   The @FT_RENDER_MODE_SDF is a special render mode that uses up to 256\n+   *   distance values, indicating the signed distance from the grid position\n+   *   to the nearest outline.\n+   *\n@@ -3241,0 +3497,9 @@\n+   *   FT_RENDER_MODE_SDF ::\n+   *     This mode corresponds to 8-bit, single-channel signed distance field\n+   *     (SDF) bitmaps.  Each pixel in the SDF grid is the value from the\n+   *     pixel's position to the nearest glyph's outline.  The distances are\n+   *     calculated from the center of the pixel and are positive if they are\n+   *     filled by the outline (i.e., inside the outline) and negative\n+   *     otherwise.  Check the note below on how to convert the output values\n+   *     to usable data.\n+   *\n@@ -3246,0 +3511,67 @@\n+   *\n+   *   For @FT_RENDER_MODE_SDF the output bitmap buffer contains normalized\n+   *   distances that are packed into unsigned 8-bit values.  To get pixel\n+   *   values in floating point representation use the following pseudo-C\n+   *   code for the conversion.\n+   *\n+   *   ```\n+   *   \/\/ Load glyph and render using FT_RENDER_MODE_SDF,\n+   *   \/\/ then use the output buffer as follows.\n+   *\n+   *   ...\n+   *   FT_Byte  buffer = glyph->bitmap->buffer;\n+   *\n+   *\n+   *   for pixel in buffer\n+   *   {\n+   *     \/\/ `sd` is the signed distance and `spread` is the current spread;\n+   *     \/\/ the default spread is 2 and can be changed.\n+   *\n+   *     float  sd = (float)pixel - 128.0f;\n+   *\n+   *\n+   *     \/\/ Convert to pixel values.\n+   *     sd = ( sd \/ 128.0f ) * spread;\n+   *\n+   *     \/\/ Store `sd` in a buffer or use as required.\n+   *   }\n+   *\n+   *   ```\n+   *\n+   *   FreeType has two rasterizers for generating SDF, namely:\n+   *\n+   *   1. `sdf` for generating SDF directly from glyph's outline, and\n+   *\n+   *   2. `bsdf` for generating SDF from rasterized bitmaps.\n+   *\n+   *   Depending on the glyph type (i.e., outline or bitmap), one of the two\n+   *   rasterizers is chosen at runtime and used for generating SDFs.  To\n+   *   force the use of `bsdf` you should render the glyph with any of the\n+   *   FreeType's other rendering modes (e.g., `FT_RENDER_MODE_NORMAL`) and\n+   *   then re-render with `FT_RENDER_MODE_SDF`.\n+   *\n+   *   There are some issues with stability and possible failures of the SDF\n+   *   renderers (specifically `sdf`).\n+   *\n+   *   1. The `sdf` rasterizer is sensitive to really small features (e.g.,\n+   *      sharp turns that are less than 1~pixel) and imperfections in the\n+   *      glyph's outline, causing artifacts in the final output.\n+   *\n+   *   2. The `sdf` rasterizer has limited support for handling intersecting\n+   *      contours and *cannot* handle self-intersecting contours whatsoever.\n+   *      Self-intersection happens when a single connected contour intersect\n+   *      itself at some point; having these in your font definitely pose a\n+   *      problem to the rasterizer and cause artifacts, too.\n+   *\n+   *   3. Generating SDF for really small glyphs may result in undesirable\n+   *      output; the pixel grid (which stores distance information) becomes\n+   *      too coarse.\n+   *\n+   *   4. Since the output buffer is normalized, precision at smaller spreads\n+   *      is greater than precision at larger spread values because the\n+   *      output range of [0..255] gets mapped to a smaller SDF range.  A\n+   *      spread of~2 should be sufficient in most cases.\n+   *\n+   *   Points (1) and (2) can be avoided by using the `bsdf` rasterizer,\n+   *   which is more stable than the `sdf` rasterizer in general.\n+   *\n@@ -3254,0 +3586,1 @@\n+    FT_RENDER_MODE_SDF,\n@@ -3285,1 +3618,1 @@\n-   *     with flag @FT_LOAD_COLOR makes FT_Render_Glyph provide a default\n+   *     with flag @FT_LOAD_COLOR makes `FT_Render_Glyph` provide a default\n@@ -3295,3 +3628,0 @@\n-   *   To get meaningful results, font scaling values must be set with\n-   *   functions like @FT_Set_Char_Size before calling `FT_Render_Glyph`.\n-   *\n@@ -3341,1 +3671,2 @@\n-   *   To correctly composite an antialiased pixel of a glyph onto a surface,\n+   *   To correctly composite an anti-aliased pixel of a glyph onto a\n+   *   surface,\n@@ -4018,162 +4349,0 @@\n-  \/**************************************************************************\n-   *\n-   * @section:\n-   *   layer_management\n-   *\n-   * @title:\n-   *   Glyph Layer Management\n-   *\n-   * @abstract:\n-   *   Retrieving and manipulating OpenType's 'COLR' table data.\n-   *\n-   * @description:\n-   *   The functions described here allow access of colored glyph layer data\n-   *   in OpenType's 'COLR' tables.\n-   *\/\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @struct:\n-   *   FT_LayerIterator\n-   *\n-   * @description:\n-   *   This iterator object is needed for @FT_Get_Color_Glyph_Layer.\n-   *\n-   * @fields:\n-   *   num_layers ::\n-   *     The number of glyph layers for the requested glyph index.  Will be\n-   *     set by @FT_Get_Color_Glyph_Layer.\n-   *\n-   *   layer ::\n-   *     The current layer.  Will be set by @FT_Get_Color_Glyph_Layer.\n-   *\n-   *   p ::\n-   *     An opaque pointer into 'COLR' table data.  The caller must set this\n-   *     to `NULL` before the first call of @FT_Get_Color_Glyph_Layer.\n-   *\/\n-  typedef struct  FT_LayerIterator_\n-  {\n-    FT_UInt   num_layers;\n-    FT_UInt   layer;\n-    FT_Byte*  p;\n-\n-  } FT_LayerIterator;\n-\n-\n-  \/**************************************************************************\n-   *\n-   * @function:\n-   *   FT_Get_Color_Glyph_Layer\n-   *\n-   * @description:\n-   *   This is an interface to the 'COLR' table in OpenType fonts to\n-   *   iteratively retrieve the colored glyph layers associated with the\n-   *   current glyph slot.\n-   *\n-   *     https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n-   *\n-   *   The glyph layer data for a given glyph index, if present, provides an\n-   *   alternative, multi-color glyph representation: Instead of rendering\n-   *   the outline or bitmap with the given glyph index, glyphs with the\n-   *   indices and colors returned by this function are rendered layer by\n-   *   layer.\n-   *\n-   *   The returned elements are ordered in the z~direction from bottom to\n-   *   top; the 'n'th element should be rendered with the associated palette\n-   *   color and blended on top of the already rendered layers (elements 0,\n-   *   1, ..., n-1).\n-   *\n-   * @input:\n-   *   face ::\n-   *     A handle to the parent face object.\n-   *\n-   *   base_glyph ::\n-   *     The glyph index the colored glyph layers are associated with.\n-   *\n-   * @inout:\n-   *   iterator ::\n-   *     An @FT_LayerIterator object.  For the first call you should set\n-   *     `iterator->p` to `NULL`.  For all following calls, simply use the\n-   *     same object again.\n-   *\n-   * @output:\n-   *   aglyph_index ::\n-   *     The glyph index of the current layer.\n-   *\n-   *   acolor_index ::\n-   *     The color index into the font face's color palette of the current\n-   *     layer.  The value 0xFFFF is special; it doesn't reference a palette\n-   *     entry but indicates that the text foreground color should be used\n-   *     instead (to be set up by the application outside of FreeType).\n-   *\n-   *     The color palette can be retrieved with @FT_Palette_Select.\n-   *\n-   * @return:\n-   *   Value~1 if everything is OK.  If there are no more layers (or if there\n-   *   are no layers at all), value~0 gets returned.  In case of an error,\n-   *   value~0 is returned also.\n-   *\n-   * @note:\n-   *   This function is necessary if you want to handle glyph layers by\n-   *   yourself.  In particular, functions that operate with @FT_GlyphRec\n-   *   objects (like @FT_Get_Glyph or @FT_Glyph_To_Bitmap) don't have access\n-   *   to this information.\n-   *\n-   *   Note that @FT_Render_Glyph is able to handle colored glyph layers\n-   *   automatically if the @FT_LOAD_COLOR flag is passed to a previous call\n-   *   to @FT_Load_Glyph.  [This is an experimental feature.]\n-   *\n-   * @example:\n-   *   ```\n-   *     FT_Color*         palette;\n-   *     FT_LayerIterator  iterator;\n-   *\n-   *     FT_Bool  have_layers;\n-   *     FT_UInt  layer_glyph_index;\n-   *     FT_UInt  layer_color_index;\n-   *\n-   *\n-   *     error = FT_Palette_Select( face, palette_index, &palette );\n-   *     if ( error )\n-   *       palette = NULL;\n-   *\n-   *     iterator.p  = NULL;\n-   *     have_layers = FT_Get_Color_Glyph_Layer( face,\n-   *                                             glyph_index,\n-   *                                             &layer_glyph_index,\n-   *                                             &layer_color_index,\n-   *                                             &iterator );\n-   *\n-   *     if ( palette && have_layers )\n-   *     {\n-   *       do\n-   *       {\n-   *         FT_Color  layer_color;\n-   *\n-   *\n-   *         if ( layer_color_index == 0xFFFF )\n-   *           layer_color = text_foreground_color;\n-   *         else\n-   *           layer_color = palette[layer_color_index];\n-   *\n-   *         \/\/ Load and render glyph `layer_glyph_index', then\n-   *         \/\/ blend resulting pixmap (using color `layer_color')\n-   *         \/\/ with previously created pixmaps.\n-   *\n-   *       } while ( FT_Get_Color_Glyph_Layer( face,\n-   *                                           glyph_index,\n-   *                                           &layer_glyph_index,\n-   *                                           &layer_color_index,\n-   *                                           &iterator ) );\n-   *     }\n-   *   ```\n-   *\/\n-  FT_EXPORT( FT_Bool )\n-  FT_Get_Color_Glyph_Layer( FT_Face            face,\n-                            FT_UInt            base_glyph,\n-                            FT_UInt           *aglyph_index,\n-                            FT_UInt           *acolor_index,\n-                            FT_LayerIterator*  iterator );\n-\n-\n@@ -4270,0 +4439,1 @@\n+   *\n@@ -4363,0 +4533,1 @@\n+   *\n@@ -4399,0 +4570,1 @@\n+   *\n@@ -4430,0 +4602,1 @@\n+   *\n@@ -4463,0 +4636,1 @@\n+   *\n@@ -4497,0 +4671,1 @@\n+   *\n@@ -4769,2 +4944,2 @@\n-#define FREETYPE_MINOR  10\n-#define FREETYPE_PATCH  4\n+#define FREETYPE_MINOR  12\n+#define FREETYPE_PATCH  0\n@@ -4832,0 +5007,1 @@\n+   *\n@@ -4860,0 +5036,1 @@\n+   *\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/freetype.h","additions":396,"deletions":219,"binary":false,"changes":615,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2020 by\n+ * Copyright (C) 2008-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftadvanc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftbbox.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftbdf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftbitmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+   *   preamble\n@@ -64,0 +65,1 @@\n+   *   svg_fonts\n@@ -84,0 +86,1 @@\n+   *   ot_svg_driver\n@@ -126,0 +129,1 @@\n+   *   debugging_apis\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftchapters.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftcid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2020 by\n+ * Copyright (C) 2018-2022 by\n@@ -305,0 +305,1405 @@\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   layer_management\n+   *\n+   * @title:\n+   *   Glyph Layer Management\n+   *\n+   * @abstract:\n+   *   Retrieving and manipulating OpenType's 'COLR' table data.\n+   *\n+   * @description:\n+   *   The functions described here allow access of colored glyph layer data\n+   *   in OpenType's 'COLR' tables.\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_LayerIterator\n+   *\n+   * @description:\n+   *   This iterator object is needed for @FT_Get_Color_Glyph_Layer.\n+   *\n+   * @fields:\n+   *   num_layers ::\n+   *     The number of glyph layers for the requested glyph index.  Will be\n+   *     set by @FT_Get_Color_Glyph_Layer.\n+   *\n+   *   layer ::\n+   *     The current layer.  Will be set by @FT_Get_Color_Glyph_Layer.\n+   *\n+   *   p ::\n+   *     An opaque pointer into 'COLR' table data.  The caller must set this\n+   *     to `NULL` before the first call of @FT_Get_Color_Glyph_Layer.\n+   *\/\n+  typedef struct  FT_LayerIterator_\n+  {\n+    FT_UInt   num_layers;\n+    FT_UInt   layer;\n+    FT_Byte*  p;\n+\n+  } FT_LayerIterator;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Color_Glyph_Layer\n+   *\n+   * @description:\n+   *   This is an interface to the 'COLR' table in OpenType fonts to\n+   *   iteratively retrieve the colored glyph layers associated with the\n+   *   current glyph slot.\n+   *\n+   *     https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n+   *\n+   *   The glyph layer data for a given glyph index, if present, provides an\n+   *   alternative, multi-color glyph representation: Instead of rendering\n+   *   the outline or bitmap with the given glyph index, glyphs with the\n+   *   indices and colors returned by this function are rendered layer by\n+   *   layer.\n+   *\n+   *   The returned elements are ordered in the z~direction from bottom to\n+   *   top; the 'n'th element should be rendered with the associated palette\n+   *   color and blended on top of the already rendered layers (elements 0,\n+   *   1, ..., n-1).\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index the colored glyph layers are associated with.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     An @FT_LayerIterator object.  For the first call you should set\n+   *     `iterator->p` to `NULL`.  For all following calls, simply use the\n+   *     same object again.\n+   *\n+   * @output:\n+   *   aglyph_index ::\n+   *     The glyph index of the current layer.\n+   *\n+   *   acolor_index ::\n+   *     The color index into the font face's color palette of the current\n+   *     layer.  The value 0xFFFF is special; it doesn't reference a palette\n+   *     entry but indicates that the text foreground color should be used\n+   *     instead (to be set up by the application outside of FreeType).\n+   *\n+   *     The color palette can be retrieved with @FT_Palette_Select.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If there are no more layers (or if there\n+   *   are no layers at all), value~0 gets returned.  In case of an error,\n+   *   value~0 is returned also.\n+   *\n+   * @note:\n+   *   This function is necessary if you want to handle glyph layers by\n+   *   yourself.  In particular, functions that operate with @FT_GlyphRec\n+   *   objects (like @FT_Get_Glyph or @FT_Glyph_To_Bitmap) don't have access\n+   *   to this information.\n+   *\n+   *   Note that @FT_Render_Glyph is able to handle colored glyph layers\n+   *   automatically if the @FT_LOAD_COLOR flag is passed to a previous call\n+   *   to @FT_Load_Glyph.  [This is an experimental feature.]\n+   *\n+   * @example:\n+   *   ```\n+   *     FT_Color*         palette;\n+   *     FT_LayerIterator  iterator;\n+   *\n+   *     FT_Bool  have_layers;\n+   *     FT_UInt  layer_glyph_index;\n+   *     FT_UInt  layer_color_index;\n+   *\n+   *\n+   *     error = FT_Palette_Select( face, palette_index, &palette );\n+   *     if ( error )\n+   *       palette = NULL;\n+   *\n+   *     iterator.p  = NULL;\n+   *     have_layers = FT_Get_Color_Glyph_Layer( face,\n+   *                                             glyph_index,\n+   *                                             &layer_glyph_index,\n+   *                                             &layer_color_index,\n+   *                                             &iterator );\n+   *\n+   *     if ( palette && have_layers )\n+   *     {\n+   *       do\n+   *       {\n+   *         FT_Color  layer_color;\n+   *\n+   *\n+   *         if ( layer_color_index == 0xFFFF )\n+   *           layer_color = text_foreground_color;\n+   *         else\n+   *           layer_color = palette[layer_color_index];\n+   *\n+   *         \/\/ Load and render glyph `layer_glyph_index', then\n+   *         \/\/ blend resulting pixmap (using color `layer_color')\n+   *         \/\/ with previously created pixmaps.\n+   *\n+   *       } while ( FT_Get_Color_Glyph_Layer( face,\n+   *                                           glyph_index,\n+   *                                           &layer_glyph_index,\n+   *                                           &layer_color_index,\n+   *                                           &iterator ) );\n+   *     }\n+   *   ```\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Color_Glyph_Layer( FT_Face            face,\n+                            FT_UInt            base_glyph,\n+                            FT_UInt           *aglyph_index,\n+                            FT_UInt           *acolor_index,\n+                            FT_LayerIterator*  iterator );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_PaintFormat\n+   *\n+   * @description:\n+   *   Enumeration describing the different paint format types of the v1\n+   *   extensions to the 'COLR' table, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *\n+   *   The enumeration values losely correspond with the format numbers of\n+   *   the specification: FreeType always returns a fully specified 'Paint'\n+   *   structure for the 'Transform', 'Translate', 'Scale', 'Rotate', and\n+   *   'Skew' table types even though the specification has different formats\n+   *   depending on whether or not a center is specified, whether the scale\n+   *   is uniform in x and y~direction or not, etc.  Also, only non-variable\n+   *   format identifiers are listed in this enumeration; as soon as support\n+   *   for variable 'COLR' v1 fonts is implemented, interpolation is\n+   *   performed dependent on axis coordinates, which are configured on the\n+   *   @FT_Face through @FT_Set_Var_Design_Coordinates.  This implies that\n+   *   always static, readily interpolated values are returned in the 'Paint'\n+   *   structures.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef enum  FT_PaintFormat_\n+  {\n+    FT_COLR_PAINTFORMAT_COLR_LAYERS     = 1,\n+    FT_COLR_PAINTFORMAT_SOLID           = 2,\n+    FT_COLR_PAINTFORMAT_LINEAR_GRADIENT = 4,\n+    FT_COLR_PAINTFORMAT_RADIAL_GRADIENT = 6,\n+    FT_COLR_PAINTFORMAT_SWEEP_GRADIENT  = 8,\n+    FT_COLR_PAINTFORMAT_GLYPH           = 10,\n+    FT_COLR_PAINTFORMAT_COLR_GLYPH      = 11,\n+    FT_COLR_PAINTFORMAT_TRANSFORM       = 12,\n+    FT_COLR_PAINTFORMAT_TRANSLATE       = 14,\n+    FT_COLR_PAINTFORMAT_SCALE           = 16,\n+    FT_COLR_PAINTFORMAT_ROTATE          = 24,\n+    FT_COLR_PAINTFORMAT_SKEW            = 28,\n+    FT_COLR_PAINTFORMAT_COMPOSITE       = 32,\n+    FT_COLR_PAINT_FORMAT_MAX            = 33,\n+    FT_COLR_PAINTFORMAT_UNSUPPORTED     = 255\n+\n+  } FT_PaintFormat;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ColorStopIterator\n+   *\n+   * @description:\n+   *   This iterator object is needed for @FT_Get_Colorline_Stops.  It keeps\n+   *   state while iterating over the stops of an @FT_ColorLine,\n+   *   representing the `ColorLine` struct of the v1 extensions to 'COLR',\n+   *   see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *\n+   * @fields:\n+   *   num_color_stops ::\n+   *     The number of color stops for the requested glyph index.  Set by\n+   *     @FT_Get_Colorline_Stops.\n+   *\n+   *   current_color_stop ::\n+   *     The current color stop.  Set by @FT_Get_Colorline_Stops.\n+   *\n+   *   p ::\n+   *     An opaque pointer into 'COLR' table data.  The caller must set this\n+   *     to `NULL` before the first call of @FT_Get_Colorline_Stops.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_ColorStopIterator_\n+  {\n+    FT_UInt  num_color_stops;\n+    FT_UInt  current_color_stop;\n+\n+    FT_Byte*  p;\n+\n+  } FT_ColorStopIterator;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ColorIndex\n+   *\n+   * @description:\n+   *   A structure representing a `ColorIndex` value of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *\n+   * @fields:\n+   *   palette_index ::\n+   *     The palette index into a 'CPAL' palette.\n+   *\n+   *   alpha ::\n+   *     Alpha transparency value multiplied with the value from 'CPAL'.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_ColorIndex_\n+  {\n+    FT_UInt16   palette_index;\n+    FT_F2Dot14  alpha;\n+\n+  } FT_ColorIndex;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ColorStop\n+   *\n+   * @description:\n+   *   A structure representing a `ColorStop` value of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *\n+   * @fields:\n+   *   stop_offset ::\n+   *     The stop offset between 0 and 1 along the gradient.\n+   *\n+   *   color ::\n+   *     The color information for this stop, see @FT_ColorIndex.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_ColorStop_\n+  {\n+    FT_F2Dot14     stop_offset;\n+    FT_ColorIndex  color;\n+\n+  } FT_ColorStop;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_PaintExtend\n+   *\n+   * @description:\n+   *   An enumeration representing the 'Extend' mode of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *   It describes how the gradient fill continues at the other boundaries.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef enum  FT_PaintExtend_\n+  {\n+    FT_COLR_PAINT_EXTEND_PAD     = 0,\n+    FT_COLR_PAINT_EXTEND_REPEAT  = 1,\n+    FT_COLR_PAINT_EXTEND_REFLECT = 2\n+\n+  } FT_PaintExtend;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ColorLine\n+   *\n+   * @description:\n+   *   A structure representing a `ColorLine` value of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *   It describes a list of color stops along the defined gradient.\n+   *\n+   * @fields:\n+   *   extend ::\n+   *     The extend mode at the outer boundaries, see @FT_PaintExtend.\n+   *\n+   *   color_stop_iterator ::\n+   *     The @FT_ColorStopIterator used to enumerate and retrieve the\n+   *     actual @FT_ColorStop's.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_ColorLine_\n+  {\n+    FT_PaintExtend        extend;\n+    FT_ColorStopIterator  color_stop_iterator;\n+\n+  } FT_ColorLine;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_Affine23\n+   *\n+   * @description:\n+   *   A structure used to store a 2x3 matrix.  Coefficients are in\n+   *   16.16 fixed-point format.  The computation performed is\n+   *\n+   *   ```\n+   *     x' = x*xx + y*xy + dx\n+   *     y' = x*yx + y*yy + dy\n+   *   ```\n+   *\n+   * @fields:\n+   *   xx ::\n+   *     Matrix coefficient.\n+   *\n+   *   xy ::\n+   *     Matrix coefficient.\n+   *\n+   *   dx ::\n+   *     x translation.\n+   *\n+   *   yx ::\n+   *     Matrix coefficient.\n+   *\n+   *   yy ::\n+   *     Matrix coefficient.\n+   *\n+   *   dy ::\n+   *     y translation.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_Affine_23_\n+  {\n+    FT_Fixed  xx, xy, dx;\n+    FT_Fixed  yx, yy, dy;\n+\n+  } FT_Affine23;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_Composite_Mode\n+   *\n+   * @description:\n+   *   An enumeration listing the 'COLR' v1 composite modes used in\n+   *   @FT_PaintComposite.  For more details on each paint mode, see\n+   *   'https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators'.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef enum  FT_Composite_Mode_\n+  {\n+    FT_COLR_COMPOSITE_CLEAR          = 0,\n+    FT_COLR_COMPOSITE_SRC            = 1,\n+    FT_COLR_COMPOSITE_DEST           = 2,\n+    FT_COLR_COMPOSITE_SRC_OVER       = 3,\n+    FT_COLR_COMPOSITE_DEST_OVER      = 4,\n+    FT_COLR_COMPOSITE_SRC_IN         = 5,\n+    FT_COLR_COMPOSITE_DEST_IN        = 6,\n+    FT_COLR_COMPOSITE_SRC_OUT        = 7,\n+    FT_COLR_COMPOSITE_DEST_OUT       = 8,\n+    FT_COLR_COMPOSITE_SRC_ATOP       = 9,\n+    FT_COLR_COMPOSITE_DEST_ATOP      = 10,\n+    FT_COLR_COMPOSITE_XOR            = 11,\n+    FT_COLR_COMPOSITE_PLUS           = 12,\n+    FT_COLR_COMPOSITE_SCREEN         = 13,\n+    FT_COLR_COMPOSITE_OVERLAY        = 14,\n+    FT_COLR_COMPOSITE_DARKEN         = 15,\n+    FT_COLR_COMPOSITE_LIGHTEN        = 16,\n+    FT_COLR_COMPOSITE_COLOR_DODGE    = 17,\n+    FT_COLR_COMPOSITE_COLOR_BURN     = 18,\n+    FT_COLR_COMPOSITE_HARD_LIGHT     = 19,\n+    FT_COLR_COMPOSITE_SOFT_LIGHT     = 20,\n+    FT_COLR_COMPOSITE_DIFFERENCE     = 21,\n+    FT_COLR_COMPOSITE_EXCLUSION      = 22,\n+    FT_COLR_COMPOSITE_MULTIPLY       = 23,\n+    FT_COLR_COMPOSITE_HSL_HUE        = 24,\n+    FT_COLR_COMPOSITE_HSL_SATURATION = 25,\n+    FT_COLR_COMPOSITE_HSL_COLOR      = 26,\n+    FT_COLR_COMPOSITE_HSL_LUMINOSITY = 27,\n+    FT_COLR_COMPOSITE_MAX            = 28\n+\n+  } FT_Composite_Mode;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_OpaquePaint\n+   *\n+   * @description:\n+   *   A structure representing an offset to a `Paint` value stored in any\n+   *   of the paint tables of a 'COLR' v1 font.  Compare Offset<24> there.\n+   *   When 'COLR' v1 paint tables represented by FreeType objects such as\n+   *   @FT_PaintColrLayers, @FT_PaintComposite, or @FT_PaintTransform\n+   *   reference downstream nested paint tables, we do not immediately\n+   *   retrieve them but encapsulate their location in this type.  Use\n+   *   @FT_Get_Paint to retrieve the actual @FT_COLR_Paint object that\n+   *   describes the details of the respective paint table.\n+   *\n+   * @fields:\n+   *   p ::\n+   *     An internal offset to a Paint table, needs to be set to NULL before\n+   *     passing this struct as an argument to @FT_Get_Paint.\n+   *\n+   *   insert_root_transform ::\n+   *     An internal boolean to track whether an initial root transform is\n+   *     to be provided.  Do not set this value.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_Opaque_Paint_\n+  {\n+    FT_Byte*  p;\n+    FT_Bool   insert_root_transform;\n+  } FT_OpaquePaint;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintColrLayers\n+   *\n+   * @description:\n+   *   A structure representing a `PaintColrLayers` table of a 'COLR' v1\n+   *   font.  This table describes a set of layers that are to be composited\n+   *   with composite mode `FT_COLR_COMPOSITE_SRC_OVER`.  The return value\n+   *   of this function is an @FT_LayerIterator initialized so that it can\n+   *   be used with @FT_Get_Paint_Layers to retrieve the @FT_OpaquePaint\n+   *   objects as references to each layer.\n+   *\n+   * @fields:\n+   *   layer_iterator ::\n+   *     The layer iterator that describes the layers of this paint.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintColrLayers_\n+  {\n+    FT_LayerIterator  layer_iterator;\n+\n+  } FT_PaintColrLayers;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintSolid\n+   *\n+   * @description:\n+   *   A structure representing a `PaintSolid` value of the 'COLR' v1\n+   *   extensions, see 'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.\n+   *   Using a `PaintSolid` value means that the glyph layer filled with\n+   *   this paint is solid-colored and does not contain a gradient.\n+   *\n+   * @fields:\n+   *   color ::\n+   *     The color information for this solid paint, see @FT_ColorIndex.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintSolid_\n+  {\n+    FT_ColorIndex  color;\n+\n+  } FT_PaintSolid;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintLinearGradient\n+   *\n+   * @description:\n+   *   A structure representing a `PaintLinearGradient` value of the 'COLR'\n+   *   v1 extensions, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  The glyph\n+   *   layer filled with this paint is drawn filled with a linear gradient.\n+   *\n+   * @fields:\n+   *   colorline ::\n+   *     The @FT_ColorLine information for this paint, i.e., the list of\n+   *     color stops along the gradient.\n+   *\n+   *   p0 ::\n+   *     The starting point of the gradient definition in font units\n+   *     represented as a 16.16 fixed-point `FT_Vector`.\n+   *\n+   *   p1 ::\n+   *     The end point of the gradient definition in font units\n+   *     represented as a 16.16 fixed-point `FT_Vector`.\n+   *\n+   *   p2 ::\n+   *     Optional point~p2 to rotate the gradient in font units\n+   *     represented as a 16.16 fixed-point `FT_Vector`.\n+   *     Otherwise equal to~p0.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintLinearGradient_\n+  {\n+    FT_ColorLine  colorline;\n+\n+    \/* TODO: Potentially expose those as x0, y0 etc. *\/\n+    FT_Vector  p0;\n+    FT_Vector  p1;\n+    FT_Vector  p2;\n+\n+  } FT_PaintLinearGradient;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintRadialGradient\n+   *\n+   * @description:\n+   *   A structure representing a `PaintRadialGradient` value of the 'COLR'\n+   *   v1 extensions, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  The glyph\n+   *   layer filled with this paint is drawn filled filled with a radial\n+   *   gradient.\n+   *\n+   * @fields:\n+   *   colorline ::\n+   *     The @FT_ColorLine information for this paint, i.e., the list of\n+   *     color stops along the gradient.\n+   *\n+   *   c0 ::\n+   *     The center of the starting point of the radial gradient in font\n+   *     units represented as a 16.16 fixed-point `FT_Vector`.\n+   *\n+   *   r0 ::\n+   *     The radius of the starting circle of the radial gradient in font\n+   *     units represented as a 16.16 fixed-point value.\n+   *\n+   *   c1 ::\n+   *     The center of the end point of the radial gradient in font units\n+   *     represented as a 16.16 fixed-point `FT_Vector`.\n+   *\n+   *   r1 ::\n+   *     The radius of the end circle of the radial gradient in font\n+   *     units represented as a 16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintRadialGradient_\n+  {\n+    FT_ColorLine  colorline;\n+\n+    FT_Vector  c0;\n+    FT_Pos     r0;\n+    FT_Vector  c1;\n+    FT_Pos     r1;\n+\n+  } FT_PaintRadialGradient;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintSweepGradient\n+   *\n+   * @description:\n+   *   A structure representing a `PaintSweepGradient` value of the 'COLR'\n+   *   v1 extensions, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  The glyph\n+   *   layer filled with this paint is drawn filled with a sweep gradient\n+   *   from `start_angle` to `end_angle`.\n+   *\n+   * @fields:\n+   *   colorline ::\n+   *     The @FT_ColorLine information for this paint, i.e., the list of\n+   *     color stops along the gradient.\n+   *\n+   *   center ::\n+   *     The center of the sweep gradient in font units represented as a\n+   *     vector of 16.16 fixed-point values.\n+   *\n+   *   start_angle ::\n+   *     The start angle of the sweep gradient in 16.16 fixed-point\n+   *     format specifying degrees divided by 180.0 (as in the\n+   *     spec).  Multiply by 180.0f to receive degrees value.  Values are\n+   *     given counter-clockwise, starting from the (positive) y~axis.\n+   *\n+   *   end_angle ::\n+   *     The end angle of the sweep gradient in 16.16 fixed-point\n+   *     format specifying degrees divided by 180.0 (as in the\n+   *     spec).  Multiply by 180.0f to receive degrees value.  Values are\n+   *     given counter-clockwise, starting from the (positive) y~axis.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintSweepGradient_\n+  {\n+    FT_ColorLine  colorline;\n+\n+    FT_Vector  center;\n+    FT_Fixed   start_angle;\n+    FT_Fixed   end_angle;\n+\n+  } FT_PaintSweepGradient;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintGlyph\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintGlyph` paint table.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An opaque paint object pointing to a `Paint` table that serves as\n+   *     the fill for the glyph ID.\n+   *\n+   *   glyphID ::\n+   *     The glyph ID from the 'glyf' table, which serves as the contour\n+   *     information that is filled with paint.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintGlyph_\n+  {\n+    FT_OpaquePaint  paint;\n+    FT_UInt         glyphID;\n+\n+  } FT_PaintGlyph;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintColrGlyph\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintColorGlyph` paint table.\n+   *\n+   * @fields:\n+   *   glyphID ::\n+   *     The glyph ID from the `BaseGlyphV1List` table that is drawn for\n+   *     this paint.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintColrGlyph_\n+  {\n+    FT_UInt  glyphID;\n+\n+  } FT_PaintColrGlyph;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintTransform\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintTransform` paint table.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An opaque paint that is subject to being transformed.\n+   *\n+   *   affine ::\n+   *     A 2x3 transformation matrix in @FT_Affine23 format containing\n+   *     16.16 fixed-point values.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintTransform_\n+  {\n+    FT_OpaquePaint  paint;\n+    FT_Affine23     affine;\n+\n+  } FT_PaintTransform;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintTranslate\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintTranslate` paint table.\n+   *   Used for translating downstream paints by a given x and y~delta.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An @FT_OpaquePaint object referencing the paint that is to be\n+   *     rotated.\n+   *\n+   *   dx ::\n+   *     Translation in x~direction in font units represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   *   dy ::\n+   *     Translation in y~direction in font units represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintTranslate_\n+  {\n+    FT_OpaquePaint  paint;\n+\n+    FT_Fixed  dx;\n+    FT_Fixed  dy;\n+\n+  } FT_PaintTranslate;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintScale\n+   *\n+   * @description:\n+   *   A structure representing all of the 'COLR' v1 'PaintScale*' paint\n+   *   tables.  Used for scaling downstream paints by a given x and y~scale,\n+   *   with a given center.  This structure is used for all 'PaintScale*'\n+   *   types that are part of specification; fields of this structure are\n+   *   filled accordingly.  If there is a center, the center values are set,\n+   *   otherwise they are set to the zero coordinate.  If the source font\n+   *   file has 'PaintScaleUniform*' set, the scale values are set\n+   *   accordingly to the same value.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An @FT_OpaquePaint object referencing the paint that is to be\n+   *     scaled.\n+   *\n+   *   scale_x ::\n+   *     Scale factor in x~direction represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   *   scale_y ::\n+   *     Scale factor in y~direction represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   *   center_x ::\n+   *     x~coordinate of center point to scale from represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   *   center_y ::\n+   *     y~coordinate of center point to scale from represented as a\n+   *     16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward-compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintScale_\n+  {\n+    FT_OpaquePaint  paint;\n+\n+    FT_Fixed  scale_x;\n+    FT_Fixed  scale_y;\n+\n+    FT_Fixed  center_x;\n+    FT_Fixed  center_y;\n+\n+  } FT_PaintScale;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintRotate\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintRotate` paint table.  Used\n+   *   for rotating downstream paints with a given center and angle.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An @FT_OpaquePaint object referencing the paint that is to be\n+   *     rotated.\n+   *\n+   *   angle ::\n+   *     The rotation angle that is to be applied in degrees divided by\n+   *     180.0 (as in the spec) represented as a 16.16 fixed-point\n+   *     value.  Multiply by 180.0f to receive degrees value.\n+   *\n+   *   center_x ::\n+   *     The x~coordinate of the pivot point of the rotation in font\n+   *     units) represented as a 16.16 fixed-point value.\n+   *\n+   *   center_y ::\n+   *     The y~coordinate of the pivot point of the rotation in font\n+   *     units represented as a 16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+\n+  typedef struct  FT_PaintRotate_\n+  {\n+    FT_OpaquePaint  paint;\n+\n+    FT_Fixed  angle;\n+\n+    FT_Fixed  center_x;\n+    FT_Fixed  center_y;\n+\n+  } FT_PaintRotate;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintSkew\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 `PaintSkew` paint table.  Used\n+   *   for skewing or shearing downstream paints by a given center and\n+   *   angle.\n+   *\n+   * @fields:\n+   *   paint ::\n+   *     An @FT_OpaquePaint object referencing the paint that is to be\n+   *     skewed.\n+   *\n+   *   x_skew_angle ::\n+   *     The skewing angle in x~direction in degrees divided by 180.0\n+   *     (as in the spec) represented as a 16.16 fixed-point\n+   *     value. Multiply by 180.0f to receive degrees.\n+   *\n+   *   y_skew_angle ::\n+   *     The skewing angle in y~direction in degrees divided by 180.0\n+   *     (as in the spec) represented as a 16.16 fixed-point\n+   *     value.  Multiply by 180.0f to receive degrees.\n+   *\n+   *   center_x ::\n+   *     The x~coordinate of the pivot point of the skew in font units\n+   *     represented as a 16.16 fixed-point value.\n+   *\n+   *   center_y ::\n+   *     The y~coordinate of the pivot point of the skew in font units\n+   *     represented as a 16.16 fixed-point value.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintSkew_\n+  {\n+    FT_OpaquePaint  paint;\n+\n+    FT_Fixed  x_skew_angle;\n+    FT_Fixed  y_skew_angle;\n+\n+    FT_Fixed  center_x;\n+    FT_Fixed  center_y;\n+\n+  } FT_PaintSkew;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_PaintComposite\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR'v1 `PaintComposite` paint table.\n+   *   Used for compositing two paints in a 'COLR' v1 directed acycling\n+   *   graph.\n+   *\n+   * @fields:\n+   *   source_paint ::\n+   *     An @FT_OpaquePaint object referencing the source that is to be\n+   *     composited.\n+   *\n+   *   composite_mode ::\n+   *     An @FT_Composite_Mode enum value determining the composition\n+   *     operation.\n+   *\n+   *   backdrop_paint ::\n+   *     An @FT_OpaquePaint object referencing the backdrop paint that\n+   *     `source_paint` is composited onto.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_PaintComposite_\n+  {\n+    FT_OpaquePaint     source_paint;\n+    FT_Composite_Mode  composite_mode;\n+    FT_OpaquePaint     backdrop_paint;\n+\n+  } FT_PaintComposite;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @union:\n+   *   FT_COLR_Paint\n+   *\n+   * @description:\n+   *   A union object representing format and details of a paint table of a\n+   *   'COLR' v1 font, see\n+   *   'https:\/\/github.com\/googlefonts\/colr-gradients-spec'.  Use\n+   *   @FT_Get_Paint to retrieve a @FT_COLR_Paint for an @FT_OpaquePaint\n+   *   object.\n+   *\n+   * @fields:\n+   *   format ::\n+   *     The gradient format for this Paint structure.\n+   *\n+   *   u ::\n+   *     Union of all paint table types:\n+   *\n+   *       * @FT_PaintColrLayers\n+   *       * @FT_PaintGlyph\n+   *       * @FT_PaintSolid\n+   *       * @FT_PaintLinearGradient\n+   *       * @FT_PaintRadialGradient\n+   *       * @FT_PaintSweepGradient\n+   *       * @FT_PaintTransform\n+   *       * @FT_PaintTranslate\n+   *       * @FT_PaintRotate\n+   *       * @FT_PaintSkew\n+   *       * @FT_PaintComposite\n+   *       * @FT_PaintColrGlyph\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_COLR_Paint_\n+  {\n+    FT_PaintFormat format;\n+\n+    union\n+    {\n+      FT_PaintColrLayers      colr_layers;\n+      FT_PaintGlyph           glyph;\n+      FT_PaintSolid           solid;\n+      FT_PaintLinearGradient  linear_gradient;\n+      FT_PaintRadialGradient  radial_gradient;\n+      FT_PaintSweepGradient   sweep_gradient;\n+      FT_PaintTransform       transform;\n+      FT_PaintTranslate       translate;\n+      FT_PaintScale           scale;\n+      FT_PaintRotate          rotate;\n+      FT_PaintSkew            skew;\n+      FT_PaintComposite       composite;\n+      FT_PaintColrGlyph       colr_glyph;\n+\n+    } u;\n+\n+  } FT_COLR_Paint;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_Color_Root_Transform\n+   *\n+   * @description:\n+   *   An enumeration to specify whether @FT_Get_Color_Glyph_Paint is to\n+   *   return a root transform to configure the client's graphics context\n+   *   matrix.\n+   *\n+   * @values:\n+   *   FT_COLOR_INCLUDE_ROOT_TRANSFORM ::\n+   *     Do include the root transform as the initial @FT_COLR_Paint object.\n+   *\n+   *   FT_COLOR_NO_ROOT_TRANSFORM ::\n+   *     Do not output an initial root transform.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef enum  FT_Color_Root_Transform_\n+  {\n+    FT_COLOR_INCLUDE_ROOT_TRANSFORM,\n+    FT_COLOR_NO_ROOT_TRANSFORM,\n+\n+    FT_COLOR_ROOT_TRANSFORM_MAX\n+\n+  } FT_Color_Root_Transform;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_ClipBox\n+   *\n+   * @description:\n+   *   A structure representing a 'COLR' v1 'ClipBox' table.  'COLR' v1\n+   *   glyphs may optionally define a clip box for aiding allocation or\n+   *   defining a maximum drawable region.  Use @FT_Get_Color_Glyph_ClipBox\n+   *   to retrieve it.\n+   *\n+   * @fields:\n+   *   bottom_left ::\n+   *     The bottom left corner of the clip box as an @FT_Vector with\n+   *     fixed-point coordinates in 26.6 format.\n+   *\n+   *   top_left ::\n+   *     The top left corner of the clip box as an @FT_Vector with\n+   *     fixed-point coordinates in 26.6 format.\n+   *\n+   *   top_right ::\n+   *     The top right corner of the clip box as an @FT_Vector with\n+   *     fixed-point coordinates in 26.6 format.\n+   *\n+   *   bottom_right ::\n+   *     The bottom right corner of the clip box as an @FT_Vector with\n+   *     fixed-point coordinates in 26.6 format.\n+   *\n+   * @since:\n+   *   2.12 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  typedef struct  FT_ClipBox_\n+  {\n+    FT_Vector  bottom_left;\n+    FT_Vector  top_left;\n+    FT_Vector  top_right;\n+    FT_Vector  bottom_right;\n+\n+  } FT_ClipBox;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Color_Glyph_Paint\n+   *\n+   * @description:\n+   *   This is the starting point and interface to color gradient\n+   *   information in a 'COLR' v1 table in OpenType fonts to recursively\n+   *   retrieve the paint tables for the directed acyclic graph of a colored\n+   *   glyph, given a glyph ID.\n+   *\n+   *     https:\/\/github.com\/googlefonts\/colr-gradients-spec\n+   *\n+   *   In a 'COLR' v1 font, each color glyph defines a directed acyclic\n+   *   graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,\n+   *   `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this\n+   *   function and specifying a glyph ID, one retrieves the root paint\n+   *   table for this glyph ID.\n+   *\n+   *   This function allows control whether an initial root transform is\n+   *   returned to configure scaling, transform, and translation correctly\n+   *   on the client's graphics context.  The initial root transform is\n+   *   computed and returned according to the values configured for @FT_Size\n+   *   and @FT_Set_Transform on the @FT_Face object, see below for details\n+   *   of the `root_transform` parameter.  This has implications for a\n+   *   client 'COLR' v1 implementation: When this function returns an\n+   *   initially computed root transform, at the time of executing the\n+   *   @FT_PaintGlyph operation, the contours should be retrieved using\n+   *   @FT_Load_Glyph at unscaled, untransformed size.  This is because the\n+   *   root transform applied to the graphics context will take care of\n+   *   correct scaling.\n+   *\n+   *   Alternatively, to allow hinting of contours, at the time of executing\n+   *   @FT_Load_Glyph, the current graphics context transformation matrix\n+   *   can be decomposed into a scaling matrix and a remainder, and\n+   *   @FT_Load_Glyph can be used to retrieve the contours at scaled size.\n+   *   Care must then be taken to blit or clip to the graphics context with\n+   *   taking this remainder transformation into account.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index for which to retrieve the root paint table.\n+   *\n+   *   root_transform ::\n+   *     Specifies whether an initially computed root is returned by the\n+   *     @FT_PaintTransform operation to account for the activated size\n+   *     (see @FT_Activate_Size) and the configured transform and translate\n+   *     (see @FT_Set_Transform).\n+   *\n+   *     This root transform is returned before nodes of the glyph graph of\n+   *     the font are returned.  Subsequent @FT_COLR_Paint structures\n+   *     contain unscaled and untransformed values.  The inserted root\n+   *     transform enables the client application to apply an initial\n+   *     transform to its graphics context.  When executing subsequent\n+   *     FT_COLR_Paint operations, values from @FT_COLR_Paint operations\n+   *     will ultimately be correctly scaled because of the root transform\n+   *     applied to the graphics context.  Use\n+   *     @FT_COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use\n+   *     @FT_COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be\n+   *     useful when traversing the 'COLR' v1 glyph graph and reaching a\n+   *     @FT_PaintColrGlyph.  When recursing into @FT_PaintColrGlyph and\n+   *     painting that inline, no additional root transform is needed as it\n+   *     has already been applied to the graphics context at the beginning\n+   *     of drawing this glyph.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The @FT_OpaquePaint object that references the actual paint table.\n+   *\n+   *     The respective actual @FT_COLR_Paint object is retrieved via\n+   *     @FT_Get_Paint.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If no color glyph is found, or the root\n+   *   paint could not be retrieved, value~0 gets returned.  In case of an\n+   *   error, value~0 is returned also.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Color_Glyph_Paint( FT_Face                  face,\n+                            FT_UInt                  base_glyph,\n+                            FT_Color_Root_Transform  root_transform,\n+                            FT_OpaquePaint*          paint );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Color_Glyph_ClipBox\n+   *\n+   * @description:\n+   *   Search for a 'COLR' v1 clip box for the specified `base_glyph` and\n+   *   fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information\n+   *   if one is found.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index for which to retrieve the clip box.\n+   *\n+   * @output:\n+   *   clip_box ::\n+   *     The clip box for the requested `base_glyph` if one is found.  The\n+   *     clip box is computed taking scale and transformations configured on\n+   *     the @FT_Face into account.  @FT_ClipBox contains @FT_Vector values\n+   *     in 26.6 format.\n+   *\n+   * @return:\n+   *   Value~1 if a clip box is found.  If no clip box is found or an error\n+   *   occured, value~0 is returned.\n+   *\n+   * @note:\n+   *   To retrieve the clip box in font units, reset scale to units-per-em\n+   *   and remove transforms configured using @FT_Set_Transform.\n+   *\n+   * @since:\n+   *   2.12 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Color_Glyph_ClipBox( FT_Face      face,\n+                              FT_UInt      base_glyph,\n+                              FT_ClipBox*  clip_box );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Paint_Layers\n+   *\n+   * @description:\n+   *   Access the layers of a `PaintColrLayers` table.\n+   *\n+   *   If the root paint of a color glyph, or a nested paint of a 'COLR'\n+   *   glyph is a `PaintColrLayers` table, this function retrieves the\n+   *   layers of the `PaintColrLayers` table.\n+   *\n+   *   The @FT_PaintColrLayers object contains an @FT_LayerIterator, which\n+   *   is used here to iterate over the layers.  Each layer is returned as\n+   *   an @FT_OpaquePaint object, which then can be used with @FT_Get_Paint\n+   *   to retrieve the actual paint object.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     The @FT_LayerIterator from an @FT_PaintColrLayers object, for which\n+   *     the layers are to be retrieved.  The internal state of the iterator\n+   *     is incremented after one call to this function for retrieving one\n+   *     layer.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The @FT_OpaquePaint object that references the actual paint table.\n+   *     The respective actual @FT_COLR_Paint object is retrieved via\n+   *     @FT_Get_Paint.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  Value~0 gets returned when the paint\n+   *   object can not be retrieved or any other error occurs.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Paint_Layers( FT_Face            face,\n+                       FT_LayerIterator*  iterator,\n+                       FT_OpaquePaint*    paint );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Get_Colorline_Stops\n+   *\n+   * @description:\n+   *   This is an interface to color gradient information in a 'COLR' v1\n+   *   table in OpenType fonts to iteratively retrieve the gradient and\n+   *   solid fill information for colored glyph layers for a specified glyph\n+   *   ID.\n+   *\n+   *     https:\/\/github.com\/googlefonts\/colr-gradients-spec\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     The retrieved @FT_ColorStopIterator, configured on an @FT_ColorLine,\n+   *     which in turn got retrieved via paint information in\n+   *     @FT_PaintLinearGradient or @FT_PaintRadialGradient.\n+   *\n+   * @output:\n+   *   color_stop ::\n+   *     Color index and alpha value for the retrieved color stop.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If there are no more color stops,\n+   *   value~0 gets returned.  In case of an error, value~0 is returned\n+   *   also.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Colorline_Stops( FT_Face                face,\n+                          FT_ColorStop*          color_stop,\n+                          FT_ColorStopIterator*  iterator );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *  FT_Get_Paint\n+   *\n+   * @description:\n+   *   Access the details of a paint using an @FT_OpaquePaint opaque paint\n+   *   object, which internally stores the offset to the respective `Paint`\n+   *   object in the 'COLR' table.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   opaque_paint ::\n+   *     The opaque paint object for which the underlying @FT_COLR_Paint\n+   *     data is to be retrieved.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The specific @FT_COLR_Paint object containing information coming\n+   *     from one of the font's `Paint*` tables.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  Value~0 if no details can be found for\n+   *   this paint or any other error occured.\n+   *\n+   * @since:\n+   *   2.11 -- **currently experimental only!**  There might be changes\n+   *   without retaining backward compatibility of both the API and ABI.\n+   *\n+   *\/\n+  FT_EXPORT( FT_Bool )\n+  FT_Get_Paint( FT_Face         face,\n+                FT_OpaquePaint  opaque_paint,\n+                FT_COLR_Paint*  paint );\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftcolor.h","additions":1406,"deletions":1,"binary":false,"changes":1407,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2022 by\n@@ -56,4 +56,4 @@\n-   *   (experimental), @darkening-parameters (experimental), @warping\n-   *   (experimental), @glyph-to-script-map (experimental), @fallback-script\n-   *   (experimental), and @default-script (experimental), as documented in\n-   *   the @properties section.\n+   *   (experimental), @darkening-parameters (experimental),\n+   *   @glyph-to-script-map (experimental), @fallback-script (experimental),\n+   *   and @default-script (experimental), as documented in the @properties\n+   *   section.\n@@ -87,1 +87,1 @@\n-   *   **Hinting and antialiasing principles of the new engine**\n+   *   **Hinting and anti-aliasing principles of the new engine**\n@@ -91,1 +91,1 @@\n-   *   amount of antialiasing applied to them, while placing vertical\n+   *   amount of anti-aliasing applied to them, while placing vertical\n@@ -95,1 +95,1 @@\n-   *   'antialiasing' means that stems are not positioned exactly on pixel\n+   *   'anti-aliasing' means that stems are not positioned exactly on pixel\n@@ -111,1 +111,1 @@\n-   *   One of the reasons to not hint horizontally is antialiasing for LCD\n+   *   One of the reasons to not hint horizontally is anti-aliasing for LCD\n@@ -119,1 +119,1 @@\n-   *   designs.  Even when the rasterizer uses greyscale antialiasing instead\n+   *   designs.  Even when the rasterizer uses greyscale anti-aliasing instead\n@@ -215,4 +215,1 @@\n-   *   and @FT_Property_Get.  The following lists the available properties\n-   *   together with the necessary macros and structures.\n-   *\n-   *   The TrueType driver's module name is 'truetype'.\n+   *   and @FT_Property_Get.\n@@ -220,2 +217,3 @@\n-   *   A single property @interpreter-version is available, as documented in\n-   *   the @properties section.\n+   *   The TrueType driver's module name is 'truetype'; a single property\n+   *   @interpreter-version is available, as documented in the @properties\n+   *   section.\n@@ -223,2 +221,2 @@\n-   *   We start with a list of definitions, kindly provided by Greg\n-   *   Hitchcock.\n+   *   To help understand the differences between interpreter versions, we\n+   *   introduce a list of definitions, kindly provided by Greg Hitchcock.\n@@ -303,0 +301,25 @@\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   ot_svg_driver\n+   *\n+   * @title:\n+   *   The SVG driver\n+   *\n+   * @abstract:\n+   *   Controlling the external rendering of OT-SVG glyphs.\n+   *\n+   * @description:\n+   *   By default, FreeType can only load the 'SVG~' table of OpenType fonts\n+   *   if configuration macro `FT_CONFIG_OPTION_SVG` is defined.  To make it\n+   *   render SVG glyphs, an external SVG rendering library is needed.  All\n+   *   details on the interface between FreeType and the external library\n+   *   via function hooks can be found in section @svg_fonts.\n+   *\n+   *   The OT-SVG driver's module name is 'ot-svg'; it supports a single\n+   *   property called @svg-hooks, documented below in the @properties\n+   *   section.\n+   *\n+   *\/\n+\n+\n@@ -365,6 +388,2 @@\n-   *   For the 'cff' module, the default engine is 'freetype' if\n-   *   `CFF_CONFIG_OPTION_OLD_ENGINE` is defined, and 'adobe' otherwise.\n-   *\n-   *   For both the 'type1' and 't1cid' modules, the default engine is\n-   *   'freetype' if `T1_CONFIG_OPTION_OLD_ENGINE` is defined, and 'adobe'\n-   *   otherwise.\n+   *   For the 'cff' module, the default engine is 'adobe'.  For both the\n+   *   'type1' and 't1cid' modules, the default engine is 'adobe', too.\n@@ -805,0 +824,34 @@\n+  \/**************************************************************************\n+   *\n+   * @property:\n+   *   svg-hooks\n+   *\n+   * @description:\n+   *   Set up the interface between FreeType and an extern SVG rendering\n+   *   library like 'librsvg'.  All details on the function hooks can be\n+   *   found in section @svg_fonts.\n+   *\n+   * @example:\n+   *   The following example code expects that the four hook functions\n+   *   `svg_*` are defined elsewhere.  Error handling is omitted, too.\n+   *\n+   *   ```\n+   *     FT_Library  library;\n+   *     SVG_RendererHooks  hooks = {\n+   *                          (SVG_Lib_Init_Func)svg_init,\n+   *                          (SVG_Lib_Free_Func)svg_free,\n+   *                          (SVG_Lib_Render_Func)svg_render,\n+   *                          (SVG_Lib_Preset_Slot_Func)svg_preset_slot };\n+   *\n+   *\n+   *     FT_Init_FreeType( &library );\n+   *\n+   *     FT_Property_Set( library, \"ot-svg\",\n+   *                               \"svg-hooks\", &hooks );\n+   *   ```\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+\n+\n@@ -1169,1 +1222,1 @@\n-   *   **Experimental only**\n+   *   **Obsolete**\n@@ -1171,3 +1224,3 @@\n-   *   If FreeType gets compiled with option `AF_CONFIG_OPTION_USE_WARPER` to\n-   *   activate the warp hinting code in the auto-hinter, this property\n-   *   switches warping on and off.\n+   *   This property was always experimental and probably never worked\n+   *   correctly.  It was entirely removed from the FreeType~2 sources.  This\n+   *   entry is only here for historical reference.\n@@ -1175,2 +1228,2 @@\n-   *   Warping only works in 'normal' auto-hinting mode replacing it.  The\n-   *   idea of the code is to slightly scale and shift a glyph along the\n+   *   Warping only worked in 'normal' auto-hinting mode replacing it.  The\n+   *   idea of the code was to slightly scale and shift a glyph along the\n@@ -1178,1 +1231,1 @@\n-   *   much of its segments are aligned (more or less) to the grid.  To find\n+   *   much of its segments were aligned (more or less) to the grid.  To find\n@@ -1180,31 +1233,1 @@\n-   *   combinations are tried and scored.\n-   *\n-   *   By default, warping is off.\n-   *\n-   * @note:\n-   *   This property can be used with @FT_Property_Get also.\n-   *\n-   *   This property can be set via the `FREETYPE_PROPERTIES` environment\n-   *   variable (using values 1 and 0 for 'on' and 'off', respectively).\n-   *\n-   *   The warping code can also change advance widths.  Have a look at the\n-   *   `lsb_delta` and `rsb_delta` fields in the @FT_GlyphSlotRec structure\n-   *   for details on improving inter-glyph distances while rendering.\n-   *\n-   *   Since warping is a global property of the auto-hinter it is best to\n-   *   change its value before rendering any face.  Otherwise, you should\n-   *   reload all faces that get auto-hinted in 'normal' hinting mode.\n-   *\n-   * @example:\n-   *   This example shows how to switch on warping (omitting the error\n-   *   handling).\n-   *\n-   *   ```\n-   *     FT_Library  library;\n-   *     FT_Bool     warping = 1;\n-   *\n-   *\n-   *     FT_Init_FreeType( &library );\n-   *\n-   *     FT_Property_Set( library, \"autofitter\", \"warping\", &warping );\n-   *   ```\n+   *   combinations were tried and scored.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftdriver.h","additions":85,"deletions":62,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n@@ -104,0 +104,2 @@\n+  FT_ERRORDEF_( Invalid_SVG_Document,                        0x18,\n+                \"invalid SVG document\" )\n@@ -237,0 +239,2 @@\n+  FT_ERRORDEF_( Missing_SVG_Hooks,                           0x9E,\n+                \"SVG hooks have not been set\" )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fterrdef.h","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -284,0 +284,2 @@\n+  \/* *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fterrors.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftfntfmt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftgasp.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -129,1 +129,1 @@\n-   *   sub-class of @FT_Glyph, and a pointer to @FT_BitmapGlyphRec.\n+   *   'sub-class' of @FT_Glyph, and a pointer to @FT_BitmapGlyphRec.\n@@ -145,1 +145,1 @@\n-   *     The root @FT_Glyph fields.\n+   *     The root fields of @FT_Glyph.\n@@ -184,1 +184,1 @@\n-   *   sub-class of @FT_Glyph, and a pointer to @FT_OutlineGlyphRec.\n+   *   'sub-class' of @FT_Glyph, and a pointer to @FT_OutlineGlyphRec.\n@@ -225,0 +225,86 @@\n+  \/**************************************************************************\n+   *\n+   * @type:\n+   *   FT_SvgGlyph\n+   *\n+   * @description:\n+   *   A handle to an object used to model an SVG glyph.  This is a\n+   *   'sub-class' of @FT_Glyph, and a pointer to @FT_SvgGlyphRec.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef struct FT_SvgGlyphRec_*  FT_SvgGlyph;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_SvgGlyphRec\n+   *\n+   * @description:\n+   *   A structure used for OT-SVG glyphs.  This is a 'sub-class' of\n+   *   @FT_GlyphRec.\n+   *\n+   * @fields:\n+   *   root ::\n+   *     The root @FT_GlyphRec fields.\n+   *\n+   *   svg_document ::\n+   *     A pointer to the SVG document.\n+   *\n+   *   svg_document_length ::\n+   *     The length of `svg_document`.\n+   *\n+   *   glyph_index ::\n+   *     The index of the glyph to be rendered.\n+   *\n+   *   metrics ::\n+   *     A metrics object storing the size information.\n+   *\n+   *   units_per_EM ::\n+   *     The size of the EM square.\n+   *\n+   *   start_glyph_id ::\n+   *     The first glyph ID in the glyph range covered by this document.\n+   *\n+   *   end_glyph_id ::\n+   *     The last glyph ID in the glyph range covered by this document.\n+   *\n+   *   transform ::\n+   *     A 2x2 transformation matrix to apply to the glyph while rendering\n+   *     it.\n+   *\n+   *   delta ::\n+   *     Translation to apply to the glyph while rendering.\n+   *\n+   * @note:\n+   *   The Glyph Management API requires @FT_Glyph or its 'sub-class' to have\n+   *   all the information needed to completely define the glyph's rendering.\n+   *   Outline-based glyphs can directly apply transformations to the outline\n+   *   but this is not possible for an SVG document that hasn't been parsed.\n+   *   Therefore, the transformation is stored along with the document.  In\n+   *   the absence of a 'ViewBox' or 'Width'\/'Height' attribute, the size of\n+   *   the ViewPort should be assumed to be 'units_per_EM'.\n+   *\/\n+  typedef struct  FT_SvgGlyphRec_\n+  {\n+    FT_GlyphRec  root;\n+\n+    FT_Byte*  svg_document;\n+    FT_ULong  svg_document_length;\n+\n+    FT_UInt  glyph_index;\n+\n+    FT_Size_Metrics  metrics;\n+    FT_UShort        units_per_EM;\n+\n+    FT_UShort  start_glyph_id;\n+    FT_UShort  end_glyph_id;\n+\n+    FT_Matrix  transform;\n+    FT_Vector  delta;\n+\n+  } FT_SvgGlyphRec;\n+\n+\n@@ -340,3 +426,3 @@\n-  FT_Glyph_Transform( FT_Glyph    glyph,\n-                      FT_Matrix*  matrix,\n-                      FT_Vector*  delta );\n+  FT_Glyph_Transform( FT_Glyph          glyph,\n+                      const FT_Matrix*  matrix,\n+                      const FT_Vector*  delta );\n@@ -501,1 +587,1 @@\n-   *   The first parameter is a pointer to an @FT_Glyph handle, that will be\n+   *   The first parameter is a pointer to an @FT_Glyph handle that will be\n@@ -503,1 +589,1 @@\n-   *   you would use (omitting error handling):\n+   *   you would do something like the following (omitting error handling).\n@@ -520,1 +606,1 @@\n-   *                                     0, 1 );\n+   *                                   0, 1 );\n@@ -535,1 +621,1 @@\n-   *   Here is another example, again without error handling:\n+   *   Here is another example, again without error handling.\n@@ -572,4 +658,4 @@\n-  FT_Glyph_To_Bitmap( FT_Glyph*       the_glyph,\n-                      FT_Render_Mode  render_mode,\n-                      FT_Vector*      origin,\n-                      FT_Bool         destroy );\n+  FT_Glyph_To_Bitmap( FT_Glyph*         the_glyph,\n+                      FT_Render_Mode    render_mode,\n+                      const FT_Vector*  origin,\n+                      FT_Bool           destroy );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftglyph.h","additions":101,"deletions":15,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftgzip.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -31,5 +31,0 @@\n-  \/* STANDALONE_ is from ftgrays.c *\/\n-#ifndef STANDALONE_\n-#endif\n-\n-\n@@ -204,0 +199,5 @@\n+  \/* *\/\n+\n+  \/* For debugging, the @FT_Pixel_Mode enumeration must stay in sync *\/\n+  \/* with the `pixel_modes` array in file `ftobjs.c`.                *\/\n+\n@@ -404,5 +404,5 @@\n-   *     This flag indicates that this outline contains overlapping contrours\n-   *     and the anti-aliased renderer should perform oversampling to\n-   *     mitigate possible artifacts.  This flag should _not_ be set for\n-   *     well designed glyphs without overlaps because it quadruples the\n-   *     rendering time.\n+   *     [Since 2.10.3] This flag indicates that this outline contains\n+   *     overlapping contours and the anti-aliased renderer should perform\n+   *     oversampling to mitigate possible artifacts.  This flag should _not_\n+   *     be set for well designed glyphs without overlaps because it quadruples\n+   *     the rendering time.\n@@ -698,5 +698,7 @@\n-#define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )  \\\n-          value = ( ( (unsigned long)_x1 << 24 ) | \\\n-                    ( (unsigned long)_x2 << 16 ) | \\\n-                    ( (unsigned long)_x3 << 8  ) | \\\n-                      (unsigned long)_x4         )\n+\n+#define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )                         \\\n+          value = ( ( FT_STATIC_BYTE_CAST( unsigned long, _x1 ) << 24 ) | \\\n+                    ( FT_STATIC_BYTE_CAST( unsigned long, _x2 ) << 16 ) | \\\n+                    ( FT_STATIC_BYTE_CAST( unsigned long, _x3 ) << 8  ) | \\\n+                      FT_STATIC_BYTE_CAST( unsigned long, _x4 )         )\n+\n@@ -742,0 +744,4 @@\n+   *\n+   *   FT_GLYPH_FORMAT_SVG ::\n+   *     [Since 2.12] The glyph is represented by an SVG document in the\n+   *     'SVG~' table.\n@@ -750,1 +756,2 @@\n-    FT_IMAGE_TAG( FT_GLYPH_FORMAT_PLOTTER,   'p', 'l', 'o', 't' )\n+    FT_IMAGE_TAG( FT_GLYPH_FORMAT_PLOTTER,   'p', 'l', 'o', 't' ),\n+    FT_IMAGE_TAG( FT_GLYPH_FORMAT_SVG,       'S', 'V', 'G', ' ' )\n@@ -775,11 +782,0 @@\n-  \/**************************************************************************\n-   *\n-   * A raster is a scan converter, in charge of rendering an outline into a\n-   * bitmap.  This section contains the public API for rasters.\n-   *\n-   * Note that in FreeType 2, all rasters are now encapsulated within\n-   * specific modules called 'renderers'.  See `ftrender.h` for more details\n-   * on renderers.\n-   *\n-   *\/\n-\n@@ -799,1 +795,21 @@\n-   *   This section contains technical definitions.\n+   *   A raster or a rasterizer is a scan converter in charge of producing a\n+   *   pixel coverage bitmap that can be used as an alpha channel when\n+   *   compositing a glyph with a background.  FreeType comes with two\n+   *   rasterizers: bilevel `raster1` and anti-aliased `smooth` are two\n+   *   separate modules.  They are usually called from the high-level\n+   *   @FT_Load_Glyph or @FT_Render_Glyph functions and produce the entire\n+   *   coverage bitmap at once, while staying largely invisible to users.\n+   *\n+   *   Instead of working with complete coverage bitmaps, it is also possible\n+   *   to intercept consecutive pixel runs on the same scanline with the same\n+   *   coverage, called _spans_, and process them individually.  Only the\n+   *   `smooth` rasterizer permits this when calling @FT_Outline_Render with\n+   *   @FT_Raster_Params as described below.\n+   *\n+   *   Working with either complete bitmaps or spans it is important to think\n+   *   of them as colorless coverage objects suitable as alpha channels to\n+   *   blend arbitrary colors with a background.  For best results, it is\n+   *   recommended to use gamma correction, too.\n+   *\n+   *   This section also describes the public API needed to set up alternative\n+   *   @FT_Renderer modules.\n@@ -802,1 +818,0 @@\n-   *   FT_Raster\n@@ -805,1 +820,0 @@\n-   *\n@@ -809,0 +823,1 @@\n+   *   FT_Raster\n@@ -819,12 +834,0 @@\n-  \/**************************************************************************\n-   *\n-   * @type:\n-   *   FT_Raster\n-   *\n-   * @description:\n-   *   An opaque handle (pointer) to a raster object.  Each object can be\n-   *   used independently to convert an outline into a bitmap or pixmap.\n-   *\/\n-  typedef struct FT_RasterRec_*  FT_Raster;\n-\n-\n@@ -837,2 +840,2 @@\n-   *   A structure used to model a single span of gray pixels when rendering\n-   *   an anti-aliased bitmap.\n+   *   A structure to model a single span of consecutive pixels when\n+   *   rendering an anti-aliased bitmap.\n@@ -855,2 +858,2 @@\n-   *   The coverage value is always between 0 and 255.  If you want less gray\n-   *   values, the callback function has to reduce them.\n+   *   The anti-aliased rasterizer produces coverage values from 0 to 255,\n+   *   this is, from completely transparent to completely opaque.\n@@ -874,2 +877,2 @@\n-   *   to let client applications draw themselves the gray pixel spans on\n-   *   each scan line.\n+   *   to let client applications draw themselves the pixel spans on each\n+   *   scan line.\n@@ -891,2 +894,2 @@\n-   *   This callback allows client applications to directly render the gray\n-   *   spans of the anti-aliased bitmap to any kind of surfaces.\n+   *   This callback allows client applications to directly render the spans\n+   *   of the anti-aliased bitmap to any kind of surfaces.\n@@ -895,1 +898,2 @@\n-   *   background bitmap, and even perform translucency.\n+   *   background bitmap using alpha compositing.  It can also be used for\n+   *   oversampling and averaging.\n@@ -965,0 +969,5 @@\n+   *\n+   *   FT_RASTER_FLAG_SDF ::\n+   *     This flag is set to indicate that a signed distance field glyph\n+   *     image should be generated.  This is only used while rendering with\n+   *     the @FT_RENDER_MODE_SDF render mode.\n@@ -970,0 +979,1 @@\n+#define FT_RASTER_FLAG_SDF      0x8\n@@ -1050,0 +1060,17 @@\n+  \/**************************************************************************\n+   *\n+   * @type:\n+   *   FT_Raster\n+   *\n+   * @description:\n+   *   An opaque handle (pointer) to a raster object.  Each object can be\n+   *   used independently to convert an outline into a bitmap or pixmap.\n+   *\n+   * @note:\n+   *   In FreeType 2, all rasters are now encapsulated within specific\n+   *   @FT_Renderer modules and only used in their context.\n+   *\n+   *\/\n+  typedef struct FT_RasterRec_*  FT_Raster;\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftimage.h","additions":79,"deletions":52,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n@@ -216,3 +216,8 @@\n-   *   before accessing its data.  This is necessary because, in certain\n-   *   formats like TrueType, the metrics are stored in a different place\n-   *   from the glyph images proper.\n+   *   before accessing its data.  This allows for handling font types such\n+   *   as PCL~XL Format~1, Class~2 downloaded TrueType fonts, where the glyph\n+   *   metrics (`hmtx` and `vmtx` tables) are permitted to be omitted from\n+   *   the font, and the relevant metrics included in the header of the glyph\n+   *   outline data.  Importantly, this is not intended to allow custom glyph\n+   *   metrics (for example, Postscript Metrics dictionaries), because that\n+   *   conflicts with the requirements of outline hinting.  Such custom\n+   *   metrics must be handled separately, by the calling application.\n@@ -238,1 +243,1 @@\n-   *     The replacement glyph metrics in font units.\n+   *     The glyph metrics in font units.\n@@ -267,1 +272,1 @@\n-   *     provide overriding glyph metrics.\n+   *     require it.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftincrem.h","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n@@ -58,1 +58,1 @@\n-   *   subpixels coverages unfiltered can create severe color fringes\n+   *   subpixel coverages unfiltered can create severe color fringes\n@@ -61,4 +61,3 @@\n-   *   equally.\n-   *\n-   *   A good 5-tap FIR filter should be applied to subpixel coverages\n-   *   regardless of pixel boundaries and should have these properties:\n+   *   evenly.  Therefore, an equalizing 5-tap FIR filter should be applied\n+   *   to subpixel coverages regardless of pixel boundaries and should have\n+   *   these properties:\n@@ -87,1 +86,1 @@\n-   *   center.  In this case, each color channel is then rendered separately\n+   *   center.  In this case, each color channel can be rendered separately\n@@ -104,3 +103,3 @@\n-   *   As a result of ClearType filtering or Harmony rendering, the\n-   *   dimensions of LCD bitmaps can be either wider or taller than the\n-   *   dimensions of the corresponding outline with regard to the pixel grid.\n+   *   As a result of ClearType filtering or Harmony shifts, the resulting\n+   *   dimensions of LCD bitmaps can be slightly wider or taller than the\n+   *   dimensions the original outline with regard to the pixel grid.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftlcdfil.h","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftlist.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/****************************************************************************\n+ *\n+ * ftlogging.h\n+ *\n+ *   Additional debugging APIs.\n+ *\n+ * Copyright (C) 2020-2022 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef FTLOGGING_H_\n+#define FTLOGGING_H_\n+\n+\n+#include <ft2build.h>\n+#include FT_CONFIG_CONFIG_H\n+\n+\n+FT_BEGIN_HEADER\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   debugging_apis\n+   *\n+   * @title:\n+   *   External Debugging APIs\n+   *\n+   * @abstract:\n+   *   Public APIs to control the `FT_DEBUG_LOGGING` macro.\n+   *\n+   * @description:\n+   *   This section contains the declarations of public functions that\n+   *   enables fine control of what the `FT_DEBUG_LOGGING` macro outputs.\n+   *\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Trace_Set_Level\n+   *\n+   * @description:\n+   *   Change the levels of tracing components of FreeType at run time.\n+   *\n+   * @input:\n+   *   tracing_level ::\n+   *     New tracing value.\n+   *\n+   * @example:\n+   *   The following call makes FreeType trace everything but the 'memory'\n+   *   component.\n+   *\n+   *   ```\n+   *   FT_Trace_Set_Level( \"any:7 memory:0 );\n+   *   ```\n+   *\n+   * @note:\n+   *   This function does nothing if compilation option `FT_DEBUG_LOGGING`\n+   *   isn't set.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Trace_Set_Level( const char*  tracing_level );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Trace_Set_Default_Level\n+   *\n+   * @description:\n+   *   Reset tracing value of FreeType's components to the default value\n+   *   (i.e., to the value of the `FT2_DEBUG` environment value or to NULL\n+   *   if `FT2_DEBUG` is not set).\n+   *\n+   * @note:\n+   *   This function does nothing if compilation option `FT_DEBUG_LOGGING`\n+   *   isn't set.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Trace_Set_Default_Level( void );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   FT_Custom_Log_Handler\n+   *\n+   * @description:\n+   *   A function typedef that is used to handle the logging of tracing and\n+   *   debug messages on a file system.\n+   *\n+   * @input:\n+   *   ft_component ::\n+   *     The name of `FT_COMPONENT` from which the current debug or error\n+   *     message is produced.\n+   *\n+   *   fmt ::\n+   *     Actual debug or tracing message.\n+   *\n+   *   args::\n+   *     Arguments of debug or tracing messages.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  typedef void\n+  (*FT_Custom_Log_Handler)( const char*  ft_component,\n+                            const char*  fmt,\n+                            va_list      args );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Set_Log_Handler\n+   *\n+   * @description:\n+   *   A function to set a custom log handler.\n+   *\n+   * @input:\n+   *   handler ::\n+   *     New logging function.\n+   *\n+   * @note:\n+   *   This function does nothing if compilation option `FT_DEBUG_LOGGING`\n+   *   isn't set.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Set_Log_Handler( FT_Custom_Log_Handler  handler );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @function:\n+   *   FT_Set_Default_Log_Handler\n+   *\n+   * @description:\n+   *   A function to undo the effect of @FT_Set_Log_Handler, resetting the\n+   *   log handler to FreeType's built-in version.\n+   *\n+   * @note:\n+   *   This function does nothing if compilation option `FT_DEBUG_LOGGING`\n+   *   isn't set.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+  FT_EXPORT( void )\n+  FT_Set_Default_Log_Handler( void );\n+\n+  \/* *\/\n+\n+\n+FT_END_HEADER\n+\n+#endif \/* FTLOGGING_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftlogging.h","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmac.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -50,0 +50,3 @@\n+   *   For Adobe MM fonts, macro @FT_IS_SFNT returns false.  For GX and\n+   *   OpenType variation fonts, it returns true.\n+   *\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmm.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -48,2 +48,4 @@\n-   *   Modules can be added, upgraded, and removed at runtime.  Additionally,\n-   *   some module properties can be controlled also.\n+   *   Internal and external modules can be added, upgraded, and removed at\n+   *   runtime.  For example, an alternative renderer or proprietary font\n+   *   driver can be registered and prioritized.  Additionally, some module\n+   *   properties can also be controlled.\n@@ -51,1 +53,1 @@\n-   *   Here is a list of possible values of the `module_name` field in the\n+   *   Here is a list of existing values of the `module_name` field in the\n@@ -89,0 +91,1 @@\n+   *   FT_FACE_DRIVER_NAME\n@@ -331,0 +334,21 @@\n+  \/**************************************************************************\n+   *\n+   * @macro:\n+   *   FT_FACE_DRIVER_NAME\n+   *\n+   * @description:\n+   *   A macro that retrieves the name of a font driver from a face object.\n+   *\n+   * @note:\n+   *   The font driver name is a valid `module_name` for @FT_Property_Set\n+   *   and @FT_Property_Get.  This is not the same as @FT_Get_Font_Format.\n+   *\n+   * @since:\n+   *   2.11\n+   *\n+   *\/\n+#define FT_FACE_DRIVER_NAME( face )                                     \\\n+          ( ( *FT_REINTERPRET_CAST( FT_Module_Class**,                  \\\n+                                    ( face )->driver ) )->module_name )\n+\n+\n@@ -488,2 +512,1 @@\n-   *                         cff:no-stem-darkening=0 \\\n-   *                         autofitter:warping=1\n+   *                         cff:no-stem-darkening=0\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmodapi.h","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n@@ -174,0 +174,1 @@\n+  FT_MODERRDEF( Sdf,      0x1700, \"Signed distance field raster module\" )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftmoderr.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -112,5 +112,7 @@\n-   *   A contour that contains a single point only is represented by a 'move\n-   *   to' operation followed by 'line to' to the same point.  In most cases,\n-   *   it is best to filter this out before using the outline for stroking\n-   *   purposes (otherwise it would result in a visible dot when round caps\n-   *   are used).\n+   *   Degenerate contours, segments, and Bezier arcs may be reported.  In\n+   *   most cases, it is best to filter these out before using the outline\n+   *   for stroking or other path modification purposes (which may cause\n+   *   degenerate segments to become non-degenrate and visible, like when\n+   *   stroke caps are used or the path is otherwise outset).  Some glyph\n+   *   outlines may contain deliberate degenerate single points for mark\n+   *   attachement.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftoutln.h","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2022 by\n@@ -115,0 +115,15 @@\n+  \/**************************************************************************\n+   *\n+   * @enum:\n+   *   FT_PARAM_TAG_IGNORE_SBIX\n+   *\n+   * @description:\n+   *   A tag for @FT_Parameter to make @FT_Open_Face ignore an 'sbix' table\n+   *   while loading a font.  Use this if @FT_FACE_FLAG_SBIX is set and you\n+   *   want to access the outline glyphs in the font.\n+   *\n+   *\/\n+#define FT_PARAM_TAG_IGNORE_SBIX \\\n+          FT_MAKE_TAG( 'i', 's', 'b', 'x' )\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftparams.h","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftrender.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsizes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsnames.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftstroke.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsynth.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ftsystem.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fttrigon.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -416,1 +416,1 @@\n-    FT_Int          length;\n+    FT_UInt         length;\n@@ -482,1 +482,1 @@\n-   *   tables into an unsigned long, to be used within FreeType.\n+   *   tables into an `FT_Tag` type, to be used within FreeType.\n@@ -488,6 +488,5 @@\n-#define FT_MAKE_TAG( _x1, _x2, _x3, _x4 ) \\\n-          (FT_Tag)                        \\\n-          ( ( (FT_ULong)_x1 << 24 ) |     \\\n-            ( (FT_ULong)_x2 << 16 ) |     \\\n-            ( (FT_ULong)_x3 <<  8 ) |     \\\n-              (FT_ULong)_x4         )\n+#define FT_MAKE_TAG( _x1, _x2, _x3, _x4 )                  \\\n+          ( ( FT_STATIC_BYTE_CAST( FT_Tag, _x1 ) << 24 ) | \\\n+            ( FT_STATIC_BYTE_CAST( FT_Tag, _x2 ) << 16 ) | \\\n+            ( FT_STATIC_BYTE_CAST( FT_Tag, _x3 ) <<  8 ) | \\\n+              FT_STATIC_BYTE_CAST( FT_Tag, _x4 )         )\n@@ -591,1 +590,1 @@\n-#define FT_BOOL( x )  ( (FT_Bool)( (x) != 0 ) )\n+#define FT_BOOL( x )         FT_STATIC_CAST( FT_Bool, (x) != 0 )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/fttypes.h","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/autohint.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/cffotypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/cfftypes.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2020 by\n+ * Copyright (C) 2020-2022 by\n@@ -74,1 +74,7 @@\n-#ifdef _WIN64\n+#ifdef __UINTPTR_TYPE__\n+  \/*\n+   * GCC and Clang both provide a `__UINTPTR_TYPE__` that can be used to\n+   * avoid a dependency on `stdint.h`.\n+   *\/\n+#  define FT_UINT_TO_POINTER( x )  (void *)(__UINTPTR_TYPE__)(x)\n+#elif defined( _WIN64 )\n@@ -77,1 +83,1 @@\n-#define FT_UINT_TO_POINTER( x )  (void *)(unsigned __int64)(x)\n+#  define FT_UINT_TO_POINTER( x )  (void *)(unsigned __int64)(x)\n@@ -79,1 +85,1 @@\n-#define FT_UINT_TO_POINTER( x )  (void *)(unsigned long)(x)\n+#  define FT_UINT_TO_POINTER( x )  (void *)(unsigned long)(x)\n@@ -219,34 +225,35 @@\n-  \/* When compiling FreeType as a DLL or DSO with hidden visibility,   *\/\n-  \/* some systems\/compilers need a special attribute in front OR after *\/\n-  \/* the return type of function declarations.                         *\/\n-  \/*                                                                   *\/\n-  \/* Two macros are used within the FreeType source code to define     *\/\n-  \/* exported library functions: `FT_EXPORT` and `FT_EXPORT_DEF`.      *\/\n-  \/*                                                                   *\/\n-  \/* - `FT_EXPORT( return_type )`                                      *\/\n-  \/*                                                                   *\/\n-  \/*   is used in a function declaration, as in                        *\/\n-  \/*                                                                   *\/\n-  \/*   ```                                                             *\/\n-  \/*     FT_EXPORT( FT_Error )                                         *\/\n-  \/*     FT_Init_FreeType( FT_Library*  alibrary );                    *\/\n-  \/*   ```                                                             *\/\n-  \/*                                                                   *\/\n-  \/* - `FT_EXPORT_DEF( return_type )`                                  *\/\n-  \/*                                                                   *\/\n-  \/*   is used in a function definition, as in                         *\/\n-  \/*                                                                   *\/\n-  \/*   ```                                                             *\/\n-  \/*     FT_EXPORT_DEF( FT_Error )                                     *\/\n-  \/*     FT_Init_FreeType( FT_Library*  alibrary )                     *\/\n-  \/*     {                                                             *\/\n-  \/*       ... some code ...                                           *\/\n-  \/*       return FT_Err_Ok;                                           *\/\n-  \/*     }                                                             *\/\n-  \/*   ```                                                             *\/\n-  \/*                                                                   *\/\n-  \/* You can provide your own implementation of `FT_EXPORT` and        *\/\n-  \/* `FT_EXPORT_DEF` here if you want.                                 *\/\n-  \/*                                                                   *\/\n-  \/* To export a variable, use `FT_EXPORT_VAR`.                        *\/\n-  \/*                                                                   *\/\n+  \/*\n+   * When compiling FreeType as a DLL or DSO with hidden visibility,\n+   * some systems\/compilers need a special attribute in front OR after\n+   * the return type of function declarations.\n+   *\n+   * Two macros are used within the FreeType source code to define\n+   * exported library functions: `FT_EXPORT` and `FT_EXPORT_DEF`.\n+   *\n+   * - `FT_EXPORT( return_type )`\n+   *\n+   *   is used in a function declaration, as in\n+   *\n+   *   ```\n+   *     FT_EXPORT( FT_Error )\n+   *     FT_Init_FreeType( FT_Library*  alibrary );\n+   *   ```\n+   *\n+   * - `FT_EXPORT_DEF( return_type )`\n+   *\n+   *   is used in a function definition, as in\n+   *\n+   *   ```\n+   *     FT_EXPORT_DEF( FT_Error )\n+   *     FT_Init_FreeType( FT_Library*  alibrary )\n+   *     {\n+   *       ... some code ...\n+   *       return FT_Err_Ok;\n+   *     }\n+   *   ```\n+   *\n+   * You can provide your own implementation of `FT_EXPORT` and\n+   * `FT_EXPORT_DEF` here if you want.\n+   *\n+   * To export a variable, use `FT_EXPORT_VAR`.\n+   *\/\n@@ -257,29 +264,32 @@\n-  \/* The following macros are needed to compile the library with a   *\/\n-  \/* C++ compiler and with 16bit compilers.                          *\/\n-  \/*                                                                 *\/\n-\n-  \/* This is special.  Within C++, you must specify `extern \"C\"` for *\/\n-  \/* functions which are used via function pointers, and you also    *\/\n-  \/* must do that for structures which contain function pointers to  *\/\n-  \/* assure C linkage -- it's not possible to have (local) anonymous *\/\n-  \/* functions which are accessed by (global) function pointers.     *\/\n-  \/*                                                                 *\/\n-  \/*                                                                 *\/\n-  \/* FT_CALLBACK_DEF is used to _define_ a callback function,        *\/\n-  \/* located in the same source code file as the structure that uses *\/\n-  \/* it.                                                             *\/\n-  \/*                                                                 *\/\n-  \/* FT_BASE_CALLBACK and FT_BASE_CALLBACK_DEF are used to declare   *\/\n-  \/* and define a callback function, respectively, in a similar way  *\/\n-  \/* as FT_BASE and FT_BASE_DEF work.                                *\/\n-  \/*                                                                 *\/\n-  \/* FT_CALLBACK_TABLE is used to _declare_ a constant variable that *\/\n-  \/* contains pointers to callback functions.                        *\/\n-  \/*                                                                 *\/\n-  \/* FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable   *\/\n-  \/* that contains pointers to callback functions.                   *\/\n-  \/*                                                                 *\/\n-  \/*                                                                 *\/\n-  \/* Some 16bit compilers have to redefine these macros to insert    *\/\n-  \/* the infamous `_cdecl` or `__fastcall` declarations.             *\/\n-  \/*                                                                 *\/\n+  \/*\n+   * The following macros are needed to compile the library with a\n+   * C++ compiler and with 16bit compilers.\n+   *\/\n+\n+  \/*\n+   * This is special.  Within C++, you must specify `extern \"C\"` for\n+   * functions which are used via function pointers, and you also\n+   * must do that for structures which contain function pointers to\n+   * assure C linkage -- it's not possible to have (local) anonymous\n+   * functions which are accessed by (global) function pointers.\n+   *\n+   *\n+   * FT_CALLBACK_DEF is used to _define_ a callback function,\n+   * located in the same source code file as the structure that uses\n+   * it.  FT_COMPARE_DEF, in addition, ensures the `cdecl` calling\n+   * convention on x86, required by the C library function `qsort`.\n+   *\n+   * FT_BASE_CALLBACK and FT_BASE_CALLBACK_DEF are used to declare\n+   * and define a callback function, respectively, in a similar way\n+   * as FT_BASE and FT_BASE_DEF work.\n+   *\n+   * FT_CALLBACK_TABLE is used to _declare_ a constant variable that\n+   * contains pointers to callback functions.\n+   *\n+   * FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable\n+   * that contains pointers to callback functions.\n+   *\n+   *\n+   * Some 16bit compilers have to redefine these macros to insert\n+   * the infamous `_cdecl` or `__fastcall` declarations.\n+   *\/\n@@ -292,0 +302,10 @@\n+#if defined( __GNUC__ ) && defined( __i386__ )\n+#define FT_COMPARE_DEF( x )  FT_CALLBACK_DEF( x ) __attribute__(( cdecl ))\n+#elif defined( _MSC_VER ) && defined( _M_IX86 )\n+#define FT_COMPARE_DEF( x )  FT_CALLBACK_DEF( x ) __cdecl\n+#elif defined( __WATCOMC__ ) && __WATCOMC__ >= 1240\n+#define FT_COMPARE_DEF( x )  FT_CALLBACK_DEF( x ) __watcall\n+#else\n+#define FT_COMPARE_DEF( x )  FT_CALLBACK_DEF( x )\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/compiler-macros.h","additions":87,"deletions":67,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -362,2 +362,2 @@\n-#if defined( __GNUC__ )                                          && \\\n-    ( __GNUC__ > 3 || ( __GNUC__ == 3 && __GNUC_MINOR__ >= 4 ) )\n+#if defined( __clang__ ) || ( defined( __GNUC__ )                &&  \\\n+    ( __GNUC__ > 3 || ( __GNUC__ == 3 && __GNUC_MINOR__ >= 4 ) ) )\n@@ -373,1 +373,1 @@\n-#endif \/* __GNUC__ *\/\n+#endif\n@@ -375,0 +375,1 @@\n+#elif defined( _MSC_VER ) && _MSC_VER >= 1400\n@@ -376,1 +377,1 @@\n-#elif defined( _MSC_VER ) && ( _MSC_VER >= 1400 )\n+#if defined( _WIN32_WCE )\n@@ -378,1 +379,13 @@\n-#if FT_SIZEOF_INT == 4\n+#include <cmnintrin.h>\n+#pragma intrinsic( _CountLeadingZeros )\n+\n+#define FT_MSB( x )  ( 31 - _CountLeadingZeros( x ) )\n+\n+#elif defined( _M_ARM64 ) || defined( _M_ARM )\n+\n+#include <intrin.h>\n+#pragma intrinsic( _CountLeadingZeros )\n+\n+#define FT_MSB( x )  ( 31 - _CountLeadingZeros( x ) )\n+\n+#elif defined( _M_IX86 ) || defined( _M_AMD64 ) || defined( _M_IA64 )\n@@ -394,1 +407,1 @@\n-#define FT_MSB( x )  ( FT_MSB_i386( x ) )\n+#define FT_MSB( x )  FT_MSB_i386( x )\n@@ -398,1 +411,1 @@\n-#endif \/* _MSC_VER *\/\n+#elif defined( __WATCOMC__ ) && defined( __386__ )\n@@ -400,0 +413,24 @@\n+  extern __inline FT_Int32\n+  FT_MSB_i386( FT_UInt32  x );\n+\n+#pragma aux FT_MSB_i386 =     \\\n+  \"bsr eax, eax\"              \\\n+  parm [eax] nomemory         \\\n+  value [eax]                 \\\n+  modify exact [eax] nomemory;\n+\n+#define FT_MSB( x )  FT_MSB_i386( x )\n+\n+#elif defined( __DECC ) || defined( __DECCXX )\n+\n+#include <builtins.h>\n+\n+#define FT_MSB( x )  (FT_Int)( 63 - _leadz( x ) )\n+\n+#elif defined( _CRAYC )\n+\n+#include <intrinsics.h>\n+\n+#define FT_MSB( x )  (FT_Int)( 31 - _leadz32( x ) )\n+\n+#endif \/* FT_MSB macro definitions *\/\n@@ -403,0 +440,1 @@\n+\n@@ -490,1 +528,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n@@ -501,1 +539,1 @@\n-#endif \/* FT_LONG64 *\/\n+#endif \/* FT_INT64 *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftcalc.h","additions":48,"deletions":10,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -34,0 +34,8 @@\n+#ifdef FT_DEBUG_LOGGING\n+#define DLG_STATIC\n+#include <dlg\/output.h>\n+#include <dlg\/dlg.h>\n+\n+#include <freetype\/ftlogging.h>\n+#endif \/* FT_DEBUG_LOGGING *\/\n+\n@@ -37,0 +45,7 @@\n+  \/* force the definition of FT_DEBUG_LEVEL_TRACE if FT_DEBUG_LOGGING is *\/\n+  \/* already defined.                                                    *\/\n+  \/*                                                                     *\/\n+#ifdef FT_DEBUG_LOGGING\n+#undef  FT_DEBUG_LEVEL_TRACE\n+#define FT_DEBUG_LEVEL_TRACE\n+#endif\n@@ -85,0 +100,3 @@\n+   * To get consistent logging output, there should be no newline character\n+   * (i.e., '\\n') or a single trailing one in the message string of\n+   * `FT_TRACEx` and `FT_ERROR`.\n@@ -87,1 +105,0 @@\n-#ifdef FT_DEBUG_LEVEL_TRACE\n@@ -89,3 +106,11 @@\n-  \/* we need two macros here to make cpp expand `FT_COMPONENT' *\/\n-#define FT_TRACE_COMP( x )   FT_TRACE_COMP_( x )\n-#define FT_TRACE_COMP_( x )  trace_ ## x\n+  \/*************************************************************************\n+   *\n+   * If FT_DEBUG_LOGGING is enabled, tracing messages are sent to dlg's API.\n+   * If FT_DEBUG_LOGGING is disabled, tracing messages are sent to\n+   * `FT_Message` (defined in ftdebug.c).\n+   *\/\n+#ifdef FT_DEBUG_LOGGING\n+\n+  \/* we need two macros to convert the names of `FT_COMPONENT` to a string *\/\n+#define FT_LOGGING_TAG( x )   FT_LOGGING_TAG_( x )\n+#define FT_LOGGING_TAG_( x )  #x\n@@ -93,1 +118,26 @@\n-#define FT_TRACE( level, varformat )                                       \\\n+  \/* we need two macros to convert the component and the trace level *\/\n+  \/* to a string that combines them                                  *\/\n+#define FT_LOGGING_TAGX( x, y )   FT_LOGGING_TAGX_( x, y )\n+#define FT_LOGGING_TAGX_( x, y )  #x \":\" #y\n+\n+\n+#define FT_LOG( level, varformat )                                         \\\n+          do                                                               \\\n+          {                                                                \\\n+            const char*  dlg_tag = FT_LOGGING_TAGX( FT_COMPONENT, level ); \\\n+                                                                           \\\n+                                                                           \\\n+            ft_add_tag( dlg_tag );                                         \\\n+            if ( ft_trace_levels[FT_TRACE_COMP( FT_COMPONENT )] >= level ) \\\n+            {                                                              \\\n+              if ( custom_output_handler != NULL )                         \\\n+                FT_Logging_Callback varformat;                             \\\n+              else                                                         \\\n+                dlg_trace varformat;                                       \\\n+            }                                                              \\\n+            ft_remove_tag( dlg_tag );                                      \\\n+          } while( 0 )\n+\n+#else \/* !FT_DEBUG_LOGGING *\/\n+\n+#define FT_LOG( level, varformat )                                         \\\n@@ -100,0 +150,11 @@\n+#endif \/* !FT_DEBUG_LOGGING *\/\n+\n+\n+#ifdef FT_DEBUG_LEVEL_TRACE\n+\n+  \/* we need two macros here to make cpp expand `FT_COMPONENT' *\/\n+#define FT_TRACE_COMP( x )   FT_TRACE_COMP_( x )\n+#define FT_TRACE_COMP_( x )  trace_ ## x\n+\n+#define FT_TRACE( level, varformat )  FT_LOG( level, varformat )\n+\n@@ -207,1 +268,26 @@\n-#define FT_ERROR( varformat )  FT_Message  varformat\n+  \/**************************************************************************\n+   *\n+   * If FT_DEBUG_LOGGING is enabled, error messages are sent to dlg's API.\n+   * If FT_DEBUG_LOGGING is disabled, error messages are sent to `FT_Message`\n+   * (defined in ftdebug.c).\n+   *\n+   *\/\n+#ifdef FT_DEBUG_LOGGING\n+\n+#define FT_ERROR( varformat )                                      \\\n+          do                                                       \\\n+          {                                                        \\\n+            const char*  dlg_tag = FT_LOGGING_TAG( FT_COMPONENT ); \\\n+                                                                   \\\n+                                                                   \\\n+            ft_add_tag( dlg_tag );                                 \\\n+            dlg_trace varformat;                                   \\\n+            ft_remove_tag( dlg_tag );                              \\\n+          } while ( 0 )\n+\n+#else \/* !FT_DEBUG_LOGGING *\/\n+\n+#define FT_ERROR( varformat )  FT_Message varformat\n+\n+#endif \/* !FT_DEBUG_LOGGING *\/\n+\n@@ -280,0 +366,71 @@\n+\n+#ifdef FT_DEBUG_LOGGING\n+\n+  \/**************************************************************************\n+   *\n+   * 'dlg' uses output handlers to control how and where log messages are\n+   * printed.  Therefore we need to define a default output handler for\n+   * FreeType.\n+   *\/\n+  FT_BASE( void )\n+  ft_log_handler( const struct dlg_origin*  origin,\n+                  const char*               string,\n+                  void*                     data );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * 1. `ft_default_log_handler` stores the function pointer that is used\n+   *    internally by FreeType to print logs to a file.\n+   *\n+   * 2. `custom_output_handler` stores the function pointer to the callback\n+   *    function provided by the user.\n+   *\n+   * It is defined in `ftdebug.c`.\n+   *\/\n+  extern dlg_handler            ft_default_log_handler;\n+  extern FT_Custom_Log_Handler  custom_output_handler;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * If FT_DEBUG_LOGGING macro is enabled, FreeType needs to initialize and\n+   * un-initialize `FILE*`.\n+   *\n+   * These functions are defined in `ftdebug.c`.\n+   *\/\n+  FT_BASE( void )\n+  ft_logging_init( void );\n+\n+  FT_BASE( void )\n+  ft_logging_deinit( void );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * For printing the name of `FT_COMPONENT` along with the actual log we\n+   * need to add a tag with the name of `FT_COMPONENT`.\n+   *\n+   * These functions are defined in `ftdebug.c`.\n+   *\/\n+  FT_BASE( void )\n+  ft_add_tag( const char*  tag );\n+\n+  FT_BASE( void )\n+  ft_remove_tag( const char*  tag );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * A function to print log data using a custom callback logging function\n+   * (which is set using `FT_Set_Log_Handler`).\n+   *\n+   * This function is defined in `ftdebug.c`.\n+   *\/\n+  FT_BASE( void )\n+  FT_Logging_Callback( const char*  fmt,\n+                       ... );\n+\n+#endif \/* FT_DEBUG_LOGGING *\/\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftdebug.h","additions":164,"deletions":7,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftdrv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n@@ -25,0 +25,1 @@\n+#include \"compiler-macros.h\"\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftgloadr.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -347,2 +347,1 @@\n-#define FT_QNEW( ptr )                           \\\n-          FT_MEM_SET_ERROR( FT_MEM_QNEW( ptr ) )\n+#define FT_QNEW( ptr )  FT_MEM_SET_ERROR( FT_MEM_QNEW( ptr ) )\n@@ -350,2 +349,2 @@\n-#define FT_QNEW_ARRAY( ptr, count )                          \\\n-          FT_MEM_SET_ERROR( FT_MEM_NEW_ARRAY( ptr, count ) )\n+#define FT_QNEW_ARRAY( ptr, count )                           \\\n+          FT_MEM_SET_ERROR( FT_MEM_QNEW_ARRAY( ptr, count ) )\n@@ -353,2 +352,2 @@\n-#define FT_QRENEW_ARRAY( ptr, curcnt, newcnt )                          \\\n-          FT_MEM_SET_ERROR( FT_MEM_RENEW_ARRAY( ptr, curcnt, newcnt ) )\n+#define FT_QRENEW_ARRAY( ptr, curcnt, newcnt )                           \\\n+          FT_MEM_SET_ERROR( FT_MEM_QRENEW_ARRAY( ptr, curcnt, newcnt ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftmemory.h","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -421,1 +421,2 @@\n-#define FT_GLYPH_OWN_BITMAP  0x1U\n+#define FT_GLYPH_OWN_BITMAP    0x1U\n+#define FT_GLYPH_OWN_GZIP_SVG  0x2U\n@@ -676,1 +677,1 @@\n-  FT_BASE( void )\n+  FT_BASE( FT_Error )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftobjs.h","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftpsprop.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftrfork.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftserv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -199,3 +199,3 @@\n-#define FT_PEEK_OFF3( p )  FT_INT32( FT_BYTE_U32( p, 0, 16 ) | \\\n-                                     FT_BYTE_U32( p, 1,  8 ) | \\\n-                                     FT_BYTE_U32( p, 2,  0 ) )\n+#define FT_PEEK_OFF3( p )  ( FT_INT32( FT_BYTE_U32( p, 0, 24 ) | \\\n+                                       FT_BYTE_U32( p, 1, 16 ) | \\\n+                                       FT_BYTE_U32( p, 2,  8 ) ) >> 8 )\n@@ -223,3 +223,3 @@\n-#define FT_PEEK_OFF3_LE( p )  FT_INT32( FT_BYTE_U32( p, 2, 16 ) | \\\n-                                        FT_BYTE_U32( p, 1,  8 ) | \\\n-                                        FT_BYTE_U32( p, 0,  0 ) )\n+#define FT_PEEK_OFF3_LE( p )  ( FT_INT32( FT_BYTE_U32( p, 2, 24 ) | \\\n+                                          FT_BYTE_U32( p, 1, 16 ) | \\\n+                                          FT_BYTE_U32( p, 0,  8 ) ) >> 8 )\n@@ -308,2 +308,2 @@\n-#define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetChar, FT_Char )\n-#define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetChar, FT_Byte )\n+#define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetByte, FT_Char )\n+#define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetByte, FT_Byte )\n@@ -312,1 +312,0 @@\n-#define FT_GET_OFF3()       FT_GET_MACRO( FT_Stream_GetUOffset, FT_Long )\n@@ -336,2 +335,2 @@\n-#define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Byte, var )\n-#define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Char, var )\n+#define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadByte, FT_Byte, var )\n+#define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadByte, FT_Char, var )\n@@ -340,1 +339,0 @@\n-#define FT_READ_OFF3( var )       FT_READ_MACRO( FT_Stream_ReadUOffset, FT_Long, var )\n@@ -460,2 +458,2 @@\n-  FT_BASE( FT_Char )\n-  FT_Stream_GetChar( FT_Stream  stream );\n+  FT_BASE( FT_Byte )\n+  FT_Stream_GetByte( FT_Stream  stream );\n@@ -485,2 +483,2 @@\n-  FT_BASE( FT_Char )\n-  FT_Stream_ReadChar( FT_Stream  stream,\n+  FT_BASE( FT_Byte )\n+  FT_Stream_ReadByte( FT_Stream  stream,\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftstream.h","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n@@ -21,0 +21,5 @@\n+  \/* the maximum string length (if the argument to `FT_TRACE_DEF` *\/\n+  \/* gets used as a string) plus one charachter for ':' plus      *\/\n+  \/* another one for the trace level                              *\/\n+#define FT_MAX_TRACE_LEVEL_LENGTH  (9 + 1 + 1)\n+\n@@ -41,0 +46,3 @@\n+FT_TRACE_DEF( synth )     \/* bold\/slant synthesizer  (ftsynth.c)  *\/\n+\n+  \/* rasterizers *\/\n@@ -43,1 +51,0 @@\n-FT_TRACE_DEF( synth )     \/* bold\/slant synthesizer  (ftsynth.c)  *\/\n@@ -45,2 +52,5 @@\n-  \/* Cache sub-system *\/\n-FT_TRACE_DEF( cache )     \/* cache sub-system        (ftcache.c, etc.) *\/\n+  \/* ot-svg module *\/\n+FT_TRACE_DEF( otsvg )     \/* OT-SVG renderer         (ftsvg.c)    *\/\n+\n+  \/* cache sub-system *\/\n+FT_TRACE_DEF( cache )     \/* cache sub-system   (ftcache.c, etc.) *\/\n@@ -57,0 +67,1 @@\n+FT_TRACE_DEF( ttsvg )     \/* OpenType SVG table      (ttsvg.c)    *\/\n@@ -80,0 +91,1 @@\n+FT_TRACE_DEF( afmparse )\n@@ -154,1 +166,0 @@\n-FT_TRACE_DEF( aflatin2 )\n@@ -156,1 +167,4 @@\n-FT_TRACE_DEF( afwarp )\n+\n+  \/* SDF components *\/\n+FT_TRACE_DEF( sdf )       \/* signed distance raster for outlines (ftsdf.c) *\/\n+FT_TRACE_DEF( bsdf )      \/* signed distance raster for bitmaps (ftbsdf.c) *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/fttrace.h","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/ftvalid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/psaux.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/pshints.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svbdf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svcfftl.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svcid.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svfntfmt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svgldict.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svgxval.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svkern.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2016-2020 by\n+ * Copyright (C) 2016-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svmetric.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svmm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svotval.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpfr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpostnm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2012-2020 by\n+ * Copyright (C) 2012-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svprop.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpscmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svpsinfo.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svsfnt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svttcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svtteng.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svttglyf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/services\/svwinfnt.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -314,0 +314,27 @@\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Load_Svg_Doc_Func\n+   *\n+   * @description:\n+   *   Scan the SVG document list to find the document containing the glyph\n+   *   that has the ID 'glyph*XXX*', where *XXX* is the value of\n+   *   `glyph_index` as a decimal integer.\n+   *\n+   * @inout:\n+   *   glyph ::\n+   *     The glyph slot from which pointers to the SVG document list is to be\n+   *     grabbed.  The results are stored back in the slot.\n+   *\n+   * @input:\n+   *   glyph_index ::\n+   *     The index of the glyph that is to be looked up.\n+   *\n+   * @return:\n+   *   FreeType error code.  0 means success.\n+   *\/\n+  typedef FT_Error\n+  (*TT_Load_Svg_Doc_Func)( FT_GlyphSlot  glyph,\n+                           FT_UInt       glyph_index );\n+\n+\n@@ -527,0 +554,164 @@\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Color_Glyph_Paint_Func\n+   *\n+   * @description:\n+   *   Find the root @FT_OpaquePaint object for a given glyph ID.\n+   *\n+   * @input:\n+   *   face ::\n+   *     The target face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index the colored glyph layers are associated with.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The root @FT_OpaquePaint object.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If no color glyph is found, or the root\n+   *   paint could not be retrieved, value~0 gets returned.  In case of an\n+   *   error, value~0 is returned also.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Color_Glyph_Paint_Func )( TT_Face                   face,\n+                                      FT_UInt                   base_glyph,\n+                                      FT_Color_Root_Transform   root_transform,\n+                                      FT_OpaquePaint           *paint );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Color_Glyph_ClipBox_Func\n+   *\n+   * @description:\n+   *   Search for a 'COLR' v1 clip box for the specified `base_glyph` and\n+   *   fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information\n+   *   if one is found.\n+   *\n+   * @input:\n+   *   face ::\n+   *     A handle to the parent face object.\n+   *\n+   *   base_glyph ::\n+   *     The glyph index for which to retrieve the clip box.\n+   *\n+   * @output:\n+   *   clip_box ::\n+   *     The clip box for the requested `base_glyph` if one is found.  The\n+   *     clip box is computed taking scale and transformations configured on\n+   *     the @FT_Face into account.  @FT_ClipBox contains @FT_Vector values\n+   *     in 26.6 format.\n+   *\n+   * @note:\n+   *     To retrieve the clip box in font units, reset scale to units-per-em\n+   *     and remove transforms configured using @FT_Set_Transform.\n+   *\n+   * @return:\n+   *   Value~1 if a ClipBox is found.  If no clip box is found or an\n+   *   error occured, value~0 is returned.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Color_Glyph_ClipBox_Func )( TT_Face      face,\n+                                        FT_UInt      base_glyph,\n+                                        FT_ClipBox*  clip_box );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Paint_Layers_Func\n+   *\n+   * @description:\n+   *   Access the layers of a `PaintColrLayers` table.\n+   *\n+   * @input:\n+   *   face ::\n+   *     The target face object.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     The @FT_LayerIterator from an @FT_PaintColrLayers object, for which\n+   *     the layers are to be retrieved.  The internal state of the iterator\n+   *     is incremented after one call to this function for retrieving one\n+   *     layer.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     The root @FT_OpaquePaint object referencing the actual paint table.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  Value~0 gets returned when the paint\n+   *   object can not be retrieved or any other error occurs.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Paint_Layers_Func )( TT_Face            face,\n+                                 FT_LayerIterator*  iterator,\n+                                 FT_OpaquePaint    *paint );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Colorline_Stops_Func\n+   *\n+   * @description:\n+   *   Get the gradient and solid fill information for a given glyph.\n+   *\n+   * @input:\n+   *   face ::\n+   *     The target face object.\n+   *\n+   * @inout:\n+   *   iterator ::\n+   *     An @FT_ColorStopIterator object.  For the first call you should set\n+   *     `iterator->p` to `NULL`.  For all following calls, simply use the\n+   *     same object again.\n+   *\n+   * @output:\n+   *   color_stop ::\n+   *     Color index and alpha value for the retrieved color stop.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  If there are no more color stops,\n+   *   value~0 gets returned.  In case of an error, value~0 is returned\n+   *   also.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Colorline_Stops_Func )( TT_Face                face,\n+                                    FT_ColorStop          *color_stop,\n+                                    FT_ColorStopIterator*  iterator );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   TT_Get_Paint_Func\n+   *\n+   * @description:\n+   *   Get the paint details for a given @FT_OpaquePaint object.\n+   *\n+   * @input:\n+   *   face ::\n+   *     The target face object.\n+   *\n+   *   opaque_paint ::\n+   *     The @FT_OpaquePaint object.\n+   *\n+   * @output:\n+   *   paint ::\n+   *     An @FT_COLR_Paint object holding the details on `opaque_paint`.\n+   *\n+   * @return:\n+   *   Value~1 if everything is OK.  Value~0 if no details can be found for\n+   *   this paint or any other error occured.\n+   *\/\n+  typedef FT_Bool\n+  ( *TT_Get_Paint_Func )( TT_Face         face,\n+                          FT_OpaquePaint  opaque_paint,\n+                          FT_COLR_Paint  *paint );\n+\n+\n@@ -712,1 +903,1 @@\n-    TT_Loader_GotoTableFunc      goto_table;\n+    TT_Loader_GotoTableFunc  goto_table;\n@@ -714,4 +905,4 @@\n-    TT_Init_Face_Func            init_face;\n-    TT_Load_Face_Func            load_face;\n-    TT_Done_Face_Func            done_face;\n-    FT_Module_Requester          get_interface;\n+    TT_Init_Face_Func    init_face;\n+    TT_Load_Face_Func    load_face;\n+    TT_Done_Face_Func    done_face;\n+    FT_Module_Requester  get_interface;\n@@ -719,1 +910,1 @@\n-    TT_Load_Any_Func             load_any;\n+    TT_Load_Any_Func  load_any;\n@@ -723,6 +914,6 @@\n-    TT_Load_Table_Func           load_head;\n-    TT_Load_Metrics_Func         load_hhea;\n-    TT_Load_Table_Func           load_cmap;\n-    TT_Load_Table_Func           load_maxp;\n-    TT_Load_Table_Func           load_os2;\n-    TT_Load_Table_Func           load_post;\n+    TT_Load_Table_Func    load_head;\n+    TT_Load_Metrics_Func  load_hhea;\n+    TT_Load_Table_Func    load_cmap;\n+    TT_Load_Table_Func    load_maxp;\n+    TT_Load_Table_Func    load_os2;\n+    TT_Load_Table_Func    load_post;\n@@ -730,2 +921,2 @@\n-    TT_Load_Table_Func           load_name;\n-    TT_Free_Table_Func           free_name;\n+    TT_Load_Table_Func  load_name;\n+    TT_Free_Table_Func  free_name;\n@@ -734,1 +925,1 @@\n-    TT_Load_Table_Func           load_kern;\n+    TT_Load_Table_Func  load_kern;\n@@ -736,2 +927,2 @@\n-    TT_Load_Table_Func           load_gasp;\n-    TT_Load_Table_Func           load_pclt;\n+    TT_Load_Table_Func  load_gasp;\n+    TT_Load_Table_Func  load_pclt;\n@@ -741,1 +932,1 @@\n-    TT_Load_Table_Func           load_bhed;\n+    TT_Load_Table_Func  load_bhed;\n@@ -743,1 +934,1 @@\n-    TT_Load_SBit_Image_Func      load_sbit_image;\n+    TT_Load_SBit_Image_Func  load_sbit_image;\n@@ -746,2 +937,2 @@\n-    TT_Get_PS_Name_Func          get_psname;\n-    TT_Free_Table_Func           free_psnames;\n+    TT_Get_PS_Name_Func  get_psname;\n+    TT_Free_Table_Func   free_psnames;\n@@ -752,1 +943,1 @@\n-    TT_Face_GetKerningFunc       get_kerning;\n+    TT_Face_GetKerningFunc  get_kerning;\n@@ -758,2 +949,2 @@\n-    TT_Load_Table_Func           load_font_dir;\n-    TT_Load_Metrics_Func         load_hmtx;\n+    TT_Load_Table_Func    load_font_dir;\n+    TT_Load_Metrics_Func  load_hmtx;\n@@ -761,2 +952,2 @@\n-    TT_Load_Table_Func           load_eblc;\n-    TT_Free_Table_Func           free_eblc;\n+    TT_Load_Table_Func  load_eblc;\n+    TT_Free_Table_Func  free_eblc;\n@@ -767,12 +958,22 @@\n-    TT_Load_Table_Func           load_cpal;\n-    TT_Load_Table_Func           load_colr;\n-    TT_Free_Table_Func           free_cpal;\n-    TT_Free_Table_Func           free_colr;\n-    TT_Set_Palette_Func          set_palette;\n-    TT_Get_Colr_Layer_Func       get_colr_layer;\n-    TT_Blend_Colr_Func           colr_blend;\n-\n-    TT_Get_Metrics_Func          get_metrics;\n-\n-    TT_Get_Name_Func             get_name;\n-    TT_Get_Name_ID_Func          get_name_id;\n+    TT_Load_Table_Func               load_cpal;\n+    TT_Load_Table_Func               load_colr;\n+    TT_Free_Table_Func               free_cpal;\n+    TT_Free_Table_Func               free_colr;\n+    TT_Set_Palette_Func              set_palette;\n+    TT_Get_Colr_Layer_Func           get_colr_layer;\n+    TT_Get_Color_Glyph_Paint_Func    get_colr_glyph_paint;\n+    TT_Get_Color_Glyph_ClipBox_Func  get_color_glyph_clipbox;\n+    TT_Get_Paint_Layers_Func         get_paint_layers;\n+    TT_Get_Colorline_Stops_Func      get_colorline_stops;\n+    TT_Get_Paint_Func                get_paint;\n+    TT_Blend_Colr_Func               colr_blend;\n+\n+    TT_Get_Metrics_Func  get_metrics;\n+\n+    TT_Get_Name_Func     get_name;\n+    TT_Get_Name_ID_Func  get_name_id;\n+\n+    \/* OpenType SVG Support *\/\n+    TT_Load_Table_Func    load_svg;\n+    TT_Free_Table_Func    free_svg;\n+    TT_Load_Svg_Doc_Func  load_svg_doc;\n@@ -823,0 +1024,5 @@\n+          get_colr_glyph_paint_,         \\\n+          get_color_glyph_clipbox,       \\\n+          get_paint_layers_,             \\\n+          get_colorline_stops_,          \\\n+          get_paint_,                    \\\n@@ -826,1 +1032,4 @@\n-          get_name_id_ )                 \\\n+          get_name_id_,                  \\\n+          load_svg_,                     \\\n+          free_svg_,                     \\\n+          load_svg_doc_ )                \\\n@@ -863,0 +1072,5 @@\n+    get_colr_glyph_paint_,               \\\n+    get_color_glyph_clipbox,             \\\n+    get_paint_layers_,                   \\\n+    get_colorline_stops_,                \\\n+    get_paint_,                          \\\n@@ -866,1 +1080,4 @@\n-    get_name_id_                         \\\n+    get_name_id_,                        \\\n+    load_svg_,                           \\\n+    free_svg_,                           \\\n+    load_svg_doc_                        \\\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/sfnt.h","additions":258,"deletions":41,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/****************************************************************************\n+ *\n+ * svginterface.h\n+ *\n+ *   Interface of ot-svg module (specification only).\n+ *\n+ * Copyright (C) 2022 by\n+ * David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef SVGINTERFACE_H_\n+#define SVGINTERFACE_H_\n+\n+#include <ft2build.h>\n+#include <freetype\/otsvg.h>\n+\n+\n+FT_BEGIN_HEADER\n+\n+  typedef FT_Error\n+  (*Preset_Bitmap_Func)( FT_Module     module,\n+                         FT_GlyphSlot  slot,\n+                         FT_Bool       cache );\n+\n+  typedef struct  SVG_Interface_\n+  {\n+    Preset_Bitmap_Func  preset_slot;\n+\n+  } SVG_Interface;\n+\n+  typedef SVG_Interface*  SVG_Service;\n+\n+FT_END_HEADER\n+\n+#endif \/* SVGINTERFACE_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/svginterface.h","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/t1types.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -1375,1 +1375,1 @@\n-   *     identical to the number of glyphs.  Ignored for Type 2 fonts.\n+   *     one more than the number of glyphs.  Ignored for Type 2 fonts.\n@@ -1393,2 +1393,2 @@\n-   *   hdmx_record_sizes ::\n-   *     An array holding the ppem sizes available in the 'hdmx' table.\n+   *   hdmx_records ::\n+   *     A array of pointers to the 'hdmx' table records sorted by ppem.\n@@ -1601,1 +1601,1 @@\n-    FT_ULong              num_locations; \/* in broken TTF, gid > 0xFFFF *\/\n+    FT_ULong              num_locations; \/* up to 0xFFFF + 1 *\/\n@@ -1608,1 +1608,1 @@\n-    FT_Byte*              hdmx_record_sizes;\n+    FT_Byte**             hdmx_records;\n@@ -1647,0 +1647,3 @@\n+    \/* since 2.12 *\/\n+    void*                 svg;\n+\n@@ -1737,1 +1740,1 @@\n-    FT_Int           byte_len;\n+    FT_UInt          byte_len;\n@@ -1772,0 +1775,3 @@\n+    \/* since version 2.11.2 *\/\n+    FT_Byte*         widthp;\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/tttypes.h","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -95,1 +95,1 @@\n-    FT_ULong  Tag;           \/* table ID                  *\/\n+    FT_Tag    Tag;           \/* table ID                  *\/\n@@ -194,1 +194,1 @@\n-    FT_ULong  Tag;                \/* table file offset         *\/\n+    FT_Tag    Tag;                \/* table file offset         *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/internal\/wofftypes.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,336 @@\n+\/****************************************************************************\n+ *\n+ * otsvg.h\n+ *\n+ *   Interface for OT-SVG support related things (specification).\n+ *\n+ * Copyright (C) 2022 by\n+ * David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef OTSVG_H_\n+#define OTSVG_H_\n+\n+#include <freetype\/freetype.h>\n+\n+#ifdef FREETYPE_H\n+#error \"freetype.h of FreeType 1 has been loaded!\"\n+#error \"Please fix the directory search order for header files\"\n+#error \"so that freetype.h of FreeType 2 is found first.\"\n+#endif\n+\n+\n+FT_BEGIN_HEADER\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @section:\n+   *   svg_fonts\n+   *\n+   * @title:\n+   *   OpenType SVG Fonts\n+   *\n+   * @abstract:\n+   *   OT-SVG API between FreeType and an external SVG rendering library.\n+   *\n+   * @description:\n+   *   This section describes the four hooks necessary to render SVG\n+   *   'documents' that are contained in an OpenType font's 'SVG~' table.\n+   *\n+   *   For more information on the implementation, see our standard hooks\n+   *   based on 'librsvg' in the [FreeType Demo\n+   *   Programs](https:\/\/gitlab.freedesktop.org\/freetype\/freetype-demos)\n+   *   repository.\n+   *\n+   *\/\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   SVG_Lib_Init_Func\n+   *\n+   * @description:\n+   *   A callback that is called when the first OT-SVG glyph is rendered in\n+   *   the lifetime of an @FT_Library object.  In a typical implementation,\n+   *   one would want to allocate a structure and point the `data_pointer`\n+   *   to it and perform any library initializations that might be needed.\n+   *\n+   * @inout:\n+   *   data_pointer ::\n+   *     The SVG rendering module stores a pointer variable that can be used\n+   *     by clients to store any data that needs to be shared across\n+   *     different hooks.  `data_pointer` is essentially a pointer to that\n+   *     pointer such that it can be written to as well as read from.\n+   *\n+   * @return:\n+   *   FreeType error code.  0 means success.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef FT_Error\n+  (*SVG_Lib_Init_Func)( FT_Pointer  *data_pointer );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   SVG_Lib_Free_Func\n+   *\n+   * @description:\n+   *   A callback that is called when the `ot-svg` module is being freed.\n+   *   It is only called if the init hook was called earlier.  This means\n+   *   that neither the init nor the free hook is called if no OT-SVG glyph\n+   *   is rendered.\n+   *\n+   *   In a typical implementation, one would want to free any state\n+   *   structure that was allocated in the init hook and perform any\n+   *   library-related closure that might be needed.\n+   *\n+   * @inout:\n+   *   data_pointer ::\n+   *     The SVG rendering module stores a pointer variable that can be used\n+   *     by clients to store any data that needs to be shared across\n+   *     different hooks.  `data_pointer` is essentially a pointer to that\n+   *     pointer such that it can be written to as well as read from.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef void\n+  (*SVG_Lib_Free_Func)( FT_Pointer  *data_pointer );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   SVG_Lib_Render_Func\n+   *\n+   * @description:\n+   *   A callback that is called to render an OT-SVG glyph.  This callback\n+   *   hook is called right after the preset hook @SVG_Lib_Preset_Slot_Func\n+   *   has been called with `cache` set to `TRUE`.  The data necessary to\n+   *   render is available through the handle @FT_SVG_Document, which is set\n+   *   in the `other` field of @FT_GlyphSlotRec.\n+   *\n+   *   The render hook is expected to render the SVG glyph to the bitmap\n+   *   buffer that is allocated already at `slot->bitmap.buffer`.  It also\n+   *   sets the `num_grays` value as well as `slot->format`.\n+   *\n+   * @input:\n+   *   slot ::\n+   *     The slot to render.\n+   *\n+   * @inout:\n+   *   data_pointer ::\n+   *     The SVG rendering module stores a pointer variable that can be used\n+   *     by clients to store any data that needs to be shared across\n+   *     different hooks.  `data_pointer` is essentially a pointer to that\n+   *     pointer such that it can be written to as well as read from.\n+   *\n+   * @return:\n+   *   FreeType error code.  0 means success.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef FT_Error\n+  (*SVG_Lib_Render_Func)( FT_GlyphSlot  slot,\n+                          FT_Pointer   *data_pointer );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @functype:\n+   *   SVG_Lib_Preset_Slot_Func\n+   *\n+   * @description:\n+   *   A callback that is called to preset the glyph slot.  It is called from\n+   *   two places.\n+   *\n+   *   1. When `FT_Load_Glyph` needs to preset the glyph slot.\n+   *\n+   *   2. Right before the `svg` module calls the render callback hook.\n+   *\n+   *   When it is the former, the argument `cache` is set to `FALSE`.  When\n+   *   it is the latter, the argument `cache` is set to `TRUE`.  This\n+   *   distinction has been made because many calculations that are necessary\n+   *   for presetting a glyph slot are the same needed later for the render\n+   *   callback hook.  Thus, if `cache` is `TRUE`, the hook can _cache_ those\n+   *   calculations in a memory block referenced by the state pointer.\n+   *\n+   *   This hook is expected to preset the slot by setting parameters such as\n+   *   `bitmap_left`, `bitmap_top`, `width`, `rows`, `pitch`, and\n+   *   `pixel_mode`.  It is also expected to set all the metrics for the slot\n+   *   including the vertical advance if it is not already set.  Typically,\n+   *   fonts have horizontal advances but not vertical ones.  If those are\n+   *   available, they had already been set, otherwise they have to be\n+   *   estimated and set manually.  The hook must take into account the\n+   *   transformations that have been set, and translate the transformation\n+   *   matrices into the SVG coordinate system, as the original matrix is\n+   *   intended for the TTF\/CFF coordinate system.\n+   *\n+   * @input:\n+   *   slot ::\n+   *     The glyph slot that has the SVG document loaded.\n+   *\n+   *   cache ::\n+   *     See description.\n+   *\n+   * @inout:\n+   *   data_pointer ::\n+   *     The SVG rendering module stores a pointer variable that can be used\n+   *     by clients to store any data that needs to be shared across\n+   *     different hooks.  `data_pointer` is essentially a pointer to that\n+   *     pointer such that it can be written to as well as read from.\n+   *\n+   * @return:\n+   *   FreeType error code.  0 means success.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef FT_Error\n+  (*SVG_Lib_Preset_Slot_Func)( FT_GlyphSlot  slot,\n+                               FT_Bool       cache,\n+                               FT_Pointer   *state );\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   SVG_RendererHooks\n+   *\n+   * @description:\n+   *   A structure that stores the four hooks needed to render OT-SVG glyphs\n+   *   properly.  The structure is publicly used to set the hooks via the\n+   *   @svg-hooks driver property.\n+   *\n+   *   The behavior of each hook is described in its documentation.  One\n+   *   thing to note is that the preset hook and the render hook often need\n+   *   to do the same operations; therefore, it's better to cache the\n+   *   intermediate data in a state structure to avoid calculating it twice.\n+   *   For example, in the preset hook one can draw the glyph on a recorder\n+   *   surface and later create a bitmap surface from it in the render hook.\n+   *\n+   *   All four hooks must be non-NULL.\n+   *\n+   * @fields:\n+   *   init_svg ::\n+   *     The initialization hook.\n+   *\n+   *   free_svg ::\n+   *     The cleanup hook.\n+   *\n+   *   render_hook ::\n+   *     The render hook.\n+   *\n+   *   preset_slot ::\n+   *     The preset hook.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef struct SVG_RendererHooks_\n+  {\n+    SVG_Lib_Init_Func    init_svg;\n+    SVG_Lib_Free_Func    free_svg;\n+    SVG_Lib_Render_Func  render_svg;\n+\n+    SVG_Lib_Preset_Slot_Func  preset_slot;\n+\n+  } SVG_RendererHooks;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @struct:\n+   *   FT_SVG_DocumentRec\n+   *\n+   * @description:\n+   *   A structure that models one SVG document.\n+   *\n+   * @fields:\n+   *   svg_document ::\n+   *     A pointer to the SVG document.\n+   *\n+   *   svg_document_length ::\n+   *     The length of `svg_document`.\n+   *\n+   *   metrics ::\n+   *     A metrics object storing the size information.\n+   *\n+   *   units_per_EM ::\n+   *     The size of the EM square.\n+   *\n+   *   start_glyph_id ::\n+   *     The first glyph ID in the glyph range covered by this document.\n+   *\n+   *   end_glyph_id ::\n+   *     The last glyph ID in the glyph range covered by this document.\n+   *\n+   *   transform ::\n+   *     A 2x2 transformation matrix to apply to the glyph while rendering\n+   *     it.\n+   *\n+   *   delta ::\n+   *     The translation to apply to the glyph while rendering.\n+   *\n+   * @note:\n+   *   When an @FT_GlyphSlot object `slot` is passed down to a renderer, the\n+   *   renderer can only access the `metrics` and `units_per_EM` fields via\n+   *   `slot->face`.  However, when @FT_Glyph_To_Bitmap sets up a dummy\n+   *   object, it has no way to set a `face` object.  Thus, metrics\n+   *   information and `units_per_EM` (which is necessary for OT-SVG) has to\n+   *   be stored separately.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef struct  FT_SVG_DocumentRec_\n+  {\n+    FT_Byte*  svg_document;\n+    FT_ULong  svg_document_length;\n+\n+    FT_Size_Metrics  metrics;\n+    FT_UShort        units_per_EM;\n+\n+    FT_UShort  start_glyph_id;\n+    FT_UShort  end_glyph_id;\n+\n+    FT_Matrix  transform;\n+    FT_Vector  delta;\n+\n+  } FT_SVG_DocumentRec;\n+\n+\n+  \/**************************************************************************\n+   *\n+   * @type:\n+   *   FT_SVG_Document\n+   *\n+   * @description:\n+   *   A handle to an @FT_SVG_DocumentRec object.\n+   *\n+   * @since:\n+   *   2.12\n+   *\/\n+  typedef struct FT_SVG_DocumentRec_*  FT_SVG_Document;\n+\n+\n+FT_END_HEADER\n+\n+#endif \/* OTSVG_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/otsvg.h","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -363,1 +363,1 @@\n-    FT_Int         sd_bytes;\n+    FT_UInt        sd_bytes;\n@@ -418,2 +418,2 @@\n-    FT_Int          fd_bytes;\n-    FT_Int          gd_bytes;\n+    FT_UInt         fd_bytes;\n+    FT_UInt         gd_bytes;\n@@ -422,1 +422,1 @@\n-    FT_Int          num_dicts;\n+    FT_UInt         num_dicts;\n@@ -456,1 +456,1 @@\n-   *    FT_Has_PS_Glyph_Names\n+   *   FT_Has_PS_Glyph_Names\n@@ -459,3 +459,3 @@\n-   *    Return true if a given face provides reliable PostScript glyph names.\n-   *    This is similar to using the @FT_HAS_GLYPH_NAMES macro, except that\n-   *    certain fonts (mostly TrueType) contain incorrect glyph name tables.\n+   *   Return true if a given face provides reliable PostScript glyph names.\n+   *   This is similar to using the @FT_HAS_GLYPH_NAMES macro, except that\n+   *   certain fonts (mostly TrueType) contain incorrect glyph name tables.\n@@ -463,2 +463,2 @@\n-   *    When this function returns true, the caller is sure that the glyph\n-   *    names returned by @FT_Get_Glyph_Name are reliable.\n+   *   When this function returns true, the caller is sure that the glyph\n+   *   names returned by @FT_Get_Glyph_Name are reliable.\n@@ -467,2 +467,2 @@\n-   *    face ::\n-   *      face handle\n+   *   face ::\n+   *     face handle\n@@ -471,1 +471,1 @@\n-   *    Boolean.  True if glyph names are reliable.\n+   *   Boolean.  True if glyph names are reliable.\n@@ -481,1 +481,1 @@\n-   *    FT_Get_PS_Font_Info\n+   *   FT_Get_PS_Font_Info\n@@ -484,2 +484,2 @@\n-   *    Retrieve the @PS_FontInfoRec structure corresponding to a given\n-   *    PostScript font.\n+   *   Retrieve the @PS_FontInfoRec structure corresponding to a given\n+   *   PostScript font.\n@@ -488,2 +488,2 @@\n-   *    face ::\n-   *      PostScript face handle.\n+   *   face ::\n+   *     PostScript face handle.\n@@ -492,2 +492,2 @@\n-   *    afont_info ::\n-   *      Output font info structure pointer.\n+   *   afont_info ::\n+   *     A pointer to a @PS_FontInfoRec object.\n@@ -496,1 +496,1 @@\n-   *    FreeType error code.  0~means success.\n+   *   FreeType error code.  0~means success.\n@@ -499,3 +499,7 @@\n-   *    String pointers within the @PS_FontInfoRec structure are owned by the\n-   *    face and don't need to be freed by the caller.  Missing entries in\n-   *    the font's FontInfo dictionary are represented by `NULL` pointers.\n+   *   String pointers within the @PS_FontInfoRec structure are owned by the\n+   *   face and don't need to be freed by the caller.  Missing entries in the\n+   *   font's FontInfo dictionary are represented by `NULL` pointers.\n+   *\n+   *   The following font formats support this feature: 'Type~1', 'Type~42',\n+   *   'CFF', 'CID~Type~1'.  For other font formats this function returns the\n+   *   `FT_Err_Invalid_Argument` error code.\n@@ -503,2 +507,8 @@\n-   *    If the font's format is not PostScript-based, this function will\n-   *    return the `FT_Err_Invalid_Argument` error code.\n+   * @example:\n+   *   ```\n+   *     PS_FontInfoRec  font_info;\n+   *\n+   *\n+   *     error = FT_Get_PS_Font_Info( face, &font_info );\n+   *     ...\n+   *   ```\n@@ -515,1 +525,1 @@\n-   *    FT_Get_PS_Font_Private\n+   *   FT_Get_PS_Font_Private\n@@ -518,2 +528,2 @@\n-   *    Retrieve the @PS_PrivateRec structure corresponding to a given\n-   *    PostScript font.\n+   *   Retrieve the @PS_PrivateRec structure corresponding to a given\n+   *   PostScript font.\n@@ -522,2 +532,2 @@\n-   *    face ::\n-   *      PostScript face handle.\n+   *   face ::\n+   *     PostScript face handle.\n@@ -526,2 +536,2 @@\n-   *    afont_private ::\n-   *      Output private dictionary structure pointer.\n+   *   afont_private ::\n+   *     A pointer to a @PS_PrivateRec object.\n@@ -530,1 +540,1 @@\n-   *    FreeType error code.  0~means success.\n+   *   FreeType error code.  0~means success.\n@@ -533,2 +543,2 @@\n-   *    The string pointers within the @PS_PrivateRec structure are owned by\n-   *    the face and don't need to be freed by the caller.\n+   *   The string pointers within the @PS_PrivateRec structure are owned by\n+   *   the face and don't need to be freed by the caller.\n@@ -536,2 +546,12 @@\n-   *    If the font's format is not PostScript-based, this function returns\n-   *    the `FT_Err_Invalid_Argument` error code.\n+   *   Only the 'Type~1' font format supports this feature.  For other font\n+   *   formats this function returns the `FT_Err_Invalid_Argument` error\n+   *   code.\n+   *\n+   * @example:\n+   *   ```\n+   *     PS_PrivateRec  font_private;\n+   *\n+   *\n+   *     error = FT_Get_PS_Font_Private( face, &font_private );\n+   *     ...\n+   *   ```\n@@ -696,1 +716,1 @@\n-   *    FT_Get_PS_Font_Value\n+   *   FT_Get_PS_Font_Value\n@@ -699,1 +719,1 @@\n-   *    Retrieve the value for the supplied key from a PostScript font.\n+   *   Retrieve the value for the supplied key from a PostScript font.\n@@ -702,2 +722,2 @@\n-   *    face ::\n-   *      PostScript face handle.\n+   *   face ::\n+   *     PostScript face handle.\n@@ -705,2 +725,2 @@\n-   *    key ::\n-   *      An enumeration value representing the dictionary key to retrieve.\n+   *   key ::\n+   *     An enumeration value representing the dictionary key to retrieve.\n@@ -708,2 +728,2 @@\n-   *    idx ::\n-   *      For array values, this specifies the index to be returned.\n+   *   idx ::\n+   *     For array values, this specifies the index to be returned.\n@@ -711,2 +731,2 @@\n-   *    value ::\n-   *      A pointer to memory into which to write the value.\n+   *   value ::\n+   *     A pointer to memory into which to write the value.\n@@ -714,2 +734,2 @@\n-   *    valen_len ::\n-   *      The size, in bytes, of the memory supplied for the value.\n+   *   valen_len ::\n+   *     The size, in bytes, of the memory supplied for the value.\n@@ -718,2 +738,2 @@\n-   *    value ::\n-   *      The value matching the above key, if it exists.\n+   *   value ::\n+   *     The value matching the above key, if it exists.\n@@ -722,2 +742,2 @@\n-   *    The amount of memory (in bytes) required to hold the requested value\n-   *    (if it exists, -1 otherwise).\n+   *   The amount of memory (in bytes) required to hold the requested value\n+   *   (if it exists, -1 otherwise).\n@@ -726,5 +746,5 @@\n-   *    The values returned are not pointers into the internal structures of\n-   *    the face, but are 'fresh' copies, so that the memory containing them\n-   *    belongs to the calling application.  This also enforces the\n-   *    'read-only' nature of these values, i.e., this function cannot be\n-   *    used to manipulate the face.\n+   *   The values returned are not pointers into the internal structures of\n+   *   the face, but are 'fresh' copies, so that the memory containing them\n+   *   belongs to the calling application.  This also enforces the\n+   *   'read-only' nature of these values, i.e., this function cannot be\n+   *   used to manipulate the face.\n@@ -732,2 +752,2 @@\n-   *    `value` is a void pointer because the values returned can be of\n-   *    various types.\n+   *   `value` is a void pointer because the values returned can be of\n+   *   various types.\n@@ -735,2 +755,2 @@\n-   *    If either `value` is `NULL` or `value_len` is too small, just the\n-   *    required memory size for the requested entry is returned.\n+   *   If either `value` is `NULL` or `value_len` is too small, just the\n+   *   required memory size for the requested entry is returned.\n@@ -738,4 +758,4 @@\n-   *    The `idx` parameter is used, not only to retrieve elements of, for\n-   *    example, the FontMatrix or FontBBox, but also to retrieve name keys\n-   *    from the CharStrings dictionary, and the charstrings themselves.  It\n-   *    is ignored for atomic values.\n+   *   The `idx` parameter is used, not only to retrieve elements of, for\n+   *   example, the FontMatrix or FontBBox, but also to retrieve name keys\n+   *   from the CharStrings dictionary, and the charstrings themselves.  It\n+   *   is ignored for atomic values.\n@@ -743,3 +763,3 @@\n-   *    `PS_DICT_BLUE_SCALE` returns a value that is scaled up by 1000.  To\n-   *    get the value as in the font stream, you need to divide by 65536000.0\n-   *    (to remove the FT_Fixed scale, and the x1000 scale).\n+   *   `PS_DICT_BLUE_SCALE` returns a value that is scaled up by 1000.  To\n+   *   get the value as in the font stream, you need to divide by 65536000.0\n+   *   (to remove the FT_Fixed scale, and the x1000 scale).\n@@ -747,4 +767,4 @@\n-   *    IMPORTANT: Only key\/value pairs read by the FreeType interpreter can\n-   *    be retrieved.  So, for example, PostScript procedures such as NP, ND,\n-   *    and RD are not available.  Arbitrary keys are, obviously, not be\n-   *    available either.\n+   *   IMPORTANT: Only key\/value pairs read by the FreeType interpreter can\n+   *   be retrieved.  So, for example, PostScript procedures such as NP, ND,\n+   *   and RD are not available.  Arbitrary keys are, obviously, not be\n+   *   available either.\n@@ -752,2 +772,2 @@\n-   *    If the font's format is not PostScript-based, this function returns\n-   *    the `FT_Err_Invalid_Argument` error code.\n+   *   If the font's format is not PostScript-based, this function returns\n+   *   the `FT_Err_Invalid_Argument` error code.\n@@ -756,1 +776,1 @@\n-   *    2.4.8\n+   *   2.4.8\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/t1tables.h","additions":98,"deletions":78,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -594,1 +594,1 @@\n-#define TT_MS_LANGID_KYRGYZ_KYRGYZSTAN \/* Cyrillic*\/   0x0440\n+#define TT_MS_LANGID_KYRGYZ_KYRGYZSTAN \/* Cyrillic *\/  0x0440\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/ttnameid.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/tttables.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -98,0 +98,1 @@\n+#define TTAG_SVG   FT_MAKE_TAG( 'S', 'V', 'G', ' ' )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/freetype\/tttags.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/include\/ft2build.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,285 +0,0 @@\n-\/****************************************************************************\n- *\n- * afangles.c\n- *\n- *   Routines used to compute vector angles with limited accuracy\n- *   and very high speed.  It also contains sorting routines (body).\n- *\n- * Copyright (C) 2003-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n- *\n- * This file is part of the FreeType project, and may only be used,\n- * modified, and distributed under the terms of the FreeType project\n- * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n- * this file you indicate that you have read the license and\n- * understand and accept it fully.\n- *\n- *\/\n-\n-\n-#include \"aftypes.h\"\n-\n-\n-  \/*\n-   * We are not using `af_angle_atan' anymore, but we keep the source\n-   * code below just in case...\n-   *\/\n-\n-\n-#if 0\n-\n-\n-  \/*\n-   * The trick here is to realize that we don't need a very accurate angle\n-   * approximation.  We are going to use the result of `af_angle_atan' to\n-   * only compare the sign of angle differences, or check whether its\n-   * magnitude is very small.\n-   *\n-   * The approximation\n-   *\n-   *   dy * PI \/ (|dx|+|dy|)\n-   *\n-   * should be enough, and much faster to compute.\n-   *\/\n-  FT_LOCAL_DEF( AF_Angle )\n-  af_angle_atan( FT_Fixed  dx,\n-                 FT_Fixed  dy )\n-  {\n-    AF_Angle  angle;\n-    FT_Fixed  ax = dx;\n-    FT_Fixed  ay = dy;\n-\n-\n-    if ( ax < 0 )\n-      ax = -ax;\n-    if ( ay < 0 )\n-      ay = -ay;\n-\n-    ax += ay;\n-\n-    if ( ax == 0 )\n-      angle = 0;\n-    else\n-    {\n-      angle = ( AF_ANGLE_PI2 * dy ) \/ ( ax + ay );\n-      if ( dx < 0 )\n-      {\n-        if ( angle >= 0 )\n-          angle = AF_ANGLE_PI - angle;\n-        else\n-          angle = -AF_ANGLE_PI - angle;\n-      }\n-    }\n-\n-    return angle;\n-  }\n-\n-\n-#elif 0\n-\n-\n-  \/* the following table has been automatically generated with *\/\n-  \/* the `mather.py' Python script                             *\/\n-\n-#define AF_ATAN_BITS  8\n-\n-  static const FT_Byte  af_arctan[1L << AF_ATAN_BITS] =\n-  {\n-     0,  0,  1,  1,  1,  2,  2,  2,\n-     3,  3,  3,  3,  4,  4,  4,  5,\n-     5,  5,  6,  6,  6,  7,  7,  7,\n-     8,  8,  8,  9,  9,  9, 10, 10,\n-    10, 10, 11, 11, 11, 12, 12, 12,\n-    13, 13, 13, 14, 14, 14, 14, 15,\n-    15, 15, 16, 16, 16, 17, 17, 17,\n-    18, 18, 18, 18, 19, 19, 19, 20,\n-    20, 20, 21, 21, 21, 21, 22, 22,\n-    22, 23, 23, 23, 24, 24, 24, 24,\n-    25, 25, 25, 26, 26, 26, 26, 27,\n-    27, 27, 28, 28, 28, 28, 29, 29,\n-    29, 30, 30, 30, 30, 31, 31, 31,\n-    31, 32, 32, 32, 33, 33, 33, 33,\n-    34, 34, 34, 34, 35, 35, 35, 35,\n-    36, 36, 36, 36, 37, 37, 37, 38,\n-    38, 38, 38, 39, 39, 39, 39, 40,\n-    40, 40, 40, 41, 41, 41, 41, 42,\n-    42, 42, 42, 42, 43, 43, 43, 43,\n-    44, 44, 44, 44, 45, 45, 45, 45,\n-    46, 46, 46, 46, 46, 47, 47, 47,\n-    47, 48, 48, 48, 48, 48, 49, 49,\n-    49, 49, 50, 50, 50, 50, 50, 51,\n-    51, 51, 51, 51, 52, 52, 52, 52,\n-    52, 53, 53, 53, 53, 53, 54, 54,\n-    54, 54, 54, 55, 55, 55, 55, 55,\n-    56, 56, 56, 56, 56, 57, 57, 57,\n-    57, 57, 57, 58, 58, 58, 58, 58,\n-    59, 59, 59, 59, 59, 59, 60, 60,\n-    60, 60, 60, 61, 61, 61, 61, 61,\n-    61, 62, 62, 62, 62, 62, 62, 63,\n-    63, 63, 63, 63, 63, 64, 64, 64\n-  };\n-\n-\n-  FT_LOCAL_DEF( AF_Angle )\n-  af_angle_atan( FT_Fixed  dx,\n-                 FT_Fixed  dy )\n-  {\n-    AF_Angle  angle;\n-\n-\n-    \/* check trivial cases *\/\n-    if ( dy == 0 )\n-    {\n-      angle = 0;\n-      if ( dx < 0 )\n-        angle = AF_ANGLE_PI;\n-      return angle;\n-    }\n-    else if ( dx == 0 )\n-    {\n-      angle = AF_ANGLE_PI2;\n-      if ( dy < 0 )\n-        angle = -AF_ANGLE_PI2;\n-      return angle;\n-    }\n-\n-    angle = 0;\n-    if ( dx < 0 )\n-    {\n-      dx = -dx;\n-      dy = -dy;\n-      angle = AF_ANGLE_PI;\n-    }\n-\n-    if ( dy < 0 )\n-    {\n-      FT_Pos  tmp;\n-\n-\n-      tmp = dx;\n-      dx  = -dy;\n-      dy  = tmp;\n-      angle -= AF_ANGLE_PI2;\n-    }\n-\n-    if ( dx == 0 && dy == 0 )\n-      return 0;\n-\n-    if ( dx == dy )\n-      angle += AF_ANGLE_PI4;\n-    else if ( dx > dy )\n-      angle += af_arctan[FT_DivFix( dy, dx ) >> ( 16 - AF_ATAN_BITS )];\n-    else\n-      angle += AF_ANGLE_PI2 -\n-               af_arctan[FT_DivFix( dx, dy ) >> ( 16 - AF_ATAN_BITS )];\n-\n-    if ( angle > AF_ANGLE_PI )\n-      angle -= AF_ANGLE_2PI;\n-\n-    return angle;\n-  }\n-\n-\n-#endif \/* 0 *\/\n-\n-\n-  FT_LOCAL_DEF( void )\n-  af_sort_pos( FT_UInt  count,\n-               FT_Pos*  table )\n-  {\n-    FT_UInt  i, j;\n-    FT_Pos   swap;\n-\n-\n-    for ( i = 1; i < count; i++ )\n-    {\n-      for ( j = i; j > 0; j-- )\n-      {\n-        if ( table[j] >= table[j - 1] )\n-          break;\n-\n-        swap         = table[j];\n-        table[j]     = table[j - 1];\n-        table[j - 1] = swap;\n-      }\n-    }\n-  }\n-\n-\n-  FT_LOCAL_DEF( void )\n-  af_sort_and_quantize_widths( FT_UInt*  count,\n-                               AF_Width  table,\n-                               FT_Pos    threshold )\n-  {\n-    FT_UInt      i, j;\n-    FT_UInt      cur_idx;\n-    FT_Pos       cur_val;\n-    FT_Pos       sum;\n-    AF_WidthRec  swap;\n-\n-\n-    if ( *count == 1 )\n-      return;\n-\n-    \/* sort *\/\n-    for ( i = 1; i < *count; i++ )\n-    {\n-      for ( j = i; j > 0; j-- )\n-      {\n-        if ( table[j].org >= table[j - 1].org )\n-          break;\n-\n-        swap         = table[j];\n-        table[j]     = table[j - 1];\n-        table[j - 1] = swap;\n-      }\n-    }\n-\n-    cur_idx = 0;\n-    cur_val = table[cur_idx].org;\n-\n-    \/* compute and use mean values for clusters not larger than  *\/\n-    \/* `threshold'; this is very primitive and might not yield   *\/\n-    \/* the best result, but normally, using reference character  *\/\n-    \/* `o', `*count' is 2, so the code below is fully sufficient *\/\n-    for ( i = 1; i < *count; i++ )\n-    {\n-      if ( table[i].org - cur_val > threshold ||\n-           i == *count - 1                    )\n-      {\n-        sum = 0;\n-\n-        \/* fix loop for end of array *\/\n-        if ( table[i].org - cur_val <= threshold &&\n-             i == *count - 1                     )\n-          i++;\n-\n-        for ( j = cur_idx; j < i; j++ )\n-        {\n-          sum         += table[j].org;\n-          table[j].org = 0;\n-        }\n-        table[cur_idx].org = sum \/ (FT_Pos)j;\n-\n-        if ( i < *count - 1 )\n-        {\n-          cur_idx = i + 1;\n-          cur_val = table[cur_idx].org;\n-        }\n-      }\n-    }\n-\n-    cur_idx = 1;\n-\n-    \/* compress array to remove zero values *\/\n-    for ( i = 1; i < *count; i++ )\n-    {\n-      if ( table[i].org )\n-        table[cur_idx++] = table[i];\n-    }\n-\n-    *count = cur_idx;\n-  }\n-\n-\n-\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afangles.c","additions":0,"deletions":285,"binary":false,"changes":285,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-\/*\n- * afangles.h\n- *\n- * This is a dummy file, used to please the build system.  It is never\n- * included by the auto-fitter sources.\n- *\n- *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afangles.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.cin","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-\/\/ Copyright (C) 2013-2020 by\n+\/\/ Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.dat","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afblue.hin","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n@@ -40,5 +40,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-#include \"afwarp.h\"\n-#endif\n-\n-\n@@ -75,4 +70,2 @@\n-    FT_TRACE5(( \"\\n\"\n-                \"cjk standard widths computation (style `%s')\\n\"\n-                \"===================================================\\n\"\n-                \"\\n\",\n+    FT_TRACE5(( \"\\n\" ));\n+    FT_TRACE5(( \"cjk standard widths computation (style `%s')\\n\",\n@@ -80,0 +73,2 @@\n+    FT_TRACE5(( \"===================================================\\n\" ));\n+    FT_TRACE5(( \"\\n\" ));\n@@ -317,3 +312,3 @@\n-    FT_TRACE5(( \"cjk blue zones computation\\n\"\n-                \"==========================\\n\"\n-                \"\\n\" ));\n+    FT_TRACE5(( \"cjk blue zones computation\\n\" ));\n+    FT_TRACE5(( \"==========================\\n\" ));\n+    FT_TRACE5(( \"\\n\" ));\n@@ -558,3 +553,2 @@\n-      FT_TRACE5(( \"    -> reference = %ld\\n\"\n-                  \"       overshoot = %ld\\n\",\n-                  *blue_ref, *blue_shoot ));\n+      FT_TRACE5(( \"    -> reference = %ld\\n\", *blue_ref ));\n+      FT_TRACE5(( \"       overshoot = %ld\\n\", *blue_shoot ));\n@@ -746,3 +740,1 @@\n-        FT_TRACE5(( \">> active cjk blue zone %c%d[%ld\/%ld]:\\n\"\n-                    \"     ref:   cur=%.2f fit=%.2f\\n\"\n-                    \"     shoot: cur=%.2f fit=%.2f\\n\",\n+        FT_TRACE5(( \">> active cjk blue zone %c%d[%ld\/%ld]:\\n\",\n@@ -750,2 +742,4 @@\n-                    nn, blue->ref.org, blue->shoot.org,\n-                    blue->ref.cur \/ 64.0, blue->ref.fit \/ 64.0,\n+                    nn, blue->ref.org, blue->shoot.org ));\n+        FT_TRACE5(( \"     ref:   cur=%.2f fit=%.2f\\n\",\n+                    blue->ref.cur \/ 64.0, blue->ref.fit \/ 64.0 ));\n+        FT_TRACE5(( \"     shoot: cur=%.2f fit=%.2f\\n\",\n@@ -852,1 +846,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -1014,1 +1008,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -1162,1 +1156,1 @@\n-      AF_Edge  edge_limit = edges + axis->num_edges;\n+      AF_Edge  edge_limit = FT_OFFSET( edges, axis->num_edges );\n@@ -1300,1 +1294,1 @@\n-    AF_Edge       edge_limit = edge + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edge, axis->num_edges );\n@@ -1404,5 +1398,0 @@\n-#if 0 \/* AF_CONFIG_OPTION_USE_WARPER *\/\n-    if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )\n-      metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;\n-#endif\n-\n@@ -1437,6 +1426,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    \/* get (global) warper flag *\/\n-    if ( !metrics->root.globals->module->warping )\n-      scaler_flags |= AF_SCALER_FLAG_NO_WARPER;\n-#endif\n-\n@@ -1818,1 +1801,1 @@\n-    AF_Edge       edge_limit = edges + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edges, axis->num_edges );\n@@ -2197,1 +2180,1 @@\n-    AF_Edge       edge_limit = edges + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edges, axis->num_edges );\n@@ -2325,19 +2308,0 @@\n-\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-        if ( dim == AF_DIMENSION_HORZ                                  &&\n-             metrics->root.scaler.render_mode == FT_RENDER_MODE_NORMAL &&\n-             AF_HINTS_DO_WARP( hints )                                 )\n-        {\n-          AF_WarperRec  warper;\n-          FT_Fixed      scale;\n-          FT_Pos        delta;\n-\n-\n-          af_warper_compute( &warper, hints, (AF_Dimension)dim,\n-                             &scale, &delta );\n-          af_glyph_hints_scale_dim( hints, (AF_Dimension)dim,\n-                                    scale, delta );\n-          continue;\n-        }\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afcjk.c","additions":21,"deletions":57,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afcjk.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afcover.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afdummy.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afdummy.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2020 by\n+ * Copyright (C) 2005-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aferrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n@@ -22,0 +22,1 @@\n+#include \"afws-decl.h\"\n@@ -35,5 +36,0 @@\n-  \/* get writing system specific header files *\/\n-#undef  WRITING_SYSTEM\n-#define WRITING_SYSTEM( ws, WS )  \/* empty *\/\n-#include \"afwrtsys.h\"\n-\n@@ -77,1 +73,1 @@\n-#include \"afwrtsys.h\"\n+#include \"afws-iter.h\"\n@@ -288,4 +284,4 @@\n-    FT_TRACE4(( \"\\n\"\n-                \"style coverage\\n\"\n-                \"==============\\n\"\n-                \"\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n+    FT_TRACE4(( \"style coverage\\n\" ));\n+    FT_TRACE4(( \"==============\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n@@ -344,3 +340,3 @@\n-    if ( FT_ALLOC( globals,\n-                   sizeof ( *globals ) +\n-                     (FT_ULong)face->num_glyphs * sizeof ( FT_UShort ) ) )\n+    if ( FT_QALLOC( globals,\n+                    sizeof ( *globals ) +\n+                      (FT_ULong)face->num_glyphs * sizeof ( FT_UShort ) ) )\n@@ -349,0 +345,2 @@\n+    FT_ZERO( &globals->metrics );\n+\n@@ -481,0 +479,4 @@\n+            \/* IMPORTANT: Clear the error code, see\n+             * https:\/\/gitlab.freedesktop.org\/freetype\/freetype\/-\/issues\/1063\n+             *\/\n+            error = FT_Err_Ok;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afglobal.c","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afglobal.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n@@ -35,0 +35,98 @@\n+  FT_LOCAL_DEF( void )\n+  af_sort_pos( FT_UInt  count,\n+               FT_Pos*  table )\n+  {\n+    FT_UInt  i, j;\n+    FT_Pos   swap;\n+\n+\n+    for ( i = 1; i < count; i++ )\n+    {\n+      for ( j = i; j > 0; j-- )\n+      {\n+        if ( table[j] >= table[j - 1] )\n+          break;\n+\n+        swap         = table[j];\n+        table[j]     = table[j - 1];\n+        table[j - 1] = swap;\n+      }\n+    }\n+  }\n+\n+\n+  FT_LOCAL_DEF( void )\n+  af_sort_and_quantize_widths( FT_UInt*  count,\n+                               AF_Width  table,\n+                               FT_Pos    threshold )\n+  {\n+    FT_UInt      i, j;\n+    FT_UInt      cur_idx;\n+    FT_Pos       cur_val;\n+    FT_Pos       sum;\n+    AF_WidthRec  swap;\n+\n+\n+    if ( *count == 1 )\n+      return;\n+\n+    \/* sort *\/\n+    for ( i = 1; i < *count; i++ )\n+    {\n+      for ( j = i; j > 0; j-- )\n+      {\n+        if ( table[j].org >= table[j - 1].org )\n+          break;\n+\n+        swap         = table[j];\n+        table[j]     = table[j - 1];\n+        table[j - 1] = swap;\n+      }\n+    }\n+\n+    cur_idx = 0;\n+    cur_val = table[cur_idx].org;\n+\n+    \/* compute and use mean values for clusters not larger than  *\/\n+    \/* `threshold'; this is very primitive and might not yield   *\/\n+    \/* the best result, but normally, using reference character  *\/\n+    \/* `o', `*count' is 2, so the code below is fully sufficient *\/\n+    for ( i = 1; i < *count; i++ )\n+    {\n+      if ( table[i].org - cur_val > threshold ||\n+           i == *count - 1                    )\n+      {\n+        sum = 0;\n+\n+        \/* fix loop for end of array *\/\n+        if ( table[i].org - cur_val <= threshold &&\n+             i == *count - 1                     )\n+          i++;\n+\n+        for ( j = cur_idx; j < i; j++ )\n+        {\n+          sum         += table[j].org;\n+          table[j].org = 0;\n+        }\n+        table[cur_idx].org = sum \/ (FT_Pos)j;\n+\n+        if ( i < *count - 1 )\n+        {\n+          cur_idx = i + 1;\n+          cur_val = table[cur_idx].org;\n+        }\n+      }\n+    }\n+\n+    cur_idx = 1;\n+\n+    \/* compress array to remove zero values *\/\n+    for ( i = 1; i < *count; i++ )\n+    {\n+      if ( table[i].org )\n+        table[cur_idx++] = table[i];\n+    }\n+\n+    *count = cur_idx;\n+  }\n+\n@@ -767,1 +865,1 @@\n-    FT_UInt    old_max, new_max;\n+    FT_Int     old_max, new_max;\n@@ -784,2 +882,2 @@\n-    new_max = (FT_UInt)outline->n_contours;\n-    old_max = (FT_UInt)hints->max_contours;\n+    new_max = outline->n_contours;\n+    old_max = hints->max_contours;\n@@ -800,1 +898,1 @@\n-      new_max = ( new_max + 3 ) & ~3U; \/* round up to a multiple of 4 *\/\n+      new_max = ( new_max + 3 ) & ~3; \/* round up to a multiple of 4 *\/\n@@ -805,1 +903,1 @@\n-      hints->max_contours = (FT_Int)new_max;\n+      hints->max_contours = new_max;\n@@ -813,2 +911,2 @@\n-    new_max = (FT_UInt)( outline->n_points + 2 );\n-    old_max = (FT_UInt)hints->max_points;\n+    new_max = outline->n_points + 2;\n+    old_max = hints->max_points;\n@@ -829,1 +927,1 @@\n-      new_max = ( new_max + 2 + 7 ) & ~7U; \/* round up to a multiple of 8 *\/\n+      new_max = ( new_max + 2 + 7 ) & ~7; \/* round up to a multiple of 8 *\/\n@@ -834,1 +932,1 @@\n-      hints->max_points = (FT_Int)new_max;\n+      hints->max_points = new_max;\n@@ -858,3 +956,0 @@\n-    hints->xmin_delta = 0;\n-    hints->xmax_delta = 0;\n-\n@@ -1224,1 +1319,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -1301,1 +1396,1 @@\n-    AF_Edge       edge_limit  = edges + axis->num_edges;\n+    AF_Edge       edge_limit  = FT_OFFSET( edges, axis->num_edges );\n@@ -1691,29 +1786,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-\n-  \/* Apply (small) warp scale and warp delta for given dimension. *\/\n-\n-  FT_LOCAL_DEF( void )\n-  af_glyph_hints_scale_dim( AF_GlyphHints  hints,\n-                            AF_Dimension   dim,\n-                            FT_Fixed       scale,\n-                            FT_Pos         delta )\n-  {\n-    AF_Point  points       = hints->points;\n-    AF_Point  points_limit = points + hints->num_points;\n-    AF_Point  point;\n-\n-\n-    if ( dim == AF_DIMENSION_HORZ )\n-    {\n-      for ( point = points; point < points_limit; point++ )\n-        point->x = FT_MulFix( point->fx, scale ) + delta;\n-    }\n-    else\n-    {\n-      for ( point = points; point < points_limit; point++ )\n-        point->y = FT_MulFix( point->fy, scale ) + delta;\n-    }\n-  }\n-\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afhints.c","additions":110,"deletions":44,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n@@ -365,3 +365,0 @@\n-    FT_Pos           xmin_delta;    \/* used for warping *\/\n-    FT_Pos           xmax_delta;\n-\n@@ -411,4 +408,0 @@\n-#define AF_HINTS_DO_WARP( h )                                  \\\n-          !AF_HINTS_TEST_SCALER( h, AF_SCALER_FLAG_NO_WARPER )\n-\n-\n@@ -462,8 +455,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-  FT_LOCAL( void )\n-  af_glyph_hints_scale_dim( AF_GlyphHints  hints,\n-                            AF_Dimension   dim,\n-                            FT_Fixed       scale,\n-                            FT_Pos         delta );\n-#endif\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afhints.h","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2022 by\n@@ -30,5 +30,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-#include \"afwarp.h\"\n-#endif\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afindic.c","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afindic.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n@@ -27,5 +27,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-#include \"afwarp.h\"\n-#endif\n-\n-\n@@ -66,4 +61,2 @@\n-    FT_TRACE5(( \"\\n\"\n-                \"latin standard widths computation (style `%s')\\n\"\n-                \"=====================================================\\n\"\n-                \"\\n\",\n+    FT_TRACE5(( \"\\n\" ));\n+    FT_TRACE5(( \"latin standard widths computation (style `%s')\\n\",\n@@ -71,0 +64,2 @@\n+    FT_TRACE5(( \"=====================================================\\n\" ));\n+    FT_TRACE5(( \"\\n\" ));\n@@ -208,1 +203,1 @@\n-        limit = seg + axhints->num_segments;\n+        limit = FT_OFFSET( seg, axhints->num_segments );\n@@ -353,3 +348,3 @@\n-    FT_TRACE5(( \"latin blue zones computation\\n\"\n-                \"============================\\n\"\n-                \"\\n\" ));\n+    FT_TRACE5(( \"latin blue zones computation\\n\" ));\n+    FT_TRACE5(( \"============================\\n\" ));\n+    FT_TRACE5(( \"\\n\" ));\n@@ -979,3 +974,2 @@\n-      FT_TRACE5(( \"    -> reference = %ld\\n\"\n-                  \"       overshoot = %ld\\n\",\n-                  *blue_ref, *blue_shoot ));\n+      FT_TRACE5(( \"    -> reference = %ld\\n\", *blue_ref ));\n+      FT_TRACE5(( \"       overshoot = %ld\\n\", *blue_shoot ));\n@@ -1278,10 +1272,10 @@\n-              FT_TRACE5((\n-                \"af_latin_metrics_scale_dim:\"\n-                \" x height alignment (style `%s'):\\n\"\n-                \"                           \"\n-                \" vertical scaling changed from %.5f to %.5f (by %ld%%)\\n\"\n-                \"\\n\",\n-                af_style_names[metrics->root.style_class->style],\n-                scale \/ 65536.0,\n-                new_scale \/ 65536.0,\n-                ( fitted - scaled ) * 100 \/ scaled ));\n+              FT_TRACE5(( \"af_latin_metrics_scale_dim:\"\n+                          \" x height alignment (style `%s'):\\n\",\n+                          af_style_names[metrics->root.style_class->style] ));\n+              FT_TRACE5(( \"                           \"\n+                          \" vertical scaling changed\"\n+                          \" from %.5f to %.5f (by %ld%%)\\n\",\n+                          scale \/ 65536.0,\n+                          new_scale \/ 65536.0,\n+                          ( fitted - scaled ) * 100 \/ scaled ));\n+              FT_TRACE5(( \"\\n\" ));\n@@ -1294,7 +1288,6 @@\n-              FT_TRACE5((\n-                \"af_latin_metrics_scale_dim:\"\n-                \" x height alignment (style `%s'):\\n\"\n-                \"                           \"\n-                \" excessive vertical scaling abandoned\\n\"\n-                \"\\n\",\n-                af_style_names[metrics->root.style_class->style] ));\n+              FT_TRACE5(( \"af_latin_metrics_scale_dim:\"\n+                          \" x height alignment (style `%s'):\\n\",\n+                          af_style_names[metrics->root.style_class->style] ));\n+              FT_TRACE5(( \"                           \"\n+                          \" excessive vertical scaling abandoned\\n\" ));\n+              FT_TRACE5(( \"\\n\" ));\n@@ -1349,2 +1342,2 @@\n-      FT_TRACE5(( \"`%s' style is extra light (at current resolution)\\n\"\n-                  \"\\n\",\n+    {\n+      FT_TRACE5(( \"`%s' style is extra light (at current resolution)\\n\",\n@@ -1352,0 +1345,2 @@\n+      FT_TRACE5(( \"\\n\" ));\n+    }\n@@ -1476,2 +1471,1 @@\n-        FT_TRACE5(( \"  reference %d: %ld scaled to %.2f%s\\n\"\n-                    \"  overshoot %d: %ld scaled to %.2f%s\\n\",\n+        FT_TRACE5(( \"  reference %d: %ld scaled to %.2f%s\\n\",\n@@ -1482,1 +1476,2 @@\n-                                                           : \" (inactive)\",\n+                                                           : \" (inactive)\" ));\n+        FT_TRACE5(( \"  overshoot %d: %ld scaled to %.2f%s\\n\",\n@@ -1850,0 +1845,25 @@\n+          \/*\n+           * For efficiency, we restrict the number of segments to 1000,\n+           * which is a heuristic value: it is very unlikely that a glyph\n+           * with so many segments can be hinted in a sensible way.\n+           * Reasons:\n+           *\n+           * - The glyph has really 1000 segments; this implies that it has\n+           *   at least 2000 outline points.  Assuming 'normal' fonts that\n+           *   have superfluous points optimized away, viewing such a glyph\n+           *   only makes sense at large magnifications where hinting\n+           *   isn't applied anyway.\n+           *\n+           * - We have a broken glyph.  Hinting doesn't make sense in this\n+           *   case either.\n+           *\/\n+          if ( axis->num_segments > 1000 )\n+          {\n+            FT_TRACE0(( \"af_latin_hints_compute_segments:\"\n+                        \" more than 1000 segments in this glyph;\\n\" ));\n+            FT_TRACE0(( \"                                \"\n+                        \" hinting is suppressed\\n\" ));\n+            axis->num_segments = 0;\n+            return FT_Err_Ok;\n+          }\n+\n@@ -1972,1 +1992,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -2092,1 +2112,1 @@\n-          seg1->link  = 0;\n+          seg1->link  = NULL;\n@@ -2117,1 +2137,1 @@\n-    AF_Segment    segment_limit = segments + axis->num_segments;\n+    AF_Segment    segment_limit = FT_OFFSET( segments, axis->num_segments );\n@@ -2483,1 +2503,1 @@\n-    AF_Edge       edge_limit = edge + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edge, axis->num_edges );\n@@ -2614,5 +2634,0 @@\n-#if 0 \/* #ifdef AF_CONFIG_OPTION_USE_WARPER *\/\n-    if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )\n-      metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;\n-#endif\n-\n@@ -2656,6 +2671,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    \/* get (global) warper flag *\/\n-    if ( !metrics->root.globals->module->warping )\n-      scaler_flags |= AF_SCALER_FLAG_NO_WARPER;\n-#endif\n-\n@@ -2987,1 +2996,1 @@\n-    AF_Edge       edge_limit = edges + axis->num_edges;\n+    AF_Edge       edge_limit = FT_OFFSET( edges, axis->num_edges );\n@@ -3578,18 +3587,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-      if ( dim == AF_DIMENSION_HORZ                                  &&\n-           metrics->root.scaler.render_mode == FT_RENDER_MODE_NORMAL &&\n-           AF_HINTS_DO_WARP( hints )                                 )\n-      {\n-        AF_WarperRec  warper;\n-        FT_Fixed      scale;\n-        FT_Pos        delta;\n-\n-\n-        af_warper_compute( &warper, hints, (AF_Dimension)dim,\n-                           &scale, &delta );\n-        af_glyph_hints_scale_dim( hints, (AF_Dimension)dim,\n-                                  scale, delta );\n-        continue;\n-      }\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aflatin.c","additions":64,"deletions":73,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aflatin.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n@@ -108,1 +108,0 @@\n-    FT_Fixed  em_ratio = FT_DivFix( af_intToFixed( 1000 ), em_size );\n@@ -145,6 +144,5 @@\n-        af_intToFixed( af_loader_compute_darkening( loader,\n-                                                    face,\n-                                                    stdVW ) );\n-      darken_x = FT_DivFix( FT_MulFix( darken_by_font_units_x,\n-                                       size_metrics->x_scale ),\n-                            em_ratio );\n+         af_loader_compute_darkening( loader,\n+                                      face,\n+                                      stdVW ) ;\n+      darken_x = FT_MulFix( darken_by_font_units_x,\n+                            size_metrics->x_scale );\n@@ -164,6 +162,5 @@\n-        af_intToFixed( af_loader_compute_darkening( loader,\n-                                                    face,\n-                                                    stdHW ) );\n-      darken_y = FT_DivFix( FT_MulFix( darken_by_font_units_y,\n-                                       size_metrics->y_scale ),\n-                            em_ratio );\n+         af_loader_compute_darkening( loader,\n+                                      face,\n+                                      stdHW ) ;\n+      darken_y = FT_MulFix( darken_by_font_units_y,\n+                            size_metrics->y_scale );\n@@ -303,6 +300,0 @@\n-#ifdef FT_OPTION_AUTOFIT2\n-    \/* XXX: undocumented hook to activate the latin2 writing system. *\/\n-    if ( load_flags & ( 1UL << 20 ) )\n-      style_options = AF_STYLE_LTN2_DFLT;\n-#endif\n-\n@@ -485,2 +476,2 @@\n-          loader->pp1.x = FT_PIX_ROUND( pp1x + hints->xmin_delta );\n-          loader->pp2.x = FT_PIX_ROUND( pp2x + hints->xmax_delta );\n+          loader->pp1.x = FT_PIX_ROUND( pp1x );\n+          loader->pp2.x = FT_PIX_ROUND( pp2x );\n@@ -597,1 +588,1 @@\n-  FT_LOCAL_DEF( FT_Int32 )\n+  FT_LOCAL_DEF( FT_Fixed )\n@@ -716,1 +707,1 @@\n-    return af_fixedToInt( FT_DivFix( darken_amount, em_ratio ) );\n+    return FT_DivFix( darken_amount, em_ratio );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afloader.c","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n@@ -78,1 +78,1 @@\n-  FT_LOCAL_DEF( FT_Int32 )\n+  FT_LOCAL_DEF( FT_Fixed )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afloader.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n@@ -51,1 +51,1 @@\n-  AF_GlyphHintsRec  _af_debug_hints_rec[1];\n+  static AF_GlyphHintsRec  _af_debug_hints_rec[1];\n@@ -151,1 +151,1 @@\n-        FT_TRACE0(( \"af_property_set: Invalid value %d for property `%s'\\n\",\n+        FT_TRACE2(( \"af_property_set: Invalid value %d for property `%s'\\n\",\n@@ -193,29 +193,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    else if ( !ft_strcmp( property_name, \"warping\" ) )\n-    {\n-#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES\n-      if ( value_is_string )\n-      {\n-        const char*  s = (const char*)value;\n-        long         w = ft_strtol( s, NULL, 10 );\n-\n-\n-        if ( w == 0 )\n-          module->warping = 0;\n-        else if ( w == 1 )\n-          module->warping = 1;\n-        else\n-          return FT_THROW( Invalid_Argument );\n-      }\n-      else\n-#endif\n-      {\n-        FT_Bool*  warping = (FT_Bool*)value;\n-\n-\n-        module->warping = *warping;\n-      }\n-\n-      return error;\n-    }\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n@@ -310,1 +281,1 @@\n-    FT_TRACE0(( \"af_property_set: missing property `%s'\\n\",\n+    FT_TRACE2(( \"af_property_set: missing property `%s'\\n\",\n@@ -325,3 +296,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    FT_Bool    warping        = module->warping;\n-#endif\n@@ -374,11 +342,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    else if ( !ft_strcmp( property_name, \"warping\" ) )\n-    {\n-      FT_Bool*  val = (FT_Bool*)value;\n-\n-\n-      *val = warping;\n-\n-      return error;\n-    }\n-#endif \/* AF_CONFIG_OPTION_USE_WARPER *\/\n@@ -413,1 +370,1 @@\n-    FT_TRACE0(( \"af_property_get: missing property `%s'\\n\",\n+    FT_TRACE2(( \"af_property_get: missing property `%s'\\n\",\n@@ -450,3 +407,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    module->warping           = 0;\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afmodule.c","additions":5,"deletions":51,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n@@ -40,3 +40,0 @@\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-    FT_Bool       warping;\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afmodule.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afranges.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afranges.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afscript.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n@@ -135,3 +135,15 @@\n-    hb_ot_tags_from_script( script,\n-                            &script_tags[0],\n-                            &script_tags[1] );\n+    {\n+      unsigned int  tags_count = 3;\n+      hb_tag_t      tags[3];\n+\n+\n+      hb_ot_tags_from_script_and_language( script,\n+                                           HB_LANGUAGE_INVALID,\n+                                           &tags_count,\n+                                           tags,\n+                                           NULL,\n+                                           NULL );\n+      script_tags[0] = tags_count > 0 ? tags[0] : HB_TAG_NONE;\n+      script_tags[1] = tags_count > 1 ? tags[1] : HB_TAG_NONE;\n+      script_tags[2] = tags_count > 2 ? tags[2] : HB_TAG_NONE;\n+    }\n@@ -139,3 +151,2 @@\n-    \/* `hb_ot_tags_from_script' usually returns HB_OT_TAG_DEFAULT_SCRIPT *\/\n-    \/* as the second tag.  We change that to HB_TAG_NONE except for the  *\/\n-    \/* default script.                                                   *\/\n+    \/* If the second tag is HB_OT_TAG_DEFAULT_SCRIPT, change that to     *\/\n+    \/* HB_TAG_NONE except for the default script.                        *\/\n@@ -160,3 +171,0 @@\n-\n-      if ( script_tags[1] == HB_OT_TAG_DEFAULT_SCRIPT )\n-        script_tags[1] = HB_TAG_NONE;\n@@ -176,2 +184,1 @@\n-    FT_TRACE4(( \"GSUB lookups (style `%s'):\\n\"\n-                \" \",\n+    FT_TRACE4(( \"GSUB lookups (style `%s'):\\n\",\n@@ -179,0 +186,1 @@\n+    FT_TRACE4(( \" \" ));\n@@ -205,1 +213,2 @@\n-    FT_TRACE4(( \"\\n\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n@@ -208,2 +217,1 @@\n-    FT_TRACE4(( \"GPOS lookups (style `%s'):\\n\"\n-                \" \",\n+    FT_TRACE4(( \"GPOS lookups (style `%s'):\\n\",\n@@ -211,0 +219,1 @@\n+    FT_TRACE4(( \" \" ));\n@@ -245,1 +254,2 @@\n-    FT_TRACE4(( \"\\n\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n@@ -356,2 +366,4 @@\n-        FT_TRACE4(( \"\\n\"\n-                    \"   \" ));\n+      {\n+        FT_TRACE4(( \"\\n\" ));\n+        FT_TRACE4(( \"   \" ));\n+      }\n@@ -379,3 +391,6 @@\n-      FT_TRACE4(( \"\\n\"\n-                  \"    (none)\" ));\n-    FT_TRACE4(( \"\\n\\n\" ));\n+    {\n+      FT_TRACE4(( \"\\n\" ));\n+      FT_TRACE4(( \"    (none)\" ));\n+    }\n+    FT_TRACE4(( \"\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afshaper.c","additions":36,"deletions":21,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afshaper.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n@@ -302,9 +302,0 @@\n-#ifdef FT_OPTION_AUTOFIT2\n-  STYLE( ltn2_dflt, LTN2_DFLT,\n-         \"Latin 2 default style\",\n-         AF_WRITING_SYSTEM_LATIN2,\n-         AF_SCRIPT_LATN,\n-         AF_BLUE_STRINGSET_LATN,\n-         AF_COVERAGE_DEFAULT )\n-#endif\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afstyles.h","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n@@ -95,57 +95,0 @@\n-  \/*************************************************************************\/\n-  \/*************************************************************************\/\n-  \/*****                                                               *****\/\n-  \/*****                   A N G L E   T Y P E S                       *****\/\n-  \/*****                                                               *****\/\n-  \/*************************************************************************\/\n-  \/*************************************************************************\/\n-\n-  \/*\n-   * The auto-fitter doesn't need a very high angular accuracy;\n-   * this allows us to speed up some computations considerably with a\n-   * light Cordic algorithm (see afangles.c).\n-   *\/\n-\n-  typedef FT_Int  AF_Angle;\n-\n-\n-#define AF_ANGLE_PI   256\n-#define AF_ANGLE_2PI  ( AF_ANGLE_PI * 2 )\n-#define AF_ANGLE_PI2  ( AF_ANGLE_PI \/ 2 )\n-#define AF_ANGLE_PI4  ( AF_ANGLE_PI \/ 4 )\n-\n-\n-#if 0\n-  \/*\n-   * compute the angle of a given 2-D vector\n-   *\/\n-  FT_LOCAL( AF_Angle )\n-  af_angle_atan( FT_Pos  dx,\n-                 FT_Pos  dy );\n-\n-\n-  \/*\n-   * compute `angle2 - angle1'; the result is always within\n-   * the range [-AF_ANGLE_PI .. AF_ANGLE_PI - 1]\n-   *\/\n-  FT_LOCAL( AF_Angle )\n-  af_angle_diff( AF_Angle  angle1,\n-                 AF_Angle  angle2 );\n-#endif \/* 0 *\/\n-\n-\n-#define AF_ANGLE_DIFF( result, angle1, angle2 ) \\\n-  FT_BEGIN_STMNT                                \\\n-    AF_Angle  _delta = (angle2) - (angle1);     \\\n-                                                \\\n-                                                \\\n-    while ( _delta <= -AF_ANGLE_PI )            \\\n-      _delta += AF_ANGLE_2PI;                   \\\n-                                                \\\n-    while ( _delta > AF_ANGLE_PI )              \\\n-      _delta -= AF_ANGLE_2PI;                   \\\n-                                                \\\n-    result = _delta;                            \\\n-  FT_END_STMNT\n-\n-\n@@ -175,1 +118,0 @@\n-#define AF_SCALER_FLAG_NO_WARPER      8U \/* disable warper             *\/\n@@ -259,1 +201,0 @@\n-#define AFWRTSYS_H_  \/* don't load header files *\/\n@@ -268,1 +209,1 @@\n-#include \"afwrtsys.h\"\n+#include \"afws-iter.h\"\n@@ -274,2 +215,0 @@\n-#undef  AFWRTSYS_H_\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/aftypes.h","additions":2,"deletions":63,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1,373 +0,0 @@\n-\/****************************************************************************\n- *\n- * afwarp.c\n- *\n- *   Auto-fitter warping algorithm (body).\n- *\n- * Copyright (C) 2006-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n- *\n- * This file is part of the FreeType project, and may only be used,\n- * modified, and distributed under the terms of the FreeType project\n- * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n- * this file you indicate that you have read the license and\n- * understand and accept it fully.\n- *\n- *\/\n-\n-\n-  \/*\n-   * The idea of the warping code is to slightly scale and shift a glyph\n-   * within a single dimension so that as much of its segments are aligned\n-   * (more or less) on the grid.  To find out the optimal scaling and\n-   * shifting value, various parameter combinations are tried and scored.\n-   *\/\n-\n-#include \"afwarp.h\"\n-\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-\n-  \/**************************************************************************\n-   *\n-   * The macro FT_COMPONENT is used in trace mode.  It is an implicit\n-   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print\/log\n-   * messages during execution.\n-   *\/\n-#undef  FT_COMPONENT\n-#define FT_COMPONENT  afwarp\n-\n-\n-  \/* The weights cover the range 0\/64 - 63\/64 of a pixel.  Obviously, *\/\n-  \/* values around a half pixel (which means exactly between two grid *\/\n-  \/* lines) gets the worst weight.                                    *\/\n-#if 1\n-  static const AF_WarpScore\n-  af_warper_weights[64] =\n-  {\n-    35, 32, 30, 25, 20, 15, 12, 10,  5,  1,  0,  0,  0,  0,  0,  0,\n-     0,  0,  0,  0,  0,  0, -1, -2, -5, -8,-10,-10,-20,-20,-30,-30,\n-\n-   -30,-30,-20,-20,-10,-10, -8, -5, -2, -1,  0,  0,  0,  0,  0,  0,\n-     0,  0,  0,  0,  0,  0,  0,  1,  5, 10, 12, 15, 20, 25, 30, 32,\n-  };\n-#else\n-  static const AF_WarpScore\n-  af_warper_weights[64] =\n-  {\n-    30, 20, 10,  5,  4,  4,  3,  2,  1,  0,  0,  0,  0,  0,  0,  0,\n-     0,  0,  0,  0,  0,  0,  0, -1, -2, -2, -5, -5,-10,-10,-15,-20,\n-\n-   -20,-15,-15,-10,-10, -5, -5, -2, -2, -1,  0,  0,  0,  0,  0,  0,\n-     0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  4,  5, 10, 20,\n-  };\n-#endif\n-\n-\n-  \/* Score segments for a given `scale' and `delta' in the range *\/\n-  \/* `xx1' to `xx2', and store the best result in `warper'.  If  *\/\n-  \/* the new best score is equal to the old one, prefer the      *\/\n-  \/* value with a smaller distortion (around `base_distort').    *\/\n-\n-  static void\n-  af_warper_compute_line_best( AF_Warper     warper,\n-                               FT_Fixed      scale,\n-                               FT_Pos        delta,\n-                               FT_Pos        xx1,\n-                               FT_Pos        xx2,\n-                               AF_WarpScore  base_distort,\n-                               AF_Segment    segments,\n-                               FT_Int        num_segments )\n-  {\n-    FT_Int        idx_min, idx_max, idx0;\n-    FT_Int        nn;\n-    AF_WarpScore  scores[65];\n-\n-\n-    for ( nn = 0; nn < 65; nn++ )\n-      scores[nn] = 0;\n-\n-    idx0 = xx1 - warper->t1;\n-\n-    \/* compute minimum and maximum indices *\/\n-    {\n-      FT_Pos  xx1min = warper->x1min;\n-      FT_Pos  xx1max = warper->x1max;\n-      FT_Pos  w      = xx2 - xx1;\n-\n-\n-      if ( xx1min + w < warper->x2min )\n-        xx1min = warper->x2min - w;\n-\n-      if ( xx1max + w > warper->x2max )\n-        xx1max = warper->x2max - w;\n-\n-      idx_min = xx1min - warper->t1;\n-      idx_max = xx1max - warper->t1;\n-\n-      if ( idx_min < 0 || idx_min > idx_max || idx_max > 64 )\n-      {\n-        FT_TRACE5(( \"invalid indices:\\n\"\n-                    \"  min=%d max=%d, xx1=%ld xx2=%ld,\\n\"\n-                    \"  x1min=%ld x1max=%ld, x2min=%ld x2max=%ld\\n\",\n-                    idx_min, idx_max, xx1, xx2,\n-                    warper->x1min, warper->x1max,\n-                    warper->x2min, warper->x2max ));\n-        return;\n-      }\n-    }\n-\n-    for ( nn = 0; nn < num_segments; nn++ )\n-    {\n-      FT_Pos  len = segments[nn].max_coord - segments[nn].min_coord;\n-      FT_Pos  y0  = FT_MulFix( segments[nn].pos, scale ) + delta;\n-      FT_Pos  y   = y0 + ( idx_min - idx0 );\n-      FT_Int  idx;\n-\n-\n-      \/* score the length of the segments for the given range *\/\n-      for ( idx = idx_min; idx <= idx_max; idx++, y++ )\n-        scores[idx] += af_warper_weights[y & 63] * len;\n-    }\n-\n-    \/* find best score *\/\n-    {\n-      FT_Int  idx;\n-\n-\n-      for ( idx = idx_min; idx <= idx_max; idx++ )\n-      {\n-        AF_WarpScore  score = scores[idx];\n-        AF_WarpScore  distort = base_distort + ( idx - idx0 );\n-\n-\n-        if ( score > warper->best_score         ||\n-             ( score == warper->best_score    &&\n-               distort < warper->best_distort ) )\n-        {\n-          warper->best_score   = score;\n-          warper->best_distort = distort;\n-          warper->best_scale   = scale;\n-          warper->best_delta   = delta + ( idx - idx0 );\n-        }\n-      }\n-    }\n-  }\n-\n-\n-  \/* Compute optimal scaling and delta values for a given glyph and *\/\n-  \/* dimension.                                                     *\/\n-\n-  FT_LOCAL_DEF( void )\n-  af_warper_compute( AF_Warper      warper,\n-                     AF_GlyphHints  hints,\n-                     AF_Dimension   dim,\n-                     FT_Fixed      *a_scale,\n-                     FT_Pos        *a_delta )\n-  {\n-    AF_AxisHints  axis;\n-    AF_Point      points;\n-\n-    FT_Fixed      org_scale;\n-    FT_Pos        org_delta;\n-\n-    FT_Int        nn, num_points, num_segments;\n-    FT_Int        X1, X2;\n-    FT_Int        w;\n-\n-    AF_WarpScore  base_distort;\n-    AF_Segment    segments;\n-\n-\n-    \/* get original scaling transformation *\/\n-    if ( dim == AF_DIMENSION_VERT )\n-    {\n-      org_scale = hints->y_scale;\n-      org_delta = hints->y_delta;\n-    }\n-    else\n-    {\n-      org_scale = hints->x_scale;\n-      org_delta = hints->x_delta;\n-    }\n-\n-    warper->best_scale   = org_scale;\n-    warper->best_delta   = org_delta;\n-    warper->best_score   = FT_INT_MIN;\n-    warper->best_distort = 0;\n-\n-    axis         = &hints->axis[dim];\n-    segments     = axis->segments;\n-    num_segments = axis->num_segments;\n-    points       = hints->points;\n-    num_points   = hints->num_points;\n-\n-    *a_scale = org_scale;\n-    *a_delta = org_delta;\n-\n-    \/* get X1 and X2, minimum and maximum in original coordinates *\/\n-    if ( num_segments < 1 )\n-      return;\n-\n-#if 1\n-    X1 = X2 = points[0].fx;\n-    for ( nn = 1; nn < num_points; nn++ )\n-    {\n-      FT_Int  X = points[nn].fx;\n-\n-\n-      if ( X < X1 )\n-        X1 = X;\n-      if ( X > X2 )\n-        X2 = X;\n-    }\n-#else\n-    X1 = X2 = segments[0].pos;\n-    for ( nn = 1; nn < num_segments; nn++ )\n-    {\n-      FT_Int  X = segments[nn].pos;\n-\n-\n-      if ( X < X1 )\n-        X1 = X;\n-      if ( X > X2 )\n-        X2 = X;\n-    }\n-#endif\n-\n-    if ( X1 >= X2 )\n-      return;\n-\n-    warper->x1 = FT_MulFix( X1, org_scale ) + org_delta;\n-    warper->x2 = FT_MulFix( X2, org_scale ) + org_delta;\n-\n-    warper->t1 = AF_WARPER_FLOOR( warper->x1 );\n-    warper->t2 = AF_WARPER_CEIL( warper->x2 );\n-\n-    \/* examine a half pixel wide range around the maximum coordinates *\/\n-    warper->x1min = warper->x1 & ~31;\n-    warper->x1max = warper->x1min + 32;\n-    warper->x2min = warper->x2 & ~31;\n-    warper->x2max = warper->x2min + 32;\n-\n-    if ( warper->x1max > warper->x2 )\n-      warper->x1max = warper->x2;\n-\n-    if ( warper->x2min < warper->x1 )\n-      warper->x2min = warper->x1;\n-\n-    warper->w0 = warper->x2 - warper->x1;\n-\n-    if ( warper->w0 <= 64 )\n-    {\n-      warper->x1max = warper->x1;\n-      warper->x2min = warper->x2;\n-    }\n-\n-    \/* examine (at most) a pixel wide range around the natural width *\/\n-    warper->wmin = warper->x2min - warper->x1max;\n-    warper->wmax = warper->x2max - warper->x1min;\n-\n-#if 1\n-    \/* some heuristics to reduce the number of widths to be examined *\/\n-    {\n-      int  margin = 16;\n-\n-\n-      if ( warper->w0 <= 128 )\n-      {\n-         margin = 8;\n-         if ( warper->w0 <= 96 )\n-           margin = 4;\n-      }\n-\n-      if ( warper->wmin < warper->w0 - margin )\n-        warper->wmin = warper->w0 - margin;\n-\n-      if ( warper->wmax > warper->w0 + margin )\n-        warper->wmax = warper->w0 + margin;\n-    }\n-\n-    if ( warper->wmin < warper->w0 * 3 \/ 4 )\n-      warper->wmin = warper->w0 * 3 \/ 4;\n-\n-    if ( warper->wmax > warper->w0 * 5 \/ 4 )\n-      warper->wmax = warper->w0 * 5 \/ 4;\n-#else\n-    \/* no scaling, just translation *\/\n-    warper->wmin = warper->wmax = warper->w0;\n-#endif\n-\n-    for ( w = warper->wmin; w <= warper->wmax; w++ )\n-    {\n-      FT_Fixed  new_scale;\n-      FT_Pos    new_delta;\n-      FT_Pos    xx1, xx2;\n-\n-\n-      \/* compute min and max positions for given width,       *\/\n-      \/* assuring that they stay within the coordinate ranges *\/\n-      xx1 = warper->x1;\n-      xx2 = warper->x2;\n-      if ( w >= warper->w0 )\n-      {\n-        xx1 -= w - warper->w0;\n-        if ( xx1 < warper->x1min )\n-        {\n-          xx2 += warper->x1min - xx1;\n-          xx1  = warper->x1min;\n-        }\n-      }\n-      else\n-      {\n-        xx1 -= w - warper->w0;\n-        if ( xx1 > warper->x1max )\n-        {\n-          xx2 -= xx1 - warper->x1max;\n-          xx1  = warper->x1max;\n-        }\n-      }\n-\n-      if ( xx1 < warper->x1 )\n-        base_distort = warper->x1 - xx1;\n-      else\n-        base_distort = xx1 - warper->x1;\n-\n-      if ( xx2 < warper->x2 )\n-        base_distort += warper->x2 - xx2;\n-      else\n-        base_distort += xx2 - warper->x2;\n-\n-      \/* give base distortion a greater weight while scoring *\/\n-      base_distort *= 10;\n-\n-      new_scale = org_scale + FT_DivFix( w - warper->w0, X2 - X1 );\n-      new_delta = xx1 - FT_MulFix( X1, new_scale );\n-\n-      af_warper_compute_line_best( warper, new_scale, new_delta, xx1, xx2,\n-                                   base_distort,\n-                                   segments, num_segments );\n-    }\n-\n-    {\n-      FT_Fixed  best_scale = warper->best_scale;\n-      FT_Pos    best_delta = warper->best_delta;\n-\n-\n-      hints->xmin_delta = FT_MulFix( X1, best_scale - org_scale )\n-                          + best_delta;\n-      hints->xmax_delta = FT_MulFix( X2, best_scale - org_scale )\n-                          + best_delta;\n-\n-      *a_scale = best_scale;\n-      *a_delta = best_delta;\n-    }\n-  }\n-\n-#else \/* !AF_CONFIG_OPTION_USE_WARPER *\/\n-\n-  \/* ANSI C doesn't like empty source files *\/\n-  typedef int  _af_warp_dummy;\n-\n-#endif \/* !AF_CONFIG_OPTION_USE_WARPER *\/\n-\n-\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afwarp.c","additions":0,"deletions":373,"binary":false,"changes":373,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/****************************************************************************\n- *\n- * afwarp.h\n- *\n- *   Auto-fitter warping algorithm (specification).\n- *\n- * Copyright (C) 2006-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n- *\n- * This file is part of the FreeType project, and may only be used,\n- * modified, and distributed under the terms of the FreeType project\n- * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n- * this file you indicate that you have read the license and\n- * understand and accept it fully.\n- *\n- *\/\n-\n-\n-#ifndef AFWARP_H_\n-#define AFWARP_H_\n-\n-#include \"afhints.h\"\n-\n-FT_BEGIN_HEADER\n-\n-#define AF_WARPER_SCALE\n-\n-#define AF_WARPER_FLOOR( x )  ( (x) & ~FT_TYPEOF( x )63 )\n-#define AF_WARPER_CEIL( x )   AF_WARPER_FLOOR( (x) + 63 )\n-\n-\n-  typedef FT_Int32  AF_WarpScore;\n-\n-  typedef struct  AF_WarperRec_\n-  {\n-    FT_Pos        x1, x2;\n-    FT_Pos        t1, t2;\n-    FT_Pos        x1min, x1max;\n-    FT_Pos        x2min, x2max;\n-    FT_Pos        w0, wmin, wmax;\n-\n-    FT_Fixed      best_scale;\n-    FT_Pos        best_delta;\n-    AF_WarpScore  best_score;\n-    AF_WarpScore  best_distort;\n-\n-  } AF_WarperRec, *AF_Warper;\n-\n-\n-#ifdef AF_CONFIG_OPTION_USE_WARPER\n-  FT_LOCAL( void )\n-  af_warper_compute( AF_Warper      warper,\n-                     AF_GlyphHints  hints,\n-                     AF_Dimension   dim,\n-                     FT_Fixed      *a_scale,\n-                     FT_Pos        *a_delta );\n-#endif\n-\n-\n-FT_END_HEADER\n-\n-\n-#endif \/* AFWARP_H_ *\/\n-\n-\n-\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afwarp.h","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/****************************************************************************\n- *\n- * afwrtsys.h\n- *\n- *   Auto-fitter writing systems (specification only).\n- *\n- * Copyright (C) 2013-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n- *\n- * This file is part of the FreeType project, and may only be used,\n- * modified, and distributed under the terms of the FreeType project\n- * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n- * this file you indicate that you have read the license and\n- * understand and accept it fully.\n- *\n- *\/\n-\n-\n-#ifndef AFWRTSYS_H_\n-#define AFWRTSYS_H_\n-\n-  \/* Since preprocessor directives can't create other preprocessor *\/\n-  \/* directives, we have to include the header files manually.     *\/\n-\n-#include \"afdummy.h\"\n-#include \"aflatin.h\"\n-#include \"afcjk.h\"\n-#include \"afindic.h\"\n-#ifdef FT_OPTION_AUTOFIT2\n-#include \"aflatin2.h\"\n-#endif\n-\n-#endif \/* AFWRTSYS_H_ *\/\n-\n-\n-  \/* The following part can be included multiple times. *\/\n-  \/* Define `WRITING_SYSTEM' as needed.                 *\/\n-\n-\n-  \/* Add new writing systems here.  The arguments are the writing system *\/\n-  \/* name in lowercase and uppercase, respectively.                      *\/\n-\n-  WRITING_SYSTEM( dummy,  DUMMY  )\n-  WRITING_SYSTEM( latin,  LATIN  )\n-  WRITING_SYSTEM( cjk,    CJK    )\n-  WRITING_SYSTEM( indic,  INDIC  )\n-#ifdef FT_OPTION_AUTOFIT2\n-  WRITING_SYSTEM( latin2, LATIN2 )\n-#endif\n-\n-\n-\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afwrtsys.h","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -0,0 +1,33 @@\n+\/****************************************************************************\n+ *\n+ * afws-decl.h\n+ *\n+ *   Auto-fitter writing system declarations (specification only).\n+ *\n+ * Copyright (C) 2013-2022 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#ifndef AFWS_DECL_H_\n+#define AFWS_DECL_H_\n+\n+  \/* Since preprocessor directives can't create other preprocessor *\/\n+  \/* directives, we have to include the header files manually.     *\/\n+\n+#include \"afdummy.h\"\n+#include \"aflatin.h\"\n+#include \"afcjk.h\"\n+#include \"afindic.h\"\n+\n+#endif \/* AFWS_DECL_H_ *\/\n+\n+\n+\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afws-decl.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/****************************************************************************\n+ *\n+ * afws-iter.h\n+ *\n+ *   Auto-fitter writing systems iterator (specification only).\n+ *\n+ * Copyright (C) 2013-2022 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+  \/* This header may be included multiple times. *\/\n+  \/* Define `WRITING_SYSTEM' as needed.          *\/\n+\n+\n+  \/* Add new writing systems here.  The arguments are the writing system *\/\n+  \/* name in lowercase and uppercase, respectively.                      *\/\n+\n+  WRITING_SYSTEM( dummy, DUMMY )\n+  WRITING_SYSTEM( latin, LATIN )\n+  WRITING_SYSTEM( cjk,   CJK   )\n+  WRITING_SYSTEM( indic, INDIC )\n+\n+\n+\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/autofit\/afws-iter.h","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2020 by\n+ * Copyright (C) 2008-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftadvanc.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2020 by\n+ * Copyright (C) 2008-2022 by\n@@ -31,0 +31,1 @@\n+  FT_DECLARE_GLYPH( ft_svg_glyph_class )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftbase.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftbbox.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2022 by\n@@ -115,1 +115,1 @@\n-        (void)FT_QREALLOC( target->buffer, target_size, size );\n+        FT_MEM_QREALLOC( target->buffer, target_size, size );\n@@ -118,1 +118,1 @@\n-      (void)FT_QALLOC( target->buffer, size );\n+      FT_MEM_QALLOC( target->buffer, size );\n@@ -483,1 +483,1 @@\n-     *   https:\/\/accessibility.kde.org\/hsl-adjusted.php\n+     *   http:\/\/www.brucelindbloom.com\/index.html?WorkingSpaceInfo.html#SideNotes\n@@ -491,3 +491,3 @@\n-    l = (  4732UL \/* 0.0722 * 65536 *\/ * bgra[0] * bgra[0] +\n-          46871UL \/* 0.7152 * 65536 *\/ * bgra[1] * bgra[1] +\n-          13933UL \/* 0.2126 * 65536 *\/ * bgra[2] * bgra[2] ) >> 16;\n+    l = (  4731UL \/* 0.072186 * 65536 *\/ * bgra[0] * bgra[0] +\n+          46868UL \/* 0.715158 * 65536 *\/ * bgra[1] * bgra[1] +\n+          13937UL \/* 0.212656 * 65536 *\/ * bgra[2] * bgra[2] ) >> 16;\n@@ -910,2 +910,2 @@\n-    FT_TRACE5(( \"FT_Bitmap_Blend:\\n\"\n-                \"  source bitmap: (%ld, %ld) -- (%ld, %ld); %d x %d\\n\",\n+    FT_TRACE5(( \"FT_Bitmap_Blend:\\n\" ));\n+    FT_TRACE5(( \"  source bitmap: (%ld, %ld) -- (%ld, %ld); %d x %d\\n\",\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftbitmap.c","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -48,1 +48,1 @@\n-#ifndef FT_LONG64\n+#ifndef FT_INT64\n@@ -57,1 +57,1 @@\n-#endif \/* !FT_LONG64 *\/\n+#endif \/* !FT_INT64 *\/\n@@ -82,1 +82,1 @@\n-  \/* FT_LONG64 is defined.                                             *\/\n+  \/* FT_INT64 is defined.                                              *\/\n@@ -112,1 +112,1 @@\n-  FT_BASE_DEF ( FT_Int )\n+  FT_BASE_DEF( FT_Int )\n@@ -167,1 +167,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n@@ -275,1 +275,1 @@\n-#else \/* !FT_LONG64 *\/\n+#else \/* !FT_INT64 *\/\n@@ -654,1 +654,1 @@\n-#endif \/* !FT_LONG64 *\/\n+#endif \/* !FT_INT64 *\/\n@@ -988,1 +988,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcalc.c","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcid.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n@@ -305,40 +305,0 @@\n-  static FT_MemTable\n-  ft_mem_table_new( FT_Memory  memory )\n-  {\n-    FT_MemTable  table;\n-\n-\n-    table = (FT_MemTable)memory->alloc( memory, sizeof ( *table ) );\n-    if ( !table )\n-      goto Exit;\n-\n-    FT_ZERO( table );\n-\n-    table->size  = FT_MEM_SIZE_MIN;\n-    table->nodes = 0;\n-\n-    table->memory = memory;\n-\n-    table->memory_user = memory->user;\n-\n-    table->alloc   = memory->alloc;\n-    table->realloc = memory->realloc;\n-    table->free    = memory->free;\n-\n-    table->buckets = (FT_MemNode *)\n-                       memory->alloc(\n-                         memory,\n-                         table->size * (FT_Long)sizeof ( FT_MemNode ) );\n-    if ( table->buckets )\n-      FT_ARRAY_ZERO( table->buckets, table->size );\n-    else\n-    {\n-      memory->free( memory, table );\n-      table = NULL;\n-    }\n-\n-  Exit:\n-    return table;\n-  }\n-\n-\n@@ -353,2 +313,0 @@\n-    FT_DumpMemory( table->memory );\n-\n@@ -416,2 +374,0 @@\n-    ft_mem_table_free( table, table );\n-\n@@ -824,1 +780,1 @@\n-  extern FT_Int\n+  extern void\n@@ -828,1 +784,0 @@\n-    FT_Int       result = 0;\n@@ -831,1 +786,6 @@\n-    if ( ft_getenv( \"FT2_DEBUG_MEMORY\" ) )\n+    if ( !ft_getenv( \"FT2_DEBUG_MEMORY\" ) )\n+      return;\n+\n+    table = (FT_MemTable)memory->alloc( memory, sizeof ( *table ) );\n+\n+    if ( table )\n@@ -833,2 +793,11 @@\n-      table = ft_mem_table_new( memory );\n-      if ( table )\n+      FT_ZERO( table );\n+\n+      table->memory      = memory;\n+      table->memory_user = memory->user;\n+      table->alloc       = memory->alloc;\n+      table->realloc     = memory->realloc;\n+      table->free        = memory->free;\n+\n+      ft_mem_table_resize( table );\n+\n+      if ( table->size )\n@@ -879,2 +848,0 @@\n-\n-        result = 1;\n@@ -882,0 +849,2 @@\n+      else\n+        memory->free( memory, table );\n@@ -883,1 +852,0 @@\n-    return result;\n@@ -890,1 +858,3 @@\n-    FT_MemTable  table = (FT_MemTable)memory->user;\n+    if ( memory->free == ft_mem_debug_free )\n+    {\n+      FT_MemTable  table = (FT_MemTable)memory->user;\n@@ -893,2 +863,4 @@\n-    if ( table )\n-    {\n+      FT_DumpMemory( memory );\n+\n+      ft_mem_table_destroy( table );\n+\n@@ -898,0 +870,1 @@\n+      memory->user    = table->memory_user;\n@@ -899,2 +872,1 @@\n-      ft_mem_table_destroy( table );\n-      memory->user = NULL;\n+      memory->free( memory, table );\n@@ -925,4 +897,1 @@\n-    FT_MemTable  table = (FT_MemTable)memory->user;\n-\n-\n-    if ( table )\n+    if ( memory->free == ft_mem_debug_free )\n@@ -930,0 +899,1 @@\n+      FT_MemTable    table = (FT_MemTable)memory->user;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftdbgmem.c","additions":32,"deletions":62,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -45,0 +45,1 @@\n+#include <freetype\/ftlogging.h>\n@@ -46,0 +47,45 @@\n+#include <freetype\/internal\/ftobjs.h>\n+\n+\n+#ifdef FT_DEBUG_LOGGING\n+\n+  \/**************************************************************************\n+   *\n+   * Variables used to control logging.\n+   *\n+   * 1. `ft_default_trace_level` stores the value of trace levels, which are\n+   *    provided to FreeType using the `FT2_DEBUG` environment variable.\n+   *\n+   * 2. `ft_fileptr` stores the `FILE*` handle.\n+   *\n+   * 3. `ft_component` is a string that holds the name of `FT_COMPONENT`.\n+   *\n+   * 4. The flag `ft_component_flag` prints the name of `FT_COMPONENT` along\n+   *    with the actual log message if set to true.\n+   *\n+   * 5. The flag `ft_timestamp_flag` prints time along with the actual log\n+   *    message if set to ture.\n+   *\n+   * 6. `ft_have_newline_char` is used to differentiate between a log\n+   *    message with and without a trailing newline character.\n+   *\n+   * 7. `ft_custom_trace_level` stores the custom trace level value, which\n+   *    is provided by the user at run-time.\n+   *\n+   * We use `static` to avoid 'unused variable' warnings.\n+   *\n+   *\/\n+  static const char*  ft_default_trace_level = NULL;\n+  static FILE*        ft_fileptr             = NULL;\n+  static const char*  ft_component           = NULL;\n+  static FT_Bool      ft_component_flag      = FALSE;\n+  static FT_Bool      ft_timestamp_flag      = FALSE;\n+  static FT_Bool      ft_have_newline_char   = TRUE;\n+  static const char*  ft_custom_trace_level  = NULL;\n+\n+  \/* declared in ftdebug.h *\/\n+\n+  dlg_handler            ft_default_log_handler = NULL;\n+  FT_Custom_Log_Handler  custom_output_handler  = NULL;\n+\n+#endif \/* FT_DEBUG_LOGGING *\/\n@@ -109,1 +155,0 @@\n-\n@@ -198,1 +243,2 @@\n-    const char*  ft2_debug = ft_getenv( \"FT2_DEBUG\" );\n+    const char*  ft2_debug = NULL;\n+\n@@ -200,0 +246,8 @@\n+#ifdef FT_DEBUG_LOGGING\n+    if ( ft_custom_trace_level != NULL )\n+      ft2_debug = ft_custom_trace_level;\n+    else\n+      ft2_debug = ft_default_trace_level;\n+#else\n+    ft2_debug = ft_getenv( \"FT2_DEBUG\" );\n+#endif\n@@ -213,0 +267,43 @@\n+#ifdef FT_DEBUG_LOGGING\n+\n+        \/* check extra arguments for logging *\/\n+        if ( *p == '-' )\n+        {\n+          const char*  r = ++p;\n+\n+\n+          if ( *r == 'v' )\n+          {\n+            const char*  s = ++r;\n+\n+\n+            ft_component_flag = TRUE;\n+\n+            if ( *s == 't' )\n+            {\n+              ft_timestamp_flag = TRUE;\n+              p++;\n+            }\n+\n+            p++;\n+          }\n+\n+          else if ( *r == 't' )\n+          {\n+            const char*  s = ++r;\n+\n+\n+            ft_timestamp_flag = TRUE;\n+\n+            if ( *s == 'v' )\n+            {\n+              ft_component_flag = TRUE;\n+              p++;\n+            }\n+\n+            p++;\n+          }\n+        }\n+\n+#endif \/* FT_DEBUG_LOGGING *\/\n+\n@@ -314,1 +411,0 @@\n-\n@@ -318,0 +414,230 @@\n+#ifdef FT_DEBUG_LOGGING\n+\n+  \/**************************************************************************\n+   *\n+   * Initialize and de-initialize 'dlg' library.\n+   *\n+   *\/\n+\n+  FT_BASE_DEF( void )\n+  ft_logging_init( void )\n+  {\n+    ft_default_log_handler = ft_log_handler;\n+    ft_default_trace_level = ft_getenv( \"FT2_DEBUG\" );\n+\n+    if ( ft_getenv( \"FT_LOGGING_FILE\" ) )\n+      ft_fileptr = ft_fopen( ft_getenv( \"FT_LOGGING_FILE\" ), \"w\" );\n+    else\n+      ft_fileptr = stderr;\n+\n+    ft_debug_init();\n+\n+    \/* Set the default output handler for 'dlg'. *\/\n+    dlg_set_handler( ft_default_log_handler, NULL );\n+  }\n+\n+\n+  FT_BASE_DEF( void )\n+  ft_logging_deinit( void )\n+  {\n+    if ( ft_fileptr != stderr )\n+      ft_fclose( ft_fileptr );\n+  }\n+\n+\n+  \/**************************************************************************\n+   *\n+   * An output log handler for FreeType.\n+   *\n+   *\/\n+  FT_BASE_DEF( void )\n+  ft_log_handler( const struct dlg_origin*  origin,\n+                  const char*               string,\n+                  void*                     data )\n+  {\n+    char         features_buf[128];\n+    char*        bufp = features_buf;\n+\n+    FT_UNUSED( data );\n+\n+\n+    if ( ft_have_newline_char )\n+    {\n+      const char*  features        = NULL;\n+      size_t       features_length = 0;\n+\n+\n+#define FEATURES_TIMESTAMP            \"[%h:%m] \"\n+#define FEATURES_COMPONENT            \"[%t] \"\n+#define FEATURES_TIMESTAMP_COMPONENT  \"[%h:%m %t] \"\n+\n+      if ( ft_timestamp_flag && ft_component_flag )\n+      {\n+        features        = FEATURES_TIMESTAMP_COMPONENT;\n+        features_length = sizeof ( FEATURES_TIMESTAMP_COMPONENT );\n+      }\n+      else if ( ft_timestamp_flag )\n+      {\n+        features        = FEATURES_TIMESTAMP;\n+        features_length = sizeof ( FEATURES_TIMESTAMP );\n+      }\n+      else if ( ft_component_flag )\n+      {\n+        features        = FEATURES_COMPONENT;\n+        features_length = sizeof ( FEATURES_COMPONENT );\n+      }\n+\n+      if ( ft_component_flag || ft_timestamp_flag )\n+      {\n+        ft_strncpy( features_buf, features, features_length );\n+        bufp += features_length - 1;\n+      }\n+\n+      if ( ft_component_flag )\n+      {\n+        size_t  tag_length = ft_strlen( *origin->tags );\n+        size_t  i;\n+\n+\n+        \/* To vertically align tracing messages we compensate the *\/\n+        \/* different FT_COMPONENT string lengths by inserting an  *\/\n+        \/* appropriate amount of space characters.                *\/\n+        for ( i = 0;\n+              i < FT_MAX_TRACE_LEVEL_LENGTH - tag_length;\n+              i++ )\n+          *bufp++ = ' ';\n+      }\n+    }\n+\n+    \/* Finally add the format string for the tracing message. *\/\n+    *bufp++ = '%';\n+    *bufp++ = 'c';\n+    *bufp   = '\\0';\n+\n+    dlg_generic_outputf_stream( ft_fileptr,\n+                                (const char*)features_buf,\n+                                origin,\n+                                string,\n+                                dlg_default_output_styles,\n+                                true );\n+\n+    if ( ft_strrchr( string, '\\n' ) )\n+      ft_have_newline_char = TRUE;\n+    else\n+      ft_have_newline_char = FALSE;\n+  }\n+\n+\n+  \/* documentation is in ftdebug.h *\/\n+  FT_BASE_DEF( void )\n+  ft_add_tag( const char*  tag )\n+  {\n+    ft_component = tag;\n+\n+    dlg_add_tag( tag, NULL );\n+  }\n+\n+\n+  \/* documentation is in ftdebug.h *\/\n+  FT_BASE_DEF( void )\n+  ft_remove_tag( const char*  tag )\n+  {\n+    dlg_remove_tag( tag, NULL );\n+  }\n+\n+\n+  \/* documentation is in ftlogging.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Trace_Set_Level( const char*  level )\n+  {\n+    ft_component_flag     = FALSE;\n+    ft_timestamp_flag     = FALSE;\n+    ft_custom_trace_level = level;\n+\n+    ft_debug_init();\n+  }\n+\n+\n+  \/* documentation is in ftlogging.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Trace_Set_Default_Level( void )\n+  {\n+    ft_component_flag     = FALSE;\n+    ft_timestamp_flag     = FALSE;\n+    ft_custom_trace_level = NULL;\n+\n+    ft_debug_init();\n+  }\n+\n+\n+  \/**************************************************************************\n+   *\n+   * Functions to handle a custom log handler.\n+   *\n+   *\/\n+\n+  \/* documentation is in ftlogging.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Set_Log_Handler( FT_Custom_Log_Handler  handler )\n+  {\n+    custom_output_handler = handler;\n+  }\n+\n+\n+  \/* documentation is in ftlogging.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Set_Default_Log_Handler( void )\n+  {\n+    custom_output_handler = NULL;\n+  }\n+\n+\n+  \/* documentation is in ftdebug.h *\/\n+  FT_BASE_DEF( void )\n+  FT_Logging_Callback( const char*  fmt,\n+                       ... )\n+  {\n+    va_list  ap;\n+\n+\n+    va_start( ap, fmt );\n+    custom_output_handler( ft_component, fmt, ap );\n+    va_end( ap );\n+  }\n+\n+#else \/* !FT_DEBUG_LOGGING *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Trace_Set_Level( const char*  level )\n+  {\n+    FT_UNUSED( level );\n+  }\n+\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Trace_Set_Default_Level( void )\n+  {\n+    \/* nothing *\/\n+  }\n+\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Set_Log_Handler( FT_Custom_Log_Handler  handler )\n+  {\n+    FT_UNUSED( handler );\n+  }\n+\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Set_Default_Log_Handler( void )\n+  {\n+    \/* nothing *\/\n+  }\n+\n+#endif \/* !FT_DEBUG_LOGGING *\/\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftdebug.c","additions":330,"deletions":4,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftfntfmt.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2008-2020 by\n+ * Copyright (C) 2008-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftfstype.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftgasp.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftgloadr.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -37,0 +37,1 @@\n+#include <freetype\/otsvg.h>\n@@ -280,0 +281,234 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+\n+  \/*************************************************************************\/\n+  \/*************************************************************************\/\n+  \/****                                                                 ****\/\n+  \/****   FT_SvgGlyph support                                           ****\/\n+  \/****                                                                 ****\/\n+  \/*************************************************************************\/\n+  \/*************************************************************************\/\n+\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  ft_svg_glyph_init( FT_Glyph      svg_glyph,\n+                     FT_GlyphSlot  slot )\n+  {\n+    FT_ULong         doc_length;\n+    FT_SVG_Document  document;\n+    FT_SvgGlyph      glyph = (FT_SvgGlyph)svg_glyph;\n+\n+    FT_Error   error  = FT_Err_Ok;\n+    FT_Memory  memory = FT_GLYPH( glyph )->library->memory;\n+\n+\n+    if ( slot->format != FT_GLYPH_FORMAT_SVG )\n+    {\n+      error = FT_THROW( Invalid_Glyph_Format );\n+      goto Exit;\n+    }\n+\n+    if ( slot->other == NULL )\n+    {\n+      error = FT_THROW( Invalid_Slot_Handle );\n+      goto Exit;\n+    }\n+\n+    document = (FT_SVG_Document)slot->other;\n+\n+    if ( document->svg_document_length == 0 )\n+    {\n+      error = FT_THROW( Invalid_Slot_Handle );\n+      goto Exit;\n+    }\n+\n+    \/* allocate a new document *\/\n+    doc_length = document->svg_document_length;\n+    if ( FT_QALLOC( glyph->svg_document, doc_length ) )\n+      goto Exit;\n+    glyph->svg_document_length = doc_length;\n+\n+    glyph->glyph_index = slot->glyph_index;\n+\n+    glyph->metrics      = document->metrics;\n+    glyph->units_per_EM = document->units_per_EM;\n+\n+    glyph->start_glyph_id = document->start_glyph_id;\n+    glyph->end_glyph_id   = document->end_glyph_id;\n+\n+    glyph->transform = document->transform;\n+    glyph->delta     = document->delta;\n+\n+    \/* copy the document into glyph *\/\n+    FT_MEM_COPY( glyph->svg_document, document->svg_document, doc_length );\n+\n+  Exit:\n+    return error;\n+  }\n+\n+\n+  FT_CALLBACK_DEF( void )\n+  ft_svg_glyph_done( FT_Glyph  svg_glyph )\n+  {\n+    FT_SvgGlyph  glyph  = (FT_SvgGlyph)svg_glyph;\n+    FT_Memory    memory = svg_glyph->library->memory;\n+\n+\n+    \/* just free the memory *\/\n+    FT_FREE( glyph->svg_document );\n+  }\n+\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  ft_svg_glyph_copy( FT_Glyph  svg_source,\n+                     FT_Glyph  svg_target )\n+  {\n+    FT_SvgGlyph  source = (FT_SvgGlyph)svg_source;\n+    FT_SvgGlyph  target = (FT_SvgGlyph)svg_target;\n+\n+    FT_Error   error  = FT_Err_Ok;\n+    FT_Memory  memory = FT_GLYPH( source )->library->memory;\n+\n+\n+    if ( svg_source->format != FT_GLYPH_FORMAT_SVG )\n+    {\n+      error = FT_THROW( Invalid_Glyph_Format );\n+      goto Exit;\n+    }\n+\n+    if ( source->svg_document_length == 0 )\n+    {\n+      error = FT_THROW( Invalid_Slot_Handle );\n+      goto Exit;\n+    }\n+\n+    target->glyph_index = source->glyph_index;\n+\n+    target->svg_document_length = source->svg_document_length;\n+\n+    target->metrics      = source->metrics;\n+    target->units_per_EM = source->units_per_EM;\n+\n+    target->start_glyph_id = source->start_glyph_id;\n+    target->end_glyph_id   = source->end_glyph_id;\n+\n+    target->transform = source->transform;\n+    target->delta     = source->delta;\n+\n+    \/* allocate space for the SVG document *\/\n+    if ( FT_QALLOC( target->svg_document, target->svg_document_length ) )\n+      goto Exit;\n+\n+    \/* copy the document *\/\n+    FT_MEM_COPY( target->svg_document,\n+                 source->svg_document,\n+                 target->svg_document_length );\n+\n+  Exit:\n+    return error;\n+  }\n+\n+\n+  FT_CALLBACK_DEF( void )\n+  ft_svg_glyph_transform( FT_Glyph          svg_glyph,\n+                          const FT_Matrix*  _matrix,\n+                          const FT_Vector*  _delta )\n+  {\n+    FT_SvgGlyph  glyph  = (FT_SvgGlyph)svg_glyph;\n+    FT_Matrix*   matrix = (FT_Matrix*)_matrix;\n+    FT_Vector*   delta  = (FT_Vector*)_delta;\n+\n+    FT_Matrix  tmp_matrix;\n+    FT_Vector  tmp_delta;\n+\n+    FT_Matrix  a, b;\n+    FT_Pos     x, y;\n+\n+\n+    if ( !matrix )\n+    {\n+      tmp_matrix.xx = 0x10000;\n+      tmp_matrix.xy = 0;\n+      tmp_matrix.yx = 0;\n+      tmp_matrix.yy = 0x10000;\n+\n+      matrix = &tmp_matrix;\n+    }\n+\n+    if ( !delta )\n+    {\n+      tmp_delta.x = 0;\n+      tmp_delta.y = 0;\n+\n+      delta = &tmp_delta;\n+    }\n+\n+    a = glyph->transform;\n+    b = *matrix;\n+    FT_Matrix_Multiply( &b, &a );\n+\n+    x = ADD_LONG( ADD_LONG( FT_MulFix( matrix->xx, glyph->delta.x ),\n+                            FT_MulFix( matrix->xy, glyph->delta.y ) ),\n+                  delta->x );\n+    y = ADD_LONG( ADD_LONG( FT_MulFix( matrix->yx, glyph->delta.x ),\n+                            FT_MulFix( matrix->yy, glyph->delta.y ) ),\n+                  delta->y );\n+\n+    glyph->delta.x = x;\n+    glyph->delta.y = y;\n+\n+    glyph->transform = a;\n+  }\n+\n+\n+  FT_CALLBACK_DEF( FT_Error )\n+  ft_svg_glyph_prepare( FT_Glyph      svg_glyph,\n+                        FT_GlyphSlot  slot )\n+  {\n+    FT_SvgGlyph  glyph = (FT_SvgGlyph)svg_glyph;\n+\n+    FT_Error   error  = FT_Err_Ok;\n+    FT_Memory  memory = svg_glyph->library->memory;\n+\n+    FT_SVG_Document  document = NULL;\n+\n+\n+    if ( FT_NEW( document ) )\n+      return error;\n+\n+    document->svg_document        = glyph->svg_document;\n+    document->svg_document_length = glyph->svg_document_length;\n+\n+    document->metrics      = glyph->metrics;\n+    document->units_per_EM = glyph->units_per_EM;\n+\n+    document->start_glyph_id = glyph->start_glyph_id;\n+    document->end_glyph_id   = glyph->end_glyph_id;\n+\n+    document->transform = glyph->transform;\n+    document->delta     = glyph->delta;\n+\n+    slot->format      = FT_GLYPH_FORMAT_SVG;\n+    slot->glyph_index = glyph->glyph_index;\n+    slot->other       = document;\n+\n+    return error;\n+  }\n+\n+\n+  FT_DEFINE_GLYPH(\n+    ft_svg_glyph_class,\n+\n+    sizeof ( FT_SvgGlyphRec ),\n+    FT_GLYPH_FORMAT_SVG,\n+\n+    ft_svg_glyph_init,      \/* FT_Glyph_InitFunc       glyph_init      *\/\n+    ft_svg_glyph_done,      \/* FT_Glyph_DoneFunc       glyph_done      *\/\n+    ft_svg_glyph_copy,      \/* FT_Glyph_CopyFunc       glyph_copy      *\/\n+    ft_svg_glyph_transform, \/* FT_Glyph_TransformFunc  glyph_transform *\/\n+    NULL,                   \/* FT_Glyph_GetBBoxFunc    glyph_bbox      *\/\n+    ft_svg_glyph_prepare    \/* FT_Glyph_PrepareFunc    glyph_prepare   *\/\n+  )\n+\n+#endif \/* FT_CONFIG_OPTION_SVG *\/\n+\n+\n@@ -380,0 +615,6 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    \/* if it is an SVG glyph *\/\n+    else if ( format == FT_GLYPH_FORMAT_SVG )\n+      clazz = &ft_svg_glyph_class;\n+#endif\n+\n@@ -456,3 +697,3 @@\n-  FT_Glyph_Transform( FT_Glyph    glyph,\n-                      FT_Matrix*  matrix,\n-                      FT_Vector*  delta )\n+  FT_Glyph_Transform( FT_Glyph          glyph,\n+                      const FT_Matrix*  matrix,\n+                      const FT_Vector*  delta )\n@@ -536,4 +777,4 @@\n-  FT_Glyph_To_Bitmap( FT_Glyph*       the_glyph,\n-                      FT_Render_Mode  render_mode,\n-                      FT_Vector*      origin,\n-                      FT_Bool         destroy )\n+  FT_Glyph_To_Bitmap( FT_Glyph*         the_glyph,\n+                      FT_Render_Mode    render_mode,\n+                      const FT_Vector*  origin,\n+                      FT_Bool           destroy )\n@@ -588,1 +829,1 @@\n-      FT_Glyph_Transform( glyph, 0, origin );\n+      FT_Glyph_Transform( glyph, NULL, origin );\n@@ -598,0 +839,10 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    if ( clazz == &ft_svg_glyph_class )\n+    {\n+      FT_Memory  memory = library->memory;\n+\n+\n+      FT_FREE( dummy.other );\n+    }\n+#endif\n+\n@@ -606,1 +857,1 @@\n-      FT_Glyph_Transform( glyph, 0, &v );\n+      FT_Glyph_Transform( glyph, NULL, &v );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftglyph.c","additions":261,"deletions":10,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-      if ( FT_NEW( nn ) )\n+      if ( FT_QNEW( nn ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/fthash.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -205,0 +205,4 @@\n+#ifdef FT_DEBUG_LOGGING\n+    ft_logging_init();\n+#endif\n+\n@@ -251,0 +255,4 @@\n+#ifdef FT_DEBUG_LOGGING\n+    ft_logging_deinit();\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftinit.c","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n@@ -35,1 +35,1 @@\n-  FT_BASE_DEF (void)\n+  FT_BASE_DEF( void )\n@@ -360,1 +360,1 @@\n-                             FT_Vector*  sub )\n+                             FT_Vector   sub[3] )\n@@ -371,1 +371,1 @@\n-  FT_BASE_DEF (void)\n+  FT_BASE_DEF( void )\n@@ -431,1 +431,1 @@\n-    return FT_THROW( Unimplemented_Feature );\n+    return FT_Err_Ok;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftlcdfil.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -108,1 +108,1 @@\n-#include FT_MAC_H\n+#include <freetype\/ftmac.h>\n@@ -563,1 +563,1 @@\n-                                 buff, sizeof ( buff )  );\n+                                 buff, sizeof ( buff ) );\n@@ -634,1 +634,1 @@\n-    if ( FT_ALLOC( buffer, (FT_Long)total_size ) )\n+    if ( FT_QALLOC( buffer, (FT_Long)total_size ) )\n@@ -755,1 +755,1 @@\n-    if ( FT_ALLOC( sfnt_data, (FT_Long)sfnt_size ) )\n+    if ( FT_QALLOC( sfnt_data, (FT_Long)sfnt_size ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftmac.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftmm.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -22,0 +22,1 @@\n+#include <freetype\/otsvg.h>\n@@ -30,0 +31,1 @@\n+#include <freetype\/internal\/svginterface.h>\n@@ -81,0 +83,3 @@\n+  \/* This array must stay in sync with the @FT_Pixel_Mode enumeration *\/\n+  \/* (in file `ftimage.h`).                                           *\/\n+\n@@ -90,1 +95,2 @@\n-    \"BGRA 32-bit color image bitmap\"\n+    \"BGRA 32-bit color image bitmap\",\n+    \"SDF 8-bit bitmap\"\n@@ -196,0 +202,1 @@\n+    FT_UInt    mode;\n@@ -207,0 +214,2 @@\n+    mode   = args->flags &\n+               ( FT_OPEN_MEMORY | FT_OPEN_STREAM | FT_OPEN_PATHNAME );\n@@ -208,6 +217,1 @@\n-    if ( FT_NEW( stream ) )\n-      goto Exit;\n-\n-    stream->memory = memory;\n-\n-    if ( args->flags & FT_OPEN_MEMORY )\n+    if ( mode == FT_OPEN_MEMORY )\n@@ -216,0 +220,3 @@\n+      if ( FT_NEW( stream ) )\n+        goto Exit;\n+\n@@ -219,0 +226,1 @@\n+      stream->memory = memory;\n@@ -223,1 +231,1 @@\n-    else if ( args->flags & FT_OPEN_PATHNAME )\n+    else if ( mode == FT_OPEN_PATHNAME )\n@@ -226,0 +234,4 @@\n+      if ( FT_NEW( stream ) )\n+        goto Exit;\n+\n+      stream->memory = memory;\n@@ -227,1 +239,2 @@\n-      stream->pathname.pointer = args->pathname;\n+      if ( error )\n+        FT_FREE( stream );\n@@ -229,1 +242,1 @@\n-    else if ( ( args->flags & FT_OPEN_STREAM ) && args->stream )\n+    else if ( ( mode == FT_OPEN_STREAM ) && args->stream )\n@@ -235,2 +248,3 @@\n-      FT_FREE( stream );\n-      stream = args->stream;\n+      stream         = args->stream;\n+      stream->memory = memory;\n+      error          = FT_Err_Ok;\n@@ -242,0 +256,1 @@\n+    {\n@@ -243,0 +258,3 @@\n+      if ( ( args->flags & FT_OPEN_STREAM ) && args->stream )\n+        FT_Stream_Close( args->stream );\n+    }\n@@ -244,6 +262,2 @@\n-    if ( error )\n-      FT_FREE( stream );\n-    else\n-      stream->memory = memory;  \/* just to be certain *\/\n-\n-    *astream = stream;\n+    if ( !error )\n+      *astream       = stream;\n@@ -319,0 +333,13 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    \/* if SVG table exists, allocate the space in `slot->other` *\/\n+    if ( slot->face->face_flags & FT_FACE_FLAG_SVG )\n+    {\n+      FT_SVG_Document  document = NULL;\n+\n+\n+      if ( FT_NEW( document ) )\n+        goto Exit;\n+      slot->other = document;\n+    }\n+#endif\n+\n@@ -363,1 +390,12 @@\n-    if ( slot->format != FT_GLYPH_FORMAT_OUTLINE )\n+    if ( slot->format == FT_GLYPH_FORMAT_SVG )\n+    {\n+      FT_Module    module;\n+      SVG_Service  svg_service;\n+\n+\n+      module      = FT_Get_Module( slot->library, \"ot-svg\" );\n+      svg_service = (SVG_Service)module->clazz->module_interface;\n+\n+      return (FT_Bool)svg_service->preset_slot( module, slot, FALSE );\n+    }\n+    else if ( slot->format != FT_GLYPH_FORMAT_OUTLINE )\n@@ -526,1 +564,1 @@\n-    (void)FT_ALLOC( slot->bitmap.buffer, size );\n+    FT_MEM_ALLOC( slot->bitmap.buffer, size );\n@@ -538,0 +576,2 @@\n+    slot->glyph_index = 0;\n+\n@@ -553,2 +593,21 @@\n-    slot->other         = NULL;\n-    slot->format        = FT_GLYPH_FORMAT_NONE;\n+\n+#ifndef FT_CONFIG_OPTION_SVG\n+    slot->other = NULL;\n+#else\n+    if ( !( slot->face->face_flags & FT_FACE_FLAG_SVG ) )\n+      slot->other = NULL;\n+    else\n+    {\n+      if ( slot->internal->flags & FT_GLYPH_OWN_GZIP_SVG )\n+      {\n+        FT_Memory        memory = slot->face->memory;\n+        FT_SVG_Document  doc    = (FT_SVG_Document)slot->other;\n+\n+\n+        FT_FREE( doc->svg_document );\n+        slot->internal->load_flags &= ~FT_GLYPH_OWN_GZIP_SVG;\n+      }\n+    }\n+#endif\n+\n+    slot->format = FT_GLYPH_FORMAT_NONE;\n@@ -558,0 +617,2 @@\n+    slot->advance.x         = 0;\n+    slot->advance.y         = 0;\n@@ -570,0 +631,17 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    if ( slot->face->face_flags & FT_FACE_FLAG_SVG )\n+    {\n+      \/* free memory in case SVG was there *\/\n+      if ( slot->internal->flags & FT_GLYPH_OWN_GZIP_SVG )\n+      {\n+        FT_SVG_Document  doc = (FT_SVG_Document)slot->other;\n+\n+\n+        FT_FREE( doc->svg_document );\n+\n+        slot->internal->flags &= ~FT_GLYPH_OWN_GZIP_SVG;\n+      }\n+\n+      FT_FREE( slot->other );\n+    }\n+#endif\n@@ -737,0 +815,23 @@\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( void )\n+  FT_Get_Transform( FT_Face     face,\n+                    FT_Matrix*  matrix,\n+                    FT_Vector*  delta )\n+  {\n+    FT_Face_Internal  internal;\n+\n+\n+    if ( !face )\n+      return;\n+\n+    internal = face->internal;\n+\n+    if ( matrix )\n+      *matrix = internal->transform_matrix;\n+\n+    if ( delta )\n+      *delta = internal->transform_delta;\n+  }\n+\n+\n@@ -822,0 +923,5 @@\n+    \/* undefined scale means no scale *\/\n+    if ( face->size->metrics.x_ppem == 0 ||\n+         face->size->metrics.y_ppem == 0 )\n+      load_flags |= FT_LOAD_NO_SCALE;\n+\n@@ -911,5 +1017,15 @@\n-      \/* try to load embedded bitmaps first if available            *\/\n-      \/*                                                            *\/\n-      \/* XXX: This is really a temporary hack that should disappear *\/\n-      \/*      promptly with FreeType 2.1!                           *\/\n-      \/*                                                            *\/\n+      \/* XXX: The use of the `FT_LOAD_XXX_ONLY` flags is not very *\/\n+      \/*      elegant.                                            *\/\n+\n+      \/* try to load SVG documents if available *\/\n+      if ( FT_HAS_SVG( face ) )\n+      {\n+        error = driver->clazz->load_glyph( slot, face->size,\n+                                           glyph_index,\n+                                           load_flags | FT_LOAD_SVG_ONLY );\n+\n+        if ( !error && slot->format == FT_GLYPH_FORMAT_SVG )\n+          goto Load_Ok;\n+      }\n+\n+      \/* try to load embedded bitmaps if available *\/\n@@ -1059,0 +1175,12 @@\n+    FT_TRACE5(( \"  bitmap %dx%d %s, %s (mode %d)\\n\",\n+                slot->bitmap.width,\n+                slot->bitmap.rows,\n+                slot->outline.points ?\n+                  slot->bitmap.buffer ? \"rendered\"\n+                                      : \"preset\"\n+                                     :\n+                  slot->internal->flags & FT_GLYPH_OWN_BITMAP ? \"owned\"\n+                                                              : \"unowned\",\n+                pixel_modes[slot->bitmap.pixel_mode],\n+                slot->bitmap.pixel_mode ));\n+    FT_TRACE5(( \"\\n\" ));\n@@ -1065,7 +1193,0 @@\n-    FT_TRACE5(( \"\\n\" ));\n-    FT_TRACE5(( \"  bitmap %dx%d, %s (mode %d)\\n\",\n-                slot->bitmap.width,\n-                slot->bitmap.rows,\n-                pixel_modes[slot->bitmap.pixel_mode],\n-                slot->bitmap.pixel_mode ));\n-    FT_TRACE5(( \"\\n\" ));\n@@ -1556,1 +1677,0 @@\n-    stream->base  = NULL;\n@@ -1785,1 +1905,1 @@\n-    if ( FT_ALLOC( sfnt_ps, (FT_Long)length ) )\n+    if ( FT_QALLOC( sfnt_ps, (FT_Long)length ) )\n@@ -1895,1 +2015,1 @@\n-    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n+    if ( FT_QALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )\n@@ -1959,1 +2079,1 @@\n-                    i, pfb_data, pfb_lenpos ));\n+                    i, (void*)pfb_data, pfb_lenpos ));\n@@ -1974,1 +2094,1 @@\n-                    i, pfb_data, pfb_pos ));\n+                    i, (void*)pfb_data, pfb_pos ));\n@@ -1997,1 +2117,1 @@\n-                  i, rlen, pfb_data, pfb_pos ));\n+                  i, rlen, (void*)pfb_data, pfb_pos ));\n@@ -2095,1 +2215,1 @@\n-    if ( FT_ALLOC( sfnt_data, rlen ) )\n+    if ( FT_QALLOC( sfnt_data, rlen ) )\n@@ -2410,0 +2530,10 @@\n+    \/* only use lower 31 bits together with sign bit *\/\n+    if ( face_index > 0 )\n+      face_index &= 0x7FFFFFFFL;\n+    else\n+    {\n+      face_index  = -face_index;\n+      face_index &= 0x7FFFFFFFL;\n+      face_index  = -face_index;\n+    }\n+\n@@ -2569,1 +2699,1 @@\n-    if ( FT_NEW( node ) )\n+    if ( FT_QNEW( node ) )\n@@ -2684,2 +2814,1 @@\n-      FT_TRACE3(( \"FT_Open_Face: The font has %ld face%s\\n\"\n-                  \"              and %ld named instance%s for face %ld\\n\",\n+      FT_TRACE3(( \"FT_Open_Face: The font has %ld face%s\\n\",\n@@ -2687,1 +2816,2 @@\n-                  face->num_faces == 1 ? \"\" : \"s\",\n+                  face->num_faces == 1 ? \"\" : \"s\" ));\n+      FT_TRACE3(( \"              and %ld named instance%s for face %ld\\n\",\n@@ -2854,1 +2984,1 @@\n-    if ( FT_ALLOC( size, clazz->size_object_size ) || FT_NEW( node ) )\n+    if ( FT_ALLOC( size, clazz->size_object_size ) || FT_QNEW( node ) )\n@@ -3091,1 +3221,1 @@\n-  FT_BASE_DEF( void )\n+  FT_BASE_DEF( FT_Error )\n@@ -3095,0 +3225,2 @@\n+    FT_Error  error = FT_Err_Ok;\n+\n@@ -3185,2 +3317,12 @@\n-      metrics->x_ppem = (FT_UShort)( ( scaled_w + 32 ) >> 6 );\n-      metrics->y_ppem = (FT_UShort)( ( scaled_h + 32 ) >> 6 );\n+      scaled_w = ( scaled_w + 32 ) >> 6;\n+      scaled_h = ( scaled_h + 32 ) >> 6;\n+      if ( scaled_w > (FT_Long)FT_USHORT_MAX ||\n+           scaled_h > (FT_Long)FT_USHORT_MAX )\n+      {\n+        FT_ERROR(( \"FT_Request_Metrics: Resulting ppem size too large\\n\" ));\n+        error = FT_ERR( Invalid_Pixel_Size );\n+        goto Exit;\n+      }\n+\n+      metrics->x_ppem = (FT_UShort)scaled_w;\n+      metrics->y_ppem = (FT_UShort)scaled_h;\n@@ -3196,0 +3338,3 @@\n+\n+  Exit:\n+    return error;\n@@ -3259,1 +3404,1 @@\n-    FT_Error         error = FT_Err_Ok;\n+    FT_Error         error;\n@@ -3267,0 +3412,3 @@\n+    if ( !face->size )\n+      return FT_THROW( Invalid_Size_Handle );\n+\n@@ -3295,1 +3443,1 @@\n-        return error;\n+        goto Exit;\n@@ -3301,1 +3449,3 @@\n-      FT_Request_Metrics( face, req );\n+      error = FT_Request_Metrics( face, req );\n+      if ( error )\n+        goto Exit;\n@@ -3324,0 +3474,1 @@\n+  Exit:\n@@ -3648,3 +3799,3 @@\n-          if ( FT_RENEW_ARRAY( face->charmaps,\n-                               face->num_charmaps,\n-                               face->num_charmaps - 1 ) )\n+          if ( FT_QRENEW_ARRAY( face->charmaps,\n+                                face->num_charmaps,\n+                                face->num_charmaps - 1 ) )\n@@ -3682,1 +3833,1 @@\n-    FT_Error   error = FT_Err_Ok;\n+    FT_Error   error;\n@@ -3707,3 +3858,3 @@\n-      if ( FT_RENEW_ARRAY( face->charmaps,\n-                           face->num_charmaps,\n-                           face->num_charmaps + 1 ) )\n+      if ( FT_QRENEW_ARRAY( face->charmaps,\n+                            face->num_charmaps,\n+                            face->num_charmaps + 1 ) )\n@@ -4403,1 +4554,1 @@\n-    if ( FT_NEW( node ) )\n+    if ( FT_QNEW( node ) )\n@@ -4415,2 +4566,1 @@\n-      if ( clazz->glyph_format == FT_GLYPH_FORMAT_OUTLINE &&\n-           clazz->raster_class->raster_new                )\n+      if ( clazz->raster_class && clazz->raster_class->raster_new )\n@@ -4426,0 +4576,5 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+      if ( clazz->glyph_format == FT_GLYPH_FORMAT_SVG )\n+        render->render = clazz->render_glyph;\n+#endif\n+\n@@ -4463,2 +4618,1 @@\n-      if ( render->clazz->glyph_format == FT_GLYPH_FORMAT_OUTLINE &&\n-           render->raster                                         )\n+      if ( render->raster )\n@@ -4559,3 +4713,0 @@\n-    case FT_GLYPH_FORMAT_BITMAP:   \/* already a bitmap, don't do anything *\/\n-      break;\n-\n@@ -4649,1 +4800,1 @@\n-        error = FT_ERR( Unimplemented_Feature );\n+        error = FT_ERR( Cannot_Render_Glyph );\n@@ -4665,0 +4816,5 @@\n+\n+        \/* it is not an error if we cannot render a bitmap glyph *\/\n+        if ( FT_ERR_EQ( error, Cannot_Render_Glyph ) &&\n+             slot->format == FT_GLYPH_FORMAT_BITMAP  )\n+          error = FT_Err_Ok;\n@@ -4737,1 +4893,2 @@\n-         ft_trace_levels[trace_checksum] >= 7 )\n+         ft_trace_levels[trace_checksum] >= 7 &&\n+         slot->bitmap.buffer                  )\n@@ -4740,2 +4897,1 @@\n-           slot->bitmap.width < 128U &&\n-           slot->bitmap.buffer       )\n+           slot->bitmap.width < 128U )\n@@ -5152,2 +5308,2 @@\n-      FT_ERROR(( \"%s: can't find module `%s'\\n\",\n-                 func_name, module_name ));\n+      FT_TRACE2(( \"%s: can't find module `%s'\\n\",\n+                  func_name, module_name ));\n@@ -5160,2 +5316,2 @@\n-      FT_ERROR(( \"%s: module `%s' doesn't support properties\\n\",\n-                 func_name, module_name ));\n+      FT_TRACE2(( \"%s: module `%s' doesn't support properties\\n\",\n+                  func_name, module_name ));\n@@ -5170,2 +5326,2 @@\n-      FT_ERROR(( \"%s: module `%s' doesn't support properties\\n\",\n-                 func_name, module_name ));\n+      FT_TRACE2(( \"%s: module `%s' doesn't support properties\\n\",\n+                  func_name, module_name ));\n@@ -5184,2 +5340,2 @@\n-      FT_ERROR(( \"%s: property service of module `%s' is broken\\n\",\n-                 func_name, module_name ));\n+      FT_TRACE2(( \"%s: property service of module `%s' is broken\\n\",\n+                  func_name, module_name ));\n@@ -5295,0 +5451,1 @@\n+#ifndef FT_DEBUG_LOGGING\n@@ -5298,1 +5455,2 @@\n-#endif\n+#endif \/* FT_DEBUG_LEVEL_ERROR *\/\n+#endif \/* !FT_DEBUG_LOGGING *\/\n@@ -5570,0 +5728,141 @@\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Color_Glyph_Paint( FT_Face                  face,\n+                            FT_UInt                  base_glyph,\n+                            FT_Color_Root_Transform  root_transform,\n+                            FT_OpaquePaint*          paint )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !paint )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_colr_layer )\n+      return sfnt->get_colr_glyph_paint( ttface,\n+                                         base_glyph,\n+                                         root_transform,\n+                                         paint );\n+    else\n+      return 0;\n+  }\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Color_Glyph_ClipBox( FT_Face      face,\n+                              FT_UInt      base_glyph,\n+                              FT_ClipBox*  clip_box )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !clip_box )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_color_glyph_clipbox )\n+      return sfnt->get_color_glyph_clipbox( ttface,\n+                                            base_glyph,\n+                                            clip_box );\n+    else\n+      return 0;\n+  }\n+\n+\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Paint_Layers( FT_Face            face,\n+                       FT_LayerIterator*  layer_iterator,\n+                       FT_OpaquePaint*    paint )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !paint || !layer_iterator )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_paint_layers )\n+      return sfnt->get_paint_layers( ttface, layer_iterator, paint );\n+    else\n+      return 0;\n+  }\n+\n+\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Paint( FT_Face face,\n+                FT_OpaquePaint  opaque_paint,\n+                FT_COLR_Paint*  paint )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !paint )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_paint )\n+      return sfnt->get_paint( ttface, opaque_paint, paint );\n+    else\n+      return 0;\n+  }\n+\n+\n+  \/* documentation is in freetype.h *\/\n+\n+  FT_EXPORT_DEF( FT_Bool )\n+  FT_Get_Colorline_Stops ( FT_Face                face,\n+                           FT_ColorStop *         color_stop,\n+                           FT_ColorStopIterator  *iterator )\n+  {\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face || !color_stop || !iterator )\n+      return 0;\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return 0;\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    if ( sfnt->get_colorline_stops )\n+      return sfnt->get_colorline_stops ( ttface, color_stop, iterator );\n+    else\n+      return 0;\n+  }\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftobjs.c","additions":380,"deletions":81,"binary":false,"changes":461,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftoutln.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2007-2020 by\n+ * Copyright (C) 2007-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftpatent.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2022 by\n@@ -223,1 +223,1 @@\n-    FT_TRACE0(( \"ps_property_set: missing property `%s'\\n\",\n+    FT_TRACE2(( \"ps_property_set: missing property `%s'\\n\",\n@@ -278,1 +278,1 @@\n-    FT_TRACE0(( \"ps_property_get: missing property `%s'\\n\",\n+    FT_TRACE2(( \"ps_property_get: missing property `%s'\\n\",\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftpsprop.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2022 by\n@@ -170,3 +170,3 @@\n-  static int\n-  ft_raccess_sort_ref_by_id( FT_RFork_Ref*  a,\n-                             FT_RFork_Ref*  b )\n+  FT_COMPARE_DEF( int )\n+  ft_raccess_sort_ref_by_id( const void*  a,\n+                             const void*  b )\n@@ -174,6 +174,1 @@\n-    if ( a->res_id < b->res_id )\n-      return -1;\n-    else if ( a->res_id > b->res_id )\n-      return 1;\n-    else\n-      return 0;\n+    return  ( (FT_RFork_Ref*)a )->res_id - ( (FT_RFork_Ref*)b )->res_id;\n@@ -259,1 +254,1 @@\n-        if ( FT_NEW_ARRAY( ref, *count ) )\n+        if ( FT_QNEW_ARRAY( ref, *count ) )\n@@ -297,2 +292,1 @@\n-                    ( int(*)(const void*,\n-                             const void*) )ft_raccess_sort_ref_by_id );\n+                    ft_raccess_sort_ref_by_id );\n@@ -308,1 +302,1 @@\n-        if ( FT_NEW_ARRAY( offsets_internal, *count ) )\n+        if ( FT_QNEW_ARRAY( offsets_internal, *count ) )\n@@ -611,1 +605,1 @@\n-    if ( FT_ALLOC( newpath, base_file_len + 6 ) )\n+    if ( FT_QALLOC( newpath, base_file_len + 6 ) )\n@@ -647,1 +641,1 @@\n-    if ( FT_ALLOC( newpath, base_file_len + 18 ) )\n+    if ( FT_QALLOC( newpath, base_file_len + 18 ) )\n@@ -877,3 +871,1 @@\n-    FT_Error     error = FT_Err_Ok;\n-\n-    FT_UNUSED( error );\n+    FT_Error     error;\n@@ -883,1 +875,1 @@\n-    if ( FT_ALLOC( new_name, new_length + 1 ) )\n+    if ( FT_QALLOC( new_name, new_length + 1 ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftrfork.c","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -68,1 +68,1 @@\n-          if ( FT_NEW_ARRAY  ( entry->string, entry->stringLength ) ||\n+          if ( FT_QNEW_ARRAY ( entry->string, entry->stringLength ) ||\n@@ -124,1 +124,1 @@\n-          if ( FT_NEW_ARRAY  ( entry->string, entry->stringLength ) ||\n+          if ( FT_QNEW_ARRAY ( entry->string, entry->stringLength ) ||\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftsnames.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2022 by\n@@ -64,1 +64,1 @@\n-      if ( stream->read( stream, pos, 0, 0 ) )\n+      if ( stream->read( stream, pos, NULL, 0 ) )\n@@ -350,2 +350,2 @@\n-  FT_BASE_DEF( FT_Char )\n-  FT_Stream_GetChar( FT_Stream  stream )\n+  FT_BASE_DEF( FT_Byte )\n+  FT_Stream_GetByte( FT_Stream  stream )\n@@ -353,1 +353,1 @@\n-    FT_Char  result;\n+    FT_Byte  result;\n@@ -360,1 +360,1 @@\n-      result = (FT_Char)*stream->cursor++;\n+      result = *stream->cursor++;\n@@ -458,2 +458,2 @@\n-  FT_BASE_DEF( FT_Char )\n-  FT_Stream_ReadChar( FT_Stream  stream,\n+  FT_BASE_DEF( FT_Byte )\n+  FT_Stream_ReadByte( FT_Stream  stream,\n@@ -467,3 +467,1 @@\n-    *error = FT_Err_Ok;\n-\n-    if ( stream->read )\n+    if ( stream->pos < stream->size )\n@@ -471,7 +469,5 @@\n-      if ( stream->read( stream, stream->pos, &result, 1L ) != 1L )\n-        goto Fail;\n-    }\n-    else\n-    {\n-      if ( stream->pos < stream->size )\n-        result = stream->base[stream->pos];\n+      if ( stream->read )\n+      {\n+        if ( stream->read( stream, stream->pos, &result, 1L ) != 1L )\n+          goto Fail;\n+      }\n@@ -479,1 +475,1 @@\n-        goto Fail;\n+        result = stream->base[stream->pos];\n@@ -481,0 +477,3 @@\n+    else\n+      goto Fail;\n+\n@@ -483,1 +482,3 @@\n-    return (FT_Char)result;\n+    *error = FT_Err_Ok;\n+\n+    return result;\n@@ -487,1 +488,1 @@\n-    FT_ERROR(( \"FT_Stream_ReadChar:\"\n+    FT_ERROR(( \"FT_Stream_ReadByte:\"\n@@ -491,1 +492,1 @@\n-    return 0;\n+    return result;\n@@ -500,1 +501,1 @@\n-    FT_Byte*   p      = 0;\n+    FT_Byte*   p;\n@@ -506,2 +507,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -528,0 +527,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -536,1 +537,1 @@\n-    return 0;\n+    return result;\n@@ -545,1 +546,1 @@\n-    FT_Byte*   p      = 0;\n+    FT_Byte*   p;\n@@ -551,2 +552,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -573,0 +572,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -581,1 +582,1 @@\n-    return 0;\n+    return result;\n@@ -590,1 +591,1 @@\n-    FT_Byte*  p      = 0;\n+    FT_Byte*  p;\n@@ -596,2 +597,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -618,0 +617,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -626,1 +627,1 @@\n-    return 0;\n+    return result;\n@@ -635,1 +636,1 @@\n-    FT_Byte*  p      = 0;\n+    FT_Byte*  p;\n@@ -641,2 +642,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -663,0 +662,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -671,1 +672,1 @@\n-    return 0;\n+    return result;\n@@ -680,1 +681,1 @@\n-    FT_Byte*  p      = 0;\n+    FT_Byte*  p;\n@@ -686,2 +687,0 @@\n-    *error = FT_Err_Ok;\n-\n@@ -708,0 +707,2 @@\n+    *error = FT_Err_Ok;\n+\n@@ -716,1 +717,1 @@\n-    return 0;\n+    return result;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftstream.c","additions":43,"deletions":42,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n@@ -977,1 +977,2 @@\n-    FT_Vector        sigma, delta;\n+    FT_Vector        sigma = { 0, 0 };\n+    FT_Vector        delta;\n@@ -1051,1 +1052,1 @@\n-      FT_Vector  sigma;\n+      FT_Vector  sigma = { 0, 0 };\n@@ -1531,1 +1532,2 @@\n-    stroker->center = *to;\n+    stroker->center      = *to;\n+    stroker->line_length = 0;\n@@ -1747,1 +1749,2 @@\n-    stroker->center = *to;\n+    stroker->center      = *to;\n+    stroker->line_length = 0;\n@@ -1900,4 +1903,0 @@\n-      FT_Angle  turn;\n-      FT_Int    inside_side;\n-\n-\n@@ -1905,2 +1904,2 @@\n-      if ( stroker->center.x != stroker->subpath_start.x ||\n-           stroker->center.y != stroker->subpath_start.y )\n+      if ( !FT_IS_SMALL( stroker->center.x - stroker->subpath_start.x ) ||\n+           !FT_IS_SMALL( stroker->center.y - stroker->subpath_start.y ) )\n@@ -1915,9 +1914,0 @@\n-      turn               = FT_Angle_Diff( stroker->angle_in,\n-                                          stroker->angle_out );\n-\n-      \/* no specific corner processing is required if the turn is 0 *\/\n-      if ( turn != 0 )\n-      {\n-        \/* when we turn to the right, the inside side is 0 *\/\n-        \/* otherwise, the inside side is 1 *\/\n-        inside_side = ( turn < 0 );\n@@ -1925,13 +1915,4 @@\n-        error = ft_stroker_inside( stroker,\n-                                   inside_side,\n-                                   stroker->subpath_line_length );\n-        if ( error )\n-          goto Exit;\n-\n-        \/* process the outside side *\/\n-        error = ft_stroker_outside( stroker,\n-                                    !inside_side,\n-                                    stroker->subpath_line_length );\n-        if ( error )\n-          goto Exit;\n-      }\n+      error = ft_stroker_process_corner( stroker,\n+                                         stroker->subpath_line_length );\n+      if ( error )\n+        goto Exit;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftstroke.c","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftsynth.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -278,1 +278,1 @@\n-    FT_TRACE1(( \" opened `%s' (%d bytes) successfully\\n\",\n+    FT_TRACE1(( \" opened `%s' (%ld bytes) successfully\\n\",\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftsystem.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n@@ -56,1 +56,1 @@\n-#ifdef FT_LONG64\n+#ifdef FT_INT64\n@@ -79,1 +79,1 @@\n-#else \/* !FT_LONG64 *\/\n+#else \/* !FT_INT64 *\/\n@@ -128,1 +128,1 @@\n-#endif \/* !FT_LONG64 *\/\n+#endif \/* !FT_INT64 *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/fttrigon.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/fttype1.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftutil.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffcmap.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -348,2 +348,2 @@\n-                   \" cannot get glyph name from a CFF2 font\\n\"\n-                   \"                   \"\n+                   \" cannot get glyph name from a CFF2 font\\n\" ));\n+        FT_ERROR(( \"                   \"\n@@ -359,2 +359,2 @@\n-                 \" cannot get glyph name from CFF & CEF fonts\\n\"\n-                 \"                   \"\n+                 \" cannot get glyph name from CFF & CEF fonts\\n\" ));\n+      FT_ERROR(( \"                   \"\n@@ -415,2 +415,2 @@\n-                   \" cannot get glyph index from a CFF2 font\\n\"\n-                   \"                   \"\n+                   \" cannot get glyph index from a CFF2 font\\n\" ));\n+        FT_ERROR(( \"                   \"\n@@ -477,1 +477,0 @@\n-      PS_FontInfoRec  *font_info = NULL;\n@@ -479,0 +478,1 @@\n+      PS_FontInfoRec*  font_info = NULL;\n@@ -481,1 +481,1 @@\n-      if ( FT_ALLOC( font_info, sizeof ( *font_info ) ) )\n+      if ( FT_QNEW( font_info ) )\n@@ -518,1 +518,1 @@\n-    if ( cff && cff->font_extra == NULL )\n+    if ( cff && !cff->font_extra )\n@@ -521,1 +521,0 @@\n-      PS_FontExtraRec*  font_extra = NULL;\n@@ -523,0 +522,1 @@\n+      PS_FontExtraRec*  font_extra = NULL;\n@@ -526,1 +526,1 @@\n-      if ( FT_ALLOC( font_extra, sizeof ( *font_extra ) ) )\n+      if ( FT_QNEW( font_extra ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffdrivr.c","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffdrivr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cfferrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -32,0 +32,8 @@\n+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n+#define IS_DEFAULT_INSTANCE( _face )             \\\n+          ( !( FT_IS_NAMED_INSTANCE( _face ) ||  \\\n+               FT_IS_VARIATION( _face )      ) )\n+#else\n+#define IS_DEFAULT_INSTANCE( _face )  1\n+#endif\n+\n@@ -62,1 +70,1 @@\n-      *length  = (FT_ULong)data.length;\n+      *length  = data.length;\n@@ -97,1 +105,1 @@\n-      data.length  = (FT_Int)length;\n+      data.length  = (FT_UInt)length;\n@@ -258,2 +266,2 @@\n-           sfnt->load_eblc                         &&\n-           ( load_flags & FT_LOAD_NO_BITMAP ) == 0 )\n+           ( load_flags & FT_LOAD_NO_BITMAP ) == 0 &&\n+           IS_DEFAULT_INSTANCE( size->root.face )  )\n@@ -349,0 +357,70 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+    \/* check for OT-SVG *\/\n+    if ( ( load_flags & FT_LOAD_COLOR )     &&\n+         ( (TT_Face)glyph->root.face )->svg )\n+    {\n+      \/*\n+       * We load the SVG document and try to grab the advances from the\n+       * table.  For the bearings we rely on the presetting hook to do that.\n+       *\/\n+\n+      FT_Short      dummy;\n+      FT_UShort     advanceX;\n+      FT_UShort     advanceY;\n+      SFNT_Service  sfnt;\n+\n+\n+      if ( size->root.metrics.x_ppem < 1 ||\n+           size->root.metrics.y_ppem < 1 )\n+      {\n+        error = FT_THROW( Invalid_Size_Handle );\n+        return error;\n+      }\n+\n+      FT_TRACE3(( \"Trying to load SVG glyph\\n\" ));\n+\n+      sfnt  = (SFNT_Service)((TT_Face)glyph->root.face)->sfnt;\n+      error = sfnt->load_svg_doc( (FT_GlyphSlot)glyph, glyph_index );\n+      if ( !error )\n+      {\n+        FT_TRACE3(( \"Successfully loaded SVG glyph\\n\" ));\n+\n+        glyph->root.format = FT_GLYPH_FORMAT_SVG;\n+\n+        \/*\n+         * If horizontal or vertical advances are not present in the table,\n+         * this is a problem with the font since the standard requires them.\n+         * However, we are graceful and calculate the values by ourselves\n+         * for the vertical case.\n+         *\/\n+        sfnt->get_metrics( face,\n+                           FALSE,\n+                           glyph_index,\n+                           &dummy,\n+                           &advanceX );\n+        sfnt->get_metrics( face,\n+                           TRUE,\n+                           glyph_index,\n+                           &dummy,\n+                           &advanceY );\n+\n+        advanceX =\n+          (FT_UShort)FT_MulDiv( advanceX,\n+                                glyph->root.face->size->metrics.x_ppem,\n+                                glyph->root.face->units_per_EM );\n+        advanceY =\n+          (FT_UShort)FT_MulDiv( advanceY,\n+                                glyph->root.face->size->metrics.y_ppem,\n+                                glyph->root.face->units_per_EM );\n+\n+        glyph->root.metrics.horiAdvance = advanceX << 6;\n+        glyph->root.metrics.vertAdvance = advanceY << 6;\n+\n+        return error;\n+      }\n+\n+      FT_TRACE3(( \"Failed to load SVG glyph\\n\" ));\n+    }\n+\n+#endif \/* FT_CONFIG_OPTION_SVG *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffgload.c","additions":83,"deletions":5,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -359,3 +359,3 @@\n-      if ( FT_NEW_ARRAY( idx->offsets, idx->count + 1 ) ||\n-           FT_STREAM_SEEK( idx->start + idx->hdr_size ) ||\n-           FT_FRAME_ENTER( data_size )                  )\n+      if ( FT_QNEW_ARRAY( idx->offsets, idx->count + 1 ) ||\n+           FT_STREAM_SEEK( idx->start + idx->hdr_size )  ||\n+           FT_FRAME_ENTER( data_size )                   )\n@@ -403,1 +403,1 @@\n-  \/* entries to C-style strings (this is, NULL-terminated).       *\/\n+  \/* entries to C-style strings (this is, null-terminated).       *\/\n@@ -430,1 +430,1 @@\n-         !FT_NEW_ARRAY( tbl, idx->count + 1 )          &&\n+         !FT_QNEW_ARRAY( tbl, idx->count + 1 )         &&\n@@ -625,1 +625,1 @@\n-    FT_String*  name = 0;\n+    FT_String*  name = NULL;\n@@ -637,1 +637,1 @@\n-    if ( !FT_ALLOC( name, byte_len + 1 ) )\n+    if ( !FT_QALLOC( name, byte_len + 1 ) )\n@@ -639,2 +639,1 @@\n-      if ( byte_len )\n-        FT_MEM_COPY( name, bytes, byte_len );\n+      FT_MEM_COPY( name, bytes, byte_len );\n@@ -775,2 +774,1 @@\n-      if ( (FT_UInt)( glyph_index - fdselect->cache_first ) <\n-                        fdselect->cache_count )\n+      if ( glyph_index - fdselect->cache_first < fdselect->cache_count )\n@@ -839,1 +837,0 @@\n-    FT_Long    j;\n@@ -857,3 +854,4 @@\n-    \/* behaviour of recent Acroread versions.                       *\/\n-    for ( j = (FT_Long)num_glyphs - 1; j >= 0; j-- )\n-      charset->cids[charset->sids[j]] = (FT_UShort)j;\n+    \/* behaviour of recent Acroread versions.  The loop stops when  *\/\n+    \/* the unsigned index wraps around after reaching zero.         *\/\n+    for ( i = num_glyphs - 1; i < num_glyphs; i-- )\n+      charset->cids[charset->sids[i]] = (FT_UShort)i;\n@@ -935,1 +933,1 @@\n-      if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n+      if ( FT_QNEW_ARRAY( charset->sids, num_glyphs ) )\n@@ -1021,2 +1019,2 @@\n-          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\"\n-                     \"predefined charset (Adobe ISO-Latin)\\n\" ));\n+          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\" ));\n+          FT_ERROR(( \"predefined charset (Adobe ISO-Latin)\\n\" ));\n@@ -1028,1 +1026,1 @@\n-        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n+        if ( FT_QNEW_ARRAY( charset->sids, num_glyphs ) )\n@@ -1039,2 +1037,2 @@\n-          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\"\n-                     \"predefined charset (Adobe Expert)\\n\" ));\n+          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\" ));\n+          FT_ERROR(( \"predefined charset (Adobe Expert)\\n\" ));\n@@ -1046,1 +1044,1 @@\n-        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n+        if ( FT_QNEW_ARRAY( charset->sids, num_glyphs ) )\n@@ -1057,2 +1055,2 @@\n-          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\"\n-                     \"predefined charset (Adobe Expert Subset)\\n\" ));\n+          FT_ERROR(( \"cff_charset_load: implicit charset larger than\\n\" ));\n+          FT_ERROR(( \"predefined charset (Adobe Expert Subset)\\n\" ));\n@@ -1064,1 +1062,1 @@\n-        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n+        if ( FT_QNEW_ARRAY( charset->sids, num_glyphs ) )\n@@ -1090,1 +1088,0 @@\n-      charset->sids   = 0;\n@@ -1144,0 +1141,2 @@\n+      FT_UInt   dataCount;\n+      FT_UInt   regionCount;\n@@ -1166,2 +1165,2 @@\n-      if ( FT_READ_ULONG( regionListOffset )   ||\n-           FT_READ_USHORT( vstore->dataCount ) )\n+      if ( FT_READ_ULONG( regionListOffset ) ||\n+           FT_READ_USHORT( dataCount )       )\n@@ -1172,1 +1171,1 @@\n-      if ( FT_NEW_ARRAY( dataOffsetArray, vstore->dataCount ) )\n+      if ( FT_QNEW_ARRAY( dataOffsetArray, dataCount ) )\n@@ -1175,1 +1174,1 @@\n-      for ( i = 0; i < vstore->dataCount; i++ )\n+      for ( i = 0; i < dataCount; i++ )\n@@ -1184,1 +1183,1 @@\n-           FT_READ_USHORT( vstore->regionCount )         )\n+           FT_READ_USHORT( regionCount )                 )\n@@ -1187,1 +1186,2 @@\n-      if ( FT_NEW_ARRAY( vstore->varRegionList, vstore->regionCount ) )\n+      vstore->regionCount = 0;\n+      if ( FT_QNEW_ARRAY( vstore->varRegionList, regionCount ) )\n@@ -1190,1 +1190,1 @@\n-      for ( i = 0; i < vstore->regionCount; i++ )\n+      for ( i = 0; i < regionCount; i++ )\n@@ -1195,1 +1195,1 @@\n-        if ( FT_NEW_ARRAY( region->axisList, vstore->axisCount ) )\n+        if ( FT_QNEW_ARRAY( region->axisList, vstore->axisCount ) )\n@@ -1198,0 +1198,3 @@\n+        \/* keep track of how many axisList to deallocate on error *\/\n+        vstore->regionCount++;\n+\n@@ -1217,1 +1220,2 @@\n-      if ( FT_NEW_ARRAY( vstore->varData, vstore->dataCount ) )\n+      vstore->dataCount = 0;\n+      if ( FT_QNEW_ARRAY( vstore->varData, dataCount ) )\n@@ -1220,1 +1224,1 @@\n-      for ( i = 0; i < vstore->dataCount; i++ )\n+      for ( i = 0; i < dataCount; i++ )\n@@ -1239,1 +1243,1 @@\n-        if ( FT_NEW_ARRAY( data->regionIndices, data->regionIdxCount ) )\n+        if ( FT_QNEW_ARRAY( data->regionIndices, data->regionIdxCount ) )\n@@ -1242,0 +1246,3 @@\n+        \/* keep track of how many regionIndices to deallocate on error *\/\n+        vstore->dataCount++;\n+\n@@ -1325,3 +1332,3 @@\n-      if ( FT_REALLOC( subFont->blend_stack,\n-                       subFont->blend_alloc,\n-                       subFont->blend_alloc + size ) )\n+      if ( FT_QREALLOC( subFont->blend_stack,\n+                        subFont->blend_alloc,\n+                        subFont->blend_alloc + size ) )\n@@ -1440,3 +1447,1 @@\n-    if ( FT_REALLOC( blend->BV,\n-                     blend->lenBV * sizeof( *blend->BV ),\n-                     len * sizeof( *blend->BV ) ) )\n+    if ( FT_QRENEW_ARRAY( blend->BV, blend->lenBV, len ) )\n@@ -1459,4 +1464,2 @@\n-        FT_TRACE4(( \"   build blend vector len %d\\n\"\n-                    \"   [ %f \",\n-                    len,\n-                    blend->BV[master] \/ 65536.0 ));\n+        FT_TRACE4(( \"   build blend vector len %d\\n\", len ));\n+        FT_TRACE4(( \"   [ %f \", blend->BV[master] \/ 65536.0 ));\n@@ -1546,3 +1549,1 @@\n-      if ( FT_REALLOC( blend->lastNDV,\n-                       blend->lenNDV * sizeof ( *NDV ),\n-                       lenNDV * sizeof ( *NDV ) ) )\n+      if ( FT_QRENEW_ARRAY( blend->lastNDV, blend->lenNDV, lenNDV ) )\n@@ -1830,1 +1831,2 @@\n-        encoding->count = 0;\n+        encoding->offset = offset; \/* used in cff_face_init *\/\n+        encoding->count  = 0;\n@@ -2366,2 +2368,2 @@\n-                   \" invalid CFF font with multiple subfonts\\n\"\n-                   \"              \"\n+                   \" invalid CFF font with multiple subfonts\\n\" ));\n+        FT_ERROR(( \"              \"\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffload.c","additions":56,"deletions":54,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -286,0 +286,2 @@\n+    FT_Error  error;\n+\n@@ -307,1 +309,3 @@\n-    FT_Request_Metrics( size->face, req );\n+    error = FT_Request_Metrics( size->face, req );\n+    if ( error )\n+      goto Exit;\n@@ -348,1 +352,2 @@\n-    return FT_Err_Ok;\n+  Exit:\n+    return error;\n@@ -409,3 +414,1 @@\n-    (void)FT_STRDUP( result, source );\n-\n-    FT_UNUSED( error );\n+    FT_MEM_STRDUP( result, source );\n@@ -662,2 +665,2 @@\n-                   \" cannot open CFF & CEF fonts\\n\"\n-                   \"              \"\n+                   \" cannot open CFF & CEF fonts\\n\" ));\n+        FT_ERROR(( \"              \"\n@@ -687,1 +690,1 @@\n-        \/* which may contain NULL bytes in the middle of the data, too. *\/\n+        \/* which may contain null bytes in the middle of the data, too. *\/\n@@ -693,1 +696,1 @@\n-          FT_PtrDist  s1len = s2 - s1 - 1; \/* without the final NULL byte *\/\n+          FT_PtrDist  s1len = s2 - s1 - 1; \/* without the final null byte *\/\n@@ -1052,1 +1055,1 @@\n-        FT_UInt        nn;\n+        FT_Int         nn;\n@@ -1056,1 +1059,1 @@\n-        for ( nn = 0; nn < (FT_UInt)cffface->num_charmaps; nn++ )\n+        for ( nn = 0; nn < cffface->num_charmaps; nn++ )\n@@ -1081,1 +1084,1 @@\n-        nn = (FT_UInt)cffface->num_charmaps;\n+        nn = cffface->num_charmaps;\n@@ -1092,1 +1095,1 @@\n-        if ( !cffface->charmap && nn != (FT_UInt)cffface->num_charmaps )\n+        if ( !cffface->charmap && nn != cffface->num_charmaps )\n@@ -1177,3 +1180,0 @@\n-#ifdef CFF_CONFIG_OPTION_OLD_ENGINE\n-    driver->hinting_engine = FT_HINTING_FREETYPE;\n-#else\n@@ -1181,1 +1181,0 @@\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffobjs.c","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -65,1 +65,1 @@\n-    if ( FT_NEW_ARRAY( parser->stack, stackSize ) )\n+    if ( FT_QNEW_ARRAY( parser->stack, stackSize ) )\n@@ -716,3 +716,4 @@\n-                    \" strange scaling values (minimum %ld, maximum %ld),\\n\"\n-                    \"                      \"\n-                    \" using default matrix\\n\", min_scaling, max_scaling ));\n+                    \" strange scaling values (minimum %ld, maximum %ld),\\n\",\n+                    min_scaling, max_scaling ));\n+        FT_TRACE1(( \"                      \"\n+                    \" using default matrix\\n\" ));\n@@ -1518,0 +1519,1 @@\n+                break;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffparse.c","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cffparse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cff\/cfftoken.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/ciderrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -66,1 +66,1 @@\n-    FT_TRACE1(( \"cid_load_glyph: glyph index %d\\n\", glyph_index ));\n+    FT_TRACE1(( \"cid_load_glyph: glyph index %u\\n\", glyph_index ));\n@@ -79,1 +79,1 @@\n-      if ( error )\n+      if ( error || glyph_data.length < cid->fd_bytes )\n@@ -83,1 +83,1 @@\n-      fd_select = cid_get_offset( &p, (FT_Byte)cid->fd_bytes );\n+      fd_select = cid_get_offset( &p, cid->fd_bytes );\n@@ -85,6 +85,4 @@\n-      if ( glyph_data.length != 0 )\n-      {\n-        glyph_length = (FT_ULong)( glyph_data.length - cid->fd_bytes );\n-        (void)FT_ALLOC( charstring, glyph_length );\n-        if ( !error )\n-          ft_memcpy( charstring, glyph_data.pointer + cid->fd_bytes,\n+      glyph_length = glyph_data.length - cid->fd_bytes;\n+\n+      if ( !FT_QALLOC( charstring, glyph_length ) )\n+        FT_MEM_COPY( charstring, glyph_data.pointer + cid->fd_bytes,\n@@ -92,1 +90,0 @@\n-      }\n@@ -107,1 +104,1 @@\n-      FT_UInt   entry_len = (FT_UInt)( cid->fd_bytes + cid->gd_bytes );\n+      FT_UInt   entry_len = cid->fd_bytes + cid->gd_bytes;\n@@ -117,2 +114,2 @@\n-      fd_select = cid_get_offset( &p, (FT_Byte)cid->fd_bytes );\n-      off1      = cid_get_offset( &p, (FT_Byte)cid->gd_bytes );\n+      fd_select = cid_get_offset( &p, cid->fd_bytes );\n+      off1      = cid_get_offset( &p, cid->gd_bytes );\n@@ -120,1 +117,1 @@\n-      off2      = cid_get_offset( &p, (FT_Byte)cid->gd_bytes );\n+      off2      = cid_get_offset( &p, cid->gd_bytes );\n@@ -123,3 +120,3 @@\n-      if ( fd_select >= (FT_ULong)cid->num_dicts ||\n-           off2 > stream->size                   ||\n-           off1 > off2                           )\n+      if ( fd_select >= cid->num_dicts ||\n+           off2 > stream->size         ||\n+           off1 > off2                 )\n@@ -133,5 +130,4 @@\n-      if ( glyph_length == 0 )\n-        goto Exit;\n-      if ( FT_ALLOC( charstring, glyph_length ) )\n-        goto Exit;\n-      if ( FT_STREAM_READ_AT( cid->data_offset + off1,\n+\n+      if ( glyph_length == 0                             ||\n+           FT_QALLOC( charstring, glyph_length )         ||\n+           FT_STREAM_READ_AT( cid->data_offset + off1,\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidgload.c","additions":19,"deletions":23,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -44,1 +44,1 @@\n-                  FT_Byte    offsize )\n+                  FT_UInt    offsize )\n@@ -116,1 +116,1 @@\n-        if ( parser->num_dict < 0 || parser->num_dict >= cid->num_dicts )\n+        if ( parser->num_dict >= cid->num_dicts )\n@@ -167,1 +167,1 @@\n-    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n+    if ( parser->num_dict < face->cid.num_dicts )\n@@ -247,1 +247,1 @@\n-    FT_Long       num_dicts;\n+    FT_Long       num_dicts, max_dicts;\n@@ -251,1 +251,1 @@\n-    if ( num_dicts < 0 )\n+    if ( num_dicts < 0 || num_dicts > FT_INT_MAX )\n@@ -275,1 +275,2 @@\n-    if ( (FT_ULong)num_dicts > stream->size \/ 100 )\n+    max_dicts = (FT_Long)( stream->size \/ 100 );\n+    if ( num_dicts > max_dicts )\n@@ -279,3 +280,2 @@\n-                  num_dicts,\n-                  stream->size \/ 100 ));\n-      num_dicts = (FT_Long)( stream->size \/ 100 );\n+                  num_dicts, max_dicts ));\n+      num_dicts = max_dicts;\n@@ -286,1 +286,1 @@\n-      FT_Int  n;\n+      FT_UInt  n;\n@@ -325,1 +325,1 @@\n-    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n+    if ( parser->num_dict < face->cid.num_dicts )\n@@ -348,1 +348,1 @@\n-    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n+    if ( parser->num_dict < face->cid.num_dicts )\n@@ -430,1 +430,1 @@\n-              FT_TRACE4(( \" FontDict %d\", parser->num_dict ));\n+              FT_TRACE4(( \" FontDict %u\", parser->num_dict ));\n@@ -520,1 +520,1 @@\n-    FT_Int         n;\n+    FT_UInt        n;\n@@ -555,1 +555,1 @@\n-        if ( FT_RENEW_ARRAY( offsets, max_offsets, new_max ) )\n+        if ( FT_QRENEW_ARRAY( offsets, max_offsets, new_max ) )\n@@ -562,2 +562,2 @@\n-      if ( FT_STREAM_SEEK( cid->data_offset + dict->subrmap_offset )     ||\n-           FT_FRAME_ENTER( ( num_subrs + 1 ) * (FT_UInt)dict->sd_bytes ) )\n+      if ( FT_STREAM_SEEK( cid->data_offset + dict->subrmap_offset ) ||\n+           FT_FRAME_ENTER( ( num_subrs + 1 ) * dict->sd_bytes )      )\n@@ -568,1 +568,1 @@\n-        offsets[count] = cid_get_offset( &p, (FT_Byte)dict->sd_bytes );\n+        offsets[count] = cid_get_offset( &p, dict->sd_bytes );\n@@ -592,2 +592,2 @@\n-      if ( FT_NEW_ARRAY( subr->code, num_subrs + 1 ) ||\n-           FT_ALLOC( subr->code[0], data_len )       )\n+      if ( FT_QNEW_ARRAY( subr->code, num_subrs + 1 ) ||\n+           FT_QALLOC( subr->code[0], data_len )       )\n@@ -597,1 +597,1 @@\n-           FT_STREAM_READ( subr->code[0], data_len )  )\n+           FT_STREAM_READ( subr->code[0], data_len )       )\n@@ -668,4 +668,5 @@\n-  cid_hex_to_binary( FT_Byte*  data,\n-                     FT_ULong  data_len,\n-                     FT_ULong  offset,\n-                     CID_Face  face )\n+  cid_hex_to_binary( FT_Byte*   data,\n+                     FT_ULong   data_len,\n+                     FT_ULong   offset,\n+                     CID_Face   face,\n+                     FT_ULong*  data_written )\n@@ -678,1 +679,1 @@\n-    FT_Byte   *d, *dlimit;\n+    FT_Byte   *d = data, *dlimit;\n@@ -687,1 +688,0 @@\n-    d      = data;\n@@ -761,0 +761,1 @@\n+    *data_written = (FT_ULong)( d - data );\n@@ -773,1 +774,1 @@\n-    FT_Int       n;\n+    FT_UInt      n;\n@@ -778,1 +779,0 @@\n-    FT_ULong  entry_len;\n@@ -806,2 +806,2 @@\n-        FT_TRACE0(( \"cid_face_open: adjusting length of binary data\\n\"\n-                    \"               (from %ld to %ld bytes)\\n\",\n+        FT_TRACE0(( \"cid_face_open: adjusting length of binary data\\n\" ));\n+        FT_TRACE0(( \"               (from %lu to %lu bytes)\\n\",\n@@ -815,1 +815,1 @@\n-      if ( FT_ALLOC( face->binary_data, parser->binary_length )    ||\n+      if ( FT_QALLOC( face->binary_data, parser->binary_length )   ||\n@@ -819,1 +819,2 @@\n-                                            face ) )               )\n+                                            face,\n+                                            &binary_length ) )     )\n@@ -823,1 +824,1 @@\n-                            face->binary_data, parser->binary_length );\n+                            face->binary_data, binary_length );\n@@ -834,1 +835,1 @@\n-    if ( cid->fd_bytes < 0 || cid->gd_bytes < 1 )\n+    if ( cid->gd_bytes == 0 )\n@@ -837,1 +838,1 @@\n-                 \" Invalid `FDBytes' or `GDBytes' value\\n\" ));\n+                 \" Invalid `GDBytes' value\\n\" ));\n@@ -846,2 +847,2 @@\n-                 \" Values of `FDBytes' or `GDBytes' larger than 4\\n\"\n-                 \"               \"\n+                 \" Values of `FDBytes' or `GDBytes' larger than 4\\n\" ));\n+      FT_ERROR(( \"               \"\n@@ -854,1 +855,18 @@\n-    entry_len     = (FT_ULong)( cid->fd_bytes + cid->gd_bytes );\n+\n+    if ( cid->cidmap_offset > binary_length )\n+    {\n+      FT_ERROR(( \"cid_face_open: Invalid `CIDMapOffset' value\\n\" ));\n+      error = FT_THROW( Invalid_File_Format );\n+      goto Exit;\n+    }\n+\n+    \/* the initial pre-check prevents the multiplication overflow *\/\n+    if ( cid->cid_count > FT_ULONG_MAX \/ 8                    ||\n+         cid->cid_count * ( cid->fd_bytes + cid->gd_bytes ) >\n+           binary_length - cid->cidmap_offset                 )\n+    {\n+      FT_ERROR(( \"cid_face_open: Invalid `CIDCount' value\\n\" ));\n+      error = FT_THROW( Invalid_File_Format );\n+      goto Exit;\n+    }\n+\n@@ -880,2 +898,1 @@\n-      if ( dict->sd_bytes < 0                        ||\n-           ( dict->num_subrs && dict->sd_bytes < 1 ) )\n+      if ( dict->num_subrs && dict->sd_bytes == 0 )\n@@ -904,5 +921,4 @@\n-      \/* `num_subrs' is scanned as a signed integer *\/\n-      if ( (FT_Int)dict->num_subrs < 0                                     ||\n-           ( dict->sd_bytes                                              &&\n-             dict->num_subrs > ( binary_length - dict->subrmap_offset ) \/\n-                                 (FT_UInt)dict->sd_bytes                 ) )\n+      \/* the initial pre-check prevents the multiplication overflow *\/\n+      if ( dict->num_subrs > FT_UINT_MAX \/ 4      ||\n+           dict->num_subrs * dict->sd_bytes >\n+             binary_length - dict->subrmap_offset )\n@@ -916,16 +932,0 @@\n-    if ( cid->cidmap_offset > binary_length )\n-    {\n-      FT_ERROR(( \"cid_face_open: Invalid `CIDMapOffset' value\\n\" ));\n-      error = FT_THROW( Invalid_File_Format );\n-      goto Exit;\n-    }\n-\n-    if ( entry_len                                            &&\n-         cid->cid_count >\n-           ( binary_length - cid->cidmap_offset ) \/ entry_len )\n-    {\n-      FT_ERROR(( \"cid_face_open: Invalid `CIDCount' value\\n\" ));\n-      error = FT_THROW( Invalid_File_Format );\n-      goto Exit;\n-    }\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidload.c","additions":63,"deletions":63,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -40,1 +40,1 @@\n-                  FT_Byte    offsize );\n+                  FT_UInt    offsize );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidload.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -160,0 +160,2 @@\n+    FT_Error  error;\n+\n@@ -163,1 +165,3 @@\n-    FT_Request_Metrics( size->face, req );\n+    error = FT_Request_Metrics( size->face, req );\n+    if ( error )\n+      goto Exit;\n@@ -173,1 +177,2 @@\n-    return FT_Err_Ok;\n+  Exit:\n+    return error;\n@@ -214,1 +219,1 @@\n-      FT_Int  n;\n+      FT_UInt  n;\n@@ -482,3 +487,0 @@\n-#ifdef T1_CONFIG_OPTION_OLD_ENGINE\n-    driver->hinting_engine = FT_HINTING_FREETYPE;\n-#else\n@@ -486,1 +488,0 @@\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidobjs.c","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -76,0 +76,3 @@\n+    {\n+      FT_TRACE2(( \"  not a CID-keyed font\\n\" ));\n+      error = FT_THROW( Unknown_File_Format );\n@@ -77,0 +80,1 @@\n+    }\n@@ -184,1 +188,1 @@\n-    parser->num_dict       = -1;\n+    parser->num_dict       = FT_UINT_MAX;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidparse.c","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -81,1 +81,1 @@\n-    FT_Int        num_dict;\n+    FT_UInt       num_dict;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidparse.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidriver.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/cid\/cidtoken.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n@@ -30,0 +30,10 @@\n+  \/**************************************************************************\n+   *\n+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit\n+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print\/log\n+   * messages during execution.\n+   *\/\n+#undef  FT_COMPONENT\n+#define FT_COMPONENT  afmparse\n+\n+\n@@ -589,1 +599,2 @@\n-    AFM_FontInfo   fi = parser->FontInfo;\n+    AFM_FontInfo   fi     = parser->FontInfo;\n+    AFM_Stream     stream = parser->stream;\n@@ -591,4 +602,5 @@\n-    char*          key;\n-    FT_Offset      len;\n-    int            n = -1;\n-    FT_Int         tmp;\n+\n+    char*      key;\n+    FT_Offset  len;\n+    int        n = -1;\n+    FT_Int     tmp;\n@@ -601,0 +613,2 @@\n+    {\n+      FT_ERROR(( \"afm_parse_track_kern: invalid number of track kerns\\n\" ));\n@@ -602,0 +616,1 @@\n+    }\n@@ -604,0 +619,13 @@\n+    FT_TRACE3(( \"afm_parse_track_kern: %u track kern%s expected\\n\",\n+                fi->NumTrackKern,\n+                fi->NumTrackKern == 1 ? \"\" : \"s\" ));\n+\n+    \/* Rough sanity check: The minimum line length of the `TrackKern` *\/\n+    \/* command is 20 characters (including the EOL character).        *\/\n+    if ( (FT_ULong)( stream->limit - stream->cursor ) \/ 20 <\n+           fi->NumTrackKern )\n+    {\n+      FT_ERROR(( \"afm_parse_track_kern:\"\n+                 \" number of track kern entries exceeds stream size\\n\" ));\n+      goto Fail;\n+    }\n@@ -626,1 +654,4 @@\n-          goto Fail;\n+          {\n+            FT_ERROR(( \"afm_parse_track_kern: too many track kern data\\n\" ));\n+            goto Fail;\n+          }\n@@ -636,0 +667,4 @@\n+        {\n+          FT_ERROR(( \"afm_parse_track_kern:\"\n+                     \" insufficient number of parameters for entry %d\\n\",\n+                     n ));\n@@ -637,0 +672,1 @@\n+        }\n@@ -649,1 +685,13 @@\n-        fi->NumTrackKern = (FT_UInt)( n + 1 );\n+        tmp = n + 1;\n+        if ( (FT_UInt)tmp != fi->NumTrackKern )\n+        {\n+          FT_TRACE1(( \"afm_parse_track_kern: %s%d track kern entr%s seen\\n\",\n+                      tmp == 0 ? \"\" : \"only \",\n+                      tmp,\n+                      tmp == 1 ? \"y\" : \"ies\" ));\n+          fi->NumTrackKern = (FT_UInt)tmp;\n+        }\n+        else\n+          FT_TRACE3(( \"afm_parse_track_kern: %d track kern entr%s seen\\n\",\n+                      tmp,\n+                      tmp == 1 ? \"y\" : \"ies\" ));\n@@ -670,1 +718,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n@@ -693,1 +741,2 @@\n-    AFM_FontInfo  fi = parser->FontInfo;\n+    AFM_FontInfo  fi     = parser->FontInfo;\n+    AFM_Stream    stream = parser->stream;\n@@ -705,0 +754,2 @@\n+    {\n+      FT_ERROR(( \"afm_parse_kern_pairs: invalid number of kern pairs\\n\" ));\n@@ -706,0 +757,1 @@\n+    }\n@@ -708,0 +760,14 @@\n+    FT_TRACE3(( \"afm_parse_kern_pairs: %u kern pair%s expected\\n\",\n+                fi->NumKernPair,\n+                fi->NumKernPair == 1 ? \"\" : \"s\" ));\n+\n+    \/* Rough sanity check: The minimum line length of the `KP`,    *\/\n+    \/* `KPH`,`KPX`, and `KPY` commands is 10 characters (including *\/\n+    \/* the EOL character).                                         *\/\n+    if ( (FT_ULong)( stream->limit - stream->cursor ) \/ 10 <\n+           fi->NumKernPair )\n+    {\n+      FT_ERROR(( \"afm_parse_kern_pairs:\"\n+                 \" number of kern pairs exceeds stream size\\n\" ));\n+      goto Fail;\n+    }\n@@ -737,0 +803,2 @@\n+          {\n+            FT_ERROR(( \"afm_parse_kern_pairs: too many kern pairs\\n\" ));\n@@ -738,0 +806,1 @@\n+          }\n@@ -747,0 +816,4 @@\n+          {\n+            FT_ERROR(( \"afm_parse_kern_pairs:\"\n+                       \" insufficient number of parameters for entry %d\\n\",\n+                       n ));\n@@ -748,0 +821,1 @@\n+          }\n@@ -769,1 +843,14 @@\n-        fi->NumKernPair = (FT_UInt)( n + 1 );\n+        tmp = n + 1;\n+        if ( (FT_UInt)tmp != fi->NumKernPair )\n+        {\n+          FT_TRACE1(( \"afm_parse_kern_pairs: %s%d kern pair%s seen\\n\",\n+                      tmp == 0 ? \"\" : \"only \",\n+                      tmp,\n+                      tmp == 1 ? \"\" : \"s\" ));\n+          fi->NumKernPair = (FT_UInt)tmp;\n+        }\n+        else\n+          FT_TRACE3(( \"afm_parse_kern_pairs: %d kern pair%s seen\\n\",\n+                      tmp,\n+                      tmp == 1 ? \"\" : \"s\" ));\n+\n@@ -795,0 +882,3 @@\n+    int  have_trackkern = 0;\n+    int  have_kernpairs = 0;\n+\n@@ -801,0 +891,7 @@\n+        if ( have_trackkern )\n+        {\n+          FT_ERROR(( \"afm_parse_kern_data:\"\n+                     \" invalid second horizontal track kern section\\n\" ));\n+          goto Fail;\n+        }\n+\n@@ -804,0 +901,2 @@\n+\n+        have_trackkern = 1;\n@@ -808,0 +907,7 @@\n+        if ( have_kernpairs )\n+        {\n+          FT_ERROR(( \"afm_parse_kern_data:\"\n+                     \" invalid second horizontal kern pair section\\n\" ));\n+          goto Fail;\n+        }\n+\n@@ -811,0 +917,2 @@\n+\n+        have_kernpairs = 1;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/afmparse.c","additions":119,"deletions":11,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/afmparse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2022 by\n@@ -1874,1 +1874,1 @@\n-            FT_Int    idx = (FT_Int)( args[1] >> 16 );\n+            FT_UInt   idx = (FT_UInt)( args[1] >> 16 );\n@@ -1883,1 +1883,1 @@\n-            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n+            if ( idx < CFF_MAX_TRANS_ELEMENTS )\n@@ -1890,1 +1890,1 @@\n-            FT_Int    idx = (FT_Int)( args[0] >> 16 );\n+            FT_UInt   idx = (FT_UInt)( args[0] >> 16 );\n@@ -1896,1 +1896,1 @@\n-            if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )\n+            if ( idx < CFF_MAX_TRANS_ELEMENTS )\n@@ -1917,3 +1917,3 @@\n-            FT_Int  reg_idx = (FT_Int)args[0];\n-            FT_Int  idx     = (FT_Int)args[1];\n-            FT_Int  count   = (FT_Int)args[2];\n+            FT_UInt  reg_idx = (FT_UInt)args[0];\n+            FT_UInt  idx     = (FT_UInt)args[1];\n+            FT_UInt  count   = (FT_UInt)args[2];\n@@ -1927,3 +1927,3 @@\n-            if ( reg_idx >= 0 && reg_idx <= 2             &&\n-                 idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS &&\n-                 count >= 0 && count <= num_axes          )\n+            if ( reg_idx <= 2                 &&\n+                 idx < CFF_MAX_TRANS_ELEMENTS &&\n+                 count <= num_axes            )\n@@ -1931,1 +1931,1 @@\n-              FT_Int  end, i;\n+              FT_UInt  end, i;\n@@ -2156,1 +2156,1 @@\n-            FT_TRACE4(( \" callsubr (idx %d, entering level %d)\\n\",\n+            FT_TRACE4(( \" callsubr (idx %d, entering level %ld)\\n\",\n@@ -2200,1 +2200,1 @@\n-            FT_TRACE4(( \" callgsubr (idx %d, entering level %d)\\n\",\n+            FT_TRACE4(( \" callgsubr (idx %d, entering level %ld)\\n\",\n@@ -2239,1 +2239,1 @@\n-          FT_TRACE4(( \" return (leaving level %d)\\n\",\n+          FT_TRACE4(( \" return (leaving level %ld)\\n\",\n@@ -2274,1 +2274,2 @@\n-    FT_TRACE4(( \"..end..\\n\\n\" ));\n+    FT_TRACE4(( \"..end..\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/cffdecode.c","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2017-2020 by\n+ * Copyright (C) 2017-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/cffdecode.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-    arrstack->chunk     = 10;    \/* chunks of 10 items *\/\n@@ -113,1 +112,1 @@\n-      if ( !FT_REALLOC( arrstack->ptr, arrstack->totalSize, newSize ) )\n+      if ( !FT_QREALLOC( arrstack->ptr, arrstack->totalSize, newSize ) )\n@@ -219,1 +218,1 @@\n-      \/* grow the buffer by one chunk *\/\n+      \/* increase the buffer size *\/\n@@ -221,1 +220,1 @@\n-             arrstack, arrstack->allocated + arrstack->chunk ) )\n+             arrstack, arrstack->allocated * 2 + 16 ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psarrst.c","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-    size_t  chunk;          \/* allocation increment in items *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psarrst.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psauxerr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psauxmod.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psauxmod.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -509,1 +509,2 @@\n-                      blues->zone[i].dsFlatEdge - cf2_intToFixed( 1 ) );\n+                      SUB_INT32( blues->zone[i].dsFlatEdge,\n+                                 cf2_intToFixed( 1 ) ) );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psblues.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psconv.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psconv.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -745,1 +745,1 @@\n-      glyph_data.length  = (FT_Int)type1->charstrings_len[glyph_index];\n+      glyph_data.length  = type1->charstrings_len[glyph_index];\n@@ -751,1 +751,1 @@\n-      FT_ULong  charstring_len  = (FT_ULong)glyph_data.length;\n+      FT_ULong  charstring_len  = glyph_data.length;\n@@ -781,1 +781,1 @@\n-    data.length  = (FT_Int)( buf->end - buf->start );\n+    data.length  = (FT_UInt)( buf->end - buf->start );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psft.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -415,0 +415,6 @@\n+      \/* final amount to move edge or edge pair *\/\n+      CF2_Fixed  move = 0;\n+\n+      CF2_Fixed  dsCoord_i;\n+      CF2_Fixed  dsCoord_j;\n+\n@@ -425,0 +431,3 @@\n+      dsCoord_i = hintmap->edge[i].dsCoord;\n+      dsCoord_j = hintmap->edge[j].dsCoord;\n+\n@@ -428,2 +437,2 @@\n-        CF2_Fixed  fracDown = cf2_fixedFraction( hintmap->edge[i].dsCoord );\n-        CF2_Fixed  fracUp   = cf2_fixedFraction( hintmap->edge[j].dsCoord );\n+        CF2_Fixed  fracDown = cf2_fixedFraction( dsCoord_i );\n+        CF2_Fixed  fracUp   = cf2_fixedFraction( dsCoord_j );\n@@ -446,3 +455,0 @@\n-        \/* final amount to move edge or edge pair *\/\n-        CF2_Fixed  move;\n-\n@@ -470,1 +476,1 @@\n-        if ( j >= hintmap->count - 1                ||\n+        if ( j >= hintmap->count - 1                         ||\n@@ -472,2 +478,1 @@\n-               ADD_INT32( hintmap->edge[j].dsCoord,\n-                          moveUp + upMinCounter )   )\n+               ADD_INT32( dsCoord_j, moveUp + upMinCounter ) )\n@@ -476,1 +481,1 @@\n-          if ( i == 0                                   ||\n+          if ( i == 0                                              ||\n@@ -478,2 +483,1 @@\n-                 ADD_INT32( hintmap->edge[i].dsCoord,\n-                            moveDown - downMinCounter ) )\n+                 ADD_INT32( dsCoord_i, moveDown - downMinCounter ) )\n@@ -490,1 +494,1 @@\n-          if ( i == 0                                   ||\n+          if ( i == 0                                              ||\n@@ -492,2 +496,1 @@\n-                 ADD_INT32( hintmap->edge[i].dsCoord,\n-                            moveDown - downMinCounter ) )\n+                 ADD_INT32( dsCoord_i, moveDown - downMinCounter ) )\n@@ -527,2 +530,1 @@\n-        hintmap->edge[i].dsCoord = ADD_INT32( hintmap->edge[i].dsCoord,\n-                                              move );\n+        hintmap->edge[i].dsCoord = ADD_INT32( dsCoord_i, move );\n@@ -530,2 +532,1 @@\n-          hintmap->edge[j].dsCoord = ADD_INT32( hintmap->edge[j].dsCoord,\n-                                                move );\n+          hintmap->edge[j].dsCoord = ADD_INT32( dsCoord_j, move );\n@@ -534,1 +535,3 @@\n-      \/* assert there are no overlaps in device space *\/\n+      \/* assert there are no overlaps in device space;     *\/\n+      \/* ignore tests if there was overflow (that is, if   *\/\n+      \/* operands have the same sign but the sum does not) *\/\n@@ -536,0 +539,2 @@\n+                 ( ( dsCoord_i ^ move ) >= 0                    &&\n+                   ( dsCoord_i ^ hintmap->edge[i].dsCoord ) < 0 )         ||\n@@ -538,0 +543,2 @@\n+                 ( ( dsCoord_j ^ move ) >= 0                    &&\n+                   ( dsCoord_j ^ hintmap->edge[j].dsCoord ) < 0 )     ||\n@@ -1025,4 +1032,11 @@\n-    FT_TRACE6(( \"%s\\n\", initialMap ? \"flags: [p]air [g]host [t]op\"\n-                                     \" [b]ottom [L]ocked [S]ynthetic\\n\"\n-                                     \"Initial hintmap\"\n-                                   : \"Hints:\" ));\n+#ifdef FT_DEBUG_LEVEL_TRACE\n+    if ( initialMap )\n+    {\n+      FT_TRACE6(( \"flags: [p]air [g]host [t]op\"\n+                  \" [b]ottom [L]ocked [S]ynthetic\\n\" ));\n+      FT_TRACE6(( \"Initial hintmap\" ));\n+    }\n+    else\n+      FT_TRACE6(( \"Hints:\" ));\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/pshints.c","additions":37,"deletions":23,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-                          CF2_Buffer            buf,\n+                          const CF2_Buffer      buf,\n@@ -1343,3 +1343,3 @@\n-                        FT_ERROR((\n-                          \"cf2_interpT2CharString: (Type 1 seac)\"\n-                          \" glyph names table not available in this font\\n\" ));\n+                        FT_ERROR(( \"cf2_interpT2CharString:\\n\" ));\n+                        FT_ERROR(( \"  (Type 1 seac) glyph names table\"\n+                                   \" not available in this font\\n\" ));\n@@ -1371,3 +1371,3 @@\n-                      FT_ERROR((\n-                        \"cf2_interpT2CharString: (Type 1 seac)\"\n-                        \" invalid seac character code arguments\\n\" ));\n+                      FT_ERROR(( \"cf2_interpT2CharString:\\n\" ));\n+                      FT_ERROR(( \"  (Type 1 seac) invalid\"\n+                                 \" seac character code arguments\\n\" ));\n@@ -1673,1 +1673,7 @@\n-                    FT_ASSERT( (CF2_UInt)arg_cnt <= count );\n+                    if ( (CF2_UInt)arg_cnt > count )\n+                    {\n+                      FT_ERROR(( \"cf2_interpT2CharString (Type 1 mode):\"\n+                                 \" stack underflow\\n\" ));\n+                      lastError = FT_THROW( Invalid_Glyph_Format );\n+                      goto exit;\n+                    }\n@@ -1896,2 +1902,3 @@\n-                        FT_Int    idx;\n-                        PS_Blend  blend = decoder->blend;\n+                        FT_UInt   idx;\n+                        PS_Blend  blend         = decoder->blend;\n+                        FT_UInt   len_buildchar = decoder->len_buildchar;\n@@ -1903,1 +1910,1 @@\n-                        idx = cf2_stack_popInt( opStack );\n+                        idx = (FT_UInt)cf2_stack_popInt( opStack );\n@@ -1905,3 +1912,2 @@\n-                        if ( idx < 0                             ||\n-                             (FT_UInt)idx + blend->num_designs >\n-                               decoder->len_buildchar            )\n+                        if ( len_buildchar < blend->num_designs       ||\n+                             len_buildchar - blend->num_designs < idx )\n@@ -1910,4 +1916,5 @@\n-                        ft_memcpy( &decoder->buildchar[idx],\n-                                   blend->weight_vector,\n-                                   blend->num_designs *\n-                                   sizeof ( blend->weight_vector[0] ) );\n+                        if ( decoder->buildchar && blend->weight_vector )\n+                          ft_memcpy( &decoder->buildchar[idx],\n+                                     blend->weight_vector,\n+                                     blend->num_designs *\n+                                       sizeof ( blend->weight_vector[0] ) );\n@@ -2007,1 +2014,1 @@\n-                        CF2_Int   idx;\n+                        CF2_UInt  idx;\n@@ -2014,1 +2021,1 @@\n-                        idx = cf2_stack_popInt( opStack );\n+                        idx = (CF2_UInt)cf2_stack_popInt( opStack );\n@@ -2016,2 +2023,1 @@\n-                        if ( idx < 0                                ||\n-                             (FT_UInt)idx >= decoder->len_buildchar )\n+                        if ( idx >= decoder->len_buildchar )\n@@ -2030,1 +2036,1 @@\n-                        CF2_Int   idx;\n+                        CF2_UInt  idx;\n@@ -2037,1 +2043,1 @@\n-                        idx = cf2_stack_popInt( opStack );\n+                        idx = (CF2_UInt)cf2_stack_popInt( opStack );\n@@ -2039,2 +2045,1 @@\n-                        if ( idx < 0                                ||\n-                             (FT_UInt)idx >= decoder->len_buildchar )\n+                        if ( idx >= decoder->len_buildchar )\n@@ -2182,1 +2187,1 @@\n-                    CF2_Int       idx;\n+                    CF2_UInt      idx;\n@@ -2187,1 +2192,1 @@\n-                    idx = cf2_stack_popInt( opStack );\n+                    idx = (CF2_UInt)cf2_stack_popInt( opStack );\n@@ -2190,1 +2195,1 @@\n-                    if ( idx >= 0 && idx < CF2_STORAGE_SIZE )\n+                    if ( idx < CF2_STORAGE_SIZE )\n@@ -2197,1 +2202,1 @@\n-                    CF2_Int  idx;\n+                    CF2_UInt  idx;\n@@ -2202,1 +2207,1 @@\n-                    idx = cf2_stack_popInt( opStack );\n+                    idx = (CF2_UInt)cf2_stack_popInt( opStack );\n@@ -2204,1 +2209,1 @@\n-                    if ( idx >= 0 && idx < CF2_STORAGE_SIZE )\n+                    if ( idx < CF2_STORAGE_SIZE )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psintrp.c","additions":37,"deletions":32,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-                          CF2_Buffer            charstring,\n+                          const CF2_Buffer      buf,\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psintrp.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -102,17 +102,0 @@\n-  static void\n-  shift_elements( PS_Table  table,\n-                  FT_Byte*  old_base )\n-  {\n-    FT_PtrDist  delta  = table->block - old_base;\n-    FT_Byte**   offset = table->elements;\n-    FT_Byte**   limit  = offset + table->max_elems;\n-\n-\n-    for ( ; offset < limit; offset++ )\n-    {\n-      if ( offset[0] )\n-        offset[0] += delta;\n-    }\n-  }\n-\n-\n@@ -120,2 +103,2 @@\n-  reallocate_t1_table( PS_Table   table,\n-                       FT_Offset  new_size )\n+  ps_table_realloc( PS_Table   table,\n+                    FT_Offset  new_size )\n@@ -128,4 +111,2 @@\n-    \/* allocate new base block *\/\n-    if ( FT_ALLOC( table->block, new_size ) )\n-    {\n-      table->block = old_base;\n+    \/* (re)allocate the base block *\/\n+    if ( FT_REALLOC( table->block, table->capacity, new_size ) )\n@@ -133,1 +114,0 @@\n-    }\n@@ -135,2 +115,2 @@\n-    \/* copy elements and shift offsets *\/\n-    if ( old_base )\n+    \/* rebase offsets if necessary *\/\n+    if ( old_base && table->block != old_base )\n@@ -138,3 +118,9 @@\n-      FT_MEM_COPY( table->block, old_base, table->capacity );\n-      shift_elements( table, old_base );\n-      FT_FREE( old_base );\n+      FT_Byte**   offset = table->elements;\n+      FT_Byte**   limit  = offset + table->max_elems;\n+\n+\n+      for ( ; offset < limit; offset++ )\n+      {\n+        if ( *offset )\n+          *offset = table->block + ( *offset - old_base );\n+      }\n@@ -207,1 +193,1 @@\n-      error = reallocate_t1_table( table, new_size );\n+      error = ps_table_realloc( table, new_size );\n@@ -237,4 +223,0 @@\n-   *\n-   * @Note:\n-   *   This function does NOT release the heap's memory block.  It is up\n-   *   to the caller to clean it, or reference it in its own structures.\n@@ -245,18 +227,2 @@\n-    FT_Memory  memory = table->memory;\n-    FT_Error   error;\n-    FT_Byte*   old_base = table->block;\n-\n-\n-    \/* should never fail, because rec.cursor <= rec.size *\/\n-    if ( !old_base )\n-      return;\n-\n-    if ( FT_ALLOC( table->block, table->cursor ) )\n-      return;\n-    FT_MEM_COPY( table->block, old_base, table->cursor );\n-    shift_elements( table, old_base );\n-\n-    table->capacity = table->cursor;\n-    FT_FREE( old_base );\n-\n-    FT_UNUSED( error );\n+    \/* no problem if shrinking fails *\/\n+    ps_table_realloc( table, table->cursor );\n@@ -598,3 +564,1 @@\n-                 \" current token is `%c' which is self-delimiting\\n\"\n-                 \"                        \"\n-                 \" but invalid at this point\\n\",\n+                 \" current token is `%c' which is self-delimiting\\n\",\n@@ -602,0 +566,2 @@\n+      FT_ERROR(( \"                        \"\n+                 \" but invalid at this point\\n\" ));\n@@ -982,1 +948,1 @@\n-    if ( cur >= limit || FT_ALLOC( result, len + 1 ) )\n+    if ( cur >= limit || FT_QALLOC( result, len + 1 ) )\n@@ -1101,1 +1067,0 @@\n-      FT_String*  string = NULL;\n@@ -1151,2 +1116,3 @@\n-          FT_Memory  memory = parser->memory;\n-          FT_UInt    len    = (FT_UInt)( limit - cur );\n+          FT_Memory   memory = parser->memory;\n+          FT_UInt     len    = (FT_UInt)( limit - cur );\n+          FT_String*  string = NULL;\n@@ -1178,2 +1144,2 @@\n-                       \" expected a name or string\\n\"\n-                       \"                     \"\n+                       \" expected a name or string\\n\" ));\n+            FT_ERROR(( \"                     \"\n@@ -1193,1 +1159,0 @@\n-            *(FT_String**)q = NULL;\n@@ -1196,1 +1161,1 @@\n-          if ( FT_ALLOC( string, len + 1 ) )\n+          if ( FT_QALLOC( string, len + 1 ) )\n@@ -1251,1 +1216,1 @@\n-          if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )\n+          if ( FT_QNEW_ARRAY( temp, max_objects * 4 ) )\n@@ -1261,3 +1226,1 @@\n-                         \" expected %d integer%s in the %s subarray\\n\"\n-                         \"                     \"\n-                         \" of \/FontBBox in the \/Blend dictionary\\n\",\n+                         \" expected %d integer%s in the %s subarray\\n\",\n@@ -1269,0 +1232,2 @@\n+              FT_ERROR(( \"                     \"\n+                         \" of \/FontBBox in the \/Blend dictionary\\n\" ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psobjs.c","additions":33,"deletions":68,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-    FT_Error  error = FT_Err_Ok;     \/* for FT_NEW *\/\n-\n+    FT_Error   error;        \/* for FT_QNEW *\/\n@@ -62,1 +61,1 @@\n-    if ( FT_NEW( stack ) )\n+    if ( FT_QNEW( stack ) )\n@@ -65,1 +64,0 @@\n-    \/* initialize the structure; FT_NEW zeroes it *\/\n@@ -70,1 +68,1 @@\n-    if ( FT_NEW_ARRAY( stack->buffer, stackSize ) )\n+    if ( FT_QNEW_ARRAY( stack->buffer, stackSize ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/psstack.c","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1cmap.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1cmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2022 by\n@@ -30,0 +30,1 @@\n+\n@@ -31,1 +32,3 @@\n-#define Fix2Int( f )  ( (FT_Int)(FT_Short)( (f) >> 16 ) )\n+#define Fix2Int( f )   ( (FT_Int) (FT_Short)( (f) >> 16 ) )\n+#define Fix2UInt( f )  ( (FT_UInt)(FT_Short)( (f) >> 16 ) )\n+\n@@ -520,1 +523,1 @@\n-        FT_TRACE5(( \" (%d)\", decoder->top - decoder->stack ));\n+        FT_TRACE5(( \" (%ld)\", decoder->top - decoder->stack ));\n@@ -1028,1 +1031,1 @@\n-            FT_Int    idx;\n+            FT_UInt   idx;\n@@ -1035,1 +1038,1 @@\n-            idx = Fix2Int( top[1] );\n+            idx = Fix2UInt( top[1] );\n@@ -1037,1 +1040,1 @@\n-            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )\n+            if ( idx >= decoder->len_buildchar )\n@@ -1049,1 +1052,1 @@\n-            FT_Int    idx;\n+            FT_UInt   idx;\n@@ -1056,1 +1059,1 @@\n-            idx = Fix2Int( top[0] );\n+            idx = Fix2UInt( top[0] );\n@@ -1058,1 +1061,1 @@\n-            if ( idx < 0 || (FT_UInt) idx >= decoder->len_buildchar )\n+            if ( idx >= decoder->len_buildchar )\n@@ -1165,1 +1168,1 @@\n-                        \" (seen %d, expected %d)\\n\",\n+                        \" (seen %ld, expected %d)\\n\",\n@@ -1167,1 +1170,1 @@\n-            break;\n+          break;\n@@ -1212,1 +1215,1 @@\n-              FT_TRACE4(( \"%d \", decoder->buildchar[i] ));\n+              FT_TRACE4(( \"%ld \", decoder->buildchar[i] ));\n@@ -1653,1 +1656,2 @@\n-    FT_TRACE4(( \"..end..\\n\\n\" ));\n+    FT_TRACE4(( \"..end..\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n@@ -2073,1 +2077,2 @@\n-    FT_TRACE4(( \"..end..\\n\\n\" ));\n+    FT_TRACE4(( \"..end..\\n\" ));\n+    FT_TRACE4(( \"\\n\" ));\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1decode.c","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psaux\/t1decode.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n@@ -185,3 +185,3 @@\n-    if ( FT_NEW_ARRAY( table->sort,  2 * count     ) ||\n-         FT_NEW_ARRAY( table->hints,     count     ) ||\n-         FT_NEW_ARRAY( table->zones, 2 * count + 1 ) )\n+    if ( FT_QNEW_ARRAY( table->sort,  2 * count     ) ||\n+         FT_QNEW_ARRAY( table->hints,     count     ) ||\n+         FT_QNEW_ARRAY( table->zones, 2 * count + 1 ) )\n@@ -191,1 +191,1 @@\n-    table->sort_global = table->sort + count;\n+    table->sort_global = FT_OFFSET( table->sort, count );\n@@ -308,1 +308,1 @@\n-      FT_Int     i1, i2;\n+      FT_UInt    i1, i2;\n@@ -315,1 +315,1 @@\n-      for ( i1 = 1; i1 < (FT_Int)count; i1++ )\n+      for ( i1 = 1; i1 < count; i1++ )\n@@ -318,1 +318,2 @@\n-        for ( i2 = i1 - 1; i2 >= 0; i2-- )\n+        \/* this loop stops when i2 wraps around after reaching 0 *\/\n+        for ( i2 = i1 - 1; i2 < i1; i2-- )\n@@ -872,1 +873,1 @@\n-#endif \/* DEBUG_HINTER*\/\n+#endif \/* DEBUG_HINTER *\/\n@@ -1052,1 +1053,1 @@\n-  static int\n+  static PSH_Dir\n@@ -1056,2 +1057,2 @@\n-    FT_Pos  ax, ay;\n-    int     result = PSH_DIR_NONE;\n+    FT_Pos   ax, ay;\n+    PSH_Dir  result = PSH_DIR_NONE;\n@@ -1169,2 +1170,2 @@\n-    if ( FT_NEW_ARRAY( glyph->points,   outline->n_points   ) ||\n-         FT_NEW_ARRAY( glyph->contours, outline->n_contours ) )\n+    if ( FT_QNEW_ARRAY( glyph->points,   outline->n_points   ) ||\n+         FT_QNEW_ARRAY( glyph->contours, outline->n_contours ) )\n@@ -1230,0 +1231,1 @@\n+        point->flags = 0;\n@@ -1231,1 +1233,1 @@\n-          point->flags = PSH_POINT_OFF;\n+          psh_point_set_off( point );\n@@ -1236,1 +1238,1 @@\n-        point->dir_in = (FT_Char)psh_compute_dir( dxi, dyi );\n+        point->dir_in = psh_compute_dir( dxi, dyi );\n@@ -1241,1 +1243,1 @@\n-        point->dir_out = (FT_Char)psh_compute_dir( dxo, dyo );\n+        point->dir_out = psh_compute_dir( dxo, dyo );\n@@ -1244,2 +1246,2 @@\n-        if ( point->flags & PSH_POINT_OFF )\n-          point->flags |= PSH_POINT_SMOOTH;\n+        if ( psh_point_is_off( point ) )\n+          psh_point_set_smooth( point );\n@@ -1251,1 +1253,1 @@\n-            point->flags |= PSH_POINT_SMOOTH;\n+            psh_point_set_smooth( point );\n@@ -1406,4 +1408,1 @@\n-  \/* major_dir is the direction for points on the bottom\/left of the stem; *\/\n-  \/* Points on the top\/right of the stem will have a direction of          *\/\n-  \/* -major_dir.                                                           *\/\n-\n+  \/* the min and max are based on contour orientation and fill rule *\/\n@@ -1415,1 +1414,1 @@\n-                                     FT_Int          major_dir )\n+                                     PSH_Dir         major_dir )\n@@ -1423,2 +1422,2 @@\n-      FT_Int  point_dir = 0;\n-      FT_Pos  org_u     = point->org_u;\n+      PSH_Dir  point_dir;\n+      FT_Pos   org_u = point->org_u;\n@@ -1430,5 +1429,2 @@\n-      if ( PSH_DIR_COMPARE( point->dir_in, major_dir ) )\n-        point_dir = point->dir_in;\n-\n-      else if ( PSH_DIR_COMPARE( point->dir_out, major_dir ) )\n-        point_dir = point->dir_out;\n+      point_dir =\n+        (PSH_Dir)( ( point->dir_in | point->dir_out ) & major_dir );\n@@ -1436,1 +1432,1 @@\n-      if ( point_dir )\n+      if ( point_dir & ( PSH_DIR_DOWN | PSH_DIR_RIGHT ) )\n@@ -1438,3 +1434,1 @@\n-        if ( point_dir == major_dir )\n-        {\n-          FT_UInt  nn;\n+        FT_UInt  nn;\n@@ -1443,4 +1437,4 @@\n-          for ( nn = 0; nn < num_hints; nn++ )\n-          {\n-            PSH_Hint  hint = sort[nn];\n-            FT_Pos    d    = org_u - hint->org_pos;\n+        for ( nn = 0; nn < num_hints; nn++ )\n+        {\n+          PSH_Hint  hint = sort[nn];\n+          FT_Pos    d    = org_u - hint->org_pos;\n@@ -1449,7 +1443,6 @@\n-            if ( d < threshold && -d < threshold )\n-            {\n-              psh_point_set_strong( point );\n-              point->flags2 |= PSH_POINT_EDGE_MIN;\n-              point->hint    = hint;\n-              break;\n-            }\n+          if ( d < threshold && -d < threshold )\n+          {\n+            psh_point_set_strong( point );\n+            point->flags2 |= PSH_POINT_EDGE_MIN;\n+            point->hint    = hint;\n+            break;\n@@ -1458,3 +1451,4 @@\n-        else if ( point_dir == -major_dir )\n-        {\n-          FT_UInt  nn;\n+      }\n+      else if ( point_dir & ( PSH_DIR_UP | PSH_DIR_LEFT ) )\n+      {\n+        FT_UInt  nn;\n@@ -1463,4 +1457,4 @@\n-          for ( nn = 0; nn < num_hints; nn++ )\n-          {\n-            PSH_Hint  hint = sort[nn];\n-            FT_Pos    d    = org_u - hint->org_pos - hint->org_len;\n+        for ( nn = 0; nn < num_hints; nn++ )\n+        {\n+          PSH_Hint  hint = sort[nn];\n+          FT_Pos    d    = org_u - hint->org_pos - hint->org_len;\n@@ -1469,7 +1463,6 @@\n-            if ( d < threshold && -d < threshold )\n-            {\n-              psh_point_set_strong( point );\n-              point->flags2 |= PSH_POINT_EDGE_MAX;\n-              point->hint    = hint;\n-              break;\n-            }\n+          if ( d < threshold && -d < threshold )\n+          {\n+            psh_point_set_strong( point );\n+            point->flags2 |= PSH_POINT_EDGE_MAX;\n+            point->hint    = hint;\n+            break;\n@@ -1558,2 +1551,3 @@\n-  \/* the maximum shift value in font units *\/\n-#define PSH_STRONG_THRESHOLD_MAXIMUM  30\n+  \/* the maximum shift value in font units tuned to distinguish *\/\n+  \/* between stems and serifs in URW+ font collection           *\/\n+#define PSH_STRONG_THRESHOLD_MAXIMUM  12\n@@ -1574,1 +1568,1 @@\n-    FT_Int          major_dir = ( dimension == 0 ) ? PSH_DIR_VERTICAL\n+    PSH_Dir         major_dir = ( dimension == 0 ) ? PSH_DIR_VERTICAL\n@@ -1659,2 +1653,2 @@\n-      if ( !PSH_DIR_COMPARE( point->dir_in,  PSH_DIR_HORIZONTAL ) &&\n-           !PSH_DIR_COMPARE( point->dir_out, PSH_DIR_HORIZONTAL ) )\n+      if ( !( point->dir_in  & PSH_DIR_HORIZONTAL ) &&\n+           !( point->dir_out & PSH_DIR_HORIZONTAL ) )\n@@ -1808,1 +1802,1 @@\n-      if ( FT_NEW_ARRAY( strongs, num_strongs ) )\n+      if ( FT_QNEW_ARRAY( strongs, num_strongs ) )\n@@ -2121,2 +2115,2 @@\n-      FT_Fixed  scaled;\n-      FT_Fixed  fitted;\n+      FT_Fixed  scaled = 0;\n+      FT_Fixed  fitted = 0;\n@@ -2127,2 +2121,5 @@\n-      scaled = FT_MulFix( globals->blues.normal_top.zones->org_ref, y_scale );\n-      fitted = FT_PIX_ROUND( scaled );\n+      if ( globals->blues.normal_top.count )\n+      {\n+        scaled = FT_MulFix( globals->blues.normal_top.zones->org_ref, y_scale );\n+        fitted = FT_PIX_ROUND( scaled );\n+      }\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshalgo.c","additions":68,"deletions":71,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n@@ -96,1 +96,1 @@\n-  enum\n+  typedef enum PSH_Dir_\n@@ -98,6 +98,7 @@\n-    PSH_DIR_NONE  =  4,\n-    PSH_DIR_UP    = -1,\n-    PSH_DIR_DOWN  =  1,\n-    PSH_DIR_LEFT  = -2,\n-    PSH_DIR_RIGHT =  2\n-  };\n+    PSH_DIR_NONE       = 0,\n+    PSH_DIR_UP         = 1,\n+    PSH_DIR_DOWN       = 2,\n+    PSH_DIR_VERTICAL   = 1 | 2,\n+    PSH_DIR_LEFT       = 4,\n+    PSH_DIR_RIGHT      = 8,\n+    PSH_DIR_HORIZONTAL = 4 | 8\n@@ -105,6 +106,1 @@\n-#define PSH_DIR_HORIZONTAL  2\n-#define PSH_DIR_VERTICAL    1\n-\n-#define PSH_DIR_COMPARE( d1, d2 )   ( (d1) == (d2) || (d1) == -(d2) )\n-#define PSH_DIR_IS_HORIZONTAL( d )  PSH_DIR_COMPARE( d, PSH_DIR_HORIZONTAL )\n-#define PSH_DIR_IS_VERTICAL( d )    PSH_DIR_COMPARE( d, PSH_DIR_VERTICAL )\n+  } PSH_Dir;\n@@ -163,2 +159,2 @@\n-    FT_Char      dir_in;\n-    FT_Char      dir_out;\n+    PSH_Dir      dir_in;\n+    PSH_Dir      dir_out;\n@@ -202,4 +198,0 @@\n-    FT_Bool            vertical;\n-    FT_Int             major_dir;\n-    FT_Int             minor_dir;\n-\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshalgo.h","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n@@ -653,1 +653,1 @@\n-    if ( !FT_NEW( globals ) )\n+    if ( !FT_QNEW( globals ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshglob.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshglob.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshmod.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshmod.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2003-2020 by\n+ * Copyright (C) 2003-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshnterr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n@@ -66,1 +66,1 @@\n-    FT_Error  error   = FT_Err_Ok;\n+    FT_Error  error;\n@@ -69,7 +69,5 @@\n-    if ( new_max > old_max )\n-    {\n-      \/* try to grow the table *\/\n-      new_max = FT_PAD_CEIL( new_max, 8 );\n-      if ( !FT_RENEW_ARRAY( table->hints, old_max, new_max ) )\n-        table->max_hints = new_max;\n-    }\n+    \/* try to grow the table *\/\n+    new_max = FT_PAD_CEIL( new_max, 8 );\n+    if ( !FT_QRENEW_ARRAY( table->hints, old_max, new_max ) )\n+      table->max_hints = new_max;\n+\n@@ -93,1 +91,1 @@\n-    if ( count >= table->max_hints )\n+    if ( count > table->max_hints )\n@@ -100,4 +98,1 @@\n-    hint        = table->hints + count - 1;\n-    hint->pos   = 0;\n-    hint->len   = 0;\n-    hint->flags = 0;\n+    hint = table->hints + count - 1;  \/* initialized upstream *\/\n@@ -139,2 +134,2 @@\n-    FT_UInt   old_max = ( mask->max_bits + 7 ) >> 3;\n-    FT_UInt   new_max = ( count          + 7 ) >> 3;\n+    FT_UInt   old_max = mask->max_bits >> 3;\n+    FT_UInt   new_max = ( count + 7 ) >> 3;\n@@ -147,0 +142,1 @@\n+      \/* added bytes are zeroed here *\/\n@@ -157,1 +153,1 @@\n-                    FT_Int   idx )\n+                    FT_UInt  idx )\n@@ -159,1 +155,1 @@\n-    if ( (FT_UInt)idx >= mask->num_bits )\n+    if ( idx >= mask->num_bits )\n@@ -166,16 +162,0 @@\n-  \/* clear a given bit *\/\n-  static void\n-  ps_mask_clear_bit( PS_Mask  mask,\n-                     FT_UInt  idx )\n-  {\n-    FT_Byte*  p;\n-\n-\n-    if ( idx >= mask->num_bits )\n-      return;\n-\n-    p    = mask->bytes + ( idx >> 3 );\n-    p[0] = (FT_Byte)( p[0] & ~( 0x80 >> ( idx & 7 ) ) );\n-  }\n-\n-\n@@ -272,0 +252,4 @@\n+    \/* reused mask must be cleared *\/\n+    if ( mask->max_bits )\n+      FT_MEM_ZERO( mask->bytes, mask->max_bits >> 3 );\n+\n@@ -429,1 +413,1 @@\n-      FT_Int   delta;\n+      FT_UInt  delta;\n@@ -440,1 +424,1 @@\n-        \/* first bitset, and clear the highest bits                  *\/\n+        \/* first bitset                                              *\/\n@@ -447,2 +431,1 @@\n-          for ( pos = count1; pos < count2; pos++ )\n-            ps_mask_clear_bit( mask1, pos );\n+          mask1->num_bits = count2;\n@@ -470,1 +453,1 @@\n-      delta = (FT_Int)( table->num_masks - 1 - index2 );\n+      delta = table->num_masks - 1 - index2;\n@@ -479,1 +462,1 @@\n-                    (FT_UInt)delta * sizeof ( PS_MaskRec ) );\n+                    delta * sizeof ( PS_MaskRec ) );\n@@ -502,1 +485,1 @@\n-    FT_Int    index1, index2;\n+    FT_UInt   index1, index2;\n@@ -506,2 +489,2 @@\n-    \/* both loops go down to 0, thus FT_Int for index1 and index2 *\/\n-    for ( index1 = (FT_Int)table->num_masks - 1; index1 > 0; index1-- )\n+    \/* the loops stop when unsigned indices wrap around after 0 *\/\n+    for ( index1 = table->num_masks - 1; index1 < table->num_masks; index1-- )\n@@ -509,1 +492,1 @@\n-      for ( index2 = index1 - 1; index2 >= 0; index2-- )\n+      for ( index2 = index1 - 1; index2 < index1; index2-- )\n@@ -511,3 +494,1 @@\n-        if ( ps_mask_table_test_intersect( table,\n-                                           (FT_UInt)index1,\n-                                           (FT_UInt)index2 ) )\n+        if ( ps_mask_table_test_intersect( table, index1, index2 ) )\n@@ -515,4 +496,1 @@\n-          error = ps_mask_table_merge( table,\n-                                       (FT_UInt)index2,\n-                                       (FT_UInt)index1,\n-                                       memory );\n+          error = ps_mask_table_merge( table, index2, index1, memory );\n@@ -655,1 +633,1 @@\n-                           FT_Int       *aindex )\n+                           FT_UInt      *aindex )\n@@ -673,3 +651,0 @@\n-    if ( aindex )\n-      *aindex = -1;\n-\n@@ -712,1 +687,1 @@\n-        *aindex = (FT_Int)idx;\n+        *aindex = idx;\n@@ -723,3 +698,3 @@\n-                            FT_Int        hint1,\n-                            FT_Int        hint2,\n-                            FT_Int        hint3,\n+                            FT_UInt       hint1,\n+                            FT_UInt       hint2,\n+                            FT_UInt       hint3,\n@@ -752,6 +727,3 @@\n-    if ( hint1 >= 0 )\n-    {\n-      error = ps_mask_set_bit( counter, (FT_UInt)hint1, memory );\n-      if ( error )\n-        goto Exit;\n-    }\n+    error = ps_mask_set_bit( counter, hint1, memory );\n+    if ( error )\n+      goto Exit;\n@@ -759,6 +731,3 @@\n-    if ( hint2 >= 0 )\n-    {\n-      error = ps_mask_set_bit( counter, (FT_UInt)hint2, memory );\n-      if ( error )\n-        goto Exit;\n-    }\n+    error = ps_mask_set_bit( counter, hint2, memory );\n+    if ( error )\n+      goto Exit;\n@@ -766,6 +735,3 @@\n-    if ( hint3 >= 0 )\n-    {\n-      error = ps_mask_set_bit( counter, (FT_UInt)hint3, memory );\n-      if ( error )\n-        goto Exit;\n-    }\n+    error = ps_mask_set_bit( counter, hint3, memory );\n+    if ( error )\n+      goto Exit;\n@@ -900,1 +866,1 @@\n-      FT_Int        idx[3];\n+      FT_UInt       idx[3];\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshrec.c","additions":44,"deletions":78,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/pshinter\/pshrec.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -158,2 +158,3 @@\n-      const char*  p   = glyph_name;\n-      const char*  dot = NULL;\n+      FT_UInt32    value = 0;\n+      const char*  p     = glyph_name;\n+\n@@ -161,0 +162,2 @@\n+      for ( ; *p && *p != '.'; p++ )\n+        ;\n@@ -162,1 +165,3 @@\n-      for ( ; *p; p++ )\n+      \/* now look up the glyph in the Adobe Glyph List;      *\/\n+      \/* `.notdef', `.null' and the empty name are short cut *\/\n+      if ( p > glyph_name )\n@@ -164,5 +169,4 @@\n-        if ( *p == '.' && p > glyph_name )\n-        {\n-          dot = p;\n-          break;\n-        }\n+        value = (FT_UInt32)ft_get_adobe_glyph_index( glyph_name, p );\n+\n+        if ( *p == '.' )\n+          value |= (FT_UInt32)VARIANT_BIT;\n@@ -171,6 +175,1 @@\n-      \/* now look up the glyph in the Adobe Glyph List *\/\n-      if ( !dot )\n-        return (FT_UInt32)ft_get_adobe_glyph_index( glyph_name, p );\n-      else\n-        return (FT_UInt32)( ft_get_adobe_glyph_index( glyph_name, dot ) |\n-                            VARIANT_BIT );\n+      return value;\n@@ -182,1 +181,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n@@ -329,1 +328,0 @@\n-    table->maps     = NULL;\n@@ -331,1 +329,1 @@\n-    if ( !FT_NEW_ARRAY( table->maps, num_glyphs + EXTRA_GLYPH_LIST_SIZE ) )\n+    if ( !FT_QNEW_ARRAY( table->maps, num_glyphs + EXTRA_GLYPH_LIST_SIZE ) )\n@@ -346,1 +344,1 @@\n-        if ( gname )\n+        if ( gname && *gname )\n@@ -394,3 +392,3 @@\n-          (void)FT_RENEW_ARRAY( table->maps,\n-                                num_glyphs + EXTRA_GLYPH_LIST_SIZE,\n-                                count );\n+          FT_MEM_QRENEW_ARRAY( table->maps,\n+                               num_glyphs + EXTRA_GLYPH_LIST_SIZE,\n+                               count );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/psmodule.c","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/psmodule.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/psnamerr.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2020 by\n+ * Copyright (C) 2005-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/psnames\/pstables.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 2005-2020 by\n+ * Copyright (C) 2005-2022 by\n@@ -50,5 +50,2 @@\n-#define FT_MAKE_TAG( _x1, _x2, _x3, _x4 ) \\\n-          ( ( (FT_ULong)_x1 << 24 ) |     \\\n-            ( (FT_ULong)_x2 << 16 ) |     \\\n-            ( (FT_ULong)_x3 <<  8 ) |     \\\n-              (FT_ULong)_x4         )\n+\n+#define FT_STATIC_BYTE_CAST( type, var )  (type)(FT_Byte)(var)\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftmisc.h","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -152,3 +152,0 @@\n-  \/* define DEBUG_RASTER if you want to compile a debugging version *\/\n-\/* #define DEBUG_RASTER *\/\n-\n@@ -203,6 +200,7 @@\n-#define Raster_Err_None          0\n-#define Raster_Err_Not_Ini      -1\n-#define Raster_Err_Overflow     -2\n-#define Raster_Err_Neg_Height   -3\n-#define Raster_Err_Invalid      -4\n-#define Raster_Err_Unsupported  -5\n+#define Raster_Err_Ok                       0\n+#define Raster_Err_Invalid_Outline         -1\n+#define Raster_Err_Cannot_Render_Glyph     -2\n+#define Raster_Err_Invalid_Argument        -3\n+#define Raster_Err_Raster_Overflow         -4\n+#define Raster_Err_Raster_Uninitialized    -5\n+#define Raster_Err_Raster_Negative_Height  -6\n@@ -233,7 +231,0 @@\n-#define Raster_Err_None         FT_Err_Ok\n-#define Raster_Err_Not_Ini      Raster_Err_Raster_Uninitialized\n-#define Raster_Err_Overflow     Raster_Err_Raster_Overflow\n-#define Raster_Err_Neg_Height   Raster_Err_Raster_Negative_Height\n-#define Raster_Err_Invalid      Raster_Err_Invalid_Outline\n-#define Raster_Err_Unsupported  Raster_Err_Cannot_Render_Glyph\n-\n@@ -378,10 +369,0 @@\n-  \/* Simple record used to implement a stack of bands, required *\/\n-  \/* by the sub-banding mechanism                               *\/\n-  typedef struct  black_TBand_\n-  {\n-    Short  y_min;   \/* band's minimum *\/\n-    Short  y_max;   \/* band's maximum *\/\n-\n-  } black_TBand;\n-\n-\n@@ -429,2 +410,2 @@\n-  Function_Sweep_Init( RAS_ARGS Short*  min,\n-                                Short*  max );\n+  Function_Sweep_Init( RAS_ARGS Short  min,\n+                                Short  max );\n@@ -495,1 +476,1 @@\n-    TPoint*     arc;                \/* current Bezier arc pointer          *\/\n+    Byte        dropOutControl;     \/* current drop_out control method     *\/\n@@ -499,0 +480,1 @@\n+    PByte       bLine;              \/* target bitmap current line          *\/\n@@ -520,3 +502,0 @@\n-    Long        traceOfs;           \/* current offset in target bitmap     *\/\n-    Short       traceIncr;          \/* sweep's increment in target bitmap  *\/\n-\n@@ -530,12 +509,0 @@\n-    Byte        dropOutControl;     \/* current drop_out control method     *\/\n-\n-    Bool        second_pass;        \/* indicates whether a horizontal pass *\/\n-                                    \/* should be performed to control      *\/\n-                                    \/* drop-out accurately when calling    *\/\n-                                    \/* Render_Glyph.                       *\/\n-\n-    TPoint      arcs[3 * MaxBezier + 1]; \/* The Bezier stack               *\/\n-\n-    black_TBand  band_stack[16];    \/* band stack used for sub-banding     *\/\n-    Int          band_top;          \/* band stack top                      *\/\n-\n@@ -663,1 +630,1 @@\n-      ras.error = FT_THROW( Overflow );\n+      ras.error = FT_THROW( Raster_Overflow );\n@@ -692,1 +659,1 @@\n-      ras.error = FT_THROW( Invalid );\n+      ras.error = FT_THROW( Invalid_Outline );\n@@ -734,1 +701,1 @@\n-      ras.error = FT_THROW( Neg_Height );\n+      ras.error = FT_THROW( Raster_Negative_Height );\n@@ -770,1 +737,1 @@\n-      ras.error = FT_THROW( Overflow );\n+      ras.error = FT_THROW( Raster_Overflow );\n@@ -825,1 +792,1 @@\n-        ras.error = FT_THROW( Overflow );\n+        ras.error = FT_THROW( Raster_Overflow );\n@@ -1089,1 +1056,1 @@\n-      ras.error = FT_THROW( Overflow );\n+      ras.error = FT_THROW( Raster_Overflow );\n@@ -1212,0 +1179,1 @@\n+                      TPoint*    arc,\n@@ -1219,1 +1187,0 @@\n-    TPoint*  arc;\n@@ -1225,1 +1192,0 @@\n-    arc = ras.arc;\n@@ -1274,1 +1240,1 @@\n-      ras.error = FT_THROW( Overflow );\n+      ras.error = FT_THROW( Raster_Overflow );\n@@ -1317,1 +1283,0 @@\n-    ras.arc -= degree;\n@@ -1349,0 +1314,1 @@\n+                        TPoint*    arc,\n@@ -1353,1 +1319,0 @@\n-    TPoint*  arc = ras.arc;\n@@ -1365,1 +1330,1 @@\n-    result = Bezier_Up( RAS_VARS degree, splitter, -maxy, -miny );\n+    result = Bezier_Up( RAS_VARS degree, arc, splitter, -maxy, -miny );\n@@ -1506,0 +1471,2 @@\n+    TPoint   arcs[2 * MaxBezier + 1]; \/* The Bezier stack           *\/\n+    TPoint*  arc;                     \/* current Bezier arc pointer *\/\n@@ -1508,7 +1475,7 @@\n-    ras.arc      = ras.arcs;\n-    ras.arc[2].x = ras.lastX;\n-    ras.arc[2].y = ras.lastY;\n-    ras.arc[1].x = cx;\n-    ras.arc[1].y = cy;\n-    ras.arc[0].x = x;\n-    ras.arc[0].y = y;\n+    arc      = arcs;\n+    arc[2].x = ras.lastX;\n+    arc[2].y = ras.lastY;\n+    arc[1].x = cx;\n+    arc[1].y = cy;\n+    arc[0].x = x;\n+    arc[0].y = y;\n@@ -1518,4 +1485,4 @@\n-      y1 = ras.arc[2].y;\n-      y2 = ras.arc[1].y;\n-      y3 = ras.arc[0].y;\n-      x3 = ras.arc[0].x;\n+      y1 = arc[2].y;\n+      y2 = arc[1].y;\n+      y3 = arc[0].y;\n+      x3 = arc[0].x;\n@@ -1539,2 +1506,2 @@\n-        Split_Conic( ras.arc );\n-        ras.arc += 2;\n+        Split_Conic( arc );\n+        arc += 2;\n@@ -1545,1 +1512,1 @@\n-        ras.arc -= 2;\n+        arc -= 2;\n@@ -1572,1 +1539,2 @@\n-          if ( Bezier_Up( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )\n+          if ( Bezier_Up( RAS_VARS 2, arc, Split_Conic,\n+                                   ras.minY, ras.maxY ) )\n@@ -1576,1 +1544,2 @@\n-          if ( Bezier_Down( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )\n+          if ( Bezier_Down( RAS_VARS 2, arc, Split_Conic,\n+                                     ras.minY, ras.maxY ) )\n@@ -1578,0 +1547,1 @@\n+        arc -= 2;\n@@ -1580,1 +1550,1 @@\n-    } while ( ras.arc >= ras.arcs );\n+    } while ( arc >= arcs );\n@@ -1635,0 +1605,2 @@\n+    TPoint   arcs[3 * MaxBezier + 1]; \/* The Bezier stack           *\/\n+    TPoint*  arc;                     \/* current Bezier arc pointer *\/\n@@ -1637,9 +1609,9 @@\n-    ras.arc      = ras.arcs;\n-    ras.arc[3].x = ras.lastX;\n-    ras.arc[3].y = ras.lastY;\n-    ras.arc[2].x = cx1;\n-    ras.arc[2].y = cy1;\n-    ras.arc[1].x = cx2;\n-    ras.arc[1].y = cy2;\n-    ras.arc[0].x = x;\n-    ras.arc[0].y = y;\n+    arc      = arcs;\n+    arc[3].x = ras.lastX;\n+    arc[3].y = ras.lastY;\n+    arc[2].x = cx1;\n+    arc[2].y = cy1;\n+    arc[1].x = cx2;\n+    arc[1].y = cy2;\n+    arc[0].x = x;\n+    arc[0].y = y;\n@@ -1649,5 +1621,5 @@\n-      y1 = ras.arc[3].y;\n-      y2 = ras.arc[2].y;\n-      y3 = ras.arc[1].y;\n-      y4 = ras.arc[0].y;\n-      x4 = ras.arc[0].x;\n+      y1 = arc[3].y;\n+      y2 = arc[2].y;\n+      y3 = arc[1].y;\n+      y4 = arc[0].y;\n+      x4 = arc[0].x;\n@@ -1682,2 +1654,2 @@\n-        Split_Cubic( ras.arc );\n-        ras.arc += 3;\n+        Split_Cubic( arc );\n+        arc += 3;\n@@ -1688,1 +1660,1 @@\n-        ras.arc -= 3;\n+        arc -= 3;\n@@ -1714,1 +1686,2 @@\n-          if ( Bezier_Up( RAS_VARS 3, Split_Cubic, ras.minY, ras.maxY ) )\n+          if ( Bezier_Up( RAS_VARS 3, arc, Split_Cubic,\n+                                   ras.minY, ras.maxY ) )\n@@ -1718,1 +1691,2 @@\n-          if ( Bezier_Down( RAS_VARS 3, Split_Cubic, ras.minY, ras.maxY ) )\n+          if ( Bezier_Down( RAS_VARS 3, arc, Split_Cubic,\n+                                     ras.minY, ras.maxY ) )\n@@ -1720,0 +1694,1 @@\n+        arc -= 3;\n@@ -1722,1 +1697,1 @@\n-    } while ( ras.arc >= ras.arcs );\n+    } while ( arc >= arcs );\n@@ -1970,1 +1945,1 @@\n-    ras.error = FT_THROW( Invalid );\n+    ras.error = FT_THROW( Invalid_Outline );\n@@ -2123,2 +2098,2 @@\n-  DelOld( PProfileList  list,\n-          PProfile      profile )\n+  DelOld( PProfileList    list,\n+          const PProfile  profile )\n@@ -2217,2 +2192,2 @@\n-  Vertical_Sweep_Init( RAS_ARGS Short*  min,\n-                                Short*  max )\n+  Vertical_Sweep_Init( RAS_ARGS Short  min,\n+                                Short  max )\n@@ -2220,2 +2195,0 @@\n-    Long  pitch = ras.target.pitch;\n-\n@@ -2225,2 +2198,1 @@\n-    ras.traceIncr = (Short)-pitch;\n-    ras.traceOfs  = -*min * pitch;\n+    ras.bLine = ras.bOrigin - min * ras.target.pitch;\n@@ -2237,2 +2209,1 @@\n-    Long   e1, e2;\n-    Byte*  target;\n+    Long  e1, e2;\n@@ -2271,0 +2242,2 @@\n+      Byte*  target;\n+\n@@ -2288,1 +2261,1 @@\n-      target = ras.bOrigin + ras.traceOfs + c1;\n+      target = ras.bLine + c1;\n@@ -2440,2 +2413,2 @@\n-        if ( e1 >= 0 && e1 < ras.bWidth                      &&\n-             ras.bOrigin[ras.traceOfs + c1] & ( 0x80 >> f1 ) )\n+        if ( e1 >= 0 && e1 < ras.bWidth     &&\n+             ras.bLine[c1] & ( 0x80 >> f1 ) )\n@@ -2457,1 +2430,1 @@\n-      ras.bOrigin[ras.traceOfs + c1] |= (char)( 0x80 >> f1 );\n+      ras.bLine[c1] |= (char)( 0x80 >> f1 );\n@@ -2468,1 +2441,1 @@\n-    ras.traceOfs += ras.traceIncr;\n+    ras.bLine -= ras.target.pitch;\n@@ -2482,2 +2455,2 @@\n-  Horizontal_Sweep_Init( RAS_ARGS Short*  min,\n-                                  Short*  max )\n+  Horizontal_Sweep_Init( RAS_ARGS Short  min,\n+                                  Short  max )\n@@ -2747,1 +2720,1 @@\n-      ras.error = FT_THROW( Invalid );\n+      ras.error = FT_THROW( Invalid_Outline );\n@@ -2753,1 +2726,1 @@\n-    ras.Proc_Sweep_Init( RAS_VARS &min_Y, &max_Y );\n+    ras.Proc_Sweep_Init( RAS_VARS min_Y, max_Y );\n@@ -2980,3 +2953,0 @@\n-    Long  xMin, yMin, xMax, yMax;\n-\n-\n@@ -2985,0 +2955,3 @@\n+      Long  xMin, yMin, xMax, yMax;\n+\n+\n@@ -3042,1 +3015,3 @@\n-  Render_Single_Pass( RAS_ARGS Bool  flipped )\n+  Render_Single_Pass( RAS_ARGS Bool  flipped,\n+                               Int   y_min,\n+                               Int   y_max )\n@@ -3044,1 +3019,3 @@\n-    Short  i, j, k;\n+    Int  y_mid;\n+    Int  band_top = 0;\n+    Int  band_stack[32];  \/* enough to bisect 32-bit int bands *\/\n@@ -3047,1 +3024,1 @@\n-    while ( ras.band_top >= 0 )\n+    while ( 1 )\n@@ -3049,2 +3026,2 @@\n-      ras.maxY = (Long)ras.band_stack[ras.band_top].y_max * ras.precision;\n-      ras.minY = (Long)ras.band_stack[ras.band_top].y_min * ras.precision;\n+      ras.minY = (Long)y_min * ras.precision;\n+      ras.maxY = (Long)y_max * ras.precision;\n@@ -3054,1 +3031,1 @@\n-      ras.error = Raster_Err_None;\n+      ras.error = Raster_Err_Ok;\n@@ -3058,4 +3035,2 @@\n-        if ( ras.error != Raster_Err_Overflow )\n-          return FAILURE;\n-\n-        ras.error = Raster_Err_None;\n+        if ( ras.error != Raster_Err_Raster_Overflow )\n+          return ras.error;\n@@ -3065,3 +3040,2 @@\n-#ifdef DEBUG_RASTER\n-        ClearBand( RAS_VARS TRUNC( ras.minY ), TRUNC( ras.maxY ) );\n-#endif\n+        if ( y_min == y_max )\n+          return ras.error;  \/* still Raster_Overflow *\/\n@@ -3069,2 +3043,1 @@\n-        i = ras.band_stack[ras.band_top].y_min;\n-        j = ras.band_stack[ras.band_top].y_max;\n+        y_mid = ( y_min + y_max ) >> 1;\n@@ -3072,16 +3045,2 @@\n-        k = (Short)( ( i + j ) \/ 2 );\n-\n-        if ( ras.band_top >= 7 || k < i )\n-        {\n-          ras.band_top = 0;\n-          ras.error    = FT_THROW( Invalid );\n-\n-          return ras.error;\n-        }\n-\n-        ras.band_stack[ras.band_top + 1].y_min = k;\n-        ras.band_stack[ras.band_top + 1].y_max = j;\n-\n-        ras.band_stack[ras.band_top].y_max = (Short)( k - 1 );\n-\n-        ras.band_top++;\n+        band_stack[band_top++] = y_min;\n+        y_min                  = y_mid + 1;\n@@ -3094,1 +3053,6 @@\n-        ras.band_top--;\n+\n+        if ( --band_top < 0 )\n+          break;\n+\n+        y_max = y_min - 1;\n+        y_min = band_stack[band_top];\n@@ -3098,1 +3062,1 @@\n-    return SUCCESS;\n+    return Raster_Err_Ok;\n@@ -3135,3 +3099,0 @@\n-    ras.second_pass = (Bool)( !( ras.outline.flags      &\n-                                 FT_OUTLINE_SINGLE_PASS ) );\n-\n@@ -3146,4 +3107,0 @@\n-    ras.band_top            = 0;\n-    ras.band_stack[0].y_min = 0;\n-    ras.band_stack[0].y_max = (Short)( ras.target.rows - 1 );\n-\n@@ -3156,1 +3113,2 @@\n-    if ( ( error = Render_Single_Pass( RAS_VARS 0 ) ) != 0 )\n+    error = Render_Single_Pass( RAS_VARS 0, 0, (Int)ras.target.rows - 1 );\n+    if ( error )\n@@ -3160,1 +3118,1 @@\n-    if ( ras.second_pass && ras.dropOutControl != 2 )\n+    if ( !( ras.outline.flags & FT_OUTLINE_SINGLE_PASS ) )\n@@ -3169,5 +3127,2 @@\n-      ras.band_top            = 0;\n-      ras.band_stack[0].y_min = 0;\n-      ras.band_stack[0].y_max = (Short)( ras.target.width - 1 );\n-\n-      if ( ( error = Render_Single_Pass( RAS_VARS 1 ) ) != 0 )\n+      error = Render_Single_Pass( RAS_VARS 1, 0, (Int)ras.target.width - 1 );\n+      if ( error )\n@@ -3177,8 +3132,1 @@\n-    return Raster_Err_None;\n-  }\n-\n-\n-  static void\n-  ft_black_init( black_PRaster  raster )\n-  {\n-    FT_UNUSED( raster );\n+    return Raster_Err_Ok;\n@@ -3205,1 +3153,0 @@\n-     ft_black_init( &the_raster );\n@@ -3230,1 +3177,0 @@\n-    *araster = 0;\n@@ -3232,1 +3178,0 @@\n-    {\n@@ -3234,1 +3179,0 @@\n-      ft_black_init( raster );\n@@ -3236,2 +3180,1 @@\n-      *araster = raster;\n-    }\n+    *araster = raster;\n@@ -3295,1 +3238,1 @@\n-      return FT_THROW( Not_Ini );\n+      return FT_THROW( Raster_Uninitialized );\n@@ -3298,1 +3241,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Outline );\n@@ -3302,1 +3245,1 @@\n-      return Raster_Err_None;\n+      return Raster_Err_Ok;\n@@ -3305,1 +3248,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Outline );\n@@ -3309,1 +3252,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Outline );\n@@ -3312,5 +3255,3 @@\n-    if ( params->flags & FT_RASTER_FLAG_DIRECT )\n-      return FT_THROW( Unsupported );\n-\n-    if ( params->flags & FT_RASTER_FLAG_AA )\n-      return FT_THROW( Unsupported );\n+    if ( params->flags & FT_RASTER_FLAG_DIRECT ||\n+         params->flags & FT_RASTER_FLAG_AA     )\n+      return FT_THROW( Cannot_Render_Glyph );\n@@ -3319,1 +3260,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Argument );\n@@ -3323,1 +3264,1 @@\n-      return Raster_Err_None;\n+      return Raster_Err_Ok;\n@@ -3326,1 +3267,1 @@\n-      return FT_THROW( Invalid );\n+      return FT_THROW( Invalid_Argument );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftraster.c","additions":132,"deletions":191,"binary":false,"changes":323,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftraster.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftrend1.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/ftrend1.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/raster\/rasterrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n@@ -273,1 +273,4 @@\n-    png_byte*  *rows = NULL; \/* pacify compiler *\/\n+\n+    \/* `rows` gets modified within a 'setjmp' scope; *\/\n+    \/* we thus need the `volatile` keyword.          *\/\n+    png_byte* *volatile  rows = NULL;\n@@ -430,1 +433,1 @@\n-    if ( FT_NEW_ARRAY( rows, imgHeight ) )\n+    if ( FT_QNEW_ARRAY( rows, imgHeight ) )\n@@ -441,2 +444,0 @@\n-    FT_FREE( rows );\n-\n@@ -446,0 +447,2 @@\n+    \/* even if reading fails with longjmp, rows must be freed *\/\n+    FT_FREE( rows );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/pngshim.c","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2013-2020 by\n+ * Copyright (C) 2013-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/pngshim.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -39,0 +39,4 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+#include \"ttsvg.h\"\n+#endif\n+\n@@ -494,1 +498,1 @@\n-    FT_Error  error = FT_Err_Ok;\n+    FT_Error  error;\n@@ -501,2 +505,0 @@\n-    FT_UNUSED( error );\n-\n@@ -504,1 +506,1 @@\n-    if ( FT_ALLOC( result, entry->stringLength \/ 2 + 1 ) )\n+    if ( FT_QALLOC( result, entry->stringLength \/ 2 + 1 ) )\n@@ -553,1 +555,1 @@\n-    FT_Error  error = FT_Err_Ok;\n+    FT_Error  error;\n@@ -560,1 +562,0 @@\n-    FT_UNUSED( error );\n@@ -562,2 +563,1 @@\n-\n-    if ( FT_ALLOC( result, entry->stringLength + 1 ) )\n+    if ( FT_QALLOC( result, entry->stringLength + 1 ) )\n@@ -871,2 +871,2 @@\n-                    \" Shortening variation PS name prefix\\n\"\n-                    \"                     \"\n+                    \" Shortening variation PS name prefix\\n\" ));\n+        FT_TRACE0(( \"                     \"\n@@ -923,2 +923,2 @@\n-                      \" can't construct named instance PS name;\\n\"\n-                      \"                     \"\n+                      \" can't construct named instance PS name;\\n\" ));\n+          FT_TRACE1(( \"                     \"\n@@ -931,2 +931,2 @@\n-        if ( FT_ALLOC( result, face->var_postscript_prefix_len +\n-                               1 + ft_strlen( subfamily_name ) + 1 ) )\n+        if ( FT_QALLOC( result, face->var_postscript_prefix_len +\n+                                1 + ft_strlen( subfamily_name ) + 1 ) )\n@@ -960,3 +960,3 @@\n-      if ( FT_ALLOC( result,\n-                     face->var_postscript_prefix_len +\n-                       num_coords * MAX_VALUE_DESCRIPTOR_LEN + 1 ) )\n+      if ( FT_QALLOC( result,\n+                      face->var_postscript_prefix_len +\n+                        num_coords * MAX_VALUE_DESCRIPTOR_LEN + 1 ) )\n@@ -996,0 +996,1 @@\n+      *p++ = '\\0';\n@@ -1216,0 +1217,8 @@\n+#ifdef FT_CONFIG_OPTION_SVG\n+#define PUT_SVG_SUPPORT( a )  a\n+#else\n+#define PUT_SVG_SUPPORT( a )  NULL\n+#endif\n+\n+#define PUT_COLOR_LAYERS_V1( a )  PUT_COLOR_LAYERS( a )\n+\n@@ -1274,1 +1283,1 @@\n-                   \/* TT_Set_SBit_Strike_Func      set_sbit_strike     *\/\n+                  \/* TT_Set_SBit_Strike_Func      set_sbit_strike      *\/\n@@ -1276,1 +1285,1 @@\n-                   \/* TT_Load_Strike_Metrics_Func  load_strike_metrics *\/\n+                  \/* TT_Load_Strike_Metrics_Func  load_strike_metrics  *\/\n@@ -1290,0 +1299,12 @@\n+\n+    PUT_COLOR_LAYERS_V1( tt_face_get_colr_glyph_paint ),\n+              \/* TT_Get_Color_Glyph_Paint_Func    get_colr_glyph_paint *\/\n+    PUT_COLOR_LAYERS_V1( tt_face_get_color_glyph_clipbox ),\n+              \/* TT_Get_Color_Glyph_ClipBox_Func  get_clipbox          *\/\n+    PUT_COLOR_LAYERS_V1( tt_face_get_paint_layers ),\n+              \/* TT_Get_Paint_Layers_Func         get_paint_layers     *\/\n+    PUT_COLOR_LAYERS_V1( tt_face_get_colorline_stops ),\n+              \/* TT_Get_Paint                     get_paint            *\/\n+    PUT_COLOR_LAYERS_V1( tt_face_get_paint ),\n+              \/* TT_Get_Colorline_Stops_Func      get_colorline_stops  *\/\n+\n@@ -1296,1 +1317,8 @@\n-    sfnt_get_name_id        \/* TT_Get_Name_ID_Func     get_name_id     *\/\n+    sfnt_get_name_id,       \/* TT_Get_Name_ID_Func     get_name_id     *\/\n+\n+    PUT_SVG_SUPPORT( tt_face_load_svg ),\n+                            \/* TT_Load_Table_Func      load_svg        *\/\n+    PUT_SVG_SUPPORT( tt_face_free_svg ),\n+                            \/* TT_Free_Table_Func      free_svg        *\/\n+    PUT_SVG_SUPPORT( tt_face_load_svg_doc )\n+                            \/* TT_Load_Svg_Doc_Func    load_svg_doc    *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfdriver.c","additions":49,"deletions":21,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfdriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sferrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -68,1 +68,1 @@\n-    if ( FT_NEW_ARRAY( string, len + 1 ) )\n+    if ( FT_QNEW_ARRAY( string, len + 1 ) )\n@@ -103,1 +103,1 @@\n-    if ( FT_NEW_ARRAY( string, len + 1 ) )\n+    if ( FT_QNEW_ARRAY( string, len + 1 ) )\n@@ -363,0 +363,5 @@\n+#ifndef FT_CONFIG_OPTION_USE_BROTLI\n+    FT_UNUSED( face_instance_index );\n+    FT_UNUSED( woff2_num_faces );\n+#endif\n+\n@@ -368,0 +373,2 @@\n+#if defined( FT_CONFIG_OPTION_USE_ZLIB )   || \\\n+    defined( FT_CONFIG_OPTION_USE_BROTLI )\n@@ -369,0 +376,2 @@\n+#endif\n+\n@@ -374,0 +383,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_ZLIB\n@@ -389,0 +399,1 @@\n+#endif\n@@ -390,0 +401,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_BROTLI\n@@ -408,0 +420,1 @@\n+#endif\n@@ -449,1 +462,1 @@\n-      if ( FT_NEW_ARRAY( face->ttc_header.offsets, face->ttc_header.count ) )\n+      if ( FT_QNEW_ARRAY( face->ttc_header.offsets, face->ttc_header.count ) )\n@@ -467,1 +480,1 @@\n-      if ( FT_NEW( face->ttc_header.offsets ) )\n+      if ( FT_QNEW( face->ttc_header.offsets ) )\n@@ -556,1 +569,1 @@\n-    if ( face_instance_index < 0 )\n+    if ( face_instance_index < 0 && face_index > 0 )\n@@ -646,2 +659,2 @@\n-           !( FT_ALLOC( default_values, num_axes * 4 )  ||\n-              FT_ALLOC( instance_values, num_axes * 4 ) )      )\n+           !( FT_QALLOC(  default_values, num_axes * 4 ) ||\n+              FT_QALLOC( instance_values, num_axes * 4 ) )     )\n@@ -774,1 +787,1 @@\n-    FT_Error      error;\n+    FT_Error  error;\n@@ -776,1 +789,1 @@\n-    FT_Error      psnames_error;\n+    FT_Error  psnames_error;\n@@ -778,7 +791,13 @@\n-    FT_Bool       has_outline;\n-    FT_Bool       is_apple_sbit;\n-    FT_Bool       is_apple_sbix;\n-    FT_Bool       has_CBLC;\n-    FT_Bool       has_CBDT;\n-    FT_Bool       ignore_typographic_family    = FALSE;\n-    FT_Bool       ignore_typographic_subfamily = FALSE;\n+\n+    FT_Bool  has_outline;\n+    FT_Bool  is_apple_sbit;\n+\n+    FT_Bool  has_CBLC;\n+    FT_Bool  has_CBDT;\n+    FT_Bool  has_EBLC;\n+    FT_Bool  has_bloc;\n+    FT_Bool  has_sbix;\n+\n+    FT_Bool  ignore_typographic_family    = FALSE;\n+    FT_Bool  ignore_typographic_subfamily = FALSE;\n+    FT_Bool  ignore_sbix                  = FALSE;\n@@ -803,0 +822,2 @@\n+        else if ( params[i].tag == FT_PARAM_TAG_IGNORE_SBIX )\n+          ignore_sbix = TRUE;\n@@ -823,1 +844,2 @@\n-    FT_TRACE2(( \"sfnt_load_face: %p\\n\\n\", (void *)face ));\n+    FT_TRACE2(( \"sfnt_load_face: %p\\n\", (void *)face ));\n+    FT_TRACE2(( \"\\n\" ));\n@@ -837,2 +859,8 @@\n-    is_apple_sbit = 0;\n-    is_apple_sbix = !face->goto_table( face, TTAG_sbix, stream, 0 );\n+    \/* check which sbit formats are present *\/\n+    has_CBLC = !face->goto_table( face, TTAG_CBLC, stream, 0 );\n+    has_CBDT = !face->goto_table( face, TTAG_CBDT, stream, 0 );\n+    has_EBLC = !face->goto_table( face, TTAG_EBLC, stream, 0 );\n+    has_bloc = !face->goto_table( face, TTAG_bloc, stream, 0 );\n+    has_sbix = !face->goto_table( face, TTAG_sbix, stream, 0 );\n+\n+    is_apple_sbit = FALSE;\n@@ -840,5 +868,2 @@\n-    \/* Apple 'sbix' color bitmaps are rendered scaled and then the 'glyf'\n-     * outline rendered on top.  We don't support that yet, so just ignore\n-     * the 'glyf' outline and advertise it as a bitmap-only font. *\/\n-    if ( is_apple_sbix )\n-      has_outline = FALSE;\n+    if ( ignore_sbix )\n+      has_sbix = FALSE;\n@@ -856,1 +881,1 @@\n-    if ( !is_apple_sbit || is_apple_sbix )\n+    if ( !is_apple_sbit || has_sbix )\n@@ -863,3 +888,0 @@\n-    has_CBLC = !face->goto_table( face, TTAG_CBLC, stream, 0 );\n-    has_CBDT = !face->goto_table( face, TTAG_CBDT, stream, 0 );\n-\n@@ -975,1 +997,5 @@\n-    if ( sfnt->load_eblc )\n+    \/* TODO: Replace this clumsy check for all possible sbit tables     *\/\n+    \/*       with something better (for example, by passing a parameter *\/\n+    \/*       to suppress 'sbix' loading).                               *\/\n+    if ( sfnt->load_eblc                                  &&\n+         ( has_CBLC || has_EBLC || has_bloc || has_sbix ) )\n@@ -985,0 +1011,4 @@\n+    \/* OpenType-SVG glyph support *\/\n+    if ( sfnt->load_svg )\n+      LOAD_( svg );\n+\n@@ -1043,1 +1073,8 @@\n-        flags |= FT_FACE_FLAG_SCALABLE;   \/* scalable outlines *\/\n+      {\n+        \/* by default (and for backward compatibility) we handle *\/\n+        \/* fonts with an 'sbix' table as bitmap-only             *\/\n+        if ( has_sbix )\n+          flags |= FT_FACE_FLAG_SBIX;     \/* with 'sbix' bitmaps *\/\n+        else\n+          flags |= FT_FACE_FLAG_SCALABLE; \/* scalable outlines *\/\n+      }\n@@ -1152,1 +1189,2 @@\n-        if ( !has_unicode )\n+        if ( !has_unicode                                &&\n+             root->face_flags & FT_FACE_FLAG_GLYPH_NAMES )\n@@ -1154,1 +1192,1 @@\n-          FT_CharMapRec cmaprec;\n+          FT_CharMapRec  cmaprec;\n@@ -1210,1 +1248,1 @@\n-               FT_NEW_ARRAY( sbit_strike_map, count ) )\n+               FT_QNEW_ARRAY( sbit_strike_map, count ) )\n@@ -1239,1 +1277,1 @@\n-          (void)FT_RENEW_ARRAY( sbit_strike_map, count, bsize_idx );\n+          FT_MEM_QRENEW_ARRAY( sbit_strike_map, count, bsize_idx );\n@@ -1265,1 +1303,2 @@\n-      if ( FT_IS_SCALABLE( root ) )\n+      if ( FT_IS_SCALABLE( root ) ||\n+           FT_HAS_SBIX( root )    )\n@@ -1404,0 +1443,6 @@\n+\n+#ifdef FT_CONFIG_OPTION_SVG\n+      \/* free SVG data *\/\n+      if ( sfnt->free_svg )\n+        sfnt->free_svg( face );\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfobjs.c","additions":81,"deletions":36,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfobjs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -26,0 +26,3 @@\n+#ifdef FT_CONFIG_OPTION_USE_ZLIB\n+\n+\n@@ -64,1 +67,0 @@\n-    stream->base  = NULL;\n@@ -69,1 +71,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n@@ -112,1 +114,1 @@\n-    FT_ULong        old_tag = 0;\n+    FT_Tag          old_tag = 0;\n@@ -163,2 +165,2 @@\n-    if ( FT_ALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||\n-         FT_NEW( sfnt_stream )                         )\n+    if ( FT_QALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||\n+         FT_NEW( sfnt_stream )                          )\n@@ -201,3 +203,3 @@\n-    FT_TRACE2(( \"\\n\"\n-                \"  tag    offset    compLen  origLen  checksum\\n\"\n-                \"  -------------------------------------------\\n\" ));\n+    FT_TRACE2(( \"\\n\" ));\n+    FT_TRACE2(( \"  tag    offset    compLen  origLen  checksum\\n\" ));\n+    FT_TRACE2(( \"  -------------------------------------------\\n\" ));\n@@ -363,2 +365,0 @@\n-#ifdef FT_CONFIG_OPTION_USE_ZLIB\n-\n@@ -380,7 +380,0 @@\n-\n-#else \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n-\n-        error = FT_THROW( Unimplemented_Feature );\n-        goto Exit1;\n-\n-#endif \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n@@ -436,0 +429,7 @@\n+#else \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n+\n+  \/* ANSI C doesn't like empty source files *\/\n+  typedef int  _sfwoff_dummy;\n+\n+#endif \/* !FT_CONFIG_OPTION_USE_ZLIB *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff.c","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -29,0 +29,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_ZLIB\n@@ -35,0 +36,2 @@\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2020 by\n+ * Copyright (C) 2019-2022 by\n@@ -29,2 +29,0 @@\n-#endif\n-\n@@ -89,0 +87,2 @@\n+#define HAVE_OVERLAP_SIMPLE_BITMAP  0x1\n+\n@@ -99,1 +99,0 @@\n-    stream->base  = NULL;\n@@ -104,1 +103,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n@@ -111,2 +110,2 @@\n-    FT_ULong  tag1 = table1->Tag;\n-    FT_ULong  tag2 = table2->Tag;\n+    FT_Tag  tag1 = table1->Tag;\n+    FT_Tag  tag2 = table2->Tag;\n@@ -319,2 +318,0 @@\n-#ifdef FT_CONFIG_OPTION_USE_BROTLI\n-\n@@ -341,7 +338,0 @@\n-\n-#else \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n-\n-    FT_ERROR(( \"woff2_decompress: Brotli support not available.\\n\" ));\n-    return FT_THROW( Unimplemented_Feature );\n-\n-#endif \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n@@ -354,1 +344,1 @@\n-              FT_ULong      tag )\n+              FT_Tag        tag )\n@@ -537,0 +527,1 @@\n+                FT_Bool            have_overlap,\n@@ -564,0 +555,3 @@\n+      if ( i == 0 && have_overlap )\n+        flag |= GLYF_OVERLAP_SIMPLE;\n+\n@@ -793,1 +787,1 @@\n-    if ( FT_NEW_ARRAY( loca_buf, loca_buf_size ) )\n+    if ( FT_QNEW_ARRAY( loca_buf, loca_buf_size ) )\n@@ -848,0 +842,1 @@\n+    FT_UShort  option_flags;\n@@ -854,1 +849,0 @@\n-    FT_ULong   bitmap_length;\n@@ -857,0 +851,3 @@\n+    FT_ULong   bbox_bitmap_length;\n+    FT_ULong   overlap_bitmap_offset = 0;\n+    FT_ULong   overlap_bitmap_length = 0;\n@@ -872,1 +869,3 @@\n-    if ( FT_STREAM_SKIP( 4 ) )\n+    if ( FT_STREAM_SKIP( 2 ) )\n+      goto Fail;\n+    if ( FT_READ_USHORT( option_flags ) )\n@@ -879,2 +878,2 @@\n-    FT_TRACE4(( \"num_glyphs = %u; index_format = %u\\n\",\n-                num_glyphs, index_format ));\n+    FT_TRACE4(( \"option_flags = %u; num_glyphs = %u; index_format = %u\\n\",\n+                option_flags, num_glyphs, index_format ));\n@@ -893,1 +892,1 @@\n-    offset = ( 2 + num_substreams ) * 4;\n+    offset = 2 + 2 + 2 + 2 + ( num_substreams * 4 );\n@@ -916,0 +915,14 @@\n+    if ( option_flags & HAVE_OVERLAP_SIMPLE_BITMAP )\n+    {\n+      \/* Size of overlapBitmap = floor((numGlyphs + 7) \/ 8) *\/\n+      overlap_bitmap_length = ( num_glyphs + 7U ) >> 3;\n+      if ( overlap_bitmap_length > info->glyf_table->TransformLength - offset )\n+        goto Fail;\n+\n+      overlap_bitmap_offset = pos + offset;\n+\n+      FT_TRACE5(( \"  Overlap bitmap: offset = %lu; size = %lu;\\n\",\n+                  overlap_bitmap_offset, overlap_bitmap_length ));\n+      offset += overlap_bitmap_length;\n+    }\n+\n@@ -923,2 +936,3 @@\n-    bitmap_length                   = ( ( num_glyphs + 31U ) >> 5 ) << 2;\n-    substreams[BBOX_STREAM].offset += bitmap_length;\n+    bbox_bitmap_length              = ( ( num_glyphs + 31U ) >> 5 ) << 2;\n+    \/* bboxStreamSize is the combined size of bboxBitmap and bboxStream. *\/\n+    substreams[BBOX_STREAM].offset += bbox_bitmap_length;\n@@ -1040,2 +1054,5 @@\n-        FT_Byte*   flags_buf   = NULL;\n-        FT_Byte*   triplet_buf = NULL;\n+        FT_Bool    have_overlap  = FALSE;\n+        FT_Byte    overlap_bitmap;\n+        FT_ULong   overlap_offset;\n+        FT_Byte*   flags_buf     = NULL;\n+        FT_Byte*   triplet_buf   = NULL;\n@@ -1050,0 +1067,11 @@\n+        \/* Set `have_overlap`. *\/\n+        if ( overlap_bitmap_offset )\n+        {\n+          overlap_offset = overlap_bitmap_offset + ( i >> 3 );\n+          if ( FT_STREAM_SEEK( overlap_offset ) ||\n+               FT_READ_BYTE( overlap_bitmap )   )\n+            goto Fail;\n+          if ( overlap_bitmap & ( 0x80 >> ( i & 7 ) ) )\n+            have_overlap = TRUE;\n+        }\n+\n@@ -1170,0 +1198,1 @@\n+                           have_overlap,\n@@ -1855,5 +1884,4 @@\n-    FT_TRACE2((\n-      \"\\n\"\n-      \"  tag    flags    transform  origLen   transformLen   offset\\n\"\n-      \"  -----------------------------------------------------------\\n\" ));\n-   \/* \"  XXXX  XXXXXXXX  XXXXXXXX   XXXXXXXX    XXXXXXXX    XXXXXXXX\" *\/\n+    FT_TRACE2(( \"\\n\" ));\n+    FT_TRACE2(( \"  tag    flags    transform  origLen   transformLen   offset\\n\" ));\n+    FT_TRACE2(( \"  -----------------------------------------------------------\\n\" ));\n+             \/* \"  XXXX  XXXXXXXX  XXXXXXXX   XXXXXXXX    XXXXXXXX    XXXXXXXX\" *\/\n@@ -2101,1 +2129,1 @@\n-    if ( *face_instance_index < 0 )\n+    if ( *face_instance_index < 0 && face_index > 0 )\n@@ -2122,2 +2150,2 @@\n-      if ( FT_NEW_ARRAY( temp_indices,\n-                         ttc_font->num_tables ) )\n+      if ( FT_QNEW_ARRAY( temp_indices,\n+                          ttc_font->num_tables ) )\n@@ -2131,3 +2159,3 @@\n-      if ( FT_RENEW_ARRAY( indices,\n-                           woff2.num_tables,\n-                           ttc_font->num_tables ) )\n+      if ( FT_QRENEW_ARRAY( indices,\n+                            woff2.num_tables,\n+                            ttc_font->num_tables ) )\n@@ -2173,2 +2201,2 @@\n-    if ( FT_ALLOC( sfnt, sfnt_size ) ||\n-         FT_NEW( sfnt_stream )       )\n+    if ( FT_QALLOC( sfnt, sfnt_size ) ||\n+         FT_NEW( sfnt_stream )        )\n@@ -2212,0 +2240,19 @@\n+    \/* reject fonts that have multiple tables with the same tag *\/\n+    for ( nn = 1; nn < woff2.num_tables; nn++ )\n+    {\n+      FT_Tag  tag = indices[nn]->Tag;\n+\n+\n+      if ( tag == indices[nn - 1]->Tag )\n+      {\n+        FT_ERROR(( \"woff2_open_font:\"\n+                   \" multiple tables with tag `%c%c%c%c'.\\n\",\n+                   (FT_Char)( tag >> 24 ),\n+                   (FT_Char)( tag >> 16 ),\n+                   (FT_Char)( tag >> 8  ),\n+                   (FT_Char)( tag       ) ));\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+    }\n+\n@@ -2226,2 +2273,2 @@\n-    if ( FT_ALLOC( uncompressed_buf, woff2.uncompressed_size ) ||\n-         FT_FRAME_ENTER( woff2.totalCompressedSize )           )\n+    if ( FT_QALLOC( uncompressed_buf, woff2.uncompressed_size ) ||\n+         FT_FRAME_ENTER( woff2.totalCompressedSize )            )\n@@ -2336,0 +2383,7 @@\n+#else \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n+\n+  \/* ANSI C doesn't like empty source files *\/\n+  typedef int  _sfwoff2_dummy;\n+\n+#endif \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff2.c","additions":96,"deletions":42,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2020 by\n+ * Copyright (C) 2019-2022 by\n@@ -29,0 +29,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_BROTLI\n@@ -58,0 +59,1 @@\n+#define GLYF_OVERLAP_SIMPLE  1 << 6\n@@ -69,0 +71,1 @@\n+#endif \/* FT_CONFIG_OPTION_USE_BROTLI *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/sfwoff2.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n@@ -919,0 +919,10 @@\n+    \/* it also happens that the `length' field is too small; *\/\n+    \/* this is easy to correct                               *\/\n+    if ( length < (FT_UInt)( valid->limit - table ) )\n+    {\n+      if ( valid->level >= FT_VALIDATE_PARANOID )\n+        FT_INVALID_DATA;\n+\n+      length = (FT_UInt)( valid->limit - table );\n+    }\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcmap.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2002-2020 by\n+ * Copyright (C) 2002-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcmap.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2009-2020 by\n+ * Copyright (C) 2009-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcmapc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,2 +7,2 @@\n- * Copyright (C) 2018-2020 by\n- * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ * Copyright (C) 2018-2022 by\n+ * David Turner, Robert Wilhelm, Dominik Röttsches, and Werner Lemberg.\n@@ -30,0 +30,1 @@\n+#include <freetype\/internal\/ftcalc.h>\n@@ -34,0 +35,1 @@\n+#include <freetype\/config\/integer-types.h>\n@@ -42,3 +44,7 @@\n-#define BASE_GLYPH_SIZE            6U\n-#define LAYER_SIZE                 4U\n-#define COLR_HEADER_SIZE          14U\n+#define BASE_GLYPH_SIZE                   6U\n+#define BASE_GLYPH_PAINT_RECORD_SIZE      6U\n+#define LAYER_V1_LIST_PAINT_OFFSET_SIZE   4U\n+#define LAYER_V1_LIST_NUM_LAYERS_SIZE     4U\n+#define COLOR_STOP_SIZE                   6U\n+#define LAYER_SIZE                        4U\n+#define COLR_HEADER_SIZE                 14U\n@@ -47,1 +53,12 @@\n-  typedef struct BaseGlyphRecord_\n+  typedef enum  FT_PaintFormat_Internal_\n+  {\n+    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER         = 18,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM        = 20,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER = 22,\n+    FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER        = 26,\n+    FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER          = 30\n+\n+  } FT_PaintFormat_Internal;\n+\n+\n+  typedef struct  BaseGlyphRecord_\n@@ -56,1 +73,10 @@\n-  typedef struct Colr_\n+  typedef struct  BaseGlyphV1Record_\n+  {\n+    FT_UShort  gid;\n+    \/* Offset from start of BaseGlyphV1List, i.e., from base_glyphs_v1. *\/\n+    FT_ULong   paint_offset;\n+\n+  } BaseGlyphV1Record;\n+\n+\n+  typedef struct  Colr_\n@@ -65,1 +91,17 @@\n-    \/* The memory which backs up the `COLR' table. *\/\n+    FT_ULong  num_base_glyphs_v1;\n+    \/* Points at beginning of BaseGlyphV1List. *\/\n+    FT_Byte*  base_glyphs_v1;\n+\n+    FT_ULong  num_layers_v1;\n+    FT_Byte*  layers_v1;\n+\n+    FT_Byte*  clip_list;\n+\n+    \/*\n+     * Paint tables start at the minimum of the end of the LayerList and the\n+     * end of the BaseGlyphList.  Record this location in a field here for\n+     * safety checks when accessing paint tables.\n+     *\/\n+    FT_Byte*  paints_start_v1;\n+\n+    \/* The memory that backs up the `COLR' table. *\/\n@@ -91,0 +133,2 @@\n+    \/* Needed for reading array lengths in referenced tables. *\/\n+    FT_Byte*  p1    = NULL;\n@@ -95,0 +139,2 @@\n+    FT_ULong  base_glyphs_offset_v1, num_base_glyphs_v1;\n+    FT_ULong  layer_offset_v1, num_layers_v1, clip_list_offset;\n@@ -118,1 +164,1 @@\n-    if ( colr->version != 0 )\n+    if ( colr->version != 0 && colr->version != 1 )\n@@ -138,0 +184,60 @@\n+    if ( colr->version == 1 )\n+    {\n+      base_glyphs_offset_v1 = FT_NEXT_ULONG( p );\n+\n+      if ( base_glyphs_offset_v1 >= table_size )\n+        goto InvalidTable;\n+\n+      p1                 = (FT_Byte*)( table + base_glyphs_offset_v1 );\n+      num_base_glyphs_v1 = FT_PEEK_ULONG( p1 );\n+\n+      if ( num_base_glyphs_v1 * BASE_GLYPH_PAINT_RECORD_SIZE >\n+             table_size - base_glyphs_offset_v1 )\n+        goto InvalidTable;\n+\n+      colr->num_base_glyphs_v1 = num_base_glyphs_v1;\n+      colr->base_glyphs_v1     = p1;\n+\n+      layer_offset_v1 = FT_NEXT_ULONG( p );\n+\n+      if ( layer_offset_v1 >= table_size )\n+        goto InvalidTable;\n+\n+      if ( layer_offset_v1 )\n+      {\n+        p1            = (FT_Byte*)( table + layer_offset_v1 );\n+        num_layers_v1 = FT_PEEK_ULONG( p1 );\n+\n+        if ( num_layers_v1 * LAYER_V1_LIST_PAINT_OFFSET_SIZE >\n+               table_size - layer_offset_v1 )\n+          goto InvalidTable;\n+\n+        colr->num_layers_v1 = num_layers_v1;\n+        colr->layers_v1     = p1;\n+\n+        colr->paints_start_v1 =\n+            FT_MIN( colr->base_glyphs_v1 +\n+                    colr->num_base_glyphs_v1 * BASE_GLYPH_PAINT_RECORD_SIZE,\n+                    colr->layers_v1 +\n+                    colr->num_layers_v1 * LAYER_V1_LIST_PAINT_OFFSET_SIZE );\n+      }\n+      else\n+      {\n+        colr->num_layers_v1   = 0;\n+        colr->layers_v1       = 0;\n+        colr->paints_start_v1 =\n+          colr->base_glyphs_v1 +\n+          colr->num_base_glyphs_v1 * BASE_GLYPH_PAINT_RECORD_SIZE;\n+      }\n+\n+      clip_list_offset = FT_NEXT_ULONG( p );\n+\n+      if ( clip_list_offset >= table_size )\n+        goto InvalidTable;\n+\n+      if ( clip_list_offset )\n+        colr->clip_list = (FT_Byte*)( table + clip_list_offset );\n+      else\n+        colr->clip_list = 0;\n+    }\n+\n@@ -177,1 +283,1 @@\n-                          FT_Int            num_base_glyph,\n+                          FT_UInt           num_base_glyph,\n@@ -181,2 +287,2 @@\n-    FT_Int  min = 0;\n-    FT_Int  max = num_base_glyph - 1;\n+    FT_UInt  min = 0;\n+    FT_UInt  max = num_base_glyph;\n@@ -185,1 +291,1 @@\n-    while ( min <= max )\n+    while ( min < max )\n@@ -187,1 +293,1 @@\n-      FT_Int    mid = min + ( max - min ) \/ 2;\n+      FT_UInt   mid = min + ( max - min ) \/ 2;\n@@ -196,1 +302,1 @@\n-        max = mid - 1;\n+        max = mid;\n@@ -268,0 +374,772 @@\n+  static FT_Bool\n+  read_color_line( FT_Byte*      color_line_p,\n+                   FT_ColorLine  *colorline )\n+  {\n+    FT_Byte*        p = color_line_p;\n+    FT_PaintExtend  paint_extend;\n+\n+\n+    paint_extend = (FT_PaintExtend)FT_NEXT_BYTE( p );\n+    if ( paint_extend > FT_COLR_PAINT_EXTEND_REFLECT )\n+      return 0;\n+\n+    colorline->extend = paint_extend;\n+\n+    colorline->color_stop_iterator.num_color_stops    = FT_NEXT_USHORT( p );\n+    colorline->color_stop_iterator.p                  = p;\n+    colorline->color_stop_iterator.current_color_stop = 0;\n+\n+    return 1;\n+  }\n+\n+\n+  \/*\n+   * Read a paint offset for `FT_Paint*` objects that have them and check\n+   * whether it is within reasonable limits within the font and the COLR\n+   * table.\n+   *\n+   * Return 1 on success, 0 on failure.\n+   *\/\n+  static FT_Bool\n+  get_child_table_pointer ( Colr*      colr,\n+                            FT_Byte*   paint_base,\n+                            FT_Byte**  p,\n+                            FT_Byte**  child_table_pointer )\n+  {\n+    FT_UInt32  paint_offset;\n+    FT_Byte*   child_table_p;\n+\n+\n+    if ( !child_table_pointer )\n+      return 0;\n+\n+    paint_offset = FT_NEXT_UOFF3( *p );\n+    if ( !paint_offset )\n+      return 0;\n+\n+    child_table_p = (FT_Byte*)( paint_base + paint_offset );\n+\n+    if ( child_table_p < colr->paints_start_v1                         ||\n+         child_table_p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+      return 0;\n+\n+    *child_table_pointer = child_table_p;\n+    return 1;\n+  }\n+\n+\n+  static FT_Bool\n+  read_paint( Colr*           colr,\n+              FT_Byte*        p,\n+              FT_COLR_Paint*  apaint )\n+  {\n+    FT_Byte*  paint_base     = p;\n+    FT_Byte*  child_table_p  = NULL;\n+\n+\n+    if ( !p || !colr || !colr->table )\n+      return 0;\n+\n+    if ( p < colr->paints_start_v1                         ||\n+         p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+      return 0;\n+\n+    apaint->format = (FT_PaintFormat)FT_NEXT_BYTE( p );\n+\n+    if ( apaint->format >= FT_COLR_PAINT_FORMAT_MAX )\n+      return 0;\n+\n+    if ( apaint->format == FT_COLR_PAINTFORMAT_COLR_LAYERS )\n+    {\n+      \/* Initialize layer iterator\/ *\/\n+      FT_Byte    num_layers;\n+      FT_UInt32  first_layer_index;\n+\n+\n+      num_layers = FT_NEXT_BYTE( p );\n+      if ( num_layers > colr->num_layers_v1 )\n+        return 0;\n+\n+      first_layer_index = FT_NEXT_ULONG( p );\n+      if ( first_layer_index + num_layers > colr->num_layers_v1 )\n+        return 0;\n+\n+      apaint->u.colr_layers.layer_iterator.num_layers = num_layers;\n+      apaint->u.colr_layers.layer_iterator.layer      = 0;\n+      \/* TODO: Check whether pointer is outside colr? *\/\n+      apaint->u.colr_layers.layer_iterator.p =\n+        colr->layers_v1 +\n+        LAYER_V1_LIST_NUM_LAYERS_SIZE +\n+        LAYER_V1_LIST_PAINT_OFFSET_SIZE * first_layer_index;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_SOLID )\n+    {\n+      apaint->u.solid.color.palette_index = FT_NEXT_USHORT( p );\n+      apaint->u.solid.color.alpha         = FT_NEXT_SHORT( p );\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_COLR_GLYPH )\n+    {\n+      apaint->u.colr_glyph.glyphID = FT_NEXT_USHORT( p );\n+\n+      return 1;\n+    }\n+\n+    \/*\n+     * Grouped below here are all paint formats that have an offset to a\n+     * child paint table as the first entry (for example, a color line or a\n+     * child paint table).  Retrieve that and determine whether that paint\n+     * offset is valid first.\n+     *\/\n+\n+    if ( !get_child_table_pointer( colr, paint_base, &p, &child_table_p ) )\n+      return 0;\n+\n+    if ( apaint->format == FT_COLR_PAINTFORMAT_LINEAR_GRADIENT )\n+    {\n+      if ( !read_color_line( child_table_p,\n+                             &apaint->u.linear_gradient.colorline ) )\n+        return 0;\n+\n+      \/*\n+       * In order to support variations expose these as FT_Fixed 16.16 values so\n+       * that we can support fractional values after interpolation.\n+       *\/\n+      apaint->u.linear_gradient.p0.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p0.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p1.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p1.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p2.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.linear_gradient.p2.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_RADIAL_GRADIENT )\n+    {\n+      FT_Pos  tmp;\n+\n+\n+      if ( !read_color_line( child_table_p,\n+                             &apaint->u.radial_gradient.colorline ) )\n+        return 0;\n+\n+      \/* In the OpenType specification, `r0` and `r1` are defined as   *\/\n+      \/* `UFWORD`.  Since FreeType doesn't have a corresponding 16.16  *\/\n+      \/* format we convert to `FWORD` and replace negative values with *\/\n+      \/* (32bit) `FT_INT_MAX`.                                         *\/\n+\n+      apaint->u.radial_gradient.c0.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.radial_gradient.c0.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      tmp                          = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.radial_gradient.r0 = tmp < 0 ? FT_INT_MAX : tmp;\n+\n+      apaint->u.radial_gradient.c1.x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.radial_gradient.c1.y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      tmp                          = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.radial_gradient.r1 = tmp < 0 ? FT_INT_MAX : tmp;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_SWEEP_GRADIENT )\n+    {\n+      if ( !read_color_line( child_table_p,\n+                             &apaint->u.sweep_gradient.colorline ) )\n+        return 0;\n+\n+      apaint->u.sweep_gradient.center.x =\n+          INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.sweep_gradient.center.y =\n+          INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      apaint->u.sweep_gradient.start_angle =\n+          F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.sweep_gradient.end_angle =\n+          F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      return 1;\n+    }\n+\n+    if ( apaint->format == FT_COLR_PAINTFORMAT_GLYPH )\n+    {\n+      apaint->u.glyph.paint.p                     = child_table_p;\n+      apaint->u.glyph.paint.insert_root_transform = 0;\n+      apaint->u.glyph.glyphID                     = FT_NEXT_USHORT( p );\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_TRANSFORM )\n+    {\n+      apaint->u.transform.paint.p                     = child_table_p;\n+      apaint->u.transform.paint.insert_root_transform = 0;\n+\n+      if ( !get_child_table_pointer( colr, paint_base, &p, &child_table_p ) )\n+         return 0;\n+\n+      p = child_table_p;\n+\n+      \/*\n+       * The following matrix coefficients are encoded as\n+       * OpenType 16.16 fixed-point values.\n+       *\/\n+      apaint->u.transform.affine.xx = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.yx = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.xy = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.yy = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.dx = FT_NEXT_LONG( p );\n+      apaint->u.transform.affine.dy = FT_NEXT_LONG( p );\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_TRANSLATE )\n+    {\n+      apaint->u.translate.paint.p                     = child_table_p;\n+      apaint->u.translate.paint.insert_root_transform = 0;\n+\n+      apaint->u.translate.dx = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.translate.dy = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format ==\n+                FT_COLR_PAINTFORMAT_SCALE                         ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER         ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM        ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER )\n+    {\n+      apaint->u.scale.paint.p                     = child_table_p;\n+      apaint->u.scale.paint.insert_root_transform = 0;\n+\n+      \/* All scale paints get at least one scale value. *\/\n+      apaint->u.scale.scale_x = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      \/* Non-uniform ones read an extra y value. *\/\n+      if ( apaint->format ==\n+             FT_COLR_PAINTFORMAT_SCALE                 ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER )\n+        apaint->u.scale.scale_y = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      else\n+        apaint->u.scale.scale_y = apaint->u.scale.scale_x;\n+\n+      \/* Scale paints that have a center read center coordinates, *\/\n+      \/* otherwise the center is (0,0).                           *\/\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_CENTER         ||\n+           (FT_PaintFormat_Internal)apaint->format ==\n+             FT_COLR_PAINTFORMAT_INTERNAL_SCALE_UNIFORM_CENTER )\n+      {\n+        apaint->u.scale.center_x = INT_TO_FIXED( FT_NEXT_SHORT ( p ) );\n+        apaint->u.scale.center_y = INT_TO_FIXED( FT_NEXT_SHORT ( p ) );\n+      }\n+      else\n+      {\n+        apaint->u.scale.center_x = 0;\n+        apaint->u.scale.center_y = 0;\n+      }\n+\n+      \/* FT 'COLR' v1 API output format always returns fully defined *\/\n+      \/* structs; we thus set the format to the public API value.    *\/\n+      apaint->format = FT_COLR_PAINTFORMAT_SCALE;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_ROTATE ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER )\n+    {\n+      apaint->u.rotate.paint.p                     = child_table_p;\n+      apaint->u.rotate.paint.insert_root_transform = 0;\n+\n+      apaint->u.rotate.angle = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+           FT_COLR_PAINTFORMAT_INTERNAL_ROTATE_CENTER )\n+      {\n+        apaint->u.rotate.center_x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+        apaint->u.rotate.center_y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      }\n+      else\n+      {\n+        apaint->u.rotate.center_x = 0;\n+        apaint->u.rotate.center_y = 0;\n+      }\n+\n+      apaint->format = FT_COLR_PAINTFORMAT_ROTATE;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_SKEW ||\n+              (FT_PaintFormat_Internal)apaint->format ==\n+                FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER )\n+    {\n+      apaint->u.skew.paint.p                     = child_table_p;\n+      apaint->u.skew.paint.insert_root_transform = 0;\n+\n+      apaint->u.skew.x_skew_angle = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      apaint->u.skew.y_skew_angle = F2DOT14_TO_FIXED( FT_NEXT_SHORT( p ) );\n+\n+      if ( (FT_PaintFormat_Internal)apaint->format ==\n+           FT_COLR_PAINTFORMAT_INTERNAL_SKEW_CENTER )\n+      {\n+        apaint->u.skew.center_x = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+        apaint->u.skew.center_y = INT_TO_FIXED( FT_NEXT_SHORT( p ) );\n+      }\n+      else\n+      {\n+        apaint->u.skew.center_x = 0;\n+        apaint->u.skew.center_y = 0;\n+      }\n+\n+      apaint->format = FT_COLR_PAINTFORMAT_SKEW;\n+\n+      return 1;\n+    }\n+\n+    else if ( apaint->format == FT_COLR_PAINTFORMAT_COMPOSITE )\n+    {\n+      FT_UInt  composite_mode;\n+\n+\n+      apaint->u.composite.source_paint.p                     = child_table_p;\n+      apaint->u.composite.source_paint.insert_root_transform = 0;\n+\n+      composite_mode = FT_NEXT_BYTE( p );\n+      if ( composite_mode >= FT_COLR_COMPOSITE_MAX )\n+        return 0;\n+\n+      apaint->u.composite.composite_mode = (FT_Composite_Mode)composite_mode;\n+\n+      if ( !get_child_table_pointer( colr, paint_base, &p, &child_table_p ) )\n+         return 0;\n+\n+      apaint->u.composite.backdrop_paint.p =\n+        child_table_p;\n+      apaint->u.composite.backdrop_paint.insert_root_transform =\n+        0;\n+\n+      return 1;\n+    }\n+\n+    return 0;\n+  }\n+\n+\n+  static FT_Bool\n+  find_base_glyph_v1_record( FT_Byte *           base_glyph_begin,\n+                             FT_UInt             num_base_glyph,\n+                             FT_UInt             glyph_id,\n+                             BaseGlyphV1Record  *record )\n+  {\n+    FT_UInt  min = 0;\n+    FT_UInt  max = num_base_glyph;\n+\n+\n+    while ( min < max )\n+    {\n+      FT_UInt  mid = min + ( max - min ) \/ 2;\n+\n+      \/*\n+       * `base_glyph_begin` is the beginning of `BaseGlyphV1List`;\n+       * skip `numBaseGlyphV1Records` by adding 4 to start binary search\n+       * in the array of `BaseGlyphV1Record`.\n+       *\/\n+      FT_Byte  *p = base_glyph_begin + 4 + mid * BASE_GLYPH_PAINT_RECORD_SIZE;\n+\n+      FT_UShort  gid = FT_NEXT_USHORT( p );\n+\n+\n+      if ( gid < glyph_id )\n+        min = mid + 1;\n+      else if (gid > glyph_id )\n+        max = mid;\n+      else\n+      {\n+        record->gid          = gid;\n+        record->paint_offset = FT_NEXT_ULONG ( p );\n+        return 1;\n+      }\n+    }\n+\n+    return 0;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_colr_glyph_paint( TT_Face                  face,\n+                                FT_UInt                  base_glyph,\n+                                FT_Color_Root_Transform  root_transform,\n+                                FT_OpaquePaint*          opaque_paint )\n+  {\n+    Colr*              colr = (Colr*)face->colr;\n+    BaseGlyphV1Record  base_glyph_v1_record;\n+    FT_Byte*           p;\n+\n+    if ( !colr || !colr->table )\n+      return 0;\n+\n+    if ( colr->version < 1 || !colr->num_base_glyphs_v1 ||\n+         !colr->base_glyphs_v1 )\n+      return 0;\n+\n+    if ( opaque_paint->p )\n+      return 0;\n+\n+    if ( !find_base_glyph_v1_record( colr->base_glyphs_v1,\n+                                     colr->num_base_glyphs_v1,\n+                                     base_glyph,\n+                                     &base_glyph_v1_record ) )\n+      return 0;\n+\n+    if ( !base_glyph_v1_record.paint_offset                   ||\n+         base_glyph_v1_record.paint_offset > colr->table_size )\n+      return 0;\n+\n+    p = (FT_Byte*)( colr->base_glyphs_v1 +\n+                    base_glyph_v1_record.paint_offset );\n+    if ( p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+      return 0;\n+\n+    opaque_paint->p = p;\n+\n+    if ( root_transform == FT_COLOR_INCLUDE_ROOT_TRANSFORM )\n+      opaque_paint->insert_root_transform = 1;\n+    else\n+      opaque_paint->insert_root_transform = 0;\n+\n+    return 1;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_color_glyph_clipbox( TT_Face      face,\n+                                   FT_UInt      base_glyph,\n+                                   FT_ClipBox*  clip_box )\n+  {\n+    Colr*  colr;\n+\n+    FT_Byte  *p, *p1, *clip_base, *limit;\n+\n+    FT_Byte    clip_list_format;\n+    FT_ULong   num_clip_boxes, i;\n+    FT_UShort  gid_start, gid_end;\n+    FT_UInt32  clip_box_offset;\n+    FT_Byte    format;\n+\n+    const FT_Byte  num_corners = 4;\n+    FT_Vector      corners[4];\n+    FT_Byte        j;\n+    FT_BBox        font_clip_box;\n+\n+\n+    colr = (Colr*)face->colr;\n+    if ( !colr )\n+      return 0;\n+\n+    if ( !colr->clip_list )\n+      return 0;\n+\n+    p = colr->clip_list;\n+\n+    \/* Limit points to the first byte after the end of the color table.    *\/\n+    \/* Thus, in subsequent limit checks below we need to check whether the *\/\n+    \/* read pointer is strictly greater than a position offset by certain  *\/\n+    \/* field sizes to the left of that position.                           *\/\n+    limit = (FT_Byte*)colr->table + colr->table_size;\n+\n+    \/* Check whether we can extract one `uint8` and one `uint32`. *\/\n+    if ( p > limit - ( 1 + 4 ) )\n+      return 0;\n+\n+    clip_base        = p;\n+    clip_list_format = FT_NEXT_BYTE ( p );\n+\n+    \/* Format byte used here to be able to upgrade ClipList for >16bit *\/\n+    \/* glyph ids; for now we can expect it to be 0.                    *\/\n+    if ( !( clip_list_format == 1 ) )\n+      return 0;\n+\n+    num_clip_boxes = FT_NEXT_ULONG( p );\n+\n+    \/* Check whether we can extract two `uint16` and one `Offset24`, *\/\n+    \/* `num_clip_boxes` times.                                       *\/\n+    if ( colr->table_size \/ ( 2 + 2 + 3 ) < num_clip_boxes ||\n+         p > limit - ( 2 + 2 + 3 ) * num_clip_boxes        )\n+      return 0;\n+\n+    for ( i = 0; i < num_clip_boxes; ++i )\n+    {\n+      gid_start       = FT_NEXT_USHORT( p );\n+      gid_end         = FT_NEXT_USHORT( p );\n+      clip_box_offset = FT_NEXT_UOFF3( p );\n+\n+      if ( base_glyph >= gid_start && base_glyph <= gid_end )\n+      {\n+        p1 = (FT_Byte*)( clip_base + clip_box_offset );\n+\n+        \/* Check whether we can extract one `uint8`. *\/\n+        if ( p1 > limit - 1 )\n+          return 0;\n+\n+        format = FT_NEXT_BYTE( p1 );\n+\n+        if ( format > 1 )\n+          return 0;\n+\n+        \/* Check whether we can extract four `FWORD`. *\/\n+        if ( p1 > limit - ( 2 + 2 + 2 + 2 ) )\n+          return 0;\n+\n+        \/* `face->root.size->metrics.x_scale` and `y_scale` are factors   *\/\n+        \/* that scale a font unit value in integers to a 26.6 fixed value *\/\n+        \/* according to the requested size, see for example               *\/\n+        \/* `ft_recompute_scaled_metrics`.                                 *\/\n+        font_clip_box.xMin = FT_MulFix( FT_NEXT_SHORT( p1 ),\n+                                        face->root.size->metrics.x_scale );\n+        font_clip_box.yMin = FT_MulFix( FT_NEXT_SHORT( p1 ),\n+                                        face->root.size->metrics.x_scale );\n+        font_clip_box.xMax = FT_MulFix( FT_NEXT_SHORT( p1 ),\n+                                        face->root.size->metrics.x_scale );\n+        font_clip_box.yMax = FT_MulFix( FT_NEXT_SHORT( p1 ),\n+                                        face->root.size->metrics.x_scale );\n+\n+        \/* Make 4 corner points (xMin, yMin), (xMax, yMax) and transform *\/\n+        \/* them.  If we we would only transform two corner points and    *\/\n+        \/* span a rectangle based on those, the rectangle may become too *\/\n+        \/* small to cover the glyph.                                     *\/\n+        corners[0].x = font_clip_box.xMin;\n+        corners[1].x = font_clip_box.xMin;\n+        corners[2].x = font_clip_box.xMax;\n+        corners[3].x = font_clip_box.xMax;\n+\n+        corners[0].y = font_clip_box.yMin;\n+        corners[1].y = font_clip_box.yMax;\n+        corners[2].y = font_clip_box.yMax;\n+        corners[3].y = font_clip_box.yMin;\n+\n+        for ( j = 0; j < num_corners; ++j )\n+        {\n+          if ( face->root.internal->transform_flags & 1 )\n+            FT_Vector_Transform( &corners[j],\n+                                 &face->root.internal->transform_matrix );\n+\n+          if ( face->root.internal->transform_flags & 2 )\n+          {\n+            corners[j].x += face->root.internal->transform_delta.x;\n+            corners[j].y += face->root.internal->transform_delta.y;\n+          }\n+        }\n+\n+        clip_box->bottom_left  = corners[0];\n+        clip_box->top_left     = corners[1];\n+        clip_box->top_right    = corners[2];\n+        clip_box->bottom_right = corners[3];\n+\n+        return 1;\n+      }\n+    }\n+\n+    return 0;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_paint_layers( TT_Face            face,\n+                            FT_LayerIterator*  iterator,\n+                            FT_OpaquePaint*    opaque_paint )\n+  {\n+    FT_Byte*   p             = NULL;\n+    FT_Byte*   p_first_layer = NULL;\n+    FT_Byte*   p_paint       = NULL;\n+    FT_UInt32  paint_offset;\n+\n+    Colr*  colr;\n+\n+\n+    if ( iterator->layer == iterator->num_layers )\n+      return 0;\n+\n+    colr = (Colr*)face->colr;\n+    if ( !colr )\n+      return 0;\n+\n+    \/*\n+     * We have an iterator pointing at a paint offset as part of the\n+     * `paintOffset` array in `LayerV1List`.\n+     *\/\n+    p = iterator->p;\n+\n+    \/*\n+     * First ensure that p is within COLRv1.\n+     *\/\n+    if ( p < colr->layers_v1                               ||\n+         p >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+      return 0;\n+\n+    \/*\n+     * Do a cursor sanity check of the iterator.  Counting backwards from\n+     * where it stands, we need to end up at a position after the beginning\n+     * of the `LayerV1List` table and not after the end of the\n+     * `LayerV1List`.\n+     *\/\n+    p_first_layer = p -\n+                      iterator->layer * LAYER_V1_LIST_PAINT_OFFSET_SIZE -\n+                      LAYER_V1_LIST_NUM_LAYERS_SIZE;\n+    if ( p_first_layer < (FT_Byte*)colr->layers_v1 )\n+      return 0;\n+    if ( p_first_layer >= (FT_Byte*)(\n+           colr->layers_v1 + LAYER_V1_LIST_NUM_LAYERS_SIZE +\n+           colr->num_layers_v1 * LAYER_V1_LIST_PAINT_OFFSET_SIZE ) )\n+      return 0;\n+\n+    paint_offset =\n+      FT_NEXT_ULONG( p );\n+    opaque_paint->insert_root_transform =\n+      0;\n+\n+    p_paint = (FT_Byte*)( colr->layers_v1 + paint_offset );\n+\n+    if ( p_paint < colr->paints_start_v1                         ||\n+         p_paint >= ( (FT_Byte*)colr->table + colr->table_size ) )\n+      return 0;\n+\n+    opaque_paint->p = p_paint;\n+\n+    iterator->p = p;\n+\n+    iterator->layer++;\n+\n+    return 1;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_colorline_stops( TT_Face                face,\n+                               FT_ColorStop*          color_stop,\n+                               FT_ColorStopIterator  *iterator )\n+  {\n+    Colr*  colr = (Colr*)face->colr;\n+\n+    FT_Byte*  p;\n+\n+\n+    if ( !colr || !colr->table )\n+      return 0;\n+\n+    if ( iterator->current_color_stop >= iterator->num_color_stops )\n+      return 0;\n+\n+    if ( iterator->p +\n+           ( ( iterator->num_color_stops - iterator->current_color_stop ) *\n+             COLOR_STOP_SIZE ) >\n+         ( (FT_Byte *)colr->table + colr->table_size ) )\n+      return 0;\n+\n+    \/* Iterator points at first `ColorStop` of `ColorLine`. *\/\n+    p = iterator->p;\n+\n+    color_stop->stop_offset = FT_NEXT_SHORT( p );\n+\n+    color_stop->color.palette_index = FT_NEXT_USHORT( p );\n+\n+    color_stop->color.alpha = FT_NEXT_SHORT( p );\n+\n+    iterator->p = p;\n+    iterator->current_color_stop++;\n+\n+    return 1;\n+  }\n+\n+\n+  FT_LOCAL_DEF( FT_Bool )\n+  tt_face_get_paint( TT_Face         face,\n+                     FT_OpaquePaint  opaque_paint,\n+                     FT_COLR_Paint*  paint )\n+  {\n+    Colr*           colr = (Colr*)face->colr;\n+    FT_OpaquePaint  next_paint;\n+    FT_Matrix       ft_root_scale;\n+\n+    if ( !colr || !colr->base_glyphs_v1 || !colr->table )\n+      return 0;\n+\n+    if ( opaque_paint.insert_root_transform )\n+    {\n+      \/* 'COLR' v1 glyph information is returned in unscaled coordinates,\n+       * i.e., `FT_Size` is not applied or multiplied into the values.  When\n+       * client applications draw color glyphs, they can request to include\n+       * a top-level transform, which includes the active `x_scale` and\n+       * `y_scale` information for scaling the glyph, as well the additional\n+       * transform and translate configured through `FT_Set_Transform`.\n+       * This allows client applications to apply this top-level transform\n+       * to the graphics context first and only once, then have gradient and\n+       * contour scaling applied correctly when performing the additional\n+       * drawing operations for subsequenct paints.  Prepare this initial\n+       * transform here.\n+       *\/\n+      paint->format = FT_COLR_PAINTFORMAT_TRANSFORM;\n+\n+      next_paint.p                     = opaque_paint.p;\n+      next_paint.insert_root_transform = 0;\n+      paint->u.transform.paint         = next_paint;\n+\n+      \/* `x_scale` and `y_scale` are in 26.6 format, representing the scale\n+       * factor to get from font units to requested size.  However, expected\n+       * return values are in 16.16, so we shift accordingly with rounding.\n+       *\/\n+      ft_root_scale.xx = ( face->root.size->metrics.x_scale + 32 ) >> 6;\n+      ft_root_scale.xy = 0;\n+      ft_root_scale.yx = 0;\n+      ft_root_scale.yy = ( face->root.size->metrics.y_scale + 32 ) >> 6;\n+\n+      if ( face->root.internal->transform_flags & 1 )\n+        FT_Matrix_Multiply( &face->root.internal->transform_matrix,\n+                            &ft_root_scale );\n+\n+      paint->u.transform.affine.xx = ft_root_scale.xx;\n+      paint->u.transform.affine.xy = ft_root_scale.xy;\n+      paint->u.transform.affine.yx = ft_root_scale.yx;\n+      paint->u.transform.affine.yy = ft_root_scale.yy;\n+\n+      \/* The translation is specified in 26.6 format and, according to the\n+       * documentation of `FT_Set_Translate`, is performed on the character\n+       * size given in the last call to `FT_Set_Char_Size`.  The\n+       * 'PaintTransform' paint table's `FT_Affine23` format expects\n+       * values in 16.16 format, thus we need to shift by 10 bits.\n+       *\/\n+      if ( face->root.internal->transform_flags & 2 )\n+      {\n+        paint->u.transform.affine.dx =\n+          face->root.internal->transform_delta.x * ( 1 << 10 );\n+        paint->u.transform.affine.dy =\n+          face->root.internal->transform_delta.y * ( 1 << 10 );\n+      }\n+      else\n+      {\n+        paint->u.transform.affine.dx = 0;\n+        paint->u.transform.affine.dy = 0;\n+      }\n+\n+      return 1;\n+    }\n+\n+    return read_paint( colr, opaque_paint.p, paint );\n+  }\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcolr.c","additions":893,"deletions":15,"binary":false,"changes":908,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2020 by\n+ * Copyright (C) 2018-2022 by\n@@ -45,0 +45,26 @@\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_colr_glyph_paint( TT_Face                  face,\n+                                FT_UInt                  base_glyph,\n+                                FT_Color_Root_Transform  root_transform,\n+                                FT_OpaquePaint*          paint );\n+\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_color_glyph_clipbox( TT_Face      face,\n+                                   FT_UInt      base_glyph,\n+                                   FT_ClipBox*  clip_box );\n+\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_paint_layers( TT_Face            face,\n+                            FT_LayerIterator*  iterator,\n+                            FT_OpaquePaint*    paint );\n+\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_colorline_stops( TT_Face                face,\n+                               FT_ColorStop*          color_stop,\n+                               FT_ColorStopIterator*  iterator );\n+\n+  FT_LOCAL( FT_Bool )\n+  tt_face_get_paint( TT_Face         face,\n+                     FT_OpaquePaint  opaque_paint,\n+                     FT_COLR_Paint*  paint );\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcolr.h","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2020 by\n+ * Copyright (C) 2018-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcpal.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2018-2020 by\n+ * Copyright (C) 2018-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttcpal.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -97,1 +97,1 @@\n-      p += 2; \/* skip version *\/\n+      p       += 2; \/* skip version *\/\n@@ -147,1 +147,1 @@\n-          if ( cur_pair <= old_pair )\n+          if ( cur_pair < old_pair )\n@@ -190,4 +190,2 @@\n-    FT_Int    result = 0;\n-    FT_UInt   count, mask;\n-    FT_Byte*  p       = face->kern_table;\n-    FT_Byte*  p_limit = p + face->kern_table_size;\n+    FT_Int   result = 0;\n+    FT_UInt  count, mask;\n@@ -195,0 +193,9 @@\n+    FT_Byte*  p;\n+    FT_Byte*  p_limit;\n+\n+\n+    if ( !face->kern_table )\n+      return result;\n+\n+    p       = face->kern_table;\n+    p_limit = p + face->kern_table_size;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttkern.c","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttkern.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -208,1 +208,0 @@\n-        nn--;\n@@ -419,3 +418,3 @@\n-    FT_TRACE2(( \"\\n\"\n-                \"  tag    offset    length   checksum\\n\"\n-                \"  ----------------------------------\\n\" ));\n+    FT_TRACE2(( \"\\n\" ));\n+    FT_TRACE2(( \"  tag    offset    length   checksum\\n\" ));\n+    FT_TRACE2(( \"  ----------------------------------\\n\" ));\n@@ -508,1 +507,2 @@\n-    FT_TRACE2(( \"table directory loaded\\n\\n\" ));\n+    FT_TRACE2(( \"table directory loaded\\n\" ));\n+    FT_TRACE2(( \"\\n\" ));\n@@ -797,2 +797,2 @@\n-                    \" too much twilight points in `maxp' table;\\n\"\n-                    \"                  \"\n+                    \" too much twilight points in `maxp' table;\\n\" ));\n+        FT_TRACE0(( \"                  \"\n@@ -839,0 +839,2 @@\n+    TT_Name       names    = NULL;\n+    TT_LangTag    langTags = NULL;\n@@ -919,2 +921,2 @@\n-      if ( FT_NEW_ARRAY( table->langTags, table->numLangTagRecords ) ||\n-           FT_FRAME_ENTER( table->numLangTagRecords * 4 )            )\n+      if ( FT_QNEW_ARRAY( langTags, table->numLangTagRecords ) ||\n+           FT_FRAME_ENTER( table->numLangTagRecords * 4 )      )\n@@ -925,1 +927,1 @@\n-        TT_LangTag  entry = table->langTags;\n+        TT_LangTag  entry = langTags;\n@@ -941,0 +943,3 @@\n+\n+          \/* mark the string as not yet loaded *\/\n+          entry->string = NULL;\n@@ -942,0 +947,3 @@\n+\n+        table->langTags = langTags;\n+        langTags        = NULL;\n@@ -950,2 +958,2 @@\n-    if ( FT_NEW_ARRAY( table->names, table->numNameRecords ) ||\n-         FT_FRAME_ENTER( table->numNameRecords * 12 )        )\n+    if ( FT_QNEW_ARRAY( names, table->numNameRecords ) ||\n+         FT_FRAME_ENTER( table->numNameRecords * 12 )  )\n@@ -956,1 +964,1 @@\n-      TT_Name  entry = table->names;\n+      TT_Name  entry = names;\n@@ -958,0 +966,1 @@\n+      FT_UInt  valid = 0;\n@@ -990,0 +999,4 @@\n+        \/* mark the string as not yet converted *\/\n+        entry->string = NULL;\n+\n+        valid++;\n@@ -994,5 +1007,6 @@\n-      count = (FT_UInt)( entry - table->names );\n-      (void)FT_RENEW_ARRAY( table->names,\n-                            table->numNameRecords,\n-                            count );\n-      table->numNameRecords = count;\n+      FT_MEM_QRENEW_ARRAY( names,\n+                           table->numNameRecords,\n+                           valid );\n+      table->names          = names;\n+      names                 = NULL;\n+      table->numNameRecords = valid;\n@@ -1007,0 +1021,2 @@\n+    FT_FREE( names );\n+    FT_FREE( langTags );\n@@ -1314,0 +1330,6 @@\n+    if ( post->FormatType != 0x00030000L &&\n+         post->FormatType != 0x00025000L &&\n+         post->FormatType != 0x00020000L &&\n+         post->FormatType != 0x00010000L )\n+      return FT_THROW( Invalid_Post_Table_Format );\n+\n@@ -1413,2 +1435,2 @@\n-    FT_UInt        j,num_ranges;\n-    TT_GaspRange   gaspranges = NULL;\n+    FT_UShort      j, num_ranges;\n+    TT_GaspRange   gasp_ranges = NULL;\n@@ -1425,2 +1447,2 @@\n-    face->gasp.version   = FT_GET_USHORT();\n-    face->gasp.numRanges = FT_GET_USHORT();\n+    face->gasp.version = FT_GET_USHORT();\n+    num_ranges         = FT_GET_USHORT();\n@@ -1438,2 +1460,1 @@\n-    num_ranges = face->gasp.numRanges;\n-    FT_TRACE3(( \"numRanges: %u\\n\", num_ranges ));\n+    FT_TRACE3(( \"numRanges: %hu\\n\", num_ranges ));\n@@ -1441,2 +1462,2 @@\n-    if ( FT_QNEW_ARRAY( face->gasp.gaspRanges, num_ranges ) ||\n-         FT_FRAME_ENTER( num_ranges * 4L )                  )\n+    if ( FT_QNEW_ARRAY( gasp_ranges, num_ranges ) ||\n+         FT_FRAME_ENTER( num_ranges * 4L )        )\n@@ -1445,2 +1466,0 @@\n-    gaspranges = face->gasp.gaspRanges;\n-\n@@ -1449,2 +1468,2 @@\n-      gaspranges[j].maxPPEM  = FT_GET_USHORT();\n-      gaspranges[j].gaspFlag = FT_GET_USHORT();\n+      gasp_ranges[j].maxPPEM  = FT_GET_USHORT();\n+      gasp_ranges[j].gaspFlag = FT_GET_USHORT();\n@@ -1454,2 +1473,2 @@\n-                  gaspranges[j].maxPPEM,\n-                  gaspranges[j].gaspFlag ));\n+                  gasp_ranges[j].maxPPEM,\n+                  gasp_ranges[j].gaspFlag ));\n@@ -1458,0 +1477,4 @@\n+    face->gasp.gaspRanges = gasp_ranges;\n+    gasp_ranges           = NULL;\n+    face->gasp.numRanges  = num_ranges;\n+\n@@ -1461,0 +1484,1 @@\n+    FT_FREE( gasp_ranges );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttload.c","additions":57,"deletions":33,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttmtx.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2006-2020 by\n+ * Copyright (C) 2006-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttmtx.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -161,1 +161,1 @@\n-                  FT_ULong   post_limit )\n+                  FT_ULong   post_len )\n@@ -171,0 +171,1 @@\n+    FT_Byte*    strings       = NULL;\n@@ -182,1 +183,2 @@\n-    if ( num_glyphs > face->max_profile.numGlyphs )\n+    if ( num_glyphs > face->max_profile.numGlyphs  ||\n+         (FT_ULong)num_glyphs * 2UL > post_len - 2 )\n@@ -193,1 +195,1 @@\n-      if ( FT_NEW_ARRAY ( glyph_indices, num_glyphs ) ||\n+      if ( FT_QNEW_ARRAY( glyph_indices, num_glyphs ) ||\n@@ -226,0 +228,1 @@\n+    if ( num_names )\n@@ -228,0 +231,1 @@\n+      FT_ULong   p;\n@@ -230,1 +234,5 @@\n-      if ( FT_NEW_ARRAY( name_strings, num_names ) )\n+      post_len -= (FT_ULong)num_glyphs * 2UL + 2;\n+\n+      if ( FT_QALLOC( strings, post_len + 1 )       ||\n+           FT_STREAM_READ( strings, post_len )      ||\n+           FT_QNEW_ARRAY( name_strings, num_names ) )\n@@ -233,1 +241,2 @@\n-      for ( n = 0; n < num_names; n++ )\n+      \/* convert from Pascal- to C-strings and set pointers *\/\n+      for ( p = 0, n = 0; p < post_len && n < num_names; n++ )\n@@ -235,9 +244,1 @@\n-        FT_UInt  len;\n-\n-\n-        if ( FT_STREAM_POS() >= post_limit )\n-          break;\n-        else\n-        {\n-          FT_TRACE6(( \"load_format_20: %ld byte left in post table\\n\",\n-                      post_limit - FT_STREAM_POS() ));\n+        FT_UInt  len = strings[p];\n@@ -245,3 +246,0 @@\n-          if ( FT_READ_BYTE( len ) )\n-            goto Fail1;\n-        }\n@@ -249,2 +247,1 @@\n-        if ( len > post_limit                   ||\n-             FT_STREAM_POS() > post_limit - len )\n+        if ( len > 63U )\n@@ -252,8 +249,2 @@\n-          FT_Int  d = (FT_Int)post_limit - (FT_Int)FT_STREAM_POS();\n-\n-\n-          FT_ERROR(( \"load_format_20:\"\n-                     \" exceeding string length (%d),\"\n-                     \" truncating at end of post table (%d byte left)\\n\",\n-                     len, d ));\n-          len = (FT_UInt)FT_MAX( 0, d );\n+          error = FT_THROW( Invalid_File_Format );\n+          goto Fail;\n@@ -262,5 +253,3 @@\n-        if ( FT_NEW_ARRAY( name_strings[n], len + 1 ) ||\n-             FT_STREAM_READ( name_strings[n], len   ) )\n-          goto Fail1;\n-\n-        name_strings[n][len] = '\\0';\n+        strings[p]      = 0;\n+        name_strings[n] = (FT_Char*)strings + p + 1;\n+        p              += len + 1;\n@@ -268,0 +257,1 @@\n+      strings[post_len] = 0;\n@@ -269,0 +259,1 @@\n+      \/* deal with missing or insufficient string data *\/\n@@ -271,0 +262,10 @@\n+        if ( post_len == 0 )\n+        {\n+          \/* fake empty string *\/\n+          if ( FT_QREALLOC( strings, 1, 2 ) )\n+            goto Fail;\n+\n+          post_len          = 1;\n+          strings[post_len] = 0;\n+        }\n+\n@@ -276,4 +277,1 @@\n-          if ( FT_NEW_ARRAY( name_strings[n], 1 ) )\n-            goto Fail1;\n-          else\n-            name_strings[n][0] = '\\0';\n+          name_strings[n] = (FT_Char*)strings + post_len;\n@@ -295,9 +293,0 @@\n-  Fail1:\n-    {\n-      FT_UShort  n;\n-\n-\n-      for ( n = 0; n < num_names; n++ )\n-        FT_FREE( name_strings[n] );\n-    }\n-\n@@ -306,0 +295,1 @@\n+    FT_FREE( strings );\n@@ -316,1 +306,1 @@\n-                  FT_ULong   post_limit )\n+                  FT_ULong   post_len )\n@@ -324,1 +314,1 @@\n-    FT_UNUSED( post_limit );\n+    FT_UNUSED( post_len );\n@@ -339,1 +329,1 @@\n-    if ( FT_NEW_ARRAY( offset_table, num_glyphs )   ||\n+    if ( FT_QNEW_ARRAY( offset_table, num_glyphs )  ||\n@@ -387,1 +377,0 @@\n-    FT_ULong   post_limit;\n@@ -398,2 +387,0 @@\n-    post_limit = FT_STREAM_POS() + post_len;\n-\n@@ -407,4 +394,4 @@\n-    if ( format == 0x00020000L )\n-      error = load_format_20( face, stream, post_limit );\n-    else if ( format == 0x00025000L )\n-      error = load_format_25( face, stream, post_limit );\n+    if ( format == 0x00020000L && post_len >= 34 )\n+      error = load_format_20( face, stream, post_len - 32 );\n+    else if ( format == 0x00025000L && post_len >= 34 )\n+      error = load_format_25( face, stream, post_len - 32 );\n@@ -436,1 +423,0 @@\n-        FT_UShort   n;\n@@ -442,2 +428,4 @@\n-        for ( n = 0; n < table->num_names; n++ )\n-          FT_FREE( table->glyph_names[n] );\n+        if ( table->num_names )\n+        {\n+          table->glyph_names[0]--;\n+          FT_FREE( table->glyph_names[0] );\n@@ -445,2 +433,3 @@\n-        FT_FREE( table->glyph_names );\n-        table->num_names = 0;\n+          FT_FREE( table->glyph_names );\n+          table->num_names = 0;\n+        }\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttpost.c","additions":50,"deletions":61,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttpost.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2005-2020 by\n+ * Copyright (C) 2005-2022 by\n@@ -175,2 +175,0 @@\n-        \/* we currently don't support bit 1; however, it is better to *\/\n-        \/* draw at least something...                                 *\/\n@@ -178,4 +176,1 @@\n-          FT_TRACE1(( \"tt_face_load_sbit_strikes:\"\n-                      \" sbix overlay not supported yet\\n\"\n-                      \"                          \"\n-                      \" expect bad rendering results\\n\" ));\n+          face->root.face_flags |= FT_FACE_FLAG_SBIX_OVERLAY;\n@@ -243,2 +238,2 @@\n-                  \" no embedded bitmap data table found;\\n\"\n-                  \"                          \"\n+                  \" no embedded bitmap data table found;\\n\" ));\n+      FT_TRACE2(( \"                          \"\n@@ -348,2 +343,2 @@\n-                        \" sanitizing invalid ascender and descender\\n\"\n-                        \"                            \"\n+                        \" sanitizing invalid ascender and descender\\n\" ));\n+            FT_TRACE2(( \"                            \"\n@@ -377,2 +372,2 @@\n-                      \" sanitizing invalid height value\\n\"\n-                      \"                            \"\n+                      \" sanitizing invalid height value\\n\" ));\n+          FT_TRACE2(( \"                            \"\n@@ -729,0 +724,3 @@\n+    if ( !line )\n+      goto Exit;\n+\n@@ -1576,1 +1574,1 @@\n-      FT_Short   abearing;\n+      FT_Short   abearing; \/* not used here *\/\n@@ -1583,1 +1581,5 @@\n-      metrics->horiBearingY = (FT_Short)( -originOffsetY + metrics->height );\n+      metrics->vertBearingX = (FT_Short)originOffsetX;\n+\n+      metrics->horiBearingY = (FT_Short)( originOffsetY + metrics->height );\n+      metrics->vertBearingY = (FT_Short)originOffsetY;\n+\n@@ -1587,0 +1589,13 @@\n+\n+      if ( face->vertical_info )\n+        tt_face_get_metrics( face, TRUE, glyph_index, &abearing, &aadvance );\n+      else if ( face->os2.version != 0xFFFFU )\n+        aadvance = (FT_UShort)FT_ABS( face->os2.sTypoAscender -\n+                                      face->os2.sTypoDescender );\n+      else\n+        aadvance = (FT_UShort)FT_ABS( face->horizontal.Ascender -\n+                                      face->horizontal.Descender );\n+\n+      metrics->vertAdvance  = (FT_UShort)( aadvance *\n+                                           face->root.size->metrics.x_ppem \/\n+                                           face->header.Units_Per_EM );\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttsbit.c","additions":30,"deletions":15,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/ttsbit.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2020 by\n+ * Copyright (C) 2019-2022 by\n@@ -20,0 +20,3 @@\n+\n+#ifdef FT_CONFIG_OPTION_USE_BROTLI\n+\n@@ -31,1 +34,1 @@\n-  FT_LOCAL_DEF( FT_ULong )\n+  FT_LOCAL_DEF( FT_Tag )\n@@ -34,1 +37,1 @@\n-    const FT_ULong  known_tags[63] =\n+    static const FT_Tag  known_tags[63] =\n@@ -108,0 +111,7 @@\n+#else \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n+\n+  \/* ANSI C doesn't like empty source files *\/\n+  typedef int  _woff2tags_dummy;\n+\n+#endif \/* !FT_CONFIG_OPTION_USE_BROTLI *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/woff2tags.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- *   WOFFF2 Font table tags (specification).\n+ *   WOFF2 Font table tags (specification).\n@@ -7,1 +7,1 @@\n- * Copyright (C) 2019-2020 by\n+ * Copyright (C) 2019-2022 by\n@@ -29,0 +29,1 @@\n+#ifdef FT_CONFIG_OPTION_USE_BROTLI\n@@ -30,1 +31,1 @@\n-  FT_LOCAL( FT_ULong )\n+  FT_LOCAL( FT_Tag )\n@@ -33,0 +34,1 @@\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/sfnt\/woff2tags.h","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2022 by\n@@ -152,8 +152,4 @@\n-#define ADD_LONG( a, b )                                    \\\n-          (long)( (unsigned long)(a) + (unsigned long)(b) )\n-#define SUB_LONG( a, b )                                    \\\n-          (long)( (unsigned long)(a) - (unsigned long)(b) )\n-#define MUL_LONG( a, b )                                    \\\n-          (long)( (unsigned long)(a) * (unsigned long)(b) )\n-#define NEG_LONG( a )                                       \\\n-          (long)( -(unsigned long)(a) )\n+#define ADD_INT( a, b )                                  \\\n+          (int)( (unsigned int)(a) + (unsigned int)(b) )\n+\n+#define FT_STATIC_BYTE_CAST( type, var )  (type)(unsigned char)(var)\n@@ -171,4 +167,5 @@\n-#define ErrRaster_Invalid_Mode      -2\n-#define ErrRaster_Invalid_Outline   -1\n-#define ErrRaster_Invalid_Argument  -3\n-#define ErrRaster_Memory_Overflow   -4\n+#define Smooth_Err_Ok                    0\n+#define Smooth_Err_Invalid_Outline      -1\n+#define Smooth_Err_Cannot_Render_Glyph  -2\n+#define Smooth_Err_Invalid_Argument     -3\n+#define Smooth_Err_Raster_Overflow      -4\n@@ -232,5 +229,5 @@\n-#define FT_THROW( e )                               \\\n-          ( FT_Throw( FT_ERR_CAT( ErrRaster_, e ),  \\\n-                      __LINE__,                     \\\n-                      __FILE__ )                  | \\\n-            FT_ERR_CAT( ErrRaster_, e )           )\n+#define FT_THROW( e )                                \\\n+          ( FT_Throw( FT_ERR_CAT( Smooth_Err_, e ),  \\\n+                      __LINE__,                      \\\n+                      __FILE__ )                   | \\\n+            FT_ERR_CAT( Smooth_Err_, e )           )\n@@ -243,2 +240,1 @@\n-#define FT_THROW( e )   FT_ERR_CAT( ErrRaster_, e )\n-\n+#define FT_THROW( e )   FT_ERR_CAT( Smooth_Err_, e )\n@@ -249,0 +245,4 @@\n+#define FT_Trace_Enable()   do { } while ( 0 )  \/* nothing *\/\n+#define FT_Trace_Disable()  do { } while ( 0 )  \/* nothing *\/\n+\n+\n@@ -281,0 +281,2 @@\n+#include <ft2build.h>\n+#include FT_CONFIG_CONFIG_H\n@@ -289,4 +291,0 @@\n-#define Smooth_Err_Invalid_Mode     Smooth_Err_Cannot_Render_Glyph\n-#define Smooth_Err_Memory_Overflow  Smooth_Err_Out_Of_Memory\n-#define ErrRaster_Memory_Overflow   Smooth_Err_Out_Of_Memory\n-\n@@ -338,0 +336,1 @@\n+#undef TRUNC\n@@ -339,0 +338,1 @@\n+#undef FRACT\n@@ -365,1 +365,1 @@\n-#ifdef  __arm__\n+#if defined( __GNUC__ ) && __GNUC__ < 7 && defined( __arm__ )\n@@ -385,8 +385,52 @@\n-  \/* These macros speed up repetitive divisions by replacing them *\/\n-  \/* with multiplications and right shifts.                       *\/\n-#define FT_UDIVPREP( c, b )                                        \\\n-  long  b ## _r = c ? (long)( FT_ULONG_MAX >> PIXEL_BITS ) \/ ( b ) \\\n-                    : 0\n-#define FT_UDIV( a, b )                                                \\\n-  (TCoord)( ( (unsigned long)( a ) * (unsigned long)( b ## _r ) ) >>   \\\n-            ( sizeof( long ) * FT_CHAR_BIT - PIXEL_BITS ) )\n+  \/* Calculating coverages for a slanted line requires a division each *\/\n+  \/* time the line crosses from cell to cell.  These macros speed up   *\/\n+  \/* the repetitive divisions by replacing them with multiplications   *\/\n+  \/* and right shifts so that at most two divisions are performed for  *\/\n+  \/* each slanted line.  Nevertheless, these divisions are noticeable  *\/\n+  \/* in the overall performance because flattened curves produce a     *\/\n+  \/* very large number of slanted lines.                               *\/\n+  \/*                                                                   *\/\n+  \/* The division results here are always within ONE_PIXEL.  Therefore *\/\n+  \/* the shift magnitude should be at least PIXEL_BITS wider than the  *\/\n+  \/* divisors to provide sufficient accuracy of the multiply-shift.    *\/\n+  \/* It should not exceed (64 - PIXEL_BITS) to prevent overflowing and *\/\n+  \/* leave enough room for 64-bit unsigned multiplication however.     *\/\n+#define FT_UDIVPREP( c, b )                                \\\n+  FT_Int64  b ## _r = c ? (FT_Int64)0xFFFFFFFF \/ ( b ) : 0\n+#define FT_UDIV( a, b )                                           \\\n+  (TCoord)( ( (FT_UInt64)( a ) * (FT_UInt64)( b ## _r ) ) >> 32 )\n+\n+\n+  \/* Scale area and apply fill rule to calculate the coverage byte. *\/\n+  \/* The top fill bit is used for the non-zero rule. The eighth     *\/\n+  \/* fill bit is used for the even-odd rule.  The higher coverage   *\/\n+  \/* bytes are either clamped for the non-zero-rule or discarded    *\/\n+  \/* later for the even-odd rule.                                   *\/\n+#define FT_FILL_RULE( coverage, area, fill )                \\\n+  FT_BEGIN_STMNT                                            \\\n+    coverage = (int)( area >> ( PIXEL_BITS * 2 + 1 - 8 ) ); \\\n+    if ( coverage & fill )                                  \\\n+      coverage = ~coverage;                                 \\\n+    if ( coverage > 255 && fill & INT_MIN )                 \\\n+      coverage = 255;                                       \\\n+  FT_END_STMNT\n+\n+\n+  \/* It is faster to write small spans byte-by-byte than calling     *\/\n+  \/* `memset'.  This is mainly due to the cost of the function call. *\/\n+#define FT_GRAY_SET( d, s, count )                          \\\n+  FT_BEGIN_STMNT                                            \\\n+    unsigned char* q = d;                                   \\\n+    switch ( count )                                        \\\n+    {                                                       \\\n+      case 7: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 6: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 5: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 4: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 3: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 2: *q++ = (unsigned char)s; \/* fall through *\/   \\\n+      case 1: *q   = (unsigned char)s; \/* fall through *\/   \\\n+      case 0: break;                                        \\\n+      default: FT_MEM_SET( d, s, count );                   \\\n+    }                                                       \\\n+  FT_END_STMNT\n@@ -435,1 +479,1 @@\n-#define FT_MAX_GRAY_SPANS  10\n+#define FT_MAX_GRAY_SPANS  16\n@@ -450,2 +494,1 @@\n-    TCoord  ex, ey;\n-    TCoord  min_ex, max_ex;\n+    TCoord  min_ex, max_ex;  \/* min and max integer pixel coordinates *\/\n@@ -453,0 +496,1 @@\n+    TCoord  count_ey;        \/* same as (max_ey - min_ey) *\/\n@@ -454,3 +498,3 @@\n-    TArea   area;\n-    TCoord  cover;\n-    int     invalid;\n+    PCell       cell;        \/* current cell                             *\/\n+    PCell       cell_free;   \/* call allocation next free slot           *\/\n+    PCell       cell_null;   \/* last cell, used as dumpster and limit    *\/\n@@ -458,4 +502,2 @@\n-    PCell*      ycells;\n-    PCell       cells;\n-    FT_PtrDist  max_cells;\n-    FT_PtrDist  num_cells;\n+    PCell*      ycells;      \/* array of cell linked-lists; one per      *\/\n+                             \/* vertical coordinate in the current band  *\/\n@@ -463,1 +505,1 @@\n-    TPos    x,  y;\n+    TPos        x,  y;       \/* last point position *\/\n@@ -465,2 +507,2 @@\n-    FT_Outline  outline;\n-    TPixmap     target;\n+    FT_Outline  outline;     \/* input outline *\/\n+    TPixmap     target;      \/* target pixmap *\/\n@@ -470,2 +512,0 @@\n-    FT_Span              spans[FT_MAX_GRAY_SPANS];\n-    int                  num_spans;\n@@ -479,1 +519,0 @@\n-\n@@ -486,0 +525,9 @@\n+  \/* The |x| value of the null cell.  Must be the largest possible *\/\n+  \/* integer value stored in a `TCell.x` field.                    *\/\n+#define CELL_MAX_X_VALUE    INT_MAX\n+\n+\n+#define FT_INTEGRATE( ras, a, b )                                       \\\n+          ras.cell->cover = ADD_INT( ras.cell->cover, a ),              \\\n+          ras.cell->area  = ADD_INT( ras.cell->area, (a) * (TArea)(b) )\n+\n@@ -489,1 +537,1 @@\n-    void*         memory;\n+    void*  memory;\n@@ -511,1 +559,1 @@\n-      for ( ; cell != NULL; cell = cell->next )\n+      for ( ; cell != ras.cell_null; cell = cell->next )\n@@ -523,1 +571,1 @@\n-   * Record the current cell in the linked list.\n+   * Set the current cell to a new position.\n@@ -526,1 +574,2 @@\n-  gray_record_cell( RAS_ARG )\n+  gray_set_cell( RAS_ARG_ TCoord  ex,\n+                          TCoord  ey )\n@@ -528,3 +577,9 @@\n-    PCell  *pcell, cell;\n-    TCoord  x = ras.ex;\n-\n+    \/* Move the cell pointer to a new position in the linked list. We use  *\/\n+    \/* a dumpster null cell for everything outside of the clipping region  *\/\n+    \/* during the render phase.  This means that:                          *\/\n+    \/*                                                                     *\/\n+    \/* . the new vertical position must be within min_ey..max_ey-1.        *\/\n+    \/* . the new horizontal position must be strictly less than max_ex     *\/\n+    \/*                                                                     *\/\n+    \/* Note that if a cell is to the left of the clipping region, it is    *\/\n+    \/* actually set to the (min_ex-1) horizontal position.                 *\/\n@@ -532,5 +587,1 @@\n-    pcell = &ras.ycells[ras.ey - ras.min_ey];\n-    while ( ( cell = *pcell ) )\n-    {\n-      if ( cell->x > x )\n-        break;\n+    TCoord  ey_index = ey - ras.min_ey;\n@@ -538,2 +589,0 @@\n-      if ( cell->x == x )\n-        goto Found;\n@@ -541,2 +590,6 @@\n-      pcell = &cell->next;\n-    }\n+    if ( ey_index < 0 || ey_index >= ras.count_ey || ex >= ras.max_ex )\n+      ras.cell = ras.cell_null;\n+    else\n+    {\n+      PCell*  pcell = ras.ycells + ey_index;\n+      PCell   cell;\n@@ -544,2 +597,0 @@\n-    if ( ras.num_cells >= ras.max_cells )\n-      ft_longjmp( ras.jump_buffer, 1 );\n@@ -547,5 +598,1 @@\n-    \/* insert new cell *\/\n-    cell        = ras.cells + ras.num_cells++;\n-    cell->x     = x;\n-    cell->area  = ras.area;\n-    cell->cover = ras.cover;\n+      ex = FT_MAX( ex, ras.min_ex - 1 );\n@@ -553,2 +600,3 @@\n-    cell->next  = *pcell;\n-    *pcell      = cell;\n+      while ( 1 )\n+      {\n+        cell = *pcell;\n@@ -556,1 +604,2 @@\n-    return;\n+        if ( cell->x > ex )\n+          break;\n@@ -558,5 +607,2 @@\n-  Found:\n-    \/* update old cell *\/\n-    cell->area  += ras.area;\n-    cell->cover += ras.cover;\n-  }\n+        if ( cell->x == ex )\n+          goto Found;\n@@ -564,0 +610,2 @@\n+        pcell = &cell->next;\n+      }\n@@ -565,17 +613,4 @@\n-  \/**************************************************************************\n-   *\n-   * Set the current cell to a new position.\n-   *\/\n-  static void\n-  gray_set_cell( RAS_ARG_ TCoord  ex,\n-                          TCoord  ey )\n-  {\n-    \/* Move the cell pointer to a new position.  We set the `invalid'      *\/\n-    \/* flag to indicate that the cell isn't part of those we're interested *\/\n-    \/* in during the render phase.  This means that:                       *\/\n-    \/*                                                                     *\/\n-    \/* . the new vertical position must be within min_ey..max_ey-1.        *\/\n-    \/* . the new horizontal position must be strictly less than max_ex     *\/\n-    \/*                                                                     *\/\n-    \/* Note that if a cell is to the left of the clipping region, it is    *\/\n-    \/* actually set to the (min_ex-1) horizontal position.                 *\/\n+      \/* insert new cell *\/\n+      cell = ras.cell_free++;\n+      if ( cell >= ras.cell_null )\n+        ft_longjmp( ras.jump_buffer, 1 );\n@@ -583,3 +618,3 @@\n-    \/* record the current one if it is valid and substantial *\/\n-    if ( !ras.invalid && ( ras.area || ras.cover ) )\n-      gray_record_cell( RAS_VAR );\n+      cell->x     = ex;\n+      cell->area  = 0;\n+      cell->cover = 0;\n@@ -587,4 +622,2 @@\n-    ras.area  = 0;\n-    ras.cover = 0;\n-    ras.ex    = FT_MAX( ex, ras.min_ex - 1 );\n-    ras.ey    = ey;\n+      cell->next  = *pcell;\n+      *pcell      = cell;\n@@ -592,2 +625,3 @@\n-    ras.invalid = ( ey >= ras.max_ey || ey < ras.min_ey ||\n-                    ex >= ras.max_ex );\n+    Found:\n+      ras.cell = cell;\n+    }\n@@ -597,1 +631,1 @@\n-#ifndef FT_LONG64\n+#ifndef FT_INT64\n@@ -625,2 +659,2 @@\n-    fx1   = FRACT( x1 );\n-    fx2   = FRACT( x2 );\n+    fx1 = FRACT( x1 );\n+    fx2 = FRACT( x2 );\n@@ -658,4 +692,3 @@\n-    ras.area  += (TArea)( ( fx1 + first ) * delta );\n-    ras.cover += delta;\n-    y1        += delta;\n-    ex1       += incr;\n+    FT_INTEGRATE( ras, delta, fx1 + first );\n+    y1  += delta;\n+    ex1 += incr;\n@@ -682,4 +715,3 @@\n-        ras.area  += (TArea)( ONE_PIXEL * delta );\n-        ras.cover += delta;\n-        y1        += delta;\n-        ex1       += incr;\n+        FT_INTEGRATE( ras, delta, ONE_PIXEL );\n+        y1  += delta;\n+        ex1 += incr;\n@@ -693,4 +725,1 @@\n-    dy = y2 - y1;\n-\n-    ras.area  += (TArea)( ( fx1 + fx2 ) * dy );\n-    ras.cover += dy;\n+    FT_INTEGRATE( ras, y2 - y1, fx1 + fx2 );\n@@ -739,1 +768,0 @@\n-      TArea   area;\n@@ -753,4 +781,3 @@\n-      delta      = first - fy1;\n-      ras.area  += (TArea)two_fx * delta;\n-      ras.cover += delta;\n-      ey1       += incr;\n+      delta = first - fy1;\n+      FT_INTEGRATE( ras, delta, two_fx);\n+      ey1 += incr;\n@@ -761,1 +788,0 @@\n-      area  = (TArea)two_fx * delta;\n@@ -764,3 +790,2 @@\n-        ras.area  += area;\n-        ras.cover += delta;\n-        ey1       += incr;\n+        FT_INTEGRATE( ras, delta, two_fx);\n+        ey1 += incr;\n@@ -771,3 +796,2 @@\n-      delta      = fy2 - ONE_PIXEL + first;\n-      ras.area  += (TArea)two_fx * delta;\n-      ras.cover += delta;\n+      delta = fy2 - ONE_PIXEL + first;\n+      FT_INTEGRATE( ras, delta, two_fx);\n@@ -886,2 +910,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * fx1 * 2;\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 * 2 );\n@@ -896,2 +919,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * fx1 * 2;\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 * 2 );\n@@ -905,1 +927,1 @@\n-      TPos  prod = dx * (TPos)fy1 - dy * (TPos)fx1;\n+      FT_Int64  prod = dx * (FT_Int64)fy1 - dy * (FT_Int64)fx1;\n@@ -915,2 +937,2 @@\n-        if      ( prod                                   <= 0 &&\n-                  prod - dx * ONE_PIXEL                  >  0 ) \/* left *\/\n+        if      ( prod - dx * ONE_PIXEL                  >  0 &&\n+                  prod                                   <= 0 ) \/* left *\/\n@@ -921,2 +943,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -927,2 +948,2 @@\n-        else if ( prod - dx * ONE_PIXEL                  <= 0 &&\n-                  prod - dx * ONE_PIXEL + dy * ONE_PIXEL >  0 ) \/* up *\/\n+        else if ( prod - dx * ONE_PIXEL + dy * ONE_PIXEL >  0 &&\n+                  prod - dx * ONE_PIXEL                  <= 0 ) \/* up *\/\n@@ -933,2 +954,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -939,2 +959,2 @@\n-        else if ( prod - dx * ONE_PIXEL + dy * ONE_PIXEL <= 0 &&\n-                  prod                  + dy * ONE_PIXEL >= 0 ) \/* right *\/\n+        else if ( prod                  + dy * ONE_PIXEL >= 0 &&\n+                  prod - dx * ONE_PIXEL + dy * ONE_PIXEL <= 0 ) \/* right *\/\n@@ -945,2 +965,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -951,2 +970,2 @@\n-        else \/* ( prod                  + dy * ONE_PIXEL <  0 &&\n-                  prod                                   >  0 )    down *\/\n+        else \/* ( prod                                   >  0 &&\n+                  prod                  + dy * ONE_PIXEL <  0 )    down *\/\n@@ -957,2 +976,1 @@\n-          ras.cover += ( fy2 - fy1 );\n-          ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+          FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -965,0 +983,1 @@\n+\n@@ -971,2 +990,1 @@\n-    ras.cover += ( fy2 - fy1 );\n-    ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );\n+    FT_INTEGRATE( ras, fy2 - fy1, fx1 + fx2 );\n@@ -975,2 +993,2 @@\n-    ras.x       = to_x;\n-    ras.y       = to_y;\n+    ras.x = to_x;\n+    ras.y = to_y;\n@@ -981,0 +999,240 @@\n+  \/*\n+   * Benchmarking shows that using DDA to flatten the quadratic Bézier arcs\n+   * is slightly faster in the following cases:\n+   *\n+   *   - When the host CPU is 64-bit.\n+   *   - When SSE2 SIMD registers and instructions are available (even on\n+   *     x86).\n+   *\n+   * For other cases, using binary splits is actually slightly faster.\n+   *\/\n+#if defined( __SSE2__ )                          || \\\n+    defined( __x86_64__ )                        || \\\n+    defined( _M_AMD64 )                          || \\\n+    ( defined( _M_IX86_FP ) && _M_IX86_FP >= 2 )\n+#  define FT_SSE2 1\n+#else\n+#  define FT_SSE2 0\n+#endif\n+\n+#if FT_SSE2                || \\\n+    defined( __aarch64__ ) || \\\n+    defined( _M_ARM64 )\n+#  define BEZIER_USE_DDA  1\n+#else\n+#  define BEZIER_USE_DDA  0\n+#endif\n+\n+  \/*\n+   * For now, the code that depends on `BEZIER_USE_DDA` requires `FT_Int64`\n+   * to be defined.  If `FT_INT64` is not defined, meaning there is no\n+   * 64-bit type available, disable it to avoid compilation errors.  See for\n+   * example https:\/\/gitlab.freedesktop.org\/freetype\/freetype\/-\/issues\/1071.\n+   *\/\n+#if !defined( FT_INT64 )\n+#  undef BEZIER_USE_DDA\n+#  define BEZIER_USE_DDA  0\n+#endif\n+\n+#if BEZIER_USE_DDA\n+\n+#if FT_SSE2\n+#  include <emmintrin.h>\n+#endif\n+\n+#define LEFT_SHIFT( a, b )  (FT_Int64)( (FT_UInt64)(a) << (b) )\n+\n+\n+  static void\n+  gray_render_conic( RAS_ARG_ const FT_Vector*  control,\n+                              const FT_Vector*  to )\n+  {\n+    FT_Vector  p0, p1, p2;\n+    TPos       ax, ay, bx, by, dx, dy;\n+    int        shift;\n+\n+    FT_Int64  rx, ry;\n+    FT_Int64  qx, qy;\n+    FT_Int64  px, py;\n+\n+    FT_UInt  count;\n+\n+\n+    p0.x = ras.x;\n+    p0.y = ras.y;\n+    p1.x = UPSCALE( control->x );\n+    p1.y = UPSCALE( control->y );\n+    p2.x = UPSCALE( to->x );\n+    p2.y = UPSCALE( to->y );\n+\n+    \/* short-cut the arc that crosses the current band *\/\n+    if ( ( TRUNC( p0.y ) >= ras.max_ey &&\n+           TRUNC( p1.y ) >= ras.max_ey &&\n+           TRUNC( p2.y ) >= ras.max_ey ) ||\n+         ( TRUNC( p0.y ) <  ras.min_ey &&\n+           TRUNC( p1.y ) <  ras.min_ey &&\n+           TRUNC( p2.y ) <  ras.min_ey ) )\n+    {\n+      ras.x = p2.x;\n+      ras.y = p2.y;\n+      return;\n+    }\n+\n+    bx = p1.x - p0.x;\n+    by = p1.y - p0.y;\n+    ax = p2.x - p1.x - bx;  \/* p0.x + p2.x - 2 * p1.x *\/\n+    ay = p2.y - p1.y - by;  \/* p0.y + p2.y - 2 * p1.y *\/\n+\n+    dx = FT_ABS( ax );\n+    dy = FT_ABS( ay );\n+    if ( dx < dy )\n+      dx = dy;\n+\n+    if ( dx <= ONE_PIXEL \/ 4 )\n+    {\n+      gray_render_line( RAS_VAR_ p2.x, p2.y );\n+      return;\n+    }\n+\n+    \/* We can calculate the number of necessary bisections because  *\/\n+    \/* each bisection predictably reduces deviation exactly 4-fold. *\/\n+    \/* Even 32-bit deviation would vanish after 16 bisections.      *\/\n+    shift = 0;\n+    do\n+    {\n+      dx   >>= 2;\n+      shift += 1;\n+\n+    } while ( dx > ONE_PIXEL \/ 4 );\n+\n+    \/*\n+     * The (P0,P1,P2) arc equation, for t in [0,1] range:\n+     *\n+     * P(t) = P0*(1-t)^2 + P1*2*t*(1-t) + P2*t^2\n+     *\n+     * P(t) = P0 + 2*(P1-P0)*t + (P0+P2-2*P1)*t^2\n+     *      = P0 + 2*B*t + A*t^2\n+     *\n+     *    for A = P0 + P2 - 2*P1\n+     *    and B = P1 - P0\n+     *\n+     * Let's consider the difference when advancing by a small\n+     * parameter h:\n+     *\n+     *    Q(h,t) = P(t+h) - P(t) = 2*B*h + A*h^2 + 2*A*h*t\n+     *\n+     * And then its own difference:\n+     *\n+     *    R(h,t) = Q(h,t+h) - Q(h,t) = 2*A*h*h = R (constant)\n+     *\n+     * Since R is always a constant, it is possible to compute\n+     * successive positions with:\n+     *\n+     *     P = P0\n+     *     Q = Q(h,0) = 2*B*h + A*h*h\n+     *     R = 2*A*h*h\n+     *\n+     *   loop:\n+     *     P += Q\n+     *     Q += R\n+     *     EMIT(P)\n+     *\n+     * To ensure accurate results, perform computations on 64-bit\n+     * values, after scaling them by 2^32.\n+     *\n+     *           h = 1 \/ 2^N\n+     *\n+     *     R << 32 = 2 * A << (32 - N - N)\n+     *             = A << (33 - 2*N)\n+     *\n+     *     Q << 32 = (2 * B << (32 - N)) + (A << (32 - N - N))\n+     *             = (B << (33 - N)) + (A << (32 - 2*N))\n+     *\/\n+\n+#if FT_SSE2\n+    \/* Experience shows that for small shift values, *\/\n+    \/* SSE2 is actually slower.                      *\/\n+    if ( shift > 2 )\n+    {\n+      union\n+      {\n+        struct { FT_Int64  ax, ay, bx, by; }  i;\n+        struct { __m128i  a, b; }  vec;\n+\n+      } u;\n+\n+      union\n+      {\n+        struct { FT_Int32  px_lo, px_hi, py_lo, py_hi; }  i;\n+        __m128i  vec;\n+\n+      } v;\n+\n+      __m128i  a, b;\n+      __m128i  r, q, q2;\n+      __m128i  p;\n+\n+\n+      u.i.ax = ax;\n+      u.i.ay = ay;\n+      u.i.bx = bx;\n+      u.i.by = by;\n+\n+      a = _mm_load_si128( &u.vec.a );\n+      b = _mm_load_si128( &u.vec.b );\n+\n+      r  = _mm_slli_epi64( a, 33 - 2 * shift );\n+      q  = _mm_slli_epi64( b, 33 - shift );\n+      q2 = _mm_slli_epi64( a, 32 - 2 * shift );\n+\n+      q = _mm_add_epi64( q2, q );\n+\n+      v.i.px_lo = 0;\n+      v.i.px_hi = p0.x;\n+      v.i.py_lo = 0;\n+      v.i.py_hi = p0.y;\n+\n+      p = _mm_load_si128( &v.vec );\n+\n+      for ( count = 1U << shift; count > 0; count-- )\n+      {\n+        p = _mm_add_epi64( p, q );\n+        q = _mm_add_epi64( q, r );\n+\n+        _mm_store_si128( &v.vec, p );\n+\n+        gray_render_line( RAS_VAR_ v.i.px_hi, v.i.py_hi );\n+      }\n+\n+      return;\n+    }\n+#endif  \/* FT_SSE2 *\/\n+\n+    rx = LEFT_SHIFT( ax, 33 - 2 * shift );\n+    ry = LEFT_SHIFT( ay, 33 - 2 * shift );\n+\n+    qx = LEFT_SHIFT( bx, 33 - shift ) + LEFT_SHIFT( ax, 32 - 2 * shift );\n+    qy = LEFT_SHIFT( by, 33 - shift ) + LEFT_SHIFT( ay, 32 - 2 * shift );\n+\n+    px = LEFT_SHIFT( p0.x, 32 );\n+    py = LEFT_SHIFT( p0.y, 32 );\n+\n+    for ( count = 1U << shift; count > 0; count-- )\n+    {\n+      px += qx;\n+      py += qy;\n+      qx += rx;\n+      qy += ry;\n+\n+      gray_render_line( RAS_VAR_ (FT_Pos)( px >> 32 ),\n+                                 (FT_Pos)( py >> 32 ) );\n+    }\n+  }\n+\n+#else  \/* !BEZIER_USE_DDA *\/\n+\n+  \/*\n+   * Note that multiple attempts to speed up the function below\n+   * with SSE2 intrinsics, using various data layouts, have turned\n+   * out to be slower than the non-SIMD code below.\n+   *\/\n@@ -1010,1 +1268,1 @@\n-    int         draw, split;\n+    int         draw;\n@@ -1053,1 +1311,3 @@\n-      split = draw & ( -draw );  \/* isolate the rightmost 1-bit *\/\n+      int  split = draw & ( -draw );  \/* isolate the rightmost 1-bit *\/\n+\n+\n@@ -1066,0 +1326,1 @@\n+#endif  \/* !BEZIER_USE_DDA *\/\n@@ -1067,0 +1328,9 @@\n+\n+  \/*\n+   * For cubic Bézier, binary splits are still faster than DDA\n+   * because the splits are adaptive to how quickly each sub-arc\n+   * approaches their chord trisection points.\n+   *\n+   * It might be useful to experiment with SSE2 to speed up\n+   * `gray_split_cubic`, though.\n+   *\/\n@@ -1208,4 +1478,1 @@\n-  gray_hline( RAS_ARG_ TCoord  x,\n-                       TCoord  y,\n-                       TArea   coverage,\n-                       TCoord  acount )\n+  gray_sweep( RAS_ARG )\n@@ -1213,2 +1480,4 @@\n-    \/* scale the coverage from 0..(ONE_PIXEL*ONE_PIXEL*2) to 0..256  *\/\n-    coverage >>= PIXEL_BITS * 2 + 1 - 8;\n+    int  fill = ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL ) ? 0x100\n+                                                                 : INT_MIN;\n+    int  coverage;\n+    int  y;\n@@ -1216,4 +1485,0 @@\n-    \/* compute the line's coverage depending on the outline fill rule *\/\n-    if ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL )\n-    {\n-      coverage &= 511;\n@@ -1221,4 +1486,1 @@\n-      if ( coverage >= 256 )\n-        coverage = 511 - coverage;\n-    }\n-    else  \/* default non-zero winding rule *\/\n+    for ( y = ras.min_ey; y < ras.max_ey; y++ )\n@@ -1226,2 +1488,3 @@\n-      if ( coverage < 0 )\n-        coverage = ~coverage;  \/* the same as -coverage - 1 *\/\n+      PCell   cell  = ras.ycells[y - ras.min_ey];\n+      TCoord  x     = ras.min_ex;\n+      TArea   cover = 0;\n@@ -1229,3 +1492,1 @@\n-      if ( coverage >= 256 )\n-        coverage = 255;\n-    }\n+      unsigned char*  line = ras.target.origin - ras.target.pitch * y;\n@@ -1233,3 +1494,4 @@\n-    if ( ras.num_spans >= 0 )  \/* for FT_RASTER_FLAG_DIRECT only *\/\n-    {\n-      FT_Span*  span = ras.spans + ras.num_spans++;\n+\n+      for ( ; cell != ras.cell_null; cell = cell->next )\n+      {\n+        TArea  area;\n@@ -1238,3 +1500,5 @@\n-      span->x        = (short)x;\n-      span->len      = (unsigned short)acount;\n-      span->coverage = (unsigned char)coverage;\n+        if ( cover != 0 && cell->x > x )\n+        {\n+          FT_FILL_RULE( coverage, cover, fill );\n+          FT_GRAY_SET( line + x, coverage, cell->x - x );\n+        }\n@@ -1242,11 +1506,2 @@\n-      if ( ras.num_spans == FT_MAX_GRAY_SPANS )\n-      {\n-        \/* flush the span buffer and reset the count *\/\n-        ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );\n-        ras.num_spans = 0;\n-      }\n-    }\n-    else\n-    {\n-      unsigned char*  q = ras.target.origin - ras.target.pitch * y + x;\n-      unsigned char   c = (unsigned char)coverage;\n+        cover += (TArea)cell->cover * ( ONE_PIXEL * 2 );\n+        area   = cover - cell->area;\n@@ -1254,0 +1509,8 @@\n+        if ( area != 0 && cell->x >= ras.min_ex )\n+        {\n+          FT_FILL_RULE( coverage, area, fill );\n+          line[cell->x] = (unsigned char)coverage;\n+        }\n+\n+        x = cell->x + 1;\n+      }\n@@ -1255,5 +1518,1 @@\n-      \/* For small-spans it is faster to do it by ourselves than\n-       * calling `memset'.  This is mainly due to the cost of the\n-       * function call.\n-       *\/\n-      switch ( acount )\n+      if ( cover != 0 )  \/* only if cropped *\/\n@@ -1261,25 +1520,2 @@\n-      case 7:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 6:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 5:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 4:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 3:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 2:\n-        *q++ = c;\n-        \/* fall through *\/\n-      case 1:\n-        *q = c;\n-        \/* fall through *\/\n-      case 0:\n-        break;\n-      default:\n-        FT_MEM_SET( q, c, acount );\n+        FT_FILL_RULE( coverage, cover, fill );\n+        FT_GRAY_SET( line + x, coverage, ras.max_ex - x );\n@@ -1292,1 +1528,1 @@\n-  gray_sweep( RAS_ARG )\n+  gray_sweep_direct( RAS_ARG )\n@@ -1294,0 +1530,3 @@\n+    int  fill = ( ras.outline.flags & FT_OUTLINE_EVEN_ODD_FILL ) ? 0x100\n+                                                                 : INT_MIN;\n+    int  coverage;\n@@ -1296,0 +1535,3 @@\n+    FT_Span  span[FT_MAX_GRAY_SPANS];\n+    int      n = 0;\n+\n@@ -1302,1 +1544,0 @@\n-      TArea   area;\n@@ -1305,1 +1546,1 @@\n-      for ( ; cell != NULL; cell = cell->next )\n+      for ( ; cell != ras.cell_null; cell = cell->next )\n@@ -1307,0 +1548,3 @@\n+        TArea  area;\n+\n+\n@@ -1308,1 +1552,14 @@\n-          gray_hline( RAS_VAR_ x, y, cover, cell->x - x );\n+        {\n+          FT_FILL_RULE( coverage, cover, fill );\n+\n+          span[n].coverage = (unsigned char)coverage;\n+          span[n].x        = (short)x;\n+          span[n].len      = (unsigned short)( cell->x - x );\n+\n+          if ( ++n == FT_MAX_GRAY_SPANS )\n+          {\n+            \/* flush the span buffer and reset the count *\/\n+            ras.render_span( y, n, span, ras.render_span_data );\n+            n = 0;\n+          }\n+        }\n@@ -1314,1 +1571,14 @@\n-          gray_hline( RAS_VAR_ cell->x, y, area, 1 );\n+        {\n+          FT_FILL_RULE( coverage, area, fill );\n+\n+          span[n].coverage = (unsigned char)coverage;\n+          span[n].x        = (short)cell->x;\n+          span[n].len      = 1;\n+\n+          if ( ++n == FT_MAX_GRAY_SPANS )\n+          {\n+            \/* flush the span buffer and reset the count *\/\n+            ras.render_span( y, n, span, ras.render_span_data );\n+            n = 0;\n+          }\n+        }\n@@ -1319,2 +1589,10 @@\n-      if ( cover != 0 )\n-        gray_hline( RAS_VAR_ x, y, cover, ras.max_ex - x );\n+      if ( cover != 0 )  \/* only if cropped *\/\n+      {\n+        FT_FILL_RULE( coverage, cover, fill );\n+\n+        span[n].coverage = (unsigned char)coverage;\n+        span[n].x        = (short)x;\n+        span[n].len      = (unsigned short)( ras.max_ex - x );\n+\n+        ++n;\n+      }\n@@ -1322,1 +1600,1 @@\n-      if ( ras.num_spans > 0 )  \/* for FT_RASTER_FLAG_DIRECT only *\/\n+      if ( n )\n@@ -1325,2 +1603,2 @@\n-        ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );\n-        ras.num_spans = 0;\n+        ras.render_span( y, n, span, ras.render_span_data );\n+        n = 0;\n@@ -1607,1 +1885,1 @@\n-    return 0;\n+    return Smooth_Err_Ok;\n@@ -1648,4 +1926,1 @@\n-      if ( !ras.invalid )\n-        gray_record_cell( RAS_VAR );\n-\n-      FT_TRACE7(( \"band [%d..%d]: %ld cell%s\\n\",\n+      FT_TRACE7(( \"band [%d..%d]: %ld cell%s remaining\/\\n\",\n@@ -1654,2 +1929,2 @@\n-                  ras.num_cells,\n-                  ras.num_cells == 1 ? \"\" : \"s\" ));\n+                  ras.cell_null - ras.cell_free,\n+                  ras.cell_null - ras.cell_free == 1 ? \"\" : \"s\" ));\n@@ -1659,1 +1934,1 @@\n-      error = FT_THROW( Memory_Overflow );\n+      error = FT_THROW( Raster_Overflow );\n@@ -1685,0 +1960,7 @@\n+    \/* Initialize the null cell at the end of the poll. *\/\n+    ras.cell_null        = buffer + FT_MAX_GRAY_POOL - 1;\n+    ras.cell_null->x     = CELL_MAX_X_VALUE;\n+    ras.cell_null->area  = 0;\n+    ras.cell_null->cover = 0;\n+    ras.cell_null->next  = NULL;\n+\n@@ -1686,0 +1968,2 @@\n+    ras.ycells     = (PCell*)buffer;\n+\n@@ -1693,7 +1977,0 @@\n-    \/* memory management *\/\n-    n = ( height * sizeof ( PCell ) + sizeof ( TCell ) - 1 ) \/ sizeof ( TCell );\n-\n-    ras.cells     = buffer + n;\n-    ras.max_cells = (FT_PtrDist)( FT_MAX_GRAY_POOL - n );\n-    ras.ycells    = (PCell*)buffer;\n-\n@@ -1713,0 +1990,1 @@\n+        TCoord  w;\n@@ -1716,1 +1994,2 @@\n-        FT_MEM_ZERO( ras.ycells, height * sizeof ( PCell ) );\n+        for ( w = 0; w < width; ++w )\n+          ras.ycells[w] = ras.cell_null;\n@@ -1718,2 +1997,6 @@\n-        ras.num_cells = 0;\n-        ras.invalid   = 1;\n+        \/* memory management: skip ycells *\/\n+        n = ( (size_t)width * sizeof ( PCell ) + sizeof ( TCell ) - 1 ) \/\n+              sizeof ( TCell );\n+\n+        ras.cell_free = buffer + n;\n+        ras.cell      = ras.cell_null;\n@@ -1722,0 +2005,1 @@\n+        ras.count_ey  = width;\n@@ -1728,1 +2012,4 @@\n-          gray_sweep( RAS_VAR );\n+          if ( ras.render_span )  \/* for FT_RASTER_FLAG_DIRECT only *\/\n+            gray_sweep_direct( RAS_VAR );\n+          else\n+            gray_sweep( RAS_VAR );\n@@ -1732,2 +2019,2 @@\n-        else if ( error != ErrRaster_Memory_Overflow )\n-          return 1;\n+        else if ( error != Smooth_Err_Raster_Overflow )\n+          return error;\n@@ -1742,1 +2029,1 @@\n-          return 1;\n+          return FT_THROW( Raster_Overflow );\n@@ -1751,1 +2038,1 @@\n-    return 0;\n+    return Smooth_Err_Ok;\n@@ -1772,1 +2059,1 @@\n-      return FT_THROW( Invalid_Mode );\n+      return FT_THROW( Cannot_Render_Glyph );\n@@ -1779,1 +2066,1 @@\n-      return 0;\n+      return Smooth_Err_Ok;\n@@ -1793,1 +2080,1 @@\n-        return 0;\n+        return Smooth_Err_Ok;\n@@ -1797,1 +2084,0 @@\n-      ras.num_spans        = 0;\n@@ -1812,1 +2098,1 @@\n-        return 0;\n+        return Smooth_Err_Ok;\n@@ -1827,1 +2113,0 @@\n-      ras.num_spans        = -1;  \/* invalid *\/\n@@ -1837,1 +2122,1 @@\n-      return 0;\n+      return Smooth_Err_Ok;\n@@ -1874,2 +2159,2 @@\n-  gray_raster_new( FT_Memory   memory,\n-                   FT_Raster*  araster )\n+  gray_raster_new( FT_Memory      memory,\n+                   gray_PRaster*  araster )\n@@ -1881,3 +2166,1 @@\n-    *araster = 0;\n-    if ( !FT_ALLOC( raster, sizeof ( gray_TRaster ) ) )\n-    {\n+    if ( !FT_NEW( raster ) )\n@@ -1885,2 +2168,2 @@\n-      *araster       = (FT_Raster)raster;\n-    }\n+\n+    *araster = raster;\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftgrays.c","additions":556,"deletions":273,"binary":false,"changes":829,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftgrays.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftsmerrs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2000-2020 by\n+ * Copyright (C) 2000-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftsmooth.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/smooth\/ftsmooth.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -111,1 +111,1 @@\n-    FT_TRACE0(( \"tt_property_set: missing property `%s'\\n\",\n+    FT_TRACE2(( \"tt_property_set: missing property `%s'\\n\",\n@@ -138,1 +138,1 @@\n-    FT_TRACE0(( \"tt_property_get: missing property `%s'\\n\",\n+    FT_TRACE2(( \"tt_property_get: missing property `%s'\\n\",\n@@ -357,1 +357,10 @@\n-    FT_Request_Metrics( size->face, req );\n+    {\n+      FT_Error  err = FT_Request_Metrics( size->face, req );\n+\n+\n+      if ( err )\n+      {\n+        error = err;\n+        goto Exit;\n+      }\n+    }\n@@ -385,0 +394,1 @@\n+  Exit:\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttdriver.c","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttdriver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/tterrors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -200,1 +200,5 @@\n-    if ( !loader->linear_def )\n+#ifdef FT_CONFIG_OPTION_INCREMENTAL\n+    \/* With the incremental interface, these values are set by  *\/\n+    \/* a call to `tt_get_metrics_incremental'.                  *\/\n+    if ( face->root.internal->incremental_interface == NULL )\n+#endif\n@@ -202,2 +206,5 @@\n-      loader->linear_def = 1;\n-      loader->linear     = advance_width;\n+      if ( !loader->linear_def )\n+      {\n+        loader->linear_def = 1;\n+        loader->linear     = advance_width;\n+      }\n@@ -213,2 +220,2 @@\n-  tt_get_metrics_incr_overrides( TT_Loader  loader,\n-                                 FT_UInt    glyph_index )\n+  tt_get_metrics_incremental( TT_Loader  loader,\n+                              FT_UInt    glyph_index )\n@@ -454,1 +461,1 @@\n-      load->exec->glyphSize = (FT_UShort)tmp;\n+      load->exec->glyphSize = (FT_UInt)tmp;\n@@ -739,2 +746,2 @@\n-          FT_TRACE7(( \"      scaling: xx=%f, yx=%f\\n\"\n-                      \"               xy=%f, yy=%f\\n\",\n+        {\n+          FT_TRACE7(( \"      scaling: xx=%f, yx=%f\\n\",\n@@ -742,1 +749,2 @@\n-                      subglyph->transform.yx \/ 65536.0,\n+                      subglyph->transform.yx \/ 65536.0 ));\n+          FT_TRACE7(( \"               xy=%f, yy=%f\\n\",\n@@ -745,0 +753,1 @@\n+        }\n@@ -1386,1 +1395,1 @@\n-      FT_TRACE5(( \"  Instructions size = %d\\n\", n_ins ));\n+      FT_TRACE5(( \"  Instructions size = %hu\\n\", n_ins ));\n@@ -1394,1 +1403,1 @@\n-        if ( (FT_Int)n_ins > loader->byte_len )\n+        if ( n_ins > loader->byte_len )\n@@ -1397,1 +1406,1 @@\n-                      \" too many instructions (%d) for glyph with length %d\\n\",\n+                      \" too many instructions (%hu) for glyph with length %u\\n\",\n@@ -1680,1 +1689,1 @@\n-                            (FT_ULong)glyph_data.length );\n+                            glyph_data.length );\n@@ -1688,2 +1697,1 @@\n-      offset = tt_face_get_location( face, glyph_index,\n-                                     (FT_UInt*)&loader->byte_len );\n+      offset = tt_face_get_location( face, glyph_index, &loader->byte_len );\n@@ -1708,1 +1716,1 @@\n-                                        (FT_UInt)loader->byte_len );\n+                                        loader->byte_len );\n@@ -1742,4 +1750,0 @@\n-      \/* must initialize points before (possibly) overriding *\/\n-      \/* glyph metrics from the incremental interface        *\/\n-      tt_loader_set_pp( loader );\n-\n@@ -1747,1 +1751,1 @@\n-      tt_get_metrics_incr_overrides( loader, glyph_index );\n+      tt_get_metrics_incremental( loader, glyph_index );\n@@ -1749,0 +1753,2 @@\n+      tt_loader_set_pp( loader );\n+\n@@ -1831,4 +1837,0 @@\n-    \/* must initialize phantom points before (possibly) overriding *\/\n-    \/* glyph metrics from the incremental interface                *\/\n-    tt_loader_set_pp( loader );\n-\n@@ -1836,1 +1838,1 @@\n-    tt_get_metrics_incr_overrides( loader, glyph_index );\n+    tt_get_metrics_incremental( loader, glyph_index );\n@@ -1838,0 +1840,2 @@\n+    tt_loader_set_pp( loader );\n+\n@@ -1847,1 +1851,1 @@\n-                                      (FT_UInt)loader->byte_len - 10 );\n+                                      loader->byte_len - 10 );\n@@ -1901,1 +1905,1 @@\n-        node2->data = (void*)FT_ULONG_MAX;\n+        node2->data = (void*)-1;\n@@ -1918,1 +1922,1 @@\n-        if ( FT_NEW( node ) )\n+        if ( FT_QNEW( node ) )\n@@ -2103,1 +2107,1 @@\n-        FT_Int       old_byte_len   = loader->byte_len;\n+        FT_UInt      old_byte_len   = loader->byte_len;\n@@ -2229,4 +2233,0 @@\n-#if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \\\n-    defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );\n-#endif\n@@ -2255,47 +2255,4 @@\n-    glyph->metrics.horiAdvance  = SUB_LONG(loader->pp2.x, loader->pp1.x);\n-\n-    \/* Adjust advance width to the value contained in the hdmx table   *\/\n-    \/* unless FT_LOAD_COMPUTE_METRICS is set or backward compatibility *\/\n-    \/* mode of the v40 interpreter is active.  See `ttinterp.h' for    *\/\n-    \/* details on backward compatibility mode.                         *\/\n-    if (\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-         !( driver->interpreter_version == TT_INTERPRETER_VERSION_40  &&\n-            ( loader->exec && loader->exec->backward_compatibility  ) ) &&\n-#endif\n-         !face->postscript.isFixedPitch                                 &&\n-         IS_HINTED( loader->load_flags )                                &&\n-         !( loader->load_flags & FT_LOAD_COMPUTE_METRICS )              )\n-    {\n-      FT_Byte*  widthp;\n-\n-\n-      widthp = tt_face_get_device_metrics( face,\n-                                           size->metrics->x_ppem,\n-                                           glyph_index );\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-\n-      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )\n-      {\n-        FT_Bool  ignore_x_mode;\n-\n-\n-        ignore_x_mode = FT_BOOL( FT_LOAD_TARGET_MODE( loader->load_flags ) !=\n-                                 FT_RENDER_MODE_MONO );\n-\n-        if ( widthp                                                   &&\n-             ( ( ignore_x_mode && loader->exec->compatible_widths ) ||\n-                !ignore_x_mode                                      ||\n-                SPH_OPTION_BITMAP_WIDTHS                            ) )\n-          glyph->metrics.horiAdvance = *widthp * 64;\n-      }\n-      else\n-\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-      {\n-        if ( widthp )\n-          glyph->metrics.horiAdvance = *widthp * 64;\n-      }\n-    }\n+    if ( loader->widthp )\n+      glyph->metrics.horiAdvance = loader->widthp[glyph_index] * 64;\n+    else\n+      glyph->metrics.horiAdvance = SUB_LONG(loader->pp2.x, loader->pp1.x);\n@@ -2716,0 +2673,3 @@\n+        error = TT_Load_Context( exec, face, size );\n+        if ( error )\n+          return error;\n@@ -2731,2 +2691,24 @@\n-        exec->ignore_x_mode = 0;\n-#endif\n+        exec->ignore_x_mode = FALSE;\n+#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n+\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+      \/*\n+       * Toggle backward compatibility according to what font wants, except\n+       * when\n+       *\n+       * 1) we have a `tricky' font that heavily relies on the interpreter to\n+       *    render glyphs correctly, for example DFKai-SB, or\n+       * 2) FT_RENDER_MODE_MONO (i.e, monochome rendering) is requested.\n+       *\n+       * In those cases, backward compatibility needs to be turned off to get\n+       * correct rendering.  The rendering is then completely up to the\n+       * font's programming.\n+       *\n+       *\/\n+      if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&\n+           subpixel_hinting_lean                                    &&\n+           !FT_IS_TRICKY( glyph->face )                             )\n+        exec->backward_compatibility = !( exec->GS.instruct_control & 4 );\n+      else\n+        exec->backward_compatibility = FALSE;\n+#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL *\/\n@@ -2737,0 +2719,24 @@\n+\n+      \/* Use the hdmx table if any unless FT_LOAD_COMPUTE_METRICS *\/\n+      \/* is set or backward compatibility mode of the v38 or v40  *\/\n+      \/* interpreters is active.  See `ttinterp.h' for details on *\/\n+      \/* backward compatibility mode.                             *\/\n+      if ( IS_HINTED( loader->load_flags )                                &&\n+           !( loader->load_flags & FT_LOAD_COMPUTE_METRICS )              &&\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+           !( driver->interpreter_version == TT_INTERPRETER_VERSION_40  &&\n+              exec->backward_compatibility                              ) &&\n+#endif\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n+           !( driver->interpreter_version == TT_INTERPRETER_VERSION_38  &&\n+              !SPH_OPTION_BITMAP_WIDTHS                                 &&\n+              FT_LOAD_TARGET_MODE( loader->load_flags ) !=\n+                                                   FT_RENDER_MODE_MONO  &&\n+              exec->compatible_widths                                   ) &&\n+#endif\n+           !face->postscript.isFixedPitch                                 )\n+      {\n+        loader->widthp = size->widthp;\n+      }\n+      else\n+        loader->widthp = NULL;\n@@ -2784,1 +2790,1 @@\n-   * @Input:\n+   * @InOut:\n@@ -2789,0 +2795,1 @@\n+   * @Input:\n@@ -2893,1 +2900,2 @@\n-        if ( FT_IS_SCALABLE( glyph->face ) )\n+        if ( FT_IS_SCALABLE( glyph->face ) ||\n+             FT_HAS_SBIX( glyph->face )    )\n@@ -2895,0 +2903,3 @@\n+          TT_Face  face = (TT_Face)glyph->face;\n+\n+\n@@ -2902,0 +2913,29 @@\n+          \/* Bitmaps from the 'sbix' table need special treatment:  *\/\n+          \/* if there is a glyph contour, the bitmap origin must be *\/\n+          \/* shifted to be relative to the lower left corner of the *\/\n+          \/* glyph bounding box, also taking the left-side bearing  *\/\n+          \/* (or top bearing) into account.                         *\/\n+          if ( face->sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX &&\n+               loader.n_contours > 0                            )\n+          {\n+            FT_Int  bitmap_left;\n+            FT_Int  bitmap_top;\n+\n+\n+            if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )\n+            {\n+              \/* This is a guess, since Apple's CoreText engine doesn't *\/\n+              \/* really do vertical typesetting.                        *\/\n+              bitmap_left = loader.bbox.xMin;\n+              bitmap_top  = loader.top_bearing;\n+            }\n+            else\n+            {\n+              bitmap_left = loader.left_bearing;\n+              bitmap_top  = loader.bbox.yMin;\n+            }\n+\n+            glyph->bitmap_left += FT_MulFix( bitmap_left, x_scale ) >> 6;\n+            glyph->bitmap_top  += FT_MulFix( bitmap_top,  y_scale ) >> 6;\n+          }\n+\n@@ -2916,0 +2956,6 @@\n+    if ( load_flags & FT_LOAD_SBITS_ONLY )\n+    {\n+      error = FT_THROW( Invalid_Argument );\n+      goto Exit;\n+    }\n+\n@@ -2925,1 +2971,55 @@\n-    if ( load_flags & FT_LOAD_SBITS_ONLY )\n+#ifdef FT_CONFIG_OPTION_SVG\n+\n+    \/* check for OT-SVG *\/\n+    if ( ( load_flags & FT_LOAD_COLOR ) && ( (TT_Face)glyph->face )->svg )\n+    {\n+      SFNT_Service  sfnt;\n+\n+      FT_Short   leftBearing;\n+      FT_Short   topBearing;\n+      FT_UShort  advanceX;\n+      FT_UShort  advanceY;\n+\n+\n+      FT_TRACE3(( \"Trying to load SVG glyph\\n\" ));\n+      sfnt = (SFNT_Service)( (TT_Face)glyph->face )->sfnt;\n+\n+      error = sfnt->load_svg_doc( glyph, glyph_index );\n+      if ( !error )\n+      {\n+        TT_Face  face = (TT_Face)glyph->face;\n+\n+\n+        FT_TRACE3(( \"Successfully loaded SVG glyph\\n\" ));\n+\n+        glyph->format = FT_GLYPH_FORMAT_SVG;\n+\n+        sfnt->get_metrics( face,\n+                           FALSE,\n+                           glyph_index,\n+                           &leftBearing,\n+                           &advanceX );\n+        sfnt->get_metrics( face,\n+                           TRUE,\n+                           glyph_index,\n+                           &topBearing,\n+                           &advanceY );\n+\n+        advanceX = (FT_UShort)FT_MulDiv( advanceX,\n+                                         glyph->face->size->metrics.x_ppem,\n+                                         glyph->face->units_per_EM );\n+        advanceY = (FT_UShort)FT_MulDiv( advanceY,\n+                                         glyph->face->size->metrics.y_ppem,\n+                                         glyph->face->units_per_EM );\n+\n+        glyph->metrics.horiAdvance = advanceX << 6;\n+        glyph->metrics.vertAdvance = advanceY << 6;\n+\n+        return error;\n+      }\n+\n+      FT_TRACE3(( \"Failed to load SVG glyph\\n\" ));\n+    }\n+\n+    \/* return immediately if we only want SVG glyphs *\/\n+    if ( load_flags & FT_LOAD_SVG_ONLY )\n@@ -2931,0 +3031,2 @@\n+#endif \/* FT_CONFIG_OPTION_SVG *\/\n+\n@@ -2935,0 +3037,9 @@\n+    \/* done if we are only interested in the `hdmx` advance *\/\n+    if ( load_flags & FT_LOAD_ADVANCE_ONLY         &&\n+         !( load_flags & FT_LOAD_VERTICAL_LAYOUT ) &&\n+         loader.widthp                             )\n+    {\n+      glyph->metrics.horiAdvance = loader.widthp[glyph_index] * 64;\n+      goto Done;\n+    }\n+\n@@ -3013,0 +3124,1 @@\n+  Done:\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgload.c","additions":199,"deletions":87,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2022 by\n@@ -154,3 +154,1 @@\n-    FT_Error   error  = FT_Err_Ok;\n-\n-    FT_UNUSED( error );\n+    FT_Error   error;\n@@ -181,1 +179,1 @@\n-    if ( FT_NEW_ARRAY( points, n + 1 ) )\n+    if ( FT_QNEW_ARRAY( points, n + 1 ) )\n@@ -267,0 +265,1 @@\n+    FT_UInt    bytes_used;\n@@ -268,3 +267,1 @@\n-    FT_Error   error  = FT_Err_Ok;\n-\n-    FT_UNUSED( error );\n+    FT_Error   error;\n@@ -273,3 +270,1 @@\n-    if ( delta_cnt > size )\n-    {\n-      FT_TRACE1(( \"ft_var_readpackeddeltas: number of points too large\\n\" ));\n+    if ( FT_QNEW_ARRAY( deltas, delta_cnt ) )\n@@ -277,1 +272,0 @@\n-    }\n@@ -279,2 +273,2 @@\n-    if ( FT_NEW_ARRAY( deltas, delta_cnt ) )\n-      return NULL;\n+    i          = 0;\n+    bytes_used = 0;\n@@ -282,2 +276,1 @@\n-    i = 0;\n-    while ( i < delta_cnt )\n+    while ( i < delta_cnt && bytes_used < size )\n@@ -288,0 +281,2 @@\n+      bytes_used++;\n+\n@@ -290,1 +285,1 @@\n-        \/* `runcnt' zeroes get added *\/\n+        \/* `cnt` + 1 zeroes get added *\/\n@@ -296,1 +291,9 @@\n-        \/* `runcnt' shorts from the stack *\/\n+        \/* `cnt` + 1 shorts from the stack *\/\n+        bytes_used += 2 * ( cnt + 1 );\n+        if ( bytes_used > size )\n+        {\n+          FT_TRACE1(( \"ft_var_readpackeddeltas:\"\n+                      \" number of short deltas too large\\n\" ));\n+          goto Fail;\n+        }\n+\n@@ -302,1 +305,9 @@\n-        \/* `runcnt' signed bytes from the stack *\/\n+        \/* `cnt` + 1 signed bytes from the stack *\/\n+        bytes_used += cnt + 1;\n+        if ( bytes_used > size )\n+        {\n+          FT_TRACE1(( \"ft_var_readpackeddeltas:\"\n+                      \" number of byte deltas too large\\n\" ));\n+          goto Fail;\n+        }\n+\n@@ -309,3 +320,3 @@\n-        \/* bad format *\/\n-        FT_FREE( deltas );\n-        return NULL;\n+        FT_TRACE1(( \"ft_var_readpackeddeltas:\"\n+                    \" number of deltas too large\\n\" ));\n+        goto Fail;\n@@ -315,0 +326,6 @@\n+    if ( i < delta_cnt )\n+    {\n+      FT_TRACE1(( \"ft_var_readpackeddeltas: not enough deltas\\n\" ));\n+      goto Fail;\n+    }\n+\n@@ -316,0 +333,4 @@\n+\n+  Fail:\n+    FT_FREE( deltas );\n+    return NULL;\n@@ -339,1 +360,1 @@\n-    FT_Error        error = FT_Err_Ok;\n+    FT_Error        error;\n@@ -345,2 +366,0 @@\n-    FT_UNUSED( error );\n-\n@@ -374,2 +393,3 @@\n-      FT_TRACE2(( \"ft_var_load_avar: number of axes in `avar' and `fvar'\\n\"\n-                  \"                  table are different\\n\" ));\n+      FT_TRACE2(( \"ft_var_load_avar:\"\n+                  \" number of axes in `avar' and `fvar'\\n\" ));\n+      FT_TRACE2(( \"                  table are different\\n\" ));\n@@ -379,1 +399,1 @@\n-    if ( FT_NEW_ARRAY( blend->avar_segment, axisCount ) )\n+    if ( FT_QNEW_ARRAY( blend->avar_segment, axisCount ) )\n@@ -388,2 +408,2 @@\n-      if ( (FT_ULong)segment->pairCount * 4 > table_len                ||\n-           FT_NEW_ARRAY( segment->correspondence, segment->pairCount ) )\n+      if ( (FT_ULong)segment->pairCount * 4 > table_len                 ||\n+           FT_QNEW_ARRAY( segment->correspondence, segment->pairCount ) )\n@@ -398,1 +418,0 @@\n-        blend->avar_segment = NULL;\n@@ -434,1 +453,2 @@\n-    FT_UInt    shortDeltaCount;\n+    FT_UInt    wordDeltaCount;\n+    FT_Bool    long_words;\n@@ -469,1 +489,1 @@\n-    if ( FT_NEW_ARRAY( dataOffsetArray, itemStore->dataCount ) )\n+    if ( FT_QNEW_ARRAY( dataOffsetArray, itemStore->dataCount ) )\n@@ -489,2 +509,2 @@\n-                  \" number of axes in item variation store\\n\"\n-                  \"                                 \"\n+                  \" number of axes in item variation store\\n\" ));\n+      FT_TRACE2(( \"                                 \"\n@@ -496,0 +516,9 @@\n+    \/* new constraint in OpenType 1.8.4 *\/\n+    if ( itemStore->regionCount >= 32768U )\n+    {\n+      FT_TRACE2(( \"ft_var_load_item_variation_store:\"\n+                  \" too many variation region tables\\n\" ));\n+      error = FT_THROW( Invalid_Table );\n+      goto Exit;\n+    }\n+\n@@ -540,1 +569,1 @@\n-           FT_READ_USHORT( shortDeltaCount )         ||\n+           FT_READ_USHORT( wordDeltaCount )          ||\n@@ -544,0 +573,3 @@\n+      long_words      = !!( wordDeltaCount & 0x8000 );\n+      wordDeltaCount &= 0x7FFF;\n+\n@@ -545,1 +577,1 @@\n-      if ( shortDeltaCount > varData->regionIdxCount )\n+      if ( wordDeltaCount > varData->regionIdxCount )\n@@ -548,1 +580,1 @@\n-                    shortDeltaCount,\n+                    wordDeltaCount,\n@@ -584,3 +616,4 @@\n-      \/* On input, deltas are (shortDeltaCount + regionIdxCount) bytes   *\/\n-      \/* each; on output, deltas are expanded to `regionIdxCount' shorts *\/\n-      \/* each.                                                           *\/\n+      \/* On input, deltas are (wordDeltaCount + regionIdxCount) bytes    *\/\n+      \/* each if `long_words` isn't set, and twice as much otherwise.    *\/\n+      \/*                                                                 *\/\n+      \/* On output, deltas are expanded to `regionIdxCount` shorts each. *\/\n@@ -591,3 +624,2 @@\n-      \/* the delta set is stored as a 2-dimensional array of shorts; *\/\n-      \/* sign-extend signed bytes to signed shorts                   *\/\n-      for ( j = 0; j < varData->itemCount * varData->regionIdxCount; )\n+      \/* the delta set is stored as a 2-dimensional array of shorts *\/\n+      if ( long_words )\n@@ -595,1 +627,11 @@\n-        for ( k = 0; k < shortDeltaCount; k++, j++ )\n+        \/* new in OpenType 1.9, currently for 'COLR' table only;          *\/\n+        \/* the deltas are interpreted as 16.16 fixed-point scaling values *\/\n+\n+        \/* not supported yet *\/\n+\n+        error = FT_THROW( Invalid_Table );\n+        goto Exit;\n+      }\n+      else\n+      {\n+        for ( j = 0; j < varData->itemCount * varData->regionIdxCount; )\n@@ -597,2 +639,4 @@\n-          \/* read the short deltas *\/\n-          FT_Short  delta;\n+          for ( k = 0; k < wordDeltaCount; k++, j++ )\n+          {\n+            \/* read the short deltas *\/\n+            FT_Short  delta;\n@@ -601,2 +645,2 @@\n-          if ( FT_READ_SHORT( delta ) )\n-            goto Exit;\n+            if ( FT_READ_SHORT( delta ) )\n+              goto Exit;\n@@ -604,2 +648,2 @@\n-          varData->deltaSet[j] = delta;\n-        }\n+            varData->deltaSet[j] = delta;\n+          }\n@@ -607,4 +651,4 @@\n-        for ( ; k < varData->regionIdxCount; k++, j++ )\n-        {\n-          \/* read the (signed) byte deltas *\/\n-          FT_Char  delta;\n+          for ( ; k < varData->regionIdxCount; k++, j++ )\n+          {\n+            \/* read the (signed) byte deltas *\/\n+            FT_Char  delta;\n@@ -613,2 +657,2 @@\n-          if ( FT_READ_CHAR( delta ) )\n-            goto Exit;\n+            if ( FT_READ_CHAR( delta ) )\n+              goto Exit;\n@@ -616,1 +660,2 @@\n-          varData->deltaSet[j] = delta;\n+            varData->deltaSet[j] = delta;\n+          }\n@@ -632,1 +677,2 @@\n-                                       GX_ItemVarStore    itemStore )\n+                                       GX_ItemVarStore    itemStore,\n+                                       FT_ULong           table_len )\n@@ -637,1 +683,1 @@\n-    FT_Error   error;\n+    FT_Error  error;\n@@ -639,5 +685,7 @@\n-    FT_UShort  format;\n-    FT_UInt    entrySize;\n-    FT_UInt    innerBitCount;\n-    FT_UInt    innerIndexMask;\n-    FT_UInt    i, j;\n+    FT_Byte   format;\n+    FT_Byte   entryFormat;\n+    FT_UInt   entrySize;\n+    FT_UInt   innerBitCount;\n+    FT_UInt   innerIndexMask;\n+    FT_ULong  i;\n+    FT_UInt   j;\n@@ -646,3 +694,3 @@\n-    if ( FT_STREAM_SEEK( offset )        ||\n-         FT_READ_USHORT( format )        ||\n-         FT_READ_USHORT( map->mapCount ) )\n+    if ( FT_STREAM_SEEK( offset )    ||\n+         FT_READ_BYTE( format )      ||\n+         FT_READ_BYTE( entryFormat ) )\n@@ -651,1 +699,11 @@\n-    if ( format & 0xFFC0 )\n+    if ( format == 0 )\n+    {\n+      if ( FT_READ_USHORT( map->mapCount ) )\n+        goto Exit;\n+    }\n+    else if ( format == 1 ) \/* new in OpenType 1.9 *\/\n+    {\n+      if ( FT_READ_ULONG( map->mapCount ) )\n+        goto Exit;\n+    }\n+    else\n@@ -658,0 +716,7 @@\n+    if ( entryFormat & 0xC0 )\n+    {\n+      FT_TRACE2(( \"bad entry format %d\\n\", format ));\n+      error = FT_THROW( Invalid_Table );\n+      goto Exit;\n+    }\n+\n@@ -659,2 +724,2 @@\n-    entrySize      = ( ( format & 0x0030 ) >> 4 ) + 1;\n-    innerBitCount  = ( format & 0x000F ) + 1;\n+    entrySize      = ( ( entryFormat & 0x30 ) >> 4 ) + 1;\n+    innerBitCount  = ( entryFormat & 0x0F ) + 1;\n@@ -663,0 +728,9 @@\n+    \/* rough sanity check *\/\n+    if ( map->mapCount * entrySize > table_len )\n+    {\n+      FT_TRACE1(( \"ft_var_load_delta_set_index_mapping:\"\n+                  \" invalid number of delta-set index mappings\\n\" ));\n+      error = FT_THROW( Invalid_Table );\n+      goto Exit;\n+    }\n+\n@@ -691,1 +765,1 @@\n-        FT_TRACE2(( \"outerIndex[%d] == %d out of range\\n\",\n+        FT_TRACE2(( \"outerIndex[%ld] == %d out of range\\n\",\n@@ -704,1 +778,1 @@\n-        FT_TRACE2(( \"innerIndex[%d] == %d out of range\\n\",\n+        FT_TRACE2(( \"innerIndex[%ld] == %d out of range\\n\",\n@@ -829,1 +903,2 @@\n-                &table->itemStore );\n+                &table->itemStore,\n+                table_len );\n@@ -1518,2 +1593,3 @@\n-      FT_TRACE1(( \"ft_var_load_gvar: number of axes in `gvar' and `cvar'\\n\"\n-                  \"                  table are different\\n\" ));\n+      FT_TRACE1(( \"ft_var_load_gvar:\"\n+                  \" number of axes in `gvar' and `cvar'\\n\" ));\n+      FT_TRACE1(( \"                  table are different\\n\" ));\n@@ -1561,1 +1637,1 @@\n-    if ( FT_NEW_ARRAY( blend->glyphoffsets, gvar_head.glyphCount + 1 ) )\n+    if ( FT_QNEW_ARRAY( blend->glyphoffsets, gvar_head.glyphCount + 1 ) )\n@@ -1640,2 +1716,2 @@\n-      if ( FT_NEW_ARRAY( blend->tuplecoords,\n-                         gvar_head.axisCount * gvar_head.globalCoordCount ) )\n+      if ( FT_QNEW_ARRAY( blend->tuplecoords,\n+                          gvar_head.axisCount * gvar_head.globalCoordCount ) )\n@@ -1844,11 +1920,6 @@\n-        FT_TRACE1((\n-          \"ft_var_to_normalized: design coordinate %.5f\\n\"\n-          \"                      is out of range [%.5f;%.5f]; clamping\\n\",\n-          coord \/ 65536.0,\n-          a->minimum \/ 65536.0,\n-          a->maximum \/ 65536.0 ));\n-\n-        if ( coord > a->maximum )\n-          coord = a->maximum;\n-        else\n-          coord = a->minimum;\n+        FT_TRACE1(( \"ft_var_to_normalized: design coordinate %.5f\\n\",\n+                    coord \/ 65536.0 ));\n+        FT_TRACE1(( \"                      is out of range [%.5f;%.5f];\"\n+                    \" clamping\\n\",\n+                    a->minimum \/ 65536.0,\n+                    a->maximum \/ 65536.0 ));\n@@ -1857,5 +1928,3 @@\n-      if ( coord < a->def )\n-        normalized[i] = -FT_DivFix( SUB_LONG( coord, a->def ),\n-                                    SUB_LONG( a->minimum, a->def ) );\n-      else if ( coord > a->def )\n-        normalized[i] = FT_DivFix( SUB_LONG( coord, a->def ),\n+      if ( coord > a->def )\n+        normalized[i] = coord >= a->maximum ?  0x10000L :\n+                        FT_DivFix( SUB_LONG( coord, a->def ),\n@@ -1863,0 +1932,4 @@\n+      else if ( coord < a->def )\n+        normalized[i] = coord <= a->minimum ? -0x10000L :\n+                        FT_DivFix( SUB_LONG( coord, a->def ),\n+                                   SUB_LONG( a->def, a->minimum ) );\n@@ -2052,1 +2125,1 @@\n-    GX_FVar_Head         fvar_head;\n+    GX_FVar_Head         fvar_head  = { 0, 0, 0, 0, 0, 0 };\n@@ -2118,2 +2191,2 @@\n-          FT_TRACE1(( \"\\n\"\n-                      \"TT_Get_MM_Var: `gvar' or `CFF2' table is missing\\n\" ));\n+          FT_TRACE1(( \"\\n\" ));\n+          FT_TRACE1(( \"TT_Get_MM_Var: `gvar' or `CFF2' table is missing\\n\" ));\n@@ -2547,2 +2620,2 @@\n-    FT_TRACE5(( \"TT_Set_MM_Blend:\\n\"\n-                \"  normalized design coordinates:\\n\" ));\n+    FT_TRACE5(( \"TT_Set_MM_Blend:\\n\" ));\n+    FT_TRACE5(( \"  normalized design coordinates:\\n\" ));\n@@ -2555,2 +2628,1 @@\n-        FT_TRACE1(( \"TT_Set_MM_Blend: normalized design coordinate %.5f\\n\"\n-                    \"                 is out of range [-1;1]\\n\",\n+        FT_TRACE1(( \"TT_Set_MM_Blend: normalized design coordinate %.5f\\n\",\n@@ -2558,0 +2630,1 @@\n+        FT_TRACE1(( \"                 is out of range [-1;1]\\n\" ));\n@@ -2655,3 +2728,4 @@\n-    FT_MEM_COPY( blend->normalizedcoords,\n-                 coords,\n-                 num_coords * sizeof ( FT_Fixed ) );\n+    if ( coords )\n+      FT_MEM_COPY( blend->normalizedcoords,\n+                   coords,\n+                   num_coords * sizeof ( FT_Fixed ) );\n@@ -2675,1 +2749,0 @@\n-        face->cvt = NULL;\n@@ -2694,1 +2767,0 @@\n-    face->postscript_name = NULL;\n@@ -2955,2 +3027,2 @@\n-    FT_TRACE5(( \"TT_Set_Var_Design:\\n\"\n-                \"  normalized design coordinates:\\n\" ));\n+    FT_TRACE5(( \"TT_Set_Var_Design:\\n\" ));\n+    FT_TRACE5(( \"  normalized design coordinates:\\n\" ));\n@@ -3155,0 +3227,2 @@\n+#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER\n+\n@@ -3169,0 +3243,3 @@\n+#endif \/* TT_CONFIG_OPTION_BYTECODE_INTERPRETER *\/\n+\n+\n@@ -3197,0 +3274,2 @@\n+#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER\n+\n@@ -3232,2 +3311,2 @@\n-      FT_TRACE2(( \"\\n\"\n-                  \"tt_face_vary_cvt: no blend specified\\n\" ));\n+      FT_TRACE2(( \"\\n\" ));\n+      FT_TRACE2(( \"tt_face_vary_cvt: no blend specified\\n\" ));\n@@ -3240,2 +3319,2 @@\n-      FT_TRACE2(( \"\\n\"\n-                  \"tt_face_vary_cvt: no `cvt ' table\\n\" ));\n+      FT_TRACE2(( \"\\n\" ));\n+      FT_TRACE2(( \"tt_face_vary_cvt: no `cvt ' table\\n\" ));\n@@ -3391,0 +3470,1 @@\n+        localpoints = NULL;\n@@ -3400,3 +3480,1 @@\n-      if ( !points                                                        ||\n-           !deltas                                                        ||\n-           ( localpoints == ALL_POINTS && point_count != face->cvt_size ) )\n+      if ( !points || !deltas )\n@@ -3517,0 +3595,10 @@\n+\n+#else \/* !TT_CONFIG_OPTION_BYTECODE_INTERPRETER *\/\n+\n+    FT_UNUSED( face );\n+    FT_UNUSED( stream );\n+\n+    return FT_Err_Ok;\n+\n+#endif \/* !TT_CONFIG_OPTION_BYTECODE_INTERPRETER *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgxvar.c","additions":204,"deletions":116,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2004-2020 by\n+ * Copyright (C) 2004-2022 by\n@@ -109,3 +109,3 @@\n-    FT_UInt   mapCount;\n-    FT_UInt*  outerIndex;             \/* indices to item var data *\/\n-    FT_UInt*  innerIndex;             \/* indices to delta set     *\/\n+    FT_ULong  mapCount;\n+    FT_UInt*  outerIndex;               \/* indices to item var data *\/\n+    FT_UInt*  innerIndex;               \/* indices to delta set     *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttgxvar.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -254,0 +254,8 @@\n+    \/* free glyf cvt working area *\/\n+    FT_FREE( exec->glyfCvt );\n+    exec->glyfCvtSize = 0;\n+\n+    \/* free glyf storage working area *\/\n+    FT_FREE( exec->glyfStorage );\n+    exec->glyfStoreSize = 0;\n+\n@@ -270,58 +278,0 @@\n-  \/**************************************************************************\n-   *\n-   * @Function:\n-   *   Init_Context\n-   *\n-   * @Description:\n-   *   Initializes a context object.\n-   *\n-   * @Input:\n-   *   memory ::\n-   *     A handle to the parent memory object.\n-   *\n-   * @InOut:\n-   *   exec ::\n-   *     A handle to the target execution context.\n-   *\n-   * @Return:\n-   *   FreeType error code.  0 means success.\n-   *\/\n-  static FT_Error\n-  Init_Context( TT_ExecContext  exec,\n-                FT_Memory       memory )\n-  {\n-    FT_Error  error;\n-\n-\n-    FT_TRACE1(( \"Init_Context: new object at %p\\n\", (void *)exec ));\n-\n-    exec->memory   = memory;\n-    exec->callSize = 32;\n-\n-    if ( FT_NEW_ARRAY( exec->callStack, exec->callSize ) )\n-      goto Fail_Memory;\n-\n-    \/* all values in the context are set to 0 already, but this is *\/\n-    \/* here as a remainder                                         *\/\n-    exec->maxPoints   = 0;\n-    exec->maxContours = 0;\n-\n-    exec->stackSize = 0;\n-    exec->glyphSize = 0;\n-\n-    exec->stack    = NULL;\n-    exec->glyphIns = NULL;\n-\n-    exec->face = NULL;\n-    exec->size = NULL;\n-\n-    return FT_Err_Ok;\n-\n-  Fail_Memory:\n-    FT_ERROR(( \"Init_Context: not enough memory for %p\\n\", (void *)exec ));\n-    TT_Done_Context( exec );\n-\n-    return error;\n- }\n-\n-\n@@ -370,1 +320,1 @@\n-      if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )\n+      if ( FT_QREALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )\n@@ -403,0 +353,2 @@\n+   *\n+   *   Note that not all members of `TT_ExecContext` get initialized.\n@@ -467,1 +419,1 @@\n-    tmp = exec->glyphSize;\n+    tmp = (FT_ULong)exec->glyphSize;\n@@ -473,1 +425,1 @@\n-    exec->glyphSize = (FT_UShort)tmp;\n+    exec->glyphSize = (FT_UInt)tmp;\n@@ -567,0 +519,8 @@\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n+    exec->iup_called  = FALSE;\n+#endif\n+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n+    exec->iupx_called = FALSE;\n+    exec->iupy_called = FALSE;\n+#endif\n+\n@@ -612,1 +572,1 @@\n-    \/* allocate object *\/\n+    \/* allocate object and zero everything inside *\/\n@@ -616,4 +576,3 @@\n-    \/* initialize it; in case of error this deallocates `exec' too *\/\n-    error = Init_Context( exec, memory );\n-    if ( error )\n-      goto Fail;\n+    \/* create callStack here, other allocations delayed *\/\n+    exec->memory   = memory;\n+    exec->callSize = 32;\n@@ -621,1 +580,2 @@\n-    return exec;\n+    if ( FT_QNEW_ARRAY( exec->callStack, exec->callSize ) )\n+      FT_FREE( exec );\n@@ -624,1 +584,1 @@\n-    return NULL;\n+    return exec;\n@@ -1575,0 +1535,21 @@\n+  static void\n+  Modify_CVT_Check( TT_ExecContext  exc )\n+  {\n+    \/* TT_RunIns sets origCvt and restores cvt to origCvt when done. *\/\n+    if ( exc->iniRange == tt_coderange_glyph &&\n+         exc->cvt == exc->origCvt            )\n+    {\n+      exc->error = Update_Max( exc->memory,\n+                               &exc->glyfCvtSize,\n+                               sizeof ( FT_Long ),\n+                               (void*)&exc->glyfCvt,\n+                               exc->cvtSize );\n+      if ( exc->error )\n+        return;\n+\n+      FT_ARRAY_COPY( exc->glyfCvt, exc->cvt, exc->glyfCvtSize );\n+      exc->cvt = exc->glyfCvt;\n+    }\n+  }\n+\n+\n@@ -1580,0 +1561,4 @@\n+    Modify_CVT_Check( exc );\n+    if ( exc->error )\n+      return;\n+\n@@ -1589,0 +1574,4 @@\n+    Modify_CVT_Check( exc );\n+    if ( exc->error )\n+      return;\n+\n@@ -1598,0 +1587,4 @@\n+    Modify_CVT_Check( exc );\n+    if ( exc->error )\n+      return;\n+\n@@ -1607,0 +1600,4 @@\n+    Modify_CVT_Check( exc );\n+    if ( exc->error )\n+      return;\n+\n@@ -3128,0 +3125,22 @@\n+    {\n+      \/* TT_RunIns sets origStorage and restores storage to origStorage *\/\n+      \/* when done.                                                     *\/\n+      if ( exc->iniRange == tt_coderange_glyph &&\n+           exc->storage == exc->origStorage    )\n+      {\n+        FT_ULong  tmp = (FT_ULong)exc->glyfStoreSize;\n+\n+\n+        exc->error = Update_Max( exc->memory,\n+                                 &tmp,\n+                                 sizeof ( FT_Long ),\n+                                 (void*)&exc->glyfStorage,\n+                                 exc->storeSize );\n+        exc->glyfStoreSize = (FT_UShort)tmp;\n+        if ( exc->error )\n+          return;\n+\n+        FT_ARRAY_COPY( exc->glyfStorage, exc->storage, exc->glyfStoreSize );\n+        exc->storage = exc->glyfStorage;\n+      }\n+\n@@ -3129,0 +3148,1 @@\n+    }\n@@ -3528,1 +3548,1 @@\n-    exc->IP += args[0];\n+    exc->IP = ADD_LONG( exc->IP, args[0] );\n@@ -3700,1 +3720,1 @@\n-    if ( exc->curRange == tt_coderange_glyph )\n+    if ( exc->iniRange == tt_coderange_glyph )\n@@ -3774,1 +3794,1 @@\n-              FT_TRACE6(( \"sph: Function %d, opcode ptrn: %d, %s %s\\n\",\n+              FT_TRACE6(( \"sph: Function %d, opcode ptrn: %ld, %s %s\\n\",\n@@ -4136,1 +4156,1 @@\n-    if ( exc->curRange == tt_coderange_glyph )\n+    if ( exc->iniRange == tt_coderange_glyph )\n@@ -4365,1 +4385,1 @@\n-      C = B;   \/* counter clockwise rotation *\/\n+      C = B;   \/* counter-clockwise rotation *\/\n@@ -4994,3 +5014,3 @@\n-    if ( SUBPIXEL_HINTING_INFINALITY &&\n-         exc->ignore_x_mode          &&\n-         FT_ABS( D ) == 64           )\n+    if ( SUBPIXEL_HINTING_INFINALITY         &&\n+         exc->ignore_x_mode                  &&\n+         ( D < 0 ? NEG_LONG( D ) : D ) == 64 )\n@@ -5053,1 +5073,1 @@\n-      C = B;   \/* counter clockwise rotation *\/\n+      C = B;   \/* counter-clockwise rotation *\/\n@@ -5077,1 +5097,1 @@\n-      C = B;   \/* counter clockwise rotation *\/\n+      C = B;   \/* counter-clockwise rotation *\/\n@@ -5251,2 +5271,6 @@\n-    exc->GS.instruct_control &= ~(FT_Byte)Kf;\n-    exc->GS.instruct_control |= (FT_Byte)L;\n+    \/* INSTCTRL should only be used in the CVT program *\/\n+    if ( exc->iniRange == tt_coderange_cvt )\n+    {\n+      exc->GS.instruct_control &= ~(FT_Byte)Kf;\n+      exc->GS.instruct_control |= (FT_Byte)L;\n+    }\n@@ -5254,1 +5278,2 @@\n-    if ( K == 3 )\n+    \/* except to change the subpixel flags temporarily *\/\n+    else if ( exc->iniRange == tt_coderange_glyph && K == 3 )\n@@ -5260,1 +5285,1 @@\n-        exc->ignore_x_mode = FT_BOOL( L == 4 );\n+        exc->ignore_x_mode = !FT_BOOL( L == 4 );\n@@ -5271,0 +5296,2 @@\n+    else if ( exc->pedantic_hinting )\n+      exc->error = FT_THROW( Invalid_Reference );\n@@ -7746,29 +7773,0 @@\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY\n-    exc->iup_called = FALSE;\n-#endif \/* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY *\/\n-\n-#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n-    \/*\n-     * Toggle backward compatibility according to what font wants, except\n-     * when\n-     *\n-     * 1) we have a `tricky' font that heavily relies on the interpreter to\n-     *    render glyphs correctly, for example DFKai-SB, or\n-     * 2) FT_RENDER_MODE_MONO (i.e, monochome rendering) is requested.\n-     *\n-     * In those cases, backward compatibility needs to be turned off to get\n-     * correct rendering.  The rendering is then completely up to the\n-     * font's programming.\n-     *\n-     *\/\n-    if ( SUBPIXEL_HINTING_MINIMAL          &&\n-         exc->subpixel_hinting_lean        &&\n-         !FT_IS_TRICKY( &exc->face->root ) )\n-      exc->backward_compatibility = !( exc->GS.instruct_control & 4 );\n-    else\n-      exc->backward_compatibility = FALSE;\n-\n-    exc->iupx_called = FALSE;\n-    exc->iupy_called = FALSE;\n-#endif\n-\n@@ -7784,2 +7782,2 @@\n-      FT_TRACE5(( \"TT_RunIns: Resetting number of twilight points\\n\"\n-                  \"           from %d to the more reasonable value %ld\\n\",\n+      FT_TRACE5(( \"TT_RunIns: Resetting number of twilight points\\n\" ));\n+      FT_TRACE5(( \"           from %d to the more reasonable value %ld\\n\",\n@@ -7845,0 +7843,4 @@\n+    exc->origCvt     = exc->cvt;\n+    exc->origStorage = exc->storage;\n+    exc->iniRange    = exc->curRange;\n+\n@@ -7853,0 +7855,1 @@\n+      if ( ft_trace_levels[trace_ttinterp] >= 6 )\n@@ -8569,2 +8572,4 @@\n-      if ( ++ins_counter > TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES )\n-        return FT_THROW( Execution_Too_Long );\n+      if ( ++ins_counter > TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES ) {\n+        exc->error = FT_THROW( Execution_Too_Long );\n+        goto LErrorLabel_;\n+      }\n@@ -8589,0 +8594,4 @@\n+\n+    exc->cvt     = exc->origCvt;\n+    exc->storage = exc->origStorage;\n+\n@@ -8598,0 +8607,3 @@\n+    exc->cvt     = exc->origCvt;\n+    exc->storage = exc->origStorage;\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttinterp.c","additions":128,"deletions":116,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -147,0 +147,3 @@\n+   *\n+   * Members that are initialized by `TT_Load_Context` are marked with '!'.\n+   * Members that are initialized by `TT_Run_Context` are marked with '@'.\n@@ -150,2 +153,2 @@\n-    TT_Face            face;\n-    TT_Size            size;\n+    TT_Face            face;       \/* ! *\/\n+    TT_Size            size;       \/* ! *\/\n@@ -158,1 +161,1 @@\n-    FT_Long            top;        \/* top of exec. stack   *\/\n+    FT_Long            top;        \/* @ top of exec. stack *\/\n@@ -160,2 +163,2 @@\n-    FT_Long            stackSize;  \/* size of exec. stack  *\/\n-    FT_Long*           stack;      \/* current exec. stack  *\/\n+    FT_Long            stackSize;  \/* ! size of exec. stack *\/\n+    FT_Long*           stack;      \/* ! current exec. stack *\/\n@@ -164,1 +167,1 @@\n-    FT_Long            new_top;    \/* new top after exec.  *\/\n+    FT_Long            new_top;    \/* new top after exec. *\/\n@@ -166,5 +169,5 @@\n-    TT_GlyphZoneRec    zp0,        \/* zone records *\/\n-                       zp1,\n-                       zp2,\n-                       pts,\n-                       twilight;\n+    TT_GlyphZoneRec    zp0,        \/* @! zone records *\/\n+                       zp1,        \/* @!              *\/\n+                       zp2,        \/* @!              *\/\n+                       pts,        \/*  !              *\/\n+                       twilight;   \/*  !              *\/\n@@ -172,3 +175,3 @@\n-    FT_Long            pointSize;  \/* in 26.6 format *\/\n-    FT_Size_Metrics    metrics;\n-    TT_Size_Metrics    tt_metrics; \/* size metrics *\/\n+    FT_Long            pointSize;  \/* ! in 26.6 format *\/\n+    FT_Size_Metrics    metrics;    \/* !                *\/\n+    TT_Size_Metrics    tt_metrics; \/* ! size metrics   *\/\n@@ -176,1 +179,1 @@\n-    TT_GraphicsState   GS;         \/* current graphics state *\/\n+    TT_GraphicsState   GS;         \/* !@ current graphics state *\/\n@@ -178,0 +181,1 @@\n+    FT_Int             iniRange;  \/* initial code range number   *\/\n@@ -188,2 +192,5 @@\n-    FT_ULong           cvtSize;\n-    FT_Long*           cvt;\n+    FT_ULong           cvtSize;   \/* ! *\/\n+    FT_Long*           cvt;       \/* ! *\/\n+    FT_ULong           glyfCvtSize;\n+    FT_Long*           glyfCvt;   \/* cvt working copy for glyph *\/\n+    FT_Long*           origCvt;\n@@ -191,2 +198,2 @@\n-    FT_UInt            glyphSize; \/* glyph instructions buffer size *\/\n-    FT_Byte*           glyphIns;  \/* glyph instructions buffer *\/\n+    FT_UInt            glyphSize; \/* ! glyph instructions buffer size *\/\n+    FT_Byte*           glyphIns;  \/* ! glyph instructions buffer      *\/\n@@ -194,3 +201,3 @@\n-    FT_UInt            numFDefs;  \/* number of function defs         *\/\n-    FT_UInt            maxFDefs;  \/* maximum number of function defs *\/\n-    TT_DefArray        FDefs;     \/* table of FDefs entries          *\/\n+    FT_UInt            numFDefs;  \/* ! number of function defs         *\/\n+    FT_UInt            maxFDefs;  \/* ! maximum number of function defs *\/\n+    TT_DefArray        FDefs;     \/*   table of FDefs entries          *\/\n@@ -198,3 +205,3 @@\n-    FT_UInt            numIDefs;  \/* number of instruction defs *\/\n-    FT_UInt            maxIDefs;  \/* maximum number of ins defs *\/\n-    TT_DefArray        IDefs;     \/* table of IDefs entries     *\/\n+    FT_UInt            numIDefs;  \/* ! number of instruction defs *\/\n+    FT_UInt            maxIDefs;  \/* ! maximum number of ins defs *\/\n+    TT_DefArray        IDefs;     \/*   table of IDefs entries     *\/\n@@ -202,2 +209,2 @@\n-    FT_UInt            maxFunc;   \/* maximum function index     *\/\n-    FT_UInt            maxIns;    \/* maximum instruction index  *\/\n+    FT_UInt            maxFunc;   \/* ! maximum function index    *\/\n+    FT_UInt            maxIns;    \/* ! maximum instruction index *\/\n@@ -205,3 +212,3 @@\n-    FT_Int             callTop,    \/* top of call stack during execution *\/\n-                       callSize;   \/* size of call stack *\/\n-    TT_CallStack       callStack;  \/* call stack *\/\n+    FT_Int             callTop,    \/* @ top of call stack during execution *\/\n+                       callSize;   \/*   size of call stack                 *\/\n+    TT_CallStack       callStack;  \/*   call stack                         *\/\n@@ -213,2 +220,2 @@\n-    TT_CodeRangeTable  codeRangeTable;  \/* table of valid code ranges *\/\n-                                        \/* useful for the debugger   *\/\n+    TT_CodeRangeTable  codeRangeTable;  \/* ! table of valid code ranges *\/\n+                                        \/*   useful for the debugger    *\/\n@@ -216,2 +223,5 @@\n-    FT_UShort          storeSize;  \/* size of current storage *\/\n-    FT_Long*           storage;    \/* storage area            *\/\n+    FT_UShort          storeSize;    \/* ! size of current storage *\/\n+    FT_Long*           storage;      \/* ! storage area            *\/\n+    FT_UShort          glyfStoreSize;\n+    FT_Long*           glyfStorage;  \/* storage working copy for glyph *\/\n+    FT_Long*           origStorage;\n@@ -223,2 +233,2 @@\n-    FT_Bool            instruction_trap; \/* If `True', the interpreter will *\/\n-                                         \/* exit after each instruction     *\/\n+    FT_Bool            instruction_trap; \/* ! If `True', the interpreter   *\/\n+                                         \/*   exits after each instruction *\/\n@@ -241,1 +251,1 @@\n-    TT_Move_Func       func_move;      \/* current point move function *\/\n+    TT_Move_Func       func_move;      \/* current point move function     *\/\n@@ -472,3 +482,2 @@\n-   *   Queries the face context for a given font.  Note that there is\n-   *   now a _single_ execution context in the TrueType driver which is\n-   *   shared among faces.\n+   *   Create a `TT_ExecContext`.  Note that there is now an execution\n+   *   context per `TT_Size` that is not shared among faces.\n@@ -477,2 +486,2 @@\n-   *   face ::\n-   *     A handle to the source face object.\n+   *   driver ::\n+   *     A handle to the driver, used for memory allocation.\n@@ -481,1 +490,1 @@\n-   *   A handle to the execution context.  Initialized for `face'.\n+   *   A handle to a new empty execution context.\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttinterp.h","additions":53,"deletions":44,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -143,1 +143,25 @@\n-#endif \/* TT_USE_BYTECODE_INTERPRETER *\/\n+\n+\n+  \/*\n+   * Fonts embedded in PDFs are made unique by prepending randomization\n+   * prefixes to their names: as defined in Section 5.5.3, 'Font Subsets',\n+   * of the PDF Reference, they consist of 6 uppercase letters followed by\n+   * the `+` sign.  For safety, we do not skip prefixes violating this rule.\n+   *\/\n+\n+  static const FT_String*\n+  tt_skip_pdffont_random_tag( const FT_String*  name )\n+  {\n+    unsigned int  i;\n+\n+\n+    if ( ft_strlen( name ) < 8 || name[6] != '+' )\n+      return name;\n+\n+    for ( i = 0; i < 6; i++ )\n+      if ( !ft_isupper( name[i] ) )\n+        return name;\n+\n+    FT_TRACE7(( \"name without randomization tag: %s\\n\", name + 7 ));\n+    return name + 7;\n+  }\n@@ -154,1 +178,1 @@\n-#define TRICK_NAMES_COUNT           26\n+#define TRICK_NAMES_COUNT           20\n@@ -174,1 +198,3 @@\n-      \"DFHei-Md-HK-BF\",     \/* maybe DynaLab Inc. *\/\n+      \"DFHei\",              \/* DynaLab Inc. 1992-1995 [DFHei-Bd-WIN-HK-BF] *\/\n+                            \/* covers \"DFHei-Md-HK-BF\", maybe DynaLab Inc. *\/\n+\n@@ -179,2 +205,1 @@\n-      \"DFKaiShu\",\n-      \"DFKaiShu-Md-HK-BF\",  \/* maybe DynaLab Inc. *\/\n+      \"DFKaiShu\",           \/* covers \"DFKaiShu-Md-HK-BF\", maybe DynaLab Inc. *\/\n@@ -182,1 +207,4 @@\n-      \"DFMing-Bd-HK-BF\",    \/* maybe DynaLab Inc. *\/\n+\n+      \"DFMing\",             \/* DynaLab Inc. 1992-1995 [DFMing-Md-WIN-HK-BF] *\/\n+                            \/* covers \"DFMing-Bd-HK-BF\", maybe DynaLab Inc. *\/\n+\n@@ -185,5 +213,7 @@\n-      \"DLCHayMedium\",       \/* dftt-b5.ttf; version 1.00, 1993 *\/\n-      \"DLCHayBold\",         \/* dftt-b7.ttf; version 1.00, 1993 *\/\n-      \"DLCKaiMedium\",       \/* dftt-k5.ttf; version 1.00, 1992 *\/\n-      \"DLCLiShu\",           \/* dftt-l5.ttf; version 1.00, 1992 *\/\n-      \"DLCRoundBold\",       \/* dftt-r7.ttf; version 1.00, 1993 *\/\n+                            \/* covers following *\/\n+                            \/* \"DLCHayMedium\", dftt-b5.ttf; version 1.00, 1993 *\/\n+                            \/* \"DLCHayBold\",   dftt-b7.ttf; version 1.00, 1993 *\/\n+                            \/* \"DLCKaiMedium\", dftt-k5.ttf; version 1.00, 1992 *\/\n+                            \/* \"DLCLiShu\",     dftt-l5.ttf; version 1.00, 1992 *\/\n+                            \/* \"DLCRoundBold\", dftt-r7.ttf; version 1.00, 1993 *\/\n+\n@@ -202,0 +232,1 @@\n+    const FT_String*  name_without_tag;\n@@ -204,0 +235,1 @@\n+    name_without_tag = tt_skip_pdffont_random_tag( name );\n@@ -205,1 +237,1 @@\n-      if ( ft_strstr( name, trick_names[nn] ) )\n+      if ( ft_strstr( name_without_tag, trick_names[nn] ) )\n@@ -280,1 +312,1 @@\n-#define TRICK_SFNT_IDS_NUM_FACES  29\n+#define TRICK_SFNT_IDS_NUM_FACES  31\n@@ -433,0 +465,10 @@\n+      },\n+        { \/* DFHei-Bd-WIN-HK-BF, issue #1087 *\/\n+        { 0x1269EB58UL, 0x00000350UL }, \/* cvt  *\/\n+        { 0x5CD5957AUL, 0x00006A4EUL }, \/* fpgm *\/\n+        { 0xF758323AUL, 0x00000380UL }  \/* prep *\/\n+      },\n+        { \/* DFMing-Md-WIN-HK-BF, issue #1087 *\/\n+        { 0x122FEB0BUL, 0x00000350UL }, \/* cvt  *\/\n+        { 0x7F10919AUL, 0x000070A9UL }, \/* fpgm *\/\n+        { 0x7CD7E7B7UL, 0x0000025CUL }  \/* prep *\/\n@@ -513,0 +555,3 @@\n+    {\n+      FT_TRACE3(( \"found as a tricky font\"\n+                  \" by its family name: %s\\n\", face->family_name ));\n@@ -514,0 +559,1 @@\n+    }\n@@ -519,0 +565,3 @@\n+    {\n+      FT_TRACE3(( \"found as a tricky font\"\n+                  \" by its cvt\/fpgm\/prep table checksum\\n\" ));\n@@ -520,0 +569,1 @@\n+    }\n@@ -524,0 +574,2 @@\n+#endif \/* TT_USE_BYTECODE_INTERPRETER *\/\n+\n@@ -669,0 +721,1 @@\n+#ifdef TT_USE_BYTECODE_INTERPRETER\n@@ -671,0 +724,1 @@\n+#endif\n@@ -676,1 +730,2 @@\n-    if ( FT_IS_SCALABLE( ttface ) )\n+    if ( FT_IS_SCALABLE( ttface ) ||\n+         FT_HAS_SBIX( ttface )    )\n@@ -715,2 +770,2 @@\n-                      \" Only the `.notdef' glyph has an outline.\\n\"\n-                      \"             \"\n+                      \" Only the `.notdef' glyph has an outline.\\n\" ));\n+          FT_TRACE5(( \"             \"\n@@ -1193,1 +1248,1 @@\n-      FT_UInt  i;\n+      FT_UShort  i;\n@@ -1197,1 +1252,1 @@\n-      for ( i = 0; i < (FT_UInt)size->twilight.n_points; i++ )\n+      for ( i = 0; i < size->twilight.n_points; i++ )\n@@ -1206,1 +1261,1 @@\n-      for ( i = 0; i < (FT_UInt)size->storage_size; i++ )\n+      for ( i = 0; i < size->storage_size; i++ )\n@@ -1384,0 +1439,2 @@\n+    size->widthp = tt_face_get_device_metrics( face, size_metrics->x_ppem, 0 );\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttobjs.c","additions":77,"deletions":20,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -285,0 +285,2 @@\n+    FT_Byte*           widthp;          \/* glyph widths from the hdmx table *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttobjs.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -101,3 +101,1 @@\n-    if ( face->header.Index_To_Loc_Format != 0 )\n-    {\n-      shift = 2;\n+    shift = face->header.Index_To_Loc_Format != 0 ? 2 : 1;\n@@ -105,8 +103,1 @@\n-      if ( table_len >= 0x40000L )\n-      {\n-        FT_TRACE2(( \"table too large\\n\" ));\n-        table_len = 0x3FFFFL;\n-      }\n-      face->num_locations = table_len >> shift;\n-    }\n-    else\n+    if ( table_len > 0x10000UL << shift )\n@@ -114,8 +105,2 @@\n-      shift = 1;\n-\n-      if ( table_len >= 0x20000L )\n-      {\n-        FT_TRACE2(( \"table too large\\n\" ));\n-        table_len = 0x1FFFFL;\n-      }\n-      face->num_locations = table_len >> shift;\n+      FT_TRACE2(( \"table too large\\n\" ));\n+      table_len = 0x10000UL << shift;\n@@ -124,0 +109,2 @@\n+    face->num_locations = table_len >> shift;\n+\n@@ -130,1 +117,1 @@\n-      if ( face->num_locations <= (FT_ULong)face->root.num_glyphs )\n+      if ( face->num_locations < (FT_ULong)face->root.num_glyphs + 1 )\n@@ -240,2 +227,3 @@\n-                  \" too large offset (0x%08lx) found for glyph index %d,\\n\"\n-                  \"                     \"\n+                  \" too large offset (0x%08lx) found for glyph index %d,\\n\",\n+                  pos1, gindex ));\n+      FT_TRACE1(( \"                     \"\n@@ -243,1 +231,1 @@\n-                  pos1, gindex, face->glyf_len ));\n+                  face->glyf_len ));\n@@ -254,2 +242,3 @@\n-                    \" too large size (%ld bytes) found for glyph index %d,\\n\"\n-                    \"                     \"\n+                    \" too large size (%ld bytes) found for glyph index %d,\\n\",\n+                    pos2 - pos1, gindex ));\n+        FT_TRACE1(( \"                     \"\n@@ -257,1 +246,1 @@\n-                    pos2 - pos1, gindex, face->glyf_len - pos1 ));\n+                    face->glyf_len - pos1 ));\n@@ -263,2 +252,3 @@\n-                    \" too large offset (0x%08lx) found for glyph index %d,\\n\"\n-                    \"                     \"\n+                    \" too large offset (0x%08lx) found for glyph index %d,\\n\",\n+                    pos2, gindex + 1 ));\n+        FT_TRACE1(( \"                     \"\n@@ -266,1 +256,1 @@\n-                    pos2, gindex + 1, face->glyf_len ));\n+                    face->glyf_len ));\n@@ -347,1 +337,1 @@\n-    if ( FT_NEW_ARRAY( face->cvt, face->cvt_size ) )\n+    if ( FT_QNEW_ARRAY( face->cvt, face->cvt_size ) )\n@@ -511,0 +501,8 @@\n+  FT_COMPARE_DEF( int )\n+  compare_ppem( const void*  a,\n+                const void*  b )\n+  {\n+    return **(FT_Byte**)a - **(FT_Byte**)b;\n+  }\n+\n+\n@@ -560,6 +558,0 @@\n-    \/* The maximum number of bytes in an hdmx device record is the *\/\n-    \/* maximum number of glyphs + 2; this is 0xFFFF + 2, thus      *\/\n-    \/* explaining why `record_size' is a long (which we read as    *\/\n-    \/* unsigned long for convenience).  In practice, two bytes are *\/\n-    \/* sufficient to hold the size value.                          *\/\n-    \/*                                                             *\/\n@@ -574,0 +566,2 @@\n+    FT_TRACE2(( \"Hdmx \" ));\n+\n@@ -575,4 +569,9 @@\n-    if ( num_records > 255              ||\n-         ( num_records > 0            &&\n-           ( record_size > 0x10001L ||\n-             record_size < 4        ) ) )\n+    if ( num_records > 255 || num_records == 0 )\n+    {\n+      FT_TRACE2(( \"with unreasonable %u records rejected\\n\", num_records ));\n+      goto Fail;\n+    }\n+\n+    \/* Out-of-spec tables are rejected.  The record size must be *\/\n+    \/* equal to the number of glyphs + 2 + 32-bit padding.       *\/\n+    if ( (FT_Long)record_size != ( ( face->root.num_glyphs + 2 + 3 ) & ~3 ) )\n@@ -580,1 +579,3 @@\n-      error = FT_THROW( Invalid_File_Format );\n+      FT_TRACE2(( \"with record size off by %ld bytes rejected\\n\",\n+                  (FT_Long)record_size -\n+                    ( ( face->root.num_glyphs + 2 + 3 ) & ~3 ) ));\n@@ -584,1 +585,1 @@\n-    if ( FT_NEW_ARRAY( face->hdmx_record_sizes, num_records ) )\n+    if ( FT_QNEW_ARRAY( face->hdmx_records, num_records ) )\n@@ -591,3 +592,2 @@\n-\n-      face->hdmx_record_sizes[nn] = p[0];\n-      p                          += record_size;\n+      face->hdmx_records[nn] = p;\n+      p                     += record_size;\n@@ -596,0 +596,4 @@\n+    \/* The records must be already sorted by ppem but it does not *\/\n+    \/* hurt to make sure so that the binary search works later.   *\/\n+    ft_qsort( face->hdmx_records, nn, sizeof ( FT_Byte* ), compare_ppem );\n+\n@@ -600,0 +604,2 @@\n+    FT_TRACE2(( \"%ux%lu loaded\\n\", num_records, record_size ));\n+\n@@ -617,1 +623,1 @@\n-    FT_FREE( face->hdmx_record_sizes );\n+    FT_FREE( face->hdmx_records );\n@@ -625,1 +631,2 @@\n-   * in the font's `hdmx' table (if any).\n+   * in the font's `hdmx' table (if any).  The records must be sorted for\n+   * the binary search to work properly.\n@@ -632,4 +639,5 @@\n-    FT_UInt   nn;\n-    FT_Byte*  result      = NULL;\n-    FT_ULong  record_size = face->hdmx_record_size;\n-    FT_Byte*  record      = FT_OFFSET( face->hdmx_table, 8 );\n+    FT_UInt   min    = 0;\n+    FT_UInt   max    = face->hdmx_record_count;\n+    FT_UInt   mid;\n+    FT_Byte*  result = NULL;\n+\n@@ -637,0 +645,3 @@\n+    while ( min < max )\n+    {\n+      mid = ( min + max ) >> 1;\n@@ -638,2 +649,5 @@\n-    for ( nn = 0; nn < face->hdmx_record_count; nn++ )\n-      if ( face->hdmx_record_sizes[nn] == ppem )\n+      if ( face->hdmx_records[mid][0] > ppem )\n+        max = mid;\n+      else if ( face->hdmx_records[mid][0] < ppem )\n+        min = mid + 1;\n+      else\n@@ -641,3 +655,1 @@\n-        gindex += 2;\n-        if ( gindex < record_size )\n-          result = record + nn * record_size + gindex;\n+        result = face->hdmx_records[mid] + 2 + gindex;\n@@ -646,0 +658,1 @@\n+    }\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttpload.c","additions":70,"deletions":57,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttpload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2010-2020 by\n+ * Copyright (C) 2010-2022 by\n@@ -318,1 +318,1 @@\n-    \/* fix vwxyz thinness*\/\n+    \/* fix vwxyz thinness *\/\n@@ -894,1 +894,1 @@\n-    loader->exec->sph_tweak_flags |= SPH_TWEAK_##x;\n+    loader->exec->sph_tweak_flags |= SPH_TWEAK_##x\n@@ -899,1 +899,1 @@\n-    loader->exec->sph_tweak_flags &= ~SPH_TWEAK_##x;\n+    loader->exec->sph_tweak_flags &= ~SPH_TWEAK_##x\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttsubpix.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2010-2020 by\n+ * Copyright (C) 2010-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/truetype\/ttsubpix.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -86,1 +86,1 @@\n-  FT_CALLBACK_DEF( int )\n+  FT_COMPARE_DEF( int )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1afm.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1afm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1driver.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1driver.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 2001-2020 by\n+ * Copyright (C) 2001-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1errors.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -82,1 +82,1 @@\n-      char_string->length  = (FT_Int)type1->charstrings_len[glyph_index];\n+      char_string->length  = type1->charstrings_len[glyph_index];\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1gload.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1gload.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -120,0 +120,3 @@\n+      blend->weight_vector             = NULL;\n+      blend->default_weight_vector     = NULL;\n+      blend->design_pos[0]             = NULL;\n@@ -133,4 +136,3 @@\n-        if ( FT_NEW_ARRAY( blend->font_infos[1], num_designs     ) ||\n-             FT_NEW_ARRAY( blend->privates  [1], num_designs     ) ||\n-             FT_NEW_ARRAY( blend->bboxes    [1], num_designs     ) ||\n-             FT_NEW_ARRAY( blend->weight_vector, num_designs * 2 ) )\n+        if ( FT_NEW_ARRAY( blend->font_infos[1], num_designs ) ||\n+             FT_NEW_ARRAY( blend->privates  [1], num_designs ) ||\n+             FT_NEW_ARRAY( blend->bboxes    [1], num_designs ) )\n@@ -139,2 +141,0 @@\n-        blend->default_weight_vector = blend->weight_vector + num_designs;\n-\n@@ -167,15 +167,0 @@\n-    \/* allocate the blend design pos table if needed *\/\n-    num_designs = blend->num_designs;\n-    num_axis    = blend->num_axis;\n-    if ( num_designs && num_axis && blend->design_pos[0] == 0 )\n-    {\n-      FT_UInt  n;\n-\n-\n-      if ( FT_NEW_ARRAY( blend->design_pos[0], num_designs * num_axis ) )\n-        goto Exit;\n-\n-      for ( n = 1; n < num_designs; n++ )\n-        blend->design_pos[n] = blend->design_pos[0] + num_axis * n;\n-    }\n-\n@@ -583,1 +568,1 @@\n-    FT_UInt   n, p;\n+    FT_UInt   n;\n@@ -602,1 +587,1 @@\n-      FT_Int        before  = -1, after = -1;\n+      FT_Int        p, before  = -1, after = -1;\n@@ -611,1 +596,1 @@\n-      for ( p = 0; p < (FT_UInt)map->num_points; p++ )\n+      for ( p = 0; p < (FT_Int)map->num_points; p++ )\n@@ -625,1 +610,1 @@\n-          after = (FT_Int)p;\n+          after = p;\n@@ -629,1 +614,1 @@\n-        before = (FT_Int)p;\n+        before = p;\n@@ -854,1 +839,1 @@\n-      if ( FT_ALLOC( blend->axis_names[n], len + 1 ) )\n+      if ( FT_QALLOC( blend->axis_names[n], len + 1 ) )\n@@ -875,2 +860,5 @@\n-    FT_Int       num_axis;\n-    T1_Parser    parser = &loader->parser;\n+    FT_Int       num_axis = 0; \/* make compiler happy *\/\n+    T1_Parser    parser   = &loader->parser;\n+    FT_Memory    memory   = face->root.memory;\n+    FT_Error     error    = FT_Err_Ok;\n+    FT_Fixed*    design_pos[T1_MAX_MM_DESIGNS];\n@@ -878,2 +866,0 @@\n-    FT_Error     error = FT_Err_Ok;\n-    PS_Blend     blend;\n@@ -881,0 +867,1 @@\n+    design_pos[0] = NULL;\n@@ -902,1 +889,2 @@\n-      FT_Int    n;\n+      FT_Int    n, nn;\n+      PS_Blend  blend;\n@@ -905,3 +893,0 @@\n-      blend    = face->blend;\n-      num_axis = 0;  \/* make compiler happy *\/\n-\n@@ -940,1 +925,7 @@\n-          blend = face->blend;\n+\n+          \/* allocate a blend design pos table *\/\n+          if ( FT_QNEW_ARRAY( design_pos[0], num_designs * num_axis ) )\n+            goto Exit;\n+\n+          for ( nn = 1; nn < num_designs; nn++ )\n+            design_pos[nn] = design_pos[0] + num_axis * nn;\n@@ -958,2 +949,2 @@\n-          blend->design_pos[n][axis] = T1_ToFixed( parser, 0 );\n-          FT_TRACE4(( \" %f\", (double)blend->design_pos[n][axis] \/ 65536 ));\n+          design_pos[n][axis] = T1_ToFixed( parser, 0 );\n+          FT_TRACE4(( \" %f\", (double)design_pos[n][axis] \/ 65536 ));\n@@ -968,0 +959,11 @@\n+\n+      \/* a valid BlendDesignPosition has been parsed *\/\n+      blend = face->blend;\n+      if ( blend->design_pos[0] )\n+        FT_FREE( blend->design_pos[0] );\n+\n+      for ( n = 0; n < num_designs; n++ )\n+      {\n+        blend->design_pos[n] = design_pos[n];\n+        design_pos[n]        = NULL;\n+      }\n@@ -971,0 +973,1 @@\n+    FT_FREE( design_pos[0] );\n@@ -1047,1 +1050,1 @@\n-      if ( FT_NEW_ARRAY( map->design_points, num_points * 2 ) )\n+      if ( FT_QNEW_ARRAY( map->design_points, num_points * 2 ) )\n@@ -1091,0 +1094,1 @@\n+    FT_Memory    memory = face->root.memory;\n@@ -1125,2 +1129,2 @@\n-                 \" \/BlendDesignPosition and \/WeightVector have\\n\"\n-                 \"                    \"\n+                 \" \/BlendDesignPosition and \/WeightVector have\\n\" ));\n+      FT_ERROR(( \"                    \"\n@@ -1132,0 +1136,6 @@\n+    if ( !blend->weight_vector )\n+      if ( FT_QNEW_ARRAY( blend->weight_vector, num_designs * 2 ) )\n+        goto Exit;\n+\n+    blend->default_weight_vector = blend->weight_vector + num_designs;\n+\n@@ -1310,2 +1320,1 @@\n-                  \" which is not valid at this point\\n\"\n-                  \"                 (probably due to missing keywords)\\n\",\n+                  \" which is not valid at this point\\n\",\n@@ -1313,0 +1322,1 @@\n+      FT_TRACE1(( \"                 (probably due to missing keywords)\\n\" ));\n@@ -1523,2 +1533,2 @@\n-      if ( FT_NEW_ARRAY( encode->char_index, array_size )     ||\n-           FT_NEW_ARRAY( encode->char_name,  array_size )     ||\n+      if ( FT_QNEW_ARRAY( encode->char_index, array_size )    ||\n+           FT_QNEW_ARRAY( encode->char_name,  array_size )    ||\n@@ -1765,1 +1775,1 @@\n-        if ( FT_NEW( loader->subrs_hash ) )\n+        if ( FT_QNEW( loader->subrs_hash ) )\n@@ -1861,1 +1871,1 @@\n-        if ( FT_ALLOC( temp, size ) )\n+        if ( FT_QALLOC( temp, size ) )\n@@ -2071,1 +2081,1 @@\n-          if ( FT_ALLOC( temp, size ) )\n+          if ( FT_QALLOC( temp, size ) )\n@@ -2581,1 +2591,9 @@\n-    \/* another safety check *\/\n+    \/* the font may have no valid WeightVector *\/\n+    if ( face->blend && !face->blend->weight_vector )\n+      T1_Done_Blend( face );\n+\n+    \/* the font may have no valid BlendDesignPositions *\/\n+    if ( face->blend && !face->blend->design_pos[0] )\n+      T1_Done_Blend( face );\n+\n+    \/* the font may have no valid BlendDesignMap *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1load.c","additions":68,"deletions":50,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1load.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -119,0 +119,2 @@\n+    FT_Error  error;\n+\n@@ -123,1 +125,3 @@\n-    FT_Request_Metrics( size->root.face, req );\n+    error = FT_Request_Metrics( size->root.face, req );\n+    if ( error )\n+      goto Exit;\n@@ -131,1 +135,2 @@\n-    return FT_Err_Ok;\n+  Exit:\n+    return error;\n@@ -220,1 +225,0 @@\n-      face->buildchar     = NULL;\n@@ -601,3 +605,0 @@\n-#ifdef T1_CONFIG_OPTION_OLD_ENGINE\n-    driver->hinting_engine = FT_HINTING_FREETYPE;\n-#else\n@@ -605,1 +606,0 @@\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1objs.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1objs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n@@ -224,1 +224,1 @@\n-      if ( FT_ALLOC( parser->base_dict, size )       ||\n+      if ( FT_QALLOC( parser->base_dict, size )      ||\n@@ -305,2 +305,2 @@\n-      if ( FT_STREAM_SEEK( start_pos )                           ||\n-           FT_ALLOC( parser->private_dict, parser->private_len ) )\n+      if ( FT_STREAM_SEEK( start_pos )                            ||\n+           FT_QALLOC( parser->private_dict, parser->private_len ) )\n@@ -453,1 +453,1 @@\n-        if ( FT_ALLOC( parser->private_dict, size + 1 ) )\n+        if ( FT_QALLOC( parser->private_dict, size + 1 ) )\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1parse.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1parse.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * Copyright (C) 1996-2020 by\n+ * Copyright (C) 1996-2022 by\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/type1\/t1tokens.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}