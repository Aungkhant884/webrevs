{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run main MultiThreadTest\n@@ -43,0 +44,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -45,0 +48,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -46,0 +51,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -54,1 +60,1 @@\n-    static Object threadlock = new Object ();\n+    static final Object threadlock = new Object ();\n@@ -56,0 +62,5 @@\n+    \/\/ KEEP_ALIVE sent by the server\n+    static final int KEEP_ALIVE = 1; \/\/ seconds\n+    \/\/ The sending thread will sleep for this time after sending\n+    \/\/ half the number of its requests\n+    static final int SLEEP = KEEP_ALIVE * 1000 + 500; \/\/ ms\n@@ -66,0 +77,3 @@\n+    \/\/ Set to true after all requests have been sent\n+    static final AtomicBoolean DONE = new AtomicBoolean();\n+\n@@ -82,3 +96,4 @@\n-    String uri;\n-    byte[] b;\n-    int requests;\n+    final String uri;\n+    final byte[] b;\n+    final int requests;\n+    final CountDownLatch countDown;\n@@ -86,1 +101,2 @@\n-    MultiThreadTest(String authority, int requests) throws Exception {\n+    MultiThreadTest(String authority, int requests, CountDownLatch latch) throws Exception {\n+        countDown = latch;\n@@ -88,1 +104,0 @@\n-\n@@ -91,4 +106,0 @@\n-\n-        synchronized (threadlock) {\n-            threadCounter ++;\n-        }\n@@ -99,1 +110,0 @@\n-\n@@ -103,0 +113,4 @@\n+                \/\/ sleep after sending half of the requests, that\n+                \/\/ should cause the connections to be closed as idle\n+                \/\/ if sleeping more than KeepAlive.\n+                if (i == requests\/2) Thread.sleep(SLEEP);\n@@ -107,6 +121,1 @@\n-            synchronized (threadlock) {\n-                threadCounter --;\n-                if (threadCounter == 0) {\n-                    threadlock.notifyAll();\n-                }\n-            }\n+            countDown.countDown();\n@@ -114,1 +123,2 @@\n-        debug(\"client: end - \" + Duration.ofNanos(System.nanoTime() - start));\n+        debug(\"client: end at \" + at() + \"ms, thread duration \"\n+                + Duration.ofNanos(System.nanoTime() - start).toMillis() + \"ms\");\n@@ -118,0 +128,11 @@\n+    \/\/ time at which main() started its work.\n+    static volatile long MAIN_START;\n+\n+    \/\/ number of millis since MAIN_START\n+    public static long at() {\n+        return at(System.nanoTime());\n+    }\n+    \/\/ number of millis between MAIN_START and the given time stamp\n+    public static long at(long nanoTime) {\n+        return Duration.ofNanos(nanoTime - MAIN_START).toMillis();\n+    }\n@@ -141,0 +162,1 @@\n+        var latch = new CountDownLatch(threads);\n@@ -142,5 +164,8 @@\n-        Object lock = MultiThreadTest.getLock();\n-        synchronized (lock) {\n-            for (int i=0; i<threads; i++) {\n-                MultiThreadTest t = new MultiThreadTest(svr.getAuthority(), requests);\n-                t.start ();\n+        MAIN_START = System.nanoTime();\n+        try {\n+            Object lock = MultiThreadTest.getLock();\n+            List<MultiThreadTest> tests = new ArrayList<>();\n+            for (int i = 0; i < threads; i++) {\n+                MultiThreadTest t = new MultiThreadTest(svr.getAuthority(), requests, latch);\n+                tests.add(t);\n+                t.start();\n@@ -148,4 +173,0 @@\n-            try {\n-                lock.wait();\n-            } catch (InterruptedException e) {}\n-        }\n@@ -153,16 +174,39 @@\n-        \/\/ shutdown server - we're done.\n-        svr.shutdown();\n-\n-        int cnt = svr.connectionCount();\n-        MultiThreadTest.debug(\"Connections = \" + cnt);\n-        int reqs = Worker.getRequests ();\n-        MultiThreadTest.debug(\"Requests = \" + reqs);\n-        System.out.println (\"Connection count = \" + cnt + \" Request count = \" + reqs);\n-\n-        \/\/ We may have received traffic from something else than\n-        \/\/ our client. We should only count those workers for which\n-        \/\/ the expected header has been found.\n-        int validConnections = 0;\n-        for (Worker w : svr.workers()) {\n-            if (w.headerFound) validConnections++;\n-        }\n+            latch.await();\n+            long end = System.nanoTime();\n+            DONE.compareAndSet(false, true);\n+            for (var test : tests) test.join();\n+\n+            MultiThreadTest.debug(\"DONE at \" + at(end) + \"ms\");\n+\n+            \/\/ shutdown server - we're done.\n+            svr.shutdown();\n+\n+            int cnt = svr.connectionCount();\n+            MultiThreadTest.debug(\"Connections = \" + cnt);\n+            int reqs = Worker.getRequests();\n+            MultiThreadTest.debug(\"Requests = \" + reqs);\n+            System.out.println(\"Connection count = \" + cnt + \" Request count = \" + reqs);\n+\n+            \/\/ We may have received traffic from something else than\n+            \/\/ our client. We should only count those workers for which\n+            \/\/ the expected header has been found.\n+            int validConnections = 0;\n+            \/\/ We detect worker threads that may have timed out, so we don't include them in\n+            \/\/ the count to compare with the number of connections.\n+            int becameIdle = 0;\n+            for (Worker w : svr.workers()) {\n+                if (w.headerFound > 0) {\n+                    validConnections++;\n+                    if (w.mayHaveTimedOut(end)) {\n+                        debug(\"Worker \" + w.id + \" may have timed out\");\n+                        becameIdle++;\n+                    } else {\n+                        long at0 = at(w.lastReading);\n+                        long at1 = at(w.lastReplied);\n+                        debug(\"Worker \" + w.id +\" has not timed out - last used at \" +\n+                            Math.max(at0, at1));\n+                    }\n+                } else {\n+                    debug(\"Worker \" + w.id + \" is not a valid connection\");\n+                }\n+            }\n@@ -170,3 +214,15 @@\n-        if (validConnections > threads + 1 || validConnections == 0) { \/\/ could be less\n-            throw new RuntimeException (\"Expected \" + threads + \" connections: used \" + validConnections);\n-        }\n+            if (validConnections > threads) {\n+                if (SLEEP > KEEP_ALIVE) {\n+                    debug(\"INFO: \" + validConnections\n+                            + \" have been used, with \" + becameIdle\n+                            + \" becoming idle for more than \" + KEEP_ALIVE + \"s\"\n+                            + \" while using \" + threads\n+                            + \" threads to make concurrent connections\");\n+                } else {\n+                    debug(\"WARNING: \" + validConnections\n+                            + \" have been used, with \" + becameIdle\n+                            + \" becoming idle for more than \" + KEEP_ALIVE + \"s\"\n+                            + \" where only \" + threads\n+                            + \" connections and none idle were expected!\");\n+                }\n+            }\n@@ -174,10 +230,3 @@\n-        \/\/ Sometimes the client drops a connection after a while and\n-        \/\/ spawns a new one. Why this is happening is not clear,\n-        \/\/ and JDK-8223783 is logged to follow up on this. For the sake\n-        \/\/ of test stabilization we don't fail on `threads + 1` connections\n-        \/\/ but log a warning instead.\n-        if (validConnections == threads + 1) {\n-            debug(\"WARNING: \" + validConnections\n-                + \" have been used, where only \" + threads\n-                + \" were expected!\");\n-        }\n+            if (validConnections > threads + becameIdle || validConnections == 0) { \/\/ could be less\n+                throw new RuntimeException(\"Expected \" + (threads + becameIdle) + \" connections: used \" + validConnections);\n+            }\n@@ -185,6 +234,6 @@\n-        if (validConnections != cnt) {\n-            debug(\"WARNING: got \" + (cnt - validConnections) + \" unexpected connections!\");\n-        }\n-        if  (validConnections == cnt && reqs != threads*requests) {\n-            throw new RuntimeException (\"Expected \"+ threads*requests+ \" requests: got \" +reqs);\n-        }\n+            if (validConnections != cnt) {\n+                debug(\"INFO: got \" + (cnt - validConnections) + \" unexpected connections\");\n+            }\n+            if (reqs != threads * requests) {\n+                throw new RuntimeException(\"Expected \" + threads * requests + \" requests: got \" + reqs);\n+            }\n@@ -192,2 +241,10 @@\n-        for (Thread worker : svr.workers()) {\n-            worker.join(60_000);\n+        } finally {\n+            debug(\"waiting for worker to shutdown at \" + at() +\"ms\");\n+            for (Worker worker : svr.workers()) {\n+                \/\/ We want to verify that the client will eventually\n+                \/\/ close the idle connections. So just join the worker\n+                \/\/ and wait... This shouldn't take more than the granularity\n+                \/\/ of the keep-alive cache timer - so we're not actually\n+                \/\/ going to have to wait for one full minute here.\n+                worker.join(60_000);\n+            }\n@@ -196,1 +253,1 @@\n-        debug(\"main thread end - \" + Duration.ofNanos(System.nanoTime() - start));\n+        debug(\"main thread end - \" + at() + \"ms\");\n@@ -234,0 +291,4 @@\n+            try {\n+                ss.close();\n+            } catch (IOException x) {\n+            }\n@@ -238,1 +299,2 @@\n-                ss.setSoTimeout(2000);\n+                ss.setSoTimeout(6000);\n+                long startServer = System.nanoTime();\n@@ -242,0 +304,1 @@\n+                    long acceptTime;\n@@ -245,2 +308,4 @@\n-                        MultiThreadTest.debug(\"server: return accept.\");\n-                    } catch (SocketTimeoutException te) {\n+                        acceptTime = System.nanoTime();\n+                        MultiThreadTest.debug(\"server: return accept (at \" +\n+                                MultiThreadTest.at(acceptTime)+ \"ms)\");\n+                    } catch (IOException te) {\n@@ -250,1 +315,2 @@\n-                                MultiThreadTest.debug(\"server: Shuting down.\");\n+                                MultiThreadTest.debug(\"server: Shuting down at: \"\n+                                        + MultiThreadTest.at() + \"ms\");\n@@ -254,1 +320,3 @@\n-                        continue;\n+                        if (te instanceof SocketTimeoutException)\n+                            continue;\n+                        throw te;\n@@ -261,1 +329,1 @@\n-                        w = new Worker(s, id);\n+                        w = new Worker(s, id, acceptTime);\n@@ -283,5 +351,28 @@\n-        Socket s;\n-        int id;\n-        volatile boolean headerFound;\n-\n-        Worker(Socket s, int id) {\n+        final long TIMEOUT = MultiThreadTest.KEEP_ALIVE; \/\/ seconds\n+        final long KEEP_ALIVE_NS = Duration.ofSeconds(TIMEOUT).toNanos(); \/\/ nanos\n+        final Socket s;\n+        final int id;\n+\n+        \/\/ time at which the connection was accepted (nanos)\n+        final long acceptTime;\n+\n+        \/\/ number of requests that had the expected URI\n+        volatile int headerFound;\n+        \/\/ time at which the worker thread exited\n+        volatile long stopTime;\n+        \/\/ Time at which the first call to is.read() for the last request\n+        \/\/ returned. This includes cases where -1 was returned.\n+        volatile long startReading;\n+        \/\/ Lat time at which a byte was read from the stream.\n+        volatile long lastReading;\n+        \/\/ number of times that the time between two consecutive received requests\n+        \/\/ exceeded the KEEP_ALIVE timeout.\n+        volatile int timeoutExceeded;\n+        \/\/ Number of requests handled by this worker\n+        volatile int requestHandled;\n+        \/\/ Time at which the last byte of the last reply was sent\n+        volatile long lastReplied;\n+        \/\/ Whether the worker was asked to stop\n+        volatile boolean done;\n+\n+        Worker(Socket s, int id, long acceptTime) {\n@@ -291,0 +382,2 @@\n+            \/\/ no time can have a value before accepTime\n+            this.acceptTime = lastReading = lastReplied = startReading = acceptTime;\n@@ -308,0 +401,22 @@\n+        \/**\n+         * {@return Whether this worker might have been idle for more\n+         * than the KEEP_ALIVE timeout}\n+         * This will be true if the worker detected that the idle timeout\n+         * was exceeded between two consecutive request, or\n+         * if the time between the last reply and `nanosNow` exceeds\n+         * the keep-alive time.\n+         * @param nanosNow a timestamp in nano seconds\n+         *\/\n+        public boolean mayHaveTimedOut(long nanosNow) {\n+            \/\/ the minimum time elapsed between nanosNow and:\n+            \/\/  - the time the socket was accepted\n+            \/\/  - the last time a byte was received\n+            \/\/  - the last time a reply was sent.\n+            \/\/ We must not use `startReading` here because `startReading` may\n+            \/\/ be set if the client asynchronously closes the connection\n+            \/\/ after all requests have been sent. We should really only\n+            \/\/ take into account `lastReading` and `lastReplied`.\n+            long idle = Math.min(nanosNow - lastReading, nanosNow - lastReplied);\n+            return timeoutExceeded > 0 || idle >= KEEP_ALIVE_NS;\n+        }\n+\n@@ -310,0 +425,1 @@\n+            long last;\n@@ -312,0 +428,5 @@\n+                last = System.nanoTime();\n+                if (count == 0) {\n+                    \/\/ time at which the first byte of the request (or EOF) was received\n+                    startReading = last;\n+                }\n@@ -314,0 +435,2 @@\n+                \/\/ time at which the last byte of the request was received (excludes EOF)\n+                lastReading = last;\n@@ -330,0 +453,3 @@\n+            \/\/ lastUsed starts when the connection was accepted\n+            long lastUsed = acceptTime;\n+            int expectedReqs = 0;\n@@ -340,1 +466,0 @@\n-\n@@ -342,1 +467,1 @@\n-                    int n=0;\n+                    int n;\n@@ -345,0 +470,8 @@\n+                    long idle = startReading - lastUsed;\n+                    if (idle >= KEEP_ALIVE_NS) {\n+                        if (!MultiThreadTest.DONE.get()) {\n+                            \/\/ avoid increasing timeoutExceeded after the test is no\n+                            \/\/ longer sending requests.\n+                            timeoutExceeded++;\n+                        }\n+                    }\n@@ -346,1 +479,2 @@\n-                        MultiThreadTest.debug(\"worker: \" + id + \": Shutdown\");\n+                        MultiThreadTest.debug(\"worker: \" + id + \": Shutdown at \"\n+                                + MultiThreadTest.at() + \"ms\");\n@@ -351,1 +485,2 @@\n-                        headerFound = true;\n+                        headerFound = ++expectedReqs;\n+                        incRequests();\n@@ -354,0 +489,2 @@\n+                        s.close();\n+                        return;\n@@ -358,1 +495,1 @@\n-                        \"(\" + n + \" bytes).\");\n+                        \"(\" + n + \" bytes) at \" + MultiThreadTest.at() + \"ms\");\n@@ -360,1 +497,0 @@\n-                    incRequests();\n@@ -365,1 +501,1 @@\n-                    out.print(\"Keep-Alive: timeout=15, max=\"+max+\"\\r\\n\");\n+                    out.print(\"Keep-Alive: timeout=\" + TIMEOUT + \", max=\"+max+\"\\r\\n\");\n@@ -371,1 +507,2 @@\n-\n+                    requestHandled++;\n+                    lastUsed = lastReplied = System.nanoTime();\n@@ -381,0 +518,1 @@\n+                long end = stopTime = System.nanoTime();\n@@ -384,2 +522,8 @@\n-                MultiThreadTest.debug(\"worker: \" + id  + \" end - \" +\n-                            Duration.ofNanos(System.nanoTime() - start));\n+                MultiThreadTest.debug(\"worker: \" + id + \" end at \" +\n+                            MultiThreadTest.at() + \"ms,  elapsed since worker start: \" +\n+                            Duration.ofNanos(end - start).toMillis() + \"ms, elapsed since accept: \" +\n+                            Duration.ofNanos(end - acceptTime).toMillis() +\n+                            \"ms, timeout exceeded: \" + timeoutExceeded +\n+                            \", successfuly handled \" + requestHandled + \"\/\" +\n+                             expectedReqs + \" genuine requests, \" +\n+                            \", mayHaveTimedOut: \" + mayHaveTimedOut(end));\n@@ -388,0 +532,1 @@\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/MultiThreadTest.java","additions":232,"deletions":87,"binary":false,"changes":319,"status":"modified"}]}